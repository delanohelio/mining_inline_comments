{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzMDc3NDQz", "number": 10020, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxOTowNzo1MlrOEFKbdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNTo1OToxN1rOEFyr3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczODQ5MjA2OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/DataSource.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxOTowNzo1MlrOGjO2ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMjo0NDowMlrOGkZf_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU5NjcwMg==", "bodyText": "Should the global datasource type be added to the docs? https://druid.apache.org/docs/0.18.1/querying/query-execution.html#datasource-type", "url": "https://github.com/apache/druid/pull/10020#discussion_r439596702", "createdAt": "2020-06-12T19:07:52Z", "author": {"login": "ccaominh"}, "path": "processing/src/main/java/org/apache/druid/query/DataSource.java", "diffHunk": "@@ -35,7 +35,8 @@\n     @JsonSubTypes.Type(value = UnionDataSource.class, name = \"union\"),\n     @JsonSubTypes.Type(value = JoinDataSource.class, name = \"join\"),\n     @JsonSubTypes.Type(value = LookupDataSource.class, name = \"lookup\"),\n-    @JsonSubTypes.Type(value = InlineDataSource.class, name = \"inline\")\n+    @JsonSubTypes.Type(value = InlineDataSource.class, name = \"inline\"),\n+    @JsonSubTypes.Type(value = GlobalTableDataSource.class, name = \"global\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bda1c7f86a1f74b0868472f0dd9b1b10ec9c9ed1"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4OTUzNQ==", "bodyText": "I'm not sure if it makes sense to add yet until more of #9953 is implemented since making effective use of this requires GlobalTableDataSource to be bound to a JoinableFactory, otherwise it behaves the same as TableDataSource", "url": "https://github.com/apache/druid/pull/10020#discussion_r439689535", "createdAt": "2020-06-13T00:34:57Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/DataSource.java", "diffHunk": "@@ -35,7 +35,8 @@\n     @JsonSubTypes.Type(value = UnionDataSource.class, name = \"union\"),\n     @JsonSubTypes.Type(value = JoinDataSource.class, name = \"join\"),\n     @JsonSubTypes.Type(value = LookupDataSource.class, name = \"lookup\"),\n-    @JsonSubTypes.Type(value = InlineDataSource.class, name = \"inline\")\n+    @JsonSubTypes.Type(value = InlineDataSource.class, name = \"inline\"),\n+    @JsonSubTypes.Type(value = GlobalTableDataSource.class, name = \"global\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU5NjcwMg=="}, "originalCommit": {"oid": "bda1c7f86a1f74b0868472f0dd9b1b10ec9c9ed1"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5OTY0NA==", "bodyText": "I think globalTable would be a better name. We only have one chance to get it right!\nIMO for some consistency between SQL and native, we'll need to either transparently globalify the regular table type (perhaps a rewrite step like ClientQuerySegmentWalker's inlining?) or we'll need to document the globalTable type. I think the former is nicer, because the latter comes with too many caveats (you have to make sure to use it in the proper conditions).", "url": "https://github.com/apache/druid/pull/10020#discussion_r440599644", "createdAt": "2020-06-16T05:47:06Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/query/DataSource.java", "diffHunk": "@@ -35,7 +35,8 @@\n     @JsonSubTypes.Type(value = UnionDataSource.class, name = \"union\"),\n     @JsonSubTypes.Type(value = JoinDataSource.class, name = \"join\"),\n     @JsonSubTypes.Type(value = LookupDataSource.class, name = \"lookup\"),\n-    @JsonSubTypes.Type(value = InlineDataSource.class, name = \"inline\")\n+    @JsonSubTypes.Type(value = InlineDataSource.class, name = \"inline\"),\n+    @JsonSubTypes.Type(value = GlobalTableDataSource.class, name = \"global\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU5NjcwMg=="}, "originalCommit": {"oid": "bda1c7f86a1f74b0868472f0dd9b1b10ec9c9ed1"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwOTg1Ng==", "bodyText": "By the way, to be clear, I don't think we need to do (2) in this PR. That was more a suggestion for future work.", "url": "https://github.com/apache/druid/pull/10020#discussion_r440609856", "createdAt": "2020-06-16T06:17:51Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/query/DataSource.java", "diffHunk": "@@ -35,7 +35,8 @@\n     @JsonSubTypes.Type(value = UnionDataSource.class, name = \"union\"),\n     @JsonSubTypes.Type(value = JoinDataSource.class, name = \"join\"),\n     @JsonSubTypes.Type(value = LookupDataSource.class, name = \"lookup\"),\n-    @JsonSubTypes.Type(value = InlineDataSource.class, name = \"inline\")\n+    @JsonSubTypes.Type(value = InlineDataSource.class, name = \"inline\"),\n+    @JsonSubTypes.Type(value = GlobalTableDataSource.class, name = \"global\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU5NjcwMg=="}, "originalCommit": {"oid": "bda1c7f86a1f74b0868472f0dd9b1b10ec9c9ed1"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxOTcxMA==", "bodyText": "Renamed to globalTable. For 2 it sounds nice to be automatic since it negates the need to document this, so will add that behavior in a follow-up.", "url": "https://github.com/apache/druid/pull/10020#discussion_r440819710", "createdAt": "2020-06-16T12:44:02Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/DataSource.java", "diffHunk": "@@ -35,7 +35,8 @@\n     @JsonSubTypes.Type(value = UnionDataSource.class, name = \"union\"),\n     @JsonSubTypes.Type(value = JoinDataSource.class, name = \"join\"),\n     @JsonSubTypes.Type(value = LookupDataSource.class, name = \"lookup\"),\n-    @JsonSubTypes.Type(value = InlineDataSource.class, name = \"inline\")\n+    @JsonSubTypes.Type(value = InlineDataSource.class, name = \"inline\"),\n+    @JsonSubTypes.Type(value = GlobalTableDataSource.class, name = \"global\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU5NjcwMg=="}, "originalCommit": {"oid": "bda1c7f86a1f74b0868472f0dd9b1b10ec9c9ed1"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczODQ5NjM0OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/GlobalTableDataSource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxOTowOTozOFrOGjO5jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDozNToxMlrOGjUhzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU5NzQ1NA==", "bodyText": "What do you think about adding a javadoc explaining why this datasource type exists?", "url": "https://github.com/apache/druid/pull/10020#discussion_r439597454", "createdAt": "2020-06-12T19:09:38Z", "author": {"login": "ccaominh"}, "path": "processing/src/main/java/org/apache/druid/query/GlobalTableDataSource.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n+\n+@JsonTypeName(\"global\")\n+public class GlobalTableDataSource extends TableDataSource", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bda1c7f86a1f74b0868472f0dd9b1b10ec9c9ed1"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4OTY3OQ==", "bodyText": "Added javadoc \ud83d\udc4d", "url": "https://github.com/apache/druid/pull/10020#discussion_r439689679", "createdAt": "2020-06-13T00:35:12Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/GlobalTableDataSource.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n+\n+@JsonTypeName(\"global\")\n+public class GlobalTableDataSource extends TableDataSource", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU5NzQ1NA=="}, "originalCommit": {"oid": "bda1c7f86a1f74b0868472f0dd9b1b10ec9c9ed1"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczODUxNzk1OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxOToxODoyOFrOGjPHjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDozNjoxOVrOGjUkNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwMTAzNw==", "bodyText": "Why are all of the datasources broadcast?", "url": "https://github.com/apache/druid/pull/10020#discussion_r439601037", "createdAt": "2020-06-12T19:18:28Z", "author": {"login": "ccaominh"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "diffHunk": "@@ -196,119 +207,130 @@ public DruidSchema(\n   public void start() throws InterruptedException\n   {\n     cacheExec.submit(\n-        new Runnable()\n-        {\n-          @Override\n-          public void run()\n-          {\n-            try {\n-              while (!Thread.currentThread().isInterrupted()) {\n-                final Set<SegmentId> segmentsToRefresh = new TreeSet<>();\n-                final Set<String> dataSourcesToRebuild = new TreeSet<>();\n-\n-                try {\n-                  synchronized (lock) {\n-                    final long nextRefreshNoFuzz = DateTimes\n-                        .utc(lastRefresh)\n-                        .plus(config.getMetadataRefreshPeriod())\n-                        .getMillis();\n-\n-                    // Fuzz a bit to spread load out when we have multiple brokers.\n-                    final long nextRefresh = nextRefreshNoFuzz + (long) ((nextRefreshNoFuzz - lastRefresh) * 0.10);\n-\n-                    while (true) {\n-                      // Do not refresh if it's too soon after a failure (to avoid rapid cycles of failure).\n-                      final boolean wasRecentFailure = DateTimes.utc(lastFailure)\n-                                                                .plus(config.getMetadataRefreshPeriod())\n-                                                                .isAfterNow();\n-\n-                      if (isServerViewInitialized &&\n-                          !wasRecentFailure &&\n-                          (!segmentsNeedingRefresh.isEmpty() || !dataSourcesNeedingRebuild.isEmpty()) &&\n-                          (refreshImmediately || nextRefresh < System.currentTimeMillis())) {\n-                        // We need to do a refresh. Break out of the waiting loop.\n-                        break;\n-                      }\n-\n-                      if (isServerViewInitialized) {\n-                        // Server view is initialized, but we don't need to do a refresh. Could happen if there are\n-                        // no segments in the system yet. Just mark us as initialized, then.\n-                        initialized.countDown();\n-                      }\n-\n-                      // Wait some more, we'll wake up when it might be time to do another refresh.\n-                      lock.wait(Math.max(1, nextRefresh - System.currentTimeMillis()));\n+        () -> {\n+          try {\n+            while (!Thread.currentThread().isInterrupted()) {\n+              final Set<SegmentId> segmentsToRefresh = new TreeSet<>();\n+              final Set<String> dataSourcesToRebuild = new TreeSet<>();\n+\n+              try {\n+                synchronized (lock) {\n+                  final long nextRefreshNoFuzz = DateTimes\n+                      .utc(lastRefresh)\n+                      .plus(config.getMetadataRefreshPeriod())\n+                      .getMillis();\n+\n+                  // Fuzz a bit to spread load out when we have multiple brokers.\n+                  final long nextRefresh = nextRefreshNoFuzz + (long) ((nextRefreshNoFuzz - lastRefresh) * 0.10);\n+\n+                  while (true) {\n+                    // Do not refresh if it's too soon after a failure (to avoid rapid cycles of failure).\n+                    final boolean wasRecentFailure = DateTimes.utc(lastFailure)\n+                                                              .plus(config.getMetadataRefreshPeriod())\n+                                                              .isAfterNow();\n+\n+                    if (isServerViewInitialized &&\n+                        !wasRecentFailure &&\n+                        (!segmentsNeedingRefresh.isEmpty() || !dataSourcesNeedingRebuild.isEmpty()) &&\n+                        (refreshImmediately || nextRefresh < System.currentTimeMillis())) {\n+                      // We need to do a refresh. Break out of the waiting loop.\n+                      break;\n                     }\n \n-                    segmentsToRefresh.addAll(segmentsNeedingRefresh);\n-                    segmentsNeedingRefresh.clear();\n-\n-                    // Mutable segments need a refresh every period, since new columns could be added dynamically.\n-                    segmentsNeedingRefresh.addAll(mutableSegments);\n+                    if (isServerViewInitialized) {\n+                      // Server view is initialized, but we don't need to do a refresh. Could happen if there are\n+                      // no segments in the system yet. Just mark us as initialized, then.\n+                      initialized.countDown();\n+                    }\n \n-                    lastFailure = 0L;\n-                    lastRefresh = System.currentTimeMillis();\n-                    refreshImmediately = false;\n+                    // Wait some more, we'll wake up when it might be time to do another refresh.\n+                    lock.wait(Math.max(1, nextRefresh - System.currentTimeMillis()));\n                   }\n \n-                  // Refresh the segments.\n-                  final Set<SegmentId> refreshed = refreshSegments(segmentsToRefresh);\n+                  segmentsToRefresh.addAll(segmentsNeedingRefresh);\n+                  segmentsNeedingRefresh.clear();\n \n-                  synchronized (lock) {\n-                    // Add missing segments back to the refresh list.\n-                    segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n+                  // Mutable segments need a refresh every period, since new columns could be added dynamically.\n+                  segmentsNeedingRefresh.addAll(mutableSegments);\n \n-                    // Compute the list of dataSources to rebuild tables for.\n-                    dataSourcesToRebuild.addAll(dataSourcesNeedingRebuild);\n-                    refreshed.forEach(segment -> dataSourcesToRebuild.add(segment.getDataSource()));\n-                    dataSourcesNeedingRebuild.clear();\n+                  lastFailure = 0L;\n+                  lastRefresh = System.currentTimeMillis();\n+                  refreshImmediately = false;\n+                }\n \n-                    lock.notifyAll();\n-                  }\n+                // Refresh the segments.\n+                final Set<SegmentId> refreshed = refreshSegments(segmentsToRefresh);\n \n-                  // Rebuild the dataSources.\n-                  for (String dataSource : dataSourcesToRebuild) {\n-                    final DruidTable druidTable = buildDruidTable(dataSource);\n-                    final DruidTable oldTable = tables.put(dataSource, druidTable);\n-                    if (oldTable == null || !oldTable.getRowSignature().equals(druidTable.getRowSignature())) {\n-                      log.info(\"dataSource [%s] has new signature: %s.\", dataSource, druidTable.getRowSignature());\n-                    } else {\n-                      log.debug(\"dataSource [%s] signature is unchanged.\", dataSource);\n-                    }\n-                  }\n+                synchronized (lock) {\n+                  // Add missing segments back to the refresh list.\n+                  segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n \n-                  initialized.countDown();\n-                }\n-                catch (InterruptedException e) {\n-                  // Fall through.\n-                  throw e;\n+                  // Compute the list of dataSources to rebuild tables for.\n+                  dataSourcesToRebuild.addAll(dataSourcesNeedingRebuild);\n+                  refreshed.forEach(segment -> dataSourcesToRebuild.add(segment.getDataSource()));\n+                  dataSourcesNeedingRebuild.clear();\n+\n+                  lock.notifyAll();\n                 }\n-                catch (Exception e) {\n-                  log.warn(e, \"Metadata refresh failed, trying again soon.\");\n-\n-                  synchronized (lock) {\n-                    // Add our segments and dataSources back to their refresh and rebuild lists.\n-                    segmentsNeedingRefresh.addAll(segmentsToRefresh);\n-                    dataSourcesNeedingRebuild.addAll(dataSourcesToRebuild);\n-                    lastFailure = System.currentTimeMillis();\n-                    lock.notifyAll();\n+\n+                // Rebuild the dataSources.\n+                for (String dataSource : dataSourcesToRebuild) {\n+                  final DruidTable druidTable = buildDruidTable(dataSource);\n+                  final DruidTable oldTable = tables.put(dataSource, druidTable);\n+                  if (oldTable == null || !oldTable.getRowSignature().equals(druidTable.getRowSignature())) {\n+                    log.info(\"dataSource [%s] has new signature: %s.\", dataSource, druidTable.getRowSignature());\n+                  } else {\n+                    log.debug(\"dataSource [%s] signature is unchanged.\", dataSource);\n                   }\n                 }\n+\n+                initialized.countDown();\n+              }\n+              catch (InterruptedException e) {\n+                // Fall through.\n+                throw e;\n+              }\n+              catch (Exception e) {\n+                log.warn(e, \"Metadata refresh failed, trying again soon.\");\n+\n+                synchronized (lock) {\n+                  // Add our segments and dataSources back to their refresh and rebuild lists.\n+                  segmentsNeedingRefresh.addAll(segmentsToRefresh);\n+                  dataSourcesNeedingRebuild.addAll(dataSourcesToRebuild);\n+                  lastFailure = System.currentTimeMillis();\n+                  lock.notifyAll();\n+                }\n               }\n-            }\n-            catch (InterruptedException e) {\n-              // Just exit.\n-            }\n-            catch (Throwable e) {\n-              // Throwables that fall out to here (not caught by an inner try/catch) are potentially gnarly, like\n-              // OOMEs. Anyway, let's just emit an alert and stop refreshing metadata.\n-              log.makeAlert(e, \"Metadata refresh failed permanently\").emit();\n-              throw e;\n-            }\n-            finally {\n-              log.info(\"Metadata refresh stopped.\");\n             }\n           }\n+          catch (InterruptedException e) {\n+            // Just exit.\n+          }\n+          catch (Throwable e) {\n+            // Throwables that fall out to here (not caught by an inner try/catch) are potentially gnarly, like\n+            // OOMEs. Anyway, let's just emit an alert and stop refreshing metadata.\n+            log.makeAlert(e, \"Metadata refresh failed permanently\").emit();\n+            throw e;\n+          }\n+          finally {\n+            log.info(\"Metadata refresh stopped.\");\n+          }\n+        }\n+    );\n+\n+    ScheduledExecutors.scheduleWithFixedDelay(\n+        localSegmentExec,\n+        config.getMetadataRefreshPeriod().toStandardDuration(),\n+        config.getMetadataRefreshPeriod().toStandardDuration(),\n+        () -> {\n+          synchronized (lock) {\n+            // refresh known broadcast segments\n+            Set<String> localSegmentDatasources = segmentManager.getDataSourceNames();\n+            dataSourcesNeedingRebuild.addAll(localSegmentDatasources);\n+            broadcastDatasources.clear();\n+            broadcastDatasources.addAll(localSegmentDatasources);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bda1c7f86a1f74b0868472f0dd9b1b10ec9c9ed1"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5MDI5Mg==", "bodyText": "added a comment to clarify that since this code only runs on the broker, and the broker can only have broadcast segments, that it's a safe assumption. If we ever load brokers load normal segments we might need to reconsider how this works, and it might be more appropriate longer term to use the load rules instead of inferring from context, but it should be ok for now I think", "url": "https://github.com/apache/druid/pull/10020#discussion_r439690292", "createdAt": "2020-06-13T00:36:19Z", "author": {"login": "clintropolis"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "diffHunk": "@@ -196,119 +207,130 @@ public DruidSchema(\n   public void start() throws InterruptedException\n   {\n     cacheExec.submit(\n-        new Runnable()\n-        {\n-          @Override\n-          public void run()\n-          {\n-            try {\n-              while (!Thread.currentThread().isInterrupted()) {\n-                final Set<SegmentId> segmentsToRefresh = new TreeSet<>();\n-                final Set<String> dataSourcesToRebuild = new TreeSet<>();\n-\n-                try {\n-                  synchronized (lock) {\n-                    final long nextRefreshNoFuzz = DateTimes\n-                        .utc(lastRefresh)\n-                        .plus(config.getMetadataRefreshPeriod())\n-                        .getMillis();\n-\n-                    // Fuzz a bit to spread load out when we have multiple brokers.\n-                    final long nextRefresh = nextRefreshNoFuzz + (long) ((nextRefreshNoFuzz - lastRefresh) * 0.10);\n-\n-                    while (true) {\n-                      // Do not refresh if it's too soon after a failure (to avoid rapid cycles of failure).\n-                      final boolean wasRecentFailure = DateTimes.utc(lastFailure)\n-                                                                .plus(config.getMetadataRefreshPeriod())\n-                                                                .isAfterNow();\n-\n-                      if (isServerViewInitialized &&\n-                          !wasRecentFailure &&\n-                          (!segmentsNeedingRefresh.isEmpty() || !dataSourcesNeedingRebuild.isEmpty()) &&\n-                          (refreshImmediately || nextRefresh < System.currentTimeMillis())) {\n-                        // We need to do a refresh. Break out of the waiting loop.\n-                        break;\n-                      }\n-\n-                      if (isServerViewInitialized) {\n-                        // Server view is initialized, but we don't need to do a refresh. Could happen if there are\n-                        // no segments in the system yet. Just mark us as initialized, then.\n-                        initialized.countDown();\n-                      }\n-\n-                      // Wait some more, we'll wake up when it might be time to do another refresh.\n-                      lock.wait(Math.max(1, nextRefresh - System.currentTimeMillis()));\n+        () -> {\n+          try {\n+            while (!Thread.currentThread().isInterrupted()) {\n+              final Set<SegmentId> segmentsToRefresh = new TreeSet<>();\n+              final Set<String> dataSourcesToRebuild = new TreeSet<>();\n+\n+              try {\n+                synchronized (lock) {\n+                  final long nextRefreshNoFuzz = DateTimes\n+                      .utc(lastRefresh)\n+                      .plus(config.getMetadataRefreshPeriod())\n+                      .getMillis();\n+\n+                  // Fuzz a bit to spread load out when we have multiple brokers.\n+                  final long nextRefresh = nextRefreshNoFuzz + (long) ((nextRefreshNoFuzz - lastRefresh) * 0.10);\n+\n+                  while (true) {\n+                    // Do not refresh if it's too soon after a failure (to avoid rapid cycles of failure).\n+                    final boolean wasRecentFailure = DateTimes.utc(lastFailure)\n+                                                              .plus(config.getMetadataRefreshPeriod())\n+                                                              .isAfterNow();\n+\n+                    if (isServerViewInitialized &&\n+                        !wasRecentFailure &&\n+                        (!segmentsNeedingRefresh.isEmpty() || !dataSourcesNeedingRebuild.isEmpty()) &&\n+                        (refreshImmediately || nextRefresh < System.currentTimeMillis())) {\n+                      // We need to do a refresh. Break out of the waiting loop.\n+                      break;\n                     }\n \n-                    segmentsToRefresh.addAll(segmentsNeedingRefresh);\n-                    segmentsNeedingRefresh.clear();\n-\n-                    // Mutable segments need a refresh every period, since new columns could be added dynamically.\n-                    segmentsNeedingRefresh.addAll(mutableSegments);\n+                    if (isServerViewInitialized) {\n+                      // Server view is initialized, but we don't need to do a refresh. Could happen if there are\n+                      // no segments in the system yet. Just mark us as initialized, then.\n+                      initialized.countDown();\n+                    }\n \n-                    lastFailure = 0L;\n-                    lastRefresh = System.currentTimeMillis();\n-                    refreshImmediately = false;\n+                    // Wait some more, we'll wake up when it might be time to do another refresh.\n+                    lock.wait(Math.max(1, nextRefresh - System.currentTimeMillis()));\n                   }\n \n-                  // Refresh the segments.\n-                  final Set<SegmentId> refreshed = refreshSegments(segmentsToRefresh);\n+                  segmentsToRefresh.addAll(segmentsNeedingRefresh);\n+                  segmentsNeedingRefresh.clear();\n \n-                  synchronized (lock) {\n-                    // Add missing segments back to the refresh list.\n-                    segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n+                  // Mutable segments need a refresh every period, since new columns could be added dynamically.\n+                  segmentsNeedingRefresh.addAll(mutableSegments);\n \n-                    // Compute the list of dataSources to rebuild tables for.\n-                    dataSourcesToRebuild.addAll(dataSourcesNeedingRebuild);\n-                    refreshed.forEach(segment -> dataSourcesToRebuild.add(segment.getDataSource()));\n-                    dataSourcesNeedingRebuild.clear();\n+                  lastFailure = 0L;\n+                  lastRefresh = System.currentTimeMillis();\n+                  refreshImmediately = false;\n+                }\n \n-                    lock.notifyAll();\n-                  }\n+                // Refresh the segments.\n+                final Set<SegmentId> refreshed = refreshSegments(segmentsToRefresh);\n \n-                  // Rebuild the dataSources.\n-                  for (String dataSource : dataSourcesToRebuild) {\n-                    final DruidTable druidTable = buildDruidTable(dataSource);\n-                    final DruidTable oldTable = tables.put(dataSource, druidTable);\n-                    if (oldTable == null || !oldTable.getRowSignature().equals(druidTable.getRowSignature())) {\n-                      log.info(\"dataSource [%s] has new signature: %s.\", dataSource, druidTable.getRowSignature());\n-                    } else {\n-                      log.debug(\"dataSource [%s] signature is unchanged.\", dataSource);\n-                    }\n-                  }\n+                synchronized (lock) {\n+                  // Add missing segments back to the refresh list.\n+                  segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n \n-                  initialized.countDown();\n-                }\n-                catch (InterruptedException e) {\n-                  // Fall through.\n-                  throw e;\n+                  // Compute the list of dataSources to rebuild tables for.\n+                  dataSourcesToRebuild.addAll(dataSourcesNeedingRebuild);\n+                  refreshed.forEach(segment -> dataSourcesToRebuild.add(segment.getDataSource()));\n+                  dataSourcesNeedingRebuild.clear();\n+\n+                  lock.notifyAll();\n                 }\n-                catch (Exception e) {\n-                  log.warn(e, \"Metadata refresh failed, trying again soon.\");\n-\n-                  synchronized (lock) {\n-                    // Add our segments and dataSources back to their refresh and rebuild lists.\n-                    segmentsNeedingRefresh.addAll(segmentsToRefresh);\n-                    dataSourcesNeedingRebuild.addAll(dataSourcesToRebuild);\n-                    lastFailure = System.currentTimeMillis();\n-                    lock.notifyAll();\n+\n+                // Rebuild the dataSources.\n+                for (String dataSource : dataSourcesToRebuild) {\n+                  final DruidTable druidTable = buildDruidTable(dataSource);\n+                  final DruidTable oldTable = tables.put(dataSource, druidTable);\n+                  if (oldTable == null || !oldTable.getRowSignature().equals(druidTable.getRowSignature())) {\n+                    log.info(\"dataSource [%s] has new signature: %s.\", dataSource, druidTable.getRowSignature());\n+                  } else {\n+                    log.debug(\"dataSource [%s] signature is unchanged.\", dataSource);\n                   }\n                 }\n+\n+                initialized.countDown();\n+              }\n+              catch (InterruptedException e) {\n+                // Fall through.\n+                throw e;\n+              }\n+              catch (Exception e) {\n+                log.warn(e, \"Metadata refresh failed, trying again soon.\");\n+\n+                synchronized (lock) {\n+                  // Add our segments and dataSources back to their refresh and rebuild lists.\n+                  segmentsNeedingRefresh.addAll(segmentsToRefresh);\n+                  dataSourcesNeedingRebuild.addAll(dataSourcesToRebuild);\n+                  lastFailure = System.currentTimeMillis();\n+                  lock.notifyAll();\n+                }\n               }\n-            }\n-            catch (InterruptedException e) {\n-              // Just exit.\n-            }\n-            catch (Throwable e) {\n-              // Throwables that fall out to here (not caught by an inner try/catch) are potentially gnarly, like\n-              // OOMEs. Anyway, let's just emit an alert and stop refreshing metadata.\n-              log.makeAlert(e, \"Metadata refresh failed permanently\").emit();\n-              throw e;\n-            }\n-            finally {\n-              log.info(\"Metadata refresh stopped.\");\n             }\n           }\n+          catch (InterruptedException e) {\n+            // Just exit.\n+          }\n+          catch (Throwable e) {\n+            // Throwables that fall out to here (not caught by an inner try/catch) are potentially gnarly, like\n+            // OOMEs. Anyway, let's just emit an alert and stop refreshing metadata.\n+            log.makeAlert(e, \"Metadata refresh failed permanently\").emit();\n+            throw e;\n+          }\n+          finally {\n+            log.info(\"Metadata refresh stopped.\");\n+          }\n+        }\n+    );\n+\n+    ScheduledExecutors.scheduleWithFixedDelay(\n+        localSegmentExec,\n+        config.getMetadataRefreshPeriod().toStandardDuration(),\n+        config.getMetadataRefreshPeriod().toStandardDuration(),\n+        () -> {\n+          synchronized (lock) {\n+            // refresh known broadcast segments\n+            Set<String> localSegmentDatasources = segmentManager.getDataSourceNames();\n+            dataSourcesNeedingRebuild.addAll(localSegmentDatasources);\n+            broadcastDatasources.clear();\n+            broadcastDatasources.addAll(localSegmentDatasources);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwMTAzNw=="}, "originalCommit": {"oid": "bda1c7f86a1f74b0868472f0dd9b1b10ec9c9ed1"}, "originalPosition": 293}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczODU0MzA2OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/TableDataSource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxOToyODoyN1rOGjPXVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxOToyODoyN1rOGjPXVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwNTA3OA==", "bodyText": "This change is causing SegmentMetadataQueryTest.testSerde() to fail: https://travis-ci.org/github/apache/druid/jobs/697612764#L5001\nThe query variable has a LegacyDataSource whereas the deserialized serialized version has a TableDataSource.", "url": "https://github.com/apache/druid/pull/10020#discussion_r439605078", "createdAt": "2020-06-12T19:28:27Z", "author": {"login": "ccaominh"}, "path": "processing/src/main/java/org/apache/druid/query/TableDataSource.java", "diffHunk": "@@ -98,7 +98,7 @@ public final boolean equals(Object o)\n     if (this == o) {\n       return true;\n     }\n-    if (!(o instanceof TableDataSource)) {\n+    if (!(o instanceof TableDataSource) || !getClass().equals(o.getClass())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bda1c7f86a1f74b0868472f0dd9b1b10ec9c9ed1"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTA1NzIzOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNTo0MzoxNlrOGkMAJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMjo0MjoyOFrOGkZcFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5ODU2Nw==", "bodyText": "localSegmentDataSources would be more consistent spelling, I think.", "url": "https://github.com/apache/druid/pull/10020#discussion_r440598567", "createdAt": "2020-06-16T05:43:16Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "diffHunk": "@@ -196,119 +207,132 @@ public DruidSchema(\n   public void start() throws InterruptedException\n   {\n     cacheExec.submit(\n-        new Runnable()\n-        {\n-          @Override\n-          public void run()\n-          {\n-            try {\n-              while (!Thread.currentThread().isInterrupted()) {\n-                final Set<SegmentId> segmentsToRefresh = new TreeSet<>();\n-                final Set<String> dataSourcesToRebuild = new TreeSet<>();\n-\n-                try {\n-                  synchronized (lock) {\n-                    final long nextRefreshNoFuzz = DateTimes\n-                        .utc(lastRefresh)\n-                        .plus(config.getMetadataRefreshPeriod())\n-                        .getMillis();\n-\n-                    // Fuzz a bit to spread load out when we have multiple brokers.\n-                    final long nextRefresh = nextRefreshNoFuzz + (long) ((nextRefreshNoFuzz - lastRefresh) * 0.10);\n-\n-                    while (true) {\n-                      // Do not refresh if it's too soon after a failure (to avoid rapid cycles of failure).\n-                      final boolean wasRecentFailure = DateTimes.utc(lastFailure)\n-                                                                .plus(config.getMetadataRefreshPeriod())\n-                                                                .isAfterNow();\n-\n-                      if (isServerViewInitialized &&\n-                          !wasRecentFailure &&\n-                          (!segmentsNeedingRefresh.isEmpty() || !dataSourcesNeedingRebuild.isEmpty()) &&\n-                          (refreshImmediately || nextRefresh < System.currentTimeMillis())) {\n-                        // We need to do a refresh. Break out of the waiting loop.\n-                        break;\n-                      }\n-\n-                      if (isServerViewInitialized) {\n-                        // Server view is initialized, but we don't need to do a refresh. Could happen if there are\n-                        // no segments in the system yet. Just mark us as initialized, then.\n-                        initialized.countDown();\n-                      }\n-\n-                      // Wait some more, we'll wake up when it might be time to do another refresh.\n-                      lock.wait(Math.max(1, nextRefresh - System.currentTimeMillis()));\n+        () -> {\n+          try {\n+            while (!Thread.currentThread().isInterrupted()) {\n+              final Set<SegmentId> segmentsToRefresh = new TreeSet<>();\n+              final Set<String> dataSourcesToRebuild = new TreeSet<>();\n+\n+              try {\n+                synchronized (lock) {\n+                  final long nextRefreshNoFuzz = DateTimes\n+                      .utc(lastRefresh)\n+                      .plus(config.getMetadataRefreshPeriod())\n+                      .getMillis();\n+\n+                  // Fuzz a bit to spread load out when we have multiple brokers.\n+                  final long nextRefresh = nextRefreshNoFuzz + (long) ((nextRefreshNoFuzz - lastRefresh) * 0.10);\n+\n+                  while (true) {\n+                    // Do not refresh if it's too soon after a failure (to avoid rapid cycles of failure).\n+                    final boolean wasRecentFailure = DateTimes.utc(lastFailure)\n+                                                              .plus(config.getMetadataRefreshPeriod())\n+                                                              .isAfterNow();\n+\n+                    if (isServerViewInitialized &&\n+                        !wasRecentFailure &&\n+                        (!segmentsNeedingRefresh.isEmpty() || !dataSourcesNeedingRebuild.isEmpty()) &&\n+                        (refreshImmediately || nextRefresh < System.currentTimeMillis())) {\n+                      // We need to do a refresh. Break out of the waiting loop.\n+                      break;\n                     }\n \n-                    segmentsToRefresh.addAll(segmentsNeedingRefresh);\n-                    segmentsNeedingRefresh.clear();\n-\n-                    // Mutable segments need a refresh every period, since new columns could be added dynamically.\n-                    segmentsNeedingRefresh.addAll(mutableSegments);\n+                    if (isServerViewInitialized) {\n+                      // Server view is initialized, but we don't need to do a refresh. Could happen if there are\n+                      // no segments in the system yet. Just mark us as initialized, then.\n+                      initialized.countDown();\n+                    }\n \n-                    lastFailure = 0L;\n-                    lastRefresh = System.currentTimeMillis();\n-                    refreshImmediately = false;\n+                    // Wait some more, we'll wake up when it might be time to do another refresh.\n+                    lock.wait(Math.max(1, nextRefresh - System.currentTimeMillis()));\n                   }\n \n-                  // Refresh the segments.\n-                  final Set<SegmentId> refreshed = refreshSegments(segmentsToRefresh);\n+                  segmentsToRefresh.addAll(segmentsNeedingRefresh);\n+                  segmentsNeedingRefresh.clear();\n \n-                  synchronized (lock) {\n-                    // Add missing segments back to the refresh list.\n-                    segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n+                  // Mutable segments need a refresh every period, since new columns could be added dynamically.\n+                  segmentsNeedingRefresh.addAll(mutableSegments);\n \n-                    // Compute the list of dataSources to rebuild tables for.\n-                    dataSourcesToRebuild.addAll(dataSourcesNeedingRebuild);\n-                    refreshed.forEach(segment -> dataSourcesToRebuild.add(segment.getDataSource()));\n-                    dataSourcesNeedingRebuild.clear();\n+                  lastFailure = 0L;\n+                  lastRefresh = System.currentTimeMillis();\n+                  refreshImmediately = false;\n+                }\n \n-                    lock.notifyAll();\n-                  }\n+                // Refresh the segments.\n+                final Set<SegmentId> refreshed = refreshSegments(segmentsToRefresh);\n \n-                  // Rebuild the dataSources.\n-                  for (String dataSource : dataSourcesToRebuild) {\n-                    final DruidTable druidTable = buildDruidTable(dataSource);\n-                    final DruidTable oldTable = tables.put(dataSource, druidTable);\n-                    if (oldTable == null || !oldTable.getRowSignature().equals(druidTable.getRowSignature())) {\n-                      log.info(\"dataSource [%s] has new signature: %s.\", dataSource, druidTable.getRowSignature());\n-                    } else {\n-                      log.debug(\"dataSource [%s] signature is unchanged.\", dataSource);\n-                    }\n-                  }\n+                synchronized (lock) {\n+                  // Add missing segments back to the refresh list.\n+                  segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n \n-                  initialized.countDown();\n-                }\n-                catch (InterruptedException e) {\n-                  // Fall through.\n-                  throw e;\n+                  // Compute the list of dataSources to rebuild tables for.\n+                  dataSourcesToRebuild.addAll(dataSourcesNeedingRebuild);\n+                  refreshed.forEach(segment -> dataSourcesToRebuild.add(segment.getDataSource()));\n+                  dataSourcesNeedingRebuild.clear();\n+\n+                  lock.notifyAll();\n                 }\n-                catch (Exception e) {\n-                  log.warn(e, \"Metadata refresh failed, trying again soon.\");\n-\n-                  synchronized (lock) {\n-                    // Add our segments and dataSources back to their refresh and rebuild lists.\n-                    segmentsNeedingRefresh.addAll(segmentsToRefresh);\n-                    dataSourcesNeedingRebuild.addAll(dataSourcesToRebuild);\n-                    lastFailure = System.currentTimeMillis();\n-                    lock.notifyAll();\n+\n+                // Rebuild the dataSources.\n+                for (String dataSource : dataSourcesToRebuild) {\n+                  final DruidTable druidTable = buildDruidTable(dataSource);\n+                  final DruidTable oldTable = tables.put(dataSource, druidTable);\n+                  if (oldTable == null || !oldTable.getRowSignature().equals(druidTable.getRowSignature())) {\n+                    log.info(\"dataSource [%s] has new signature: %s.\", dataSource, druidTable.getRowSignature());\n+                  } else {\n+                    log.debug(\"dataSource [%s] signature is unchanged.\", dataSource);\n                   }\n                 }\n+\n+                initialized.countDown();\n+              }\n+              catch (InterruptedException e) {\n+                // Fall through.\n+                throw e;\n+              }\n+              catch (Exception e) {\n+                log.warn(e, \"Metadata refresh failed, trying again soon.\");\n+\n+                synchronized (lock) {\n+                  // Add our segments and dataSources back to their refresh and rebuild lists.\n+                  segmentsNeedingRefresh.addAll(segmentsToRefresh);\n+                  dataSourcesNeedingRebuild.addAll(dataSourcesToRebuild);\n+                  lastFailure = System.currentTimeMillis();\n+                  lock.notifyAll();\n+                }\n               }\n-            }\n-            catch (InterruptedException e) {\n-              // Just exit.\n-            }\n-            catch (Throwable e) {\n-              // Throwables that fall out to here (not caught by an inner try/catch) are potentially gnarly, like\n-              // OOMEs. Anyway, let's just emit an alert and stop refreshing metadata.\n-              log.makeAlert(e, \"Metadata refresh failed permanently\").emit();\n-              throw e;\n-            }\n-            finally {\n-              log.info(\"Metadata refresh stopped.\");\n             }\n           }\n+          catch (InterruptedException e) {\n+            // Just exit.\n+          }\n+          catch (Throwable e) {\n+            // Throwables that fall out to here (not caught by an inner try/catch) are potentially gnarly, like\n+            // OOMEs. Anyway, let's just emit an alert and stop refreshing metadata.\n+            log.makeAlert(e, \"Metadata refresh failed permanently\").emit();\n+            throw e;\n+          }\n+          finally {\n+            log.info(\"Metadata refresh stopped.\");\n+          }\n+        }\n+    );\n+\n+    ScheduledExecutors.scheduleWithFixedDelay(\n+        localSegmentExec,\n+        config.getMetadataRefreshPeriod().toStandardDuration(),\n+        config.getMetadataRefreshPeriod().toStandardDuration(),\n+        () -> {\n+          synchronized (lock) {\n+            // refresh known broadcast segments. Since DruidSchema is only present on the broker, any segment we have\n+            // locally in the SegmentManager must be broadcast datasources. This could potentially be replaced in the\n+            // future by fetching load rules from the coordinator\n+            Set<String> localSegmentDatasources = segmentManager.getDataSourceNames();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxODcxMA==", "bodyText": "this logic has been removed", "url": "https://github.com/apache/druid/pull/10020#discussion_r440818710", "createdAt": "2020-06-16T12:42:28Z", "author": {"login": "clintropolis"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "diffHunk": "@@ -196,119 +207,132 @@ public DruidSchema(\n   public void start() throws InterruptedException\n   {\n     cacheExec.submit(\n-        new Runnable()\n-        {\n-          @Override\n-          public void run()\n-          {\n-            try {\n-              while (!Thread.currentThread().isInterrupted()) {\n-                final Set<SegmentId> segmentsToRefresh = new TreeSet<>();\n-                final Set<String> dataSourcesToRebuild = new TreeSet<>();\n-\n-                try {\n-                  synchronized (lock) {\n-                    final long nextRefreshNoFuzz = DateTimes\n-                        .utc(lastRefresh)\n-                        .plus(config.getMetadataRefreshPeriod())\n-                        .getMillis();\n-\n-                    // Fuzz a bit to spread load out when we have multiple brokers.\n-                    final long nextRefresh = nextRefreshNoFuzz + (long) ((nextRefreshNoFuzz - lastRefresh) * 0.10);\n-\n-                    while (true) {\n-                      // Do not refresh if it's too soon after a failure (to avoid rapid cycles of failure).\n-                      final boolean wasRecentFailure = DateTimes.utc(lastFailure)\n-                                                                .plus(config.getMetadataRefreshPeriod())\n-                                                                .isAfterNow();\n-\n-                      if (isServerViewInitialized &&\n-                          !wasRecentFailure &&\n-                          (!segmentsNeedingRefresh.isEmpty() || !dataSourcesNeedingRebuild.isEmpty()) &&\n-                          (refreshImmediately || nextRefresh < System.currentTimeMillis())) {\n-                        // We need to do a refresh. Break out of the waiting loop.\n-                        break;\n-                      }\n-\n-                      if (isServerViewInitialized) {\n-                        // Server view is initialized, but we don't need to do a refresh. Could happen if there are\n-                        // no segments in the system yet. Just mark us as initialized, then.\n-                        initialized.countDown();\n-                      }\n-\n-                      // Wait some more, we'll wake up when it might be time to do another refresh.\n-                      lock.wait(Math.max(1, nextRefresh - System.currentTimeMillis()));\n+        () -> {\n+          try {\n+            while (!Thread.currentThread().isInterrupted()) {\n+              final Set<SegmentId> segmentsToRefresh = new TreeSet<>();\n+              final Set<String> dataSourcesToRebuild = new TreeSet<>();\n+\n+              try {\n+                synchronized (lock) {\n+                  final long nextRefreshNoFuzz = DateTimes\n+                      .utc(lastRefresh)\n+                      .plus(config.getMetadataRefreshPeriod())\n+                      .getMillis();\n+\n+                  // Fuzz a bit to spread load out when we have multiple brokers.\n+                  final long nextRefresh = nextRefreshNoFuzz + (long) ((nextRefreshNoFuzz - lastRefresh) * 0.10);\n+\n+                  while (true) {\n+                    // Do not refresh if it's too soon after a failure (to avoid rapid cycles of failure).\n+                    final boolean wasRecentFailure = DateTimes.utc(lastFailure)\n+                                                              .plus(config.getMetadataRefreshPeriod())\n+                                                              .isAfterNow();\n+\n+                    if (isServerViewInitialized &&\n+                        !wasRecentFailure &&\n+                        (!segmentsNeedingRefresh.isEmpty() || !dataSourcesNeedingRebuild.isEmpty()) &&\n+                        (refreshImmediately || nextRefresh < System.currentTimeMillis())) {\n+                      // We need to do a refresh. Break out of the waiting loop.\n+                      break;\n                     }\n \n-                    segmentsToRefresh.addAll(segmentsNeedingRefresh);\n-                    segmentsNeedingRefresh.clear();\n-\n-                    // Mutable segments need a refresh every period, since new columns could be added dynamically.\n-                    segmentsNeedingRefresh.addAll(mutableSegments);\n+                    if (isServerViewInitialized) {\n+                      // Server view is initialized, but we don't need to do a refresh. Could happen if there are\n+                      // no segments in the system yet. Just mark us as initialized, then.\n+                      initialized.countDown();\n+                    }\n \n-                    lastFailure = 0L;\n-                    lastRefresh = System.currentTimeMillis();\n-                    refreshImmediately = false;\n+                    // Wait some more, we'll wake up when it might be time to do another refresh.\n+                    lock.wait(Math.max(1, nextRefresh - System.currentTimeMillis()));\n                   }\n \n-                  // Refresh the segments.\n-                  final Set<SegmentId> refreshed = refreshSegments(segmentsToRefresh);\n+                  segmentsToRefresh.addAll(segmentsNeedingRefresh);\n+                  segmentsNeedingRefresh.clear();\n \n-                  synchronized (lock) {\n-                    // Add missing segments back to the refresh list.\n-                    segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n+                  // Mutable segments need a refresh every period, since new columns could be added dynamically.\n+                  segmentsNeedingRefresh.addAll(mutableSegments);\n \n-                    // Compute the list of dataSources to rebuild tables for.\n-                    dataSourcesToRebuild.addAll(dataSourcesNeedingRebuild);\n-                    refreshed.forEach(segment -> dataSourcesToRebuild.add(segment.getDataSource()));\n-                    dataSourcesNeedingRebuild.clear();\n+                  lastFailure = 0L;\n+                  lastRefresh = System.currentTimeMillis();\n+                  refreshImmediately = false;\n+                }\n \n-                    lock.notifyAll();\n-                  }\n+                // Refresh the segments.\n+                final Set<SegmentId> refreshed = refreshSegments(segmentsToRefresh);\n \n-                  // Rebuild the dataSources.\n-                  for (String dataSource : dataSourcesToRebuild) {\n-                    final DruidTable druidTable = buildDruidTable(dataSource);\n-                    final DruidTable oldTable = tables.put(dataSource, druidTable);\n-                    if (oldTable == null || !oldTable.getRowSignature().equals(druidTable.getRowSignature())) {\n-                      log.info(\"dataSource [%s] has new signature: %s.\", dataSource, druidTable.getRowSignature());\n-                    } else {\n-                      log.debug(\"dataSource [%s] signature is unchanged.\", dataSource);\n-                    }\n-                  }\n+                synchronized (lock) {\n+                  // Add missing segments back to the refresh list.\n+                  segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n \n-                  initialized.countDown();\n-                }\n-                catch (InterruptedException e) {\n-                  // Fall through.\n-                  throw e;\n+                  // Compute the list of dataSources to rebuild tables for.\n+                  dataSourcesToRebuild.addAll(dataSourcesNeedingRebuild);\n+                  refreshed.forEach(segment -> dataSourcesToRebuild.add(segment.getDataSource()));\n+                  dataSourcesNeedingRebuild.clear();\n+\n+                  lock.notifyAll();\n                 }\n-                catch (Exception e) {\n-                  log.warn(e, \"Metadata refresh failed, trying again soon.\");\n-\n-                  synchronized (lock) {\n-                    // Add our segments and dataSources back to their refresh and rebuild lists.\n-                    segmentsNeedingRefresh.addAll(segmentsToRefresh);\n-                    dataSourcesNeedingRebuild.addAll(dataSourcesToRebuild);\n-                    lastFailure = System.currentTimeMillis();\n-                    lock.notifyAll();\n+\n+                // Rebuild the dataSources.\n+                for (String dataSource : dataSourcesToRebuild) {\n+                  final DruidTable druidTable = buildDruidTable(dataSource);\n+                  final DruidTable oldTable = tables.put(dataSource, druidTable);\n+                  if (oldTable == null || !oldTable.getRowSignature().equals(druidTable.getRowSignature())) {\n+                    log.info(\"dataSource [%s] has new signature: %s.\", dataSource, druidTable.getRowSignature());\n+                  } else {\n+                    log.debug(\"dataSource [%s] signature is unchanged.\", dataSource);\n                   }\n                 }\n+\n+                initialized.countDown();\n+              }\n+              catch (InterruptedException e) {\n+                // Fall through.\n+                throw e;\n+              }\n+              catch (Exception e) {\n+                log.warn(e, \"Metadata refresh failed, trying again soon.\");\n+\n+                synchronized (lock) {\n+                  // Add our segments and dataSources back to their refresh and rebuild lists.\n+                  segmentsNeedingRefresh.addAll(segmentsToRefresh);\n+                  dataSourcesNeedingRebuild.addAll(dataSourcesToRebuild);\n+                  lastFailure = System.currentTimeMillis();\n+                  lock.notifyAll();\n+                }\n               }\n-            }\n-            catch (InterruptedException e) {\n-              // Just exit.\n-            }\n-            catch (Throwable e) {\n-              // Throwables that fall out to here (not caught by an inner try/catch) are potentially gnarly, like\n-              // OOMEs. Anyway, let's just emit an alert and stop refreshing metadata.\n-              log.makeAlert(e, \"Metadata refresh failed permanently\").emit();\n-              throw e;\n-            }\n-            finally {\n-              log.info(\"Metadata refresh stopped.\");\n             }\n           }\n+          catch (InterruptedException e) {\n+            // Just exit.\n+          }\n+          catch (Throwable e) {\n+            // Throwables that fall out to here (not caught by an inner try/catch) are potentially gnarly, like\n+            // OOMEs. Anyway, let's just emit an alert and stop refreshing metadata.\n+            log.makeAlert(e, \"Metadata refresh failed permanently\").emit();\n+            throw e;\n+          }\n+          finally {\n+            log.info(\"Metadata refresh stopped.\");\n+          }\n+        }\n+    );\n+\n+    ScheduledExecutors.scheduleWithFixedDelay(\n+        localSegmentExec,\n+        config.getMetadataRefreshPeriod().toStandardDuration(),\n+        config.getMetadataRefreshPeriod().toStandardDuration(),\n+        () -> {\n+          synchronized (lock) {\n+            // refresh known broadcast segments. Since DruidSchema is only present on the broker, any segment we have\n+            // locally in the SegmentManager must be broadcast datasources. This could potentially be replaced in the\n+            // future by fetching load rules from the coordinator\n+            Set<String> localSegmentDatasources = segmentManager.getDataSourceNames();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5ODU2Nw=="}, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 292}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTA3MTIyOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/GlobalTableDataSource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNTo1MTowNFrOGkMIsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMjo0MjoyMFrOGkZbwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMDc1Mw==", "bodyText": "\"datasource\" makes more sense here than \"segment\".", "url": "https://github.com/apache/druid/pull/10020#discussion_r440600753", "createdAt": "2020-06-16T05:51:04Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/query/GlobalTableDataSource.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n+\n+/**\n+ * {@link TableDataSource} variant for globally available 'broadcast' segments. If bound to a\n+ * {@link org.apache.druid.segment.join.JoinableFactory} that can create an\n+ * {@link org.apache.druid.segment.join.table.IndexedTable} using DruidBinders.joinableFactoryBinder, this allows\n+ * optimal usage of segments using this DataSource type in join operations (because they are global), and so can be pushed\n+ * down to historicals as a {@link JoinDataSource}, instead of requiring a subquery join using\n+ * {@link InlineDataSource} to construct an {@link org.apache.druid.segment.join.table.IndexedTable} on the fly on the\n+ * broker. Because it is also a {@link TableDataSource}, when queried directly, or on the left hand side of a join,\n+ * they will be treated as any normal segment.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxODYyNA==", "bodyText": "fixed", "url": "https://github.com/apache/druid/pull/10020#discussion_r440818624", "createdAt": "2020-06-16T12:42:20Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/GlobalTableDataSource.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n+\n+/**\n+ * {@link TableDataSource} variant for globally available 'broadcast' segments. If bound to a\n+ * {@link org.apache.druid.segment.join.JoinableFactory} that can create an\n+ * {@link org.apache.druid.segment.join.table.IndexedTable} using DruidBinders.joinableFactoryBinder, this allows\n+ * optimal usage of segments using this DataSource type in join operations (because they are global), and so can be pushed\n+ * down to historicals as a {@link JoinDataSource}, instead of requiring a subquery join using\n+ * {@link InlineDataSource} to construct an {@link org.apache.druid.segment.join.table.IndexedTable} on the fly on the\n+ * broker. Because it is also a {@link TableDataSource}, when queried directly, or on the left hand side of a join,\n+ * they will be treated as any normal segment.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMDc1Mw=="}, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTA3MjMxOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/GlobalTableDataSource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNTo1MTo0OFrOGkMJaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMjo0MjoxN1rOGkZbpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMDkzOQ==", "bodyText": "Why shouldn't it be cacheable?", "url": "https://github.com/apache/druid/pull/10020#discussion_r440600939", "createdAt": "2020-06-16T05:51:48Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/query/GlobalTableDataSource.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n+\n+/**\n+ * {@link TableDataSource} variant for globally available 'broadcast' segments. If bound to a\n+ * {@link org.apache.druid.segment.join.JoinableFactory} that can create an\n+ * {@link org.apache.druid.segment.join.table.IndexedTable} using DruidBinders.joinableFactoryBinder, this allows\n+ * optimal usage of segments using this DataSource type in join operations (because they are global), and so can be pushed\n+ * down to historicals as a {@link JoinDataSource}, instead of requiring a subquery join using\n+ * {@link InlineDataSource} to construct an {@link org.apache.druid.segment.join.table.IndexedTable} on the fly on the\n+ * broker. Because it is also a {@link TableDataSource}, when queried directly, or on the left hand side of a join,\n+ * they will be treated as any normal segment.\n+ */\n+@JsonTypeName(\"global\")\n+public class GlobalTableDataSource extends TableDataSource\n+{\n+  @JsonCreator\n+  public GlobalTableDataSource(@JsonProperty(\"name\") String name)\n+  {\n+    super(name);\n+  }\n+\n+  @Override\n+  public boolean isCacheable()\n+  {\n+    return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxODU5Nw==", "bodyText": "I think it should be, changed.", "url": "https://github.com/apache/druid/pull/10020#discussion_r440818597", "createdAt": "2020-06-16T12:42:17Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/GlobalTableDataSource.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n+\n+/**\n+ * {@link TableDataSource} variant for globally available 'broadcast' segments. If bound to a\n+ * {@link org.apache.druid.segment.join.JoinableFactory} that can create an\n+ * {@link org.apache.druid.segment.join.table.IndexedTable} using DruidBinders.joinableFactoryBinder, this allows\n+ * optimal usage of segments using this DataSource type in join operations (because they are global), and so can be pushed\n+ * down to historicals as a {@link JoinDataSource}, instead of requiring a subquery join using\n+ * {@link InlineDataSource} to construct an {@link org.apache.druid.segment.join.table.IndexedTable} on the fly on the\n+ * broker. Because it is also a {@link TableDataSource}, when queried directly, or on the left hand side of a join,\n+ * they will be treated as any normal segment.\n+ */\n+@JsonTypeName(\"global\")\n+public class GlobalTableDataSource extends TableDataSource\n+{\n+  @JsonCreator\n+  public GlobalTableDataSource(@JsonProperty(\"name\") String name)\n+  {\n+    super(name);\n+  }\n+\n+  @Override\n+  public boolean isCacheable()\n+  {\n+    return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMDkzOQ=="}, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTA3NjM2OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/TableDataSource.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNTo1Mzo0OVrOGkML1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMTo0OTo0MlrOGkuZZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMTU1OQ==", "bodyText": "I think you can make this a little less gross by replacing this equals impl (and the one in GlobalTableDataSource) with a new auto-generated one that checks getClass.", "url": "https://github.com/apache/druid/pull/10020#discussion_r440601559", "createdAt": "2020-06-16T05:53:49Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/query/TableDataSource.java", "diffHunk": "@@ -102,6 +102,11 @@ public final boolean equals(Object o)\n       return false;\n     }\n \n+    if ((o instanceof GlobalTableDataSource || this instanceof GlobalTableDataSource) &&\n+        !getClass().equals(o.getClass())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxODUzNA==", "bodyText": "I haven't made this change yet, still considering the best way and need to think about it. LegacyDataSource is also a TableDataSource and they need to be equal to each other, so I think something somewhere is going to be gross...", "url": "https://github.com/apache/druid/pull/10020#discussion_r440818534", "createdAt": "2020-06-16T12:42:12Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/TableDataSource.java", "diffHunk": "@@ -102,6 +102,11 @@ public final boolean equals(Object o)\n       return false;\n     }\n \n+    if ((o instanceof GlobalTableDataSource || this instanceof GlobalTableDataSource) &&\n+        !getClass().equals(o.getClass())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMTU1OQ=="}, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEwMjY5Mg==", "bodyText": "#10037 removes LegacyDataSource (inspired by this thread).", "url": "https://github.com/apache/druid/pull/10020#discussion_r441102692", "createdAt": "2020-06-16T19:50:12Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/query/TableDataSource.java", "diffHunk": "@@ -102,6 +102,11 @@ public final boolean equals(Object o)\n       return false;\n     }\n \n+    if ((o instanceof GlobalTableDataSource || this instanceof GlobalTableDataSource) &&\n+        !getClass().equals(o.getClass())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMTU1OQ=="}, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE2MjA4Nw==", "bodyText": "generated equals and hashcode for TableDataSource after ^ was merged", "url": "https://github.com/apache/druid/pull/10020#discussion_r441162087", "createdAt": "2020-06-16T21:49:42Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/TableDataSource.java", "diffHunk": "@@ -102,6 +102,11 @@ public final boolean equals(Object o)\n       return false;\n     }\n \n+    if ((o instanceof GlobalTableDataSource || this instanceof GlobalTableDataSource) &&\n+        !getClass().equals(o.getClass())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMTU1OQ=="}, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTA3NzE3OnYy", "diffSide": "RIGHT", "path": "processing/src/test/java/org/apache/druid/query/GlobalTableDataSourceTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNTo1NDoxOFrOGkMMZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMjo0MjowNlrOGkZbNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMTcwMA==", "bodyText": "Please add a test for nonequality with a TableDataSource of the same name.", "url": "https://github.com/apache/druid/pull/10020#discussion_r440601700", "createdAt": "2020-06-16T05:54:18Z", "author": {"login": "gianm"}, "path": "processing/src/test/java/org/apache/druid/query/GlobalTableDataSourceTest.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import nl.jqno.equalsverifier.EqualsVerifier;\n+import org.apache.druid.segment.TestHelper;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class GlobalTableDataSourceTest\n+{\n+  private static final GlobalTableDataSource GLOBAL_TABLE_DATA_SOURCE = new GlobalTableDataSource(\"foo\");\n+\n+  @Test\n+  public void testEquals()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxODQ4NA==", "bodyText": "added", "url": "https://github.com/apache/druid/pull/10020#discussion_r440818484", "createdAt": "2020-06-16T12:42:06Z", "author": {"login": "clintropolis"}, "path": "processing/src/test/java/org/apache/druid/query/GlobalTableDataSourceTest.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import nl.jqno.equalsverifier.EqualsVerifier;\n+import org.apache.druid.segment.TestHelper;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class GlobalTableDataSourceTest\n+{\n+  private static final GlobalTableDataSource GLOBAL_TABLE_DATA_SOURCE = new GlobalTableDataSource(\"foo\");\n+\n+  @Test\n+  public void testEquals()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMTcwMA=="}, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTA4MDAwOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNTo1NToyMlrOGkMN-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTo1MTo1NlrOGkq1Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMjEwNA==", "bodyText": "broadcastDataSources is more consistent spelling. Please add a comment too.", "url": "https://github.com/apache/druid/pull/10020#discussion_r440602104", "createdAt": "2020-06-16T05:55:22Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "diffHunk": "@@ -122,6 +128,8 @@\n   // All dataSources that need tables regenerated.\n   private final Set<String> dataSourcesNeedingRebuild = new HashSet<>();\n \n+  private final Set<String> broadcastDatasources = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMzQ5Ng==", "bodyText": "This should be @GuardedBy(\"lock\"), and so should dataSourcesNeedingRebuild, mutableSegments, segmentsNeedingRefresh, refreshImmediately, lastRefresh, lastFailure, and isServerViewInitialized.\nCould you please add those, and also remove the comment on lock, which is woefully out of date. (Thanks in advance for the housekeeping work.)", "url": "https://github.com/apache/druid/pull/10020#discussion_r440603496", "createdAt": "2020-06-16T05:59:56Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "diffHunk": "@@ -122,6 +128,8 @@\n   // All dataSources that need tables regenerated.\n   private final Set<String> dataSourcesNeedingRebuild = new HashSet<>();\n \n+  private final Set<String> broadcastDatasources = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMjEwNA=="}, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxODQyNQ==", "bodyText": "added annotations, though I actually ended up removing this field in a refactor", "url": "https://github.com/apache/druid/pull/10020#discussion_r440818425", "createdAt": "2020-06-16T12:42:01Z", "author": {"login": "clintropolis"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "diffHunk": "@@ -122,6 +128,8 @@\n   // All dataSources that need tables regenerated.\n   private final Set<String> dataSourcesNeedingRebuild = new HashSet<>();\n \n+  private final Set<String> broadcastDatasources = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMjEwNA=="}, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEwMzYzMQ==", "bodyText": "Thanks.", "url": "https://github.com/apache/druid/pull/10020#discussion_r441103631", "createdAt": "2020-06-16T19:51:56Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "diffHunk": "@@ -122,6 +128,8 @@\n   // All dataSources that need tables regenerated.\n   private final Set<String> dataSourcesNeedingRebuild = new HashSet<>();\n \n+  private final Set<String> broadcastDatasources = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMjEwNA=="}, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTA4MzUwOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNTo1NzowN1rOGkMQAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTo1MjowN1rOGkq1fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMjYyNw==", "bodyText": "Why not do this as part of the loop in the main thread?", "url": "https://github.com/apache/druid/pull/10020#discussion_r440602627", "createdAt": "2020-06-16T05:57:07Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "diffHunk": "@@ -196,119 +207,132 @@ public DruidSchema(\n   public void start() throws InterruptedException\n   {\n     cacheExec.submit(\n-        new Runnable()\n-        {\n-          @Override\n-          public void run()\n-          {\n-            try {\n-              while (!Thread.currentThread().isInterrupted()) {\n-                final Set<SegmentId> segmentsToRefresh = new TreeSet<>();\n-                final Set<String> dataSourcesToRebuild = new TreeSet<>();\n-\n-                try {\n-                  synchronized (lock) {\n-                    final long nextRefreshNoFuzz = DateTimes\n-                        .utc(lastRefresh)\n-                        .plus(config.getMetadataRefreshPeriod())\n-                        .getMillis();\n-\n-                    // Fuzz a bit to spread load out when we have multiple brokers.\n-                    final long nextRefresh = nextRefreshNoFuzz + (long) ((nextRefreshNoFuzz - lastRefresh) * 0.10);\n-\n-                    while (true) {\n-                      // Do not refresh if it's too soon after a failure (to avoid rapid cycles of failure).\n-                      final boolean wasRecentFailure = DateTimes.utc(lastFailure)\n-                                                                .plus(config.getMetadataRefreshPeriod())\n-                                                                .isAfterNow();\n-\n-                      if (isServerViewInitialized &&\n-                          !wasRecentFailure &&\n-                          (!segmentsNeedingRefresh.isEmpty() || !dataSourcesNeedingRebuild.isEmpty()) &&\n-                          (refreshImmediately || nextRefresh < System.currentTimeMillis())) {\n-                        // We need to do a refresh. Break out of the waiting loop.\n-                        break;\n-                      }\n-\n-                      if (isServerViewInitialized) {\n-                        // Server view is initialized, but we don't need to do a refresh. Could happen if there are\n-                        // no segments in the system yet. Just mark us as initialized, then.\n-                        initialized.countDown();\n-                      }\n-\n-                      // Wait some more, we'll wake up when it might be time to do another refresh.\n-                      lock.wait(Math.max(1, nextRefresh - System.currentTimeMillis()));\n+        () -> {\n+          try {\n+            while (!Thread.currentThread().isInterrupted()) {\n+              final Set<SegmentId> segmentsToRefresh = new TreeSet<>();\n+              final Set<String> dataSourcesToRebuild = new TreeSet<>();\n+\n+              try {\n+                synchronized (lock) {\n+                  final long nextRefreshNoFuzz = DateTimes\n+                      .utc(lastRefresh)\n+                      .plus(config.getMetadataRefreshPeriod())\n+                      .getMillis();\n+\n+                  // Fuzz a bit to spread load out when we have multiple brokers.\n+                  final long nextRefresh = nextRefreshNoFuzz + (long) ((nextRefreshNoFuzz - lastRefresh) * 0.10);\n+\n+                  while (true) {\n+                    // Do not refresh if it's too soon after a failure (to avoid rapid cycles of failure).\n+                    final boolean wasRecentFailure = DateTimes.utc(lastFailure)\n+                                                              .plus(config.getMetadataRefreshPeriod())\n+                                                              .isAfterNow();\n+\n+                    if (isServerViewInitialized &&\n+                        !wasRecentFailure &&\n+                        (!segmentsNeedingRefresh.isEmpty() || !dataSourcesNeedingRebuild.isEmpty()) &&\n+                        (refreshImmediately || nextRefresh < System.currentTimeMillis())) {\n+                      // We need to do a refresh. Break out of the waiting loop.\n+                      break;\n                     }\n \n-                    segmentsToRefresh.addAll(segmentsNeedingRefresh);\n-                    segmentsNeedingRefresh.clear();\n-\n-                    // Mutable segments need a refresh every period, since new columns could be added dynamically.\n-                    segmentsNeedingRefresh.addAll(mutableSegments);\n+                    if (isServerViewInitialized) {\n+                      // Server view is initialized, but we don't need to do a refresh. Could happen if there are\n+                      // no segments in the system yet. Just mark us as initialized, then.\n+                      initialized.countDown();\n+                    }\n \n-                    lastFailure = 0L;\n-                    lastRefresh = System.currentTimeMillis();\n-                    refreshImmediately = false;\n+                    // Wait some more, we'll wake up when it might be time to do another refresh.\n+                    lock.wait(Math.max(1, nextRefresh - System.currentTimeMillis()));\n                   }\n \n-                  // Refresh the segments.\n-                  final Set<SegmentId> refreshed = refreshSegments(segmentsToRefresh);\n+                  segmentsToRefresh.addAll(segmentsNeedingRefresh);\n+                  segmentsNeedingRefresh.clear();\n \n-                  synchronized (lock) {\n-                    // Add missing segments back to the refresh list.\n-                    segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n+                  // Mutable segments need a refresh every period, since new columns could be added dynamically.\n+                  segmentsNeedingRefresh.addAll(mutableSegments);\n \n-                    // Compute the list of dataSources to rebuild tables for.\n-                    dataSourcesToRebuild.addAll(dataSourcesNeedingRebuild);\n-                    refreshed.forEach(segment -> dataSourcesToRebuild.add(segment.getDataSource()));\n-                    dataSourcesNeedingRebuild.clear();\n+                  lastFailure = 0L;\n+                  lastRefresh = System.currentTimeMillis();\n+                  refreshImmediately = false;\n+                }\n \n-                    lock.notifyAll();\n-                  }\n+                // Refresh the segments.\n+                final Set<SegmentId> refreshed = refreshSegments(segmentsToRefresh);\n \n-                  // Rebuild the dataSources.\n-                  for (String dataSource : dataSourcesToRebuild) {\n-                    final DruidTable druidTable = buildDruidTable(dataSource);\n-                    final DruidTable oldTable = tables.put(dataSource, druidTable);\n-                    if (oldTable == null || !oldTable.getRowSignature().equals(druidTable.getRowSignature())) {\n-                      log.info(\"dataSource [%s] has new signature: %s.\", dataSource, druidTable.getRowSignature());\n-                    } else {\n-                      log.debug(\"dataSource [%s] signature is unchanged.\", dataSource);\n-                    }\n-                  }\n+                synchronized (lock) {\n+                  // Add missing segments back to the refresh list.\n+                  segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n \n-                  initialized.countDown();\n-                }\n-                catch (InterruptedException e) {\n-                  // Fall through.\n-                  throw e;\n+                  // Compute the list of dataSources to rebuild tables for.\n+                  dataSourcesToRebuild.addAll(dataSourcesNeedingRebuild);\n+                  refreshed.forEach(segment -> dataSourcesToRebuild.add(segment.getDataSource()));\n+                  dataSourcesNeedingRebuild.clear();\n+\n+                  lock.notifyAll();\n                 }\n-                catch (Exception e) {\n-                  log.warn(e, \"Metadata refresh failed, trying again soon.\");\n-\n-                  synchronized (lock) {\n-                    // Add our segments and dataSources back to their refresh and rebuild lists.\n-                    segmentsNeedingRefresh.addAll(segmentsToRefresh);\n-                    dataSourcesNeedingRebuild.addAll(dataSourcesToRebuild);\n-                    lastFailure = System.currentTimeMillis();\n-                    lock.notifyAll();\n+\n+                // Rebuild the dataSources.\n+                for (String dataSource : dataSourcesToRebuild) {\n+                  final DruidTable druidTable = buildDruidTable(dataSource);\n+                  final DruidTable oldTable = tables.put(dataSource, druidTable);\n+                  if (oldTable == null || !oldTable.getRowSignature().equals(druidTable.getRowSignature())) {\n+                    log.info(\"dataSource [%s] has new signature: %s.\", dataSource, druidTable.getRowSignature());\n+                  } else {\n+                    log.debug(\"dataSource [%s] signature is unchanged.\", dataSource);\n                   }\n                 }\n+\n+                initialized.countDown();\n+              }\n+              catch (InterruptedException e) {\n+                // Fall through.\n+                throw e;\n+              }\n+              catch (Exception e) {\n+                log.warn(e, \"Metadata refresh failed, trying again soon.\");\n+\n+                synchronized (lock) {\n+                  // Add our segments and dataSources back to their refresh and rebuild lists.\n+                  segmentsNeedingRefresh.addAll(segmentsToRefresh);\n+                  dataSourcesNeedingRebuild.addAll(dataSourcesToRebuild);\n+                  lastFailure = System.currentTimeMillis();\n+                  lock.notifyAll();\n+                }\n               }\n-            }\n-            catch (InterruptedException e) {\n-              // Just exit.\n-            }\n-            catch (Throwable e) {\n-              // Throwables that fall out to here (not caught by an inner try/catch) are potentially gnarly, like\n-              // OOMEs. Anyway, let's just emit an alert and stop refreshing metadata.\n-              log.makeAlert(e, \"Metadata refresh failed permanently\").emit();\n-              throw e;\n-            }\n-            finally {\n-              log.info(\"Metadata refresh stopped.\");\n             }\n           }\n+          catch (InterruptedException e) {\n+            // Just exit.\n+          }\n+          catch (Throwable e) {\n+            // Throwables that fall out to here (not caught by an inner try/catch) are potentially gnarly, like\n+            // OOMEs. Anyway, let's just emit an alert and stop refreshing metadata.\n+            log.makeAlert(e, \"Metadata refresh failed permanently\").emit();\n+            throw e;\n+          }\n+          finally {\n+            log.info(\"Metadata refresh stopped.\");\n+          }\n+        }\n+    );\n+\n+    ScheduledExecutors.scheduleWithFixedDelay(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxODM5NA==", "bodyText": "Removed this executor entirely in a refactor", "url": "https://github.com/apache/druid/pull/10020#discussion_r440818394", "createdAt": "2020-06-16T12:41:58Z", "author": {"login": "clintropolis"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "diffHunk": "@@ -196,119 +207,132 @@ public DruidSchema(\n   public void start() throws InterruptedException\n   {\n     cacheExec.submit(\n-        new Runnable()\n-        {\n-          @Override\n-          public void run()\n-          {\n-            try {\n-              while (!Thread.currentThread().isInterrupted()) {\n-                final Set<SegmentId> segmentsToRefresh = new TreeSet<>();\n-                final Set<String> dataSourcesToRebuild = new TreeSet<>();\n-\n-                try {\n-                  synchronized (lock) {\n-                    final long nextRefreshNoFuzz = DateTimes\n-                        .utc(lastRefresh)\n-                        .plus(config.getMetadataRefreshPeriod())\n-                        .getMillis();\n-\n-                    // Fuzz a bit to spread load out when we have multiple brokers.\n-                    final long nextRefresh = nextRefreshNoFuzz + (long) ((nextRefreshNoFuzz - lastRefresh) * 0.10);\n-\n-                    while (true) {\n-                      // Do not refresh if it's too soon after a failure (to avoid rapid cycles of failure).\n-                      final boolean wasRecentFailure = DateTimes.utc(lastFailure)\n-                                                                .plus(config.getMetadataRefreshPeriod())\n-                                                                .isAfterNow();\n-\n-                      if (isServerViewInitialized &&\n-                          !wasRecentFailure &&\n-                          (!segmentsNeedingRefresh.isEmpty() || !dataSourcesNeedingRebuild.isEmpty()) &&\n-                          (refreshImmediately || nextRefresh < System.currentTimeMillis())) {\n-                        // We need to do a refresh. Break out of the waiting loop.\n-                        break;\n-                      }\n-\n-                      if (isServerViewInitialized) {\n-                        // Server view is initialized, but we don't need to do a refresh. Could happen if there are\n-                        // no segments in the system yet. Just mark us as initialized, then.\n-                        initialized.countDown();\n-                      }\n-\n-                      // Wait some more, we'll wake up when it might be time to do another refresh.\n-                      lock.wait(Math.max(1, nextRefresh - System.currentTimeMillis()));\n+        () -> {\n+          try {\n+            while (!Thread.currentThread().isInterrupted()) {\n+              final Set<SegmentId> segmentsToRefresh = new TreeSet<>();\n+              final Set<String> dataSourcesToRebuild = new TreeSet<>();\n+\n+              try {\n+                synchronized (lock) {\n+                  final long nextRefreshNoFuzz = DateTimes\n+                      .utc(lastRefresh)\n+                      .plus(config.getMetadataRefreshPeriod())\n+                      .getMillis();\n+\n+                  // Fuzz a bit to spread load out when we have multiple brokers.\n+                  final long nextRefresh = nextRefreshNoFuzz + (long) ((nextRefreshNoFuzz - lastRefresh) * 0.10);\n+\n+                  while (true) {\n+                    // Do not refresh if it's too soon after a failure (to avoid rapid cycles of failure).\n+                    final boolean wasRecentFailure = DateTimes.utc(lastFailure)\n+                                                              .plus(config.getMetadataRefreshPeriod())\n+                                                              .isAfterNow();\n+\n+                    if (isServerViewInitialized &&\n+                        !wasRecentFailure &&\n+                        (!segmentsNeedingRefresh.isEmpty() || !dataSourcesNeedingRebuild.isEmpty()) &&\n+                        (refreshImmediately || nextRefresh < System.currentTimeMillis())) {\n+                      // We need to do a refresh. Break out of the waiting loop.\n+                      break;\n                     }\n \n-                    segmentsToRefresh.addAll(segmentsNeedingRefresh);\n-                    segmentsNeedingRefresh.clear();\n-\n-                    // Mutable segments need a refresh every period, since new columns could be added dynamically.\n-                    segmentsNeedingRefresh.addAll(mutableSegments);\n+                    if (isServerViewInitialized) {\n+                      // Server view is initialized, but we don't need to do a refresh. Could happen if there are\n+                      // no segments in the system yet. Just mark us as initialized, then.\n+                      initialized.countDown();\n+                    }\n \n-                    lastFailure = 0L;\n-                    lastRefresh = System.currentTimeMillis();\n-                    refreshImmediately = false;\n+                    // Wait some more, we'll wake up when it might be time to do another refresh.\n+                    lock.wait(Math.max(1, nextRefresh - System.currentTimeMillis()));\n                   }\n \n-                  // Refresh the segments.\n-                  final Set<SegmentId> refreshed = refreshSegments(segmentsToRefresh);\n+                  segmentsToRefresh.addAll(segmentsNeedingRefresh);\n+                  segmentsNeedingRefresh.clear();\n \n-                  synchronized (lock) {\n-                    // Add missing segments back to the refresh list.\n-                    segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n+                  // Mutable segments need a refresh every period, since new columns could be added dynamically.\n+                  segmentsNeedingRefresh.addAll(mutableSegments);\n \n-                    // Compute the list of dataSources to rebuild tables for.\n-                    dataSourcesToRebuild.addAll(dataSourcesNeedingRebuild);\n-                    refreshed.forEach(segment -> dataSourcesToRebuild.add(segment.getDataSource()));\n-                    dataSourcesNeedingRebuild.clear();\n+                  lastFailure = 0L;\n+                  lastRefresh = System.currentTimeMillis();\n+                  refreshImmediately = false;\n+                }\n \n-                    lock.notifyAll();\n-                  }\n+                // Refresh the segments.\n+                final Set<SegmentId> refreshed = refreshSegments(segmentsToRefresh);\n \n-                  // Rebuild the dataSources.\n-                  for (String dataSource : dataSourcesToRebuild) {\n-                    final DruidTable druidTable = buildDruidTable(dataSource);\n-                    final DruidTable oldTable = tables.put(dataSource, druidTable);\n-                    if (oldTable == null || !oldTable.getRowSignature().equals(druidTable.getRowSignature())) {\n-                      log.info(\"dataSource [%s] has new signature: %s.\", dataSource, druidTable.getRowSignature());\n-                    } else {\n-                      log.debug(\"dataSource [%s] signature is unchanged.\", dataSource);\n-                    }\n-                  }\n+                synchronized (lock) {\n+                  // Add missing segments back to the refresh list.\n+                  segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n \n-                  initialized.countDown();\n-                }\n-                catch (InterruptedException e) {\n-                  // Fall through.\n-                  throw e;\n+                  // Compute the list of dataSources to rebuild tables for.\n+                  dataSourcesToRebuild.addAll(dataSourcesNeedingRebuild);\n+                  refreshed.forEach(segment -> dataSourcesToRebuild.add(segment.getDataSource()));\n+                  dataSourcesNeedingRebuild.clear();\n+\n+                  lock.notifyAll();\n                 }\n-                catch (Exception e) {\n-                  log.warn(e, \"Metadata refresh failed, trying again soon.\");\n-\n-                  synchronized (lock) {\n-                    // Add our segments and dataSources back to their refresh and rebuild lists.\n-                    segmentsNeedingRefresh.addAll(segmentsToRefresh);\n-                    dataSourcesNeedingRebuild.addAll(dataSourcesToRebuild);\n-                    lastFailure = System.currentTimeMillis();\n-                    lock.notifyAll();\n+\n+                // Rebuild the dataSources.\n+                for (String dataSource : dataSourcesToRebuild) {\n+                  final DruidTable druidTable = buildDruidTable(dataSource);\n+                  final DruidTable oldTable = tables.put(dataSource, druidTable);\n+                  if (oldTable == null || !oldTable.getRowSignature().equals(druidTable.getRowSignature())) {\n+                    log.info(\"dataSource [%s] has new signature: %s.\", dataSource, druidTable.getRowSignature());\n+                  } else {\n+                    log.debug(\"dataSource [%s] signature is unchanged.\", dataSource);\n                   }\n                 }\n+\n+                initialized.countDown();\n+              }\n+              catch (InterruptedException e) {\n+                // Fall through.\n+                throw e;\n+              }\n+              catch (Exception e) {\n+                log.warn(e, \"Metadata refresh failed, trying again soon.\");\n+\n+                synchronized (lock) {\n+                  // Add our segments and dataSources back to their refresh and rebuild lists.\n+                  segmentsNeedingRefresh.addAll(segmentsToRefresh);\n+                  dataSourcesNeedingRebuild.addAll(dataSourcesToRebuild);\n+                  lastFailure = System.currentTimeMillis();\n+                  lock.notifyAll();\n+                }\n               }\n-            }\n-            catch (InterruptedException e) {\n-              // Just exit.\n-            }\n-            catch (Throwable e) {\n-              // Throwables that fall out to here (not caught by an inner try/catch) are potentially gnarly, like\n-              // OOMEs. Anyway, let's just emit an alert and stop refreshing metadata.\n-              log.makeAlert(e, \"Metadata refresh failed permanently\").emit();\n-              throw e;\n-            }\n-            finally {\n-              log.info(\"Metadata refresh stopped.\");\n             }\n           }\n+          catch (InterruptedException e) {\n+            // Just exit.\n+          }\n+          catch (Throwable e) {\n+            // Throwables that fall out to here (not caught by an inner try/catch) are potentially gnarly, like\n+            // OOMEs. Anyway, let's just emit an alert and stop refreshing metadata.\n+            log.makeAlert(e, \"Metadata refresh failed permanently\").emit();\n+            throw e;\n+          }\n+          finally {\n+            log.info(\"Metadata refresh stopped.\");\n+          }\n+        }\n+    );\n+\n+    ScheduledExecutors.scheduleWithFixedDelay(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMjYyNw=="}, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEwMzc0MA==", "bodyText": "Great.", "url": "https://github.com/apache/druid/pull/10020#discussion_r441103740", "createdAt": "2020-06-16T19:52:07Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "diffHunk": "@@ -196,119 +207,132 @@ public DruidSchema(\n   public void start() throws InterruptedException\n   {\n     cacheExec.submit(\n-        new Runnable()\n-        {\n-          @Override\n-          public void run()\n-          {\n-            try {\n-              while (!Thread.currentThread().isInterrupted()) {\n-                final Set<SegmentId> segmentsToRefresh = new TreeSet<>();\n-                final Set<String> dataSourcesToRebuild = new TreeSet<>();\n-\n-                try {\n-                  synchronized (lock) {\n-                    final long nextRefreshNoFuzz = DateTimes\n-                        .utc(lastRefresh)\n-                        .plus(config.getMetadataRefreshPeriod())\n-                        .getMillis();\n-\n-                    // Fuzz a bit to spread load out when we have multiple brokers.\n-                    final long nextRefresh = nextRefreshNoFuzz + (long) ((nextRefreshNoFuzz - lastRefresh) * 0.10);\n-\n-                    while (true) {\n-                      // Do not refresh if it's too soon after a failure (to avoid rapid cycles of failure).\n-                      final boolean wasRecentFailure = DateTimes.utc(lastFailure)\n-                                                                .plus(config.getMetadataRefreshPeriod())\n-                                                                .isAfterNow();\n-\n-                      if (isServerViewInitialized &&\n-                          !wasRecentFailure &&\n-                          (!segmentsNeedingRefresh.isEmpty() || !dataSourcesNeedingRebuild.isEmpty()) &&\n-                          (refreshImmediately || nextRefresh < System.currentTimeMillis())) {\n-                        // We need to do a refresh. Break out of the waiting loop.\n-                        break;\n-                      }\n-\n-                      if (isServerViewInitialized) {\n-                        // Server view is initialized, but we don't need to do a refresh. Could happen if there are\n-                        // no segments in the system yet. Just mark us as initialized, then.\n-                        initialized.countDown();\n-                      }\n-\n-                      // Wait some more, we'll wake up when it might be time to do another refresh.\n-                      lock.wait(Math.max(1, nextRefresh - System.currentTimeMillis()));\n+        () -> {\n+          try {\n+            while (!Thread.currentThread().isInterrupted()) {\n+              final Set<SegmentId> segmentsToRefresh = new TreeSet<>();\n+              final Set<String> dataSourcesToRebuild = new TreeSet<>();\n+\n+              try {\n+                synchronized (lock) {\n+                  final long nextRefreshNoFuzz = DateTimes\n+                      .utc(lastRefresh)\n+                      .plus(config.getMetadataRefreshPeriod())\n+                      .getMillis();\n+\n+                  // Fuzz a bit to spread load out when we have multiple brokers.\n+                  final long nextRefresh = nextRefreshNoFuzz + (long) ((nextRefreshNoFuzz - lastRefresh) * 0.10);\n+\n+                  while (true) {\n+                    // Do not refresh if it's too soon after a failure (to avoid rapid cycles of failure).\n+                    final boolean wasRecentFailure = DateTimes.utc(lastFailure)\n+                                                              .plus(config.getMetadataRefreshPeriod())\n+                                                              .isAfterNow();\n+\n+                    if (isServerViewInitialized &&\n+                        !wasRecentFailure &&\n+                        (!segmentsNeedingRefresh.isEmpty() || !dataSourcesNeedingRebuild.isEmpty()) &&\n+                        (refreshImmediately || nextRefresh < System.currentTimeMillis())) {\n+                      // We need to do a refresh. Break out of the waiting loop.\n+                      break;\n                     }\n \n-                    segmentsToRefresh.addAll(segmentsNeedingRefresh);\n-                    segmentsNeedingRefresh.clear();\n-\n-                    // Mutable segments need a refresh every period, since new columns could be added dynamically.\n-                    segmentsNeedingRefresh.addAll(mutableSegments);\n+                    if (isServerViewInitialized) {\n+                      // Server view is initialized, but we don't need to do a refresh. Could happen if there are\n+                      // no segments in the system yet. Just mark us as initialized, then.\n+                      initialized.countDown();\n+                    }\n \n-                    lastFailure = 0L;\n-                    lastRefresh = System.currentTimeMillis();\n-                    refreshImmediately = false;\n+                    // Wait some more, we'll wake up when it might be time to do another refresh.\n+                    lock.wait(Math.max(1, nextRefresh - System.currentTimeMillis()));\n                   }\n \n-                  // Refresh the segments.\n-                  final Set<SegmentId> refreshed = refreshSegments(segmentsToRefresh);\n+                  segmentsToRefresh.addAll(segmentsNeedingRefresh);\n+                  segmentsNeedingRefresh.clear();\n \n-                  synchronized (lock) {\n-                    // Add missing segments back to the refresh list.\n-                    segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n+                  // Mutable segments need a refresh every period, since new columns could be added dynamically.\n+                  segmentsNeedingRefresh.addAll(mutableSegments);\n \n-                    // Compute the list of dataSources to rebuild tables for.\n-                    dataSourcesToRebuild.addAll(dataSourcesNeedingRebuild);\n-                    refreshed.forEach(segment -> dataSourcesToRebuild.add(segment.getDataSource()));\n-                    dataSourcesNeedingRebuild.clear();\n+                  lastFailure = 0L;\n+                  lastRefresh = System.currentTimeMillis();\n+                  refreshImmediately = false;\n+                }\n \n-                    lock.notifyAll();\n-                  }\n+                // Refresh the segments.\n+                final Set<SegmentId> refreshed = refreshSegments(segmentsToRefresh);\n \n-                  // Rebuild the dataSources.\n-                  for (String dataSource : dataSourcesToRebuild) {\n-                    final DruidTable druidTable = buildDruidTable(dataSource);\n-                    final DruidTable oldTable = tables.put(dataSource, druidTable);\n-                    if (oldTable == null || !oldTable.getRowSignature().equals(druidTable.getRowSignature())) {\n-                      log.info(\"dataSource [%s] has new signature: %s.\", dataSource, druidTable.getRowSignature());\n-                    } else {\n-                      log.debug(\"dataSource [%s] signature is unchanged.\", dataSource);\n-                    }\n-                  }\n+                synchronized (lock) {\n+                  // Add missing segments back to the refresh list.\n+                  segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n \n-                  initialized.countDown();\n-                }\n-                catch (InterruptedException e) {\n-                  // Fall through.\n-                  throw e;\n+                  // Compute the list of dataSources to rebuild tables for.\n+                  dataSourcesToRebuild.addAll(dataSourcesNeedingRebuild);\n+                  refreshed.forEach(segment -> dataSourcesToRebuild.add(segment.getDataSource()));\n+                  dataSourcesNeedingRebuild.clear();\n+\n+                  lock.notifyAll();\n                 }\n-                catch (Exception e) {\n-                  log.warn(e, \"Metadata refresh failed, trying again soon.\");\n-\n-                  synchronized (lock) {\n-                    // Add our segments and dataSources back to their refresh and rebuild lists.\n-                    segmentsNeedingRefresh.addAll(segmentsToRefresh);\n-                    dataSourcesNeedingRebuild.addAll(dataSourcesToRebuild);\n-                    lastFailure = System.currentTimeMillis();\n-                    lock.notifyAll();\n+\n+                // Rebuild the dataSources.\n+                for (String dataSource : dataSourcesToRebuild) {\n+                  final DruidTable druidTable = buildDruidTable(dataSource);\n+                  final DruidTable oldTable = tables.put(dataSource, druidTable);\n+                  if (oldTable == null || !oldTable.getRowSignature().equals(druidTable.getRowSignature())) {\n+                    log.info(\"dataSource [%s] has new signature: %s.\", dataSource, druidTable.getRowSignature());\n+                  } else {\n+                    log.debug(\"dataSource [%s] signature is unchanged.\", dataSource);\n                   }\n                 }\n+\n+                initialized.countDown();\n+              }\n+              catch (InterruptedException e) {\n+                // Fall through.\n+                throw e;\n+              }\n+              catch (Exception e) {\n+                log.warn(e, \"Metadata refresh failed, trying again soon.\");\n+\n+                synchronized (lock) {\n+                  // Add our segments and dataSources back to their refresh and rebuild lists.\n+                  segmentsNeedingRefresh.addAll(segmentsToRefresh);\n+                  dataSourcesNeedingRebuild.addAll(dataSourcesToRebuild);\n+                  lastFailure = System.currentTimeMillis();\n+                  lock.notifyAll();\n+                }\n               }\n-            }\n-            catch (InterruptedException e) {\n-              // Just exit.\n-            }\n-            catch (Throwable e) {\n-              // Throwables that fall out to here (not caught by an inner try/catch) are potentially gnarly, like\n-              // OOMEs. Anyway, let's just emit an alert and stop refreshing metadata.\n-              log.makeAlert(e, \"Metadata refresh failed permanently\").emit();\n-              throw e;\n-            }\n-            finally {\n-              log.info(\"Metadata refresh stopped.\");\n             }\n           }\n+          catch (InterruptedException e) {\n+            // Just exit.\n+          }\n+          catch (Throwable e) {\n+            // Throwables that fall out to here (not caught by an inner try/catch) are potentially gnarly, like\n+            // OOMEs. Anyway, let's just emit an alert and stop refreshing metadata.\n+            log.makeAlert(e, \"Metadata refresh failed permanently\").emit();\n+            throw e;\n+          }\n+          finally {\n+            log.info(\"Metadata refresh stopped.\");\n+          }\n+        }\n+    );\n+\n+    ScheduledExecutors.scheduleWithFixedDelay(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMjYyNw=="}, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 283}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTA4NDI3OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNTo1NzozMVrOGkMQgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTo1Mjo1N1rOGkq3Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMjc1NA==", "bodyText": "Why do we need to rebuild them all continuously?", "url": "https://github.com/apache/druid/pull/10020#discussion_r440602754", "createdAt": "2020-06-16T05:57:31Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "diffHunk": "@@ -196,119 +207,132 @@ public DruidSchema(\n   public void start() throws InterruptedException\n   {\n     cacheExec.submit(\n-        new Runnable()\n-        {\n-          @Override\n-          public void run()\n-          {\n-            try {\n-              while (!Thread.currentThread().isInterrupted()) {\n-                final Set<SegmentId> segmentsToRefresh = new TreeSet<>();\n-                final Set<String> dataSourcesToRebuild = new TreeSet<>();\n-\n-                try {\n-                  synchronized (lock) {\n-                    final long nextRefreshNoFuzz = DateTimes\n-                        .utc(lastRefresh)\n-                        .plus(config.getMetadataRefreshPeriod())\n-                        .getMillis();\n-\n-                    // Fuzz a bit to spread load out when we have multiple brokers.\n-                    final long nextRefresh = nextRefreshNoFuzz + (long) ((nextRefreshNoFuzz - lastRefresh) * 0.10);\n-\n-                    while (true) {\n-                      // Do not refresh if it's too soon after a failure (to avoid rapid cycles of failure).\n-                      final boolean wasRecentFailure = DateTimes.utc(lastFailure)\n-                                                                .plus(config.getMetadataRefreshPeriod())\n-                                                                .isAfterNow();\n-\n-                      if (isServerViewInitialized &&\n-                          !wasRecentFailure &&\n-                          (!segmentsNeedingRefresh.isEmpty() || !dataSourcesNeedingRebuild.isEmpty()) &&\n-                          (refreshImmediately || nextRefresh < System.currentTimeMillis())) {\n-                        // We need to do a refresh. Break out of the waiting loop.\n-                        break;\n-                      }\n-\n-                      if (isServerViewInitialized) {\n-                        // Server view is initialized, but we don't need to do a refresh. Could happen if there are\n-                        // no segments in the system yet. Just mark us as initialized, then.\n-                        initialized.countDown();\n-                      }\n-\n-                      // Wait some more, we'll wake up when it might be time to do another refresh.\n-                      lock.wait(Math.max(1, nextRefresh - System.currentTimeMillis()));\n+        () -> {\n+          try {\n+            while (!Thread.currentThread().isInterrupted()) {\n+              final Set<SegmentId> segmentsToRefresh = new TreeSet<>();\n+              final Set<String> dataSourcesToRebuild = new TreeSet<>();\n+\n+              try {\n+                synchronized (lock) {\n+                  final long nextRefreshNoFuzz = DateTimes\n+                      .utc(lastRefresh)\n+                      .plus(config.getMetadataRefreshPeriod())\n+                      .getMillis();\n+\n+                  // Fuzz a bit to spread load out when we have multiple brokers.\n+                  final long nextRefresh = nextRefreshNoFuzz + (long) ((nextRefreshNoFuzz - lastRefresh) * 0.10);\n+\n+                  while (true) {\n+                    // Do not refresh if it's too soon after a failure (to avoid rapid cycles of failure).\n+                    final boolean wasRecentFailure = DateTimes.utc(lastFailure)\n+                                                              .plus(config.getMetadataRefreshPeriod())\n+                                                              .isAfterNow();\n+\n+                    if (isServerViewInitialized &&\n+                        !wasRecentFailure &&\n+                        (!segmentsNeedingRefresh.isEmpty() || !dataSourcesNeedingRebuild.isEmpty()) &&\n+                        (refreshImmediately || nextRefresh < System.currentTimeMillis())) {\n+                      // We need to do a refresh. Break out of the waiting loop.\n+                      break;\n                     }\n \n-                    segmentsToRefresh.addAll(segmentsNeedingRefresh);\n-                    segmentsNeedingRefresh.clear();\n-\n-                    // Mutable segments need a refresh every period, since new columns could be added dynamically.\n-                    segmentsNeedingRefresh.addAll(mutableSegments);\n+                    if (isServerViewInitialized) {\n+                      // Server view is initialized, but we don't need to do a refresh. Could happen if there are\n+                      // no segments in the system yet. Just mark us as initialized, then.\n+                      initialized.countDown();\n+                    }\n \n-                    lastFailure = 0L;\n-                    lastRefresh = System.currentTimeMillis();\n-                    refreshImmediately = false;\n+                    // Wait some more, we'll wake up when it might be time to do another refresh.\n+                    lock.wait(Math.max(1, nextRefresh - System.currentTimeMillis()));\n                   }\n \n-                  // Refresh the segments.\n-                  final Set<SegmentId> refreshed = refreshSegments(segmentsToRefresh);\n+                  segmentsToRefresh.addAll(segmentsNeedingRefresh);\n+                  segmentsNeedingRefresh.clear();\n \n-                  synchronized (lock) {\n-                    // Add missing segments back to the refresh list.\n-                    segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n+                  // Mutable segments need a refresh every period, since new columns could be added dynamically.\n+                  segmentsNeedingRefresh.addAll(mutableSegments);\n \n-                    // Compute the list of dataSources to rebuild tables for.\n-                    dataSourcesToRebuild.addAll(dataSourcesNeedingRebuild);\n-                    refreshed.forEach(segment -> dataSourcesToRebuild.add(segment.getDataSource()));\n-                    dataSourcesNeedingRebuild.clear();\n+                  lastFailure = 0L;\n+                  lastRefresh = System.currentTimeMillis();\n+                  refreshImmediately = false;\n+                }\n \n-                    lock.notifyAll();\n-                  }\n+                // Refresh the segments.\n+                final Set<SegmentId> refreshed = refreshSegments(segmentsToRefresh);\n \n-                  // Rebuild the dataSources.\n-                  for (String dataSource : dataSourcesToRebuild) {\n-                    final DruidTable druidTable = buildDruidTable(dataSource);\n-                    final DruidTable oldTable = tables.put(dataSource, druidTable);\n-                    if (oldTable == null || !oldTable.getRowSignature().equals(druidTable.getRowSignature())) {\n-                      log.info(\"dataSource [%s] has new signature: %s.\", dataSource, druidTable.getRowSignature());\n-                    } else {\n-                      log.debug(\"dataSource [%s] signature is unchanged.\", dataSource);\n-                    }\n-                  }\n+                synchronized (lock) {\n+                  // Add missing segments back to the refresh list.\n+                  segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n \n-                  initialized.countDown();\n-                }\n-                catch (InterruptedException e) {\n-                  // Fall through.\n-                  throw e;\n+                  // Compute the list of dataSources to rebuild tables for.\n+                  dataSourcesToRebuild.addAll(dataSourcesNeedingRebuild);\n+                  refreshed.forEach(segment -> dataSourcesToRebuild.add(segment.getDataSource()));\n+                  dataSourcesNeedingRebuild.clear();\n+\n+                  lock.notifyAll();\n                 }\n-                catch (Exception e) {\n-                  log.warn(e, \"Metadata refresh failed, trying again soon.\");\n-\n-                  synchronized (lock) {\n-                    // Add our segments and dataSources back to their refresh and rebuild lists.\n-                    segmentsNeedingRefresh.addAll(segmentsToRefresh);\n-                    dataSourcesNeedingRebuild.addAll(dataSourcesToRebuild);\n-                    lastFailure = System.currentTimeMillis();\n-                    lock.notifyAll();\n+\n+                // Rebuild the dataSources.\n+                for (String dataSource : dataSourcesToRebuild) {\n+                  final DruidTable druidTable = buildDruidTable(dataSource);\n+                  final DruidTable oldTable = tables.put(dataSource, druidTable);\n+                  if (oldTable == null || !oldTable.getRowSignature().equals(druidTable.getRowSignature())) {\n+                    log.info(\"dataSource [%s] has new signature: %s.\", dataSource, druidTable.getRowSignature());\n+                  } else {\n+                    log.debug(\"dataSource [%s] signature is unchanged.\", dataSource);\n                   }\n                 }\n+\n+                initialized.countDown();\n+              }\n+              catch (InterruptedException e) {\n+                // Fall through.\n+                throw e;\n+              }\n+              catch (Exception e) {\n+                log.warn(e, \"Metadata refresh failed, trying again soon.\");\n+\n+                synchronized (lock) {\n+                  // Add our segments and dataSources back to their refresh and rebuild lists.\n+                  segmentsNeedingRefresh.addAll(segmentsToRefresh);\n+                  dataSourcesNeedingRebuild.addAll(dataSourcesToRebuild);\n+                  lastFailure = System.currentTimeMillis();\n+                  lock.notifyAll();\n+                }\n               }\n-            }\n-            catch (InterruptedException e) {\n-              // Just exit.\n-            }\n-            catch (Throwable e) {\n-              // Throwables that fall out to here (not caught by an inner try/catch) are potentially gnarly, like\n-              // OOMEs. Anyway, let's just emit an alert and stop refreshing metadata.\n-              log.makeAlert(e, \"Metadata refresh failed permanently\").emit();\n-              throw e;\n-            }\n-            finally {\n-              log.info(\"Metadata refresh stopped.\");\n             }\n           }\n+          catch (InterruptedException e) {\n+            // Just exit.\n+          }\n+          catch (Throwable e) {\n+            // Throwables that fall out to here (not caught by an inner try/catch) are potentially gnarly, like\n+            // OOMEs. Anyway, let's just emit an alert and stop refreshing metadata.\n+            log.makeAlert(e, \"Metadata refresh failed permanently\").emit();\n+            throw e;\n+          }\n+          finally {\n+            log.info(\"Metadata refresh stopped.\");\n+          }\n+        }\n+    );\n+\n+    ScheduledExecutors.scheduleWithFixedDelay(\n+        localSegmentExec,\n+        config.getMetadataRefreshPeriod().toStandardDuration(),\n+        config.getMetadataRefreshPeriod().toStandardDuration(),\n+        () -> {\n+          synchronized (lock) {\n+            // refresh known broadcast segments. Since DruidSchema is only present on the broker, any segment we have\n+            // locally in the SegmentManager must be broadcast datasources. This could potentially be replaced in the\n+            // future by fetching load rules from the coordinator\n+            Set<String> localSegmentDatasources = segmentManager.getDataSourceNames();\n+            dataSourcesNeedingRebuild.addAll(localSegmentDatasources);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxODI2MQ==", "bodyText": "We don't really, I've refactored this pretty heavily.\nI reworked the fix I did for #10017, to instead now preserve the segment/timeline event callbacks from the BrokerServerView (but still not add the server/segment to the timeline to avoid the weird loops), which in turn allows DruidSchema get these events for broker segments to mark datasources to be rebuilt in the normal path (just skipping metadata fetch on the assumption that the segment will appear, so that the existing loop handles these changes correctly.", "url": "https://github.com/apache/druid/pull/10020#discussion_r440818261", "createdAt": "2020-06-16T12:41:47Z", "author": {"login": "clintropolis"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "diffHunk": "@@ -196,119 +207,132 @@ public DruidSchema(\n   public void start() throws InterruptedException\n   {\n     cacheExec.submit(\n-        new Runnable()\n-        {\n-          @Override\n-          public void run()\n-          {\n-            try {\n-              while (!Thread.currentThread().isInterrupted()) {\n-                final Set<SegmentId> segmentsToRefresh = new TreeSet<>();\n-                final Set<String> dataSourcesToRebuild = new TreeSet<>();\n-\n-                try {\n-                  synchronized (lock) {\n-                    final long nextRefreshNoFuzz = DateTimes\n-                        .utc(lastRefresh)\n-                        .plus(config.getMetadataRefreshPeriod())\n-                        .getMillis();\n-\n-                    // Fuzz a bit to spread load out when we have multiple brokers.\n-                    final long nextRefresh = nextRefreshNoFuzz + (long) ((nextRefreshNoFuzz - lastRefresh) * 0.10);\n-\n-                    while (true) {\n-                      // Do not refresh if it's too soon after a failure (to avoid rapid cycles of failure).\n-                      final boolean wasRecentFailure = DateTimes.utc(lastFailure)\n-                                                                .plus(config.getMetadataRefreshPeriod())\n-                                                                .isAfterNow();\n-\n-                      if (isServerViewInitialized &&\n-                          !wasRecentFailure &&\n-                          (!segmentsNeedingRefresh.isEmpty() || !dataSourcesNeedingRebuild.isEmpty()) &&\n-                          (refreshImmediately || nextRefresh < System.currentTimeMillis())) {\n-                        // We need to do a refresh. Break out of the waiting loop.\n-                        break;\n-                      }\n-\n-                      if (isServerViewInitialized) {\n-                        // Server view is initialized, but we don't need to do a refresh. Could happen if there are\n-                        // no segments in the system yet. Just mark us as initialized, then.\n-                        initialized.countDown();\n-                      }\n-\n-                      // Wait some more, we'll wake up when it might be time to do another refresh.\n-                      lock.wait(Math.max(1, nextRefresh - System.currentTimeMillis()));\n+        () -> {\n+          try {\n+            while (!Thread.currentThread().isInterrupted()) {\n+              final Set<SegmentId> segmentsToRefresh = new TreeSet<>();\n+              final Set<String> dataSourcesToRebuild = new TreeSet<>();\n+\n+              try {\n+                synchronized (lock) {\n+                  final long nextRefreshNoFuzz = DateTimes\n+                      .utc(lastRefresh)\n+                      .plus(config.getMetadataRefreshPeriod())\n+                      .getMillis();\n+\n+                  // Fuzz a bit to spread load out when we have multiple brokers.\n+                  final long nextRefresh = nextRefreshNoFuzz + (long) ((nextRefreshNoFuzz - lastRefresh) * 0.10);\n+\n+                  while (true) {\n+                    // Do not refresh if it's too soon after a failure (to avoid rapid cycles of failure).\n+                    final boolean wasRecentFailure = DateTimes.utc(lastFailure)\n+                                                              .plus(config.getMetadataRefreshPeriod())\n+                                                              .isAfterNow();\n+\n+                    if (isServerViewInitialized &&\n+                        !wasRecentFailure &&\n+                        (!segmentsNeedingRefresh.isEmpty() || !dataSourcesNeedingRebuild.isEmpty()) &&\n+                        (refreshImmediately || nextRefresh < System.currentTimeMillis())) {\n+                      // We need to do a refresh. Break out of the waiting loop.\n+                      break;\n                     }\n \n-                    segmentsToRefresh.addAll(segmentsNeedingRefresh);\n-                    segmentsNeedingRefresh.clear();\n-\n-                    // Mutable segments need a refresh every period, since new columns could be added dynamically.\n-                    segmentsNeedingRefresh.addAll(mutableSegments);\n+                    if (isServerViewInitialized) {\n+                      // Server view is initialized, but we don't need to do a refresh. Could happen if there are\n+                      // no segments in the system yet. Just mark us as initialized, then.\n+                      initialized.countDown();\n+                    }\n \n-                    lastFailure = 0L;\n-                    lastRefresh = System.currentTimeMillis();\n-                    refreshImmediately = false;\n+                    // Wait some more, we'll wake up when it might be time to do another refresh.\n+                    lock.wait(Math.max(1, nextRefresh - System.currentTimeMillis()));\n                   }\n \n-                  // Refresh the segments.\n-                  final Set<SegmentId> refreshed = refreshSegments(segmentsToRefresh);\n+                  segmentsToRefresh.addAll(segmentsNeedingRefresh);\n+                  segmentsNeedingRefresh.clear();\n \n-                  synchronized (lock) {\n-                    // Add missing segments back to the refresh list.\n-                    segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n+                  // Mutable segments need a refresh every period, since new columns could be added dynamically.\n+                  segmentsNeedingRefresh.addAll(mutableSegments);\n \n-                    // Compute the list of dataSources to rebuild tables for.\n-                    dataSourcesToRebuild.addAll(dataSourcesNeedingRebuild);\n-                    refreshed.forEach(segment -> dataSourcesToRebuild.add(segment.getDataSource()));\n-                    dataSourcesNeedingRebuild.clear();\n+                  lastFailure = 0L;\n+                  lastRefresh = System.currentTimeMillis();\n+                  refreshImmediately = false;\n+                }\n \n-                    lock.notifyAll();\n-                  }\n+                // Refresh the segments.\n+                final Set<SegmentId> refreshed = refreshSegments(segmentsToRefresh);\n \n-                  // Rebuild the dataSources.\n-                  for (String dataSource : dataSourcesToRebuild) {\n-                    final DruidTable druidTable = buildDruidTable(dataSource);\n-                    final DruidTable oldTable = tables.put(dataSource, druidTable);\n-                    if (oldTable == null || !oldTable.getRowSignature().equals(druidTable.getRowSignature())) {\n-                      log.info(\"dataSource [%s] has new signature: %s.\", dataSource, druidTable.getRowSignature());\n-                    } else {\n-                      log.debug(\"dataSource [%s] signature is unchanged.\", dataSource);\n-                    }\n-                  }\n+                synchronized (lock) {\n+                  // Add missing segments back to the refresh list.\n+                  segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n \n-                  initialized.countDown();\n-                }\n-                catch (InterruptedException e) {\n-                  // Fall through.\n-                  throw e;\n+                  // Compute the list of dataSources to rebuild tables for.\n+                  dataSourcesToRebuild.addAll(dataSourcesNeedingRebuild);\n+                  refreshed.forEach(segment -> dataSourcesToRebuild.add(segment.getDataSource()));\n+                  dataSourcesNeedingRebuild.clear();\n+\n+                  lock.notifyAll();\n                 }\n-                catch (Exception e) {\n-                  log.warn(e, \"Metadata refresh failed, trying again soon.\");\n-\n-                  synchronized (lock) {\n-                    // Add our segments and dataSources back to their refresh and rebuild lists.\n-                    segmentsNeedingRefresh.addAll(segmentsToRefresh);\n-                    dataSourcesNeedingRebuild.addAll(dataSourcesToRebuild);\n-                    lastFailure = System.currentTimeMillis();\n-                    lock.notifyAll();\n+\n+                // Rebuild the dataSources.\n+                for (String dataSource : dataSourcesToRebuild) {\n+                  final DruidTable druidTable = buildDruidTable(dataSource);\n+                  final DruidTable oldTable = tables.put(dataSource, druidTable);\n+                  if (oldTable == null || !oldTable.getRowSignature().equals(druidTable.getRowSignature())) {\n+                    log.info(\"dataSource [%s] has new signature: %s.\", dataSource, druidTable.getRowSignature());\n+                  } else {\n+                    log.debug(\"dataSource [%s] signature is unchanged.\", dataSource);\n                   }\n                 }\n+\n+                initialized.countDown();\n+              }\n+              catch (InterruptedException e) {\n+                // Fall through.\n+                throw e;\n+              }\n+              catch (Exception e) {\n+                log.warn(e, \"Metadata refresh failed, trying again soon.\");\n+\n+                synchronized (lock) {\n+                  // Add our segments and dataSources back to their refresh and rebuild lists.\n+                  segmentsNeedingRefresh.addAll(segmentsToRefresh);\n+                  dataSourcesNeedingRebuild.addAll(dataSourcesToRebuild);\n+                  lastFailure = System.currentTimeMillis();\n+                  lock.notifyAll();\n+                }\n               }\n-            }\n-            catch (InterruptedException e) {\n-              // Just exit.\n-            }\n-            catch (Throwable e) {\n-              // Throwables that fall out to here (not caught by an inner try/catch) are potentially gnarly, like\n-              // OOMEs. Anyway, let's just emit an alert and stop refreshing metadata.\n-              log.makeAlert(e, \"Metadata refresh failed permanently\").emit();\n-              throw e;\n-            }\n-            finally {\n-              log.info(\"Metadata refresh stopped.\");\n             }\n           }\n+          catch (InterruptedException e) {\n+            // Just exit.\n+          }\n+          catch (Throwable e) {\n+            // Throwables that fall out to here (not caught by an inner try/catch) are potentially gnarly, like\n+            // OOMEs. Anyway, let's just emit an alert and stop refreshing metadata.\n+            log.makeAlert(e, \"Metadata refresh failed permanently\").emit();\n+            throw e;\n+          }\n+          finally {\n+            log.info(\"Metadata refresh stopped.\");\n+          }\n+        }\n+    );\n+\n+    ScheduledExecutors.scheduleWithFixedDelay(\n+        localSegmentExec,\n+        config.getMetadataRefreshPeriod().toStandardDuration(),\n+        config.getMetadataRefreshPeriod().toStandardDuration(),\n+        () -> {\n+          synchronized (lock) {\n+            // refresh known broadcast segments. Since DruidSchema is only present on the broker, any segment we have\n+            // locally in the SegmentManager must be broadcast datasources. This could potentially be replaced in the\n+            // future by fetching load rules from the coordinator\n+            Set<String> localSegmentDatasources = segmentManager.getDataSourceNames();\n+            dataSourcesNeedingRebuild.addAll(localSegmentDatasources);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMjc1NA=="}, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEwNDIwNg==", "bodyText": "OK, I will take another look.", "url": "https://github.com/apache/druid/pull/10020#discussion_r441104206", "createdAt": "2020-06-16T19:52:57Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "diffHunk": "@@ -196,119 +207,132 @@ public DruidSchema(\n   public void start() throws InterruptedException\n   {\n     cacheExec.submit(\n-        new Runnable()\n-        {\n-          @Override\n-          public void run()\n-          {\n-            try {\n-              while (!Thread.currentThread().isInterrupted()) {\n-                final Set<SegmentId> segmentsToRefresh = new TreeSet<>();\n-                final Set<String> dataSourcesToRebuild = new TreeSet<>();\n-\n-                try {\n-                  synchronized (lock) {\n-                    final long nextRefreshNoFuzz = DateTimes\n-                        .utc(lastRefresh)\n-                        .plus(config.getMetadataRefreshPeriod())\n-                        .getMillis();\n-\n-                    // Fuzz a bit to spread load out when we have multiple brokers.\n-                    final long nextRefresh = nextRefreshNoFuzz + (long) ((nextRefreshNoFuzz - lastRefresh) * 0.10);\n-\n-                    while (true) {\n-                      // Do not refresh if it's too soon after a failure (to avoid rapid cycles of failure).\n-                      final boolean wasRecentFailure = DateTimes.utc(lastFailure)\n-                                                                .plus(config.getMetadataRefreshPeriod())\n-                                                                .isAfterNow();\n-\n-                      if (isServerViewInitialized &&\n-                          !wasRecentFailure &&\n-                          (!segmentsNeedingRefresh.isEmpty() || !dataSourcesNeedingRebuild.isEmpty()) &&\n-                          (refreshImmediately || nextRefresh < System.currentTimeMillis())) {\n-                        // We need to do a refresh. Break out of the waiting loop.\n-                        break;\n-                      }\n-\n-                      if (isServerViewInitialized) {\n-                        // Server view is initialized, but we don't need to do a refresh. Could happen if there are\n-                        // no segments in the system yet. Just mark us as initialized, then.\n-                        initialized.countDown();\n-                      }\n-\n-                      // Wait some more, we'll wake up when it might be time to do another refresh.\n-                      lock.wait(Math.max(1, nextRefresh - System.currentTimeMillis()));\n+        () -> {\n+          try {\n+            while (!Thread.currentThread().isInterrupted()) {\n+              final Set<SegmentId> segmentsToRefresh = new TreeSet<>();\n+              final Set<String> dataSourcesToRebuild = new TreeSet<>();\n+\n+              try {\n+                synchronized (lock) {\n+                  final long nextRefreshNoFuzz = DateTimes\n+                      .utc(lastRefresh)\n+                      .plus(config.getMetadataRefreshPeriod())\n+                      .getMillis();\n+\n+                  // Fuzz a bit to spread load out when we have multiple brokers.\n+                  final long nextRefresh = nextRefreshNoFuzz + (long) ((nextRefreshNoFuzz - lastRefresh) * 0.10);\n+\n+                  while (true) {\n+                    // Do not refresh if it's too soon after a failure (to avoid rapid cycles of failure).\n+                    final boolean wasRecentFailure = DateTimes.utc(lastFailure)\n+                                                              .plus(config.getMetadataRefreshPeriod())\n+                                                              .isAfterNow();\n+\n+                    if (isServerViewInitialized &&\n+                        !wasRecentFailure &&\n+                        (!segmentsNeedingRefresh.isEmpty() || !dataSourcesNeedingRebuild.isEmpty()) &&\n+                        (refreshImmediately || nextRefresh < System.currentTimeMillis())) {\n+                      // We need to do a refresh. Break out of the waiting loop.\n+                      break;\n                     }\n \n-                    segmentsToRefresh.addAll(segmentsNeedingRefresh);\n-                    segmentsNeedingRefresh.clear();\n-\n-                    // Mutable segments need a refresh every period, since new columns could be added dynamically.\n-                    segmentsNeedingRefresh.addAll(mutableSegments);\n+                    if (isServerViewInitialized) {\n+                      // Server view is initialized, but we don't need to do a refresh. Could happen if there are\n+                      // no segments in the system yet. Just mark us as initialized, then.\n+                      initialized.countDown();\n+                    }\n \n-                    lastFailure = 0L;\n-                    lastRefresh = System.currentTimeMillis();\n-                    refreshImmediately = false;\n+                    // Wait some more, we'll wake up when it might be time to do another refresh.\n+                    lock.wait(Math.max(1, nextRefresh - System.currentTimeMillis()));\n                   }\n \n-                  // Refresh the segments.\n-                  final Set<SegmentId> refreshed = refreshSegments(segmentsToRefresh);\n+                  segmentsToRefresh.addAll(segmentsNeedingRefresh);\n+                  segmentsNeedingRefresh.clear();\n \n-                  synchronized (lock) {\n-                    // Add missing segments back to the refresh list.\n-                    segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n+                  // Mutable segments need a refresh every period, since new columns could be added dynamically.\n+                  segmentsNeedingRefresh.addAll(mutableSegments);\n \n-                    // Compute the list of dataSources to rebuild tables for.\n-                    dataSourcesToRebuild.addAll(dataSourcesNeedingRebuild);\n-                    refreshed.forEach(segment -> dataSourcesToRebuild.add(segment.getDataSource()));\n-                    dataSourcesNeedingRebuild.clear();\n+                  lastFailure = 0L;\n+                  lastRefresh = System.currentTimeMillis();\n+                  refreshImmediately = false;\n+                }\n \n-                    lock.notifyAll();\n-                  }\n+                // Refresh the segments.\n+                final Set<SegmentId> refreshed = refreshSegments(segmentsToRefresh);\n \n-                  // Rebuild the dataSources.\n-                  for (String dataSource : dataSourcesToRebuild) {\n-                    final DruidTable druidTable = buildDruidTable(dataSource);\n-                    final DruidTable oldTable = tables.put(dataSource, druidTable);\n-                    if (oldTable == null || !oldTable.getRowSignature().equals(druidTable.getRowSignature())) {\n-                      log.info(\"dataSource [%s] has new signature: %s.\", dataSource, druidTable.getRowSignature());\n-                    } else {\n-                      log.debug(\"dataSource [%s] signature is unchanged.\", dataSource);\n-                    }\n-                  }\n+                synchronized (lock) {\n+                  // Add missing segments back to the refresh list.\n+                  segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n \n-                  initialized.countDown();\n-                }\n-                catch (InterruptedException e) {\n-                  // Fall through.\n-                  throw e;\n+                  // Compute the list of dataSources to rebuild tables for.\n+                  dataSourcesToRebuild.addAll(dataSourcesNeedingRebuild);\n+                  refreshed.forEach(segment -> dataSourcesToRebuild.add(segment.getDataSource()));\n+                  dataSourcesNeedingRebuild.clear();\n+\n+                  lock.notifyAll();\n                 }\n-                catch (Exception e) {\n-                  log.warn(e, \"Metadata refresh failed, trying again soon.\");\n-\n-                  synchronized (lock) {\n-                    // Add our segments and dataSources back to their refresh and rebuild lists.\n-                    segmentsNeedingRefresh.addAll(segmentsToRefresh);\n-                    dataSourcesNeedingRebuild.addAll(dataSourcesToRebuild);\n-                    lastFailure = System.currentTimeMillis();\n-                    lock.notifyAll();\n+\n+                // Rebuild the dataSources.\n+                for (String dataSource : dataSourcesToRebuild) {\n+                  final DruidTable druidTable = buildDruidTable(dataSource);\n+                  final DruidTable oldTable = tables.put(dataSource, druidTable);\n+                  if (oldTable == null || !oldTable.getRowSignature().equals(druidTable.getRowSignature())) {\n+                    log.info(\"dataSource [%s] has new signature: %s.\", dataSource, druidTable.getRowSignature());\n+                  } else {\n+                    log.debug(\"dataSource [%s] signature is unchanged.\", dataSource);\n                   }\n                 }\n+\n+                initialized.countDown();\n+              }\n+              catch (InterruptedException e) {\n+                // Fall through.\n+                throw e;\n+              }\n+              catch (Exception e) {\n+                log.warn(e, \"Metadata refresh failed, trying again soon.\");\n+\n+                synchronized (lock) {\n+                  // Add our segments and dataSources back to their refresh and rebuild lists.\n+                  segmentsNeedingRefresh.addAll(segmentsToRefresh);\n+                  dataSourcesNeedingRebuild.addAll(dataSourcesToRebuild);\n+                  lastFailure = System.currentTimeMillis();\n+                  lock.notifyAll();\n+                }\n               }\n-            }\n-            catch (InterruptedException e) {\n-              // Just exit.\n-            }\n-            catch (Throwable e) {\n-              // Throwables that fall out to here (not caught by an inner try/catch) are potentially gnarly, like\n-              // OOMEs. Anyway, let's just emit an alert and stop refreshing metadata.\n-              log.makeAlert(e, \"Metadata refresh failed permanently\").emit();\n-              throw e;\n-            }\n-            finally {\n-              log.info(\"Metadata refresh stopped.\");\n             }\n           }\n+          catch (InterruptedException e) {\n+            // Just exit.\n+          }\n+          catch (Throwable e) {\n+            // Throwables that fall out to here (not caught by an inner try/catch) are potentially gnarly, like\n+            // OOMEs. Anyway, let's just emit an alert and stop refreshing metadata.\n+            log.makeAlert(e, \"Metadata refresh failed permanently\").emit();\n+            throw e;\n+          }\n+          finally {\n+            log.info(\"Metadata refresh stopped.\");\n+          }\n+        }\n+    );\n+\n+    ScheduledExecutors.scheduleWithFixedDelay(\n+        localSegmentExec,\n+        config.getMetadataRefreshPeriod().toStandardDuration(),\n+        config.getMetadataRefreshPeriod().toStandardDuration(),\n+        () -> {\n+          synchronized (lock) {\n+            // refresh known broadcast segments. Since DruidSchema is only present on the broker, any segment we have\n+            // locally in the SegmentManager must be broadcast datasources. This could potentially be replaced in the\n+            // future by fetching load rules from the coordinator\n+            Set<String> localSegmentDatasources = segmentManager.getDataSourceNames();\n+            dataSourcesNeedingRebuild.addAll(localSegmentDatasources);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMjc1NA=="}, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 293}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTA4NzY3OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNTo1OToxN1rOGkMSlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTo1MzowNlrOGkq3gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMzI4NQ==", "bodyText": "tiny nit: the logic is laid out a bit weirdly here; it'd make more sense to emphasize what's different by having the dataSource be created in the if block, but the DruidTable created outside of it.", "url": "https://github.com/apache/druid/pull/10020#discussion_r440603285", "createdAt": "2020-06-16T05:59:17Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "diffHunk": "@@ -616,6 +631,12 @@ private DruidTable buildDruidTable(final String dataSource)\n \n       final RowSignature.Builder builder = RowSignature.builder();\n       columnTypes.forEach(builder::add);\n+      if (broadcastDatasources.contains(dataSource)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 346}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxODMzNg==", "bodyText": "modified", "url": "https://github.com/apache/druid/pull/10020#discussion_r440818336", "createdAt": "2020-06-16T12:41:52Z", "author": {"login": "clintropolis"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "diffHunk": "@@ -616,6 +631,12 @@ private DruidTable buildDruidTable(final String dataSource)\n \n       final RowSignature.Builder builder = RowSignature.builder();\n       columnTypes.forEach(builder::add);\n+      if (broadcastDatasources.contains(dataSource)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMzI4NQ=="}, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 346}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEwNDI1Nw==", "bodyText": "\ud83c\udd92", "url": "https://github.com/apache/druid/pull/10020#discussion_r441104257", "createdAt": "2020-06-16T19:53:06Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "diffHunk": "@@ -616,6 +631,12 @@ private DruidTable buildDruidTable(final String dataSource)\n \n       final RowSignature.Builder builder = RowSignature.builder();\n       columnTypes.forEach(builder::add);\n+      if (broadcastDatasources.contains(dataSource)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMzI4NQ=="}, "originalCommit": {"oid": "9d7a9b6fce0b4d8ba4f9e7f4321aa6eb24458f01"}, "originalPosition": 346}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2324, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}