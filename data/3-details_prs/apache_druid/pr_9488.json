{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1ODQ3OTc4", "number": 9488, "title": "Match GREATEST/LEAST function behavior to other DBs", "bodyText": "Description\nChange the behavior of the GREATEST / LEAST functions to be similar to how it is implemented in other databases (as functions instead of aggregators). The GREATEST/LEAST functions are not in the SQL standard, but users will expect behavior similar to what other databases provide.\nReferences:\n\nPostgreSQL: https://www.postgresql.org/docs/9.5/functions-conditional.html\nVertica: https://www.vertica.com/docs/9.2.x/HTML/Content/Authoring/SQLReferenceManual/Functions/String/GREATEST.htm\nMySQL: https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_greatest\nOracle: https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions087.htm#SQLRF00657\n\n\nThis PR has:\n\n been self-reviewed.\n added documentation for new or modified features or behaviors.\n added Javadocs for most classes and all non-trivial methods. Linked related entities via Javadoc links.\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.\n added unit tests or modified existing tests to cover new code paths.", "createdAt": "2020-03-09T22:27:27Z", "url": "https://github.com/apache/druid/pull/9488", "merged": true, "mergeCommit": {"oid": "6b02991464839188ae815242adeef5b43da16341"}, "closed": true, "closedAt": "2020-03-12T22:10:12Z", "author": {"login": "ccaominh"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcMFiRcAH2gAyMzg1ODQ3OTc4OjQ0YzRiNWU0MGVjMWNhYmRlNWJhNWY3NjcwN2Y0ZWI1MzUyMjI5ODk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcNAsBhgFqTM3MzgzMzIxNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "44c4b5e40ec1cabde5ba5f76707f4eb535222989", "author": {"user": {"login": "ccaominh", "name": "Chi Cao Minh"}}, "url": "https://github.com/apache/druid/commit/44c4b5e40ec1cabde5ba5f76707f4eb535222989", "committedDate": "2020-03-09T22:20:08Z", "message": "Match GREATEST/LEAST function behavior\n\nChange the behavior of the GREATEST / LEAST functions to be similar to\nhow it is implemented in other databases (as functions instead of\naggregators). The GREATEST/LEAST functions are not in the SQL standard,\nbut users will expect behavior similar to what other databases provide."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNTg2MTI4", "url": "https://github.com/apache/druid/pull/9488#pullrequestreview-371586128", "createdAt": "2020-03-09T23:08:42Z", "commit": {"oid": "44c4b5e40ec1cabde5ba5f76707f4eb535222989"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMzowODo0MlrOFz8T6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMzowODo0MlrOFz8T6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwOTgzMg==", "bodyText": "is this implicit cast something that other databases do as well ? how about enforce an explicit cast ?", "url": "https://github.com/apache/druid/pull/9488#discussion_r390009832", "createdAt": "2020-03-09T23:08:42Z", "author": {"login": "b-slim"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -334,6 +332,22 @@ simplest way to write literal timestamps in other time zones is to use TIME_PARS\n |<code>timestamp_expr { + &#124; - } <interval_expr><code>|Add or subtract an amount of time from a timestamp. interval_expr can include interval literals like `INTERVAL '2' HOUR`, and may include interval arithmetic as well. This operator treats days as uniformly 86400 seconds long, and does not take into account daylight savings time. To account for daylight savings time, use TIME_SHIFT instead.|\n \n \n+### Reduction functions\n+\n+Reduction functions operate on zero or more expressions and return a single expression. If no expressions are passed\n+as arguments, then the result is `NULL`. The expressions must all be convertible to a\n+common data type, which will be the type of the result:\n+*  If any argument is `NULL`, the result is `NULL`.\n+*  If the arguments comprise a mix of numbers and strings, the arguments are interpreted as strings.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44c4b5e40ec1cabde5ba5f76707f4eb535222989"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNTg3Nzk5", "url": "https://github.com/apache/druid/pull/9488#pullrequestreview-371587799", "createdAt": "2020-03-09T23:13:26Z", "commit": {"oid": "44c4b5e40ec1cabde5ba5f76707f4eb535222989"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMzoxMzoyN1rOFz8Zwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMzoxMzo1NVrOFz8aUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTMzMA==", "bodyText": "Old text, but maximum/minimum seem like not quite the right word.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | greatest([expr1, ...]) | Returns the maximum expression across zero or more expressions. |\n          \n          \n            \n            | greatest([expr1, ...]) | Returns the largest value among zero or more expressions. |", "url": "https://github.com/apache/druid/pull/9488#discussion_r390011330", "createdAt": "2020-03-09T23:13:27Z", "author": {"login": "sthetland"}, "path": "docs/misc/math-expr.md", "diffHunk": "@@ -181,6 +181,22 @@ See javadoc of java.lang.Math for detailed explanation for each function.\n | all(lambda,arr) | returns 1 if all elements in the array matches the lambda expression, else 0 |\n \n \n+### Reduction functions\n+\n+Reduction functions operate on zero or more expressions and return a single expression. If no expressions are passed\n+as arguments, then the result is `NULL`. The expressions must all be convertible to a\n+common data type, which will be the type of the result:\n+*  If any argument is `NULL`, the result is `NULL`.\n+*  If the arguments comprise a mix of numbers and strings, the arguments are interpreted as strings.\n+*  If all arguments are integer numbers, the arguments are interpreted as longs.\n+*  If all arguments are numbers and at least one argument is a double, the arguments are interpreted as doubles. \n+\n+| function | description |\n+| --- | --- |\n+| greatest([expr1, ...]) | Returns the maximum expression across zero or more expressions. |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44c4b5e40ec1cabde5ba5f76707f4eb535222989"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTQ3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | least([expr1, ...]) | Returns the minimum expression across zero or more expressions. |\n          \n          \n            \n            | least([expr1, ...]) | Returns the smallest value among zero or more expressions. |", "url": "https://github.com/apache/druid/pull/9488#discussion_r390011472", "createdAt": "2020-03-09T23:13:55Z", "author": {"login": "sthetland"}, "path": "docs/misc/math-expr.md", "diffHunk": "@@ -181,6 +181,22 @@ See javadoc of java.lang.Math for detailed explanation for each function.\n | all(lambda,arr) | returns 1 if all elements in the array matches the lambda expression, else 0 |\n \n \n+### Reduction functions\n+\n+Reduction functions operate on zero or more expressions and return a single expression. If no expressions are passed\n+as arguments, then the result is `NULL`. The expressions must all be convertible to a\n+common data type, which will be the type of the result:\n+*  If any argument is `NULL`, the result is `NULL`.\n+*  If the arguments comprise a mix of numbers and strings, the arguments are interpreted as strings.\n+*  If all arguments are integer numbers, the arguments are interpreted as longs.\n+*  If all arguments are numbers and at least one argument is a double, the arguments are interpreted as doubles. \n+\n+| function | description |\n+| --- | --- |\n+| greatest([expr1, ...]) | Returns the maximum expression across zero or more expressions. |\n+| least([expr1, ...]) | Returns the minimum expression across zero or more expressions. |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44c4b5e40ec1cabde5ba5f76707f4eb535222989"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8", "author": {"user": {"login": "ccaominh", "name": "Chi Cao Minh"}}, "url": "https://github.com/apache/druid/commit/ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8", "committedDate": "2020-03-10T18:07:29Z", "message": "Merge remote-tracking branch 'upstream/master' into fix-greatest-least"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyOTE0Nzcx", "url": "https://github.com/apache/druid/pull/9488#pullrequestreview-372914771", "createdAt": "2020-03-11T16:17:13Z", "commit": {"oid": "ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjoxNzoxM1rOF0-ZwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjozNzo0NFrOF0_Qqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5MjY3Mw==", "bodyText": "Given it's not standard and we can do what we want, I would suggest going with the Postgres behavior for these reasons:\n\nIMO the Postgres behavior is more likely to be useful: if I do GREATEST(x, y, z) and y is null, I probably want that to be equivalent to GREATEST(x, z).\nPostgres behavior is used as a base for a wide variety of other databases beyond the ones we're looking at here, so its behavior is influential.", "url": "https://github.com/apache/druid/pull/9488#discussion_r391092673", "createdAt": "2020-03-11T16:17:13Z", "author": {"login": "gianm"}, "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "diffHunk": "@@ -976,6 +981,163 @@ protected ExprEval eval(double x, double y)\n     }\n   }\n \n+  class GreatestFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"greatest\";\n+\n+    public GreatestFunc()\n+    {\n+      super(\n+          Math::max,\n+          Math::max,\n+          BinaryOperator.maxBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  class LeastFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"least\";\n+\n+    public LeastFunc()\n+    {\n+      super(\n+          Math::min,\n+          Math::min,\n+          BinaryOperator.minBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  abstract class ReduceFunc implements Function\n+  {\n+    private final DoubleBinaryOperator doubleReducer;\n+    private final LongBinaryOperator longReducer;\n+    private final BinaryOperator<String> stringReducer;\n+\n+    ReduceFunc(\n+        DoubleBinaryOperator doubleReducer,\n+        LongBinaryOperator longReducer,\n+        BinaryOperator<String> stringReducer\n+    )\n+    {\n+      this.doubleReducer = doubleReducer;\n+      this.longReducer = longReducer;\n+      this.stringReducer = stringReducer;\n+    }\n+\n+    @Override\n+    public void validateArguments(List<Expr> args)\n+    {\n+      // anything goes\n+    }\n+\n+    @Override\n+    public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n+    {\n+      if (args.isEmpty()) {\n+        return ExprEval.of(null);\n+      }\n+\n+      ExprAnalysis exprAnalysis = analyzeExprs(args, bindings);\n+      if (exprAnalysis == null) {\n+        // The GREATEST/LEAST functions are not in the SQL standard, but most (e.g., MySQL, Oracle) return NULL if any\n+        // are NULL. Others (e.g., Postgres) only return NULL if all are NULL, otherwise the NULLs are ignored.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5NDg1Mg==", "bodyText": "Even though this method is private, javadocs would be nice, especially for explaining when null would be returned. The method is long enough that it is not obvious what it does without studying it.", "url": "https://github.com/apache/druid/pull/9488#discussion_r391094852", "createdAt": "2020-03-11T16:20:20Z", "author": {"login": "gianm"}, "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "diffHunk": "@@ -976,6 +981,163 @@ protected ExprEval eval(double x, double y)\n     }\n   }\n \n+  class GreatestFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"greatest\";\n+\n+    public GreatestFunc()\n+    {\n+      super(\n+          Math::max,\n+          Math::max,\n+          BinaryOperator.maxBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  class LeastFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"least\";\n+\n+    public LeastFunc()\n+    {\n+      super(\n+          Math::min,\n+          Math::min,\n+          BinaryOperator.minBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  abstract class ReduceFunc implements Function\n+  {\n+    private final DoubleBinaryOperator doubleReducer;\n+    private final LongBinaryOperator longReducer;\n+    private final BinaryOperator<String> stringReducer;\n+\n+    ReduceFunc(\n+        DoubleBinaryOperator doubleReducer,\n+        LongBinaryOperator longReducer,\n+        BinaryOperator<String> stringReducer\n+    )\n+    {\n+      this.doubleReducer = doubleReducer;\n+      this.longReducer = longReducer;\n+      this.stringReducer = stringReducer;\n+    }\n+\n+    @Override\n+    public void validateArguments(List<Expr> args)\n+    {\n+      // anything goes\n+    }\n+\n+    @Override\n+    public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n+    {\n+      if (args.isEmpty()) {\n+        return ExprEval.of(null);\n+      }\n+\n+      ExprAnalysis exprAnalysis = analyzeExprs(args, bindings);\n+      if (exprAnalysis == null) {\n+        // The GREATEST/LEAST functions are not in the SQL standard, but most (e.g., MySQL, Oracle) return NULL if any\n+        // are NULL. Others (e.g., Postgres) only return NULL if all are NULL, otherwise the NULLs are ignored.\n+        return ExprEval.of(null);\n+      }\n+\n+      Stream<ExprEval<?>> exprEvalStream = exprAnalysis.exprEvals.stream();\n+      switch (exprAnalysis.comparisonType) {\n+        case DOUBLE:\n+          //noinspection OptionalGetWithoutIsPresent (empty list handled earlier)\n+          return ExprEval.of(exprEvalStream.mapToDouble(ExprEval::asDouble).reduce(doubleReducer).getAsDouble());\n+        case LONG:\n+          //noinspection OptionalGetWithoutIsPresent (empty list handled earlier)\n+          return ExprEval.of(exprEvalStream.mapToLong(ExprEval::asLong).reduce(longReducer).getAsLong());\n+        default:\n+          //noinspection OptionalGetWithoutIsPresent (empty list handled earlier)\n+          return ExprEval.of(exprEvalStream.map(ExprEval::asString).reduce(stringReducer).get());\n+      }\n+    }\n+\n+    @Nullable\n+    private ExprAnalysis analyzeExprs(List<Expr> exprs, Expr.ObjectBinding bindings)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5NzU2NQ==", "bodyText": "I believe exprEval.value() == null is equivalent and may avoid computing the stringValue in some cases.", "url": "https://github.com/apache/druid/pull/9488#discussion_r391097565", "createdAt": "2020-03-11T16:24:16Z", "author": {"login": "gianm"}, "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "diffHunk": "@@ -976,6 +981,163 @@ protected ExprEval eval(double x, double y)\n     }\n   }\n \n+  class GreatestFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"greatest\";\n+\n+    public GreatestFunc()\n+    {\n+      super(\n+          Math::max,\n+          Math::max,\n+          BinaryOperator.maxBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  class LeastFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"least\";\n+\n+    public LeastFunc()\n+    {\n+      super(\n+          Math::min,\n+          Math::min,\n+          BinaryOperator.minBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  abstract class ReduceFunc implements Function\n+  {\n+    private final DoubleBinaryOperator doubleReducer;\n+    private final LongBinaryOperator longReducer;\n+    private final BinaryOperator<String> stringReducer;\n+\n+    ReduceFunc(\n+        DoubleBinaryOperator doubleReducer,\n+        LongBinaryOperator longReducer,\n+        BinaryOperator<String> stringReducer\n+    )\n+    {\n+      this.doubleReducer = doubleReducer;\n+      this.longReducer = longReducer;\n+      this.stringReducer = stringReducer;\n+    }\n+\n+    @Override\n+    public void validateArguments(List<Expr> args)\n+    {\n+      // anything goes\n+    }\n+\n+    @Override\n+    public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n+    {\n+      if (args.isEmpty()) {\n+        return ExprEval.of(null);\n+      }\n+\n+      ExprAnalysis exprAnalysis = analyzeExprs(args, bindings);\n+      if (exprAnalysis == null) {\n+        // The GREATEST/LEAST functions are not in the SQL standard, but most (e.g., MySQL, Oracle) return NULL if any\n+        // are NULL. Others (e.g., Postgres) only return NULL if all are NULL, otherwise the NULLs are ignored.\n+        return ExprEval.of(null);\n+      }\n+\n+      Stream<ExprEval<?>> exprEvalStream = exprAnalysis.exprEvals.stream();\n+      switch (exprAnalysis.comparisonType) {\n+        case DOUBLE:\n+          //noinspection OptionalGetWithoutIsPresent (empty list handled earlier)\n+          return ExprEval.of(exprEvalStream.mapToDouble(ExprEval::asDouble).reduce(doubleReducer).getAsDouble());\n+        case LONG:\n+          //noinspection OptionalGetWithoutIsPresent (empty list handled earlier)\n+          return ExprEval.of(exprEvalStream.mapToLong(ExprEval::asLong).reduce(longReducer).getAsLong());\n+        default:\n+          //noinspection OptionalGetWithoutIsPresent (empty list handled earlier)\n+          return ExprEval.of(exprEvalStream.map(ExprEval::asString).reduce(stringReducer).get());\n+      }\n+    }\n+\n+    @Nullable\n+    private ExprAnalysis analyzeExprs(List<Expr> exprs, Expr.ObjectBinding bindings)\n+    {\n+      Set<ExprType> presentTypes = EnumSet.noneOf(ExprType.class);\n+      List<ExprEval<?>> exprEvals = new ArrayList<>();\n+\n+      for (Expr expr : exprs) {\n+        ExprEval<?> exprEval = expr.eval(bindings);\n+        ExprType exprType = exprEval.type();\n+\n+        if (isValidType(exprType)) {\n+          presentTypes.add(exprType);\n+        }\n+\n+        if (exprEval.asString() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5OTkxNg==", "bodyText": "How about:\n\nEvaluates zero or more expressions and returns the maximum value based on comparisons as described above.\n\nI do think \"maximum\" is better than \"largest\" due to the ambiguity with strings.", "url": "https://github.com/apache/druid/pull/9488#discussion_r391099916", "createdAt": "2020-03-11T16:27:44Z", "author": {"login": "gianm"}, "path": "docs/misc/math-expr.md", "diffHunk": "@@ -181,6 +181,22 @@ See javadoc of java.lang.Math for detailed explanation for each function.\n | all(lambda,arr) | returns 1 if all elements in the array matches the lambda expression, else 0 |\n \n \n+### Reduction functions\n+\n+Reduction functions operate on zero or more expressions and return a single expression. If no expressions are passed\n+as arguments, then the result is `NULL`. The expressions must all be convertible to a\n+common data type, which will be the type of the result:\n+*  If any argument is `NULL`, the result is `NULL`.\n+*  If the arguments comprise a mix of numbers and strings, the arguments are interpreted as strings.\n+*  If all arguments are integer numbers, the arguments are interpreted as longs.\n+*  If all arguments are numbers and at least one argument is a double, the arguments are interpreted as doubles. \n+\n+| function | description |\n+| --- | --- |\n+| greatest([expr1, ...]) | Returns the maximum expression across zero or more expressions. |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTMzMA=="}, "originalCommit": {"oid": "44c4b5e40ec1cabde5ba5f76707f4eb535222989"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwNjczMQ==", "bodyText": "There are more SQL types than Druid types so we need to account for all the 'extras' too. (They can show up from literals, etc.) For example a DECIMAL or FLOAT could show up and we want to treat those as doubles for purposes of this logic.\nMostly we do this mapping by using Calcites.getValueTypeForSqlTypeName \u2014\u00a0try checking that out.", "url": "https://github.com/apache/druid/pull/9488#discussion_r391106731", "createdAt": "2020-03-11T16:37:44Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/builtin/ReductionOperatorConversionHelper.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.expression.builtin;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeFactory;\n+import org.apache.calcite.sql.type.SqlReturnTypeInference;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+\n+class ReductionOperatorConversionHelper\n+{\n+  private ReductionOperatorConversionHelper()\n+  {\n+  }\n+\n+  /**\n+   * Implements rules similar to: https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_least\n+   *\n+   * @see org.apache.druid.math.expr.Function.ReduceFunc#apply\n+   * @see org.apache.druid.math.expr.Function.ReduceFunc#getComparisionType\n+   */\n+  static final SqlReturnTypeInference TYPE_INFERENCE =\n+      opBinding -> {\n+        final RelDataTypeFactory typeFactory = opBinding.getTypeFactory();\n+\n+        final int n = opBinding.getOperandCount();\n+        if (n == 0) {\n+          return typeFactory.createSqlType(SqlTypeName.NULL);\n+        }\n+\n+        boolean hasDouble = false;\n+        for (int i = 0; i < n; i++) {\n+          RelDataType type = opBinding.getOperandType(i);\n+          if (SqlTypeUtil.isString(type) || SqlTypeUtil.isCharacter(type)) {\n+            return type;\n+          } else if (SqlTypeUtil.isDouble(type)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyOTM5ODE4", "url": "https://github.com/apache/druid/pull/9488#pullrequestreview-372939818", "createdAt": "2020-03-11T16:46:21Z", "commit": {"oid": "ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo0NjoyMVrOF0_n9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo0NjoyMVrOF0_n9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExMjY5Mw==", "bodyText": "Sorry if I'm mis-reading this.\nIt looks like this patch introduces expressions to calculate the greatest / least across multiple expressions. Native druid queries have a post aggregator that should do this. When I was thinking of implementing this I thought there would be a translation from sql to the native druid query with the correct post aggregator (maybe somewhere in here - OperatorConversions#toPostAggregator)\nOtherwise we'd want to make sure this behavior stays in sync with the Double/LongPostAggregators", "url": "https://github.com/apache/druid/pull/9488#discussion_r391112693", "createdAt": "2020-03-11T16:46:21Z", "author": {"login": "suneet-s"}, "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "diffHunk": "@@ -976,6 +981,163 @@ protected ExprEval eval(double x, double y)\n     }\n   }\n \n+  class GreatestFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"greatest\";\n+\n+    public GreatestFunc()\n+    {\n+      super(\n+          Math::max,\n+          Math::max,\n+          BinaryOperator.maxBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  class LeastFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"least\";\n+\n+    public LeastFunc()\n+    {\n+      super(\n+          Math::min,\n+          Math::min,\n+          BinaryOperator.minBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  abstract class ReduceFunc implements Function\n+  {\n+    private final DoubleBinaryOperator doubleReducer;\n+    private final LongBinaryOperator longReducer;\n+    private final BinaryOperator<String> stringReducer;\n+\n+    ReduceFunc(\n+        DoubleBinaryOperator doubleReducer,\n+        LongBinaryOperator longReducer,\n+        BinaryOperator<String> stringReducer\n+    )\n+    {\n+      this.doubleReducer = doubleReducer;\n+      this.longReducer = longReducer;\n+      this.stringReducer = stringReducer;\n+    }\n+\n+    @Override\n+    public void validateArguments(List<Expr> args)\n+    {\n+      // anything goes\n+    }\n+\n+    @Override\n+    public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n+    {\n+      if (args.isEmpty()) {\n+        return ExprEval.of(null);\n+      }\n+\n+      ExprAnalysis exprAnalysis = analyzeExprs(args, bindings);\n+      if (exprAnalysis == null) {\n+        // The GREATEST/LEAST functions are not in the SQL standard, but most (e.g., MySQL, Oracle) return NULL if any\n+        // are NULL. Others (e.g., Postgres) only return NULL if all are NULL, otherwise the NULLs are ignored.\n+        return ExprEval.of(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8"}, "originalPosition": 102}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a5a9610e9c6e10910059bc383238b5b88c5cbd6", "author": {"user": {"login": "ccaominh", "name": "Chi Cao Minh"}}, "url": "https://github.com/apache/druid/commit/1a5a9610e9c6e10910059bc383238b5b88c5cbd6", "committedDate": "2020-03-12T19:06:03Z", "message": "Match postgres behavior & handle more SQL types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f0fcc03ac04411af6f50607db22a67e2ca3ddf8", "author": {"user": {"login": "ccaominh", "name": "Chi Cao Minh"}}, "url": "https://github.com/apache/druid/commit/5f0fcc03ac04411af6f50607db22a67e2ca3ddf8", "committedDate": "2020-03-12T19:07:00Z", "message": "Merge remote-tracking branch 'upstream/master' into fix-greatest-least"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "643a3fc6fa82df975f72148971a64179958c25b7", "author": {"user": {"login": "ccaominh", "name": "Chi Cao Minh"}}, "url": "https://github.com/apache/druid/commit/643a3fc6fa82df975f72148971a64179958c25b7", "committedDate": "2020-03-12T19:10:25Z", "message": "Fix imports"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczODMzMjE3", "url": "https://github.com/apache/druid/pull/9488#pullrequestreview-373833217", "createdAt": "2020-03-12T19:15:11Z", "commit": {"oid": "643a3fc6fa82df975f72148971a64179958c25b7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2599, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}