{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxNzU0NDcy", "number": 9441, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxODoyNDowMlrODkw8yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMzoxMjo0N1rODmfk4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5ODc3MzIzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/druid/timeline/VersionedIntervalTimeline.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxODoyNDowMlrOFxRTRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNzo0NDoxOVrOFzy35w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwODAwNw==", "bodyText": "missing unit tests for this function?", "url": "https://github.com/apache/druid/pull/9441#discussion_r387208007", "createdAt": "2020-03-03T18:24:02Z", "author": {"login": "suneet-s"}, "path": "core/src/main/java/org/apache/druid/timeline/VersionedIntervalTimeline.java", "diffHunk": "@@ -161,11 +162,11 @@ public int getNumObjects()\n    */\n   public Set<ObjectType> findNonOvershadowedObjectsInInterval(Interval interval, Partitions completeness)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26edbff1a331956ff087924810568b32b46eaa27"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg1NTIwNw==", "bodyText": "Added some.", "url": "https://github.com/apache/druid/pull/9441#discussion_r389855207", "createdAt": "2020-03-09T17:44:19Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/timeline/VersionedIntervalTimeline.java", "diffHunk": "@@ -161,11 +162,11 @@ public int getNumObjects()\n    */\n   public Set<ObjectType> findNonOvershadowedObjectsInInterval(Interval interval, Partitions completeness)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwODAwNw=="}, "originalCommit": {"oid": "26edbff1a331956ff087924810568b32b46eaa27"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5OTAxMDA3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/druid/timeline/VersionedIntervalTimeline.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxOTozMzo0NFrOFxTo1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNzo0NjowNVrOFzy79g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI0NjI5Mw==", "bodyText": "Are we guaranteed that chunk.getObject will never be null?", "url": "https://github.com/apache/druid/pull/9441#discussion_r387246293", "createdAt": "2020-03-03T19:33:44Z", "author": {"login": "suneet-s"}, "path": "core/src/main/java/org/apache/druid/timeline/VersionedIntervalTimeline.java", "diffHunk": "@@ -482,7 +483,12 @@ public boolean isOvershadowed(Interval interval, VersionType version, ObjectType\n         if (versionCompare > 0) {\n           return false;\n         } else if (versionCompare == 0) {\n-          if (timelineEntry.partitionHolder.stream().noneMatch(chunk -> chunk.getObject().overshadows(object))) {\n+          // Intentionally use the Iterators API instead of the stream API for performance.\n+          //noinspection ConstantConditions\n+          final boolean nonOvershadowedObject = Iterators.all(\n+              timelineEntry.partitionHolder.iterator(), chunk -> !chunk.getObject().overshadows(object)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26edbff1a331956ff087924810568b32b46eaa27"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg1NjI0Ng==", "bodyText": "If you are asking whether we guarantee that programmatically, then I don't think so. But the object in the chunk should never be null.", "url": "https://github.com/apache/druid/pull/9441#discussion_r389856246", "createdAt": "2020-03-09T17:46:05Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/timeline/VersionedIntervalTimeline.java", "diffHunk": "@@ -482,7 +483,12 @@ public boolean isOvershadowed(Interval interval, VersionType version, ObjectType\n         if (versionCompare > 0) {\n           return false;\n         } else if (versionCompare == 0) {\n-          if (timelineEntry.partitionHolder.stream().noneMatch(chunk -> chunk.getObject().overshadows(object))) {\n+          // Intentionally use the Iterators API instead of the stream API for performance.\n+          //noinspection ConstantConditions\n+          final boolean nonOvershadowedObject = Iterators.all(\n+              timelineEntry.partitionHolder.iterator(), chunk -> !chunk.getObject().overshadows(object)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI0NjI5Mw=="}, "originalCommit": {"oid": "26edbff1a331956ff087924810568b32b46eaa27"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjQ3MzczOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/druid/timeline/partition/OvershadowableManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMDozMjo1MlrOFz4WKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMjowNToyMlrOFz6-Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk0NDg3NA==", "bodyText": "should this override public OvershadowableManager<T> clone() instead?", "url": "https://github.com/apache/druid/pull/9441#discussion_r389944874", "createdAt": "2020-03-09T20:32:52Z", "author": {"login": "suneet-s"}, "path": "core/src/main/java/org/apache/druid/timeline/partition/OvershadowableManager.java", "diffHunk": "@@ -105,12 +105,46 @@\n     this.overshadowedGroups = new TreeMap<>();\n   }\n \n-  OvershadowableManager(OvershadowableManager<T> other)\n+  public OvershadowableManager<T> copyVisible()\n   {\n-    this.knownPartitionChunks = new HashMap<>(other.knownPartitionChunks);\n-    this.standbyGroups = new TreeMap<>(other.standbyGroups);\n-    this.visibleGroupPerRange = new TreeMap<>(other.visibleGroupPerRange);\n-    this.overshadowedGroups = new TreeMap<>(other.overshadowedGroups);\n+    final OvershadowableManager<T> copy = new OvershadowableManager<>();\n+    visibleGroupPerRange.forEach((partitionRange, versionToGroups) -> {\n+      // There should be only one group per partition range\n+      final AtomicUpdateGroup<T> group = versionToGroups.values().iterator().next();\n+      group.getChunks().forEach(chunk -> copy.knownPartitionChunks.put(chunk.getChunkNumber(), chunk));\n+\n+      copy.visibleGroupPerRange.put(\n+          partitionRange,\n+          new SingleEntryShort2ObjectSortedMap<>(group.getMinorVersion(), AtomicUpdateGroup.copy(group))\n+      );\n+    });\n+    return copy;\n+  }\n+\n+  public OvershadowableManager<T> deepCopy()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "114bf34c62cac009270a81c1ddd580c65172fa93"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4Nzg3NQ==", "bodyText": "From the Item 13 (Override clone judiciously) of the book \"Effective Java\",\n\nIs all this complexity really necessary? Rarely. If you extend a class that already implements Cloneable, you have little choice but to implement a well-behaved clone method. Otherwise, you are usually better off providing an alternative means of object copying. A better approach to object copying is to provide a copy constructor or copy factory.\n\nI changed this method to a static factory based on this.", "url": "https://github.com/apache/druid/pull/9441#discussion_r389987875", "createdAt": "2020-03-09T22:05:22Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/timeline/partition/OvershadowableManager.java", "diffHunk": "@@ -105,12 +105,46 @@\n     this.overshadowedGroups = new TreeMap<>();\n   }\n \n-  OvershadowableManager(OvershadowableManager<T> other)\n+  public OvershadowableManager<T> copyVisible()\n   {\n-    this.knownPartitionChunks = new HashMap<>(other.knownPartitionChunks);\n-    this.standbyGroups = new TreeMap<>(other.standbyGroups);\n-    this.visibleGroupPerRange = new TreeMap<>(other.visibleGroupPerRange);\n-    this.overshadowedGroups = new TreeMap<>(other.overshadowedGroups);\n+    final OvershadowableManager<T> copy = new OvershadowableManager<>();\n+    visibleGroupPerRange.forEach((partitionRange, versionToGroups) -> {\n+      // There should be only one group per partition range\n+      final AtomicUpdateGroup<T> group = versionToGroups.values().iterator().next();\n+      group.getChunks().forEach(chunk -> copy.knownPartitionChunks.put(chunk.getChunkNumber(), chunk));\n+\n+      copy.visibleGroupPerRange.put(\n+          partitionRange,\n+          new SingleEntryShort2ObjectSortedMap<>(group.getMinorVersion(), AtomicUpdateGroup.copy(group))\n+      );\n+    });\n+    return copy;\n+  }\n+\n+  public OvershadowableManager<T> deepCopy()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk0NDg3NA=="}, "originalCommit": {"oid": "114bf34c62cac009270a81c1ddd580c65172fa93"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjQ3Nzc1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/druid/timeline/partition/OvershadowableManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMDozNDowM1rOFz4YgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMjowNToyN1rOFz6-SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk0NTQ3Mw==", "bodyText": "missing tests to verify that the returned copy is a deepCopy() - what if new fields are added to the overshadowable manager? Similar comments for copyVisible()", "url": "https://github.com/apache/druid/pull/9441#discussion_r389945473", "createdAt": "2020-03-09T20:34:03Z", "author": {"login": "suneet-s"}, "path": "core/src/main/java/org/apache/druid/timeline/partition/OvershadowableManager.java", "diffHunk": "@@ -105,12 +105,46 @@\n     this.overshadowedGroups = new TreeMap<>();\n   }\n \n-  OvershadowableManager(OvershadowableManager<T> other)\n+  public OvershadowableManager<T> copyVisible()\n   {\n-    this.knownPartitionChunks = new HashMap<>(other.knownPartitionChunks);\n-    this.standbyGroups = new TreeMap<>(other.standbyGroups);\n-    this.visibleGroupPerRange = new TreeMap<>(other.visibleGroupPerRange);\n-    this.overshadowedGroups = new TreeMap<>(other.overshadowedGroups);\n+    final OvershadowableManager<T> copy = new OvershadowableManager<>();\n+    visibleGroupPerRange.forEach((partitionRange, versionToGroups) -> {\n+      // There should be only one group per partition range\n+      final AtomicUpdateGroup<T> group = versionToGroups.values().iterator().next();\n+      group.getChunks().forEach(chunk -> copy.knownPartitionChunks.put(chunk.getChunkNumber(), chunk));\n+\n+      copy.visibleGroupPerRange.put(\n+          partitionRange,\n+          new SingleEntryShort2ObjectSortedMap<>(group.getMinorVersion(), AtomicUpdateGroup.copy(group))\n+      );\n+    });\n+    return copy;\n+  }\n+\n+  public OvershadowableManager<T> deepCopy()\n+  {\n+    final OvershadowableManager<T> copy = copyVisible();\n+    overshadowedGroups.forEach((partitionRange, versionToGroups) -> {\n+      // There should be only one group per partition range\n+      final AtomicUpdateGroup<T> group = versionToGroups.values().iterator().next();\n+      group.getChunks().forEach(chunk -> copy.knownPartitionChunks.put(chunk.getChunkNumber(), chunk));\n+\n+      copy.overshadowedGroups.put(\n+          partitionRange,\n+          new SingleEntryShort2ObjectSortedMap<>(group.getMinorVersion(), AtomicUpdateGroup.copy(group))\n+      );\n+    });\n+    standbyGroups.forEach((partitionRange, versionToGroups) -> {\n+      // There should be only one group per partition range\n+      final AtomicUpdateGroup<T> group = versionToGroups.values().iterator().next();\n+      group.getChunks().forEach(chunk -> copy.knownPartitionChunks.put(chunk.getChunkNumber(), chunk));\n+\n+      copy.standbyGroups.put(\n+          partitionRange,\n+          new SingleEntryShort2ObjectSortedMap<>(group.getMinorVersion(), AtomicUpdateGroup.copy(group))\n+      );\n+    });\n+    return copy;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "114bf34c62cac009270a81c1ddd580c65172fa93"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4NzkxMw==", "bodyText": "Added tests.", "url": "https://github.com/apache/druid/pull/9441#discussion_r389987913", "createdAt": "2020-03-09T22:05:27Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/timeline/partition/OvershadowableManager.java", "diffHunk": "@@ -105,12 +105,46 @@\n     this.overshadowedGroups = new TreeMap<>();\n   }\n \n-  OvershadowableManager(OvershadowableManager<T> other)\n+  public OvershadowableManager<T> copyVisible()\n   {\n-    this.knownPartitionChunks = new HashMap<>(other.knownPartitionChunks);\n-    this.standbyGroups = new TreeMap<>(other.standbyGroups);\n-    this.visibleGroupPerRange = new TreeMap<>(other.visibleGroupPerRange);\n-    this.overshadowedGroups = new TreeMap<>(other.overshadowedGroups);\n+    final OvershadowableManager<T> copy = new OvershadowableManager<>();\n+    visibleGroupPerRange.forEach((partitionRange, versionToGroups) -> {\n+      // There should be only one group per partition range\n+      final AtomicUpdateGroup<T> group = versionToGroups.values().iterator().next();\n+      group.getChunks().forEach(chunk -> copy.knownPartitionChunks.put(chunk.getChunkNumber(), chunk));\n+\n+      copy.visibleGroupPerRange.put(\n+          partitionRange,\n+          new SingleEntryShort2ObjectSortedMap<>(group.getMinorVersion(), AtomicUpdateGroup.copy(group))\n+      );\n+    });\n+    return copy;\n+  }\n+\n+  public OvershadowableManager<T> deepCopy()\n+  {\n+    final OvershadowableManager<T> copy = copyVisible();\n+    overshadowedGroups.forEach((partitionRange, versionToGroups) -> {\n+      // There should be only one group per partition range\n+      final AtomicUpdateGroup<T> group = versionToGroups.values().iterator().next();\n+      group.getChunks().forEach(chunk -> copy.knownPartitionChunks.put(chunk.getChunkNumber(), chunk));\n+\n+      copy.overshadowedGroups.put(\n+          partitionRange,\n+          new SingleEntryShort2ObjectSortedMap<>(group.getMinorVersion(), AtomicUpdateGroup.copy(group))\n+      );\n+    });\n+    standbyGroups.forEach((partitionRange, versionToGroups) -> {\n+      // There should be only one group per partition range\n+      final AtomicUpdateGroup<T> group = versionToGroups.values().iterator().next();\n+      group.getChunks().forEach(chunk -> copy.knownPartitionChunks.put(chunk.getChunkNumber(), chunk));\n+\n+      copy.standbyGroups.put(\n+          partitionRange,\n+          new SingleEntryShort2ObjectSortedMap<>(group.getMinorVersion(), AtomicUpdateGroup.copy(group))\n+      );\n+    });\n+    return copy;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk0NTQ3Mw=="}, "originalCommit": {"oid": "114bf34c62cac009270a81c1ddd580c65172fa93"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjQ5MzU3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/druid/server/coordinator/duty/NewestSegmentFirstIterator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMDozOTowNFrOFz4iTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMjowNTozMFrOFz6-YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk0Nzk4MA==", "bodyText": "Does the order of the segments matter?\nWhy not just calculate the min start and max end with O(n) implementation by looping over segments", "url": "https://github.com/apache/druid/pull/9441#discussion_r389947980", "createdAt": "2020-03-09T20:39:04Z", "author": {"login": "suneet-s"}, "path": "server/src/main/java/org/apache/druid/server/coordinator/duty/NewestSegmentFirstIterator.java", "diffHunk": "@@ -509,12 +509,13 @@ private SegmentsToCompact findSegmentsToCompact(\n     private QueueEntry(List<DataSegment> segments)\n     {\n       Preconditions.checkArgument(segments != null && !segments.isEmpty());\n-      Collections.sort(segments);\n+      final List<DataSegment> segmentsToSort = new ArrayList<>(segments);\n+      Collections.sort(segmentsToSort);\n       this.interval = new Interval(\n-          segments.get(0).getInterval().getStart(),\n-          segments.get(segments.size() - 1).getInterval().getEnd()\n+          segmentsToSort.get(0).getInterval().getStart(),\n+          segmentsToSort.get(segmentsToSort.size() - 1).getInterval().getEnd()\n       );\n-      this.segments = segments;\n+      this.segments = segmentsToSort;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "114bf34c62cac009270a81c1ddd580c65172fa93"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4NzkzNg==", "bodyText": "\ud83d\udc4d fixed.", "url": "https://github.com/apache/druid/pull/9441#discussion_r389987936", "createdAt": "2020-03-09T22:05:30Z", "author": {"login": "jihoonson"}, "path": "server/src/main/java/org/apache/druid/server/coordinator/duty/NewestSegmentFirstIterator.java", "diffHunk": "@@ -509,12 +509,13 @@ private SegmentsToCompact findSegmentsToCompact(\n     private QueueEntry(List<DataSegment> segments)\n     {\n       Preconditions.checkArgument(segments != null && !segments.isEmpty());\n-      Collections.sort(segments);\n+      final List<DataSegment> segmentsToSort = new ArrayList<>(segments);\n+      Collections.sort(segmentsToSort);\n       this.interval = new Interval(\n-          segments.get(0).getInterval().getStart(),\n-          segments.get(segments.size() - 1).getInterval().getEnd()\n+          segmentsToSort.get(0).getInterval().getStart(),\n+          segmentsToSort.get(segmentsToSort.size() - 1).getInterval().getEnd()\n       );\n-      this.segments = segments;\n+      this.segments = segmentsToSort;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk0Nzk4MA=="}, "originalCommit": {"oid": "114bf34c62cac009270a81c1ddd580c65172fa93"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjg5ODI1OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/druid/timeline/partition/OvershadowableManagerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMzoxMjo0N1rOFz8Y-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMzoyMDoyM1rOFz8ieg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTEyOA==", "bodyText": "Thanks for the tests! One last ask, since this depends on equals to be implemented correctly, I think we need another test for equals\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            \n          \n          \n            \n              @Test\n          \n          \n            \n              public void testEqualAndHashCodeContract()\n          \n          \n            \n              {\n          \n          \n            \n                EqualsVerifier.forClass(OvershadowableManager.class).usingGetClass().verify();\n          \n          \n            \n              }", "url": "https://github.com/apache/druid/pull/9441#discussion_r390011128", "createdAt": "2020-03-09T23:12:47Z", "author": {"login": "suneet-s"}, "path": "core/src/test/java/org/apache/druid/timeline/partition/OvershadowableManagerTest.java", "diffHunk": "@@ -63,6 +64,57 @@ public void setup()\n     expectedStandbyChunks = new ArrayList<>();\n   }\n \n+  @Test\n+  public void testCopyVisible()\n+  {\n+    // chunks of partition id 0 and 1\n+    manager.addChunk(newRootChunk());\n+    manager.addChunk(newRootChunk());\n+\n+    // chunks to overshadow the partition id range [0, 2)\n+    manager.addChunk(newNonRootChunk(0, 2, 1, 3));\n+    manager.addChunk(newNonRootChunk(0, 2, 1, 3));\n+    manager.addChunk(newNonRootChunk(0, 2, 1, 3));\n+\n+    // chunks of partition id 3 and 4\n+    manager.addChunk(newRootChunk());\n+    manager.addChunk(newRootChunk());\n+\n+    // standby chunk\n+    manager.addChunk(newNonRootChunk(2, 4, 1, 3));\n+\n+    OvershadowableManager<OvershadowableInteger> copy = OvershadowableManager.copyVisible(manager);\n+    Assert.assertTrue(copy.getOvershadowedChunks().isEmpty());\n+    Assert.assertTrue(copy.getStandbyChunks().isEmpty());\n+    Assert.assertEquals(\n+        Lists.newArrayList(manager.visibleChunksIterator()),\n+        Lists.newArrayList(copy.visibleChunksIterator())\n+    );\n+  }\n+\n+  @Test\n+  public void testDeepCopy()\n+  {\n+    // chunks of partition id 0 and 1\n+    manager.addChunk(newRootChunk());\n+    manager.addChunk(newRootChunk());\n+\n+    // chunks to overshadow the partition id range [0, 2)\n+    manager.addChunk(newNonRootChunk(0, 2, 1, 3));\n+    manager.addChunk(newNonRootChunk(0, 2, 1, 3));\n+    manager.addChunk(newNonRootChunk(0, 2, 1, 3));\n+\n+    // chunks of partition id 3 and 4\n+    manager.addChunk(newRootChunk());\n+    manager.addChunk(newRootChunk());\n+\n+    // standby chunk\n+    manager.addChunk(newNonRootChunk(2, 4, 1, 3));\n+\n+    OvershadowableManager<OvershadowableInteger> copy = OvershadowableManager.deepCopy(manager);\n+    Assert.assertEquals(manager, copy);\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b49262fa6df2b22d97c6605fb9bdcb3e58a0e8c0"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzU2Mg==", "bodyText": "Oops, added tests for OvershadowableManager and AtomicUpdateGroup.", "url": "https://github.com/apache/druid/pull/9441#discussion_r390013562", "createdAt": "2020-03-09T23:20:23Z", "author": {"login": "jihoonson"}, "path": "core/src/test/java/org/apache/druid/timeline/partition/OvershadowableManagerTest.java", "diffHunk": "@@ -63,6 +64,57 @@ public void setup()\n     expectedStandbyChunks = new ArrayList<>();\n   }\n \n+  @Test\n+  public void testCopyVisible()\n+  {\n+    // chunks of partition id 0 and 1\n+    manager.addChunk(newRootChunk());\n+    manager.addChunk(newRootChunk());\n+\n+    // chunks to overshadow the partition id range [0, 2)\n+    manager.addChunk(newNonRootChunk(0, 2, 1, 3));\n+    manager.addChunk(newNonRootChunk(0, 2, 1, 3));\n+    manager.addChunk(newNonRootChunk(0, 2, 1, 3));\n+\n+    // chunks of partition id 3 and 4\n+    manager.addChunk(newRootChunk());\n+    manager.addChunk(newRootChunk());\n+\n+    // standby chunk\n+    manager.addChunk(newNonRootChunk(2, 4, 1, 3));\n+\n+    OvershadowableManager<OvershadowableInteger> copy = OvershadowableManager.copyVisible(manager);\n+    Assert.assertTrue(copy.getOvershadowedChunks().isEmpty());\n+    Assert.assertTrue(copy.getStandbyChunks().isEmpty());\n+    Assert.assertEquals(\n+        Lists.newArrayList(manager.visibleChunksIterator()),\n+        Lists.newArrayList(copy.visibleChunksIterator())\n+    );\n+  }\n+\n+  @Test\n+  public void testDeepCopy()\n+  {\n+    // chunks of partition id 0 and 1\n+    manager.addChunk(newRootChunk());\n+    manager.addChunk(newRootChunk());\n+\n+    // chunks to overshadow the partition id range [0, 2)\n+    manager.addChunk(newNonRootChunk(0, 2, 1, 3));\n+    manager.addChunk(newNonRootChunk(0, 2, 1, 3));\n+    manager.addChunk(newNonRootChunk(0, 2, 1, 3));\n+\n+    // chunks of partition id 3 and 4\n+    manager.addChunk(newRootChunk());\n+    manager.addChunk(newRootChunk());\n+\n+    // standby chunk\n+    manager.addChunk(newNonRootChunk(2, 4, 1, 3));\n+\n+    OvershadowableManager<OvershadowableInteger> copy = OvershadowableManager.deepCopy(manager);\n+    Assert.assertEquals(manager, copy);\n+  }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTEyOA=="}, "originalCommit": {"oid": "b49262fa6df2b22d97c6605fb9bdcb3e58a0e8c0"}, "originalPosition": 62}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2808, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}