{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyOTAzOTE0", "number": 9187, "reviewThreads": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNjoxNDowOVrODYEnzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwOToxMDo1NFrODYbwhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTY4MTQzOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/AggregatorUtil.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNjoxNDowOVrOFduLtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzowNjo1NFrOFeJV3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcwOTY4NQ==", "bodyText": "I think you need a different byte for each type id here.\nAlso nitpicking here - can you add a comment above the group saying this is for the any aggregators", "url": "https://github.com/apache/druid/pull/9187#discussion_r366709685", "createdAt": "2020-01-15T06:14:09Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/AggregatorUtil.java", "diffHunk": "@@ -121,6 +121,11 @@\n \n   public static final byte MEAN_CACHE_TYPE_ID = 0x41;\n \n+  public static final byte LONG_ANY_CACHE_TYPE_ID = 0x42;\n+  public static final byte DOUBLE_ANY_CACHE_TYPE_ID = 0x42;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebd8fc0b75cd3269ab54863bd71b9224263d580d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExMDg2MQ==", "bodyText": "yes these need to be different values", "url": "https://github.com/apache/druid/pull/9187#discussion_r367110861", "createdAt": "2020-01-15T21:16:03Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/AggregatorUtil.java", "diffHunk": "@@ -121,6 +121,11 @@\n \n   public static final byte MEAN_CACHE_TYPE_ID = 0x41;\n \n+  public static final byte LONG_ANY_CACHE_TYPE_ID = 0x42;\n+  public static final byte DOUBLE_ANY_CACHE_TYPE_ID = 0x42;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcwOTY4NQ=="}, "originalCommit": {"oid": "ebd8fc0b75cd3269ab54863bd71b9224263d580d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1NDY1Mg==", "bodyText": "Copy+Paste and forgot to change the value. Done.", "url": "https://github.com/apache/druid/pull/9187#discussion_r367154652", "createdAt": "2020-01-15T23:06:54Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/AggregatorUtil.java", "diffHunk": "@@ -121,6 +121,11 @@\n \n   public static final byte MEAN_CACHE_TYPE_ID = 0x41;\n \n+  public static final byte LONG_ANY_CACHE_TYPE_ID = 0x42;\n+  public static final byte DOUBLE_ANY_CACHE_TYPE_ID = 0x42;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcwOTY4NQ=="}, "originalCommit": {"oid": "ebd8fc0b75cd3269ab54863bd71b9224263d580d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzY2MTQ1OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzo1Mzo0MlrOFeBIsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzowNzozMFrOFeJW1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMDIxMA==", "bodyText": "nit: javadocs please - I know most of the aggregators don't have docs, but I think explaining how nulls should be handled in this class is valuable", "url": "https://github.com/apache/druid/pull/9187#discussion_r367020210", "createdAt": "2020-01-15T17:53:42Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1NDkwMw==", "bodyText": "Done.", "url": "https://github.com/apache/druid/pull/9187#discussion_r367154903", "createdAt": "2020-01-15T23:07:30Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMDIxMA=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzY4NTIxOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODowMTo0OVrOFeBXjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzoxNjoxNlrOFeJg6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNDAxNA==", "bodyText": "I think you should store this as a primitive so we don't have to do un-necessary boxing. Also I think we need another variable in here to track whether the value is null or not. We would need to implement isNull for the aggregator.", "url": "https://github.com/apache/druid/pull/9187#discussion_r367024014", "createdAt": "2020-01-15T18:01:49Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator\n+{\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  private Double foundValue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA2MDE1Mw==", "bodyText": "As mentioned before we don't have to worry about null. This is just considering which is more optimize between checking if Double is null or checking if boolean is T/F (and I guess memory for storing one Double vs. storing one double and one Boolean)", "url": "https://github.com/apache/druid/pull/9187#discussion_r367060153", "createdAt": "2020-01-15T19:20:34Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator\n+{\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  private Double foundValue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNDAxNA=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExOTk3Nw==", "bodyText": "Since this is created by NullableNumericAggregatorFactory it can be a primitive. NullableNumericAggregator and NullableNumericBufferAggregator will initialize to a null value, so aggregate will never be called unless you encounter a not null value.", "url": "https://github.com/apache/druid/pull/9187#discussion_r367119977", "createdAt": "2020-01-15T21:36:58Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator\n+{\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  private Double foundValue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNDAxNA=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyNjA5MA==", "bodyText": "I would also go with primitive double and a boolean found, we can avoid the boxing and I don't think using one Double object would save memory compared to double+boolean", "url": "https://github.com/apache/druid/pull/9187#discussion_r367126090", "createdAt": "2020-01-15T21:51:23Z", "author": {"login": "jon-wei"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator\n+{\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  private Double foundValue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNDAxNA=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1NzQ4MA==", "bodyText": "Done.", "url": "https://github.com/apache/druid/pull/9187#discussion_r367157480", "createdAt": "2020-01-15T23:16:16Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator\n+{\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  private Double foundValue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNDAxNA=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzY5ODU1OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODowNjo0MVrOFeBf9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOToxODozMlrOFeDhIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNjE2Nw==", "bodyText": "This can throw an NPE if isNull is true. I can't tell if this is called from a hot loop or not. @clintropolis or @jon-wei might know how we should deal with this. I see this potential NPE in other aggregators as well.\nIf you switch to using a primitive in the class, then all these getters can simply cast the local variable", "url": "https://github.com/apache/druid/pull/9187#discussion_r367026167", "createdAt": "2020-01-15T18:06:41Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator\n+{\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  private Double foundValue;\n+\n+  public DoubleAnyAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+    foundValue = null;\n+  }\n+\n+  @Override\n+  public void aggregate()\n+  {\n+    if (foundValue == null && !valueSelector.isNull()) {\n+      foundValue = valueSelector.getDouble();\n+    }\n+  }\n+\n+  @Override\n+  public Object get()\n+  {\n+    return foundValue;\n+  }\n+\n+  @Override\n+  public float getFloat()\n+  {\n+    return foundValue.floatValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1OTIzMw==", "bodyText": "(Double/Float/Long)AnyAggregators are created by the (Double/Float/Long)AnyAggregatorFactory. The (Double/Float/Long)AnyAggregatorFactory extends from NullableNumericAggregatorFactory. NullableNumericAggregatorFactory will handle the Null for the (Double/Float/Long)AnyAggregators. If useDefaultValueForNull=true then we don't have to worry about null since all null will be convert to non-null (i.e. 0) before aggregation. If useDefaultValueForNull=false then the NullableNumericAggregatorFactory will wrap the AnyAggregators in NullableNumericAggregator which already have isNull check. (Those methods like getFloat also won't be call if isNull is true)", "url": "https://github.com/apache/druid/pull/9187#discussion_r367059233", "createdAt": "2020-01-15T19:18:32Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator\n+{\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  private Double foundValue;\n+\n+  public DoubleAnyAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+    foundValue = null;\n+  }\n+\n+  @Override\n+  public void aggregate()\n+  {\n+    if (foundValue == null && !valueSelector.isNull()) {\n+      foundValue = valueSelector.getDouble();\n+    }\n+  }\n+\n+  @Override\n+  public Object get()\n+  {\n+    return foundValue;\n+  }\n+\n+  @Override\n+  public float getFloat()\n+  {\n+    return foundValue.floatValue();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNjE2Nw=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzcwMDk0OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODowNzo0M1rOFeBhoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzoxNzozOVrOFeJifg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNjU5Mg==", "bodyText": "nit: Add a comment explaining why this function is empty to indicate it is intentional", "url": "https://github.com/apache/druid/pull/9187#discussion_r367026592", "createdAt": "2020-01-15T18:07:43Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator\n+{\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  private Double foundValue;\n+\n+  public DoubleAnyAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+    foundValue = null;\n+  }\n+\n+  @Override\n+  public void aggregate()\n+  {\n+    if (foundValue == null && !valueSelector.isNull()) {\n+      foundValue = valueSelector.getDouble();\n+    }\n+  }\n+\n+  @Override\n+  public Object get()\n+  {\n+    return foundValue;\n+  }\n+\n+  @Override\n+  public float getFloat()\n+  {\n+    return foundValue.floatValue();\n+  }\n+\n+  @Override\n+  public long getLong()\n+  {\n+    return foundValue.longValue();\n+  }\n+\n+  @Override\n+  public double getDouble()\n+  {\n+    return foundValue;\n+  }\n+\n+  @Override\n+  public void close()\n+  {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1Nzg4Ng==", "bodyText": "Done", "url": "https://github.com/apache/druid/pull/9187#discussion_r367157886", "createdAt": "2020-01-15T23:17:39Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator\n+{\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  private Double foundValue;\n+\n+  public DoubleAnyAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+    foundValue = null;\n+  }\n+\n+  @Override\n+  public void aggregate()\n+  {\n+    if (foundValue == null && !valueSelector.isNull()) {\n+      foundValue = valueSelector.getDouble();\n+    }\n+  }\n+\n+  @Override\n+  public Object get()\n+  {\n+    return foundValue;\n+  }\n+\n+  @Override\n+  public float getFloat()\n+  {\n+    return foundValue.floatValue();\n+  }\n+\n+  @Override\n+  public long getLong()\n+  {\n+    return foundValue.longValue();\n+  }\n+\n+  @Override\n+  public double getDouble()\n+  {\n+    return foundValue;\n+  }\n+\n+  @Override\n+  public void close()\n+  {\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNjU5Mg=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzcyNzg5OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODoxNzoyMVrOFeBytQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzo0MzoyMlrOFeJ-gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMDk2NQ==", "bodyText": "Shouldn't we be looking at storeDoubleAsFloat  as well for equalsAndHashCode?\nCan we add an EqualsVerifierTest for this?", "url": "https://github.com/apache/druid/pull/9187#discussion_r367030965", "createdAt": "2020-01-15T18:17:21Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Arrays.asList(fieldName);\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    byte[] fieldNameBytes = StringUtils.toUtf8(fieldName);\n+\n+    return ByteBuffer.allocate(1 + fieldNameBytes.length)\n+                     .put(AggregatorUtil.DOUBLE_ANY_CACHE_TYPE_ID)\n+                     .put(fieldNameBytes)\n+                     .array();\n+  }\n+\n+  @Override\n+  public String getTypeName()\n+  {\n+    if (storeDoubleAsFloat) {\n+      return \"float\";\n+    }\n+    return \"double\";\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Double.BYTES;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o)\n+  {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    DoubleAnyAggregatorFactory that = (DoubleAnyAggregatorFactory) o;\n+\n+    return name.equals(that.name) && fieldName.equals(that.fieldName);\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Objects.hash(name, fieldName);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1ODMyNg==", "bodyText": "No idea. DoubleFirstAggregatorFactory does not look at storeDoubleAsFloat for hashCode.", "url": "https://github.com/apache/druid/pull/9187#discussion_r367158326", "createdAt": "2020-01-15T23:19:13Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Arrays.asList(fieldName);\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    byte[] fieldNameBytes = StringUtils.toUtf8(fieldName);\n+\n+    return ByteBuffer.allocate(1 + fieldNameBytes.length)\n+                     .put(AggregatorUtil.DOUBLE_ANY_CACHE_TYPE_ID)\n+                     .put(fieldNameBytes)\n+                     .array();\n+  }\n+\n+  @Override\n+  public String getTypeName()\n+  {\n+    if (storeDoubleAsFloat) {\n+      return \"float\";\n+    }\n+    return \"double\";\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Double.BYTES;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o)\n+  {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    DoubleAnyAggregatorFactory that = (DoubleAnyAggregatorFactory) o;\n+\n+    return name.equals(that.name) && fieldName.equals(that.fieldName);\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Objects.hash(name, fieldName);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMDk2NQ=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2NTA1Nw==", "bodyText": "Actually gonna remove storeDoubleAsFloat", "url": "https://github.com/apache/druid/pull/9187#discussion_r367165057", "createdAt": "2020-01-15T23:43:22Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Arrays.asList(fieldName);\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    byte[] fieldNameBytes = StringUtils.toUtf8(fieldName);\n+\n+    return ByteBuffer.allocate(1 + fieldNameBytes.length)\n+                     .put(AggregatorUtil.DOUBLE_ANY_CACHE_TYPE_ID)\n+                     .put(fieldNameBytes)\n+                     .array();\n+  }\n+\n+  @Override\n+  public String getTypeName()\n+  {\n+    if (storeDoubleAsFloat) {\n+      return \"float\";\n+    }\n+    return \"double\";\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Double.BYTES;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o)\n+  {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    DoubleAnyAggregatorFactory that = (DoubleAnyAggregatorFactory) o;\n+\n+    return name.equals(that.name) && fieldName.equals(that.fieldName);\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Objects.hash(name, fieldName);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMDk2NQ=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzcyOTY3OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODoxNzo1N1rOFeBz2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzo0MzozNFrOFeJ-yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMTI1Nw==", "bodyText": "Similar comment to above...\nUgh I can't wait till we can hide all of this away with lombok", "url": "https://github.com/apache/druid/pull/9187#discussion_r367031257", "createdAt": "2020-01-15T18:17:57Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Arrays.asList(fieldName);\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    byte[] fieldNameBytes = StringUtils.toUtf8(fieldName);\n+\n+    return ByteBuffer.allocate(1 + fieldNameBytes.length)\n+                     .put(AggregatorUtil.DOUBLE_ANY_CACHE_TYPE_ID)\n+                     .put(fieldNameBytes)\n+                     .array();\n+  }\n+\n+  @Override\n+  public String getTypeName()\n+  {\n+    if (storeDoubleAsFloat) {\n+      return \"float\";\n+    }\n+    return \"double\";\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Double.BYTES;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o)\n+  {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    DoubleAnyAggregatorFactory that = (DoubleAnyAggregatorFactory) o;\n+\n+    return name.equals(that.name) && fieldName.equals(that.fieldName);\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Objects.hash(name, fieldName);\n+  }\n+\n+  @Override\n+  public String toString()\n+  {\n+    return \"DoubleAnyAggregatorFactory{\" +\n+           \"name='\" + name + '\\'' +\n+           \", fieldName='\" + fieldName + '\\'' +\n+           '}';\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1ODk5Nw==", "bodyText": "No idea. DoubleFirstAggregatorFactory does not look at storeDoubleAsFloat for hashCode.", "url": "https://github.com/apache/druid/pull/9187#discussion_r367158997", "createdAt": "2020-01-15T23:21:34Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Arrays.asList(fieldName);\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    byte[] fieldNameBytes = StringUtils.toUtf8(fieldName);\n+\n+    return ByteBuffer.allocate(1 + fieldNameBytes.length)\n+                     .put(AggregatorUtil.DOUBLE_ANY_CACHE_TYPE_ID)\n+                     .put(fieldNameBytes)\n+                     .array();\n+  }\n+\n+  @Override\n+  public String getTypeName()\n+  {\n+    if (storeDoubleAsFloat) {\n+      return \"float\";\n+    }\n+    return \"double\";\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Double.BYTES;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o)\n+  {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    DoubleAnyAggregatorFactory that = (DoubleAnyAggregatorFactory) o;\n+\n+    return name.equals(that.name) && fieldName.equals(that.fieldName);\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Objects.hash(name, fieldName);\n+  }\n+\n+  @Override\n+  public String toString()\n+  {\n+    return \"DoubleAnyAggregatorFactory{\" +\n+           \"name='\" + name + '\\'' +\n+           \", fieldName='\" + fieldName + '\\'' +\n+           '}';\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMTI1Nw=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2NTEyOA==", "bodyText": "Actually gonna remove storeDoubleAsFloat", "url": "https://github.com/apache/druid/pull/9187#discussion_r367165128", "createdAt": "2020-01-15T23:43:34Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Arrays.asList(fieldName);\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    byte[] fieldNameBytes = StringUtils.toUtf8(fieldName);\n+\n+    return ByteBuffer.allocate(1 + fieldNameBytes.length)\n+                     .put(AggregatorUtil.DOUBLE_ANY_CACHE_TYPE_ID)\n+                     .put(fieldNameBytes)\n+                     .array();\n+  }\n+\n+  @Override\n+  public String getTypeName()\n+  {\n+    if (storeDoubleAsFloat) {\n+      return \"float\";\n+    }\n+    return \"double\";\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Double.BYTES;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o)\n+  {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    DoubleAnyAggregatorFactory that = (DoubleAnyAggregatorFactory) o;\n+\n+    return name.equals(that.name) && fieldName.equals(that.fieldName);\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Objects.hash(name, fieldName);\n+  }\n+\n+  @Override\n+  public String toString()\n+  {\n+    return \"DoubleAnyAggregatorFactory{\" +\n+           \"name='\" + name + '\\'' +\n+           \", fieldName='\" + fieldName + '\\'' +\n+           '}';\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMTI1Nw=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzczODMzOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODoyMTowMVrOFeB5bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzo0Mzo0MVrOFeJ-6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMjY4Ng==", "bodyText": "not sure if this makes a difference or not, but won't the max size be Float.BYTES if storeDoubleAsFloat is true?\nI see the pattern you used is the same as what's used in DoubleFirstAggregatorFactory - probably a bug in both?", "url": "https://github.com/apache/druid/pull/9187#discussion_r367032686", "createdAt": "2020-01-15T18:21:01Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Arrays.asList(fieldName);\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    byte[] fieldNameBytes = StringUtils.toUtf8(fieldName);\n+\n+    return ByteBuffer.allocate(1 + fieldNameBytes.length)\n+                     .put(AggregatorUtil.DOUBLE_ANY_CACHE_TYPE_ID)\n+                     .put(fieldNameBytes)\n+                     .array();\n+  }\n+\n+  @Override\n+  public String getTypeName()\n+  {\n+    if (storeDoubleAsFloat) {\n+      return \"float\";\n+    }\n+    return \"double\";\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Double.BYTES;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2NTE2MA==", "bodyText": "Actually gonna remove storeDoubleAsFloat", "url": "https://github.com/apache/druid/pull/9187#discussion_r367165160", "createdAt": "2020-01-15T23:43:41Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Arrays.asList(fieldName);\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    byte[] fieldNameBytes = StringUtils.toUtf8(fieldName);\n+\n+    return ByteBuffer.allocate(1 + fieldNameBytes.length)\n+                     .put(AggregatorUtil.DOUBLE_ANY_CACHE_TYPE_ID)\n+                     .put(fieldNameBytes)\n+                     .array();\n+  }\n+\n+  @Override\n+  public String getTypeName()\n+  {\n+    if (storeDoubleAsFloat) {\n+      return \"float\";\n+    }\n+    return \"double\";\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Double.BYTES;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMjY4Ng=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2Nzc0MjQ0OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODoyMjoxMVrOFeB77g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzoyMzo0MVrOFeJpGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMzMyNg==", "bodyText": "nit: Collections.singletonList(fieldName)", "url": "https://github.com/apache/druid/pull/9187#discussion_r367033326", "createdAt": "2020-01-15T18:22:11Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Arrays.asList(fieldName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1OTU3Nw==", "bodyText": "Done", "url": "https://github.com/apache/druid/pull/9187#discussion_r367159577", "createdAt": "2020-01-15T23:23:41Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Arrays.asList(fieldName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMzMyNg=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2Nzc2NDQ3OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODoyOTozMVrOFeCJuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzoyNzowN1rOFeJtHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzNjg1Nw==", "bodyText": "I don't understand why both the parameters here are fieldName and both the parameters in getCombiningFactory are name - I see this pattern used in all the aggregators", "url": "https://github.com/apache/druid/pull/9187#discussion_r367036857", "createdAt": "2020-01-15T18:29:31Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MDUzOQ==", "bodyText": "There's javadoc on AggregatorFactory class. But i think it's like reusing input output fields", "url": "https://github.com/apache/druid/pull/9187#discussion_r367160539", "createdAt": "2020-01-15T23:26:55Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzNjg1Nw=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MDYwNA==", "bodyText": "getCombiningFactory are combining between segments", "url": "https://github.com/apache/druid/pull/9187#discussion_r367160604", "createdAt": "2020-01-15T23:27:07Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzNjg1Nw=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2Nzc4NTA4OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODozNjozNFrOFeCWzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzoyODo0N1rOFeJu1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0MDIwNQ==", "bodyText": "Is this so that missing values show up first? Is that the behavior we want? I don't know the answer...", "url": "https://github.com/apache/druid/pull/9187#discussion_r367040205", "createdAt": "2020-01-15T18:36:34Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MTA0NQ==", "bodyText": "Not sure I understand the question. This is for sorting the aggregated result. I think it does not really matters", "url": "https://github.com/apache/druid/pull/9187#discussion_r367161045", "createdAt": "2020-01-15T23:28:47Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0MDIwNQ=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2Nzc5ODY1OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODo0MTo0M1rOFeCfiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzo0Njo1NlrOFeKCeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0MjQ0MQ==", "bodyText": "I know this is an existing pattern, but I prefer having a package private all args constructor to make unit testing easier and have the JsonCreator constructor call the all args constructor. Otherwise the tests need to rely on the static implementation of ColumnHolder#storeDoubleAsFloat which can be a huge pain to try and mock correctly.", "url": "https://github.com/apache/druid/pull/9187#discussion_r367042441", "createdAt": "2020-01-15T18:41:43Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjA2NA==", "bodyText": "Not sure if the storeDoubleAsFloat is even needed.", "url": "https://github.com/apache/druid/pull/9187#discussion_r367162064", "createdAt": "2020-01-15T23:32:06Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0MjQ0MQ=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2NjA3NA==", "bodyText": "Actually gonna remove storeDoubleAsFloat", "url": "https://github.com/apache/druid/pull/9187#discussion_r367166074", "createdAt": "2020-01-15T23:46:56Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0MjQ0MQ=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzgwMDU4OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODo0MjoyNVrOFeCgxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzozNzo0MVrOFeJ4eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0Mjc1Ng==", "bodyText": "nit: Comment for empty function please", "url": "https://github.com/apache/druid/pull/9187#discussion_r367042756", "createdAt": "2020-01-15T18:42:25Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+public class DoubleAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final double NULL_VALUE = 0;\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  public DoubleAnyBufferAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+  }\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.putDouble(position, NULL_VALUE);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position)\n+  {\n+    if (buf.getDouble(position) == NULL_VALUE && !valueSelector.isNull()) {\n+      buf.putDouble(position, valueSelector.getDouble());\n+    }\n+  }\n+\n+  @Override\n+  public Object get(ByteBuffer buf, int position)\n+  {\n+    return buf.getDouble(position);\n+  }\n+\n+  @Override\n+  public float getFloat(ByteBuffer buf, int position)\n+  {\n+    return (float) buf.getDouble(position);\n+  }\n+\n+  @Override\n+  public long getLong(ByteBuffer buf, int position)\n+  {\n+    return (long) buf.getDouble(position);\n+  }\n+\n+  @Override\n+  public double getDouble(ByteBuffer buf, int position)\n+  {\n+    return buf.getDouble(position);\n+  }\n+\n+  @Override\n+  public void close()\n+  {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MzUxMg==", "bodyText": "Done", "url": "https://github.com/apache/druid/pull/9187#discussion_r367163512", "createdAt": "2020-01-15T23:37:41Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+public class DoubleAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final double NULL_VALUE = 0;\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  public DoubleAnyBufferAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+  }\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.putDouble(position, NULL_VALUE);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position)\n+  {\n+    if (buf.getDouble(position) == NULL_VALUE && !valueSelector.isNull()) {\n+      buf.putDouble(position, valueSelector.getDouble());\n+    }\n+  }\n+\n+  @Override\n+  public Object get(ByteBuffer buf, int position)\n+  {\n+    return buf.getDouble(position);\n+  }\n+\n+  @Override\n+  public float getFloat(ByteBuffer buf, int position)\n+  {\n+    return (float) buf.getDouble(position);\n+  }\n+\n+  @Override\n+  public long getLong(ByteBuffer buf, int position)\n+  {\n+    return (long) buf.getDouble(position);\n+  }\n+\n+  @Override\n+  public double getDouble(ByteBuffer buf, int position)\n+  {\n+    return buf.getDouble(position);\n+  }\n+\n+  @Override\n+  public void close()\n+  {\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0Mjc1Ng=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzgwNzg1OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODo0NToyMVrOFeCliw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzo1MTo0NVrOFeKHsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0Mzk3OQ==", "bodyText": "0 is a valid value for a double. I think Double.NaN is safer to indicate that the value is not found.\nSimilar comments to DoubleAnyAggregator - I think you need to store a byte to indicate whether or not the value has been found since 0, NaN, etc. are all valid values that can show up in a double column.", "url": "https://github.com/apache/druid/pull/9187#discussion_r367043979", "createdAt": "2020-01-15T18:45:21Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+public class DoubleAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final double NULL_VALUE = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2NzQwOQ==", "bodyText": "Added byte to indicate whether or not the value has been found. We actually do not get null due to the NullableNumericAggregatorFactory/ NullableNumericAggregator stuff", "url": "https://github.com/apache/druid/pull/9187#discussion_r367167409", "createdAt": "2020-01-15T23:51:45Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+public class DoubleAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final double NULL_VALUE = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0Mzk3OQ=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzgyNzkzOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/first/StringAggregatorUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODo1MjoyN1rOFeCyMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzo1MjoyOFrOFeKIbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0NzIxNg==", "bodyText": "Why was this change needed?", "url": "https://github.com/apache/druid/pull/9187#discussion_r367047216", "createdAt": "2020-01-15T18:52:27Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/first/StringAggregatorUtils.java", "diffHunk": "@@ -87,7 +87,7 @@ public static void writePair(\n \n     if (pair.rhs != null) {\n       mutationBuffer.position(position + Long.BYTES + Integer.BYTES);\n-      mutationBuffer.limit(maxStringBytes);\n+      mutationBuffer.limit(position + Long.BYTES + Integer.BYTES + maxStringBytes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA4NTExMA==", "bodyText": "This is to fix an existing bug i found. The limit method for buffer sets it at absolute position. The correct limit should be maxStringBytes after where we are writing the String to the buffer (which is position + Long.BYTES + Integer.BYTES). Hence, limit should be position + Long.BYTES + Integer.BYTES + maxStringBytes", "url": "https://github.com/apache/druid/pull/9187#discussion_r367085110", "createdAt": "2020-01-15T20:15:19Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/first/StringAggregatorUtils.java", "diffHunk": "@@ -87,7 +87,7 @@ public static void writePair(\n \n     if (pair.rhs != null) {\n       mutationBuffer.position(position + Long.BYTES + Integer.BYTES);\n-      mutationBuffer.limit(maxStringBytes);\n+      mutationBuffer.limit(position + Long.BYTES + Integer.BYTES + maxStringBytes);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0NzIxNg=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2NzU5OA==", "bodyText": "Removed this. Will fix as part of separate PR", "url": "https://github.com/apache/druid/pull/9187#discussion_r367167598", "createdAt": "2020-01-15T23:52:28Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/first/StringAggregatorUtils.java", "diffHunk": "@@ -87,7 +87,7 @@ public static void writePair(\n \n     if (pair.rhs != null) {\n       mutationBuffer.position(position + Long.BYTES + Integer.BYTES);\n-      mutationBuffer.limit(maxStringBytes);\n+      mutationBuffer.limit(position + Long.BYTES + Integer.BYTES + maxStringBytes);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0NzIxNg=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2ODI1NTgxOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMToyNzo0NFrOFeG_EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMzo1NDo0MlrOFeKKtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExNjA0OQ==", "bodyText": "valueSelector.isNull() will never be true since this the factory is NullableNumericAggregatorFactory", "url": "https://github.com/apache/druid/pull/9187#discussion_r367116049", "createdAt": "2020-01-15T21:27:44Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator\n+{\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  private Double foundValue;\n+\n+  public DoubleAnyAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+    foundValue = null;\n+  }\n+\n+  @Override\n+  public void aggregate()\n+  {\n+    if (foundValue == null && !valueSelector.isNull()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9b71131991216c9265af15e72407159825762b8"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2ODE4Mg==", "bodyText": "Removed.", "url": "https://github.com/apache/druid/pull/9187#discussion_r367168182", "createdAt": "2020-01-15T23:54:42Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator\n+{\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  private Double foundValue;\n+\n+  public DoubleAnyAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+    foundValue = null;\n+  }\n+\n+  @Override\n+  public void aggregate()\n+  {\n+    if (foundValue == null && !valueSelector.isNull()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExNjA0OQ=="}, "originalCommit": {"oid": "a9b71131991216c9265af15e72407159825762b8"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2ODI4Mjc5OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMTozODowOVrOFeHQQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwMToxNzowNVrOFeLaYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyMDQ0OQ==", "bodyText": "I think this could be SimpleDoubleAggregatorFactory", "url": "https://github.com/apache/druid/pull/9187#discussion_r367120449", "createdAt": "2020-01-15T21:38:09Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9b71131991216c9265af15e72407159825762b8"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE4ODU3OA==", "bodyText": "Done", "url": "https://github.com/apache/druid/pull/9187#discussion_r367188578", "createdAt": "2020-01-16T01:17:05Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyMDQ0OQ=="}, "originalCommit": {"oid": "a9b71131991216c9265af15e72407159825762b8"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2ODgxNTc0OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwMjozMTo0NFrOFeMYxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNjo0MDo1OVrOFePWnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNDU1MA==", "bodyText": "This method and similar could use CacheKeyBuilder instead", "url": "https://github.com/apache/druid/pull/9187#discussion_r367204550", "createdAt": "2020-01-16T02:31:44Z", "author": {"login": "jon-wei"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JacksonInject;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.DoubleMaxAggregator;\n+import org.apache.druid.query.aggregation.DoubleMaxBufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.query.aggregation.SimpleDoubleAggregatorFactory;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends SimpleDoubleAggregatorFactory\n+{\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName,\n+      @JsonProperty(\"expression\") @Nullable String expression,\n+      @JacksonInject ExprMacroTable macroTable\n+  )\n+  {\n+    super(macroTable, name, fieldName, expression);\n+  }\n+\n+  public DoubleAnyAggregatorFactory(String name, String fieldName)\n+  {\n+    this(name, fieldName, null, ExprMacroTable.nil());\n+  }\n+\n+  @Override\n+  protected double nullValue()\n+  {\n+    return Double.NaN;\n+  }\n+\n+  @Override\n+  protected Aggregator buildAggregator(BaseDoubleColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator buildBufferAggregator(BaseDoubleColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name, null, macroTable);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName, expression, macroTable));\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    byte[] fieldNameBytes = StringUtils.toUtf8WithNullToEmpty(fieldName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI1MzE0OA==", "bodyText": "Done!", "url": "https://github.com/apache/druid/pull/9187#discussion_r367253148", "createdAt": "2020-01-16T06:40:59Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JacksonInject;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.DoubleMaxAggregator;\n+import org.apache.druid.query.aggregation.DoubleMaxBufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.query.aggregation.SimpleDoubleAggregatorFactory;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends SimpleDoubleAggregatorFactory\n+{\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName,\n+      @JsonProperty(\"expression\") @Nullable String expression,\n+      @JacksonInject ExprMacroTable macroTable\n+  )\n+  {\n+    super(macroTable, name, fieldName, expression);\n+  }\n+\n+  public DoubleAnyAggregatorFactory(String name, String fieldName)\n+  {\n+    this(name, fieldName, null, ExprMacroTable.nil());\n+  }\n+\n+  @Override\n+  protected double nullValue()\n+  {\n+    return Double.NaN;\n+  }\n+\n+  @Override\n+  protected Aggregator buildAggregator(BaseDoubleColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator buildBufferAggregator(BaseDoubleColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name, null, macroTable);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName, expression, macroTable));\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    byte[] fieldNameBytes = StringUtils.toUtf8WithNullToEmpty(fieldName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNDU1MA=="}, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2ODgxNjgwOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwMjozMjo0NVrOFeMZgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNjo0OTo1M1rOFePfhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNDczOA==", "bodyText": "nit: suggest setting the IS_SET byte first before the double value, since that's the order they appear in the buffer", "url": "https://github.com/apache/druid/pull/9187#discussion_r367204738", "createdAt": "2020-01-16T02:32:45Z", "author": {"login": "jon-wei"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * This Aggregator is created by the {@link DoubleAnyAggregatorFactory} which extends from\n+ * {@link NullableNumericAggregatorFactory}. If null needs to be handle, then {@link NullableNumericAggregatorFactory}\n+ * will wrap this aggregator in {@link NullableNumericAggregator} and can handle all null in that class.\n+ * Hence, no null will ever be pass into this aggregator from the valueSelector.\n+ */\n+public class DoubleAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n+  private static final byte BYTE_FLAG_IS_SET = 1;\n+  private static final double NULL_VALUE = 0;\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  public DoubleAnyBufferAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+  }\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, BYTE_FLAG_IS_NOT_SET);\n+    buf.putDouble(position + Byte.BYTES, NULL_VALUE);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position)\n+  {\n+    if (buf.get(position) == BYTE_FLAG_IS_NOT_SET) {\n+      buf.putDouble(position + Byte.BYTES, valueSelector.getDouble());\n+      buf.put(position, BYTE_FLAG_IS_SET);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMTAzMA==", "bodyText": "I agree on put ordering", "url": "https://github.com/apache/druid/pull/9187#discussion_r367231030", "createdAt": "2020-01-16T04:58:47Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * This Aggregator is created by the {@link DoubleAnyAggregatorFactory} which extends from\n+ * {@link NullableNumericAggregatorFactory}. If null needs to be handle, then {@link NullableNumericAggregatorFactory}\n+ * will wrap this aggregator in {@link NullableNumericAggregator} and can handle all null in that class.\n+ * Hence, no null will ever be pass into this aggregator from the valueSelector.\n+ */\n+public class DoubleAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n+  private static final byte BYTE_FLAG_IS_SET = 1;\n+  private static final double NULL_VALUE = 0;\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  public DoubleAnyBufferAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+  }\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, BYTE_FLAG_IS_NOT_SET);\n+    buf.putDouble(position + Byte.BYTES, NULL_VALUE);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position)\n+  {\n+    if (buf.get(position) == BYTE_FLAG_IS_NOT_SET) {\n+      buf.putDouble(position + Byte.BYTES, valueSelector.getDouble());\n+      buf.put(position, BYTE_FLAG_IS_SET);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNDczOA=="}, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI1NTQzMQ==", "bodyText": "Done", "url": "https://github.com/apache/druid/pull/9187#discussion_r367255431", "createdAt": "2020-01-16T06:49:53Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * This Aggregator is created by the {@link DoubleAnyAggregatorFactory} which extends from\n+ * {@link NullableNumericAggregatorFactory}. If null needs to be handle, then {@link NullableNumericAggregatorFactory}\n+ * will wrap this aggregator in {@link NullableNumericAggregator} and can handle all null in that class.\n+ * Hence, no null will ever be pass into this aggregator from the valueSelector.\n+ */\n+public class DoubleAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n+  private static final byte BYTE_FLAG_IS_SET = 1;\n+  private static final double NULL_VALUE = 0;\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  public DoubleAnyBufferAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+  }\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, BYTE_FLAG_IS_NOT_SET);\n+    buf.putDouble(position + Byte.BYTES, NULL_VALUE);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position)\n+  {\n+    if (buf.get(position) == BYTE_FLAG_IS_NOT_SET) {\n+      buf.putDouble(position + Byte.BYTES, valueSelector.getDouble());\n+      buf.put(position, BYTE_FLAG_IS_SET);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNDczOA=="}, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2ODgzNTg3OnYy", "diffSide": "RIGHT", "path": "docs/querying/sql.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwMjo0ODoxMVrOFeMlcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNjo1MTowMVrOFePgxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNzc5NQ==", "bodyText": "\"this can returns the default\" -> \"this can return the default\", similarly for \"then this will returns\"", "url": "https://github.com/apache/druid/pull/9187#discussion_r367207795", "createdAt": "2020-01-16T02:48:11Z", "author": {"login": "jon-wei"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -203,6 +203,10 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest non-null value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n+|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will returns any non-null value of `expr`|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI1NTc1MQ==", "bodyText": "Done", "url": "https://github.com/apache/druid/pull/9187#discussion_r367255751", "createdAt": "2020-01-16T06:51:01Z", "author": {"login": "maytasm"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -203,6 +203,10 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest non-null value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n+|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will returns any non-null value of `expr`|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNzc5NQ=="}, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2ODgzNjk5OnYy", "diffSide": "RIGHT", "path": "docs/querying/sql.md", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwMjo0OTowNVrOFeMmGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQyMDowNzo0M1rOFemBLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNzk2MQ==", "bodyText": "This should mention that the default maxBytesPerString is 1024", "url": "https://github.com/apache/druid/pull/9187#discussion_r367207961", "createdAt": "2020-01-16T02:49:05Z", "author": {"login": "jon-wei"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -203,6 +203,10 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest non-null value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n+|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will returns any non-null value of `expr`|\n+|`ANY_VALUE(expr, maxBytesPerString)`|Like `ANY_VALUE(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI1NTk3NA==", "bodyText": "What do you mean default? You need to always pass the value. There is no default value for maxBytesPerString", "url": "https://github.com/apache/druid/pull/9187#discussion_r367255974", "createdAt": "2020-01-16T06:51:58Z", "author": {"login": "maytasm"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -203,6 +203,10 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest non-null value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n+|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will returns any non-null value of `expr`|\n+|`ANY_VALUE(expr, maxBytesPerString)`|Like `ANY_VALUE(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNzk2MQ=="}, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYxNjgxMQ==", "bodyText": "you have this block in StringAnyAggregatorFactory:\n\n    this.maxStringBytes = maxStringBytes == null\n                          ? StringFirstAggregatorFactory.DEFAULT_MAX_STRING_SIZE\n                          : maxStringBytes;\n\nI would give the SQL function consistent behavior", "url": "https://github.com/apache/druid/pull/9187#discussion_r367616811", "createdAt": "2020-01-16T19:49:50Z", "author": {"login": "jon-wei"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -203,6 +203,10 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest non-null value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n+|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will returns any non-null value of `expr`|\n+|`ANY_VALUE(expr, maxBytesPerString)`|Like `ANY_VALUE(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNzk2MQ=="}, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYyNDI4OA==", "bodyText": "Currently, the implementation for LATEST, EARLIEST (and ANY since I based it off LATEST, EARLIEST) is that if you use the json stuff, then maxStringBytes is optional and if not present will default to 1024 (as per the docs in docs/querying/aggregations.md).\nHowever, this does not work the same if you issue the query through SQL. To use LATEST, EARLIEST (and ANY) in SQL, you must give the maxStringBytes as the second argument. If you do not, then the column actually gets cast into double (super weird).", "url": "https://github.com/apache/druid/pull/9187#discussion_r367624288", "createdAt": "2020-01-16T20:07:16Z", "author": {"login": "maytasm"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -203,6 +203,10 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest non-null value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n+|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will returns any non-null value of `expr`|\n+|`ANY_VALUE(expr, maxBytesPerString)`|Like `ANY_VALUE(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNzk2MQ=="}, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYyNDQ5NQ==", "bodyText": "Let's discuss. We can change this behaviour for LATEST, EARLIEST (and ANY)", "url": "https://github.com/apache/druid/pull/9187#discussion_r367624495", "createdAt": "2020-01-16T20:07:43Z", "author": {"login": "maytasm"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -203,6 +203,10 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest non-null value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n+|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will returns any non-null value of `expr`|\n+|`ANY_VALUE(expr, maxBytesPerString)`|Like `ANY_VALUE(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNzk2MQ=="}, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2ODgzNzcyOnYy", "diffSide": "RIGHT", "path": "docs/querying/sql.md", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwMjo0OTo0NlrOFeMmjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQyMToxMzowMVrOFent_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwODA3OA==", "bodyText": "Can you also add entries for the new aggregators under docs/querying/aggregations.md?", "url": "https://github.com/apache/druid/pull/9187#discussion_r367208078", "createdAt": "2020-01-16T02:49:46Z", "author": {"login": "jon-wei"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -203,6 +203,10 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest non-null value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n+|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will returns any non-null value of `expr`|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI1NzU0OQ==", "bodyText": "Done. Btw I saw filterNullValues for stringLast and stringFirst. Is that still true?", "url": "https://github.com/apache/druid/pull/9187#discussion_r367257549", "createdAt": "2020-01-16T06:58:13Z", "author": {"login": "maytasm"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -203,6 +203,10 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest non-null value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n+|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will returns any non-null value of `expr`|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwODA3OA=="}, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY1MjM0OQ==", "bodyText": "Hm, looks like the docs are out of date for those, we can fix those later", "url": "https://github.com/apache/druid/pull/9187#discussion_r367652349", "createdAt": "2020-01-16T21:13:01Z", "author": {"login": "jon-wei"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -203,6 +203,10 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest non-null value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n+|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will returns any non-null value of `expr`|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwODA3OA=="}, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2ODk4NzMyOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNDo1NToyOVrOFeN-Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNzoxMTowMlrOFeP0uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMDQ4Mw==", "bodyText": "instead of NULL_VALUE maybe use NullHandling.ZERO_DOUBLE or like just 0 since this is the only place this is used", "url": "https://github.com/apache/druid/pull/9187#discussion_r367230483", "createdAt": "2020-01-16T04:55:29Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * This Aggregator is created by the {@link DoubleAnyAggregatorFactory} which extends from\n+ * {@link NullableNumericAggregatorFactory}. If null needs to be handle, then {@link NullableNumericAggregatorFactory}\n+ * will wrap this aggregator in {@link NullableNumericAggregator} and can handle all null in that class.\n+ * Hence, no null will ever be pass into this aggregator from the valueSelector.\n+ */\n+public class DoubleAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n+  private static final byte BYTE_FLAG_IS_SET = 1;\n+  private static final double NULL_VALUE = 0;\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  public DoubleAnyBufferAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+  }\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, BYTE_FLAG_IS_NOT_SET);\n+    buf.putDouble(position + Byte.BYTES, NULL_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI2MDg1Nw==", "bodyText": "Done", "url": "https://github.com/apache/druid/pull/9187#discussion_r367260857", "createdAt": "2020-01-16T07:11:02Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * This Aggregator is created by the {@link DoubleAnyAggregatorFactory} which extends from\n+ * {@link NullableNumericAggregatorFactory}. If null needs to be handle, then {@link NullableNumericAggregatorFactory}\n+ * will wrap this aggregator in {@link NullableNumericAggregator} and can handle all null in that class.\n+ * Hence, no null will ever be pass into this aggregator from the valueSelector.\n+ */\n+public class DoubleAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n+  private static final byte BYTE_FLAG_IS_SET = 1;\n+  private static final double NULL_VALUE = 0;\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  public DoubleAnyBufferAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+  }\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, BYTE_FLAG_IS_NOT_SET);\n+    buf.putDouble(position + Byte.BYTES, NULL_VALUE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMDQ4Mw=="}, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2ODk5ODk2OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNTowNToyN1rOFeOE9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNzoxOToxMVrOFeP9aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMjI0Nw==", "bodyText": "nit: It is probably worth pushing chop down into StringUtils rather than renaming and widening the usage of StringAggregatorUtils", "url": "https://github.com/apache/druid/pull/9187#discussion_r367232247", "createdAt": "2020-01-16T05:05:27Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregator.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.first.StringAggregatorUtils;\n+import org.apache.druid.segment.BaseObjectColumnValueSelector;\n+import org.apache.druid.segment.DimensionHandlerUtils;\n+\n+public class StringAnyAggregator implements Aggregator\n+{\n+  private final BaseObjectColumnValueSelector valueSelector;\n+  private final int maxStringBytes;\n+\n+  private String foundValue;\n+\n+  public StringAnyAggregator(BaseObjectColumnValueSelector valueSelector, int maxStringBytes)\n+  {\n+    this.valueSelector = valueSelector;\n+    this.maxStringBytes = maxStringBytes;\n+    this.foundValue = null;\n+  }\n+\n+  @Override\n+  public void aggregate()\n+  {\n+    if (foundValue == null) {\n+      final Object object = valueSelector.getObject();\n+      if (object != null) {\n+        foundValue = DimensionHandlerUtils.convertObjectToString(object);\n+        if (foundValue != null && foundValue.length() > maxStringBytes) {\n+          foundValue = foundValue.substring(0, maxStringBytes);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Object get()\n+  {\n+    return StringAggregatorUtils.chop(foundValue, maxStringBytes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI2MzA4MA==", "bodyText": "sounds good to me. Done", "url": "https://github.com/apache/druid/pull/9187#discussion_r367263080", "createdAt": "2020-01-16T07:19:11Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregator.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.first.StringAggregatorUtils;\n+import org.apache.druid.segment.BaseObjectColumnValueSelector;\n+import org.apache.druid.segment.DimensionHandlerUtils;\n+\n+public class StringAnyAggregator implements Aggregator\n+{\n+  private final BaseObjectColumnValueSelector valueSelector;\n+  private final int maxStringBytes;\n+\n+  private String foundValue;\n+\n+  public StringAnyAggregator(BaseObjectColumnValueSelector valueSelector, int maxStringBytes)\n+  {\n+    this.valueSelector = valueSelector;\n+    this.maxStringBytes = maxStringBytes;\n+    this.foundValue = null;\n+  }\n+\n+  @Override\n+  public void aggregate()\n+  {\n+    if (foundValue == null) {\n+      final Object object = valueSelector.getObject();\n+      if (object != null) {\n+        foundValue = DimensionHandlerUtils.convertObjectToString(object);\n+        if (foundValue != null && foundValue.length() > maxStringBytes) {\n+          foundValue = foundValue.substring(0, maxStringBytes);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Object get()\n+  {\n+    return StringAggregatorUtils.chop(foundValue, maxStringBytes);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMjI0Nw=="}, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2OTAwMTI2OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/first/StringAggregatorUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNTowNjo0N1rOFeOGKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNzoxOToxOFrOFeP9hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMjU1NA==", "bodyText": "If you decide to end up moving chop to StringUtils, please revert this rename", "url": "https://github.com/apache/druid/pull/9187#discussion_r367232554", "createdAt": "2020-01-16T05:06:47Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/first/StringAggregatorUtils.java", "diffHunk": "@@ -29,7 +29,7 @@\n import java.nio.ByteBuffer;\n import java.nio.charset.StandardCharsets;\n \n-public class StringFirstLastUtils\n+public class StringAggregatorUtils", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI2MzEwOQ==", "bodyText": "done", "url": "https://github.com/apache/druid/pull/9187#discussion_r367263109", "createdAt": "2020-01-16T07:19:18Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/first/StringAggregatorUtils.java", "diffHunk": "@@ -29,7 +29,7 @@\n import java.nio.ByteBuffer;\n import java.nio.charset.StandardCharsets;\n \n-public class StringFirstLastUtils\n+public class StringAggregatorUtils", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMjU1NA=="}, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2OTAwNTk0OnYy", "diffSide": "RIGHT", "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNToxMDoyNlrOFeOI4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNzoyMDoyOFrOFeP-pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMzI1MA==", "bodyText": "nit: It would probably be worth adding an additional test that tests numeric columns agains druid.numfoo table since it contains numeric columns that have null values when run in sql compatible null mode, and also tests for ordering by each 'any' aggregator.", "url": "https://github.com/apache/druid/pull/9187#discussion_r367233250", "createdAt": "2020-01-16T05:10:26Z", "author": {"login": "clintropolis"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -1297,6 +1301,46 @@ public void testLatestAggregators() throws Exception\n     );\n   }\n \n+  // This test the on-heap version of the AnyAggregator (Double/Float/Long/String)\n+  @Test\n+  public void testAnyAggregator() throws Exception", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI2MzM5Nw==", "bodyText": "done", "url": "https://github.com/apache/druid/pull/9187#discussion_r367263397", "createdAt": "2020-01-16T07:20:28Z", "author": {"login": "maytasm"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -1297,6 +1301,46 @@ public void testLatestAggregators() throws Exception\n     );\n   }\n \n+  // This test the on-heap version of the AnyAggregator (Double/Float/Long/String)\n+  @Test\n+  public void testAnyAggregator() throws Exception", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMzI1MA=="}, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2OTQ1NTkxOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwOTowNTo0M1rOFeSTfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxODo0NDozMVrOFejsww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMTUwMg==", "bodyText": "sorry I missed this earlier, this check isn't necessary, DimensionHandlerUtils.convertObjectToString has it's own null check", "url": "https://github.com/apache/druid/pull/9187#discussion_r367301502", "createdAt": "2020-01-16T09:05:43Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregator.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseObjectColumnValueSelector;\n+import org.apache.druid.segment.DimensionHandlerUtils;\n+\n+public class StringAnyAggregator implements Aggregator\n+{\n+  private final BaseObjectColumnValueSelector valueSelector;\n+  private final int maxStringBytes;\n+\n+  private String foundValue;\n+\n+  public StringAnyAggregator(BaseObjectColumnValueSelector valueSelector, int maxStringBytes)\n+  {\n+    this.valueSelector = valueSelector;\n+    this.maxStringBytes = maxStringBytes;\n+    this.foundValue = null;\n+  }\n+\n+  @Override\n+  public void aggregate()\n+  {\n+    if (foundValue == null) {\n+      final Object object = valueSelector.getObject();\n+      if (object != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6f954355ed3455f529507da578e903930bec1b9"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4NjQ5OQ==", "bodyText": "Done", "url": "https://github.com/apache/druid/pull/9187#discussion_r367586499", "createdAt": "2020-01-16T18:44:31Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregator.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseObjectColumnValueSelector;\n+import org.apache.druid.segment.DimensionHandlerUtils;\n+\n+public class StringAnyAggregator implements Aggregator\n+{\n+  private final BaseObjectColumnValueSelector valueSelector;\n+  private final int maxStringBytes;\n+\n+  private String foundValue;\n+\n+  public StringAnyAggregator(BaseObjectColumnValueSelector valueSelector, int maxStringBytes)\n+  {\n+    this.valueSelector = valueSelector;\n+    this.maxStringBytes = maxStringBytes;\n+    this.foundValue = null;\n+  }\n+\n+  @Override\n+  public void aggregate()\n+  {\n+    if (foundValue == null) {\n+      final Object object = valueSelector.getObject();\n+      if (object != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMTUwMg=="}, "originalCommit": {"oid": "d6f954355ed3455f529507da578e903930bec1b9"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2OTQ1OTEzOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyBufferAggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwOTowNjo1M1rOFeSVdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxODo0NDozM1rOFejszw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMjAwNg==", "bodyText": "same comment about unnecessary check", "url": "https://github.com/apache/druid/pull/9187#discussion_r367302006", "createdAt": "2020-01-16T09:06:53Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.segment.BaseObjectColumnValueSelector;\n+import org.apache.druid.segment.DimensionHandlerUtils;\n+\n+import java.nio.ByteBuffer;\n+\n+public class StringAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final int NULL_STRING_LENGTH = -1;\n+  private final BaseObjectColumnValueSelector valueSelector;\n+  private final int maxStringBytes;\n+\n+  public StringAnyBufferAggregator(BaseObjectColumnValueSelector valueSelector, int maxStringBytes)\n+  {\n+    this.valueSelector = valueSelector;\n+    this.maxStringBytes = maxStringBytes;\n+  }\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.putInt(position, NULL_STRING_LENGTH);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position)\n+  {\n+    int stringSizeBytes = buf.getInt(position);\n+    if (stringSizeBytes < 0) {\n+      final Object object = valueSelector.getObject();\n+      if (object != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6f954355ed3455f529507da578e903930bec1b9"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4NjUxMQ==", "bodyText": "Done", "url": "https://github.com/apache/druid/pull/9187#discussion_r367586511", "createdAt": "2020-01-16T18:44:33Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.segment.BaseObjectColumnValueSelector;\n+import org.apache.druid.segment.DimensionHandlerUtils;\n+\n+import java.nio.ByteBuffer;\n+\n+public class StringAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final int NULL_STRING_LENGTH = -1;\n+  private final BaseObjectColumnValueSelector valueSelector;\n+  private final int maxStringBytes;\n+\n+  public StringAnyBufferAggregator(BaseObjectColumnValueSelector valueSelector, int maxStringBytes)\n+  {\n+    this.valueSelector = valueSelector;\n+    this.maxStringBytes = maxStringBytes;\n+  }\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.putInt(position, NULL_STRING_LENGTH);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position)\n+  {\n+    int stringSizeBytes = buf.getInt(position);\n+    if (stringSizeBytes < 0) {\n+      final Object object = valueSelector.getObject();\n+      if (object != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMjAwNg=="}, "originalCommit": {"oid": "d6f954355ed3455f529507da578e903930bec1b9"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2OTQ3MjA2OnYy", "diffSide": "RIGHT", "path": "sql/src/test/java/org/apache/druid/sql/calcite/util/CalciteTests.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwOToxMDo1NFrOFeSdDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQyMDoxNjowOFrOFemP_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMzk1MA==", "bodyText": "Hmm, it seems like this change is causing some unrelated test failures", "url": "https://github.com/apache/druid/pull/9187#discussion_r367303950", "createdAt": "2020-01-16T09:10:54Z", "author": {"login": "clintropolis"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/util/CalciteTests.java", "diffHunk": "@@ -377,6 +377,15 @@ public AuthenticationResult createEscalatedAuthenticationResult()\n   );\n \n   public static final List<InputRow> ROWS1_WITH_NUMERIC_DIMS = ImmutableList.of(\n+      createRow(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6f954355ed3455f529507da578e903930bec1b9"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYwMzYwNA==", "bodyText": "Seems like the VarianceSqlAggregatorTest is using this data too and when the ordering of the rows changed, the variance also changed. I created a new datasource that have the numeric dim first for my test and changed the numfoo datasource back to how it was. The reason I wanted to have numeric null first is because the ANY will select the first row and skip everything after. So if the first row is not null, then there is not really any point in testing (if we want to test the numeric null stuff)", "url": "https://github.com/apache/druid/pull/9187#discussion_r367603604", "createdAt": "2020-01-16T19:21:17Z", "author": {"login": "maytasm"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/util/CalciteTests.java", "diffHunk": "@@ -377,6 +377,15 @@ public AuthenticationResult createEscalatedAuthenticationResult()\n   );\n \n   public static final List<InputRow> ROWS1_WITH_NUMERIC_DIMS = ImmutableList.of(\n+      createRow(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMzk1MA=="}, "originalCommit": {"oid": "d6f954355ed3455f529507da578e903930bec1b9"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYyODI4NQ==", "bodyText": "Actually, I think it's fine to just test with the same numfoo datasource (with first row being non-null)", "url": "https://github.com/apache/druid/pull/9187#discussion_r367628285", "createdAt": "2020-01-16T20:16:08Z", "author": {"login": "maytasm"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/util/CalciteTests.java", "diffHunk": "@@ -377,6 +377,15 @@ public AuthenticationResult createEscalatedAuthenticationResult()\n   );\n \n   public static final List<InputRow> ROWS1_WITH_NUMERIC_DIMS = ImmutableList.of(\n+      createRow(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMzk1MA=="}, "originalCommit": {"oid": "d6f954355ed3455f529507da578e903930bec1b9"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2130, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}