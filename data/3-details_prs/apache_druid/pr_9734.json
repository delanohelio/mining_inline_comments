{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2ODA5NDg4", "number": 9734, "title": "Initialize SettableByteEntityReader only when inputFormat is not null", "bodyText": "Fixes #9728\nDescription\nSettableByteEntityReader has a null check in its constructor which throws NPE when inputFormat is null. This PR changes to creating it when inputFormat is not null.\n\nThis PR has:\n\n been self-reviewed.\n\n using the concurrency checklist (Remove this item if the PR doesn't have any relation to concurrency.)\n\n\n added documentation for new or modified features or behaviors.\n added Javadocs for most classes and all non-trivial methods. Linked related entities via Javadoc links.\n added or updated version, license, or notice information in licenses.yaml\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.\n added unit tests or modified existing tests to cover new code paths.\n added integration tests.\n been tested in a test Druid cluster.", "createdAt": "2020-04-21T17:40:31Z", "url": "https://github.com/apache/druid/pull/9734", "merged": true, "mergeCommit": {"oid": "7fa72fbf15f627d25e860eb249922bea9331d623"}, "closed": true, "closedAt": "2020-04-24T17:22:52Z", "author": {"login": "jihoonson"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcZ3PgJAH2gAyNDA2ODA5NDg4OjFmY2ZkNmQyNmJiNTlmMjc3OWYzOWRjOTM0NWQyOWYwZWVhNjNjNTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcanc0GgFqTM5OTU4NjQ2Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1fcfd6d26bb59f2779f39dc9345d29f0eea63c56", "author": {"user": {"login": "jihoonson", "name": "Jihoon Son"}}, "url": "https://github.com/apache/druid/commit/1fcfd6d26bb59f2779f39dc9345d29f0eea63c56", "committedDate": "2020-04-21T17:35:54Z", "message": "Lazy initialization of SettableByteEntityReader to avoid NPE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d452d1c018d435968b189c6274b79442a08f863d", "author": {"user": {"login": "jihoonson", "name": "Jihoon Son"}}, "url": "https://github.com/apache/druid/commit/d452d1c018d435968b189c6274b79442a08f863d", "committedDate": "2020-04-21T17:55:11Z", "message": "toInputFormat for tsv"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NjU0ODA2", "url": "https://github.com/apache/druid/pull/9734#pullrequestreview-397654806", "createdAt": "2020-04-21T20:34:44Z", "commit": {"oid": "d452d1c018d435968b189c6274b79442a08f863d"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDozNDo0NFrOGJXVPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDozODo0NVrOGJXe5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3MjYzNw==", "bodyText": "nit: this error message should be \"Either parser or inputFormat should be set\" maybe since this is checking if both are null?", "url": "https://github.com/apache/druid/pull/9734#discussion_r412472637", "createdAt": "2020-04-21T20:34:44Z", "author": {"login": "clintropolis"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/StreamChunkParser.java", "diffHunk": "@@ -38,20 +45,38 @@\n {\n   @Nullable\n   private final InputRowParser<ByteBuffer> parser;\n-  private final SettableByteEntityReader byteEntityReader;\n+  private final Supplier<SettableByteEntityReader> lazyByteEntityReaderSupplier; // lazy initializer\n \n-  StreamChunkParser(@Nullable InputRowParser<ByteBuffer> parser, SettableByteEntityReader byteEntityReader)\n+  /**\n+   * Either parser or inputFormat shouldn't be null.\n+   */\n+  StreamChunkParser(\n+      @Nullable InputRowParser<ByteBuffer> parser,\n+      @Nullable InputFormat inputFormat,\n+      InputRowSchema inputRowSchema,\n+      TransformSpec transformSpec,\n+      File indexingTmpDir\n+  )\n   {\n+    if (parser == null && inputFormat == null) {\n+      throw new IAE(\"Either parser or inputFormat shouldn't be set\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d452d1c018d435968b189c6274b79442a08f863d"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3MzU4Mw==", "bodyText": "Would it be better to prefer the inputFormat if it exists?", "url": "https://github.com/apache/druid/pull/9734#discussion_r412473583", "createdAt": "2020-04-21T20:36:15Z", "author": {"login": "clintropolis"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/StreamChunkParser.java", "diffHunk": "@@ -38,20 +45,38 @@\n {\n   @Nullable\n   private final InputRowParser<ByteBuffer> parser;\n-  private final SettableByteEntityReader byteEntityReader;\n+  private final Supplier<SettableByteEntityReader> lazyByteEntityReaderSupplier; // lazy initializer\n \n-  StreamChunkParser(@Nullable InputRowParser<ByteBuffer> parser, SettableByteEntityReader byteEntityReader)\n+  /**\n+   * Either parser or inputFormat shouldn't be null.\n+   */\n+  StreamChunkParser(\n+      @Nullable InputRowParser<ByteBuffer> parser,\n+      @Nullable InputFormat inputFormat,\n+      InputRowSchema inputRowSchema,\n+      TransformSpec transformSpec,\n+      File indexingTmpDir\n+  )\n   {\n+    if (parser == null && inputFormat == null) {\n+      throw new IAE(\"Either parser or inputFormat shouldn't be set\");\n+    }\n     this.parser = parser;\n-    this.byteEntityReader = byteEntityReader;\n+    // Create a lazy initializer since it will fail to create a SettableByteEntityReader if inputFormat is null\n+    this.lazyByteEntityReaderSupplier = Suppliers.memoize(() -> new SettableByteEntityReader(\n+        inputFormat,\n+        inputRowSchema,\n+        transformSpec,\n+        indexingTmpDir\n+    ));\n   }\n \n   List<InputRow> parse(List<byte[]> streamChunk) throws IOException\n   {\n     if (parser != null) {\n       return parseWithParser(parser, streamChunk);\n     } else {\n-      return parseWithInputFormat(byteEntityReader, streamChunk);\n+      return parseWithInputFormat(lazyByteEntityReaderSupplier.get(), streamChunk);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d452d1c018d435968b189c6274b79442a08f863d"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3NTEwOQ==", "bodyText": "nit: Why a supplier instead of just making byteEntityReader @Nullable? it seems like it would not be used if parser is not null.", "url": "https://github.com/apache/druid/pull/9734#discussion_r412475109", "createdAt": "2020-04-21T20:38:45Z", "author": {"login": "clintropolis"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/StreamChunkParser.java", "diffHunk": "@@ -38,20 +45,38 @@\n {\n   @Nullable\n   private final InputRowParser<ByteBuffer> parser;\n-  private final SettableByteEntityReader byteEntityReader;\n+  private final Supplier<SettableByteEntityReader> lazyByteEntityReaderSupplier; // lazy initializer\n \n-  StreamChunkParser(@Nullable InputRowParser<ByteBuffer> parser, SettableByteEntityReader byteEntityReader)\n+  /**\n+   * Either parser or inputFormat shouldn't be null.\n+   */\n+  StreamChunkParser(\n+      @Nullable InputRowParser<ByteBuffer> parser,\n+      @Nullable InputFormat inputFormat,\n+      InputRowSchema inputRowSchema,\n+      TransformSpec transformSpec,\n+      File indexingTmpDir\n+  )\n   {\n+    if (parser == null && inputFormat == null) {\n+      throw new IAE(\"Either parser or inputFormat shouldn't be set\");\n+    }\n     this.parser = parser;\n-    this.byteEntityReader = byteEntityReader;\n+    // Create a lazy initializer since it will fail to create a SettableByteEntityReader if inputFormat is null\n+    this.lazyByteEntityReaderSupplier = Suppliers.memoize(() -> new SettableByteEntityReader(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d452d1c018d435968b189c6274b79442a08f863d"}, "originalPosition": 45}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1acd298348fdf2eacf91b40dad5936dd96d57b4", "author": {"user": {"login": "jihoonson", "name": "Jihoon Son"}}, "url": "https://github.com/apache/druid/commit/a1acd298348fdf2eacf91b40dad5936dd96d57b4", "committedDate": "2020-04-21T20:59:51Z", "message": "address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3Njc1NjI3", "url": "https://github.com/apache/druid/pull/9734#pullrequestreview-397675627", "createdAt": "2020-04-21T21:06:54Z", "commit": {"oid": "a1acd298348fdf2eacf91b40dad5936dd96d57b4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NjgwNDg3", "url": "https://github.com/apache/druid/pull/9734#pullrequestreview-397680487", "createdAt": "2020-04-21T21:14:13Z", "commit": {"oid": "a1acd298348fdf2eacf91b40dad5936dd96d57b4"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMToxNDoxM1rOGJYxVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMTozNzoxMFrOGJZjew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NjIxMw==", "bodyText": "Where is the test that makes sure TSV is handled properly now? Also do we already have a similar test for CSV?", "url": "https://github.com/apache/druid/pull/9734#discussion_r412496213", "createdAt": "2020-04-21T21:14:13Z", "author": {"login": "ccaominh"}, "path": "core/src/main/java/org/apache/druid/data/input/impl/DelimitedParseSpec.java", "diffHunk": "@@ -123,6 +124,12 @@ public int getSkipHeaderRows()\n     );\n   }\n \n+  @Override\n+  public InputFormat toInputFormat()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1acd298348fdf2eacf91b40dad5936dd96d57b4"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwNTYyNQ==", "bodyText": "I think it would be good to add some tests for this class since it looks like the existing unit tests don't cover this class at all. For example, there's nothing ensuring that parser and inputFormat are both not null when they're passed to the StreamChunkParser constructor.\nAlso, it looks like we only have tests that ensure that real time ingestion works with JSON. We should add a tests to make sure real time ingestion never breaks in the future for Avro, TSV, etc.", "url": "https://github.com/apache/druid/pull/9734#discussion_r412505625", "createdAt": "2020-04-21T21:30:45Z", "author": {"login": "ccaominh"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/SeekableStreamIndexTaskRunner.java", "diffHunk": "@@ -372,12 +373,10 @@ private TaskStatus runInternal(TaskToolbox toolbox) throws Exception\n     // Now we can initialize StreamChunkReader with the given toolbox.\n     final StreamChunkParser parser = new StreamChunkParser(\n         this.parser,\n-        new SettableByteEntityReader(\n-            inputFormat,\n-            inputRowSchema,\n-            task.getDataSchema().getTransformSpec(),\n-            toolbox.getIndexingTmpDir()\n-        )\n+        inputFormat,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1acd298348fdf2eacf91b40dad5936dd96d57b4"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwOTA1MQ==", "bodyText": "This is repeated for two of the tests below, so may be worth factoring out.", "url": "https://github.com/apache/druid/pull/9734#discussion_r412509051", "createdAt": "2020-04-21T21:37:10Z", "author": {"login": "ccaominh"}, "path": "indexing-service/src/test/java/org/apache/druid/indexing/seekablestream/StreamChunkParserTest.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.indexing.seekablestream;\n+\n+import com.google.common.collect.Iterables;\n+import org.apache.druid.data.input.InputEntity;\n+import org.apache.druid.data.input.InputEntityReader;\n+import org.apache.druid.data.input.InputFormat;\n+import org.apache.druid.data.input.InputRow;\n+import org.apache.druid.data.input.InputRowSchema;\n+import org.apache.druid.data.input.impl.DimensionsSpec;\n+import org.apache.druid.data.input.impl.InputRowParser;\n+import org.apache.druid.data.input.impl.JSONParseSpec;\n+import org.apache.druid.data.input.impl.JsonInputFormat;\n+import org.apache.druid.data.input.impl.StringInputRowParser;\n+import org.apache.druid.data.input.impl.TimestampSpec;\n+import org.apache.druid.java.util.common.DateTimes;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.parsers.JSONPathSpec;\n+import org.apache.druid.segment.transform.TransformSpec;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.TemporaryFolder;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class StreamChunkParserTest\n+{\n+  private static final TimestampSpec TIMESTAMP_SPEC = new TimestampSpec(null, null, null);\n+\n+  @Rule\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  @Rule\n+  public ExpectedException expectedException = ExpectedException.none();\n+\n+  @Test\n+  public void testWithParserAndNullInputformatParseProperly() throws IOException\n+  {\n+    final InputRowParser<ByteBuffer> parser = new StringInputRowParser(\n+        new NotConvertibleToInputFormatParseSpec(),\n+        StringUtils.UTF8_STRING\n+    );\n+    final StreamChunkParser chunkParser = new StreamChunkParser(\n+        parser,\n+        // Set nulls for all parameters below since inputFormat will be never used.\n+        null,\n+        null,\n+        null,\n+        null\n+    );\n+    final String json = \"{\\\"timestamp\\\": \\\"2020-01-01\\\", \\\"dim\\\": \\\"val\\\", \\\"met\\\": \\\"val2\\\"}\";\n+    List<InputRow> parsedRows = chunkParser.parse(Collections.singletonList(json.getBytes(StringUtils.UTF8_STRING)));\n+    Assert.assertEquals(1, parsedRows.size());\n+    InputRow row = parsedRows.get(0);\n+    Assert.assertEquals(DateTimes.of(\"2020-01-01\"), row.getTimestamp());\n+    Assert.assertEquals(\"val\", Iterables.getOnlyElement(row.getDimension(\"dim\")));\n+    Assert.assertEquals(\"val2\", Iterables.getOnlyElement(row.getDimension(\"met\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1acd298348fdf2eacf91b40dad5936dd96d57b4"}, "originalPosition": 83}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d3f79602e0ecc40bdc695592e20167cc10682ee", "author": {"user": {"login": "jihoonson", "name": "Jihoon Son"}}, "url": "https://github.com/apache/druid/commit/1d3f79602e0ecc40bdc695592e20167cc10682ee", "committedDate": "2020-04-24T00:08:02Z", "message": "common code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NTg2NDYz", "url": "https://github.com/apache/druid/pull/9734#pullrequestreview-399586463", "createdAt": "2020-04-24T01:43:15Z", "commit": {"oid": "1d3f79602e0ecc40bdc695592e20167cc10682ee"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwMTo0MzoxNVrOGLC0fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwMTo0NDo1M1rOGLC2Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIzMzcyNA==", "bodyText": "Cool, I didn't look at the coverage from KafkaIndexTaskTest and KinesisIndexTaskTest, so my comment can be disregarded.\nAdding the integration tests in a follow up PR sounds good to me since you manually verified your fix for the scenario that uncovered this bug.", "url": "https://github.com/apache/druid/pull/9734#discussion_r414233724", "createdAt": "2020-04-24T01:43:15Z", "author": {"login": "ccaominh"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/SeekableStreamIndexTaskRunner.java", "diffHunk": "@@ -372,12 +373,10 @@ private TaskStatus runInternal(TaskToolbox toolbox) throws Exception\n     // Now we can initialize StreamChunkReader with the given toolbox.\n     final StreamChunkParser parser = new StreamChunkParser(\n         this.parser,\n-        new SettableByteEntityReader(\n-            inputFormat,\n-            inputRowSchema,\n-            task.getDataSchema().getTransformSpec(),\n-            toolbox.getIndexingTmpDir()\n-        )\n+        inputFormat,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwNTYyNQ=="}, "originalCommit": {"oid": "a1acd298348fdf2eacf91b40dad5936dd96d57b4"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIzNDE5NA==", "bodyText": "Sorry, my comment was more about adding integration tests for streaming ingestion with the various formats, which I believe we're missing. This can be addressed in a follow up PR that tackles the issue comprehensively.", "url": "https://github.com/apache/druid/pull/9734#discussion_r414234194", "createdAt": "2020-04-24T01:44:53Z", "author": {"login": "ccaominh"}, "path": "core/src/main/java/org/apache/druid/data/input/impl/DelimitedParseSpec.java", "diffHunk": "@@ -123,6 +124,12 @@ public int getSkipHeaderRows()\n     );\n   }\n \n+  @Override\n+  public InputFormat toInputFormat()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NjIxMw=="}, "originalCommit": {"oid": "a1acd298348fdf2eacf91b40dad5936dd96d57b4"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2561, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}