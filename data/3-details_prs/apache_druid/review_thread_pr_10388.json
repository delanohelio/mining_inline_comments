{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg1NjQwNDA0", "number": 10388, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwNToxMTowNVrOEivwaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwMjo0MToxMVrOEjZa3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODY5NDgxOnYy", "diffSide": "RIGHT", "path": "processing/src/test/java/org/apache/druid/segment/virtual/AlwaysTwoVectorizedVirtualColumn.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwNToxMTowNVrOHQyrQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwNToxMTowNVrOHQyrQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM2OTUzOA==", "bodyText": "nit: using RangeIndexedInts may be simpler when reading code.", "url": "https://github.com/apache/druid/pull/10388#discussion_r487369538", "createdAt": "2020-09-12T05:11:05Z", "author": {"login": "jihoonson"}, "path": "processing/src/test/java/org/apache/druid/segment/virtual/AlwaysTwoVectorizedVirtualColumn.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.virtual;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.druid.query.dimension.DimensionSpec;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.ColumnInspector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.DimensionSelector;\n+import org.apache.druid.segment.IdLookup;\n+import org.apache.druid.segment.VirtualColumn;\n+import org.apache.druid.segment.column.ColumnCapabilities;\n+import org.apache.druid.segment.data.IndexedInts;\n+import org.apache.druid.segment.vector.MultiValueDimensionVectorSelector;\n+import org.apache.druid.segment.vector.SingleValueDimensionVectorSelector;\n+import org.apache.druid.segment.vector.VectorColumnSelectorFactory;\n+import org.apache.druid.segment.vector.VectorObjectSelector;\n+import org.apache.druid.segment.vector.VectorSizeInspector;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class AlwaysTwoVectorizedVirtualColumn implements VirtualColumn\n+{\n+  private final String outputName;\n+  private final ColumnCapabilities capabilities;\n+  private final boolean dictionaryEncoded;\n+\n+  public AlwaysTwoVectorizedVirtualColumn(\n+      String name,\n+      ColumnCapabilities capabilites\n+  )\n+  {\n+    this.outputName = name;\n+    this.capabilities = capabilites;\n+    this.dictionaryEncoded = capabilites.isDictionaryEncoded().isTrue() &&\n+                             capabilites.areDictionaryValuesUnique().isTrue();\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector inspector)\n+  {\n+    return true;\n+  }\n+\n+  @Override\n+  public String getOutputName()\n+  {\n+    return outputName;\n+  }\n+\n+  @Override\n+  public DimensionSelector makeDimensionSelector(DimensionSpec dimensionSpec, ColumnSelectorFactory factory)\n+  {\n+    throw new IllegalStateException(\"don't call this\");\n+  }\n+\n+  @Override\n+  public ColumnValueSelector<?> makeColumnValueSelector(String columnName, ColumnSelectorFactory factory)\n+  {\n+    throw new IllegalStateException(\"don't call this\");\n+  }\n+\n+  @Override\n+  public SingleValueDimensionVectorSelector makeSingleValueVectorDimensionSelector(\n+      DimensionSpec dimensionSpec,\n+      VectorColumnSelectorFactory factory\n+  )\n+  {\n+    return new SingleValueDimensionVectorSelector()\n+    {\n+      private final VectorSizeInspector inspector = factory.getVectorSizeInspector();\n+      private final int[] rowVector = new int[inspector.getMaxVectorSize()];\n+\n+      @Override\n+      public int[] getRowVector()\n+      {\n+\n+        return rowVector;\n+      }\n+\n+      @Override\n+      public int getValueCardinality()\n+      {\n+        return dictionaryEncoded ? 1 : CARDINALITY_UNKNOWN;\n+      }\n+\n+      @Nullable\n+      @Override\n+      public String lookupName(int id)\n+      {\n+        return \"2\";\n+      }\n+\n+      @Override\n+      public boolean nameLookupPossibleInAdvance()\n+      {\n+        return dictionaryEncoded;\n+      }\n+\n+      @Nullable\n+      @Override\n+      public IdLookup idLookup()\n+      {\n+        return null;\n+      }\n+\n+      @Override\n+      public int getMaxVectorSize()\n+      {\n+        return inspector.getMaxVectorSize();\n+      }\n+\n+      @Override\n+      public int getCurrentVectorSize()\n+      {\n+        return inspector.getCurrentVectorSize();\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public MultiValueDimensionVectorSelector makeMultiValueVectorDimensionSelector(\n+      DimensionSpec dimensionSpec,\n+      VectorColumnSelectorFactory factory\n+  )\n+  {\n+    final IndexedInts[] rowVector = new IndexedInts[factory.getVectorSizeInspector().getMaxVectorSize()];\n+    Arrays.fill(rowVector, new IndexedInts()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "294b58a304248a6ccecd1aed2e3c6d2d7c57332e"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODcwMTM2OnYy", "diffSide": "RIGHT", "path": "processing/src/test/java/org/apache/druid/segment/virtual/AlwaysTwoCounterAggregatorFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwNToyMDo1MVrOHQyuNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwNToyMDo1MVrOHQyuNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM3MDI5NQ==", "bodyText": "It might be nice to add some Javaodc saying that the aggregator created by this factory verifies values read from vectorSelector as well as counting.", "url": "https://github.com/apache/druid/pull/10388#discussion_r487370295", "createdAt": "2020-09-12T05:20:51Z", "author": {"login": "jihoonson"}, "path": "processing/src/test/java/org/apache/druid/segment/virtual/AlwaysTwoCounterAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.virtual;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.CountAggregatorFactory;\n+import org.apache.druid.query.aggregation.CountVectorAggregator;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.query.dimension.DefaultDimensionSpec;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.column.ColumnCapabilities;\n+import org.apache.druid.segment.data.IndexedInts;\n+import org.apache.druid.segment.vector.MultiValueDimensionVectorSelector;\n+import org.apache.druid.segment.vector.SingleValueDimensionVectorSelector;\n+import org.apache.druid.segment.vector.VectorColumnSelectorFactory;\n+import org.apache.druid.segment.vector.VectorObjectSelector;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+import org.junit.Assert;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+\n+public class AlwaysTwoCounterAggregatorFactory extends CountAggregatorFactory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "294b58a304248a6ccecd1aed2e3c6d2d7c57332e"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NTUyMDk0OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/vector/VectorGroupByEngine.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwMjo0MToxMVrOHRuaxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwMjo0MzoyOVrOHRudPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM0ODM1OQ==", "bodyText": "How do you decide between columnCapabilities.hasMultipleValues().isFalse() and !columnCapabilities.hasMultipleValues().isMaybeTrue() - I'm never sure which one to check", "url": "https://github.com/apache/druid/pull/10388#discussion_r488348359", "createdAt": "2020-09-15T02:41:11Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/vector/VectorGroupByEngine.java", "diffHunk": "@@ -70,24 +73,47 @@ public static boolean canVectorize(\n       @Nullable final Filter filter\n   )\n   {\n-    // Multi-value dimensions are not yet supported.\n-    //\n-    // Two notes here about how we're handling this check:\n-    //   1) After multi-value dimensions are supported, we could alter \"GroupByQueryEngineV2.isAllSingleValueDims\"\n-    //      to accept a ColumnSelectorFactory, which makes more sense than using a StorageAdapter (see #8013).\n-    //   2) Technically using StorageAdapter here is bad since it only looks at real columns, but they might\n-    //      be shadowed by virtual columns (again, see #8013). But it's fine for now since adapter.canVectorize\n-    //      always returns false if there are any virtual columns.\n-    //\n-    // This situation should sort itself out pretty well once this engine supports multi-valued columns. Then we\n-    // won't have to worry about having this all-single-value-dims check here.\n-\n-    return GroupByQueryEngineV2.isAllSingleValueDims(adapter::getColumnCapabilities, query.getDimensions(), true)\n+    Function<String, ColumnCapabilities> capabilitiesFunction = name ->\n+        query.getVirtualColumns().getColumnCapabilitiesWithFallback(adapter, name);\n+\n+    return canVectorizeDimensions(capabilitiesFunction, query.getDimensions())\n            && query.getDimensions().stream().allMatch(DimensionSpec::canVectorize)\n            && query.getAggregatorSpecs().stream().allMatch(aggregatorFactory -> aggregatorFactory.canVectorize(adapter))\n            && adapter.canVectorize(filter, query.getVirtualColumns(), false);\n   }\n \n+  public static boolean canVectorizeDimensions(\n+      final Function<String, ColumnCapabilities> capabilitiesFunction,\n+      final List<DimensionSpec> dimensions\n+  )\n+  {\n+    return dimensions\n+        .stream()\n+        .allMatch(\n+            dimension -> {\n+              if (dimension.mustDecorate()) {\n+                // group by on multi value dimensions are not currently supported\n+                // DimensionSpecs that decorate may turn singly-valued columns into multi-valued selectors.\n+                // To be safe, we must return false here.\n+                return false;\n+              }\n+\n+              // Now check column capabilities.\n+              final ColumnCapabilities columnCapabilities = capabilitiesFunction.apply(dimension.getDimension());\n+              // null here currently means the column does not exist, nil columns can be vectorized\n+              if (columnCapabilities == null) {\n+                return true;\n+              }\n+              // strings must be single valued, dictionary encoded, and have unique dictionary entries\n+              if (ValueType.STRING.equals(columnCapabilities.getType())) {\n+                return columnCapabilities.hasMultipleValues().isFalse() &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad0419ce2d4e895acb804136653adcda32b5afe5"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM0ODk5MA==", "bodyText": "Well, I guess the example I gave is equivalent. Maybe a better way to ask that question is should UNKNOWN be treated as multi-value or single value?", "url": "https://github.com/apache/druid/pull/10388#discussion_r488348990", "createdAt": "2020-09-15T02:43:29Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/vector/VectorGroupByEngine.java", "diffHunk": "@@ -70,24 +73,47 @@ public static boolean canVectorize(\n       @Nullable final Filter filter\n   )\n   {\n-    // Multi-value dimensions are not yet supported.\n-    //\n-    // Two notes here about how we're handling this check:\n-    //   1) After multi-value dimensions are supported, we could alter \"GroupByQueryEngineV2.isAllSingleValueDims\"\n-    //      to accept a ColumnSelectorFactory, which makes more sense than using a StorageAdapter (see #8013).\n-    //   2) Technically using StorageAdapter here is bad since it only looks at real columns, but they might\n-    //      be shadowed by virtual columns (again, see #8013). But it's fine for now since adapter.canVectorize\n-    //      always returns false if there are any virtual columns.\n-    //\n-    // This situation should sort itself out pretty well once this engine supports multi-valued columns. Then we\n-    // won't have to worry about having this all-single-value-dims check here.\n-\n-    return GroupByQueryEngineV2.isAllSingleValueDims(adapter::getColumnCapabilities, query.getDimensions(), true)\n+    Function<String, ColumnCapabilities> capabilitiesFunction = name ->\n+        query.getVirtualColumns().getColumnCapabilitiesWithFallback(adapter, name);\n+\n+    return canVectorizeDimensions(capabilitiesFunction, query.getDimensions())\n            && query.getDimensions().stream().allMatch(DimensionSpec::canVectorize)\n            && query.getAggregatorSpecs().stream().allMatch(aggregatorFactory -> aggregatorFactory.canVectorize(adapter))\n            && adapter.canVectorize(filter, query.getVirtualColumns(), false);\n   }\n \n+  public static boolean canVectorizeDimensions(\n+      final Function<String, ColumnCapabilities> capabilitiesFunction,\n+      final List<DimensionSpec> dimensions\n+  )\n+  {\n+    return dimensions\n+        .stream()\n+        .allMatch(\n+            dimension -> {\n+              if (dimension.mustDecorate()) {\n+                // group by on multi value dimensions are not currently supported\n+                // DimensionSpecs that decorate may turn singly-valued columns into multi-valued selectors.\n+                // To be safe, we must return false here.\n+                return false;\n+              }\n+\n+              // Now check column capabilities.\n+              final ColumnCapabilities columnCapabilities = capabilitiesFunction.apply(dimension.getDimension());\n+              // null here currently means the column does not exist, nil columns can be vectorized\n+              if (columnCapabilities == null) {\n+                return true;\n+              }\n+              // strings must be single valued, dictionary encoded, and have unique dictionary entries\n+              if (ValueType.STRING.equals(columnCapabilities.getType())) {\n+                return columnCapabilities.hasMultipleValues().isFalse() &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM0ODM1OQ=="}, "originalCommit": {"oid": "ad0419ce2d4e895acb804136653adcda32b5afe5"}, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3206, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}