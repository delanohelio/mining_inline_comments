{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyNTU5MjIx", "number": 9448, "title": "Fix superbatch merge last partition boundaries", "bodyText": "Description\nA bug in the computation for the last parallel merge partition could cause an IndexOutOfBoundsException or precondition failure due to an empty partition.\n\nThis PR has:\n\n been self-reviewed.\n added Javadocs for most classes and all non-trivial methods. Linked related entities via Javadoc links.\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.\n added unit tests or modified existing tests to cover new code paths.", "createdAt": "2020-03-02T19:15:25Z", "url": "https://github.com/apache/druid/pull/9448", "merged": true, "mergeCommit": {"oid": "4ed83f6af67b307b25b9481d5d6762f8bd536cec"}, "closed": true, "closedAt": "2020-03-04T18:35:22Z", "author": {"login": "ccaominh"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcJPEpRgH2gAyMzgyNTU5MjIxOjA4NmU2ZDc2YzlkNDFhYjRlOTAyMjBlOTNhODhjYWZhYTljNTA0MTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcKas4qgFqTM2ODk5MzExNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "086e6d76c9d41ab4e90220e93a88cafaa9c50414", "author": {"user": {"login": "ccaominh", "name": "Chi Cao Minh"}}, "url": "https://github.com/apache/druid/commit/086e6d76c9d41ab4e90220e93a88cafaa9c50414", "committedDate": "2020-03-01T01:45:03Z", "message": "Fix superbatch merge last partition boundaries\n\nA bug in the computation for the last parallel merge partition could\ncause an IndexOutOfBoundsException or precondition failure due to an\nempty partition."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NDk3NjE3", "url": "https://github.com/apache/druid/pull/9448#pullrequestreview-367497617", "createdAt": "2020-03-02T20:18:08Z", "commit": {"oid": "086e6d76c9d41ab4e90220e93a88cafaa9c50414"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMDoxODowOFrOFwt0qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMDoxODowOFrOFwt0qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNjczMA==", "bodyText": "Can you add comment on  purpose of (index < remainder ? index : remainder) ?\ni.e. splitting the remainder across the first remainder tasks etc.", "url": "https://github.com/apache/druid/pull/9448#discussion_r386626730", "createdAt": "2020-03-02T20:18:08Z", "author": {"login": "maytasm"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/batch/parallel/ParallelIndexSupervisorTask.java", "diffHunk": "@@ -760,29 +761,39 @@ private PartitionBoundaries determineRangePartition(Collection<StringDistributio\n     // See PartitionStat in GeneratedPartitionsReport.\n     final List<Pair<Interval, Integer>> partitions = new ArrayList<>(partitionToLocations.keySet());\n     Collections.shuffle(partitions, ThreadLocalRandom.current());\n-    final int numPartitionsPerTask = (int) Math.round(partitions.size() / (double) numMergeTasks);\n \n     final List<M> assignedPartitionLocations = new ArrayList<>(numMergeTasks);\n-    for (int i = 0; i < numMergeTasks - 1; i++) {\n+    for (int i = 0; i < numMergeTasks; i++) {\n+      Pair<Integer, Integer> partitionBoundaries = getPartitionBoundaries(i, partitions.size(), numMergeTasks);\n       final List<L> assignedToSameTask = partitions\n-          .subList(i * numPartitionsPerTask, (i + 1) * numPartitionsPerTask)\n+          .subList(partitionBoundaries.lhs, partitionBoundaries.rhs)\n           .stream()\n           .flatMap(intervalAndPartitionId -> partitionToLocations.get(intervalAndPartitionId).stream())\n           .collect(Collectors.toList());\n       assignedPartitionLocations.add(createPartialSegmentMergeIOConfig.apply(assignedToSameTask));\n     }\n \n-    // The last task is assigned all remaining partitions.\n-    final List<L> assignedToSameTask = partitions\n-        .subList((numMergeTasks - 1) * numPartitionsPerTask, partitions.size())\n-        .stream()\n-        .flatMap(intervalAndPartitionId -> partitionToLocations.get(intervalAndPartitionId).stream())\n-        .collect(Collectors.toList());\n-    assignedPartitionLocations.add(createPartialSegmentMergeIOConfig.apply(assignedToSameTask));\n-\n     return assignedPartitionLocations;\n   }\n \n+  /**\n+   * Partition items into as evenly-sized splits as possible.\n+   *\n+   * @param index  index of partition\n+   * @param total  number of items to partitions\n+   * @param splits number of desired partitions\n+   *\n+   * @return partition range: [lhs, rhs)\n+   */\n+  private static Pair<Integer, Integer> getPartitionBoundaries(int index, int total, int splits)\n+  {\n+    int chunk = total / splits;\n+    int remainder = total % splits;\n+    int start = index * chunk + (index < remainder ? index : remainder);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "086e6d76c9d41ab4e90220e93a88cafaa9c50414"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NDk3NzM3", "url": "https://github.com/apache/druid/pull/9448#pullrequestreview-367497737", "createdAt": "2020-03-02T20:18:22Z", "commit": {"oid": "086e6d76c9d41ab4e90220e93a88cafaa9c50414"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMDoxODoyMlrOFwt1GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMDoxODoyMlrOFwt1GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNjg0MQ==", "bodyText": "same here for (index < remainder ? 1 : 0)", "url": "https://github.com/apache/druid/pull/9448#discussion_r386626841", "createdAt": "2020-03-02T20:18:22Z", "author": {"login": "maytasm"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/batch/parallel/ParallelIndexSupervisorTask.java", "diffHunk": "@@ -760,29 +761,39 @@ private PartitionBoundaries determineRangePartition(Collection<StringDistributio\n     // See PartitionStat in GeneratedPartitionsReport.\n     final List<Pair<Interval, Integer>> partitions = new ArrayList<>(partitionToLocations.keySet());\n     Collections.shuffle(partitions, ThreadLocalRandom.current());\n-    final int numPartitionsPerTask = (int) Math.round(partitions.size() / (double) numMergeTasks);\n \n     final List<M> assignedPartitionLocations = new ArrayList<>(numMergeTasks);\n-    for (int i = 0; i < numMergeTasks - 1; i++) {\n+    for (int i = 0; i < numMergeTasks; i++) {\n+      Pair<Integer, Integer> partitionBoundaries = getPartitionBoundaries(i, partitions.size(), numMergeTasks);\n       final List<L> assignedToSameTask = partitions\n-          .subList(i * numPartitionsPerTask, (i + 1) * numPartitionsPerTask)\n+          .subList(partitionBoundaries.lhs, partitionBoundaries.rhs)\n           .stream()\n           .flatMap(intervalAndPartitionId -> partitionToLocations.get(intervalAndPartitionId).stream())\n           .collect(Collectors.toList());\n       assignedPartitionLocations.add(createPartialSegmentMergeIOConfig.apply(assignedToSameTask));\n     }\n \n-    // The last task is assigned all remaining partitions.\n-    final List<L> assignedToSameTask = partitions\n-        .subList((numMergeTasks - 1) * numPartitionsPerTask, partitions.size())\n-        .stream()\n-        .flatMap(intervalAndPartitionId -> partitionToLocations.get(intervalAndPartitionId).stream())\n-        .collect(Collectors.toList());\n-    assignedPartitionLocations.add(createPartialSegmentMergeIOConfig.apply(assignedToSameTask));\n-\n     return assignedPartitionLocations;\n   }\n \n+  /**\n+   * Partition items into as evenly-sized splits as possible.\n+   *\n+   * @param index  index of partition\n+   * @param total  number of items to partitions\n+   * @param splits number of desired partitions\n+   *\n+   * @return partition range: [lhs, rhs)\n+   */\n+  private static Pair<Integer, Integer> getPartitionBoundaries(int index, int total, int splits)\n+  {\n+    int chunk = total / splits;\n+    int remainder = total % splits;\n+    int start = index * chunk + (index < remainder ? index : remainder);\n+    int stop = start + chunk + (index < remainder ? 1 : 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "086e6d76c9d41ab4e90220e93a88cafaa9c50414"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NDk5NDQw", "url": "https://github.com/apache/druid/pull/9448#pullrequestreview-367499440", "createdAt": "2020-03-02T20:21:17Z", "commit": {"oid": "086e6d76c9d41ab4e90220e93a88cafaa9c50414"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMDoyMToxOFrOFwt6dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMDoyMToxOFrOFwt6dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyODIxNA==", "bodyText": "Some ideas for other assertions.\n\nVerify that the split is evenly distributed. i.e. we should have 10 tasks with 2 each (for 20), 4 tasks with 3 and 6 tasks with 2 (for 24), etc.", "url": "https://github.com/apache/druid/pull/9448#discussion_r386628214", "createdAt": "2020-03-02T20:21:18Z", "author": {"login": "maytasm"}, "path": "indexing-service/src/test/java/org/apache/druid/indexing/common/task/batch/parallel/ParallelIndexSupervisorTaskTest.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.indexing.common.task.batch.parallel;\n+\n+import org.apache.druid.java.util.common.Intervals;\n+import org.apache.druid.java.util.common.Pair;\n+import org.joda.time.Interval;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.experimental.runners.Enclosed;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+@RunWith(Enclosed.class)\n+public class ParallelIndexSupervisorTaskTest\n+{\n+  @RunWith(Parameterized.class)\n+  public static class CreateMergeIoConfigsTest\n+  {\n+    private static final Function<List<HashPartitionLocation>, PartialHashSegmentMergeIOConfig>\n+        CREATE_PARTIAL_SEGMENT_MERGE_IO_CONFIG = PartialHashSegmentMergeIOConfig::new;\n+\n+    @Parameterized.Parameters(name = \"count = {0}\")\n+    public static Iterable<? extends Object> data()\n+    {\n+      // different scenarios for last (index = 10 - 1 = 9) partition:\n+      return Arrays.asList(\n+          20,  // even partitions per task: round(20 / 10) * (10 - 1) = 2 * 9 = 18 < 20\n+          24,  // round down:               round(24 / 10) * (10 - 1) = 2 * 9 = 18 < 24\n+          25,  // round up to greater:      round(25 / 10) * (10 - 1) = 3 * 9 = 27 > 25 (index out of bounds)\n+          27   // round up to equal:        round(27 / 10) * (10 - 1) = 3 * 9 = 27 == 27 (empty partition)\n+      );\n+    }\n+\n+    @Parameterized.Parameter\n+    public int count;\n+\n+    @Test\n+    public void handlesLastPartitionCorrectly()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "086e6d76c9d41ab4e90220e93a88cafaa9c50414"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NDk5OTQ2", "url": "https://github.com/apache/druid/pull/9448#pullrequestreview-367499946", "createdAt": "2020-03-02T20:22:08Z", "commit": {"oid": "086e6d76c9d41ab4e90220e93a88cafaa9c50414"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4MzQ5NDI5", "url": "https://github.com/apache/druid/pull/9448#pullrequestreview-368349429", "createdAt": "2020-03-03T21:47:31Z", "commit": {"oid": "086e6d76c9d41ab4e90220e93a88cafaa9c50414"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMTo0OTowOVrOFxXygA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMTo1NDoxNFrOFxX8qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNDMwNA==", "bodyText": "to partition?", "url": "https://github.com/apache/druid/pull/9448#discussion_r387314304", "createdAt": "2020-03-03T21:49:09Z", "author": {"login": "jihoonson"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/batch/parallel/ParallelIndexSupervisorTask.java", "diffHunk": "@@ -760,29 +761,39 @@ private PartitionBoundaries determineRangePartition(Collection<StringDistributio\n     // See PartitionStat in GeneratedPartitionsReport.\n     final List<Pair<Interval, Integer>> partitions = new ArrayList<>(partitionToLocations.keySet());\n     Collections.shuffle(partitions, ThreadLocalRandom.current());\n-    final int numPartitionsPerTask = (int) Math.round(partitions.size() / (double) numMergeTasks);\n \n     final List<M> assignedPartitionLocations = new ArrayList<>(numMergeTasks);\n-    for (int i = 0; i < numMergeTasks - 1; i++) {\n+    for (int i = 0; i < numMergeTasks; i++) {\n+      Pair<Integer, Integer> partitionBoundaries = getPartitionBoundaries(i, partitions.size(), numMergeTasks);\n       final List<L> assignedToSameTask = partitions\n-          .subList(i * numPartitionsPerTask, (i + 1) * numPartitionsPerTask)\n+          .subList(partitionBoundaries.lhs, partitionBoundaries.rhs)\n           .stream()\n           .flatMap(intervalAndPartitionId -> partitionToLocations.get(intervalAndPartitionId).stream())\n           .collect(Collectors.toList());\n       assignedPartitionLocations.add(createPartialSegmentMergeIOConfig.apply(assignedToSameTask));\n     }\n \n-    // The last task is assigned all remaining partitions.\n-    final List<L> assignedToSameTask = partitions\n-        .subList((numMergeTasks - 1) * numPartitionsPerTask, partitions.size())\n-        .stream()\n-        .flatMap(intervalAndPartitionId -> partitionToLocations.get(intervalAndPartitionId).stream())\n-        .collect(Collectors.toList());\n-    assignedPartitionLocations.add(createPartialSegmentMergeIOConfig.apply(assignedToSameTask));\n-\n     return assignedPartitionLocations;\n   }\n \n+  /**\n+   * Partition items into as evenly-sized splits as possible.\n+   *\n+   * @param index  index of partition\n+   * @param total  number of items to partitions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "086e6d76c9d41ab4e90220e93a88cafaa9c50414"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNjkwNQ==", "bodyText": "I think index * (chunk + index < remainder ? 1 : 0) is more clear.", "url": "https://github.com/apache/druid/pull/9448#discussion_r387316905", "createdAt": "2020-03-03T21:54:14Z", "author": {"login": "jihoonson"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/batch/parallel/ParallelIndexSupervisorTask.java", "diffHunk": "@@ -760,29 +761,39 @@ private PartitionBoundaries determineRangePartition(Collection<StringDistributio\n     // See PartitionStat in GeneratedPartitionsReport.\n     final List<Pair<Interval, Integer>> partitions = new ArrayList<>(partitionToLocations.keySet());\n     Collections.shuffle(partitions, ThreadLocalRandom.current());\n-    final int numPartitionsPerTask = (int) Math.round(partitions.size() / (double) numMergeTasks);\n \n     final List<M> assignedPartitionLocations = new ArrayList<>(numMergeTasks);\n-    for (int i = 0; i < numMergeTasks - 1; i++) {\n+    for (int i = 0; i < numMergeTasks; i++) {\n+      Pair<Integer, Integer> partitionBoundaries = getPartitionBoundaries(i, partitions.size(), numMergeTasks);\n       final List<L> assignedToSameTask = partitions\n-          .subList(i * numPartitionsPerTask, (i + 1) * numPartitionsPerTask)\n+          .subList(partitionBoundaries.lhs, partitionBoundaries.rhs)\n           .stream()\n           .flatMap(intervalAndPartitionId -> partitionToLocations.get(intervalAndPartitionId).stream())\n           .collect(Collectors.toList());\n       assignedPartitionLocations.add(createPartialSegmentMergeIOConfig.apply(assignedToSameTask));\n     }\n \n-    // The last task is assigned all remaining partitions.\n-    final List<L> assignedToSameTask = partitions\n-        .subList((numMergeTasks - 1) * numPartitionsPerTask, partitions.size())\n-        .stream()\n-        .flatMap(intervalAndPartitionId -> partitionToLocations.get(intervalAndPartitionId).stream())\n-        .collect(Collectors.toList());\n-    assignedPartitionLocations.add(createPartialSegmentMergeIOConfig.apply(assignedToSameTask));\n-\n     return assignedPartitionLocations;\n   }\n \n+  /**\n+   * Partition items into as evenly-sized splits as possible.\n+   *\n+   * @param index  index of partition\n+   * @param total  number of items to partitions\n+   * @param splits number of desired partitions\n+   *\n+   * @return partition range: [lhs, rhs)\n+   */\n+  private static Pair<Integer, Integer> getPartitionBoundaries(int index, int total, int splits)\n+  {\n+    int chunk = total / splits;\n+    int remainder = total % splits;\n+    int start = index * chunk + (index < remainder ? index : remainder);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNjczMA=="}, "originalCommit": {"oid": "086e6d76c9d41ab4e90220e93a88cafaa9c50414"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ad4f2a467d32d1dd3bc983212f9695e4ad7a8c8", "author": {"user": {"login": "ccaominh", "name": "Chi Cao Minh"}}, "url": "https://github.com/apache/druid/commit/4ad4f2a467d32d1dd3bc983212f9695e4ad7a8c8", "committedDate": "2020-03-04T02:09:51Z", "message": "Improve comments and tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4OTkzMTE1", "url": "https://github.com/apache/druid/pull/9448#pullrequestreview-368993115", "createdAt": "2020-03-04T17:51:53Z", "commit": {"oid": "4ad4f2a467d32d1dd3bc983212f9695e4ad7a8c8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2984, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}