{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwMjA4NDYy", "number": 9407, "title": "query laning and load shedding", "bodyText": "Description\nInitial piece of #6993, adding basic query laning facilities for capacity enforcement. Note that to keep things simpler to review, this PR does not include automatic prioritization, this will be done in a follow-up PR that builds on top of this branch.\nThis PR introduces the concept of query lanes, and using them as a mean to control capacity allotments to 'classes' of queries. Based on the vivid discussion in #6993, a QueryLaningStrategy interface has been introduced to try and ensure this foundation is appropriately expressive for the variety of strategies discussed in that PR.\nTo make this happen, an opinionated stance has been taken on the purpose of QueryManager, which has been renamed QueryScheduler. QueryScheduler, in addition to continuing to provide cancellation facilities of QueryManager, is now also responsible for enforcing lane limits, by computing what lane a query belongs to with the help of the configured QueryLaningStrategy, and trying to acquire a semaphore. If available, query processing proceeds, otherwise a new QueryCapacityExceededException is thrown, which currently is mapped to an HTTP 429 response code (instead of 503 for the reasons discussed in #6993) by the QueryResource and SqlResource endpoints.\nThe lane assignment is happens on the broker, in CachingClusteredClient so that the laning strategy has access to the number of segments taking part in the query as well as the pool of servers available to query for those segments.\nAs a proof of concept, two initial laning strategies are included in this PR, a 'No laning strategy' which does nothing and behaves as the current behavior of the only limit being the size of the HTTP thread pool, and a 'High/Low' laning strategy, which classes any query with a priority set in the query context less than 0 to be in the 'low' lane.\nThe lane semaphores are provided through resilience4j-bulkhead, which simplified the code a bit compared to the map of semaphores my initial prototype relied on, but functionally appears to have little difference. I encountered this library from #8357, which proposes using an alternative library, concurrency-limits which is very interesting, but I was worried about the initial complexity of using measurement based dynamic limits for the lane enforcement.\nI do think this is worth exploring in the future, either strictly for total capacity enforcement or for more I am currently unsure. AbstractPartitionedLimiter seems very close to what we might want to enforce laning, but it provides a slightly different at least guarantee than the at most guarantee that this PR is currently providing, where I feel the at most works a bit better with our fixed Jetty thread pool size. However, since lane limit enforcement is entirely contained within QueryScheduler, it is likely not a ton of effort to switch libraries if we find in the future that we can get better behavior with concurrency-limits, just as I swapped from my map of Semaphore to using BulkheadRegistry.\nWhy not QosFilter\nJetty has a QoSFilter which almost provided the machinery required for the total capacity enforcement, but logically does not occur late enough to have sufficient information to be able to perform some of the decisions desired in #6993, particularly with regards to things like number of segments or information about which servers are available to take part in a query, which required being further down in CachingClusteredClient closer to where the actual query stuffs are happening.\nFollow-up improvements\nManual laning and end to end integration tests\nA query lane is just a query context property, so allowing a custom static lane limit configuration is a low effort follow-up that could probably support a lot of simple custom capacity planning solutions, and easier testing of this functionality in integration tests. clintropolis/druid@query-laning-and-load-shedding...clintropolis:manual-query-laning\nAutomatic prioritization\nThe other half of #6993, I want to follow-up this PR immediately with another that will add in the threshold based automatic prioritization described in the design document.\nclintropolis/druid@query-laning-and-load-shedding...clintropolis:query-auto-prioritization\nLane based TierSelectorStrategy\nPart of the motivation for laning is providing Druid with the means to avoid the necessity to run multiple pools of brokers. One of the reasons this is currently done is to have separate pools of Brokers which have differently configured tier selection strategies to router different types of queries to reduce historical contention (druid.broker.select.tier, etc). By extending QueryLaningStrategy to allow fetching a TierSelectorStrategy, e.g.:\nTierSelectorStrategy getTierSelectorStrategy(Query<T> query);\n\nwhich the brokers CachingClusteredClient could use along with a lightly modified ServerSelector that allows providing a TierSelectorStrategy to the pick method in order to override the default broker configuration.\nTier based laning\nAdding a new TieredQueryLaningStrategy to allow capacity control based on the historical tier that a query will be routed to, for scenarios where historical tiers serve disjoint intervals or datasources. This is to serve as a partial replacement/alternative to druid.router.tierToBrokerMap, which allows a Druid router to route queries to different pools of Druid brokers based on what tier a query belongs to, allowing partitioning of queries between different pools of resources. Instead, this will be able to be done within a single broker pool, reserving capacity for queries going to each lane.\nBetter utilization and automatic cancellation of lower priority queries\nThe initial solution will introduce an under-utilization problem, if all queries are low priority they will still be limited by the lane limits. Longer term, we should be able to utilize the entire HTTP thread pool with any lane of query, and cancel them when higher priority lanes come in.\nLane limit enforcement on historicals and peons/indexers\nEverything will already have a QueryScheduler as of this PR, because it is the only implementation of QueryWatcher, we just need to wire a call to run into these services to allow them to enforce these limits as well. On the broker side, we will want to watch for these responses and cancel the query for over-running capacity.\nAdaptive limits\nThe current iteration of this PR is going to require a bunch of calculations to figure out what the correct lane limits are for a given cluster size. Longer term, it would be nice for these to be  adaptively computed to adjust lane limits to be higher or lower based on cluster size and/or back-pressure from historicals.\nProcessing pool enhancements\nWith lane limits in place, we can explore additional options for how the processing pool functions such as exploring preemption of lower priority queries by higher priority lanes. Using the existing priorities, lower priority queries can already experience starvation, but this becomes greatly exaggerated if the processing pool allows preempting the per segment results. But with lane limits in place, we can ensure that the per query resources such as the HTTP thread pools cannot be overrun by starving low priority queries.\n\nThis PR has:\n\n been self-reviewed.\n\n using the concurrency checklist (Remove this item if the PR doesn't have any relation to concurrency.)\n\n\n added documentation for new or modified features or behaviors.\n added Javadocs for most classes and all non-trivial methods. Linked related entities via Javadoc links.\n added or updated version, license, or notice information in licenses.yaml\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.\n added unit tests or modified existing tests to cover new code paths.\n added integration tests.\n been tested in a test Druid cluster.\n\n\n\nKey changed/added classes in this PR\n\nQueryManager -> QueryScheduler\nQuerySchedulerConfig\nQueryLaningStrategy and implementations\nQueryResource and SqlResource", "createdAt": "2020-02-26T12:21:22Z", "url": "https://github.com/apache/druid/pull/9407", "merged": true, "mergeCommit": {"oid": "8b9fe6f58461f1fc3f453c14f1634f9e779aeb71"}, "closed": true, "closedAt": "2020-03-10T09:57:17Z", "author": {"login": "clintropolis"}, "timelineItems": {"totalCount": 48, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcHv2ppgH2gAyMzgwMjA4NDYyOjYyMjA5ODU1NTliNGZhOTQxZTI1ZTYxY2FhNTg0NmM3Y2U4ZTM2OGE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcMNbDGgFqTM3MTY4NDkyMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6220985559b4fa941e25e61caa5846c7ce8e368a", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/6220985559b4fa941e25e61caa5846c7ce8e368a", "committedDate": "2020-02-25T10:48:47Z", "message": "prototype"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f410014da090c7df66df293a1894da3486cabaa", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/3f410014da090c7df66df293a1894da3486cabaa", "committedDate": "2020-02-25T10:48:47Z", "message": "merge QueryScheduler and QueryManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "feae8b193d73354366ce683c0ef405e366c8e31b", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/feae8b193d73354366ce683c0ef405e366c8e31b", "committedDate": "2020-02-25T10:48:47Z", "message": "everything in its right place"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "554b8b514a6c92d04f806960eaf33ebb366ab21a", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/554b8b514a6c92d04f806960eaf33ebb366ab21a", "committedDate": "2020-02-25T18:41:00Z", "message": "adjustments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0597c3f87117a8f35785a3cea7ba8f9b4e7e8511", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/0597c3f87117a8f35785a3cea7ba8f9b4e7e8511", "committedDate": "2020-02-26T12:15:34Z", "message": "docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "405c94e52988ebb1381b3e9337e1d6ff11331ada", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/405c94e52988ebb1381b3e9337e1d6ff11331ada", "committedDate": "2020-02-27T11:38:39Z", "message": "fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1NzgzMzM0", "url": "https://github.com/apache/druid/pull/9407#pullrequestreview-365783334", "createdAt": "2020-02-27T16:03:02Z", "commit": {"oid": "405c94e52988ebb1381b3e9337e1d6ff11331ada"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNjowMzowMlrOFvXCWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNjowMzowMlrOFvXCWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIwNDgyNw==", "bodyText": "a variety of mechanisms examine\nI believe a \"to\" is missing here ?", "url": "https://github.com/apache/druid/pull/9407#discussion_r385204827", "createdAt": "2020-02-27T16:03:02Z", "author": {"login": "sascha-coenen"}, "path": "docs/configuration/index.md", "diffHunk": "@@ -1476,9 +1476,31 @@ These Broker configurations can be defined in the `broker/runtime.properties` fi\n |`druid.broker.select.tier`|`highestPriority`, `lowestPriority`, `custom`|If segments are cross-replicated across tiers in a cluster, you can tell the broker to prefer to select segments in a tier with a certain priority.|`highestPriority`|\n |`druid.broker.select.tier.custom.priorities`|`An array of integer priorities.`|Select servers in tiers with a custom priority list.|None|\n \n+##### Query laning\n+\n+Druid provides facilities to aid in query capacity reservation for heterogenous query workloads in the form of 'laning' strategies, which provide a variety of mechanisms examine and classify a query at the broker, assigning it to a 'lane'. Lanes are defined with capacity limits which the broker will enforce, causing requests in excess of the capacity to be discarded with an HTTP 429 status code, reserving resources for other lanes or for interactive queries (with no lane). ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405c94e52988ebb1381b3e9337e1d6ff11331ada"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e22ece12861765ec3eeccc6531c283e717785969", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/e22ece12861765ec3eeccc6531c283e717785969", "committedDate": "2020-02-28T00:11:50Z", "message": "doc fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e98cad76992ced1659ab75834bab7a8967eaa33e", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/e98cad76992ced1659ab75834bab7a8967eaa33e", "committedDate": "2020-02-28T05:48:15Z", "message": "use resilience4j instead of semaphore"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2069437298c6b111804d0fd18034514c47ae8f1b", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/2069437298c6b111804d0fd18034514c47ae8f1b", "committedDate": "2020-02-28T06:59:43Z", "message": "more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eaf1449a360506a85257f16abe25201875af8387", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/eaf1449a360506a85257f16abe25201875af8387", "committedDate": "2020-02-28T08:42:09Z", "message": "simplify"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "688ca43af1f246dd6578e2ace96778cdb3571cff", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/688ca43af1f246dd6578e2ace96778cdb3571cff", "committedDate": "2020-02-28T11:09:06Z", "message": "checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0b3f9f02be406e42e8fa523716c630d2b21aa36", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/f0b3f9f02be406e42e8fa523716c630d2b21aa36", "committedDate": "2020-02-28T19:11:38Z", "message": "spelling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87c6cbd1660d4981fc3618feed9210f91a218ca5", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/87c6cbd1660d4981fc3618feed9210f91a218ca5", "committedDate": "2020-02-28T22:15:22Z", "message": "oops heh"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e91bcba6661334d8b6d6dc745ce2cd68037ca0e", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/5e91bcba6661334d8b6d6dc745ce2cd68037ca0e", "committedDate": "2020-02-28T22:17:34Z", "message": "remove unused"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "912b7bc43d5406114f85e85918e04b8c01a9bf7f", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/912b7bc43d5406114f85e85918e04b8c01a9bf7f", "committedDate": "2020-02-29T03:07:33Z", "message": "simplify"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e384bf9e4d8c2cae1cf12e894aa2afa00e9a9c1", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/1e384bf9e4d8c2cae1cf12e894aa2afa00e9a9c1", "committedDate": "2020-03-02T11:48:27Z", "message": "concurrency tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60861a43fd25bca15aa3215988252bc392b3ad3f", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/60861a43fd25bca15aa3215988252bc392b3ad3f", "committedDate": "2020-03-03T06:02:13Z", "message": "add SqlResource tests, refactor error response"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9aed16e6ca23d413d30554ebfd8157210849e67b", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/9aed16e6ca23d413d30554ebfd8157210849e67b", "committedDate": "2020-03-04T01:13:23Z", "message": "add json config tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "419ab98ef48eb0a7590bb064393c424a553d3544", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/419ab98ef48eb0a7590bb064393c424a553d3544", "committedDate": "2020-03-04T01:19:13Z", "message": "use LongAdder instead of AtomicLong"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0d39e1dd4108c9ee803fd6335c515813a892d14", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/f0d39e1dd4108c9ee803fd6335c515813a892d14", "committedDate": "2020-03-04T02:04:05Z", "message": "remove test only stuffs from scheduler"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2afaaf1150b7808e8543e87eecf45ecd9bf8b9fe", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/2afaaf1150b7808e8543e87eecf45ecd9bf8b9fe", "committedDate": "2020-03-04T11:45:53Z", "message": "javadocs, etc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/ef029c4a894aafd4b17ca903e77ae497e41034ba", "committedDate": "2020-03-04T12:13:46Z", "message": "style"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTU4MzI1", "url": "https://github.com/apache/druid/pull/9407#pullrequestreview-369158325", "createdAt": "2020-03-04T22:05:12Z", "commit": {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba"}, "state": "COMMENTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMjowNToxM1rOFx_XWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMToyNToyOFrOFyqWzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk2MjcxNQ==", "bodyText": "Perhaps the setting name (\"type\") and the name in the docs (\"strategy\") should be made consistent.\nIn terms of documentation flow, it may be helpful to add a section below (e.g. \"Laning strategy\") and reference it here. \"No laning strategy\", etc. would be children on this new section.", "url": "https://github.com/apache/druid/pull/9407#discussion_r387962715", "createdAt": "2020-03-04T22:05:13Z", "author": {"login": "ccaominh"}, "path": "docs/configuration/index.md", "diffHunk": "@@ -1476,9 +1476,31 @@ These Broker configurations can be defined in the `broker/runtime.properties` fi\n |`druid.broker.select.tier`|`highestPriority`, `lowestPriority`, `custom`|If segments are cross-replicated across tiers in a cluster, you can tell the broker to prefer to select segments in a tier with a certain priority.|`highestPriority`|\n |`druid.broker.select.tier.custom.priorities`|`An array of integer priorities.`|Select servers in tiers with a custom priority list.|None|\n \n+##### Query laning\n+\n+The Broker provides facilities to aid in query capacity reservation for heterogeneous query workloads in the form of 'laning' strategies, which provide a variety of mechanisms to examine and classify a query, assigning it to a 'lane'. Lanes are defined with capacity limits which the broker will enforce, causing requests in excess of the capacity to be discarded with an HTTP 429 status code, reserving resources for other lanes or for interactive queries (with no lane).\n+\n+|Property|Description|Default|\n+|--------|-----------|-------|\n+|`druid.query.scheduler.numThreads`|Maximum number of HTTP threads to dedicate to query processing. To save HTTP thread capacity, this should be lower than `druid.server.http.numThreads`.|Unbounded|\n+|`druid.query.scheduler.laning.type`|Query laning strategy to use to assign queries to a lane in order to control capacities for certain classes of queries.|`none`|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk2NDUwNQ==", "bodyText": "Consider adding:\nThis strategy can be enabled by setting druid.query.scheduler.laning.type to none.", "url": "https://github.com/apache/druid/pull/9407#discussion_r387964505", "createdAt": "2020-03-04T22:09:05Z", "author": {"login": "ccaominh"}, "path": "docs/configuration/index.md", "diffHunk": "@@ -1476,9 +1476,31 @@ These Broker configurations can be defined in the `broker/runtime.properties` fi\n |`druid.broker.select.tier`|`highestPriority`, `lowestPriority`, `custom`|If segments are cross-replicated across tiers in a cluster, you can tell the broker to prefer to select segments in a tier with a certain priority.|`highestPriority`|\n |`druid.broker.select.tier.custom.priorities`|`An array of integer priorities.`|Select servers in tiers with a custom priority list.|None|\n \n+##### Query laning\n+\n+The Broker provides facilities to aid in query capacity reservation for heterogeneous query workloads in the form of 'laning' strategies, which provide a variety of mechanisms to examine and classify a query, assigning it to a 'lane'. Lanes are defined with capacity limits which the broker will enforce, causing requests in excess of the capacity to be discarded with an HTTP 429 status code, reserving resources for other lanes or for interactive queries (with no lane).\n+\n+|Property|Description|Default|\n+|--------|-----------|-------|\n+|`druid.query.scheduler.numThreads`|Maximum number of HTTP threads to dedicate to query processing. To save HTTP thread capacity, this should be lower than `druid.server.http.numThreads`.|Unbounded|\n+|`druid.query.scheduler.laning.type`|Query laning strategy to use to assign queries to a lane in order to control capacities for certain classes of queries.|`none`|\n+\n+###### No laning strategy\n+\n+In this mode, queries are never assigned a lane and only limited by `druid.server.http.numThreads` or `druid.query.scheduler.numThreads`, if set. This is the default Druid query scheduler operating mode.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTc4NA==", "bodyText": "Was this added to the docs?", "url": "https://github.com/apache/druid/pull/9407#discussion_r387991784", "createdAt": "2020-03-04T23:16:48Z", "author": {"login": "ccaominh"}, "path": "processing/src/main/java/org/apache/druid/query/QueryContexts.java", "diffHunk": "@@ -35,6 +35,7 @@\n public class QueryContexts\n {\n   public static final String PRIORITY_KEY = \"priority\";\n+  public static final String LANE_KEY = \"lane\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5OTE0OA==", "bodyText": "There's some similarity between this and QueryInterruptedException and ResourceLimitExceededException and at first glance it may be unclear when to use which (perhaps mitigated by adding javadocs to this class). Is there a way to incorporate this into the same pattern in the QueryInterruptedException implementation?", "url": "https://github.com/apache/druid/pull/9407#discussion_r387999148", "createdAt": "2020-03-04T23:38:35Z", "author": {"login": "ccaominh"}, "path": "server/src/main/java/org/apache/druid/server/QueryCapacityExceededException.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.QueryException;\n+\n+public class QueryCapacityExceededException extends QueryException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxMjk5OQ==", "bodyText": "Is it useful to test when QueryContexts.LANE_KEY is set?", "url": "https://github.com/apache/druid/pull/9407#discussion_r388012999", "createdAt": "2020-03-05T00:23:34Z", "author": {"login": "ccaominh"}, "path": "server/src/test/java/org/apache/druid/server/scheduling/HiLoQueryLaningStrategyTest.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.java.util.common.Intervals;\n+import org.apache.druid.java.util.common.granularity.Granularities;\n+import org.apache.druid.query.Druids;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.aggregation.CountAggregatorFactory;\n+import org.apache.druid.query.timeseries.TimeseriesQuery;\n+import org.apache.druid.server.QueryLaningStrategy;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+public class HiLoQueryLaningStrategyTest\n+{\n+  @Rule\n+  public ExpectedException expectedException = ExpectedException.none();\n+\n+  private Druids.TimeseriesQueryBuilder queryBuilder;\n+  private HiLoQueryLaningStrategy strategy;\n+\n+  @Before\n+  public void setup()\n+  {\n+    this.queryBuilder = Druids.newTimeseriesQueryBuilder()\n+                              .dataSource(\"test\")\n+                              .intervals(ImmutableList.of(Intervals.ETERNITY))\n+                              .granularity(Granularities.DAY)\n+                              .aggregators(new CountAggregatorFactory(\"count\"));\n+\n+    this.strategy = new HiLoQueryLaningStrategy(10);\n+  }\n+\n+  @Test\n+  public void testMaxLowThreadsRequired()\n+  {\n+    expectedException.expect(NullPointerException.class);\n+    expectedException.expectMessage(\"maxLowThreads must be set\");\n+    QueryLaningStrategy strategy = new HiLoQueryLaningStrategy(null);\n+  }\n+\n+  @Test\n+  public void testLaneLimits()\n+  {\n+    Object2IntMap<String> laneConfig = strategy.getLaneLimits();\n+    Assert.assertEquals(1, laneConfig.size());\n+    Assert.assertTrue(laneConfig.containsKey(HiLoQueryLaningStrategy.LOW));\n+    Assert.assertEquals(10, laneConfig.getInt(HiLoQueryLaningStrategy.LOW));\n+  }\n+\n+  @Test\n+  public void testLaningNoPriority()\n+  {\n+    TimeseriesQuery query = queryBuilder.build();\n+    Assert.assertFalse(strategy.computeLane(QueryPlus.wrap(query), ImmutableSet.of()).isPresent());\n+  }\n+\n+  @Test\n+  public void testLaningZeroPriority()\n+  {\n+    TimeseriesQuery query = queryBuilder.context(ImmutableMap.of(QueryContexts.PRIORITY_KEY, 0)).build();\n+    Assert.assertFalse(strategy.computeLane(QueryPlus.wrap(query), ImmutableSet.of()).isPresent());\n+  }\n+\n+  @Test\n+  public void testLaningInteractivePriority()\n+  {\n+    TimeseriesQuery query = queryBuilder.context(ImmutableMap.of(QueryContexts.PRIORITY_KEY, 100)).build();\n+    Assert.assertFalse(strategy.computeLane(QueryPlus.wrap(query), ImmutableSet.of()).isPresent());\n+  }\n+\n+  @Test\n+  public void testLaningLowPriority()\n+  {\n+    TimeseriesQuery query = queryBuilder.context(ImmutableMap.of(QueryContexts.PRIORITY_KEY, -1)).build();\n+    Assert.assertTrue(strategy.computeLane(QueryPlus.wrap(query), ImmutableSet.of()).isPresent());\n+    Assert.assertEquals(\n+        HiLoQueryLaningStrategy.LOW,\n+        strategy.computeLane(QueryPlus.wrap(query), ImmutableSet.of()).get()\n+    );\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNjI3OQ==", "bodyText": "Perhaps rename to maxLowHttpThreads so that it's not confused with the number of processing threads", "url": "https://github.com/apache/druid/pull/9407#discussion_r388016279", "createdAt": "2020-03-05T00:35:09Z", "author": {"login": "ccaominh"}, "path": "docs/configuration/index.md", "diffHunk": "@@ -1476,9 +1476,31 @@ These Broker configurations can be defined in the `broker/runtime.properties` fi\n |`druid.broker.select.tier`|`highestPriority`, `lowestPriority`, `custom`|If segments are cross-replicated across tiers in a cluster, you can tell the broker to prefer to select segments in a tier with a certain priority.|`highestPriority`|\n |`druid.broker.select.tier.custom.priorities`|`An array of integer priorities.`|Select servers in tiers with a custom priority list.|None|\n \n+##### Query laning\n+\n+The Broker provides facilities to aid in query capacity reservation for heterogeneous query workloads in the form of 'laning' strategies, which provide a variety of mechanisms to examine and classify a query, assigning it to a 'lane'. Lanes are defined with capacity limits which the broker will enforce, causing requests in excess of the capacity to be discarded with an HTTP 429 status code, reserving resources for other lanes or for interactive queries (with no lane).\n+\n+|Property|Description|Default|\n+|--------|-----------|-------|\n+|`druid.query.scheduler.numThreads`|Maximum number of HTTP threads to dedicate to query processing. To save HTTP thread capacity, this should be lower than `druid.server.http.numThreads`.|Unbounded|\n+|`druid.query.scheduler.laning.type`|Query laning strategy to use to assign queries to a lane in order to control capacities for certain classes of queries.|`none`|\n+\n+###### No laning strategy\n+\n+In this mode, queries are never assigned a lane and only limited by `druid.server.http.numThreads` or `druid.query.scheduler.numThreads`, if set. This is the default Druid query scheduler operating mode.\n+\n+###### 'High/Low' laning strategy\n+This laning strategy splits queries with a `priority` below zero into a `low` query lane, automatically. The limit on `low` queries can be set to some desired fraction of the total capacity (or HTTP thread pool size), reserving capacity for interactive queries. Queries in the `low` lane are _not_ guaranteed their capacity, which may be consumed by interactive queries, but may use up to this limit if total capacity is available. \n+\n+This strategy can be enabled by setting `druid.query.scheduler.laning.type` to `hilo`.\n+\n+|Property|Description|Default|\n+|--------|-----------|-------|\n+|`druid.query.scheduler.laning.maxLowThreads`|Maximum number of HTTP threads that can be used by queries with a priority lower than 0.|No default, must be set if using this mode|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNjU0Ng==", "bodyText": "Left a comment in the docs about the property name", "url": "https://github.com/apache/druid/pull/9407#discussion_r388016546", "createdAt": "2020-03-05T00:35:56Z", "author": {"login": "ccaominh"}, "path": "server/src/main/java/org/apache/druid/server/scheduling/HiLoQueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.QueryLaningStrategy;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Query laning strategy which associates all {@link Query} with priority lower than 0 into a 'low' lane\n+ */\n+public class HiLoQueryLaningStrategy implements QueryLaningStrategy\n+{\n+  public static final String LOW = \"low\";\n+\n+  @JsonProperty\n+  private final int maxLowThreads;\n+\n+  @JsonCreator\n+  public HiLoQueryLaningStrategy(\n+      @JsonProperty(\"maxLowThreads\") Integer maxLowThreads", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMTg1MQ==", "bodyText": "Thanks for adding all the javadocs that were missing before!", "url": "https://github.com/apache/druid/pull/9407#discussion_r388631851", "createdAt": "2020-03-05T23:51:24Z", "author": {"login": "ccaominh"}, "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(totalNumThreads));\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMjI1Ng==", "bodyText": "Consider adding a named constant for the -1 (similar for getLaneAvailableCapacity)", "url": "https://github.com/apache/druid/pull/9407#discussion_r388632256", "createdAt": "2020-03-05T23:52:49Z", "author": {"login": "ccaominh"}, "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(totalNumThreads));\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  public int getTotalAvailableCapacity()\n+  {\n+    return laneRegistry.getConfiguration(TOTAL)\n+                       .map(config -> laneRegistry.bulkhead(TOTAL, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY1OTcyMw==", "bodyText": "May be better to do this in a exception handler in case there's an unexpected error between the two acquisitions. I don't think there's a test for this scenario?", "url": "https://github.com/apache/druid/pull/9407#discussion_r388659723", "createdAt": "2020-03-06T01:05:11Z", "author": {"login": "ccaominh"}, "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(totalNumThreads));\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  public int getTotalAvailableCapacity()\n+  {\n+    return laneRegistry.getConfiguration(TOTAL)\n+                       .map(config -> laneRegistry.bulkhead(TOTAL, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support for a given lane\n+   */\n+  public int getLaneAvailableCapacity(String lane)\n+  {\n+    return laneRegistry.getConfiguration(lane)\n+                       .map(config -> laneRegistry.bulkhead(lane, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Acquire a semaphore for both the 'total' and a lane, if any is associated with a query\n+   */\n+  @VisibleForTesting\n+  List<Bulkhead> acquireLanes(Query<?> query)\n+  {\n+    final String lane = QueryContexts.getLane(query);\n+    final Optional<BulkheadConfig> laneConfig = lane == null ? Optional.empty() : laneRegistry.getConfiguration(lane);\n+    List<Bulkhead> hallPasses = new ArrayList<>(2);\n+    final Optional<BulkheadConfig> totalConfig = laneRegistry.getConfiguration(TOTAL);\n+    // if we have a lane, get it first\n+    laneConfig.ifPresent(config -> {\n+      Bulkhead laneLimiter = laneRegistry.bulkhead(lane, config);\n+      if (!laneLimiter.tryAcquirePermission()) {\n+        throw new QueryCapacityExceededException(lane);\n+      }\n+      hallPasses.add(laneLimiter);\n+    });\n+\n+    // everyone needs to take one from the total lane; to ensure we don't acquire a lane and never release it, we want\n+    // to check for total capacity exceeded and release the lane (if present) before throwing capacity exceeded\n+    totalConfig.ifPresent(config -> {\n+      Bulkhead totalLimiter = laneRegistry.bulkhead(TOTAL, config);\n+      if (!totalLimiter.tryAcquirePermission()) {\n+        releaseLanes(hallPasses);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2MjA1MQ==", "bodyText": "Maybe rename to \"bulkhead\"", "url": "https://github.com/apache/druid/pull/9407#discussion_r388662051", "createdAt": "2020-03-06T01:08:33Z", "author": {"login": "ccaominh"}, "path": "server/src/test/java/org/apache/druid/server/QuerySchedulerTest.java", "diffHunk": "@@ -0,0 +1,566 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.ListeningExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.inject.Injector;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import org.apache.druid.guice.GuiceInjectors;\n+import org.apache.druid.guice.JsonConfigProvider;\n+import org.apache.druid.guice.JsonConfigurator;\n+import org.apache.druid.guice.annotations.Global;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.BaseSequence;\n+import org.apache.druid.java.util.common.guava.LazySequence;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.java.util.common.guava.SequenceWrapper;\n+import org.apache.druid.java.util.common.guava.Sequences;\n+import org.apache.druid.java.util.common.guava.Yielder;\n+import org.apache.druid.java.util.common.guava.Yielders;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.aggregation.CountAggregatorFactory;\n+import org.apache.druid.query.topn.TopNQuery;\n+import org.apache.druid.query.topn.TopNQueryBuilder;\n+import org.apache.druid.server.scheduling.HiLoQueryLaningStrategy;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class QuerySchedulerTest\n+{\n+  private static final int NUM_CONCURRENT_QUERIES = 10000;\n+  private static final int NUM_ROWS = 10000;\n+\n+  @Rule\n+  public ExpectedException expected = ExpectedException.none();\n+\n+  private ListeningExecutorService executorService;\n+  private QueryScheduler scheduler;\n+\n+  private AtomicLong totalAcquired;\n+  private AtomicLong totalReleased;\n+  private AtomicLong laneAcquired;\n+  private AtomicLong laneNotAcquired;\n+  private AtomicLong laneReleased;\n+\n+  @Before\n+  public void setup()\n+  {\n+    executorService = MoreExecutors.listeningDecorator(\n+        Execs.multiThreaded(8, \"test_query_scheduler_%s\")\n+    );\n+    totalAcquired = new AtomicLong();\n+    totalReleased = new AtomicLong();\n+    laneAcquired = new AtomicLong();\n+    laneNotAcquired = new AtomicLong();\n+    laneReleased = new AtomicLong();\n+    scheduler = new QueryScheduler(5, new HiLoQueryLaningStrategy(2)) {\n+      @Override\n+      List<Bulkhead> acquireLanes(Query<?> query)\n+      {\n+        List<Bulkhead> bulkheads = super.acquireLanes(query);\n+        if (bulkheads.stream().anyMatch(b -> b.getName().equals(QueryScheduler.TOTAL))) {\n+          totalAcquired.incrementAndGet();\n+        }\n+        if (bulkheads.stream().anyMatch(b -> !b.getName().equals(QueryScheduler.TOTAL))) {\n+          laneAcquired.incrementAndGet();\n+        }\n+\n+        return bulkheads;\n+      }\n+\n+      @Override\n+      void releaseLanes(List<Bulkhead> bulkheads)\n+      {\n+        super.releaseLanes(bulkheads);\n+        if (bulkheads.stream().anyMatch(b -> b.getName().equals(QueryScheduler.TOTAL))) {\n+          totalReleased.incrementAndGet();\n+        }\n+        if (bulkheads.stream().anyMatch(b -> !b.getName().equals(QueryScheduler.TOTAL))) {\n+          laneReleased.incrementAndGet();\n+          if (bulkheads.size() == 1) {\n+            laneNotAcquired.incrementAndGet();\n+          }\n+        }\n+      }\n+    };\n+  }\n+\n+  @After\n+  public void teardown()\n+  {\n+    executorService.shutdownNow();\n+  }\n+\n+  @Test\n+  public void testHiLoHi() throws ExecutionException, InterruptedException\n+  {\n+    TopNQuery interactive = makeInteractiveQuery();\n+    ListenableFuture<?> future = executorService.submit(() -> {\n+      try {\n+        Query<?> scheduled = scheduler.laneQuery(QueryPlus.wrap(interactive), ImmutableSet.of());\n+\n+        Assert.assertNotNull(scheduled);\n+\n+        Sequence<Integer> underlyingSequence = makeSequence(10);\n+        underlyingSequence = Sequences.wrap(underlyingSequence, new SequenceWrapper()\n+        {\n+          @Override\n+          public void before()\n+          {\n+            Assert.assertEquals(4, scheduler.getTotalAvailableCapacity());\n+            Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(HiLoQueryLaningStrategy.LOW));\n+          }\n+        });\n+        Sequence<Integer> results = scheduler.run(scheduled, underlyingSequence);\n+        int rowCount = consumeAndCloseSequence(results);\n+\n+        Assert.assertEquals(10, rowCount);\n+      }\n+      catch (IOException ex) {\n+        throw new RuntimeException(ex);\n+      }\n+    });\n+    future.get();\n+    Assert.assertEquals(5, scheduler.getTotalAvailableCapacity());\n+  }\n+\n+  @Test\n+  public void testHiLoLo() throws ExecutionException, InterruptedException\n+  {\n+    TopNQuery report = makeReportQuery();\n+    ListenableFuture<?> future = executorService.submit(() -> {\n+      try {\n+        Query<?> scheduledReport = scheduler.laneQuery(QueryPlus.wrap(report), ImmutableSet.of());\n+        Assert.assertNotNull(scheduledReport);\n+        Assert.assertEquals(HiLoQueryLaningStrategy.LOW, QueryContexts.getLane(scheduledReport));\n+\n+        Sequence<Integer> underlyingSequence = makeSequence(10);\n+        underlyingSequence = Sequences.wrap(underlyingSequence, new SequenceWrapper()\n+        {\n+          @Override\n+          public void before()\n+          {\n+            Assert.assertEquals(4, scheduler.getTotalAvailableCapacity());\n+            Assert.assertEquals(1, scheduler.getLaneAvailableCapacity(HiLoQueryLaningStrategy.LOW));\n+          }\n+        });\n+        Sequence<Integer> results = scheduler.run(scheduledReport, underlyingSequence);\n+\n+        int rowCount = consumeAndCloseSequence(results);\n+        Assert.assertEquals(10, rowCount);\n+      }\n+      catch (IOException ex) {\n+        throw new RuntimeException(ex);\n+      }\n+    });\n+    future.get();\n+    Assert.assertEquals(5, scheduler.getTotalAvailableCapacity());\n+    Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(HiLoQueryLaningStrategy.LOW));\n+  }\n+\n+  @Test\n+  public void testHiLoReleaseSemaphoreWhenSequenceExplodes() throws Exception", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2MzE4Ng==", "bodyText": "This assert is not executed. Maybe use an exception handler instead of expected?", "url": "https://github.com/apache/druid/pull/9407#discussion_r388663186", "createdAt": "2020-03-06T01:11:05Z", "author": {"login": "ccaominh"}, "path": "server/src/test/java/org/apache/druid/server/QuerySchedulerTest.java", "diffHunk": "@@ -0,0 +1,566 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.ListeningExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.inject.Injector;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import org.apache.druid.guice.GuiceInjectors;\n+import org.apache.druid.guice.JsonConfigProvider;\n+import org.apache.druid.guice.JsonConfigurator;\n+import org.apache.druid.guice.annotations.Global;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.BaseSequence;\n+import org.apache.druid.java.util.common.guava.LazySequence;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.java.util.common.guava.SequenceWrapper;\n+import org.apache.druid.java.util.common.guava.Sequences;\n+import org.apache.druid.java.util.common.guava.Yielder;\n+import org.apache.druid.java.util.common.guava.Yielders;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.aggregation.CountAggregatorFactory;\n+import org.apache.druid.query.topn.TopNQuery;\n+import org.apache.druid.query.topn.TopNQueryBuilder;\n+import org.apache.druid.server.scheduling.HiLoQueryLaningStrategy;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class QuerySchedulerTest\n+{\n+  private static final int NUM_CONCURRENT_QUERIES = 10000;\n+  private static final int NUM_ROWS = 10000;\n+\n+  @Rule\n+  public ExpectedException expected = ExpectedException.none();\n+\n+  private ListeningExecutorService executorService;\n+  private QueryScheduler scheduler;\n+\n+  private AtomicLong totalAcquired;\n+  private AtomicLong totalReleased;\n+  private AtomicLong laneAcquired;\n+  private AtomicLong laneNotAcquired;\n+  private AtomicLong laneReleased;\n+\n+  @Before\n+  public void setup()\n+  {\n+    executorService = MoreExecutors.listeningDecorator(\n+        Execs.multiThreaded(8, \"test_query_scheduler_%s\")\n+    );\n+    totalAcquired = new AtomicLong();\n+    totalReleased = new AtomicLong();\n+    laneAcquired = new AtomicLong();\n+    laneNotAcquired = new AtomicLong();\n+    laneReleased = new AtomicLong();\n+    scheduler = new QueryScheduler(5, new HiLoQueryLaningStrategy(2)) {\n+      @Override\n+      List<Bulkhead> acquireLanes(Query<?> query)\n+      {\n+        List<Bulkhead> bulkheads = super.acquireLanes(query);\n+        if (bulkheads.stream().anyMatch(b -> b.getName().equals(QueryScheduler.TOTAL))) {\n+          totalAcquired.incrementAndGet();\n+        }\n+        if (bulkheads.stream().anyMatch(b -> !b.getName().equals(QueryScheduler.TOTAL))) {\n+          laneAcquired.incrementAndGet();\n+        }\n+\n+        return bulkheads;\n+      }\n+\n+      @Override\n+      void releaseLanes(List<Bulkhead> bulkheads)\n+      {\n+        super.releaseLanes(bulkheads);\n+        if (bulkheads.stream().anyMatch(b -> b.getName().equals(QueryScheduler.TOTAL))) {\n+          totalReleased.incrementAndGet();\n+        }\n+        if (bulkheads.stream().anyMatch(b -> !b.getName().equals(QueryScheduler.TOTAL))) {\n+          laneReleased.incrementAndGet();\n+          if (bulkheads.size() == 1) {\n+            laneNotAcquired.incrementAndGet();\n+          }\n+        }\n+      }\n+    };\n+  }\n+\n+  @After\n+  public void teardown()\n+  {\n+    executorService.shutdownNow();\n+  }\n+\n+  @Test\n+  public void testHiLoHi() throws ExecutionException, InterruptedException\n+  {\n+    TopNQuery interactive = makeInteractiveQuery();\n+    ListenableFuture<?> future = executorService.submit(() -> {\n+      try {\n+        Query<?> scheduled = scheduler.laneQuery(QueryPlus.wrap(interactive), ImmutableSet.of());\n+\n+        Assert.assertNotNull(scheduled);\n+\n+        Sequence<Integer> underlyingSequence = makeSequence(10);\n+        underlyingSequence = Sequences.wrap(underlyingSequence, new SequenceWrapper()\n+        {\n+          @Override\n+          public void before()\n+          {\n+            Assert.assertEquals(4, scheduler.getTotalAvailableCapacity());\n+            Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(HiLoQueryLaningStrategy.LOW));\n+          }\n+        });\n+        Sequence<Integer> results = scheduler.run(scheduled, underlyingSequence);\n+        int rowCount = consumeAndCloseSequence(results);\n+\n+        Assert.assertEquals(10, rowCount);\n+      }\n+      catch (IOException ex) {\n+        throw new RuntimeException(ex);\n+      }\n+    });\n+    future.get();\n+    Assert.assertEquals(5, scheduler.getTotalAvailableCapacity());\n+  }\n+\n+  @Test\n+  public void testHiLoLo() throws ExecutionException, InterruptedException\n+  {\n+    TopNQuery report = makeReportQuery();\n+    ListenableFuture<?> future = executorService.submit(() -> {\n+      try {\n+        Query<?> scheduledReport = scheduler.laneQuery(QueryPlus.wrap(report), ImmutableSet.of());\n+        Assert.assertNotNull(scheduledReport);\n+        Assert.assertEquals(HiLoQueryLaningStrategy.LOW, QueryContexts.getLane(scheduledReport));\n+\n+        Sequence<Integer> underlyingSequence = makeSequence(10);\n+        underlyingSequence = Sequences.wrap(underlyingSequence, new SequenceWrapper()\n+        {\n+          @Override\n+          public void before()\n+          {\n+            Assert.assertEquals(4, scheduler.getTotalAvailableCapacity());\n+            Assert.assertEquals(1, scheduler.getLaneAvailableCapacity(HiLoQueryLaningStrategy.LOW));\n+          }\n+        });\n+        Sequence<Integer> results = scheduler.run(scheduledReport, underlyingSequence);\n+\n+        int rowCount = consumeAndCloseSequence(results);\n+        Assert.assertEquals(10, rowCount);\n+      }\n+      catch (IOException ex) {\n+        throw new RuntimeException(ex);\n+      }\n+    });\n+    future.get();\n+    Assert.assertEquals(5, scheduler.getTotalAvailableCapacity());\n+    Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(HiLoQueryLaningStrategy.LOW));\n+  }\n+\n+  @Test\n+  public void testHiLoReleaseSemaphoreWhenSequenceExplodes() throws Exception\n+  {\n+    expected.expectMessage(\"exploded\");\n+    expected.expect(ExecutionException.class);\n+    TopNQuery interactive = makeInteractiveQuery();\n+    ListenableFuture<?> future = executorService.submit(() -> {\n+      try {\n+        Query<?> scheduled = scheduler.laneQuery(QueryPlus.wrap(interactive), ImmutableSet.of());\n+\n+        Assert.assertNotNull(scheduled);\n+\n+        Sequence<Integer> underlyingSequence = makeExplodingSequence(10);\n+        underlyingSequence = Sequences.wrap(underlyingSequence, new SequenceWrapper()\n+        {\n+          @Override\n+          public void before()\n+          {\n+            Assert.assertEquals(4, scheduler.getTotalAvailableCapacity());\n+          }\n+        });\n+        Sequence<Integer> results = scheduler.run(scheduled, underlyingSequence);\n+\n+        consumeAndCloseSequence(results);\n+      }\n+      catch (IOException ex) {\n+        throw new RuntimeException(ex);\n+      }\n+    });\n+    future.get();\n+    Assert.assertEquals(5, scheduler.getTotalAvailableCapacity());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NTY1NQ==", "bodyText": "This and the method below are public but they appear to just be used in the unit test.", "url": "https://github.com/apache/druid/pull/9407#discussion_r388665655", "createdAt": "2020-03-06T01:20:30Z", "author": {"login": "ccaominh"}, "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(totalNumThreads));\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  public int getTotalAvailableCapacity()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NjM1OA==", "bodyText": "What's the purpose of the TOTAL bulkhead if each lane has a bulkhead?", "url": "https://github.com/apache/druid/pull/9407#discussion_r388666358", "createdAt": "2020-03-06T01:23:02Z", "author": {"login": "ccaominh"}, "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(totalNumThreads));\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  public int getTotalAvailableCapacity()\n+  {\n+    return laneRegistry.getConfiguration(TOTAL)\n+                       .map(config -> laneRegistry.bulkhead(TOTAL, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support for a given lane\n+   */\n+  public int getLaneAvailableCapacity(String lane)\n+  {\n+    return laneRegistry.getConfiguration(lane)\n+                       .map(config -> laneRegistry.bulkhead(lane, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Acquire a semaphore for both the 'total' and a lane, if any is associated with a query\n+   */\n+  @VisibleForTesting\n+  List<Bulkhead> acquireLanes(Query<?> query)\n+  {\n+    final String lane = QueryContexts.getLane(query);\n+    final Optional<BulkheadConfig> laneConfig = lane == null ? Optional.empty() : laneRegistry.getConfiguration(lane);\n+    List<Bulkhead> hallPasses = new ArrayList<>(2);\n+    final Optional<BulkheadConfig> totalConfig = laneRegistry.getConfiguration(TOTAL);\n+    // if we have a lane, get it first\n+    laneConfig.ifPresent(config -> {\n+      Bulkhead laneLimiter = laneRegistry.bulkhead(lane, config);\n+      if (!laneLimiter.tryAcquirePermission()) {\n+        throw new QueryCapacityExceededException(lane);\n+      }\n+      hallPasses.add(laneLimiter);\n+    });\n+\n+    // everyone needs to take one from the total lane; to ensure we don't acquire a lane and never release it, we want", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NjU4Mg==", "bodyText": "Missing blank line", "url": "https://github.com/apache/druid/pull/9407#discussion_r388666582", "createdAt": "2020-03-06T01:23:44Z", "author": {"login": "ccaominh"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/util/CalciteTests.java", "diffHunk": "@@ -700,6 +701,14 @@ public static SpecificSegmentsQuerySegmentWalker createMockWalker(\n       final QueryRunnerFactoryConglomerate conglomerate,\n       final File tmpDir\n   )\n+  {\n+    return createMockWalker(conglomerate, tmpDir, null);\n+  }\n+  public static SpecificSegmentsQuerySegmentWalker createMockWalker(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NzA4Nw==", "bodyText": "Which tests cover this block?", "url": "https://github.com/apache/druid/pull/9407#discussion_r388667087", "createdAt": "2020-03-06T01:25:28Z", "author": {"login": "ccaominh"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/util/SpecificSegmentsQuerySegmentWalker.java", "diffHunk": "@@ -388,13 +410,33 @@ public SegmentDescriptor getDescriptor()\n           toolChest\n       );\n \n+\n       // Wrap baseRunner in a runner that rewrites the QuerySegmentSpec to mention the specific segments.\n       // This mimics what CachingClusteredClient on the Broker does, and is required for certain queries (like Scan)\n       // to function properly.\n-      return (theQuery, responseContext) -> baseRunner.run(\n-          theQuery.withQuery(Queries.withSpecificSegments(theQuery.getQuery(), ImmutableList.copyOf(specs))),\n-          responseContext\n-      );\n+      return (theQuery, responseContext) -> {\n+        if (scheduler != null) {\n+          Set<SegmentServerSelector> segments = new HashSet<>();\n+          specs.forEach(spec -> segments.add(new SegmentServerSelector(null, spec)));\n+          return scheduler.run(\n+              scheduler.laneQuery(theQuery, segments),\n+              new LazySequence<>(\n+                  () -> baseRunner.run(\n+                      theQuery.withQuery(Queries.withSpecificSegments(\n+                          theQuery.getQuery(),\n+                          ImmutableList.copyOf(specs)\n+                      )),\n+                      responseContext\n+                  )\n+              )\n+          );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba"}, "originalPosition": 109}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "committedDate": "2020-03-06T12:59:58Z", "message": "partial review stuffs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ec8a2657e9f10e84fcd41cf42fef22063fe89ac", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/0ec8a2657e9f10e84fcd41cf42fef22063fe89ac", "committedDate": "2020-03-06T21:04:47Z", "message": "adjust"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MzQwOTM5", "url": "https://github.com/apache/druid/pull/9407#pullrequestreview-369340939", "createdAt": "2020-03-05T07:22:44Z", "commit": {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzo0Nzo1MlrOFzBv2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMDoyMjozNlrOFzGVPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA1MDMyOQ==", "bodyText": "Provide a map?", "url": "https://github.com/apache/druid/pull/9407#discussion_r389050329", "createdAt": "2020-03-06T17:47:52Z", "author": {"login": "jihoonson"}, "path": "server/src/main/java/org/apache/druid/server/QueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.scheduling.HiLoQueryLaningStrategy;\n+import org.apache.druid.server.scheduling.NoQueryLaningStrategy;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+\n+@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"strategy\", defaultImpl = NoQueryLaningStrategy.class)\n+@JsonSubTypes(value = {\n+    @JsonSubTypes.Type(name = \"none\", value = NoQueryLaningStrategy.class),\n+    @JsonSubTypes.Type(name = \"hilo\", value = HiLoQueryLaningStrategy.class)\n+})\n+public interface QueryLaningStrategy\n+{\n+  /**\n+   * Provide map of lane names to the limit on the number of concurrent queries for that lane", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA2NDkwMA==", "bodyText": "Probably the javadoc of this method (or this class) should say that this class is used in QueryScheduler and should be thread-safe.", "url": "https://github.com/apache/druid/pull/9407#discussion_r389064900", "createdAt": "2020-03-06T18:19:33Z", "author": {"login": "jihoonson"}, "path": "server/src/main/java/org/apache/druid/server/QueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.scheduling.HiLoQueryLaningStrategy;\n+import org.apache.druid.server.scheduling.NoQueryLaningStrategy;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+\n+@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"strategy\", defaultImpl = NoQueryLaningStrategy.class)\n+@JsonSubTypes(value = {\n+    @JsonSubTypes.Type(name = \"none\", value = NoQueryLaningStrategy.class),\n+    @JsonSubTypes.Type(name = \"hilo\", value = HiLoQueryLaningStrategy.class)\n+})\n+public interface QueryLaningStrategy\n+{\n+  /**\n+   * Provide map of lane names to the limit on the number of concurrent queries for that lane\n+   * @param totalLimit\n+   */\n+  Object2IntMap<String> getLaneLimits(int totalLimit);\n+\n+  /**\n+   * For a given {@link QueryPlus} and set of {@link SegmentServerSelector}, compute if a query belongs to a lane\n+   */\n+  <T> Optional<String> computeLane(QueryPlus<T> query, Set<SegmentServerSelector> segments);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA2NjE4NA==", "bodyText": "Please add a comment what the key and the value are.", "url": "https://github.com/apache/druid/pull/9407#discussion_r389066184", "createdAt": "2020-03-06T18:22:16Z", "author": {"login": "jihoonson"}, "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+import org.apache.druid.server.initialization.ServerConfig;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final int totalCapacity;\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA3NzgyMg==", "bodyText": "I find this comment confusing. There will be multiple futures of the same ID in historicals most of the time unless the query reads only one segment in a historical. Probably better to comment about what could happen in brokers and historicals.", "url": "https://github.com/apache/druid/pull/9407#discussion_r389077822", "createdAt": "2020-03-06T18:46:07Z", "author": {"login": "jihoonson"}, "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+import org.apache.druid.server.initialization.ServerConfig;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final int totalCapacity;\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy, ServerConfig serverConfig)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    // if totalNumThreads is above 0 and less than druid.server.http.numThreads, enforce total limit\n+    final boolean limitTotal;\n+    if (totalNumThreads > 0 && totalNumThreads < serverConfig.getNumThreads()) {\n+      limitTotal = true;\n+      this.totalCapacity = totalNumThreads;\n+    } else {\n+      limitTotal = false;\n+      this.totalCapacity = serverConfig.getNumThreads();\n+    }\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(limitTotal));\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4ODYwMw==", "bodyText": "Please comment that this class is used in everywhere including historicals and tasks.", "url": "https://github.com/apache/druid/pull/9407#discussion_r389088603", "createdAt": "2020-03-06T19:09:14Z", "author": {"login": "jihoonson"}, "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+import org.apache.druid.server.initialization.ServerConfig;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyMTc1Ng==", "bodyText": "It seems racy that two queries can compete on a particular lane and the total lane separately. I guess it would be a better behavior if it guarantees the first-come, first-served basis.", "url": "https://github.com/apache/druid/pull/9407#discussion_r389121756", "createdAt": "2020-03-06T20:13:54Z", "author": {"login": "jihoonson"}, "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+import org.apache.druid.server.initialization.ServerConfig;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final int totalCapacity;\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy, ServerConfig serverConfig)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    // if totalNumThreads is above 0 and less than druid.server.http.numThreads, enforce total limit\n+    final boolean limitTotal;\n+    if (totalNumThreads > 0 && totalNumThreads < serverConfig.getNumThreads()) {\n+      limitTotal = true;\n+      this.totalCapacity = totalNumThreads;\n+    } else {\n+      limitTotal = false;\n+      this.totalCapacity = serverConfig.getNumThreads();\n+    }\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(limitTotal));\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  @VisibleForTesting\n+  int getTotalAvailableCapacity()\n+  {\n+    return laneRegistry.getConfiguration(TOTAL)\n+                       .map(config -> laneRegistry.bulkhead(TOTAL, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support for a given lane\n+   */\n+  @VisibleForTesting\n+  int getLaneAvailableCapacity(String lane)\n+  {\n+    return laneRegistry.getConfiguration(lane)\n+                       .map(config -> laneRegistry.bulkhead(lane, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Acquire a semaphore for both the 'total' and a lane, if any is associated with a query\n+   */\n+  @VisibleForTesting\n+  List<Bulkhead> acquireLanes(Query<?> query)\n+  {\n+    final String lane = QueryContexts.getLane(query);\n+    final Optional<BulkheadConfig> laneConfig = lane == null ? Optional.empty() : laneRegistry.getConfiguration(lane);\n+    List<Bulkhead> hallPasses = new ArrayList<>(2);\n+    final Optional<BulkheadConfig> totalConfig = laneRegistry.getConfiguration(TOTAL);\n+    // if we have a lane, get it first\n+    laneConfig.ifPresent(config -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyNDg5Nw==", "bodyText": "nit: the javadoc of releasePermission says:\n    /**\n     * Releases a permission and increases the number of available permits by one.\n     * <p>\n     * Should only be used when a permission was acquired but not used. Otherwise use {@link\n     * Bulkhead#onComplete()} to signal a completed call and release a permission.\n     */\n    void releasePermission();\nreleasePermission() and onComplete() of SemaphoreBulkhead are:\n    @Override\n    public void releasePermission() {\n        semaphore.release();\n    }\n\n    @Override\n    public void onComplete() {\n        semaphore.release();\n        publishBulkheadEvent(() -> new BulkheadOnCallFinishedEvent(name));\n    }\nI think it's safe to call releasePermission() for now since we don't use the EventPublisher, but it still wouldn't harm to use onComplete(). It would also probably be better to avoid potential bugs if we want to use EventPublisher in the future.", "url": "https://github.com/apache/druid/pull/9407#discussion_r389124897", "createdAt": "2020-03-06T20:21:23Z", "author": {"login": "jihoonson"}, "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+import org.apache.druid.server.initialization.ServerConfig;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final int totalCapacity;\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy, ServerConfig serverConfig)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    // if totalNumThreads is above 0 and less than druid.server.http.numThreads, enforce total limit\n+    final boolean limitTotal;\n+    if (totalNumThreads > 0 && totalNumThreads < serverConfig.getNumThreads()) {\n+      limitTotal = true;\n+      this.totalCapacity = totalNumThreads;\n+    } else {\n+      limitTotal = false;\n+      this.totalCapacity = serverConfig.getNumThreads();\n+    }\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(limitTotal));\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  @VisibleForTesting\n+  int getTotalAvailableCapacity()\n+  {\n+    return laneRegistry.getConfiguration(TOTAL)\n+                       .map(config -> laneRegistry.bulkhead(TOTAL, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support for a given lane\n+   */\n+  @VisibleForTesting\n+  int getLaneAvailableCapacity(String lane)\n+  {\n+    return laneRegistry.getConfiguration(lane)\n+                       .map(config -> laneRegistry.bulkhead(lane, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Acquire a semaphore for both the 'total' and a lane, if any is associated with a query\n+   */\n+  @VisibleForTesting\n+  List<Bulkhead> acquireLanes(Query<?> query)\n+  {\n+    final String lane = QueryContexts.getLane(query);\n+    final Optional<BulkheadConfig> laneConfig = lane == null ? Optional.empty() : laneRegistry.getConfiguration(lane);\n+    List<Bulkhead> hallPasses = new ArrayList<>(2);\n+    final Optional<BulkheadConfig> totalConfig = laneRegistry.getConfiguration(TOTAL);\n+    // if we have a lane, get it first\n+    laneConfig.ifPresent(config -> {\n+      Bulkhead laneLimiter = laneRegistry.bulkhead(lane, config);\n+      if (!laneLimiter.tryAcquirePermission()) {\n+        throw new QueryCapacityExceededException(lane);\n+      }\n+      hallPasses.add(laneLimiter);\n+    });\n+\n+    // everyone needs to take one from the total lane; to ensure we don't acquire a lane and never release it, we want\n+    // to check for total capacity exceeded and release the lane (if present) before throwing capacity exceeded\n+    totalConfig.ifPresent(config -> {\n+      Bulkhead totalLimiter = laneRegistry.bulkhead(TOTAL, config);\n+      if (!totalLimiter.tryAcquirePermission()) {\n+        releaseLanes(hallPasses);\n+        throw new QueryCapacityExceededException();\n+      }\n+      hallPasses.add(totalLimiter);\n+    });\n+    return hallPasses;\n+  }\n+\n+  /**\n+   * Release all {@link Bulkhead} semaphores in the list\n+   */\n+  @VisibleForTesting\n+  void releaseLanes(List<Bulkhead> bulkheads)\n+  {\n+    bulkheads.forEach(Bulkhead::releasePermission);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyNTQzNg==", "bodyText": "hastotalLimit -> hasTotalLimit", "url": "https://github.com/apache/druid/pull/9407#discussion_r389125436", "createdAt": "2020-03-06T20:22:36Z", "author": {"login": "jihoonson"}, "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+import org.apache.druid.server.initialization.ServerConfig;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final int totalCapacity;\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy, ServerConfig serverConfig)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    // if totalNumThreads is above 0 and less than druid.server.http.numThreads, enforce total limit\n+    final boolean limitTotal;\n+    if (totalNumThreads > 0 && totalNumThreads < serverConfig.getNumThreads()) {\n+      limitTotal = true;\n+      this.totalCapacity = totalNumThreads;\n+    } else {\n+      limitTotal = false;\n+      this.totalCapacity = serverConfig.getNumThreads();\n+    }\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(limitTotal));\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  @VisibleForTesting\n+  int getTotalAvailableCapacity()\n+  {\n+    return laneRegistry.getConfiguration(TOTAL)\n+                       .map(config -> laneRegistry.bulkhead(TOTAL, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support for a given lane\n+   */\n+  @VisibleForTesting\n+  int getLaneAvailableCapacity(String lane)\n+  {\n+    return laneRegistry.getConfiguration(lane)\n+                       .map(config -> laneRegistry.bulkhead(lane, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Acquire a semaphore for both the 'total' and a lane, if any is associated with a query\n+   */\n+  @VisibleForTesting\n+  List<Bulkhead> acquireLanes(Query<?> query)\n+  {\n+    final String lane = QueryContexts.getLane(query);\n+    final Optional<BulkheadConfig> laneConfig = lane == null ? Optional.empty() : laneRegistry.getConfiguration(lane);\n+    List<Bulkhead> hallPasses = new ArrayList<>(2);\n+    final Optional<BulkheadConfig> totalConfig = laneRegistry.getConfiguration(TOTAL);\n+    // if we have a lane, get it first\n+    laneConfig.ifPresent(config -> {\n+      Bulkhead laneLimiter = laneRegistry.bulkhead(lane, config);\n+      if (!laneLimiter.tryAcquirePermission()) {\n+        throw new QueryCapacityExceededException(lane);\n+      }\n+      hallPasses.add(laneLimiter);\n+    });\n+\n+    // everyone needs to take one from the total lane; to ensure we don't acquire a lane and never release it, we want\n+    // to check for total capacity exceeded and release the lane (if present) before throwing capacity exceeded\n+    totalConfig.ifPresent(config -> {\n+      Bulkhead totalLimiter = laneRegistry.bulkhead(TOTAL, config);\n+      if (!totalLimiter.tryAcquirePermission()) {\n+        releaseLanes(hallPasses);\n+        throw new QueryCapacityExceededException();\n+      }\n+      hallPasses.add(totalLimiter);\n+    });\n+    return hallPasses;\n+  }\n+\n+  /**\n+   * Release all {@link Bulkhead} semaphores in the list\n+   */\n+  @VisibleForTesting\n+  void releaseLanes(List<Bulkhead> bulkheads)\n+  {\n+    bulkheads.forEach(Bulkhead::releasePermission);\n+  }\n+\n+  /**\n+   * With a total thread count and {@link QueryLaningStrategy#getLaneLimits}, create a map of lane name to\n+   * {@link BulkheadConfig} to be used to create the {@link #laneRegistry}. This accepts the configured value of\n+   * numThreads rather than using {@link #totalCapacity} so that we only have a total {@link Bulkhead} if\n+   * {@link QuerySchedulerConfig#getNumThreads()} is set\n+   */\n+  private Map<String, BulkheadConfig> getLaneConfigs(boolean hastotalLimit)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd"}, "originalPosition": 224}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNjQ2OTcw", "url": "https://github.com/apache/druid/pull/9407#pullrequestreview-370646970", "createdAt": "2020-03-06T21:47:35Z", "commit": {"oid": "0ec8a2657e9f10e84fcd41cf42fef22063fe89ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMTo0NzozNVrOFzIdww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMTo0NzozNVrOFzIdww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MDM4Nw==", "bodyText": "Does it make sense to add maxCapacity as well?", "url": "https://github.com/apache/druid/pull/9407#discussion_r389160387", "createdAt": "2020-03-06T21:47:35Z", "author": {"login": "jihoonson"}, "path": "server/src/main/java/org/apache/druid/server/scheduling/HiLoQueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import com.google.common.primitives.Ints;\n+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.QueryLaningStrategy;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Query laning strategy which associates all {@link Query} with priority lower than 0 into a 'low' lane\n+ */\n+public class HiLoQueryLaningStrategy implements QueryLaningStrategy\n+{\n+  public static final String LOW = \"low\";\n+\n+  @JsonProperty\n+  private final int maxLowPercent;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ec8a2657e9f10e84fcd41cf42fef22063fe89ac"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNjY2ODQ2", "url": "https://github.com/apache/druid/pull/9407#pullrequestreview-370666846", "createdAt": "2020-03-06T22:32:59Z", "commit": {"oid": "0ec8a2657e9f10e84fcd41cf42fef22063fe89ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMjozMjo1OVrOFzJboQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMjozMjo1OVrOFzJboQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3NjIyNQ==", "bodyText": "Maybe worth to say what configuration is related to this error. See https://github.com/apache/druid/blob/master/processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/Groupers.java#L39 as an example.", "url": "https://github.com/apache/druid/pull/9407#discussion_r389176225", "createdAt": "2020-03-06T22:32:59Z", "author": {"login": "jihoonson"}, "path": "server/src/main/java/org/apache/druid/server/QueryCapacityExceededException.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.QueryException;\n+\n+public class QueryCapacityExceededException extends QueryException\n+{\n+  private static final String ERROR_CLASS = QueryCapacityExceededException.class.getName();\n+  public static final String ERROR_CODE = \"Query capacity exceeded\";\n+  public static final String ERROR_MESSAGE = \"Total query capacity exceeded\";\n+  public static final String ERROR_MESSAGE_TEMPLATE = \"Query capacity exceeded for lane %s\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ec8a2657e9f10e84fcd41cf42fef22063fe89ac"}, "originalPosition": 32}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5711fce706bbd23a5f7b559ff91e4288ea8ad96d", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/5711fce706bbd23a5f7b559ff91e4288ea8ad96d", "committedDate": "2020-03-07T01:14:28Z", "message": "review stuffs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa73a14a056e61f14a0927e8a029da999f95fc1c", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/aa73a14a056e61f14a0927e8a029da999f95fc1c", "committedDate": "2020-03-07T01:22:25Z", "message": "more javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50847af1a17bb2fa2a8bff12ee32e4476fe67a86", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/50847af1a17bb2fa2a8bff12ee32e4476fe67a86", "committedDate": "2020-03-07T02:20:05Z", "message": "error response documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abe3631be329e40c5a3fbdbd904f4867a00ec6ee", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/abe3631be329e40c5a3fbdbd904f4867a00ec6ee", "committedDate": "2020-03-07T03:00:40Z", "message": "spelling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86501ef4bbe2f1d2b425b75e697b55e32571b2b1", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/86501ef4bbe2f1d2b425b75e697b55e32571b2b1", "committedDate": "2020-03-07T03:12:01Z", "message": "preserve user specified lane for NoSchedulingStrategy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b7b70d16c6da7347d12718f4db3720114c17fec", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/8b7b70d16c6da7347d12718f4db3720114c17fec", "committedDate": "2020-03-07T03:14:09Z", "message": "more test, why not"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91ad9d97fc3d416801204bd3d19f10205d3b6283", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/91ad9d97fc3d416801204bd3d19f10205d3b6283", "committedDate": "2020-03-07T03:17:21Z", "message": "doc adjustment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "373fd1158f13c9f7a77ac6ba1748aa2b2cbb8b99", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/373fd1158f13c9f7a77ac6ba1748aa2b2cbb8b99", "committedDate": "2020-03-07T05:08:54Z", "message": "style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "274150174fabd07646fe87a01dea67dc714172c7", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/274150174fabd07646fe87a01dea67dc714172c7", "committedDate": "2020-03-09T17:12:17Z", "message": "missed review for make a thing a constant"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNTEyMjky", "url": "https://github.com/apache/druid/pull/9407#pullrequestreview-371512292", "createdAt": "2020-03-09T20:39:18Z", "commit": {"oid": "274150174fabd07646fe87a01dea67dc714172c7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNTIyMDkx", "url": "https://github.com/apache/druid/pull/9407#pullrequestreview-371522091", "createdAt": "2020-03-09T20:55:02Z", "commit": {"oid": "274150174fabd07646fe87a01dea67dc714172c7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMDo1NTowMlrOFz5BzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMDo1NTowMlrOFz5BzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1NjA0NQ==", "bodyText": "Behavior here is a bit different from the docs, which say the value is rounded up.\nSince this allows a lane limit of zero or the total limit, it is a bit inconsistent with disallowing maxLowPercent from being 0 or 100 percent.", "url": "https://github.com/apache/druid/pull/9407#discussion_r389956045", "createdAt": "2020-03-09T20:55:02Z", "author": {"login": "ccaominh"}, "path": "server/src/main/java/org/apache/druid/server/scheduling/HiLoQueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import com.google.common.primitives.Ints;\n+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.QueryLaningStrategy;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Query laning strategy which associates all {@link Query} with priority lower than 0 into a 'low' lane\n+ */\n+public class HiLoQueryLaningStrategy implements QueryLaningStrategy\n+{\n+  public static final String LOW = \"low\";\n+\n+  @JsonProperty\n+  private final int maxLowPercent;\n+\n+  @JsonCreator\n+  public HiLoQueryLaningStrategy(\n+      @JsonProperty(\"maxLowPercent\") Integer maxLowPercent\n+  )\n+  {\n+    this.maxLowPercent = Preconditions.checkNotNull(maxLowPercent, \"maxLowPercent must be set\");\n+    Preconditions.checkArgument(\n+        0 < maxLowPercent && maxLowPercent < 100,\n+        \"maxLowPercent must be between 0 and 100\"\n+    );\n+  }\n+\n+  @Override\n+  public Object2IntMap<String> getLaneLimits(int totalLimit)\n+  {\n+    Object2IntMap<String> onlyLow = new Object2IntArrayMap<>(1);\n+    onlyLow.put(LOW, Ints.checkedCast(Math.round(totalLimit * ((double) maxLowPercent / 100))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "274150174fabd07646fe87a01dea67dc714172c7"}, "originalPosition": 63}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8575cf8dc1a3e4fbedb46b1f7d36985e984b991c", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/8575cf8dc1a3e4fbedb46b1f7d36985e984b991c", "committedDate": "2020-03-09T21:14:59Z", "message": "fixes and tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNTQ2NjUx", "url": "https://github.com/apache/druid/pull/9407#pullrequestreview-371546651", "createdAt": "2020-03-09T21:37:17Z", "commit": {"oid": "8575cf8dc1a3e4fbedb46b1f7d36985e984b991c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNTYxMjI0", "url": "https://github.com/apache/druid/pull/9407#pullrequestreview-371561224", "createdAt": "2020-03-09T22:06:06Z", "commit": {"oid": "8575cf8dc1a3e4fbedb46b1f7d36985e984b991c"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMjowNjowN1rOFz6_Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMjowODoxOFrOFz7CXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4ODE5NA==", "bodyText": "Not bad as is, but if i were to try to boil it down just a little, it might be something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The Broker provides facilities to aid in query capacity reservation for heterogeneous query workloads in the form of 'laning' strategies, which provide a variety of mechanisms to examine and classify a query, assigning it to a 'lane'. Lanes are defined with capacity limits which the broker will enforce, causing requests in excess of the capacity to be discarded with an HTTP 429 status code, reserving resources for other lanes or for interactive queries (with no lane).\n          \n          \n            \n            *Laning strategies* allow you to control capacity utilization for heterogeneous query workloads. With laning, the broker examines and classifies a query for the purpose of assigning it to a 'lane'. Lanes have capacity limits, enforced by the broker, that ensure sufficient resources are available for other lanes or for interactive queries (with no lane). Requests in excess of the capacity are discarded with an HTTP 429 status code.", "url": "https://github.com/apache/druid/pull/9407#discussion_r389988194", "createdAt": "2020-03-09T22:06:07Z", "author": {"login": "sthetland"}, "path": "docs/configuration/index.md", "diffHunk": "@@ -1476,9 +1476,35 @@ These Broker configurations can be defined in the `broker/runtime.properties` fi\n |`druid.broker.select.tier`|`highestPriority`, `lowestPriority`, `custom`|If segments are cross-replicated across tiers in a cluster, you can tell the broker to prefer to select segments in a tier with a certain priority.|`highestPriority`|\n |`druid.broker.select.tier.custom.priorities`|`An array of integer priorities.`|Select servers in tiers with a custom priority list.|None|\n \n+##### Query laning\n+\n+The Broker provides facilities to aid in query capacity reservation for heterogeneous query workloads in the form of 'laning' strategies, which provide a variety of mechanisms to examine and classify a query, assigning it to a 'lane'. Lanes are defined with capacity limits which the broker will enforce, causing requests in excess of the capacity to be discarded with an HTTP 429 status code, reserving resources for other lanes or for interactive queries (with no lane).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8575cf8dc1a3e4fbedb46b1f7d36985e984b991c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4ODk1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In this mode, queries are never assigned lane, and concurrent query count will only limited by `druid.server.http.numThreads` or `druid.query.scheduler.numThreads`, if set. This is the default Druid query scheduler operating mode. This strategy can also be explicitly enabled by setting `druid.query.scheduler.laning.strategy` to `none`.\n          \n          \n            \n            In this mode, queries are never assigned a lane, and the concurrent query count will only be limited by `druid.server.http.numThreads` or `druid.query.scheduler.numThreads`, if set. This is the default Druid query scheduler operating mode. Enable this strategy explicitly by setting `druid.query.scheduler.laning.strategy` to `none`.", "url": "https://github.com/apache/druid/pull/9407#discussion_r389988957", "createdAt": "2020-03-09T22:08:18Z", "author": {"login": "sthetland"}, "path": "docs/configuration/index.md", "diffHunk": "@@ -1476,9 +1476,35 @@ These Broker configurations can be defined in the `broker/runtime.properties` fi\n |`druid.broker.select.tier`|`highestPriority`, `lowestPriority`, `custom`|If segments are cross-replicated across tiers in a cluster, you can tell the broker to prefer to select segments in a tier with a certain priority.|`highestPriority`|\n |`druid.broker.select.tier.custom.priorities`|`An array of integer priorities.`|Select servers in tiers with a custom priority list.|None|\n \n+##### Query laning\n+\n+The Broker provides facilities to aid in query capacity reservation for heterogeneous query workloads in the form of 'laning' strategies, which provide a variety of mechanisms to examine and classify a query, assigning it to a 'lane'. Lanes are defined with capacity limits which the broker will enforce, causing requests in excess of the capacity to be discarded with an HTTP 429 status code, reserving resources for other lanes or for interactive queries (with no lane).\n+\n+|Property|Description|Default|\n+|--------|-----------|-------|\n+|`druid.query.scheduler.numThreads`|Maximum number of HTTP threads to dedicate to query processing. To save HTTP thread capacity, this should be lower than `druid.server.http.numThreads`.|Unbounded|\n+|`druid.query.scheduler.laning.strategy`|Query laning strategy to use to assign queries to a lane in order to control capacities for certain classes of queries.|`none`|\n+\n+##### Laning strategies\n+\n+###### No laning strategy\n+\n+In this mode, queries are never assigned lane, and concurrent query count will only limited by `druid.server.http.numThreads` or `druid.query.scheduler.numThreads`, if set. This is the default Druid query scheduler operating mode. This strategy can also be explicitly enabled by setting `druid.query.scheduler.laning.strategy` to `none`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8575cf8dc1a3e4fbedb46b1f7d36985e984b991c"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25a8bda9fa2dd456b23598390c94c1a39e1a70a3", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/25a8bda9fa2dd456b23598390c94c1a39e1a70a3", "committedDate": "2020-03-10T00:37:20Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32965a4fa92d60c46f4296a5f387b9b29484712b", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/32965a4fa92d60c46f4296a5f387b9b29484712b", "committedDate": "2020-03-10T00:43:25Z", "message": "Update docs/configuration/index.md\n\nCo-Authored-By: sthetland <steve.hetland@imply.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "361e06e80186835be87e69b0001ddc84d5838e16", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/361e06e80186835be87e69b0001ddc84d5838e16", "committedDate": "2020-03-10T00:44:16Z", "message": "Merge remote-tracking branch 'upstream/master' into query-laning-and-load-shedding"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ba7808e32bdeeef603fa3e4b6665bd927ce9bb8", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/3ba7808e32bdeeef603fa3e4b6665bd927ce9bb8", "committedDate": "2020-03-10T00:46:04Z", "message": "doc update"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNjg0OTIx", "url": "https://github.com/apache/druid/pull/9407#pullrequestreview-371684921", "createdAt": "2020-03-10T05:10:42Z", "commit": {"oid": "3ba7808e32bdeeef603fa3e4b6665bd927ce9bb8"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwNToxMDo0MlrOF0BsWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwNzoyOTo1MVrOF0Dx6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA5ODAxMQ==", "bodyText": "why is this  Integer and not int considering it has a default non-null value?", "url": "https://github.com/apache/druid/pull/9407#discussion_r390098011", "createdAt": "2020-03-10T05:10:42Z", "author": {"login": "himanshug"}, "path": "server/src/main/java/org/apache/druid/server/QuerySchedulerConfig.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import org.apache.druid.server.scheduling.NoQueryLaningStrategy;\n+\n+public class QuerySchedulerConfig\n+{\n+  @JsonProperty\n+  private Integer numThreads = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba7808e32bdeeef603fa3e4b6665bd927ce9bb8"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEyNDA0NQ==", "bodyText": "in what use case would I ever want to set it something other  than druid.server.http.numThreads ? If the recommendation is to set it lower than druid.server.http.numThreads then why the default value is not set to druid.server.http.numThreads - 1 ?\nI guess, as a user I don't quite understand the importance of setting this higher/same/lower compared to druid.server.http.numThreads and when I should choose one vs the other.", "url": "https://github.com/apache/druid/pull/9407#discussion_r390124045", "createdAt": "2020-03-10T07:01:40Z", "author": {"login": "himanshug"}, "path": "docs/configuration/index.md", "diffHunk": "@@ -1481,9 +1481,35 @@ These Broker configurations can be defined in the `broker/runtime.properties` fi\n |`druid.broker.select.tier`|`highestPriority`, `lowestPriority`, `custom`|If segments are cross-replicated across tiers in a cluster, you can tell the broker to prefer to select segments in a tier with a certain priority.|`highestPriority`|\n |`druid.broker.select.tier.custom.priorities`|`An array of integer priorities.`|Select servers in tiers with a custom priority list.|None|\n \n+##### Query laning\n+\n+*Laning strategies* allow you to control capacity utilization for heterogeneous query workloads. With laning, the broker examines and classifies a query for the purpose of assigning it to a 'lane'. Lanes have capacity limits, enforced by the broker, that can be used to ensure sufficient resources are available for other lanes or for interactive queries (with no lane), or to limit overall throughput for queries within the lane. Requests in excess of the capacity are discarded with an HTTP 429 status code.\n+\n+|Property|Description|Default|\n+|--------|-----------|-------|\n+|`druid.query.scheduler.numThreads`|Maximum number of HTTP threads to dedicate to query processing. To save HTTP thread capacity, this should be lower than `druid.server.http.numThreads`.|Unbounded|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba7808e32bdeeef603fa3e4b6665bd927ce9bb8"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEzMjIwMQ==", "bodyText": "is it expected that sum(returned_map.values) < totalLimit ?\nnit:  Also wonder why limits returned here  were not percentages but absolute counts given that each implementation would probably end up doing that calculation.", "url": "https://github.com/apache/druid/pull/9407#discussion_r390132201", "createdAt": "2020-03-10T07:29:51Z", "author": {"login": "himanshug"}, "path": "server/src/main/java/org/apache/druid/server/QueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.scheduling.HiLoQueryLaningStrategy;\n+import org.apache.druid.server.scheduling.NoQueryLaningStrategy;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+\n+@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"strategy\", defaultImpl = NoQueryLaningStrategy.class)\n+@JsonSubTypes(value = {\n+    @JsonSubTypes.Type(name = \"none\", value = NoQueryLaningStrategy.class),\n+    @JsonSubTypes.Type(name = \"hilo\", value = HiLoQueryLaningStrategy.class)\n+})\n+public interface QueryLaningStrategy\n+{\n+  /**\n+   * Provide a map of lane names to the limit on the number of concurrent queries for that lane\n+   * @param totalLimit\n+   */\n+  Object2IntMap<String> getLaneLimits(int totalLimit);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba7808e32bdeeef603fa3e4b6665bd927ce9bb8"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2952, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}