{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg0Nzc4ODEx", "number": 10383, "title": "Fix ingestion failure of pretty-formatted JSON message", "bodyText": "This PR fixes #10259 .\nDescription\nThe cause and solution has been discussed completely in the issue.\nIn this PR,\n\na new JsonReader is provided to read json text for streaming ingestion\noriginal JsonReader is renamed to JsonLineReader for batch ingestion\n\n\n\n\n\n\nThis PR has:\n\n been self-reviewed.\n using the concurrency checklist (Remove this item if the PR doesn't have any relation to concurrency.)\n added documentation for new or modified features or behaviors.\n added Javadocs for most classes and all non-trivial methods. Linked related entities via Javadoc links.\n added or updated version, license, or notice information in licenses.yaml\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.\n added unit tests or modified existing tests to cover new code paths, ensuring the threshold for code coverage is met.\n added integration tests.\n been tested in a test Druid cluster.", "createdAt": "2020-09-11T08:02:35Z", "url": "https://github.com/apache/druid/pull/10383", "merged": true, "mergeCommit": {"oid": "e83d5cb59e07d605f6198dfade87d2d71eb31c01"}, "closed": true, "closedAt": "2020-11-13T21:59:24Z", "author": {"login": "FrankChen021"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdIDP64AFqTQ4NzIwNTcyOA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdbToglAH2gAyNDg0Nzc4ODExOmZiZTY4M2EyNDM4NWQ5YzY0YTgzZjJmMWU4ZWE2YzgxYWQ3N2EzZjQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MjA1NzI4", "url": "https://github.com/apache/druid/pull/10383#pullrequestreview-487205728", "createdAt": "2020-09-12T05:35:43Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwNTozNTo0NFrOHQyzPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwNTozNTo0NFrOHQyzPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM3MTU4Mw==", "bodyText": "I haven't looked through the PR yet, but found that the parser created from JsonFactory is Closeable which should be closed when the below CloseableIterator is closed. I will review again when you update the PR.", "url": "https://github.com/apache/druid/pull/10383#discussion_r487371583", "createdAt": "2020-09-12T05:35:44Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/data/input/impl/JsonReader.java", "diffHunk": "@@ -49,41 +55,99 @@\n       boolean keepNullColumns\n   )\n   {\n-    super(inputRowSchema, source);\n+    this.inputRowSchema = inputRowSchema;\n+    this.source = source;\n     this.flattener = ObjectFlatteners.create(flattenSpec, new JSONFlattenerMaker(keepNullColumns));\n     this.mapper = mapper;\n   }\n \n-  @Override\n-  public List<InputRow> parseInputRows(String line) throws IOException, ParseException\n-  {\n-    final JsonNode document = mapper.readValue(line, JsonNode.class);\n-    final Map<String, Object> flattened = flattener.flatten(document);\n-    return Collections.singletonList(MapInputRowParser.parse(getInputRowSchema(), flattened));\n-  }\n \n   @Override\n-  public Map<String, Object> toMap(String intermediateRow) throws IOException\n+  public CloseableIterator<InputRow> read() throws IOException\n   {\n-    //noinspection unchecked\n-    return mapper.readValue(intermediateRow, Map.class);\n+    final MappingIterator<JsonNode> delegate = mapper.readValues(\n+        new JsonFactory().createParser(this.source.open()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 62}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyMTYyNjcw", "url": "https://github.com/apache/druid/pull/10383#pullrequestreview-492162670", "createdAt": "2020-09-20T00:03:22Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQwMDowMzoyMlrOHU2GQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwMTo0MDo0MlrOHXyDrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTYxOTkwNA==", "bodyText": "Hmm, SpotBugs thinks this is not good since it cannot throw NoSuchElementException which is wrong since next() never can be called more than once. But, let's make it happy by simply adding if (!haxNext()) throws NoSuchElementException` here.", "url": "https://github.com/apache/druid/pull/10383#discussion_r491619904", "createdAt": "2020-09-20T00:03:22Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/data/input/ExceptionThrowingIterator.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.data.input;\n+\n+import org.apache.druid.java.util.common.parsers.CloseableIterator;\n+\n+public class ExceptionThrowingIterator<T> implements CloseableIterator<T>\n+{\n+  private final RuntimeException exception;\n+\n+  private boolean thrown = false;\n+\n+  public ExceptionThrowingIterator(Throwable exception)\n+  {\n+    this.exception = exception instanceof RuntimeException\n+                     ? (RuntimeException) exception\n+                     : new RuntimeException(exception);\n+  }\n+\n+  @Override\n+  public boolean hasNext()\n+  {\n+    return !thrown;\n+  }\n+\n+  @Override\n+  public T next()\n+  {\n+    thrown = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTYyMDM3OQ==", "bodyText": "As this class is extracted now, please add some Javaodc describing what this class does and where it is used.", "url": "https://github.com/apache/druid/pull/10383#discussion_r491620379", "createdAt": "2020-09-20T00:04:20Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/data/input/ExceptionThrowingIterator.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.data.input;\n+\n+import org.apache.druid.java.util.common.parsers.CloseableIterator;\n+\n+public class ExceptionThrowingIterator<T> implements CloseableIterator<T>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTYyMDk4OA==", "bodyText": "typo: splitted -> split.", "url": "https://github.com/apache/druid/pull/10383#discussion_r491620988", "createdAt": "2020-09-20T00:05:33Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/data/input/impl/JsonInputFormat.java", "diffHunk": "@@ -41,6 +42,20 @@\n   private final ObjectMapper objectMapper;\n   private final boolean keepNullColumns;\n \n+  /**\n+   * <pre>\n+   * This parameter is introduced to support json string of an object in multiple lines in streaming ingestion records\n+   *\n+   * It indicates whether the input text can be splitted into lines in first, which will then be parsed into JSON objects one by one independently.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTYyMjg1NQ==", "bodyText": "The pre tag is a tag for pre-formatted text such as source codes. I think you don't have to use it in this case.", "url": "https://github.com/apache/druid/pull/10383#discussion_r491622855", "createdAt": "2020-09-20T00:09:25Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/data/input/impl/JsonInputFormat.java", "diffHunk": "@@ -41,6 +42,20 @@\n   private final ObjectMapper objectMapper;\n   private final boolean keepNullColumns;\n \n+  /**\n+   * <pre>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY1MDEzMA==", "bodyText": "Same comment here. You don't need a pre tag.", "url": "https://github.com/apache/druid/pull/10383#discussion_r491650130", "createdAt": "2020-09-20T04:17:40Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/data/input/impl/JsonReader.java", "diffHunk": "@@ -33,13 +40,98 @@\n \n import java.io.IOException;\n import java.util.Collections;\n-import java.util.List;\n+import java.util.Iterator;\n import java.util.Map;\n+import java.util.NoSuchElementException;\n \n-public class JsonReader extends TextReader\n+/**\n+ * <pre>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY1MTEwNg==", "bodyText": "Please verify that e is the exception what we expect.", "url": "https://github.com/apache/druid/pull/10383#discussion_r491651106", "createdAt": "2020-09-20T04:32:34Z", "author": {"login": "jihoonson"}, "path": "core/src/test/java/org/apache/druid/data/input/impl/JsonReaderTest.java", "diffHunk": "@@ -126,138 +149,158 @@ public void testParseRowWithConditional() throws IOException\n     try (CloseableIterator<InputRow> iterator = reader.read()) {\n       int numActualIterations = 0;\n       while (iterator.hasNext()) {\n+\n         final InputRow row = iterator.next();\n-        Assert.assertEquals(\"test\", Iterables.getOnlyElement(row.getDimension(\"bar\")));\n-        Assert.assertEquals(Collections.emptyList(), row.getDimension(\"foo\"));\n-        Assert.assertTrue(row.getDimension(\"baz\").isEmpty());\n-        numActualIterations++;\n-      }\n-      Assert.assertEquals(numExpectedIterations, numActualIterations);\n-    }\n-  }\n \n-  @Test\n-  public void testParseRowKeepNullColumns() throws IOException\n-  {\n-    final JsonInputFormat format = new JsonInputFormat(\n-        new JSONPathSpec(\n-            true,\n-            ImmutableList.of(\n-                new JSONPathFieldSpec(JSONPathFieldType.PATH, \"path_omg\", \"$.o.mg\")\n-            )\n-        ),\n-        null,\n-        true\n-    );\n+        Assert.assertEquals(DateTimes.of(\"2019-01-01\"), row.getTimestamp());\n+        Assert.assertEquals(\"x\", Iterables.getOnlyElement(row.getDimension(\"foo\")));\n+        Assert.assertEquals(\"4\", Iterables.getOnlyElement(row.getDimension(\"baz\")));\n+        Assert.assertEquals(\"4\", Iterables.getOnlyElement(row.getDimension(\"root_baz\")));\n+        Assert.assertEquals(\"1\", Iterables.getOnlyElement(row.getDimension(\"path_omg\")));\n+        Assert.assertEquals(\"1\", Iterables.getOnlyElement(row.getDimension(\"jq_omg\")));\n \n-    final ByteEntity source = new ByteEntity(\n-        StringUtils.toUtf8(\"{\\\"timestamp\\\":\\\"2019-01-01\\\",\\\"bar\\\":null,\\\"foo\\\":\\\"x\\\",\\\"o\\\":{\\\"mg\\\":null}}\")\n-    );\n+        Assert.assertTrue(row.getDimension(\"root_baz2\").isEmpty());\n+        Assert.assertTrue(row.getDimension(\"path_omg2\").isEmpty());\n+        Assert.assertTrue(row.getDimension(\"jq_omg2\").isEmpty());\n \n-    final InputEntityReader reader = format.createReader(\n-        new InputRowSchema(\n-            new TimestampSpec(\"timestamp\", \"iso\", null),\n-            new DimensionsSpec(DimensionsSpec.getDefaultSchemas(Collections.emptyList())),\n-            Collections.emptyList()\n-        ),\n-        source,\n-        null\n-    );\n-    final int numExpectedIterations = 1;\n-    try (CloseableIterator<InputRow> iterator = reader.read()) {\n-      int numActualIterations = 0;\n-      while (iterator.hasNext()) {\n-        final InputRow row = iterator.next();\n-        Assert.assertEquals(Arrays.asList(\"path_omg\", \"timestamp\", \"bar\", \"foo\"), row.getDimensions());\n-        Assert.assertTrue(row.getDimension(\"bar\").isEmpty());\n-        Assert.assertEquals(\"x\", Iterables.getOnlyElement(row.getDimension(\"foo\")));\n-        Assert.assertTrue(row.getDimension(\"path_omg\").isEmpty());\n         numActualIterations++;\n       }\n+\n       Assert.assertEquals(numExpectedIterations, numActualIterations);\n     }\n   }\n \n   @Test\n-  public void testKeepNullColumnsWithNoNullValues() throws IOException\n+  public void testInvalidJSONText() throws IOException\n   {\n     final JsonInputFormat format = new JsonInputFormat(\n         new JSONPathSpec(\n             true,\n             ImmutableList.of(\n-                new JSONPathFieldSpec(JSONPathFieldType.PATH, \"path_omg\", \"$.o.mg\")\n+                new JSONPathFieldSpec(JSONPathFieldType.ROOT, \"root_baz\", \"baz\"),\n+                new JSONPathFieldSpec(JSONPathFieldType.ROOT, \"root_baz2\", \"baz2\"),\n+                new JSONPathFieldSpec(JSONPathFieldType.PATH, \"path_omg\", \"$.o.mg\"),\n+                new JSONPathFieldSpec(JSONPathFieldType.PATH, \"path_omg2\", \"$.o.mg2\"),\n+                new JSONPathFieldSpec(JSONPathFieldType.JQ, \"jq_omg\", \".o.mg\"),\n+                new JSONPathFieldSpec(JSONPathFieldType.JQ, \"jq_omg2\", \".o.mg2\")\n             )\n         ),\n         null,\n-        true\n+        null\n     );\n \n+    //make sure JsonReader is used\n+    format.setLineSplittable(false);\n+\n     final ByteEntity source = new ByteEntity(\n-        StringUtils.toUtf8(\"{\\\"timestamp\\\":\\\"2019-01-01\\\",\\\"bar\\\":1,\\\"foo\\\":\\\"x\\\",\\\"o\\\":{\\\"mg\\\":\\\"a\\\"}}\")\n+        StringUtils.toUtf8(\"{\\\"timestamp\\\":\\\"2019-01-01\\\",\\\"bar\\\":null,\\\"foo\\\":\\\"x\\\",\\\"baz\\\":4,\\\"o\\\":{\\\"mg\\\":1}}\"\n+                           + \"{\\\"timestamp\\\":\\\"2019-01-01\\\",\\\"bar\\\":null,\\\"foo\\\":\\\"x\\\",\\\"baz\\\":4xxx,\\\"o\\\":{\\\"mg\\\":2}}\" //baz property is illegal\n+                           + \"{\\\"timestamp\\\":\\\"2019-01-01\\\",\\\"bar\\\":null,\\\"foo\\\":\\\"x\\\",\\\"baz\\\":4,\\\"o\\\":{\\\"mg\\\":3}}\")\n     );\n \n     final InputEntityReader reader = format.createReader(\n         new InputRowSchema(\n             new TimestampSpec(\"timestamp\", \"iso\", null),\n-            new DimensionsSpec(DimensionsSpec.getDefaultSchemas(Collections.emptyList())),\n+            new DimensionsSpec(DimensionsSpec.getDefaultSchemas(ImmutableList.of(\"bar\", \"foo\"))),\n             Collections.emptyList()\n         ),\n         source,\n         null\n     );\n+\n+    // the 2nd line is ill-formed, it stops to iterate to the 3rd line.\n+    // So in total, only 1 lines has been parsed\n     final int numExpectedIterations = 1;\n+\n     try (CloseableIterator<InputRow> iterator = reader.read()) {\n       int numActualIterations = 0;\n       while (iterator.hasNext()) {\n-        final InputRow row = iterator.next();\n-        Assert.assertEquals(Arrays.asList(\"path_omg\", \"timestamp\", \"bar\", \"foo\"), row.getDimensions());\n-        Assert.assertEquals(\"1\", Iterables.getOnlyElement(row.getDimension(\"bar\")));\n-        Assert.assertEquals(\"x\", Iterables.getOnlyElement(row.getDimension(\"foo\")));\n-        Assert.assertEquals(\"a\", Iterables.getOnlyElement(row.getDimension(\"path_omg\")));\n-        numActualIterations++;\n+\n+        try {\n+          final InputRow row = iterator.next();\n+\n+          final String msgId = String.valueOf(++numActualIterations);\n+          Assert.assertEquals(DateTimes.of(\"2019-01-01\"), row.getTimestamp());\n+          Assert.assertEquals(\"x\", Iterables.getOnlyElement(row.getDimension(\"foo\")));\n+          Assert.assertEquals(\"4\", Iterables.getOnlyElement(row.getDimension(\"baz\")));\n+          Assert.assertEquals(\"4\", Iterables.getOnlyElement(row.getDimension(\"root_baz\")));\n+          Assert.assertEquals(msgId, Iterables.getOnlyElement(row.getDimension(\"path_omg\")));\n+          Assert.assertEquals(msgId, Iterables.getOnlyElement(row.getDimension(\"jq_omg\")));\n+\n+          Assert.assertTrue(row.getDimension(\"root_baz2\").isEmpty());\n+          Assert.assertTrue(row.getDimension(\"path_omg2\").isEmpty());\n+          Assert.assertTrue(row.getDimension(\"jq_omg2\").isEmpty());\n+        }\n+        catch (Exception e) {\n+          //ignore the exception when parsing the 2nd", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY1NTMxNw==", "bodyText": "Hmm, I think the Javadoc should be more clear on what this flag means. How about rephrase it as below?\nThis parameter indicates whether or not the given InputEntity should be split by lines before parsing it. If it is set to true, the InputEntity must be split by lines first. If it is set to false, unlike what you could imagine, it means that the InputEntity doesn't have to be split by lines first, but it can still contain multiple lines. A created InputEntityReader from this format will determine by itself if line splitting is necessary.\n\nThis parameter should always be true for batch ingestion and false for streaming ingestion. For more information, see: https://github.com/apache/druid/pull/10383.", "url": "https://github.com/apache/druid/pull/10383#discussion_r491655317", "createdAt": "2020-09-20T05:37:30Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/data/input/impl/JsonInputFormat.java", "diffHunk": "@@ -41,6 +42,20 @@\n   private final ObjectMapper objectMapper;\n   private final boolean keepNullColumns;\n \n+  /**\n+   * <pre>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTYyMjg1NQ=="}, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5NjM3Mg==", "bodyText": "Thinking about this new reader, I think the new requirement for parsing multiple JSON objects to multiple rows doesn't fit in the current interface of the sampler. The sampler currently assumes that there is only one JSON object in an input chunk which could have either an array or a nested object. That means, the current interface allows multiple out rows as inputRows is a list of InputRows in InputRowListPlusRawValues, but doesn't allow multiple values in an input chunk as rawValues is a map in InputRowListPlusRawValues. To support the requirement, I think rawValues should be a list of map, so that all raw values in an input chunk can be returned to the sampler.\nIf we do this, JsonReader can simply extend IntermediateRowParsingReader, where the intermediate row will be the inputText created from source.open(). Here is an example.\npublic class JsonReader2 extends IntermediateRowParsingReader<String>\n{\n  private final ObjectFlattener<JsonNode> flattener;\n  private final ObjectMapper mapper;\n  private final InputEntity source;\n  private final InputRowSchema inputRowSchema;\n\n  JsonReader2(\n      InputRowSchema inputRowSchema,\n      InputEntity source,\n      JSONPathSpec flattenSpec,\n      ObjectMapper mapper,\n      boolean keepNullColumns\n  )\n  {\n    this.inputRowSchema = inputRowSchema;\n    this.source = source;\n    this.flattener = ObjectFlatteners.create(flattenSpec, new JSONFlattenerMaker(keepNullColumns));\n    this.mapper = mapper;\n  }\n\n  @Override\n  protected CloseableIterator<String> intermediateRowIterator() throws IOException\n  {\n    return CloseableIterators.withEmptyBaggage(\n        Iterators.singletonIterator(IOUtils.toString(source.open(), StringUtils.UTF8_STRING))\n    );\n  }\n\n  @Override\n  protected List<InputRow> parseInputRows(String intermediateRow) throws IOException, ParseException\n  {\n    try (JsonParser parser = new JsonFactory().createParser(intermediateRow)) {\n      final Iterator<JsonNode> delegate = mapper.readValues(parser, JsonNode.class);\n      return FluentIterable.from(() -> delegate)\n                           .transform(jsonNode -> MapInputRowParser.parse(inputRowSchema, flattener.flatten(jsonNode)))\n                           .toList();\n    }\n  }\n\n  @Override\n  protected List<Map<String, Object>> toMap(String intermediateRow) throws IOException\n  {\n    try (JsonParser parser = new JsonFactory().createParser(intermediateRow)) {\n      final Iterator<Map> delegate = mapper.readValues(parser, Map.class);\n      return FluentIterable.from(() -> delegate).transform(map -> (Map<String, Object>) map).toList();\n    }\n  }\n}", "url": "https://github.com/apache/druid/pull/10383#discussion_r494696372", "createdAt": "2020-09-25T01:28:32Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/data/input/impl/JsonReader.java", "diffHunk": "@@ -33,13 +40,98 @@\n \n import java.io.IOException;\n import java.util.Collections;\n-import java.util.List;\n+import java.util.Iterator;\n import java.util.Map;\n+import java.util.NoSuchElementException;\n \n-public class JsonReader extends TextReader\n+/**\n+ * <pre>\n+ * In constract to {@link JsonLineReader} which processes input text line by line independently,\n+ * this class tries to parse the input text as a whole to an array of objects.\n+ *\n+ * The input text can be:\n+ * 1. a JSON string of an object in a line or multiple lines(such as pretty-printed JSON text)\n+ * 2. multiple JSON object strings concated by white space character(s)\n+ *\n+ * For case 2, what should be noticed is that if an exception is thrown when parsing one JSON string,\n+ * the rest JSON text will all be ignored\n+ *\n+ * For more information, see: https://github.com/apache/druid/pull/10383\n+ * </pre>\n+ */\n+public class JsonReader implements InputEntityReader", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5Njc2Ng==", "bodyText": "If JsonReader extends IntermediateRowParsingReader, this class will not have to be extracted.", "url": "https://github.com/apache/druid/pull/10383#discussion_r494696766", "createdAt": "2020-09-25T01:30:11Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/data/input/ExceptionThrowingIterator.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.data.input;\n+\n+import org.apache.druid.java.util.common.parsers.CloseableIterator;\n+\n+public class ExceptionThrowingIterator<T> implements CloseableIterator<T>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTYyMDM3OQ=="}, "originalCommit": null, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5OTQzNw==", "bodyText": "This doesn't look pretty, but simple enough to handle this exceptional case. Maybe we can introduce another layer on top of inputFormat to make it more pretty, but I don't think it will be worth at least at this point.", "url": "https://github.com/apache/druid/pull/10383#discussion_r494699437", "createdAt": "2020-09-25T01:40:42Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/data/input/impl/JsonInputFormat.java", "diffHunk": "@@ -73,7 +88,14 @@ public boolean isSplittable()\n   @Override\n   public InputEntityReader createReader(InputRowSchema inputRowSchema, InputEntity source, File temporaryDirectory)\n   {\n-    return new JsonReader(inputRowSchema, source, getFlattenSpec(), objectMapper, keepNullColumns);\n+    return this.lineSplittable ?\n+           new JsonLineReader(inputRowSchema, source, getFlattenSpec(), objectMapper, keepNullColumns) :\n+           new JsonReader(inputRowSchema, source, getFlattenSpec(), objectMapper, keepNullColumns);\n+  }\n+\n+  public void setLineSplittable(boolean lineSplittable)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzA0NTcw", "url": "https://github.com/apache/druid/pull/10383#pullrequestreview-502304570", "createdAt": "2020-10-05T18:15:51Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoxNTo1MlrOHcoZaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMDo1MzozMVrOHctZ3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4NDA0Mw==", "bodyText": "Accidental change?", "url": "https://github.com/apache/druid/pull/10383#discussion_r499784043", "createdAt": "2020-10-05T18:15:52Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/data/input/IntermediateRowParsingReader.java", "diffHunk": "@@ -123,7 +138,7 @@ public void close() throws IOException\n \n   /**\n    * Parses the given intermediate row into a list of {@link InputRow}s.\n-   * This should return a non-empty list.\n+   * This should return a non-empty list", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2MTQ3MQ==", "bodyText": "I think we should check if the sizes of rawColumnsList and rows are same (as in the Javadoc contract) instead of computing a min of them.", "url": "https://github.com/apache/druid/pull/10383#discussion_r499861471", "createdAt": "2020-10-05T20:44:33Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/data/input/IntermediateRowParsingReader.java", "diffHunk": "@@ -96,23 +99,35 @@ public void close() throws IOException\n   public CloseableIterator<InputRowListPlusRawValues> sample() throws IOException\n   {\n     return intermediateRowIterator().map(row -> {\n-      final Map<String, Object> rawColumns;\n+\n+      final List<Map<String, Object>> rawColumnsList;\n       try {\n-        rawColumns = toMap(row);\n+        rawColumnsList = toMap(row);\n       }\n       catch (Exception e) {\n-        return InputRowListPlusRawValues.of(null, new ParseException(e, \"Unable to parse row [%s] into JSON\", row));\n+        return Collections.singletonList(InputRowListPlusRawValues.of(null,\n+                                                                      new ParseException(e, \"Unable to parse row [%s] into JSON\", row)));\n       }\n+\n+      List<InputRow> rows;\n       try {\n-        return InputRowListPlusRawValues.of(parseInputRows(row), rawColumns);\n+        rows = parseInputRows(row);\n       }\n       catch (ParseException e) {\n-        return InputRowListPlusRawValues.of(rawColumns, e);\n+        return Collections.singletonList(InputRowListPlusRawValues.of(rawColumnsList.isEmpty() ? null : rawColumnsList.get(0), e));\n       }\n       catch (IOException e) {\n-        return InputRowListPlusRawValues.of(rawColumns, new ParseException(e, \"Unable to parse row [%s] into inputRow\", row));\n+        return Collections.singletonList(InputRowListPlusRawValues.of(rawColumnsList.isEmpty() ? null : rawColumnsList.get(0),\n+                                                                      new ParseException(e, \"Unable to parse row [%s] into inputRow\", row)));\n+      }\n+\n+      List<InputRowListPlusRawValues> list = new ArrayList<InputRowListPlusRawValues>();\n+      for (int i = 0; i < Math.min(rows.size(), rawColumnsList.size()); i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2MjMzNQ==", "bodyText": "Should we return the entire rawColumnsList instead of the first element? I thought InputRowListPlusRawValues will be able to have a list of rawColumns.", "url": "https://github.com/apache/druid/pull/10383#discussion_r499862335", "createdAt": "2020-10-05T20:46:13Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/data/input/IntermediateRowParsingReader.java", "diffHunk": "@@ -96,23 +99,35 @@ public void close() throws IOException\n   public CloseableIterator<InputRowListPlusRawValues> sample() throws IOException\n   {\n     return intermediateRowIterator().map(row -> {\n-      final Map<String, Object> rawColumns;\n+\n+      final List<Map<String, Object>> rawColumnsList;\n       try {\n-        rawColumns = toMap(row);\n+        rawColumnsList = toMap(row);\n       }\n       catch (Exception e) {\n-        return InputRowListPlusRawValues.of(null, new ParseException(e, \"Unable to parse row [%s] into JSON\", row));\n+        return Collections.singletonList(InputRowListPlusRawValues.of(null,\n+                                                                      new ParseException(e, \"Unable to parse row [%s] into JSON\", row)));\n       }\n+\n+      List<InputRow> rows;\n       try {\n-        return InputRowListPlusRawValues.of(parseInputRows(row), rawColumns);\n+        rows = parseInputRows(row);\n       }\n       catch (ParseException e) {\n-        return InputRowListPlusRawValues.of(rawColumns, e);\n+        return Collections.singletonList(InputRowListPlusRawValues.of(rawColumnsList.isEmpty() ? null : rawColumnsList.get(0), e));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2MzA4Mw==", "bodyText": "Also, should we fail if rawColumnsList.isEmpty()?", "url": "https://github.com/apache/druid/pull/10383#discussion_r499863083", "createdAt": "2020-10-05T20:47:37Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/data/input/IntermediateRowParsingReader.java", "diffHunk": "@@ -96,23 +99,35 @@ public void close() throws IOException\n   public CloseableIterator<InputRowListPlusRawValues> sample() throws IOException\n   {\n     return intermediateRowIterator().map(row -> {\n-      final Map<String, Object> rawColumns;\n+\n+      final List<Map<String, Object>> rawColumnsList;\n       try {\n-        rawColumns = toMap(row);\n+        rawColumnsList = toMap(row);\n       }\n       catch (Exception e) {\n-        return InputRowListPlusRawValues.of(null, new ParseException(e, \"Unable to parse row [%s] into JSON\", row));\n+        return Collections.singletonList(InputRowListPlusRawValues.of(null,\n+                                                                      new ParseException(e, \"Unable to parse row [%s] into JSON\", row)));\n       }\n+\n+      List<InputRow> rows;\n       try {\n-        return InputRowListPlusRawValues.of(parseInputRows(row), rawColumns);\n+        rows = parseInputRows(row);\n       }\n       catch (ParseException e) {\n-        return InputRowListPlusRawValues.of(rawColumns, e);\n+        return Collections.singletonList(InputRowListPlusRawValues.of(rawColumnsList.isEmpty() ? null : rawColumnsList.get(0), e));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2MjMzNQ=="}, "originalCommit": null, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2NTM5Ng==", "bodyText": "Where is JsonParseException thrown wrapped in RuntimeException? Can you add a comment about it?", "url": "https://github.com/apache/druid/pull/10383#discussion_r499865396", "createdAt": "2020-10-05T20:52:04Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/data/input/impl/JsonReader.java", "diffHunk": "@@ -49,41 +73,57 @@\n       boolean keepNullColumns\n   )\n   {\n-    super(inputRowSchema, source);\n+    this.inputRowSchema = inputRowSchema;\n+    this.source = source;\n     this.flattener = ObjectFlatteners.create(flattenSpec, new JSONFlattenerMaker(keepNullColumns));\n     this.mapper = mapper;\n   }\n \n   @Override\n-  public List<InputRow> parseInputRows(String line) throws IOException, ParseException\n+  protected CloseableIterator<String> intermediateRowIterator() throws IOException\n   {\n-    final JsonNode document = mapper.readValue(line, JsonNode.class);\n-    final Map<String, Object> flattened = flattener.flatten(document);\n-    return Collections.singletonList(MapInputRowParser.parse(getInputRowSchema(), flattened));\n+    return CloseableIterators.withEmptyBaggage(\n+        Iterators.singletonIterator(IOUtils.toString(source.open(), StringUtils.UTF8_STRING))\n+    );\n   }\n \n   @Override\n-  public Map<String, Object> toMap(String intermediateRow) throws IOException\n+  protected List<InputRow> parseInputRows(String intermediateRow) throws IOException, ParseException\n   {\n-    //noinspection unchecked\n-    return mapper.readValue(intermediateRow, Map.class);\n-  }\n+    try (JsonParser parser = new JsonFactory().createParser(intermediateRow)) {\n+      final Iterator<JsonNode> delegate = mapper.readValues(parser, JsonNode.class);\n+      return FluentIterable.from(() -> delegate)\n+                           .transform(jsonNode -> MapInputRowParser.parse(inputRowSchema, flattener.flatten(jsonNode)))\n+                           .toList();\n+    }\n+    catch (RuntimeException e) {\n+      //convert Jackson's JsonParseException into druid's exception for further processing\n+      if (e.getCause() instanceof JsonParseException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2NjA3OA==", "bodyText": "lineSplittable shouldn't be ignored, but included in equals() and hashCode().", "url": "https://github.com/apache/druid/pull/10383#discussion_r499866078", "createdAt": "2020-10-05T20:53:31Z", "author": {"login": "jihoonson"}, "path": "core/src/test/java/org/apache/druid/data/input/impl/JsonInputFormatTest.java", "diffHunk": "@@ -69,7 +69,7 @@ public void testEquals()\n               new ObjectMapper(),\n               new ObjectMapper()\n               )\n-              .withIgnoredFields(\"objectMapper\")\n+              .withIgnoredFields(\"objectMapper\", \"lineSplittable\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTY2MjIx", "url": "https://github.com/apache/druid/pull/10383#pullrequestreview-506966221", "createdAt": "2020-10-12T23:01:13Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMzowMToxM1rOHgP1-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMzowNToxMVrOHgP6QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3NjA1Ng==", "bodyText": "This doesn't still seem correct to me.. The purpose of returning rawColumn and exception in InputRowListPlusRawValues is showing them in the sampler altogether, so that users will debug their data and input format easily. To do that, we should show exactly what the data was when a ParseException is thrown. Now, thinking about the new behavior parsing a list of JSONs into InputRows, row will contain the list of JSONs here. If a ParseException was thrown while parsing one of them, we should return one InputRowListPlusRawValues which contains row (the whole list of JSONs) and the exception because we don't know exactly in which JSON in the list the ParseException was thrown from. For this, I still think we should change rawValues in InputRowListPlusRawValues to be List<Map<String, Object>>. I understand that you don't want to touch it as it is widely used in unit tests, but I'm not sure if we can fix this without touching it.", "url": "https://github.com/apache/druid/pull/10383#discussion_r503576056", "createdAt": "2020-10-12T23:01:13Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/data/input/IntermediateRowParsingReader.java", "diffHunk": "@@ -96,23 +101,45 @@ public void close() throws IOException\n   public CloseableIterator<InputRowListPlusRawValues> sample() throws IOException\n   {\n     return intermediateRowIterator().map(row -> {\n-      final Map<String, Object> rawColumns;\n+\n+      final List<Map<String, Object>> rawColumnsList;\n       try {\n-        rawColumns = toMap(row);\n+        rawColumnsList = toMap(row);\n       }\n       catch (Exception e) {\n-        return InputRowListPlusRawValues.of(null, new ParseException(e, \"Unable to parse row [%s] into JSON\", row));\n+        return Collections.singletonList(InputRowListPlusRawValues.of(null,\n+                                                                      new ParseException(e, \"Unable to parse row [%s] into JSON\", row)));\n+      }\n+\n+      if (CollectionUtils.isNullOrEmpty(rawColumnsList)) {\n+        return Collections.singletonList(InputRowListPlusRawValues.of(null,\n+                                                                      new ParseException(\"No map object parsed for row [%s]\", row)));\n       }\n+\n+      List<InputRow> rows;\n       try {\n-        return InputRowListPlusRawValues.of(parseInputRows(row), rawColumns);\n+        rows = parseInputRows(row);\n       }\n       catch (ParseException e) {\n-        return InputRowListPlusRawValues.of(rawColumns, e);\n+        return rawColumnsList.stream().map(rawColumn -> InputRowListPlusRawValues.of(rawColumn, e)).collect(Collectors.toList());\n       }\n       catch (IOException e) {\n-        return InputRowListPlusRawValues.of(rawColumns, new ParseException(e, \"Unable to parse row [%s] into inputRow\", row));\n+        ParseException exception = new ParseException(e, \"Unable to parse row [%s] into inputRow\", row);\n+        return rawColumnsList.stream().map(rawColumn -> InputRowListPlusRawValues.of(rawColumn, exception)).collect(Collectors.toList());\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3NzE1Mw==", "bodyText": "I think we should set both rows and rawColumnsList in InputRowListPlusRawValues in this case, so that users will learn how they are different.", "url": "https://github.com/apache/druid/pull/10383#discussion_r503577153", "createdAt": "2020-10-12T23:05:11Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/data/input/IntermediateRowParsingReader.java", "diffHunk": "@@ -96,23 +101,45 @@ public void close() throws IOException\n   public CloseableIterator<InputRowListPlusRawValues> sample() throws IOException\n   {\n     return intermediateRowIterator().map(row -> {\n-      final Map<String, Object> rawColumns;\n+\n+      final List<Map<String, Object>> rawColumnsList;\n       try {\n-        rawColumns = toMap(row);\n+        rawColumnsList = toMap(row);\n       }\n       catch (Exception e) {\n-        return InputRowListPlusRawValues.of(null, new ParseException(e, \"Unable to parse row [%s] into JSON\", row));\n+        return Collections.singletonList(InputRowListPlusRawValues.of(null,\n+                                                                      new ParseException(e, \"Unable to parse row [%s] into JSON\", row)));\n+      }\n+\n+      if (CollectionUtils.isNullOrEmpty(rawColumnsList)) {\n+        return Collections.singletonList(InputRowListPlusRawValues.of(null,\n+                                                                      new ParseException(\"No map object parsed for row [%s]\", row)));\n       }\n+\n+      List<InputRow> rows;\n       try {\n-        return InputRowListPlusRawValues.of(parseInputRows(row), rawColumns);\n+        rows = parseInputRows(row);\n       }\n       catch (ParseException e) {\n-        return InputRowListPlusRawValues.of(rawColumns, e);\n+        return rawColumnsList.stream().map(rawColumn -> InputRowListPlusRawValues.of(rawColumn, e)).collect(Collectors.toList());\n       }\n       catch (IOException e) {\n-        return InputRowListPlusRawValues.of(rawColumns, new ParseException(e, \"Unable to parse row [%s] into inputRow\", row));\n+        ParseException exception = new ParseException(e, \"Unable to parse row [%s] into inputRow\", row);\n+        return rawColumnsList.stream().map(rawColumn -> InputRowListPlusRawValues.of(rawColumn, exception)).collect(Collectors.toList());\n+      }\n+\n+      if (rows.size() != rawColumnsList.size()) {\n+        return Collections.singletonList(InputRowListPlusRawValues.of(null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea0a561b0f8fd5723b88cfc9ea2e397870d75a10", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/ea0a561b0f8fd5723b88cfc9ea2e397870d75a10", "committedDate": "2020-10-16T10:30:15Z", "message": "support multi-line text"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18b7b99b7fbf5cdc2ebbc5e415b750ae00129ed3", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/18b7b99b7fbf5cdc2ebbc5e415b750ae00129ed3", "committedDate": "2020-10-16T10:30:15Z", "message": "add test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3815eda2c0c64e904bc3e95faf0bc8d66e70963c", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/3815eda2c0c64e904bc3e95faf0bc8d66e70963c", "committedDate": "2020-10-16T10:30:15Z", "message": "split json text into lines case by case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2159cb85f4c78189159c50317c45741f2ee0ea34", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/2159cb85f4c78189159c50317c45741f2ee0ea34", "committedDate": "2020-10-16T10:30:15Z", "message": "improve exception handle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "129db850e933a43b9a05cc5f6567eea2cde585d9", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/129db850e933a43b9a05cc5f6567eea2cde585d9", "committedDate": "2020-10-16T10:30:16Z", "message": "fix CI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93b06abb80b3f18a57905539a6675ecd73a16e49", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/93b06abb80b3f18a57905539a6675ecd73a16e49", "committedDate": "2020-10-16T10:30:16Z", "message": "use IntermediateRowParsingReader as base of JsonReader"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d3822450e205dcc1bccaa4763ef3e34d65ee6ff", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/9d3822450e205dcc1bccaa4763ef3e34d65ee6ff", "committedDate": "2020-10-16T10:30:16Z", "message": "update doc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7df940c5db2dbc594e00c29bcf0a3e743cd6d228", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/7df940c5db2dbc594e00c29bcf0a3e743cd6d228", "committedDate": "2020-10-16T10:30:16Z", "message": "ignore the non-immutable field in test case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "330b16c4f8d023040b3556854a65272f3e152883", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/330b16c4f8d023040b3556854a65272f3e152883", "committedDate": "2020-10-16T10:30:16Z", "message": "add more test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3649e89afe8736218441cea6236757ab6737e58d", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/3649e89afe8736218441cea6236757ab6737e58d", "committedDate": "2020-10-16T10:30:16Z", "message": "mark `lineSplittable` as final"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "929f2a208cf2773b9c1d6fe52b79f337c7fd4a53", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/929f2a208cf2773b9c1d6fe52b79f337c7fd4a53", "committedDate": "2020-10-16T10:30:16Z", "message": "fix testcases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "078410d4cb4a8ad8340b1f5f04da3d897698400b", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/078410d4cb4a8ad8340b1f5f04da3d897698400b", "committedDate": "2020-10-16T10:30:16Z", "message": "fix doc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0f449ec2a3472755524ae4fccbbe9e852c55594", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/d0f449ec2a3472755524ae4fccbbe9e852c55594", "committedDate": "2020-10-16T10:30:16Z", "message": "add a test case for SqlReader"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd34e1d0f6b762ba6cab93b966ccbe3ef1a79374", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/fd34e1d0f6b762ba6cab93b966ccbe3ef1a79374", "committedDate": "2020-10-16T10:36:42Z", "message": "return all raw columns when exception occurs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "fd34e1d0f6b762ba6cab93b966ccbe3ef1a79374", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/fd34e1d0f6b762ba6cab93b966ccbe3ef1a79374", "committedDate": "2020-10-16T10:36:42Z", "message": "return all raw columns when exception occurs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8cba03019a59001efb391aa15240c1946cc1cfb1", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/8cba03019a59001efb391aa15240c1946cc1cfb1", "committedDate": "2020-10-19T09:36:42Z", "message": "fix CI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9eb12a548e961ab700a43b064735d52f4495c40", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/a9eb12a548e961ab700a43b064735d52f4495c40", "committedDate": "2020-10-20T05:18:26Z", "message": "fix test cases"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "a9eb12a548e961ab700a43b064735d52f4495c40", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/a9eb12a548e961ab700a43b064735d52f4495c40", "committedDate": "2020-10-20T05:18:26Z", "message": "fix test cases"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MTM0NjUz", "url": "https://github.com/apache/druid/pull/10383#pullrequestreview-515134653", "createdAt": "2020-10-22T21:31:09Z", "commit": {"oid": "a9eb12a548e961ab700a43b064735d52f4495c40"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMTozMToxMFrOHm0mqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMTowMToxMFrOHoiMow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2OTgwMg==", "bodyText": "nit: it would be better to use Iterables.getOnlyElement(rawValues) to make sure that you are getting the only element.", "url": "https://github.com/apache/druid/pull/10383#discussion_r510469802", "createdAt": "2020-10-22T21:31:10Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/data/input/InputRowListPlusRawValues.java", "diffHunk": "@@ -82,8 +121,16 @@ private InputRowListPlusRawValues(\n     return inputRows;\n   }\n \n+  /**\n+   * This method is left here only for test cases\n+   */\n   @Nullable\n   public Map<String, Object> getRawValues()\n+  {\n+    return CollectionUtils.isNullOrEmpty(rawValues) ? null : rawValues.get(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9eb12a548e961ab700a43b064735d52f4495c40"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MTY5Mw==", "bodyText": "ParseException is Nullable.", "url": "https://github.com/apache/druid/pull/10383#discussion_r512261693", "createdAt": "2020-10-26T20:54:23Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/data/input/InputRowListPlusRawValues.java", "diffHunk": "@@ -53,21 +54,59 @@ public static InputRowListPlusRawValues of(@Nullable InputRow inputRow, Map<Stri\n \n   public static InputRowListPlusRawValues of(@Nullable List<InputRow> inputRows, Map<String, Object> rawColumns)\n   {\n-    return new InputRowListPlusRawValues(inputRows, Preconditions.checkNotNull(rawColumns, \"rawColumns\"), null);\n+    return new InputRowListPlusRawValues(inputRows,\n+                                         Collections.singletonList(Preconditions.checkNotNull(rawColumns, \"rawColumns\")),\n+                                         null);\n   }\n \n   public static InputRowListPlusRawValues of(@Nullable Map<String, Object> rawColumns, ParseException parseException)\n   {\n     return new InputRowListPlusRawValues(\n         null,\n-        rawColumns,\n+        rawColumns == null ? null : Collections.singletonList(rawColumns),\n         Preconditions.checkNotNull(parseException, \"parseException\")\n     );\n   }\n \n+  public static InputRowListPlusRawValues ofList(@Nullable List<Map<String, Object>> rawColumnsList, ParseException parseException)\n+  {\n+    return ofList(rawColumnsList, null, parseException);\n+  }\n+\n+  /**\n+   * Create an instance of {@link InputRowListPlusRawValues}\n+   *\n+   * Make sure the size of given rawColumnsList and inputRows are the same if both of them are not null\n+   */\n+  public static InputRowListPlusRawValues ofList(@Nullable List<Map<String, Object>> rawColumnsList,\n+                                                 @Nullable List<InputRow> inputRows)\n+  {\n+    return ofList(rawColumnsList, inputRows, null);\n+  }\n+\n+  /**\n+   * Create an instance of {@link InputRowListPlusRawValues}\n+   *\n+   * Make sure the size of given rawColumnsList and inputRows are the same if both of them are not null\n+   */\n+  public static InputRowListPlusRawValues ofList(@Nullable List<Map<String, Object>> rawColumnsList,\n+                                                 @Nullable List<InputRow> inputRows,\n+                                                 ParseException parseException)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9eb12a548e961ab700a43b064735d52f4495c40"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2NTM3OQ==", "bodyText": "Can this introduce duplicate rows in responseRows? Suppose you have 3 rawColumns in rawColumnsList including an unparseable row at the second position. The first row will be added to both index and thus a new SamplerResponseRow of the first rawColumns will be added to responseRows. But for the second row, index.add() will throw a ParseException which will execute these lines. In this case, 2 duplicate rawColumns of the first row will be added in responseRows.\nLooking at what JsonReader does, it seems throwing away the whole intermediateRow when there is any unparseable row. The sampler behavior should match to the actual ingestion.", "url": "https://github.com/apache/druid/pull/10383#discussion_r512265379", "createdAt": "2020-10-26T21:01:10Z", "author": {"login": "jihoonson"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/overlord/sampler/InputSourceSampler.java", "diffHunk": "@@ -131,17 +130,27 @@ public SamplerResponse sample(\n             continue;\n           }\n \n-          for (InputRow row : inputRowListPlusRawValues.getInputRows()) {\n-            index.add(new SamplerInputRow(row, counter), true);\n+          for (int i = 0; i < rawColumnsList.size(); i++) {\n+            Map<String, Object> rawColumns = rawColumnsList.get(i);\n+            InputRow row = inputRowListPlusRawValues.getInputRows().get(i);\n+\n+            //keep the index of the row to be added to responseRows for further use\n+            final int rowIndex = responseRows.size();\n+            index.add(new SamplerInputRow(row, rowIndex), true);\n+\n             // store the raw value; will be merged with the data from the IncrementalIndex later\n-            responseRows[counter] = new SamplerResponseRow(rawColumns, null, null, null);\n-            counter++;\n+            responseRows.add(new SamplerResponseRow(rawColumns, null, null, null));\n             numRowsIndexed++;\n           }\n         }\n         catch (ParseException e) {\n-          responseRows[counter] = new SamplerResponseRow(rawColumns, null, true, e.getMessage());\n-          counter++;\n+          if (rawColumnsList != null) {\n+            responseRows.addAll(rawColumnsList.stream()\n+                                              .map(rawColumns -> new SamplerResponseRow(rawColumns, null, true, e.getMessage()))\n+                                              .collect(Collectors.toList()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9eb12a548e961ab700a43b064735d52f4495c40"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "167a579aa28f1733509cec436e60d50a322fef26", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/167a579aa28f1733509cec436e60d50a322fef26", "committedDate": "2020-10-27T09:36:58Z", "message": "resolve review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4288c4a3087eb78079b365e26d5b3878c9cf2f67", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/4288c4a3087eb78079b365e26d5b3878c9cf2f67", "committedDate": "2020-10-30T08:20:33Z", "message": "handle ParseException returned by index.add"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1157d2f13f8cff3e3539fb64555c2eb1cba3c21", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/c1157d2f13f8cff3e3539fb64555c2eb1cba3c21", "committedDate": "2020-10-30T08:25:36Z", "message": "apply Iterables.getOnlyElement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "150c57954f30c2b9f267556f1e4e47402c124bee", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/150c57954f30c2b9f267556f1e4e47402c124bee", "committedDate": "2020-10-30T10:42:41Z", "message": "fix CI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e89053e22659effbf6bad7f198ad002528fe1727", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/e89053e22659effbf6bad7f198ad002528fe1727", "committedDate": "2020-10-31T01:24:19Z", "message": "fix test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e5c1306ba4df053c54419e726fed24e457387d3", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/2e5c1306ba4df053c54419e726fed24e457387d3", "committedDate": "2020-10-31T01:46:00Z", "message": "improve code in more graceful way"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a9076cfe7b8c767b02888f03b98133f9a480f26", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/3a9076cfe7b8c767b02888f03b98133f9a480f26", "committedDate": "2020-11-01T12:03:24Z", "message": "fix test cases"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NTE4MzI3", "url": "https://github.com/apache/druid/pull/10383#pullrequestreview-526518327", "createdAt": "2020-11-09T18:06:13Z", "commit": {"oid": "3a9076cfe7b8c767b02888f03b98133f9a480f26"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxODowNjoxNFrOHv7H5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxODoyNToxM1rOHv7zNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAxMzc5OQ==", "bodyText": "nit: with this change, when a parseException is thrown while parsing a list of rows in one message, those rows in the message will be added as separate rows in responseRows but with the same parseException. This can be confusing since the parseException error message seem irrelevant to the associated rawColumns in the same responseRow. IMO, the better fix in this case would be storing the whole rawColumnsList in one SamplerResponseRow. Then, the parseException can indicate that it was thrown while parsing one of the rows in rawColumnsList. However, this requires a change on the web console side as well. I'm OK with fixing this in a follow-up PR.", "url": "https://github.com/apache/druid/pull/10383#discussion_r520013799", "createdAt": "2020-11-09T18:06:14Z", "author": {"login": "jihoonson"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/overlord/sampler/InputSourceSampler.java", "diffHunk": "@@ -111,38 +113,49 @@ public SamplerResponse sample(\n     try (final CloseableIterator<InputRowListPlusRawValues> iterator = reader.sample();\n          final IncrementalIndex<Aggregator> index = buildIncrementalIndex(nonNullSamplerConfig, nonNullDataSchema);\n          final Closer closer1 = closer) {\n-      SamplerResponseRow[] responseRows = new SamplerResponseRow[nonNullSamplerConfig.getNumRows()];\n-      int counter = 0, numRowsIndexed = 0;\n-\n-      while (counter < responseRows.length && iterator.hasNext()) {\n-        Map<String, Object> rawColumns = null;\n-        try {\n-          final InputRowListPlusRawValues inputRowListPlusRawValues = iterator.next();\n-\n-          if (inputRowListPlusRawValues.getRawValues() != null) {\n-            rawColumns = inputRowListPlusRawValues.getRawValues();\n-          }\n-\n-          if (inputRowListPlusRawValues.getParseException() != null) {\n-            throw inputRowListPlusRawValues.getParseException();\n+      List<SamplerResponseRow> responseRows = new ArrayList<>(nonNullSamplerConfig.getNumRows());\n+      int numRowsIndexed = 0;\n+\n+      while (responseRows.size() < nonNullSamplerConfig.getNumRows() && iterator.hasNext()) {\n+        final InputRowListPlusRawValues inputRowListPlusRawValues = iterator.next();\n+\n+        final List<Map<String, Object>> rawColumnsList = inputRowListPlusRawValues.getRawValuesList();\n+\n+        final ParseException parseException = inputRowListPlusRawValues.getParseException();\n+        if (parseException != null) {\n+          if (rawColumnsList != null) {\n+            // add all rows to response\n+            responseRows.addAll(rawColumnsList.stream()\n+                                              .map(rawColumns -> new SamplerResponseRow(rawColumns, null, true, parseException.getMessage()))\n+                                              .collect(Collectors.toList()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a9076cfe7b8c767b02888f03b98133f9a480f26"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAxODgxMQ==", "bodyText": "Did you intend StringUtils.toUtf8(illformed)? The variable illformed is not in use.", "url": "https://github.com/apache/druid/pull/10383#discussion_r520018811", "createdAt": "2020-11-09T18:14:52Z", "author": {"login": "jihoonson"}, "path": "extensions-core/kafka-indexing-service/src/test/java/org/apache/druid/indexing/kafka/KafkaIndexTaskTest.java", "diffHunk": "@@ -2726,4 +2726,83 @@ public void close()\n         null\n     );\n   }\n+\n+  @Test(timeout = 60_000L)\n+  public void testMultipleLinesJSONText() throws Exception\n+  {\n+    reportParseExceptions = false;\n+    maxParseExceptions = 1000;\n+    maxSavedParseExceptions = 2;\n+\n+    // Insert data\n+    try (final KafkaProducer<byte[], byte[]> kafkaProducer = kafkaServer.newProducer()) {\n+      kafkaProducer.initTransactions();\n+      kafkaProducer.beginTransaction();\n+\n+      //multiple objects in one Kafka record will yield 2 rows in druid\n+      String wellformed = toJsonString(true, \"2049\", \"d2\", \"y\", \"10\", \"22.0\", \"2.0\") +\n+                     toJsonString(true, \"2049\", \"d3\", \"y\", \"10\", \"23.0\", \"3.0\");\n+\n+      //multiple objects in one Kafka record but some objects are in ill-formed format\n+      //the whole ProducerRecord will be discarded\n+      String illformed = \"{\\\"timestamp\\\":2049, \\\"dim1\\\": \\\"d4\\\", \\\"dim2\\\":\\\"x\\\", \\\"dimLong\\\": 10, \\\"dimFloat\\\":\\\"24.0\\\", \\\"met1\\\":\\\"2.0\\\" }\" +\n+                     \"{\\\"timestamp\\\":2049, \\\"dim1\\\": \\\"d5\\\", \\\"dim2\\\":\\\"y\\\", \\\"dimLong\\\": 10, \\\"dimFloat\\\":\\\"24.0\\\", \\\"met1\\\":invalidFormat }\" +\n+                     \"{\\\"timestamp\\\":2049, \\\"dim1\\\": \\\"d6\\\", \\\"dim2\\\":\\\"z\\\", \\\"dimLong\\\": 10, \\\"dimFloat\\\":\\\"24.0\\\", \\\"met1\\\":\\\"3.0\\\" }\";\n+\n+      ProducerRecord[] producerRecords = new ProducerRecord[]{\n+          // pretty formatted\n+          new ProducerRecord<>(topic, 0, null, jb(true, \"2049\", \"d1\", \"y\", \"10\", \"20.0\", \"1.0\")),\n+          //well-formed\n+          new ProducerRecord<>(topic, 0, null, StringUtils.toUtf8(wellformed)),\n+          //ill-formed\n+          new ProducerRecord<>(topic, 0, null, StringUtils.toUtf8(\"illformed\")),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a9076cfe7b8c767b02888f03b98133f9a480f26"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAyNDg4Nw==", "bodyText": "Thanks for adding this test! Similar to https://github.com/apache/druid/pull/10383/files#diff-ef25ac1cc1f275b47b939b65e1d0c8b8b8512aeada52d06b8541b8f381df03eeR2731, could you please add a unit test for sampling a block of multiple JSON strings? The unit test can be run only when parserType is STR_JSON. We usually just return in the unit test when the parameter is not what we want to test with. It would be nice if the test verifies the followings:\n\nThe sampler response when there is no parseException with a list of multiple JSON strings.\nThe sampler response when there is a parseException thrown while parsing a list of multiple JSON strings. Maybe you can improve this unit test to do it as well.", "url": "https://github.com/apache/druid/pull/10383#discussion_r520024887", "createdAt": "2020-11-09T18:25:13Z", "author": {"login": "jihoonson"}, "path": "indexing-service/src/test/java/org/apache/druid/indexing/overlord/sampler/InputSourceSamplerTest.java", "diffHunk": "@@ -1060,6 +1062,107 @@ public void testWithFilter() throws IOException\n     );\n   }\n \n+  @Test\n+  public void testIndexParseException() throws IOException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a9076cfe7b8c767b02888f03b98133f9a480f26"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50718ce5f8c6862edcdf094895afc277c3229d62", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/50718ce5f8c6862edcdf094895afc277c3229d62", "committedDate": "2020-11-10T04:18:20Z", "message": "fix test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19fae71afb3d6f750a468c5bca2e8cdddb55a71f", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/19fae71afb3d6f750a468c5bca2e8cdddb55a71f", "committedDate": "2020-11-10T09:47:16Z", "message": "add a test case to check multiple json string in one text block"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NDYyMzgw", "url": "https://github.com/apache/druid/pull/10383#pullrequestreview-527462380", "createdAt": "2020-11-10T17:55:37Z", "commit": {"oid": "19fae71afb3d6f750a468c5bca2e8cdddb55a71f"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNzo1NTozN1rOHwomsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNzo1NTozN1rOHwomsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1ODk2MQ==", "bodyText": "[ERROR] indexing-service/src/test/java/org/apache/druid/indexing/overlord/sampler/InputSourceSamplerTest.java:1221 -- Can be replaced with 'Collectors.joining'\n\nSeems like the Intellij Inspection CI doesn't like this line.", "url": "https://github.com/apache/druid/pull/10383#discussion_r520758961", "createdAt": "2020-11-10T17:55:37Z", "author": {"login": "jihoonson"}, "path": "indexing-service/src/test/java/org/apache/druid/indexing/overlord/sampler/InputSourceSamplerTest.java", "diffHunk": "@@ -1163,6 +1172,121 @@ public void testIndexParseException() throws IOException\n     );\n   }\n \n+  /**\n+   *\n+   * This case tests sampling for multiple json lines in one text block\n+   * Currently only RecordSupplierInputSource supports this kind of input, see https://github.com/apache/druid/pull/10383 for more information\n+   *\n+   * This test combines illegal json block and legal json block together to verify:\n+   * 1. all lines in the illegal json block should not be parsed\n+   * 2. the illegal json block should not affect the processing of the 2nd record\n+   * 3. all lines in legal json block should be parsed successfully\n+   *\n+   */\n+  @Test\n+  public void testMultipleJsonStringInOneBlock() throws IOException\n+  {\n+    if (!ParserType.STR_JSON.equals(parserType) || !useInputFormatApi) {\n+      return;\n+    }\n+\n+    final TimestampSpec timestampSpec = new TimestampSpec(\"t\", null, null);\n+    final DimensionsSpec dimensionsSpec = new DimensionsSpec(\n+        ImmutableList.of(StringDimensionSchema.create(\"dim1PlusBar\"))\n+    );\n+    final TransformSpec transformSpec = new TransformSpec(\n+        null,\n+        ImmutableList.of(new ExpressionTransform(\"dim1PlusBar\", \"concat(dim1 + 'bar')\", TestExprMacroTable.INSTANCE))\n+    );\n+    final AggregatorFactory[] aggregatorFactories = {new LongSumAggregatorFactory(\"met1\", \"met1\")};\n+    final GranularitySpec granularitySpec = new UniformGranularitySpec(\n+        Granularities.DAY,\n+        Granularities.HOUR,\n+        true,\n+        null\n+    );\n+    final DataSchema dataSchema = createDataSchema(\n+        timestampSpec,\n+        dimensionsSpec,\n+        aggregatorFactories,\n+        granularitySpec,\n+        transformSpec\n+    );\n+\n+    List<String> jsonBlockList = ImmutableList.of(\n+        // include the line which can't be parsed into JSON object to form a illegal json block\n+        String.join(\"\", STR_JSON_ROWS),\n+\n+        // exclude the last line to form a legal json block\n+        String.join(\"\", STR_JSON_ROWS.stream().limit(STR_JSON_ROWS.size() - 1).collect(Collectors.toList()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19fae71afb3d6f750a468c5bca2e8cdddb55a71f"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fbe683a24385d9c64a83f2f1e8ea6c81ad77a3f4", "author": {"user": {"login": "FrankChen021", "name": "Frank Chen"}}, "url": "https://github.com/apache/druid/commit/fbe683a24385d9c64a83f2f1e8ea6c81ad77a3f4", "committedDate": "2020-11-11T01:25:38Z", "message": "fix inspection check"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3619, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}