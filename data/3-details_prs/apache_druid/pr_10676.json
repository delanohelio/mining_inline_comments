{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM5NjI1Mjgx", "number": 10676, "title": "Allow client to configure batch ingestion task to wait to complete until segments are confirmed to be available by other", "bodyText": "update for release notes\nAdd the ability to tell a batch ingestion task to wait for newly indexed segments to become available for query on Historical services before completing. This is turned off by default. If an end user wants their task to wait a specified amount of time for their segments to become available before the task completes, they must add awaitSegmentAvailabilityTimeoutMillis to the tuningConfig in their ingestion spec. If an end user adds this to their spec, the job will query the coordinator periodically checking to see if the desired segments have become available for query. If not all segments become available by the time this timeout expires, the job will still succeed. However, in the IngestionStatsAndErrors report, segmentAvailabilityConfirmed will be false. This indicates that handoff was not successful and these newly indexed segments may not all be available for query. On the other hand, if all segments become available for query on the Historical services before the timeout expires, the value for that key in the report will be true.\nThis tuningConfig value is not supported for compaction tasks at this time. If a user tries to specify a value for awaitSegmentAvailabilityTimeoutMillis for Compaction, the task will fail telling the user it is not supported.\nend update\n\n\n\nDescription\n\n\n\nHigh Level Description\nAdd configuration in tuningConfig for end user to tell Indexing Service to wait for segments to become available for query before completing the indexing task. The configuration is a timeout value in milliseconds to prevent waiting forever. If the timeout expires, the task still succeeds, but the task reports will indicate that Druid was not able to confirm that the segments became available for query.\nThis new configuration stems from my experience operating a production cluster with many tenants who often have the same complaint: \"My indexing job is complete but the latest data is not available right when the job finishes\". This addresses that by letting the client set a reasonable timeout. After the job completes, they can parse the ingestion report and see if their segments became available. More often than not, with a reasonable timeout, their segments will indeed be available right when the job completes.\nImplementation\nA lot of the code is already written for realtime handoffs. I extracted that code out of the realtime packages into a Java package so it is less confusing as to why non-realtime tasks are using it. org.apache.druid.segment.handoff is a new package in druid-server module.\nAbstractBatchIndexTask gets a new method, waitForSegmentAvailability(TaskToolbox toolbox, ExecutorService exec, List<DataSegment> segmentsToWaitFor, long waitTimeout) that handles the waiting. Batch Indexing implementations leverage this method at the end of their ingestion task code if the client's tuningConfig has a non-zero wait time for segment availability. Default is to not wait.\nA new key:value pair is added to the IngestionStatsAndErrorsTaskReport segmentAvailabilityConfirmed. This is a boolean that indicates if the job was able to confirm query availability of the new segments before finishing. Parallel index task supervisor did not previously have this report, so this PR adds the report with the needed availability key:value pair so all of simple native, parallel native, and hadoop native can implement this availability wait.\nAlternatives\nhttps://github.com/apache/druid/releases#19-datasource-loadstatus became available in druid 0.20.0. However, I worry about giving ingestion clients the green light to hit this API endpoint due to the possible expense of the calls depending on the questions asked.\n\n\n\n\n\nThis PR has:\n\n been self-reviewed.\n\n using the concurrency checklist (Remove this item if the PR doesn't have any relation to concurrency.)\n\n\n added documentation for new or modified features or behaviors.\n added Javadocs for most classes and all non-trivial methods. Linked related entities via Javadoc links.\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.\n added unit tests or modified existing tests to cover new code paths, ensuring the threshold for code coverage is met.\n added integration tests.\n been tested in a test Druid cluster.\n\n\n\nKey changed/added classes in this PR\n\nAbstractBatchIndexTask\nHadoopIndexTask\nIndexTask\nParallelIndexSupervisorTask\nHadoopTuningConfig\nParallelIndexTuningConfig\nIngestionStatsAndErrorsTaskReportData\nAbstractITBatchIndexTest\nITHadoopIndexTest\nITBestEffortRollupParallelIndexTest\nITIndexerTest", "createdAt": "2020-12-14T16:05:15Z", "url": "https://github.com/apache/druid/pull/10676", "merged": true, "mergeCommit": {"oid": "8264203cee688607091232897749e959e7706010"}, "closed": true, "closedAt": "2021-04-09T04:03:00Z", "author": {"login": "capistrant"}, "timelineItems": {"totalCount": 54, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdkfbMSAH2gAyNTM5NjI1MjgxOmQ5ZTdmOWJkMmI1Y2QxYjJlOGRmMDdiNjZmZjliN2FlYTFlNDE0NDM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABeKnoSaAH2gAyNTM5NjI1MjgxOjM4MWNkZmU4ZDY0MDRlZWRiYzFkZjAxZjU4MjM1ZDdmNGE5YmY1MTU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d9e7f9bd2b5cd1b2e8df07b66ff9b7aea1e41443", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/d9e7f9bd2b5cd1b2e8df07b66ff9b7aea1e41443", "committedDate": "2020-12-09T14:15:16Z", "message": "Add ability to wait for segment availability for batch jobs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d4de8ca8ddee96357c48955f74fb95d4d3d2cec", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/3d4de8ca8ddee96357c48955f74fb95d4d3d2cec", "committedDate": "2020-12-11T21:14:24Z", "message": "IT updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "027938ea80e385136b32c405f8046b9cef675fc1", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/027938ea80e385136b32c405f8046b9cef675fc1", "committedDate": "2020-12-11T23:39:57Z", "message": "fix queries in legacy hadoop IT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b9d26d07527b8b2b6b1a8ed09dc0ac36e353797", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/8b9d26d07527b8b2b6b1a8ed09dc0ac36e353797", "committedDate": "2020-12-14T23:09:39Z", "message": "Fix broken indexing integration tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72cd38a438c16a4cadb4bdedc7b643ffde0b7230", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/72cd38a438c16a4cadb4bdedc7b643ffde0b7230", "committedDate": "2020-12-15T00:14:22Z", "message": "address an lgtm flag"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f47a8bdb1dfe9602fa64459c3cf8c8ec13808cae", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/f47a8bdb1dfe9602fa64459c3cf8c8ec13808cae", "committedDate": "2020-12-15T20:42:48Z", "message": "spell checker still flagging for hadoop doc. adding under that file header too"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5ed3c838e6939f4779bc34b65b9bcae321507b3", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/d5ed3c838e6939f4779bc34b65b9bcae321507b3", "committedDate": "2020-12-15T20:45:47Z", "message": "fix compaction IT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71d6f180e31bec39cf5a3917b44c6a9afd984cfc", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/71d6f180e31bec39cf5a3917b44c6a9afd984cfc", "committedDate": "2020-12-15T23:13:11Z", "message": "Updates to wait for availability method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0170dcaa6b81ff72b117c84faeb9a755006544d3", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/0170dcaa6b81ff72b117c84faeb9a755006544d3", "committedDate": "2020-12-15T23:13:23Z", "message": "improve unit testing for patch"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNDQwMTQz", "url": "https://github.com/apache/druid/pull/10676#pullrequestreview-553440143", "createdAt": "2020-12-16T08:09:25Z", "commit": {"oid": "0170dcaa6b81ff72b117c84faeb9a755006544d3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODowOToyNVrOIG4uQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODowOToyNVrOIG4uQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA5MTcxNA==", "bodyText": "nit: Each time we call the waitForSegmentAvailability function will communicate with coordinator no matter what the value of waitTimeout is and bring extra pressure to the Coordiantor, because there may be hundreds of thousands of batch tasks per day.\nMaybe we can do a double check here, like when waitTimeout<=0 then skip all the waitForSegmentAvailability  if possible , just in case that call waitForSegmentAvailability function without checking waitTimeout.", "url": "https://github.com/apache/druid/pull/10676#discussion_r544091714", "createdAt": "2020-12-16T08:09:25Z", "author": {"login": "zhangyue19921010"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/AbstractBatchIndexTask.java", "diffHunk": "@@ -576,6 +582,73 @@ static Granularity findGranularityFromSegments(List<DataSegment> segments)\n     }\n   }\n \n+  /**\n+   * Wait for segments to become available on the cluster. If waitTimeout is reached, giveup on waiting. This is a\n+   * QoS method that can be used to make Batch Ingest tasks wait to finish until their ingested data is available on\n+   * the cluster. Doing so gives an end user assurance that a Successful task status means their data is available\n+   * for querying.\n+   *\n+   * @param toolbox {@link TaskToolbox} object with for assisting with task work.\n+   * @param segmentsToWaitFor {@link List} of segments to wait for availability.\n+   * @param waitTimeout Millis to wait before giving up\n+   * @return True if all segments became available, otherwise False.\n+   */\n+  protected boolean waitForSegmentAvailability(TaskToolbox toolbox, ExecutorService exec, List<DataSegment> segmentsToWaitFor, long waitTimeout)\n+  {\n+    if (segmentsToWaitFor.isEmpty()) {\n+      log.info(\"Asked to wait for segments to be available, but I wasn't provided with any segments!?\");\n+      return false;\n+    }\n+    log.info(\"Waiting for segments to be loaded by the cluster...\");\n+\n+    SegmentHandoffNotifier notifier = toolbox.getSegmentHandoffNotifierFactory()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0170dcaa6b81ff72b117c84faeb9a755006544d3"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNDQwMzAw", "url": "https://github.com/apache/druid/pull/10676#pullrequestreview-553440300", "createdAt": "2020-12-16T08:09:39Z", "commit": {"oid": "0170dcaa6b81ff72b117c84faeb9a755006544d3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODowOTozOVrOIG4u5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODowOTozOVrOIG4u5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA5MTg3OA==", "bodyText": "nit: Could we extract ingestionSchema.getTuningConfig().getAwaitSegmentAvailabilityTimeoutMillis() at class level if possible?", "url": "https://github.com/apache/druid/pull/10676#discussion_r544091878", "createdAt": "2020-12-16T08:09:39Z", "author": {"login": "zhangyue19921010"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/batch/parallel/ParallelIndexSupervisorTask.java", "diffHunk": "@@ -491,6 +497,31 @@ private boolean isParallelMode()\n     return isParallelMode(baseInputSource, ingestionSchema.getTuningConfig());\n   }\n \n+  /**\n+   * Attempt to wait for indexed segments to become available on the cluster.\n+   * @param reportsMap Map containing information with published segments that we are going to wait for.\n+   */\n+  private void waitForSegmentAvailability(Map<String, PushedSegmentsReport> reportsMap)\n+  {\n+    ArrayList<DataSegment> segmentsToWaitFor = new ArrayList<>();\n+    reportsMap.values()\n+              .forEach(report -> {\n+                segmentsToWaitFor.addAll(report.getNewSegments());\n+              });\n+    ExecutorService availabilityExec = Execs.singleThreaded(\"ParallelTaskAvailabilityWaitExec\");\n+    try {\n+      segmentAvailabilityConfirmationCompleted = waitForSegmentAvailability(\n+          toolbox,\n+          availabilityExec,\n+          segmentsToWaitFor,\n+          ingestionSchema.getTuningConfig().getAwaitSegmentAvailabilityTimeoutMillis()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0170dcaa6b81ff72b117c84faeb9a755006544d3"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNTQ1Mzk2", "url": "https://github.com/apache/druid/pull/10676#pullrequestreview-553545396", "createdAt": "2020-12-16T10:23:03Z", "commit": {"oid": "0170dcaa6b81ff72b117c84faeb9a755006544d3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDoyMzowM1rOIG-JZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDoyMzowM1rOIG-JZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE4MDU4MQ==", "bodyText": "not sure but removing items from the collection while iterating it may cause an error. Instead, we could use a counter and a completableFuture together. Something like this\nCompletableFuture<Void> uberFuture = CompletableFuture.completedFuture(null);\nfor (DataSegment s : segmentsToWaitFor) {\n      CompletableFuture<Void> future = new CompletableFuture<>();\n      notifier.registerSegmentHandoffCallback(\n          new SegmentDescriptor(s.getInterval(), s.getVersion(), s.getShardSpec().getPartitionNum()),\n          exec,\n          () -> {\n            log.info(\n                \"Confirmed availability for [%s]. Removing from list of segments to wait for\",\n                s.getId()\n            );\n           future.complete(null);\n         }\n      );\n     uberFuture = uberFuture.thenCombine(future, (a, b) -> null);\n    }\nuberFuture.get(waitTimeout, TimeUnit.MILLISECONDS)", "url": "https://github.com/apache/druid/pull/10676#discussion_r544180581", "createdAt": "2020-12-16T10:23:03Z", "author": {"login": "abhishekagarwal87"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/AbstractBatchIndexTask.java", "diffHunk": "@@ -576,6 +582,73 @@ static Granularity findGranularityFromSegments(List<DataSegment> segments)\n     }\n   }\n \n+  /**\n+   * Wait for segments to become available on the cluster. If waitTimeout is reached, giveup on waiting. This is a\n+   * QoS method that can be used to make Batch Ingest tasks wait to finish until their ingested data is available on\n+   * the cluster. Doing so gives an end user assurance that a Successful task status means their data is available\n+   * for querying.\n+   *\n+   * @param toolbox {@link TaskToolbox} object with for assisting with task work.\n+   * @param segmentsToWaitFor {@link List} of segments to wait for availability.\n+   * @param waitTimeout Millis to wait before giving up\n+   * @return True if all segments became available, otherwise False.\n+   */\n+  protected boolean waitForSegmentAvailability(TaskToolbox toolbox, ExecutorService exec, List<DataSegment> segmentsToWaitFor, long waitTimeout)\n+  {\n+    if (segmentsToWaitFor.isEmpty()) {\n+      log.info(\"Asked to wait for segments to be available, but I wasn't provided with any segments!?\");\n+      return false;\n+    }\n+    log.info(\"Waiting for segments to be loaded by the cluster...\");\n+\n+    SegmentHandoffNotifier notifier = toolbox.getSegmentHandoffNotifierFactory()\n+                                             .createSegmentHandoffNotifier(segmentsToWaitFor.get(0).getDataSource());\n+\n+    notifier.start();\n+    for (DataSegment s : segmentsToWaitFor) {\n+      notifier.registerSegmentHandoffCallback(\n+          new SegmentDescriptor(s.getInterval(), s.getVersion(), s.getShardSpec().getPartitionNum()),\n+          exec,\n+          () -> {\n+            log.info(\n+                \"Confirmed availability for [%s]. Removing from list of segments to wait for\",\n+                s.getId()\n+            );\n+            synchronized (availabilityCondition) {\n+              segmentsToWaitFor.remove(s);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0170dcaa6b81ff72b117c84faeb9a755006544d3"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNTQ3MDM3", "url": "https://github.com/apache/druid/pull/10676#pullrequestreview-553547037", "createdAt": "2020-12-16T10:24:58Z", "commit": {"oid": "0170dcaa6b81ff72b117c84faeb9a755006544d3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDoyNDo1OFrOIG-O5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDoyNDo1OFrOIG-O5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE4MTk5MA==", "bodyText": "Nit: Since the runnable is a simple call without blocking or computation, we could just pass Execs.directExecutor here.", "url": "https://github.com/apache/druid/pull/10676#discussion_r544181990", "createdAt": "2020-12-16T10:24:58Z", "author": {"login": "abhishekagarwal87"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/AbstractBatchIndexTask.java", "diffHunk": "@@ -576,6 +582,73 @@ static Granularity findGranularityFromSegments(List<DataSegment> segments)\n     }\n   }\n \n+  /**\n+   * Wait for segments to become available on the cluster. If waitTimeout is reached, giveup on waiting. This is a\n+   * QoS method that can be used to make Batch Ingest tasks wait to finish until their ingested data is available on\n+   * the cluster. Doing so gives an end user assurance that a Successful task status means their data is available\n+   * for querying.\n+   *\n+   * @param toolbox {@link TaskToolbox} object with for assisting with task work.\n+   * @param segmentsToWaitFor {@link List} of segments to wait for availability.\n+   * @param waitTimeout Millis to wait before giving up\n+   * @return True if all segments became available, otherwise False.\n+   */\n+  protected boolean waitForSegmentAvailability(TaskToolbox toolbox, ExecutorService exec, List<DataSegment> segmentsToWaitFor, long waitTimeout)\n+  {\n+    if (segmentsToWaitFor.isEmpty()) {\n+      log.info(\"Asked to wait for segments to be available, but I wasn't provided with any segments!?\");\n+      return false;\n+    }\n+    log.info(\"Waiting for segments to be loaded by the cluster...\");\n+\n+    SegmentHandoffNotifier notifier = toolbox.getSegmentHandoffNotifierFactory()\n+                                             .createSegmentHandoffNotifier(segmentsToWaitFor.get(0).getDataSource());\n+\n+    notifier.start();\n+    for (DataSegment s : segmentsToWaitFor) {\n+      notifier.registerSegmentHandoffCallback(\n+          new SegmentDescriptor(s.getInterval(), s.getVersion(), s.getShardSpec().getPartitionNum()),\n+          exec,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0170dcaa6b81ff72b117c84faeb9a755006544d3"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "237325f909f79c3dbb51f03b1d7c841cb20fe062", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/237325f909f79c3dbb51f03b1d7c841cb20fe062", "committedDate": "2020-12-17T16:32:46Z", "message": "fix bad indentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "848805ebbf31ac6c1d6e4d85ac4c7d0de2e5ed88", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/848805ebbf31ac6c1d6e4d85ac4c7d0de2e5ed88", "committedDate": "2020-12-17T18:00:25Z", "message": "refactor waitForSegmentAvailability"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8169c88acbef88f7cd9e4fb6d346ac60903512f9", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/8169c88acbef88f7cd9e4fb6d346ac60903512f9", "committedDate": "2020-12-28T21:27:52Z", "message": "Merge branch 'master' into batch-ingest-wait-for-handoff"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwODAwNzg0", "url": "https://github.com/apache/druid/pull/10676#pullrequestreview-560800784", "createdAt": "2021-01-04T06:26:13Z", "commit": {"oid": "8169c88acbef88f7cd9e4fb6d346ac60903512f9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwNjoyNjoxM1rOINmrKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwNjoyNjoxM1rOINmrKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTEzNjA0Mw==", "bodyText": "shouldn't this return true here? If there are no segments to confirm, the confirmation is done.", "url": "https://github.com/apache/druid/pull/10676#discussion_r551136043", "createdAt": "2021-01-04T06:26:13Z", "author": {"login": "abhishekagarwal87"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/AbstractBatchIndexTask.java", "diffHunk": "@@ -576,6 +584,64 @@ static Granularity findGranularityFromSegments(List<DataSegment> segments)\n     }\n   }\n \n+  /**\n+   * Wait for segments to become available on the cluster. If waitTimeout is reached, giveup on waiting. This is a\n+   * QoS method that can be used to make Batch Ingest tasks wait to finish until their ingested data is available on\n+   * the cluster. Doing so gives an end user assurance that a Successful task status means their data is available\n+   * for querying.\n+   *\n+   * @param toolbox {@link TaskToolbox} object with for assisting with task work.\n+   * @param segmentsToWaitFor {@link List} of segments to wait for availability.\n+   * @param waitTimeout Millis to wait before giving up\n+   * @return True if all segments became available, otherwise False.\n+   */\n+  protected boolean waitForSegmentAvailability(\n+      TaskToolbox toolbox,\n+      List<DataSegment> segmentsToWaitFor,\n+      long waitTimeout\n+  )\n+  {\n+    if (segmentsToWaitFor.isEmpty()) {\n+      log.warn(\"Asked to wait for segments to be available, but I wasn't provided with any segments!?\");\n+      return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8169c88acbef88f7cd9e4fb6d346ac60903512f9"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxNDUzNTc1", "url": "https://github.com/apache/druid/pull/10676#pullrequestreview-561453575", "createdAt": "2021-01-05T01:11:37Z", "commit": {"oid": "8169c88acbef88f7cd9e4fb6d346ac60903512f9"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQwMToxMTozOFrOIOGsHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQwMToyNTowN1rOIOG50Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY2MDU3Mg==", "bodyText": "Can you give some more details on how this will be used in your application? Do you want to track handoff failures of each task? I'm wondering if handoff time is also important.", "url": "https://github.com/apache/druid/pull/10676#discussion_r551660572", "createdAt": "2021-01-05T01:11:38Z", "author": {"login": "jihoonson"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/IngestionStatsAndErrorsTaskReportData.java", "diffHunk": "@@ -41,17 +41,22 @@\n   @Nullable\n   private String errorMsg;\n \n+  @JsonProperty\n+  private boolean segmentAvailabilityConfirmed;\n+\n   public IngestionStatsAndErrorsTaskReportData(\n       @JsonProperty(\"ingestionState\") IngestionState ingestionState,\n       @JsonProperty(\"unparseableEvents\") Map<String, Object> unparseableEvents,\n       @JsonProperty(\"rowStats\") Map<String, Object> rowStats,\n-      @JsonProperty(\"errorMsg\") @Nullable String errorMsg\n+      @JsonProperty(\"errorMsg\") @Nullable String errorMsg,\n+      @JsonProperty(\"segmentAvailabilityConfirmed\") boolean segmentAvailabilityConfirmed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8169c88acbef88f7cd9e4fb6d346ac60903512f9"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY2MjUyMg==", "bodyText": "Wondering if you can reuse StreamAppenderatorDriver.registerHandoff() or StreamAppenderatorDriver.publishAndRegisterHandoff() as they seem pretty similar to this new method. You would need to move that method out to BaseAppenderatorDriver.", "url": "https://github.com/apache/druid/pull/10676#discussion_r551662522", "createdAt": "2021-01-05T01:19:00Z", "author": {"login": "jihoonson"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/AbstractBatchIndexTask.java", "diffHunk": "@@ -576,6 +584,64 @@ static Granularity findGranularityFromSegments(List<DataSegment> segments)\n     }\n   }\n \n+  /**\n+   * Wait for segments to become available on the cluster. If waitTimeout is reached, giveup on waiting. This is a\n+   * QoS method that can be used to make Batch Ingest tasks wait to finish until their ingested data is available on\n+   * the cluster. Doing so gives an end user assurance that a Successful task status means their data is available\n+   * for querying.\n+   *\n+   * @param toolbox {@link TaskToolbox} object with for assisting with task work.\n+   * @param segmentsToWaitFor {@link List} of segments to wait for availability.\n+   * @param waitTimeout Millis to wait before giving up\n+   * @return True if all segments became available, otherwise False.\n+   */\n+  protected boolean waitForSegmentAvailability(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8169c88acbef88f7cd9e4fb6d346ac60903512f9"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY2MzU0OQ==", "bodyText": "Why is this always false? Does it make more sense to be always true because realtime tasks will fail when handoff fails?", "url": "https://github.com/apache/druid/pull/10676#discussion_r551663549", "createdAt": "2021-01-05T01:23:19Z", "author": {"login": "jihoonson"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/SeekableStreamIndexTaskRunner.java", "diffHunk": "@@ -1058,7 +1058,8 @@ private synchronized void persistSequences() throws IOException\n                 ingestionState,\n                 getTaskCompletionUnparseableEvents(),\n                 getTaskCompletionRowStats(),\n-                errorMsg\n+                errorMsg,\n+                false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8169c88acbef88f7cd9e4fb6d346ac60903512f9"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY2NDA4MQ==", "bodyText": "Testing with true would be better because missing booleans are defaulted to false by Jackson in Druid.", "url": "https://github.com/apache/druid/pull/10676#discussion_r551664081", "createdAt": "2021-01-05T01:25:07Z", "author": {"login": "jihoonson"}, "path": "indexing-service/src/test/java/org/apache/druid/indexing/common/task/TaskReportSerdeTest.java", "diffHunk": "@@ -55,7 +55,8 @@ public void testSerde() throws Exception\n             ImmutableMap.of(\n                 \"number\", 1234\n             ),\n-            \"an error message\"\n+            \"an error message\",\n+            false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8169c88acbef88f7cd9e4fb6d346ac60903512f9"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32fdff51d315f71fa44bcf5522a9dc823124593b", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/32fdff51d315f71fa44bcf5522a9dc823124593b", "committedDate": "2021-01-05T22:28:13Z", "message": "Fixes based off of review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4f2e09d90ce5b3c01ed309f5beedbf554eef261", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/b4f2e09d90ce5b3c01ed309f5beedbf554eef261", "committedDate": "2021-01-06T16:48:40Z", "message": "Merge branch 'master' into batch-ingest-wait-for-handoff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9295df14e44d970cd1e71c893e0e5572279db905", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/9295df14e44d970cd1e71c893e0e5572279db905", "committedDate": "2021-01-06T17:20:24Z", "message": "cleanup to get compile after merging with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abf7f99f6412975b83d7c83e171ef4cc35d54321", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/abf7f99f6412975b83d7c83e171ef4cc35d54321", "committedDate": "2021-01-06T17:25:38Z", "message": "fix failing test after previous logic update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2e9918d3ba2e9e388645de44bd7138866a14e52", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/d2e9918d3ba2e9e388645de44bd7138866a14e52", "committedDate": "2021-01-06T20:11:54Z", "message": "add back code that must have gotten deleted during conflict resolution"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92f3bec29adbe27c011f56a31017306e415a7cb1", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/92f3bec29adbe27c011f56a31017306e415a7cb1", "committedDate": "2021-01-11T20:17:37Z", "message": "Merge branch 'master' into batch-ingest-wait-for-handoff"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3NzE3NjMz", "url": "https://github.com/apache/druid/pull/10676#pullrequestreview-567717633", "createdAt": "2021-01-13T22:40:17Z", "commit": {"oid": "92f3bec29adbe27c011f56a31017306e415a7cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMjo0MDoxN1rOITH14A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMjo0MDoxN1rOITH14A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkyMjMzNg==", "bodyText": "I think this should be errorMsg == null. also add javadoc\n/**\n   * Return a map of reports for the task.\n   *\n   * A successfull task should always have a null errorMsg. A falied task should always have a non-null\n   * errorMsg. Nullable error message for the task. null if task succeeded.\n   *\n   * @return Map of reports for the task.\n   */", "url": "https://github.com/apache/druid/pull/10676#discussion_r556922336", "createdAt": "2021-01-13T22:40:17Z", "author": {"login": "capistrant"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/AppenderatorDriverRealtimeIndexTask.java", "diffHunk": "@@ -584,7 +584,8 @@ protected boolean isFirehoseDrainableByClosing(FirehoseFactory firehoseFactory)\n                 ingestionState,\n                 getTaskCompletionUnparseableEvents(),\n                 getTaskCompletionRowStats(),\n-                errorMsg\n+                errorMsg,\n+                false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92f3bec29adbe27c011f56a31017306e415a7cb1"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyNDcxMDEx", "url": "https://github.com/apache/druid/pull/10676#pullrequestreview-572471011", "createdAt": "2021-01-20T17:39:42Z", "commit": {"oid": "92f3bec29adbe27c011f56a31017306e415a7cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQxNzozOTo0MlrOIXKAfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQxNzozOTo0MlrOIXKAfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE1MjEyNQ==", "bodyText": "I think this needs an assert", "url": "https://github.com/apache/druid/pull/10676#discussion_r561152125", "createdAt": "2021-01-20T17:39:42Z", "author": {"login": "capistrant"}, "path": "indexing-service/src/test/java/org/apache/druid/indexing/common/task/TaskSerdeTest.java", "diffHunk": "@@ -268,7 +268,8 @@ public void testIndexTaskSerde() throws Exception\n                 null,\n                 null,\n                 null,\n-                null\n+                null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92f3bec29adbe27c011f56a31017306e415a7cb1"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2ODkwNzkw", "url": "https://github.com/apache/druid/pull/10676#pullrequestreview-576890790", "createdAt": "2021-01-27T00:54:47Z", "commit": {"oid": "92f3bec29adbe27c011f56a31017306e415a7cb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QwMDo1NDo0N1rOIaxViw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QwMDo1NDo0N1rOIaxViw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk0MjIxOQ==", "bodyText": "I think we should change the log level of some info logs to debug in this class which are printed per segment. It could be a lot in batch ingestion.", "url": "https://github.com/apache/druid/pull/10676#discussion_r564942219", "createdAt": "2021-01-27T00:54:47Z", "author": {"login": "jihoonson"}, "path": "server/src/main/java/org/apache/druid/segment/handoff/CoordinatorBasedSegmentHandoffNotifier.java", "diffHunk": "@@ -17,7 +17,7 @@\n  * under the License.\n  */\n \n-package org.apache.druid.segment.realtime.plumber;\n+package org.apache.druid.segment.handoff;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92f3bec29adbe27c011f56a31017306e415a7cb1"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "222d3c2bfa9257a7a6c765597cd87d5bfb3587e4", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/222d3c2bfa9257a7a6c765597cd87d5bfb3587e4", "committedDate": "2021-01-28T16:53:31Z", "message": "update some logging code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88df46c4e08bb448e8aa594910be3ed60fb64b9e", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/88df46c4e08bb448e8aa594910be3ed60fb64b9e", "committedDate": "2021-01-28T16:54:43Z", "message": "Merge branch 'master' into batch-ingest-wait-for-handoff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "452b649088340b757cc3656bd2c241da73c8fb60", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/452b649088340b757cc3656bd2c241da73c8fb60", "committedDate": "2021-01-28T17:49:32Z", "message": "fixes to get compilation working after merge with master"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NjkwODQ4", "url": "https://github.com/apache/druid/pull/10676#pullrequestreview-578690848", "createdAt": "2021-01-28T19:56:18Z", "commit": {"oid": "452b649088340b757cc3656bd2c241da73c8fb60"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQxOTo1NjoxOFrOIcIZ2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQyMDoxNzozNFrOIcJGPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjM2ODcyOQ==", "bodyText": "The interrupted state is cleared out after it's checked. We should set the state of the current thread back. Please add Thread.currentThread().interrupt().", "url": "https://github.com/apache/druid/pull/10676#discussion_r566368729", "createdAt": "2021-01-28T19:56:18Z", "author": {"login": "jihoonson"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/AbstractBatchIndexTask.java", "diffHunk": "@@ -580,6 +588,64 @@ static Granularity findGranularityFromSegments(List<DataSegment> segments)\n     }\n   }\n \n+  /**\n+   * Wait for segments to become available on the cluster. If waitTimeout is reached, giveup on waiting. This is a\n+   * QoS method that can be used to make Batch Ingest tasks wait to finish until their ingested data is available on\n+   * the cluster. Doing so gives an end user assurance that a Successful task status means their data is available\n+   * for querying.\n+   *\n+   * @param toolbox {@link TaskToolbox} object with for assisting with task work.\n+   * @param segmentsToWaitFor {@link List} of segments to wait for availability.\n+   * @param waitTimeout Millis to wait before giving up\n+   * @return True if all segments became available, otherwise False.\n+   */\n+  protected boolean waitForSegmentAvailability(\n+      TaskToolbox toolbox,\n+      List<DataSegment> segmentsToWaitFor,\n+      long waitTimeout\n+  )\n+  {\n+    if (segmentsToWaitFor.isEmpty()) {\n+      log.info(\"Asked to wait for segments to be available, but I wasn't provided with any segments!?\");\n+      return true;\n+    } else if (waitTimeout <= 0) {\n+      log.warn(\"Asked to wait for availability for <= 0 seconds?! Requested waitTimeout: [%s]\", waitTimeout);\n+      return false;\n+    }\n+    log.info(\"Waiting for [%d] segments to be loaded by the cluster...\", segmentsToWaitFor.size());\n+\n+    SegmentHandoffNotifier notifier = toolbox.getSegmentHandoffNotifierFactory()\n+                                             .createSegmentHandoffNotifier(segmentsToWaitFor.get(0).getDataSource());\n+    ExecutorService exec = Execs.directExecutor();\n+    CountDownLatch doneSignal = new CountDownLatch(segmentsToWaitFor.size());\n+\n+    notifier.start();\n+    for (DataSegment s : segmentsToWaitFor) {\n+      notifier.registerSegmentHandoffCallback(\n+          new SegmentDescriptor(s.getInterval(), s.getVersion(), s.getShardSpec().getPartitionNum()),\n+          exec,\n+          () -> {\n+            log.debug(\n+                \"Confirmed availability for [%s]. Removing from list of segments to wait for\",\n+                s.getId()\n+            );\n+            doneSignal.countDown();\n+          }\n+      );\n+    }\n+\n+    try {\n+      return doneSignal.await(waitTimeout, TimeUnit.MILLISECONDS);\n+    }\n+    catch (InterruptedException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452b649088340b757cc3656bd2c241da73c8fb60"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjM3MDg0Mg==", "bodyText": "Yeah, I think you are right.", "url": "https://github.com/apache/druid/pull/10676#discussion_r566370842", "createdAt": "2021-01-28T20:00:01Z", "author": {"login": "jihoonson"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/AbstractBatchIndexTask.java", "diffHunk": "@@ -576,6 +584,64 @@ static Granularity findGranularityFromSegments(List<DataSegment> segments)\n     }\n   }\n \n+  /**\n+   * Wait for segments to become available on the cluster. If waitTimeout is reached, giveup on waiting. This is a\n+   * QoS method that can be used to make Batch Ingest tasks wait to finish until their ingested data is available on\n+   * the cluster. Doing so gives an end user assurance that a Successful task status means their data is available\n+   * for querying.\n+   *\n+   * @param toolbox {@link TaskToolbox} object with for assisting with task work.\n+   * @param segmentsToWaitFor {@link List} of segments to wait for availability.\n+   * @param waitTimeout Millis to wait before giving up\n+   * @return True if all segments became available, otherwise False.\n+   */\n+  protected boolean waitForSegmentAvailability(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY2MjUyMg=="}, "originalCommit": {"oid": "8169c88acbef88f7cd9e4fb6d346ac60903512f9"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjM4MDA5NQ==", "bodyText": "For us a simple yes/no will suffice. The cluster operators would have the goal of having 100% of jobs successfully handoff data before the timeout, but when that doesn't happen our users simply want to know that they may need to wait longer. We are simply trying to be transparent and report the point in time status. The onus of finding out when the data is fully loaded if this timeout expired before loading, would fall on a different solution (TBD).\n\nCool, are you working on \"the different solution\"? That would be interesting too.\n\nWhy the handoff failed would be something I as an operator am more interested compared to a user (unless that user is also an operator). I think that would be very difficult to communicate in these reports since the indexing task doesn't know much about what the rest of the cluster is doing.\n\nI agree. I think we need more visibility on the coordinator behavior.\n\nKnowing how long it took before the time out could be found in the spec, but I guess it could be useful to add that value to the report as well if you think users would want to have quick reference. I think that rather than having that static value, it could be cool to have the dynamic time waited for handoff. Maybe it is the static value because we hit the timeout. but as an operator I would enjoy seeing how long each successful job waited for handoff. what do you think about that?\n\nThat seems useful to me too \ud83d\udc4d\nFor the time to fail handoff, due to the above issue of the lack of ability to know the cause of handoff failures, I guess I was wondering if the report can be a false alarm. For example, the report can say it failed to confirm the segments handed off, but maybe the handoff could be even not triggered at all for some reason. I don't think this can happen for now, but is possible in the future if someone else modifies this area for some good reason. segmentAvailabilityConfirmationCompleted + time to fail handoff can be an indicator of such unexpected failures. I would say this is not a blocker for this PR, but it seems useful to me.", "url": "https://github.com/apache/druid/pull/10676#discussion_r566380095", "createdAt": "2021-01-28T20:17:34Z", "author": {"login": "jihoonson"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/IngestionStatsAndErrorsTaskReportData.java", "diffHunk": "@@ -41,17 +41,22 @@\n   @Nullable\n   private String errorMsg;\n \n+  @JsonProperty\n+  private boolean segmentAvailabilityConfirmed;\n+\n   public IngestionStatsAndErrorsTaskReportData(\n       @JsonProperty(\"ingestionState\") IngestionState ingestionState,\n       @JsonProperty(\"unparseableEvents\") Map<String, Object> unparseableEvents,\n       @JsonProperty(\"rowStats\") Map<String, Object> rowStats,\n-      @JsonProperty(\"errorMsg\") @Nullable String errorMsg\n+      @JsonProperty(\"errorMsg\") @Nullable String errorMsg,\n+      @JsonProperty(\"segmentAvailabilityConfirmed\") boolean segmentAvailabilityConfirmed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY2MDU3Mg=="}, "originalCommit": {"oid": "8169c88acbef88f7cd9e4fb6d346ac60903512f9"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "376cfa097cea19a86141b3dc63ce091d80c156f5", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/376cfa097cea19a86141b3dc63ce091d80c156f5", "committedDate": "2021-01-28T20:45:34Z", "message": "reset interrupt flag in catch block after code review pointed it out"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c63611a33fe7114014432830b0d69227340c6ad6", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/c63611a33fe7114014432830b0d69227340c6ad6", "committedDate": "2021-01-28T20:51:36Z", "message": "small changes following self-review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NzU4NjIy", "url": "https://github.com/apache/druid/pull/10676#pullrequestreview-578758622", "createdAt": "2021-01-28T21:33:16Z", "commit": {"oid": "c63611a33fe7114014432830b0d69227340c6ad6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1772199f6b001eccffc3034314c77623843ae4d2", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/1772199f6b001eccffc3034314c77623843ae4d2", "committedDate": "2021-02-10T15:32:36Z", "message": "Merge branch 'master' into batch-ingest-wait-for-handoff"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAwNDgxNjYx", "url": "https://github.com/apache/druid/pull/10676#pullrequestreview-600481661", "createdAt": "2021-03-01T08:25:01Z", "commit": {"oid": "1772199f6b001eccffc3034314c77623843ae4d2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16274c3f35ead6f147a0fde334570a72dbedbd22", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/16274c3f35ead6f147a0fde334570a72dbedbd22", "committedDate": "2021-03-17T14:50:20Z", "message": "Merge branch 'master' into batch-ingest-wait-for-handoff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "503bdb448c52c7e94efb136162ee907e3f90a13f", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/503bdb448c52c7e94efb136162ee907e3f90a13f", "committedDate": "2021-03-17T20:06:26Z", "message": "fixup some issues brought on by merge with master"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIxNTU3MTAy", "url": "https://github.com/apache/druid/pull/10676#pullrequestreview-621557102", "createdAt": "2021-03-25T20:37:15Z", "commit": {"oid": "503bdb448c52c7e94efb136162ee907e3f90a13f"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNVQyMDozNzoxNlrOI98UbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNVQyMToyMTowNVrOI993Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTgyMjMxNw==", "bodyText": "nit: This is a long elsewhere. I don't think this matters though.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              int DEFAULT_AWAIT_SEGMENT_AVAILABILITY_TIMEOUT_MILLIS = 0;\n          \n          \n            \n              long DEFAULT_AWAIT_SEGMENT_AVAILABILITY_TIMEOUT_MILLIS = 0;", "url": "https://github.com/apache/druid/pull/10676#discussion_r601822317", "createdAt": "2021-03-25T20:37:16Z", "author": {"login": "suneet-s"}, "path": "server/src/main/java/org/apache/druid/segment/indexing/TuningConfig.java", "diffHunk": "@@ -40,6 +40,7 @@\n   int DEFAULT_MAX_SAVED_PARSE_EXCEPTIONS = 0;\n   int DEFAULT_MAX_ROWS_IN_MEMORY = 1_000_000;\n   boolean DEFAULT_SKIP_BYTES_IN_MEMORY_OVERHEAD_CHECK = false;\n+  int DEFAULT_AWAIT_SEGMENT_AVAILABILITY_TIMEOUT_MILLIS = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "503bdb448c52c7e94efb136162ee907e3f90a13f"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTgyNDg0MA==", "bodyText": "nit: did you mean to add this twice?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            awaitSegmentAvailabilityTimeoutMillis", "url": "https://github.com/apache/druid/pull/10676#discussion_r601824840", "createdAt": "2021-03-25T20:41:34Z", "author": {"login": "suneet-s"}, "path": "website/.spelling", "diffHunk": "@@ -970,6 +970,7 @@ InputSplit\n JobHistory\n a.example.com\n assumeGrouped\n+awaitSegmentAvailabilityTimeoutMillis", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "503bdb448c52c7e94efb136162ee907e3f90a13f"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTgyOTkzMg==", "bodyText": "Naive question: Should this be\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  @JsonProperty(\"segmentAvailabilityConfirmed\") boolean segmentAvailabilityConfirmed\n          \n          \n            \n                  @JsonProperty(\"segmentAvailabilityConfirmed\") @Nullable Boolean segmentAvailabilityConfirmed\n          \n      \n    \n    \n  \n\nSeeing the json properties automatically make me think about version mismatches - but I don't exactly know how this is used - so I'm just asking in the hope you can save me some time from digging :)", "url": "https://github.com/apache/druid/pull/10676#discussion_r601829932", "createdAt": "2021-03-25T20:49:38Z", "author": {"login": "suneet-s"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/IngestionStatsAndErrorsTaskReportData.java", "diffHunk": "@@ -41,17 +41,22 @@\n   @Nullable\n   private String errorMsg;\n \n+  @JsonProperty\n+  private boolean segmentAvailabilityConfirmed;\n+\n   public IngestionStatsAndErrorsTaskReportData(\n       @JsonProperty(\"ingestionState\") IngestionState ingestionState,\n       @JsonProperty(\"unparseableEvents\") Map<String, Object> unparseableEvents,\n       @JsonProperty(\"rowStats\") Map<String, Object> rowStats,\n-      @JsonProperty(\"errorMsg\") @Nullable String errorMsg\n+      @JsonProperty(\"errorMsg\") @Nullable String errorMsg,\n+      @JsonProperty(\"segmentAvailabilityConfirmed\") boolean segmentAvailabilityConfirmed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "503bdb448c52c7e94efb136162ee907e3f90a13f"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTgzMTk1NQ==", "bodyText": "This shouldn't be a warn message since the default is 0. Maybe you want a less than check, which should technically never happen, since there is a check in the constructor.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                } else if (waitTimeout <= 0) {\n          \n          \n            \n                } else if (waitTimeout < 0) {", "url": "https://github.com/apache/druid/pull/10676#discussion_r601831955", "createdAt": "2021-03-25T20:53:14Z", "author": {"login": "suneet-s"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/AbstractBatchIndexTask.java", "diffHunk": "@@ -566,6 +574,65 @@ static Granularity findGranularityFromSegments(List<DataSegment> segments)\n     }\n   }\n \n+  /**\n+   * Wait for segments to become available on the cluster. If waitTimeout is reached, giveup on waiting. This is a\n+   * QoS method that can be used to make Batch Ingest tasks wait to finish until their ingested data is available on\n+   * the cluster. Doing so gives an end user assurance that a Successful task status means their data is available\n+   * for querying.\n+   *\n+   * @param toolbox {@link TaskToolbox} object with for assisting with task work.\n+   * @param segmentsToWaitFor {@link List} of segments to wait for availability.\n+   * @param waitTimeout Millis to wait before giving up\n+   * @return True if all segments became available, otherwise False.\n+   */\n+  protected boolean waitForSegmentAvailability(\n+      TaskToolbox toolbox,\n+      List<DataSegment> segmentsToWaitFor,\n+      long waitTimeout\n+  )\n+  {\n+    if (segmentsToWaitFor.isEmpty()) {\n+      log.info(\"Asked to wait for segments to be available, but I wasn't provided with any segments!?\");\n+      return true;\n+    } else if (waitTimeout <= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "503bdb448c52c7e94efb136162ee907e3f90a13f"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTgzMzMwNg==", "bodyText": "nit: The question mark in this message makes it seem like this is an un-expected state. Should this be logged at a warn level instead?\nHonestly, if I didn't read the question mark at the end, I would have thought this is a reasonable info level message.", "url": "https://github.com/apache/druid/pull/10676#discussion_r601833306", "createdAt": "2021-03-25T20:55:34Z", "author": {"login": "suneet-s"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/AbstractBatchIndexTask.java", "diffHunk": "@@ -566,6 +574,65 @@ static Granularity findGranularityFromSegments(List<DataSegment> segments)\n     }\n   }\n \n+  /**\n+   * Wait for segments to become available on the cluster. If waitTimeout is reached, giveup on waiting. This is a\n+   * QoS method that can be used to make Batch Ingest tasks wait to finish until their ingested data is available on\n+   * the cluster. Doing so gives an end user assurance that a Successful task status means their data is available\n+   * for querying.\n+   *\n+   * @param toolbox {@link TaskToolbox} object with for assisting with task work.\n+   * @param segmentsToWaitFor {@link List} of segments to wait for availability.\n+   * @param waitTimeout Millis to wait before giving up\n+   * @return True if all segments became available, otherwise False.\n+   */\n+  protected boolean waitForSegmentAvailability(\n+      TaskToolbox toolbox,\n+      List<DataSegment> segmentsToWaitFor,\n+      long waitTimeout\n+  )\n+  {\n+    if (segmentsToWaitFor.isEmpty()) {\n+      log.info(\"Asked to wait for segments to be available, but I wasn't provided with any segments!?\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "503bdb448c52c7e94efb136162ee907e3f90a13f"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTgzNzU0NA==", "bodyText": "Instead of catching this in the finally block, I think a try-with-resource pattern would be safer. I don't think anything can fail in the for loop where we're registering callbacks, but if it does - the SegmentHandoffNotifier won't clean up after itself\ntry (SegmentHandoffNotifier notifier = toolbox.getSegmentHandoffNotifierFactory().createSegmentHandoffNotifier(segmentsToWaitFor.get(0).getDataSource())) {\n    // register handoffs and wait for signal\n}", "url": "https://github.com/apache/druid/pull/10676#discussion_r601837544", "createdAt": "2021-03-25T21:02:44Z", "author": {"login": "suneet-s"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/AbstractBatchIndexTask.java", "diffHunk": "@@ -566,6 +574,65 @@ static Granularity findGranularityFromSegments(List<DataSegment> segments)\n     }\n   }\n \n+  /**\n+   * Wait for segments to become available on the cluster. If waitTimeout is reached, giveup on waiting. This is a\n+   * QoS method that can be used to make Batch Ingest tasks wait to finish until their ingested data is available on\n+   * the cluster. Doing so gives an end user assurance that a Successful task status means their data is available\n+   * for querying.\n+   *\n+   * @param toolbox {@link TaskToolbox} object with for assisting with task work.\n+   * @param segmentsToWaitFor {@link List} of segments to wait for availability.\n+   * @param waitTimeout Millis to wait before giving up\n+   * @return True if all segments became available, otherwise False.\n+   */\n+  protected boolean waitForSegmentAvailability(\n+      TaskToolbox toolbox,\n+      List<DataSegment> segmentsToWaitFor,\n+      long waitTimeout\n+  )\n+  {\n+    if (segmentsToWaitFor.isEmpty()) {\n+      log.info(\"Asked to wait for segments to be available, but I wasn't provided with any segments!?\");\n+      return true;\n+    } else if (waitTimeout <= 0) {\n+      log.warn(\"Asked to wait for availability for <= 0 seconds?! Requested waitTimeout: [%s]\", waitTimeout);\n+      return false;\n+    }\n+    log.info(\"Waiting for [%d] segments to be loaded by the cluster...\", segmentsToWaitFor.size());\n+\n+    SegmentHandoffNotifier notifier = toolbox.getSegmentHandoffNotifierFactory()\n+                                             .createSegmentHandoffNotifier(segmentsToWaitFor.get(0).getDataSource());\n+    ExecutorService exec = Execs.directExecutor();\n+    CountDownLatch doneSignal = new CountDownLatch(segmentsToWaitFor.size());\n+\n+    notifier.start();\n+    for (DataSegment s : segmentsToWaitFor) {\n+      notifier.registerSegmentHandoffCallback(\n+          new SegmentDescriptor(s.getInterval(), s.getVersion(), s.getShardSpec().getPartitionNum()),\n+          exec,\n+          () -> {\n+            log.debug(\n+                \"Confirmed availability for [%s]. Removing from list of segments to wait for\",\n+                s.getId()\n+            );\n+            doneSignal.countDown();\n+          }\n+      );\n+    }\n+\n+    try {\n+      return doneSignal.await(waitTimeout, TimeUnit.MILLISECONDS);\n+    }\n+    catch (InterruptedException e) {\n+      log.warn(\"Interrupted while waiting for segment availablity; Unable to confirm availability!\");\n+      Thread.currentThread().interrupt();\n+      return false;\n+    }\n+    finally {\n+      notifier.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "503bdb448c52c7e94efb136162ee907e3f90a13f"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTgzOTM5NQ==", "bodyText": "Another naive question: Is it possible for the segments to be handed off before the callback was registered?\nI haven't dug deep into this part of Druid yet, so I'm just if it's something you've considered", "url": "https://github.com/apache/druid/pull/10676#discussion_r601839395", "createdAt": "2021-03-25T21:06:08Z", "author": {"login": "suneet-s"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/AbstractBatchIndexTask.java", "diffHunk": "@@ -566,6 +574,65 @@ static Granularity findGranularityFromSegments(List<DataSegment> segments)\n     }\n   }\n \n+  /**\n+   * Wait for segments to become available on the cluster. If waitTimeout is reached, giveup on waiting. This is a\n+   * QoS method that can be used to make Batch Ingest tasks wait to finish until their ingested data is available on\n+   * the cluster. Doing so gives an end user assurance that a Successful task status means their data is available\n+   * for querying.\n+   *\n+   * @param toolbox {@link TaskToolbox} object with for assisting with task work.\n+   * @param segmentsToWaitFor {@link List} of segments to wait for availability.\n+   * @param waitTimeout Millis to wait before giving up\n+   * @return True if all segments became available, otherwise False.\n+   */\n+  protected boolean waitForSegmentAvailability(\n+      TaskToolbox toolbox,\n+      List<DataSegment> segmentsToWaitFor,\n+      long waitTimeout\n+  )\n+  {\n+    if (segmentsToWaitFor.isEmpty()) {\n+      log.info(\"Asked to wait for segments to be available, but I wasn't provided with any segments!?\");\n+      return true;\n+    } else if (waitTimeout <= 0) {\n+      log.warn(\"Asked to wait for availability for <= 0 seconds?! Requested waitTimeout: [%s]\", waitTimeout);\n+      return false;\n+    }\n+    log.info(\"Waiting for [%d] segments to be loaded by the cluster...\", segmentsToWaitFor.size());\n+\n+    SegmentHandoffNotifier notifier = toolbox.getSegmentHandoffNotifierFactory()\n+                                             .createSegmentHandoffNotifier(segmentsToWaitFor.get(0).getDataSource());\n+    ExecutorService exec = Execs.directExecutor();\n+    CountDownLatch doneSignal = new CountDownLatch(segmentsToWaitFor.size());\n+\n+    notifier.start();\n+    for (DataSegment s : segmentsToWaitFor) {\n+      notifier.registerSegmentHandoffCallback(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "503bdb448c52c7e94efb136162ee907e3f90a13f"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg0MzE5NA==", "bodyText": "I think we should add a comment here that says something to the effect of \"For streaming ingestion, segments are considered to be available immediately if the task is successful. If the task failed, the segments are not available\"\nAt least that's what I think this is trying to say.", "url": "https://github.com/apache/druid/pull/10676#discussion_r601843194", "createdAt": "2021-03-25T21:13:02Z", "author": {"login": "suneet-s"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/SeekableStreamIndexTaskRunner.java", "diffHunk": "@@ -1066,7 +1075,8 @@ private synchronized void persistSequences() throws IOException\n                 ingestionState,\n                 getTaskCompletionUnparseableEvents(),\n                 getTaskCompletionRowStats(),\n-                errorMsg\n+                errorMsg,\n+                errorMsg == null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "503bdb448c52c7e94efb136162ee907e3f90a13f"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg0NDQ3MA==", "bodyText": "Do we need a CompactionTaskTest where awaitSegmentAvailabilityTimeoutMillis is non null", "url": "https://github.com/apache/druid/pull/10676#discussion_r601844470", "createdAt": "2021-03-25T21:15:24Z", "author": {"login": "suneet-s"}, "path": "indexing-service/src/test/java/org/apache/druid/indexing/common/task/CompactionTaskTest.java", "diffHunk": "@@ -1447,6 +1452,7 @@ private void assertIngestionSchema(\n             null,\n             null,\n             null,\n+            null,\n             null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "503bdb448c52c7e94efb136162ee907e3f90a13f"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg0NDk2NA==", "bodyText": "Do we need an IndexTaskSerdeTest where awaitSegmentAvailabilityTimeoutMillis is not null", "url": "https://github.com/apache/druid/pull/10676#discussion_r601844964", "createdAt": "2021-03-25T21:16:20Z", "author": {"login": "suneet-s"}, "path": "indexing-service/src/test/java/org/apache/druid/indexing/common/task/IndexTaskSerdeTest.java", "diffHunk": "@@ -267,6 +272,7 @@ public void testBestEffortRollupWithHashedPartitionsSpec()\n         true,\n         10,\n         100,\n+        null,\n         null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "503bdb448c52c7e94efb136162ee907e3f90a13f"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg0NzYyNg==", "bodyText": "Is it worth testing what happens when this is non zero?\nDo we also want to check that the IngestionStatsAndErrorsTaskReportData reports segmentAvailabilityConfirmed as false now?", "url": "https://github.com/apache/druid/pull/10676#discussion_r601847626", "createdAt": "2021-03-25T21:21:05Z", "author": {"login": "suneet-s"}, "path": "integration-tests/src/test/java/org/apache/druid/tests/coordinator/duty/ITAutoCompactionTest.java", "diffHunk": "@@ -376,6 +376,11 @@ private void loadData(String indexTask) throws Exception\n   {\n     String taskSpec = getResourceAsString(indexTask);\n     taskSpec = StringUtils.replace(taskSpec, \"%%DATASOURCE%%\", fullDatasourceName);\n+    taskSpec = StringUtils.replace(\n+        taskSpec,\n+        \"%%SEGMENT_AVAIL_TIMEOUT_MILLIS%%\",\n+        jsonMapper.writeValueAsString(\"0\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "503bdb448c52c7e94efb136162ee907e3f90a13f"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fa4f410cedb5a413d03ebb84bf6a618043bed0b", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/0fa4f410cedb5a413d03ebb84bf6a618043bed0b", "committedDate": "2021-03-25T22:54:07Z", "message": "small changes after review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "367483667d91159c21f7777848ff176f559d0046", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/367483667d91159c21f7777848ff176f559d0046", "committedDate": "2021-03-25T23:09:47Z", "message": "Merge branch 'master' into batch-ingest-wait-for-handoff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c3a49968413fa433d68b60cab25bf61435dd809", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/8c3a49968413fa433d68b60cab25bf61435dd809", "committedDate": "2021-03-25T23:10:43Z", "message": "cleanup a little bit after merge with master"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIzNTEyNzg4", "url": "https://github.com/apache/druid/pull/10676#pullrequestreview-623512788", "createdAt": "2021-03-29T18:11:52Z", "commit": {"oid": "8c3a49968413fa433d68b60cab25bf61435dd809"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOVQxODoxMTo1M1rOI_jNmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOVQxODoxMTo1M1rOI_jNmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzUwODEyMw==", "bodyText": "Do we want to remove the retry loop in here https://github.com/apache/druid/pull/10676/files#diff-6dbfd938d89c6c209d36efc181277afa535629677dfe6b5a1710190c2f9d8ee3L308-L311\nif IngestionStatsAndErrorsTaskReport say that the segment Availability was confirmed. If it isn't true on the first attempt, that means the task report was wrong - am I understanding this correctly?", "url": "https://github.com/apache/druid/pull/10676#discussion_r603508123", "createdAt": "2021-03-29T18:11:53Z", "author": {"login": "suneet-s"}, "path": "integration-tests/src/test/java/org/apache/druid/tests/indexer/AbstractITBatchIndexTest.java", "diffHunk": "@@ -280,6 +334,18 @@ private void submitTaskAndWait(\n       );\n     }\n \n+    if (segmentAvailabilityConfirmationPair.lhs != null && segmentAvailabilityConfirmationPair.lhs) {\n+      TaskReport reportRaw = indexer.getTaskReport(taskID).get(\"ingestionStatsAndErrors\");\n+      IngestionStatsAndErrorsTaskReport report = (IngestionStatsAndErrorsTaskReport) reportRaw;\n+      IngestionStatsAndErrorsTaskReportData reportData = (IngestionStatsAndErrorsTaskReportData) report.getPayload();\n+      if (segmentAvailabilityConfirmationPair.rhs != null) {\n+        Assert.assertEquals(\n+            Boolean.valueOf(reportData.isSegmentAvailabilityConfirmed()),\n+            segmentAvailabilityConfirmationPair.rhs\n+        );\n+      }\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c3a49968413fa433d68b60cab25bf61435dd809"}, "originalPosition": 175}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIzNTE1Mjg4", "url": "https://github.com/apache/druid/pull/10676#pullrequestreview-623515288", "createdAt": "2021-03-29T18:15:01Z", "commit": {"oid": "8c3a49968413fa433d68b60cab25bf61435dd809"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOVQxODoxNTowMlrOI_jU5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOVQxODoxNTowMlrOI_jU5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzUwOTk4OA==", "bodyText": "Some comments on this pattern since I've seen it across a few tests\n\nDoes this change mean we lose coverage on a missing SEGMENT_AVAIL_TIMEOUT_MILLIS? Since this is the default mode, it would be good to have coverage for that missing change\nDo we have / want tests where this is set to a high enough number that we don't need a re-try loop in the integration tests while waiting for the segments to be available", "url": "https://github.com/apache/druid/pull/10676#discussion_r603509988", "createdAt": "2021-03-29T18:15:02Z", "author": {"login": "suneet-s"}, "path": "integration-tests/src/test/java/org/apache/druid/tests/indexer/ITCombiningFirehoseFactoryIndexTest.java", "diffHunk": "@@ -59,13 +61,28 @@ public void testIndexData() throws Exception\n           throw new RuntimeException(e);\n         }\n       };\n+      final Function<String, String> transform = spec -> {\n+        try {\n+          return StringUtils.replace(\n+              spec,\n+              \"%%SEGMENT_AVAIL_TIMEOUT_MILLIS%%\",\n+              jsonMapper.writeValueAsString(\"0\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c3a49968413fa433d68b60cab25bf61435dd809"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIzNTE2MTA5", "url": "https://github.com/apache/druid/pull/10676#pullrequestreview-623516109", "createdAt": "2021-03-29T18:16:02Z", "commit": {"oid": "8c3a49968413fa433d68b60cab25bf61435dd809"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6c91680a7fd4b751754e302862d3ad6eb57e1f5", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/f6c91680a7fd4b751754e302862d3ad6eb57e1f5", "committedDate": "2021-03-30T18:17:17Z", "message": "Fix potential resource leak in AbstractBatchIndexTask"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edc26dddaa0ac2bebd3580041136673c1cca7724", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/edc26dddaa0ac2bebd3580041136673c1cca7724", "committedDate": "2021-03-30T18:55:33Z", "message": "syntax fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b25321dd2f5eb0f92d3fbb379a57abbc8792f30", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/7b25321dd2f5eb0f92d3fbb379a57abbc8792f30", "committedDate": "2021-03-31T17:23:15Z", "message": "Add a Compcation TuningConfig type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9498cb07ba6c83a1a36f57580d42c337dd7fc75f", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/9498cb07ba6c83a1a36f57580d42c337dd7fc75f", "committedDate": "2021-03-31T21:04:33Z", "message": "add docs stipulating the lack of support by Compaction tasks for the new config"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI4NDQ4MjU0", "url": "https://github.com/apache/druid/pull/10676#pullrequestreview-628448254", "createdAt": "2021-04-06T01:55:29Z", "commit": {"oid": "7b25321dd2f5eb0f92d3fbb379a57abbc8792f30"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wNlQwMTo1NToyOVrOJDS3ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wNlQwMTo1NToyOVrOJDS3ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNzQzNDY1NA==", "bodyText": "I think this change means that compaction jobs that are submitted with a ParallelIndexTuningConfig (using type = index_parallel) will start failing after this change - is this correct?\nIf so, I think instead of introducing this as a breaking change, we can just add the Precondition check that you have in the CompactionTuningConfig  into the constructor for the compaction task.\nIf this isn't a breaking change, I like that there's a separate tuningConfig for compaction tasks, so that in the future, this config can be more easily optimized.\ncc @maytasm Since I've seen you make some improvements around compaction recently", "url": "https://github.com/apache/druid/pull/10676#discussion_r607434654", "createdAt": "2021-04-06T01:55:29Z", "author": {"login": "suneet-s"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/CompactionTask.java", "diffHunk": "@@ -146,7 +151,7 @@\n   @Nullable\n   private final ClientCompactionTaskGranularitySpec granularitySpec;\n   @Nullable\n-  private final ParallelIndexTuningConfig tuningConfig;\n+  private final CompactionTuningConfig tuningConfig;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b25321dd2f5eb0f92d3fbb379a57abbc8792f30"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI4NDU0OTIz", "url": "https://github.com/apache/druid/pull/10676#pullrequestreview-628454923", "createdAt": "2021-04-06T01:59:14Z", "commit": {"oid": "9498cb07ba6c83a1a36f57580d42c337dd7fc75f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d39dfa3869377d36cb1946424b65bef17eeb8182", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/d39dfa3869377d36cb1946424b65bef17eeb8182", "committedDate": "2021-04-06T20:21:06Z", "message": "Merge branch 'master' into batch-ingest-wait-for-handoff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "747ee337f27efb2f36cad1c2bbe3058646e826b3", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/747ee337f27efb2f36cad1c2bbe3058646e826b3", "committedDate": "2021-04-06T20:41:10Z", "message": "Fixup compilation errors after merge with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "381cdfe8d6404eedbc1df01f58235d7f4a9bf515", "author": {"user": {"login": "capistrant", "name": "Lucas Capistrant"}}, "url": "https://github.com/apache/druid/commit/381cdfe8d6404eedbc1df01f58235d7f4a9bf515", "committedDate": "2021-04-07T01:17:56Z", "message": "Remove erreneous newline"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3167, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}