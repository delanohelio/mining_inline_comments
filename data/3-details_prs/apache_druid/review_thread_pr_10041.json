{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM1Nzg3OTI2", "number": 10041, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDo0NzowNlrOEGgwXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjoyNDowMVrOEG7nSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjYzNTgzOnYy", "diffSide": "RIGHT", "path": "sql/src/test/java/org/apache/druid/sql/calcite/schema/DruidSchemaTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDo0NzowNlrOGlW1QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDo0NzowNlrOGlW1QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyNDU3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      DataSource dataSource, JoinConditionAnalysis condition\n          \n          \n            \n                      DataSource dataSource,\n          \n          \n            \n                      JoinConditionAnalysis condition", "url": "https://github.com/apache/druid/pull/10041#discussion_r441824577", "createdAt": "2020-06-17T20:47:06Z", "author": {"login": "jihoonson"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/schema/DruidSchemaTest.java", "diffHunk": "@@ -222,10 +228,29 @@ public void setUp() throws Exception\n     serverView = new TestServerInventoryView(walker.getSegments(), realtimeSegments);\n     druidServers = serverView.getDruidServers();\n \n+    final JoinableFactory globalTableJoinable = new JoinableFactory()\n+    {\n+      @Override\n+      public boolean isDirectlyJoinable(DataSource dataSource)\n+      {\n+        return dataSource instanceof GlobalTableDataSource &&\n+               segmentDataSourceNames.contains(((GlobalTableDataSource) dataSource).getName());\n+      }\n+\n+      @Override\n+      public Optional<Joinable> build(\n+          DataSource dataSource, JoinConditionAnalysis condition", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f50b3ecfe89743cc23abf4bddbf981a0c2ff3af"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzAzNjI1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/druid/server/ClientQuerySegmentWalker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjoyNDowMVrOGmCJEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMDowNDo0MVrOGmD8cQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzNDE2Mw==", "bodyText": "super nit: even though query is not used in CachingClusteredClient.getQueryRunnerForSegments(), it could be better to use freeTradeQuery instead of query for future proof for when someone changes the logic of CachingClusteredClient.getQueryRunnerForSegments().", "url": "https://github.com/apache/druid/pull/10041#discussion_r442534163", "createdAt": "2020-06-18T22:24:01Z", "author": {"login": "jihoonson"}, "path": "server/src/main/java/org/apache/druid/server/ClientQuerySegmentWalker.java", "diffHunk": "@@ -187,10 +198,15 @@ public ClientQuerySegmentWalker(\n   @Override\n   public <T> QueryRunner<T> getQueryRunnerForSegments(Query<T> query, Iterable<SegmentDescriptor> specs)\n   {\n-    // Inlining isn't done for segments-based queries.\n+    // Inlining isn't done for segments-based queries, but we still globalify the table datasources if possible\n+    final Query<T> freeTradeQuery = query.withDataSource(globalizeIfPossible(query.getDataSource()));\n \n     if (canRunQueryUsingClusterWalker(query)) {\n-      return decorateClusterRunner(query, clusterClient.getQueryRunnerForSegments(query, specs));\n+      return new QuerySwappingQueryRunner<>(\n+          decorateClusterRunner(freeTradeQuery, clusterClient.getQueryRunnerForSegments(query, specs)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f7876560565e320c022e809bdcc047c457f1a05"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2MzY5Nw==", "bodyText": "oops, good catch, fixed \ud83d\udc4d", "url": "https://github.com/apache/druid/pull/10041#discussion_r442563697", "createdAt": "2020-06-19T00:04:41Z", "author": {"login": "clintropolis"}, "path": "server/src/main/java/org/apache/druid/server/ClientQuerySegmentWalker.java", "diffHunk": "@@ -187,10 +198,15 @@ public ClientQuerySegmentWalker(\n   @Override\n   public <T> QueryRunner<T> getQueryRunnerForSegments(Query<T> query, Iterable<SegmentDescriptor> specs)\n   {\n-    // Inlining isn't done for segments-based queries.\n+    // Inlining isn't done for segments-based queries, but we still globalify the table datasources if possible\n+    final Query<T> freeTradeQuery = query.withDataSource(globalizeIfPossible(query.getDataSource()));\n \n     if (canRunQueryUsingClusterWalker(query)) {\n-      return decorateClusterRunner(query, clusterClient.getQueryRunnerForSegments(query, specs));\n+      return new QuerySwappingQueryRunner<>(\n+          decorateClusterRunner(freeTradeQuery, clusterClient.getQueryRunnerForSegments(query, specs)),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzNDE2Mw=="}, "originalCommit": {"oid": "1f7876560565e320c022e809bdcc047c457f1a05"}, "originalPosition": 96}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2337, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}