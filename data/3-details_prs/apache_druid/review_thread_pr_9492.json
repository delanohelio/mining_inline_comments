{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2MDY4ODY4", "number": 9492, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxOTowODo0NVrODnNeug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMTo0NzoyNFrODnpQ7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNDQxOTE0OnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/java/org/apache/druid/tests/query/ITWikipediaQueryTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxOTowODo0NVrOF1E-zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTowNzoxMlrOF18M_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwMDQ2MA==", "bodyText": "assert this against StringUtils.format(QueryCapacityExceededException.ERROR_MESSAGE_TEMPLATE, \"one\") instead?", "url": "https://github.com/apache/druid/pull/9492#discussion_r391200460", "createdAt": "2020-03-11T19:08:45Z", "author": {"login": "maytasm"}, "path": "integration-tests/src/test/java/org/apache/druid/tests/query/ITWikipediaQueryTest.java", "diffHunk": "@@ -51,15 +69,78 @@ public void before() throws Exception\n     ITRetryUtil.retryUntilTrue(\n         () -> coordinatorClient.areSegmentsLoaded(WIKIPEDIA_DATA_SOURCE), \"wikipedia segment load\"\n     );\n-    coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n-    ITRetryUtil.retryUntilTrue(\n-        () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n-    );\n+    if (!coordinatorClient.areLookupsLoaded(WIKI_LOOKUP)) {\n+      coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n+      ITRetryUtil.retryUntilTrue(\n+          () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n+      );\n+    }\n   }\n \n   @Test\n   public void testWikipediaQueriesFromFile() throws Exception\n   {\n     queryHelper.testQueriesFromFile(WIKIPEDIA_QUERIES_RESOURCE, 2);\n   }\n+\n+  @Test\n+  public void testQueryLaning() throws Exception\n+  {\n+    // the broker is configured with 2 manually defined query lanes, 'one' with limit 1, and 'two' with limit 'two'\n+    //  -Ddruid.query.scheduler.laning.type=manual\n+    //  -Ddruid.query.scheduler.laning.lanes.one=1\n+    //  -Ddruid.query.scheduler.laning.lanes.two=2\n+    // by issuing 50 queries, at least 1 of them will succeed on 'one', and at least 1 of them will overlap enough to\n+    // get limited\n+    final int numQueries = 50;\n+    List<Future<StatusResponseHolder>> futures = new ArrayList<>(numQueries);\n+    for (int i = 0; i < numQueries; i++) {\n+      futures.add(\n+          queryClient.queryAsync(\n+              queryHelper.getQueryURL(config.getBrokerUrl()),\n+              getQueryBuilder().build()\n+          )\n+      );\n+    }\n+\n+    int success = 0;\n+    int limited = 0;\n+\n+    for (Future<StatusResponseHolder> future : futures) {\n+      StatusResponseHolder status = future.get();\n+      if (status.getStatus().getCode() == QueryCapacityExceededException.STATUS_CODE) {\n+        limited++;\n+        Assert.assertTrue(status.getContent().contains(\"one\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEwNTIxNQ==", "bodyText": "changed", "url": "https://github.com/apache/druid/pull/9492#discussion_r392105215", "createdAt": "2020-03-13T09:07:12Z", "author": {"login": "clintropolis"}, "path": "integration-tests/src/test/java/org/apache/druid/tests/query/ITWikipediaQueryTest.java", "diffHunk": "@@ -51,15 +69,78 @@ public void before() throws Exception\n     ITRetryUtil.retryUntilTrue(\n         () -> coordinatorClient.areSegmentsLoaded(WIKIPEDIA_DATA_SOURCE), \"wikipedia segment load\"\n     );\n-    coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n-    ITRetryUtil.retryUntilTrue(\n-        () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n-    );\n+    if (!coordinatorClient.areLookupsLoaded(WIKI_LOOKUP)) {\n+      coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n+      ITRetryUtil.retryUntilTrue(\n+          () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n+      );\n+    }\n   }\n \n   @Test\n   public void testWikipediaQueriesFromFile() throws Exception\n   {\n     queryHelper.testQueriesFromFile(WIKIPEDIA_QUERIES_RESOURCE, 2);\n   }\n+\n+  @Test\n+  public void testQueryLaning() throws Exception\n+  {\n+    // the broker is configured with 2 manually defined query lanes, 'one' with limit 1, and 'two' with limit 'two'\n+    //  -Ddruid.query.scheduler.laning.type=manual\n+    //  -Ddruid.query.scheduler.laning.lanes.one=1\n+    //  -Ddruid.query.scheduler.laning.lanes.two=2\n+    // by issuing 50 queries, at least 1 of them will succeed on 'one', and at least 1 of them will overlap enough to\n+    // get limited\n+    final int numQueries = 50;\n+    List<Future<StatusResponseHolder>> futures = new ArrayList<>(numQueries);\n+    for (int i = 0; i < numQueries; i++) {\n+      futures.add(\n+          queryClient.queryAsync(\n+              queryHelper.getQueryURL(config.getBrokerUrl()),\n+              getQueryBuilder().build()\n+          )\n+      );\n+    }\n+\n+    int success = 0;\n+    int limited = 0;\n+\n+    for (Future<StatusResponseHolder> future : futures) {\n+      StatusResponseHolder status = future.get();\n+      if (status.getStatus().getCode() == QueryCapacityExceededException.STATUS_CODE) {\n+        limited++;\n+        Assert.assertTrue(status.getContent().contains(\"one\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwMDQ2MA=="}, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNDQyODIxOnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/java/org/apache/druid/tests/query/ITWikipediaQueryTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxOToxMTo0M1rOF1FEgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTowNTo1OVrOF18KuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwMTkyMA==", "bodyText": "This can be separate into another @test method. Will make understanding each test case easier.", "url": "https://github.com/apache/druid/pull/9492#discussion_r391201920", "createdAt": "2020-03-11T19:11:43Z", "author": {"login": "maytasm"}, "path": "integration-tests/src/test/java/org/apache/druid/tests/query/ITWikipediaQueryTest.java", "diffHunk": "@@ -51,15 +69,78 @@ public void before() throws Exception\n     ITRetryUtil.retryUntilTrue(\n         () -> coordinatorClient.areSegmentsLoaded(WIKIPEDIA_DATA_SOURCE), \"wikipedia segment load\"\n     );\n-    coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n-    ITRetryUtil.retryUntilTrue(\n-        () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n-    );\n+    if (!coordinatorClient.areLookupsLoaded(WIKI_LOOKUP)) {\n+      coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n+      ITRetryUtil.retryUntilTrue(\n+          () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n+      );\n+    }\n   }\n \n   @Test\n   public void testWikipediaQueriesFromFile() throws Exception\n   {\n     queryHelper.testQueriesFromFile(WIKIPEDIA_QUERIES_RESOURCE, 2);\n   }\n+\n+  @Test\n+  public void testQueryLaning() throws Exception\n+  {\n+    // the broker is configured with 2 manually defined query lanes, 'one' with limit 1, and 'two' with limit 'two'\n+    //  -Ddruid.query.scheduler.laning.type=manual\n+    //  -Ddruid.query.scheduler.laning.lanes.one=1\n+    //  -Ddruid.query.scheduler.laning.lanes.two=2\n+    // by issuing 50 queries, at least 1 of them will succeed on 'one', and at least 1 of them will overlap enough to\n+    // get limited\n+    final int numQueries = 50;\n+    List<Future<StatusResponseHolder>> futures = new ArrayList<>(numQueries);\n+    for (int i = 0; i < numQueries; i++) {\n+      futures.add(\n+          queryClient.queryAsync(\n+              queryHelper.getQueryURL(config.getBrokerUrl()),\n+              getQueryBuilder().build()\n+          )\n+      );\n+    }\n+\n+    int success = 0;\n+    int limited = 0;\n+\n+    for (Future<StatusResponseHolder> future : futures) {\n+      StatusResponseHolder status = future.get();\n+      if (status.getStatus().getCode() == QueryCapacityExceededException.STATUS_CODE) {\n+        limited++;\n+        Assert.assertTrue(status.getContent().contains(\"one\"));\n+      } else if (status.getStatus().getCode() == HttpResponseStatus.OK.getCode()) {\n+        success++;\n+      }\n+    }\n+\n+    Assert.assertTrue(success > 0);\n+    Assert.assertTrue(limited > 0);\n+\n+    // test another to make sure we can still issue one query at a time", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIzNzcxMA==", "bodyText": "Hmm, this is testing a sequence of events though, so it belongs in the same test", "url": "https://github.com/apache/druid/pull/9492#discussion_r391237710", "createdAt": "2020-03-11T20:09:15Z", "author": {"login": "clintropolis"}, "path": "integration-tests/src/test/java/org/apache/druid/tests/query/ITWikipediaQueryTest.java", "diffHunk": "@@ -51,15 +69,78 @@ public void before() throws Exception\n     ITRetryUtil.retryUntilTrue(\n         () -> coordinatorClient.areSegmentsLoaded(WIKIPEDIA_DATA_SOURCE), \"wikipedia segment load\"\n     );\n-    coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n-    ITRetryUtil.retryUntilTrue(\n-        () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n-    );\n+    if (!coordinatorClient.areLookupsLoaded(WIKI_LOOKUP)) {\n+      coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n+      ITRetryUtil.retryUntilTrue(\n+          () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n+      );\n+    }\n   }\n \n   @Test\n   public void testWikipediaQueriesFromFile() throws Exception\n   {\n     queryHelper.testQueriesFromFile(WIKIPEDIA_QUERIES_RESOURCE, 2);\n   }\n+\n+  @Test\n+  public void testQueryLaning() throws Exception\n+  {\n+    // the broker is configured with 2 manually defined query lanes, 'one' with limit 1, and 'two' with limit 'two'\n+    //  -Ddruid.query.scheduler.laning.type=manual\n+    //  -Ddruid.query.scheduler.laning.lanes.one=1\n+    //  -Ddruid.query.scheduler.laning.lanes.two=2\n+    // by issuing 50 queries, at least 1 of them will succeed on 'one', and at least 1 of them will overlap enough to\n+    // get limited\n+    final int numQueries = 50;\n+    List<Future<StatusResponseHolder>> futures = new ArrayList<>(numQueries);\n+    for (int i = 0; i < numQueries; i++) {\n+      futures.add(\n+          queryClient.queryAsync(\n+              queryHelper.getQueryURL(config.getBrokerUrl()),\n+              getQueryBuilder().build()\n+          )\n+      );\n+    }\n+\n+    int success = 0;\n+    int limited = 0;\n+\n+    for (Future<StatusResponseHolder> future : futures) {\n+      StatusResponseHolder status = future.get();\n+      if (status.getStatus().getCode() == QueryCapacityExceededException.STATUS_CODE) {\n+        limited++;\n+        Assert.assertTrue(status.getContent().contains(\"one\"));\n+      } else if (status.getStatus().getCode() == HttpResponseStatus.OK.getCode()) {\n+        success++;\n+      }\n+    }\n+\n+    Assert.assertTrue(success > 0);\n+    Assert.assertTrue(limited > 0);\n+\n+    // test another to make sure we can still issue one query at a time", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwMTkyMA=="}, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI0MDY4OQ==", "bodyText": "I was thinking the top part is test where we exceed and expect rejection. The bottom part is test where we are always under the limit and never exceed hence expect all to be successful.", "url": "https://github.com/apache/druid/pull/9492#discussion_r391240689", "createdAt": "2020-03-11T20:12:49Z", "author": {"login": "maytasm"}, "path": "integration-tests/src/test/java/org/apache/druid/tests/query/ITWikipediaQueryTest.java", "diffHunk": "@@ -51,15 +69,78 @@ public void before() throws Exception\n     ITRetryUtil.retryUntilTrue(\n         () -> coordinatorClient.areSegmentsLoaded(WIKIPEDIA_DATA_SOURCE), \"wikipedia segment load\"\n     );\n-    coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n-    ITRetryUtil.retryUntilTrue(\n-        () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n-    );\n+    if (!coordinatorClient.areLookupsLoaded(WIKI_LOOKUP)) {\n+      coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n+      ITRetryUtil.retryUntilTrue(\n+          () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n+      );\n+    }\n   }\n \n   @Test\n   public void testWikipediaQueriesFromFile() throws Exception\n   {\n     queryHelper.testQueriesFromFile(WIKIPEDIA_QUERIES_RESOURCE, 2);\n   }\n+\n+  @Test\n+  public void testQueryLaning() throws Exception\n+  {\n+    // the broker is configured with 2 manually defined query lanes, 'one' with limit 1, and 'two' with limit 'two'\n+    //  -Ddruid.query.scheduler.laning.type=manual\n+    //  -Ddruid.query.scheduler.laning.lanes.one=1\n+    //  -Ddruid.query.scheduler.laning.lanes.two=2\n+    // by issuing 50 queries, at least 1 of them will succeed on 'one', and at least 1 of them will overlap enough to\n+    // get limited\n+    final int numQueries = 50;\n+    List<Future<StatusResponseHolder>> futures = new ArrayList<>(numQueries);\n+    for (int i = 0; i < numQueries; i++) {\n+      futures.add(\n+          queryClient.queryAsync(\n+              queryHelper.getQueryURL(config.getBrokerUrl()),\n+              getQueryBuilder().build()\n+          )\n+      );\n+    }\n+\n+    int success = 0;\n+    int limited = 0;\n+\n+    for (Future<StatusResponseHolder> future : futures) {\n+      StatusResponseHolder status = future.get();\n+      if (status.getStatus().getCode() == QueryCapacityExceededException.STATUS_CODE) {\n+        limited++;\n+        Assert.assertTrue(status.getContent().contains(\"one\"));\n+      } else if (status.getStatus().getCode() == HttpResponseStatus.OK.getCode()) {\n+        success++;\n+      }\n+    }\n+\n+    Assert.assertTrue(success > 0);\n+    Assert.assertTrue(limited > 0);\n+\n+    // test another to make sure we can still issue one query at a time", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwMTkyMA=="}, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEwNDYzMw==", "bodyText": "added a separate test which runs a bunch of queries the same manner that do not belong to a lane to make sure they are not limited", "url": "https://github.com/apache/druid/pull/9492#discussion_r392104633", "createdAt": "2020-03-13T09:05:59Z", "author": {"login": "clintropolis"}, "path": "integration-tests/src/test/java/org/apache/druid/tests/query/ITWikipediaQueryTest.java", "diffHunk": "@@ -51,15 +69,78 @@ public void before() throws Exception\n     ITRetryUtil.retryUntilTrue(\n         () -> coordinatorClient.areSegmentsLoaded(WIKIPEDIA_DATA_SOURCE), \"wikipedia segment load\"\n     );\n-    coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n-    ITRetryUtil.retryUntilTrue(\n-        () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n-    );\n+    if (!coordinatorClient.areLookupsLoaded(WIKI_LOOKUP)) {\n+      coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n+      ITRetryUtil.retryUntilTrue(\n+          () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n+      );\n+    }\n   }\n \n   @Test\n   public void testWikipediaQueriesFromFile() throws Exception\n   {\n     queryHelper.testQueriesFromFile(WIKIPEDIA_QUERIES_RESOURCE, 2);\n   }\n+\n+  @Test\n+  public void testQueryLaning() throws Exception\n+  {\n+    // the broker is configured with 2 manually defined query lanes, 'one' with limit 1, and 'two' with limit 'two'\n+    //  -Ddruid.query.scheduler.laning.type=manual\n+    //  -Ddruid.query.scheduler.laning.lanes.one=1\n+    //  -Ddruid.query.scheduler.laning.lanes.two=2\n+    // by issuing 50 queries, at least 1 of them will succeed on 'one', and at least 1 of them will overlap enough to\n+    // get limited\n+    final int numQueries = 50;\n+    List<Future<StatusResponseHolder>> futures = new ArrayList<>(numQueries);\n+    for (int i = 0; i < numQueries; i++) {\n+      futures.add(\n+          queryClient.queryAsync(\n+              queryHelper.getQueryURL(config.getBrokerUrl()),\n+              getQueryBuilder().build()\n+          )\n+      );\n+    }\n+\n+    int success = 0;\n+    int limited = 0;\n+\n+    for (Future<StatusResponseHolder> future : futures) {\n+      StatusResponseHolder status = future.get();\n+      if (status.getStatus().getCode() == QueryCapacityExceededException.STATUS_CODE) {\n+        limited++;\n+        Assert.assertTrue(status.getContent().contains(\"one\"));\n+      } else if (status.getStatus().getCode() == HttpResponseStatus.OK.getCode()) {\n+        success++;\n+      }\n+    }\n+\n+    Assert.assertTrue(success > 0);\n+    Assert.assertTrue(limited > 0);\n+\n+    // test another to make sure we can still issue one query at a time", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwMTkyMA=="}, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNDQ1ODk3OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/druid/server/QuerySchedulerTest.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxOToyMTozMVrOF1FYEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTowNzo1MFrOF18OOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwNjkzMQ==", "bodyText": "maybe also test negative case (like lane name \"three\") and see we get NO_CAPACITY?", "url": "https://github.com/apache/druid/pull/9492#discussion_r391206931", "createdAt": "2020-03-11T19:21:31Z", "author": {"login": "maytasm"}, "path": "server/src/test/java/org/apache/druid/server/QuerySchedulerTest.java", "diffHunk": "@@ -399,6 +399,49 @@ public void testMisConfigHiLo()\n   }\n \n \n+  @Test\n+  public void testConfigManual()\n+  {\n+    final Injector injector = createInjector();\n+    final String propertyPrefix = \"druid.query.scheduler\";\n+    final JsonConfigProvider<QuerySchedulerProvider> provider = JsonConfigProvider.of(\n+        propertyPrefix,\n+        QuerySchedulerProvider.class\n+    );\n+    final Properties properties = new Properties();\n+    properties.put(propertyPrefix + \".numThreads\", \"10\");\n+    properties.put(propertyPrefix + \".laning.strategy\", \"manual\");\n+    properties.put(propertyPrefix + \".laning.lanes.one\", \"1\");\n+    properties.put(propertyPrefix + \".laning.lanes.two\", \"2\");\n+    provider.inject(properties, injector.getInstance(JsonConfigurator.class));\n+    final QueryScheduler scheduler = provider.get().get().get();\n+    Assert.assertEquals(10, scheduler.getTotalAvailableCapacity());\n+    Assert.assertEquals(1, scheduler.getLaneAvailableCapacity(\"one\"));\n+    Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(\"two\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIzOTc2MQ==", "bodyText": "This isn't actually true currently, non-existent lanes are currently treated the same as not having a lane. I did this in  #9407 because it seemed friendlier, but an argument can probably made for making undefined lanes that are present be treated as having 0 capacity which would make what you are suggesting true. If we wanted to make this change, we could either do it across the board in QueryScheduler, or leave the decision to the QueryLaningStrategy which is a bit more flexible.", "url": "https://github.com/apache/druid/pull/9492#discussion_r391239761", "createdAt": "2020-03-11T20:11:37Z", "author": {"login": "clintropolis"}, "path": "server/src/test/java/org/apache/druid/server/QuerySchedulerTest.java", "diffHunk": "@@ -399,6 +399,49 @@ public void testMisConfigHiLo()\n   }\n \n \n+  @Test\n+  public void testConfigManual()\n+  {\n+    final Injector injector = createInjector();\n+    final String propertyPrefix = \"druid.query.scheduler\";\n+    final JsonConfigProvider<QuerySchedulerProvider> provider = JsonConfigProvider.of(\n+        propertyPrefix,\n+        QuerySchedulerProvider.class\n+    );\n+    final Properties properties = new Properties();\n+    properties.put(propertyPrefix + \".numThreads\", \"10\");\n+    properties.put(propertyPrefix + \".laning.strategy\", \"manual\");\n+    properties.put(propertyPrefix + \".laning.lanes.one\", \"1\");\n+    properties.put(propertyPrefix + \".laning.lanes.two\", \"2\");\n+    provider.inject(properties, injector.getInstance(JsonConfigurator.class));\n+    final QueryScheduler scheduler = provider.get().get().get();\n+    Assert.assertEquals(10, scheduler.getTotalAvailableCapacity());\n+    Assert.assertEquals(1, scheduler.getLaneAvailableCapacity(\"one\"));\n+    Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(\"two\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwNjkzMQ=="}, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI0NzEzOQ==", "bodyText": "Oh, I maybe interpreted this as something deeper, suggesting that we should treat queries that specify non-existent lanes as a 0 capacity lane, because of my poorly named NO_CAPACITY variable which I am going to rename as UNAVAILABLE pending this discussion. If you're just suggesting that we check that non-existent lanes return -1 I can add that test.", "url": "https://github.com/apache/druid/pull/9492#discussion_r391247139", "createdAt": "2020-03-11T20:23:37Z", "author": {"login": "clintropolis"}, "path": "server/src/test/java/org/apache/druid/server/QuerySchedulerTest.java", "diffHunk": "@@ -399,6 +399,49 @@ public void testMisConfigHiLo()\n   }\n \n \n+  @Test\n+  public void testConfigManual()\n+  {\n+    final Injector injector = createInjector();\n+    final String propertyPrefix = \"druid.query.scheduler\";\n+    final JsonConfigProvider<QuerySchedulerProvider> provider = JsonConfigProvider.of(\n+        propertyPrefix,\n+        QuerySchedulerProvider.class\n+    );\n+    final Properties properties = new Properties();\n+    properties.put(propertyPrefix + \".numThreads\", \"10\");\n+    properties.put(propertyPrefix + \".laning.strategy\", \"manual\");\n+    properties.put(propertyPrefix + \".laning.lanes.one\", \"1\");\n+    properties.put(propertyPrefix + \".laning.lanes.two\", \"2\");\n+    provider.inject(properties, injector.getInstance(JsonConfigurator.class));\n+    final QueryScheduler scheduler = provider.get().get().get();\n+    Assert.assertEquals(10, scheduler.getTotalAvailableCapacity());\n+    Assert.assertEquals(1, scheduler.getLaneAvailableCapacity(\"one\"));\n+    Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(\"two\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwNjkzMQ=="}, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0Mzc0NA==", "bodyText": "Im just suggesting to add test that check that non-existent lanes return -1", "url": "https://github.com/apache/druid/pull/9492#discussion_r391343744", "createdAt": "2020-03-12T00:30:56Z", "author": {"login": "maytasm"}, "path": "server/src/test/java/org/apache/druid/server/QuerySchedulerTest.java", "diffHunk": "@@ -399,6 +399,49 @@ public void testMisConfigHiLo()\n   }\n \n \n+  @Test\n+  public void testConfigManual()\n+  {\n+    final Injector injector = createInjector();\n+    final String propertyPrefix = \"druid.query.scheduler\";\n+    final JsonConfigProvider<QuerySchedulerProvider> provider = JsonConfigProvider.of(\n+        propertyPrefix,\n+        QuerySchedulerProvider.class\n+    );\n+    final Properties properties = new Properties();\n+    properties.put(propertyPrefix + \".numThreads\", \"10\");\n+    properties.put(propertyPrefix + \".laning.strategy\", \"manual\");\n+    properties.put(propertyPrefix + \".laning.lanes.one\", \"1\");\n+    properties.put(propertyPrefix + \".laning.lanes.two\", \"2\");\n+    provider.inject(properties, injector.getInstance(JsonConfigurator.class));\n+    final QueryScheduler scheduler = provider.get().get().get();\n+    Assert.assertEquals(10, scheduler.getTotalAvailableCapacity());\n+    Assert.assertEquals(1, scheduler.getLaneAvailableCapacity(\"one\"));\n+    Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(\"two\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwNjkzMQ=="}, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEwNTUzMQ==", "bodyText": "added some asserts to existing tests to show that non-existent lane is unavailable", "url": "https://github.com/apache/druid/pull/9492#discussion_r392105531", "createdAt": "2020-03-13T09:07:50Z", "author": {"login": "clintropolis"}, "path": "server/src/test/java/org/apache/druid/server/QuerySchedulerTest.java", "diffHunk": "@@ -399,6 +399,49 @@ public void testMisConfigHiLo()\n   }\n \n \n+  @Test\n+  public void testConfigManual()\n+  {\n+    final Injector injector = createInjector();\n+    final String propertyPrefix = \"druid.query.scheduler\";\n+    final JsonConfigProvider<QuerySchedulerProvider> provider = JsonConfigProvider.of(\n+        propertyPrefix,\n+        QuerySchedulerProvider.class\n+    );\n+    final Properties properties = new Properties();\n+    properties.put(propertyPrefix + \".numThreads\", \"10\");\n+    properties.put(propertyPrefix + \".laning.strategy\", \"manual\");\n+    properties.put(propertyPrefix + \".laning.lanes.one\", \"1\");\n+    properties.put(propertyPrefix + \".laning.lanes.two\", \"2\");\n+    provider.inject(properties, injector.getInstance(JsonConfigurator.class));\n+    final QueryScheduler scheduler = provider.get().get().get();\n+    Assert.assertEquals(10, scheduler.getTotalAvailableCapacity());\n+    Assert.assertEquals(1, scheduler.getLaneAvailableCapacity(\"one\"));\n+    Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(\"two\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwNjkzMQ=="}, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNDQ1OTI0OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/druid/server/QuerySchedulerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxOToyMTozNlrOF1FYPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxOToyMTozNlrOF1FYPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwNjk3NQ==", "bodyText": "maybe also test negative case (like lane name \"three\") and see we get NO_CAPACITY?", "url": "https://github.com/apache/druid/pull/9492#discussion_r391206975", "createdAt": "2020-03-11T19:21:36Z", "author": {"login": "maytasm"}, "path": "server/src/test/java/org/apache/druid/server/QuerySchedulerTest.java", "diffHunk": "@@ -399,6 +399,49 @@ public void testMisConfigHiLo()\n   }\n \n \n+  @Test\n+  public void testConfigManual()\n+  {\n+    final Injector injector = createInjector();\n+    final String propertyPrefix = \"druid.query.scheduler\";\n+    final JsonConfigProvider<QuerySchedulerProvider> provider = JsonConfigProvider.of(\n+        propertyPrefix,\n+        QuerySchedulerProvider.class\n+    );\n+    final Properties properties = new Properties();\n+    properties.put(propertyPrefix + \".numThreads\", \"10\");\n+    properties.put(propertyPrefix + \".laning.strategy\", \"manual\");\n+    properties.put(propertyPrefix + \".laning.lanes.one\", \"1\");\n+    properties.put(propertyPrefix + \".laning.lanes.two\", \"2\");\n+    provider.inject(properties, injector.getInstance(JsonConfigurator.class));\n+    final QueryScheduler scheduler = provider.get().get().get();\n+    Assert.assertEquals(10, scheduler.getTotalAvailableCapacity());\n+    Assert.assertEquals(1, scheduler.getLaneAvailableCapacity(\"one\"));\n+    Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(\"two\"));\n+  }\n+\n+  @Test\n+  public void testConfigManualPercent()\n+  {\n+    final Injector injector = createInjector();\n+    final String propertyPrefix = \"druid.query.scheduler\";\n+    final JsonConfigProvider<QuerySchedulerProvider> provider = JsonConfigProvider.of(\n+        propertyPrefix,\n+        QuerySchedulerProvider.class\n+    );\n+    final Properties properties = new Properties();\n+    properties.put(propertyPrefix + \".numThreads\", \"10\");\n+    properties.put(propertyPrefix + \".laning.strategy\", \"manual\");\n+    properties.put(propertyPrefix + \".laning.isLimitPercent\", \"true\");\n+    properties.put(propertyPrefix + \".laning.lanes.one\", \"1\");\n+    properties.put(propertyPrefix + \".laning.lanes.twenty\", \"20\");\n+    provider.inject(properties, injector.getInstance(JsonConfigurator.class));\n+    final QueryScheduler scheduler = provider.get().get().get();\n+    Assert.assertEquals(10, scheduler.getTotalAvailableCapacity());\n+    Assert.assertEquals(1, scheduler.getLaneAvailableCapacity(\"one\"));\n+    Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(\"twenty\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNDQ5NDEyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/druid/server/scheduling/ManualQueryLaningStrategy.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxOTozMzowM1rOF1Fuwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMDozMTo0N1rOF1NvdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIxMjczOA==", "bodyText": "Just wondering..why does computeLane needs SegmentServerSelector? Doesn't laning or not should just depend on the query context that was given with the query?", "url": "https://github.com/apache/druid/pull/9492#discussion_r391212738", "createdAt": "2020-03-11T19:33:03Z", "author": {"login": "maytasm"}, "path": "server/src/main/java/org/apache/druid/server/scheduling/ManualQueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.QueryLaningStrategy;\n+\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public class ManualQueryLaningStrategy implements QueryLaningStrategy\n+{\n+  @JsonProperty\n+  private Map<String, Integer> lanes;\n+\n+  @JsonProperty\n+  private boolean isLimitPercent;\n+\n+  @JsonCreator\n+  public ManualQueryLaningStrategy(\n+      @JsonProperty(\"lanes\") Map<String, Integer> lanes,\n+      @JsonProperty(\"isLimitPercent\") @Nullable Boolean isLimitPercent\n+  )\n+  {\n+    this.lanes = Preconditions.checkNotNull(lanes, \"lanes must be set\");\n+    this.isLimitPercent = isLimitPercent != null ? isLimitPercent : false;\n+    Preconditions.checkArgument(lanes.size() > 0, \"lanes must define at least one lane\");\n+    Preconditions.checkArgument(\n+        lanes.values().stream().allMatch(x -> this.isLimitPercent ? 0 < x && x <= 100 : x > 0),\n+        this.isLimitPercent ? \"All lane limits must be in the range 1 to 100\" : \"All lane limits must be greater than 0\"\n+    );\n+  }\n+\n+  @Override\n+  public Object2IntMap<String> getLaneLimits(int totalLimit)\n+  {\n+\n+    if (isLimitPercent) {\n+      Object2IntMap<String> laneLimits = new Object2IntArrayMap<>(lanes.size());\n+      lanes.forEach((key, value) -> laneLimits.put(key, computeLimitFromPercent(totalLimit, value)));\n+      return laneLimits;\n+    }\n+    return new Object2IntArrayMap<>(lanes);\n+  }\n+\n+  @Override\n+  public <T> Optional<String> computeLane(QueryPlus<T> query, Set<SegmentServerSelector> segments)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI0MzI3OQ==", "bodyText": "QueryLaningStrategy are intended to compute the lane on the query context, which the QueryScheduler can then use to enforce limits. This laning strategy is a bit of a special case because it only preserves what was already there, but other strategies could consider all sorts of information to allow them to make informed decisions about lane assignment based on details of the query.", "url": "https://github.com/apache/druid/pull/9492#discussion_r391243279", "createdAt": "2020-03-11T20:16:07Z", "author": {"login": "clintropolis"}, "path": "server/src/main/java/org/apache/druid/server/scheduling/ManualQueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.QueryLaningStrategy;\n+\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public class ManualQueryLaningStrategy implements QueryLaningStrategy\n+{\n+  @JsonProperty\n+  private Map<String, Integer> lanes;\n+\n+  @JsonProperty\n+  private boolean isLimitPercent;\n+\n+  @JsonCreator\n+  public ManualQueryLaningStrategy(\n+      @JsonProperty(\"lanes\") Map<String, Integer> lanes,\n+      @JsonProperty(\"isLimitPercent\") @Nullable Boolean isLimitPercent\n+  )\n+  {\n+    this.lanes = Preconditions.checkNotNull(lanes, \"lanes must be set\");\n+    this.isLimitPercent = isLimitPercent != null ? isLimitPercent : false;\n+    Preconditions.checkArgument(lanes.size() > 0, \"lanes must define at least one lane\");\n+    Preconditions.checkArgument(\n+        lanes.values().stream().allMatch(x -> this.isLimitPercent ? 0 < x && x <= 100 : x > 0),\n+        this.isLimitPercent ? \"All lane limits must be in the range 1 to 100\" : \"All lane limits must be greater than 0\"\n+    );\n+  }\n+\n+  @Override\n+  public Object2IntMap<String> getLaneLimits(int totalLimit)\n+  {\n+\n+    if (isLimitPercent) {\n+      Object2IntMap<String> laneLimits = new Object2IntArrayMap<>(lanes.size());\n+      lanes.forEach((key, value) -> laneLimits.put(key, computeLimitFromPercent(totalLimit, value)));\n+      return laneLimits;\n+    }\n+    return new Object2IntArrayMap<>(lanes);\n+  }\n+\n+  @Override\n+  public <T> Optional<String> computeLane(QueryPlus<T> query, Set<SegmentServerSelector> segments)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIxMjczOA=="}, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0Mzk4OA==", "bodyText": "I see. Thanks for the clarification", "url": "https://github.com/apache/druid/pull/9492#discussion_r391343988", "createdAt": "2020-03-12T00:31:47Z", "author": {"login": "maytasm"}, "path": "server/src/main/java/org/apache/druid/server/scheduling/ManualQueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.QueryLaningStrategy;\n+\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public class ManualQueryLaningStrategy implements QueryLaningStrategy\n+{\n+  @JsonProperty\n+  private Map<String, Integer> lanes;\n+\n+  @JsonProperty\n+  private boolean isLimitPercent;\n+\n+  @JsonCreator\n+  public ManualQueryLaningStrategy(\n+      @JsonProperty(\"lanes\") Map<String, Integer> lanes,\n+      @JsonProperty(\"isLimitPercent\") @Nullable Boolean isLimitPercent\n+  )\n+  {\n+    this.lanes = Preconditions.checkNotNull(lanes, \"lanes must be set\");\n+    this.isLimitPercent = isLimitPercent != null ? isLimitPercent : false;\n+    Preconditions.checkArgument(lanes.size() > 0, \"lanes must define at least one lane\");\n+    Preconditions.checkArgument(\n+        lanes.values().stream().allMatch(x -> this.isLimitPercent ? 0 < x && x <= 100 : x > 0),\n+        this.isLimitPercent ? \"All lane limits must be in the range 1 to 100\" : \"All lane limits must be greater than 0\"\n+    );\n+  }\n+\n+  @Override\n+  public Object2IntMap<String> getLaneLimits(int totalLimit)\n+  {\n+\n+    if (isLimitPercent) {\n+      Object2IntMap<String> laneLimits = new Object2IntArrayMap<>(lanes.size());\n+      lanes.forEach((key, value) -> laneLimits.put(key, computeLimitFromPercent(totalLimit, value)));\n+      return laneLimits;\n+    }\n+    return new Object2IntArrayMap<>(lanes);\n+  }\n+\n+  @Override\n+  public <T> Optional<String> computeLane(QueryPlus<T> query, Set<SegmentServerSelector> segments)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIxMjczOA=="}, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNDQ5OTQzOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/druid/server/scheduling/ManualQueryLaningStrategyTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxOTozNDo0N1rOF1FyRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTowMTo1OFrOF18DmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIxMzYzOA==", "bodyText": "testPercentLaneLimitsMustBeBelowOneHundred?", "url": "https://github.com/apache/druid/pull/9492#discussion_r391213638", "createdAt": "2020-03-11T19:34:47Z", "author": {"login": "maytasm"}, "path": "server/src/test/java/org/apache/druid/server/scheduling/ManualQueryLaningStrategyTest.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.java.util.common.Intervals;\n+import org.apache.druid.java.util.common.granularity.Granularities;\n+import org.apache.druid.query.Druids;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.aggregation.CountAggregatorFactory;\n+import org.apache.druid.query.timeseries.TimeseriesQuery;\n+import org.apache.druid.server.QueryLaningStrategy;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+@SuppressWarnings(\"ResultOfObjectAllocationIgnored\")\n+public class ManualQueryLaningStrategyTest\n+{\n+  private Druids.TimeseriesQueryBuilder queryBuilder;\n+  private QueryLaningStrategy exactStrategy;\n+  private QueryLaningStrategy percentStrategy;\n+\n+  @Rule\n+  public ExpectedException expectedException = ExpectedException.none();\n+\n+  @Before\n+  public void setup()\n+  {\n+    this.queryBuilder = Druids.newTimeseriesQueryBuilder()\n+                              .dataSource(\"test\")\n+                              .intervals(ImmutableList.of(Intervals.ETERNITY))\n+                              .granularity(Granularities.DAY)\n+                              .aggregators(new CountAggregatorFactory(\"count\"));\n+    this.exactStrategy =\n+        new ManualQueryLaningStrategy(ImmutableMap.of(\"one\", 1, \"ten\", 10), null);\n+    this.percentStrategy =\n+        new ManualQueryLaningStrategy(ImmutableMap.of(\"one\", 1, \"ten\", 10), true);\n+  }\n+\n+  @Test\n+  public void testLanesMustBeSet()\n+  {\n+    expectedException.expect(NullPointerException.class);\n+    expectedException.expectMessage(\"lanes must be set\");\n+    new ManualQueryLaningStrategy(null, null);\n+  }\n+\n+  @Test\n+  public void testMustDefineAtLeast1Lane()\n+  {\n+    expectedException.expect(IllegalArgumentException.class);\n+    expectedException.expectMessage(\"lanes must define at least one lane\");\n+    new ManualQueryLaningStrategy(ImmutableMap.of(), null);\n+  }\n+\n+  @Test\n+  public void testExactLaneLimitsMustBeAboveZero()\n+  {\n+    expectedException.expect(IllegalArgumentException.class);\n+    expectedException.expectMessage(\"All lane limits must be greater than 0\");\n+    new ManualQueryLaningStrategy(ImmutableMap.of(\"zero\", 0, \"one\", 1), null);\n+  }\n+\n+  @Test\n+  public void testPercentLaneLimitsMustBeAboveZero()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEwMjgwOQ==", "bodyText": "added more tests", "url": "https://github.com/apache/druid/pull/9492#discussion_r392102809", "createdAt": "2020-03-13T09:01:58Z", "author": {"login": "clintropolis"}, "path": "server/src/test/java/org/apache/druid/server/scheduling/ManualQueryLaningStrategyTest.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.java.util.common.Intervals;\n+import org.apache.druid.java.util.common.granularity.Granularities;\n+import org.apache.druid.query.Druids;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.aggregation.CountAggregatorFactory;\n+import org.apache.druid.query.timeseries.TimeseriesQuery;\n+import org.apache.druid.server.QueryLaningStrategy;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+@SuppressWarnings(\"ResultOfObjectAllocationIgnored\")\n+public class ManualQueryLaningStrategyTest\n+{\n+  private Druids.TimeseriesQueryBuilder queryBuilder;\n+  private QueryLaningStrategy exactStrategy;\n+  private QueryLaningStrategy percentStrategy;\n+\n+  @Rule\n+  public ExpectedException expectedException = ExpectedException.none();\n+\n+  @Before\n+  public void setup()\n+  {\n+    this.queryBuilder = Druids.newTimeseriesQueryBuilder()\n+                              .dataSource(\"test\")\n+                              .intervals(ImmutableList.of(Intervals.ETERNITY))\n+                              .granularity(Granularities.DAY)\n+                              .aggregators(new CountAggregatorFactory(\"count\"));\n+    this.exactStrategy =\n+        new ManualQueryLaningStrategy(ImmutableMap.of(\"one\", 1, \"ten\", 10), null);\n+    this.percentStrategy =\n+        new ManualQueryLaningStrategy(ImmutableMap.of(\"one\", 1, \"ten\", 10), true);\n+  }\n+\n+  @Test\n+  public void testLanesMustBeSet()\n+  {\n+    expectedException.expect(NullPointerException.class);\n+    expectedException.expectMessage(\"lanes must be set\");\n+    new ManualQueryLaningStrategy(null, null);\n+  }\n+\n+  @Test\n+  public void testMustDefineAtLeast1Lane()\n+  {\n+    expectedException.expect(IllegalArgumentException.class);\n+    expectedException.expectMessage(\"lanes must define at least one lane\");\n+    new ManualQueryLaningStrategy(ImmutableMap.of(), null);\n+  }\n+\n+  @Test\n+  public void testExactLaneLimitsMustBeAboveZero()\n+  {\n+    expectedException.expect(IllegalArgumentException.class);\n+    expectedException.expectMessage(\"All lane limits must be greater than 0\");\n+    new ManualQueryLaningStrategy(ImmutableMap.of(\"zero\", 0, \"one\", 1), null);\n+  }\n+\n+  @Test\n+  public void testPercentLaneLimitsMustBeAboveZero()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIxMzYzOA=="}, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNDUyNDE4OnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/java/org/apache/druid/tests/query/ITWikipediaQueryTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxOTo0Mjo0NFrOF1GCOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMDozMzo0N1rOF1Nxog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIxNzcyMA==", "bodyText": "Should we also have a test for when the Manual Lane From Context That Arent In Map is given? For example, if lane in query context is \"some-unknown-lane\"", "url": "https://github.com/apache/druid/pull/9492#discussion_r391217720", "createdAt": "2020-03-11T19:42:44Z", "author": {"login": "maytasm"}, "path": "integration-tests/src/test/java/org/apache/druid/tests/query/ITWikipediaQueryTest.java", "diffHunk": "@@ -51,15 +69,78 @@ public void before() throws Exception\n     ITRetryUtil.retryUntilTrue(\n         () -> coordinatorClient.areSegmentsLoaded(WIKIPEDIA_DATA_SOURCE), \"wikipedia segment load\"\n     );\n-    coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n-    ITRetryUtil.retryUntilTrue(\n-        () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n-    );\n+    if (!coordinatorClient.areLookupsLoaded(WIKI_LOOKUP)) {\n+      coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n+      ITRetryUtil.retryUntilTrue(\n+          () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n+      );\n+    }\n   }\n \n   @Test\n   public void testWikipediaQueriesFromFile() throws Exception\n   {\n     queryHelper.testQueriesFromFile(WIKIPEDIA_QUERIES_RESOURCE, 2);\n   }\n+\n+  @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIyMDI2Nw==", "bodyText": "I guess they will always be rejected since we give NO_CAPACITY right?", "url": "https://github.com/apache/druid/pull/9492#discussion_r391220267", "createdAt": "2020-03-11T19:47:45Z", "author": {"login": "maytasm"}, "path": "integration-tests/src/test/java/org/apache/druid/tests/query/ITWikipediaQueryTest.java", "diffHunk": "@@ -51,15 +69,78 @@ public void before() throws Exception\n     ITRetryUtil.retryUntilTrue(\n         () -> coordinatorClient.areSegmentsLoaded(WIKIPEDIA_DATA_SOURCE), \"wikipedia segment load\"\n     );\n-    coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n-    ITRetryUtil.retryUntilTrue(\n-        () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n-    );\n+    if (!coordinatorClient.areLookupsLoaded(WIKI_LOOKUP)) {\n+      coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n+      ITRetryUtil.retryUntilTrue(\n+          () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n+      );\n+    }\n   }\n \n   @Test\n   public void testWikipediaQueriesFromFile() throws Exception\n   {\n     queryHelper.testQueriesFromFile(WIKIPEDIA_QUERIES_RESOURCE, 2);\n   }\n+\n+  @Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIxNzcyMA=="}, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NDU0Ng==", "bodyText": "^ update typo above. Meant to say \"also\" have a test for case when the Manual Lane From Context That Arent In Map is given", "url": "https://github.com/apache/druid/pull/9492#discussion_r391344546", "createdAt": "2020-03-12T00:33:47Z", "author": {"login": "maytasm"}, "path": "integration-tests/src/test/java/org/apache/druid/tests/query/ITWikipediaQueryTest.java", "diffHunk": "@@ -51,15 +69,78 @@ public void before() throws Exception\n     ITRetryUtil.retryUntilTrue(\n         () -> coordinatorClient.areSegmentsLoaded(WIKIPEDIA_DATA_SOURCE), \"wikipedia segment load\"\n     );\n-    coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n-    ITRetryUtil.retryUntilTrue(\n-        () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n-    );\n+    if (!coordinatorClient.areLookupsLoaded(WIKI_LOOKUP)) {\n+      coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n+      ITRetryUtil.retryUntilTrue(\n+          () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n+      );\n+    }\n   }\n \n   @Test\n   public void testWikipediaQueriesFromFile() throws Exception\n   {\n     queryHelper.testQueriesFromFile(WIKIPEDIA_QUERIES_RESOURCE, 2);\n   }\n+\n+  @Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIxNzcyMA=="}, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODczNTYxOnYy", "diffSide": "RIGHT", "path": "docs/configuration/index.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDo0ODowMlrOF1uy_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDo0ODowMlrOF1uy_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4NTU2Ng==", "bodyText": "numbers must be in the range of 1 to 100.\n\nShould it say the number type is the integer?", "url": "https://github.com/apache/druid/pull/9492#discussion_r391885566", "createdAt": "2020-03-12T20:48:02Z", "author": {"login": "jihoonson"}, "path": "docs/configuration/index.md", "diffHunk": "@@ -1505,7 +1505,16 @@ This strategy can be enabled by setting `druid.query.scheduler.laning.strategy=h\n \n |Property|Description|Default|\n |--------|-----------|-------|\n-|`druid.query.scheduler.laning.maxLowPercent`|Maximum percent of the smaller number of`druid.server.http.numThreads` or `druid.query.scheduler.numThreads`, defining the number of HTTP threads that can be used by queries with a priority lower than 0. Value must be in the range 1 to 100, and will be rounded up|No default, must be set if using this mode|\n+|`druid.query.scheduler.laning.maxLowPercent`|Maximum percent of the smaller number of `druid.server.http.numThreads` or `druid.query.scheduler.numThreads`, defining the number of HTTP threads that can be used by queries with a priority lower than 0. Value must be in the range 1 to 100, and will be rounded up|No default, must be set if using this mode|\n+\n+\n+###### 'Manual' laning strategy\n+This laning strategy is best suited for cases where one or more external applications which query Druid are capable of manually deciding what lane a given query should belong to. Configured with a map of lane names to percent or exact max capacities, queries with a matching `lane` parameter in the [query context](../querying/query-context.md) will be subjected to those limits.\n+\n+|Property|Description|Default|\n+|--------|-----------|-------|\n+|`druid.query.scheduler.laning.lanes.{name}`|Maximum percent or exact limit of queries that can concurrently run in the defined lanes. Any number of lanes may be defined like this.|No default, must define at least one lane with a limit above 0. If `druid.query.scheduler.laning.isLimitPercent` is set to `true`, numbers must be in the range of 1 to 100.|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODk1MzAxOnYy", "diffSide": "RIGHT", "path": "integration-tests/src/test/java/org/apache/druid/tests/query/ITWikipediaQueryTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMTo0Mzo1NlrOF1wvSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMTo0Mzo1NlrOF1wvSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkxNzM4Ng==", "bodyText": "Seems the lane 'two' is not used. Perhaps better to remove it for now.", "url": "https://github.com/apache/druid/pull/9492#discussion_r391917386", "createdAt": "2020-03-12T21:43:56Z", "author": {"login": "jihoonson"}, "path": "integration-tests/src/test/java/org/apache/druid/tests/query/ITWikipediaQueryTest.java", "diffHunk": "@@ -51,15 +69,78 @@ public void before() throws Exception\n     ITRetryUtil.retryUntilTrue(\n         () -> coordinatorClient.areSegmentsLoaded(WIKIPEDIA_DATA_SOURCE), \"wikipedia segment load\"\n     );\n-    coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n-    ITRetryUtil.retryUntilTrue(\n-        () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n-    );\n+    if (!coordinatorClient.areLookupsLoaded(WIKI_LOOKUP)) {\n+      coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n+      ITRetryUtil.retryUntilTrue(\n+          () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n+      );\n+    }\n   }\n \n   @Test\n   public void testWikipediaQueriesFromFile() throws Exception\n   {\n     queryHelper.testQueriesFromFile(WIKIPEDIA_QUERIES_RESOURCE, 2);\n   }\n+\n+  @Test\n+  public void testQueryLaning() throws Exception\n+  {\n+    // the broker is configured with 2 manually defined query lanes, 'one' with limit 1, and 'two' with limit 'two'\n+    //  -Ddruid.query.scheduler.laning.type=manual\n+    //  -Ddruid.query.scheduler.laning.lanes.one=1\n+    //  -Ddruid.query.scheduler.laning.lanes.two=2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODk3MTMyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/druid/server/scheduling/ManualQueryLaningStrategy.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMTo0NzoyNFrOF1w4_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxODozNzowNVrOF2Of1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkxOTg3MQ==", "bodyText": "Should it check the sum of percents of lanes is less than or equal to 100 when isLimitPercent = true?", "url": "https://github.com/apache/druid/pull/9492#discussion_r391919871", "createdAt": "2020-03-12T21:47:24Z", "author": {"login": "jihoonson"}, "path": "server/src/main/java/org/apache/druid/server/scheduling/ManualQueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.QueryLaningStrategy;\n+\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public class ManualQueryLaningStrategy implements QueryLaningStrategy\n+{\n+  @JsonProperty\n+  private Map<String, Integer> lanes;\n+\n+  @JsonProperty\n+  private boolean isLimitPercent;\n+\n+  @JsonCreator\n+  public ManualQueryLaningStrategy(\n+      @JsonProperty(\"lanes\") Map<String, Integer> lanes,\n+      @JsonProperty(\"isLimitPercent\") @Nullable Boolean isLimitPercent\n+  )\n+  {\n+    this.lanes = Preconditions.checkNotNull(lanes, \"lanes must be set\");\n+    this.isLimitPercent = isLimitPercent != null ? isLimitPercent : false;\n+    Preconditions.checkArgument(lanes.size() > 0, \"lanes must define at least one lane\");\n+    Preconditions.checkArgument(\n+        lanes.values().stream().allMatch(x -> this.isLimitPercent ? 0 < x && x <= 100 : x > 0),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEwMTQ3NA==", "bodyText": "I'm not sure it is necessary to enforce that since lane limits are currently an 'at most' guarantee instead of an 'at least'; so it seems possibly legitimate to say configure two lanes and allow either of them to use 75% of total capacity.", "url": "https://github.com/apache/druid/pull/9492#discussion_r392101474", "createdAt": "2020-03-13T08:59:01Z", "author": {"login": "clintropolis"}, "path": "server/src/main/java/org/apache/druid/server/scheduling/ManualQueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.QueryLaningStrategy;\n+\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public class ManualQueryLaningStrategy implements QueryLaningStrategy\n+{\n+  @JsonProperty\n+  private Map<String, Integer> lanes;\n+\n+  @JsonProperty\n+  private boolean isLimitPercent;\n+\n+  @JsonCreator\n+  public ManualQueryLaningStrategy(\n+      @JsonProperty(\"lanes\") Map<String, Integer> lanes,\n+      @JsonProperty(\"isLimitPercent\") @Nullable Boolean isLimitPercent\n+  )\n+  {\n+    this.lanes = Preconditions.checkNotNull(lanes, \"lanes must be set\");\n+    this.isLimitPercent = isLimitPercent != null ? isLimitPercent : false;\n+    Preconditions.checkArgument(lanes.size() > 0, \"lanes must define at least one lane\");\n+    Preconditions.checkArgument(\n+        lanes.values().stream().allMatch(x -> this.isLimitPercent ? 0 < x && x <= 100 : x > 0),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkxOTg3MQ=="}, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQwNDk0OQ==", "bodyText": "Hmm I see. Then should this be documented?", "url": "https://github.com/apache/druid/pull/9492#discussion_r392404949", "createdAt": "2020-03-13T18:37:05Z", "author": {"login": "jihoonson"}, "path": "server/src/main/java/org/apache/druid/server/scheduling/ManualQueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.QueryLaningStrategy;\n+\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public class ManualQueryLaningStrategy implements QueryLaningStrategy\n+{\n+  @JsonProperty\n+  private Map<String, Integer> lanes;\n+\n+  @JsonProperty\n+  private boolean isLimitPercent;\n+\n+  @JsonCreator\n+  public ManualQueryLaningStrategy(\n+      @JsonProperty(\"lanes\") Map<String, Integer> lanes,\n+      @JsonProperty(\"isLimitPercent\") @Nullable Boolean isLimitPercent\n+  )\n+  {\n+    this.lanes = Preconditions.checkNotNull(lanes, \"lanes must be set\");\n+    this.isLimitPercent = isLimitPercent != null ? isLimitPercent : false;\n+    Preconditions.checkArgument(lanes.size() > 0, \"lanes must define at least one lane\");\n+    Preconditions.checkArgument(\n+        lanes.values().stream().allMatch(x -> this.isLimitPercent ? 0 < x && x <= 100 : x > 0),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkxOTg3MQ=="}, "originalCommit": {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61"}, "originalPosition": 55}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2614, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}