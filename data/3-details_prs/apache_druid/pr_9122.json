{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5MDg5MDMw", "number": 9122, "title": "Add SQL GROUPING SETS support.", "bodyText": "Built on top of the subtotalsSpec feature in the groupBy query. This also involves\ntwo changes to subtotalsSpec:\n\nAlter behavior so limitSpec is applied after subtotalsSpec, rather than applied to\neach grouping set. This is more in line with SQL standard behavior. I think it is okay\nto make this change, since the old behavior was not documented, so users should\nhopefully not be depending on it.\nFix a bug where virtual columns were included in the subtotal queries, but they\nshould not have been.\n\nAlso fixes two bugs in query equality checking:\n\nBaseQuery: Use getDuration() instead of \"duration\" in equals and hashCode, since the\nlatter is lazily initialized and might be null in one query but not the other.\nGroupByQuery: Include subtotalsSpec in equals and hashCode.\n\nRelease-Notes-Update: subtotalsSpec user with a limitSpec in the query would get a different  ordering of rows as limitSpec is now applied in the end on whole result set instead of result set from individual subtotals.", "createdAt": "2020-01-03T19:03:47Z", "url": "https://github.com/apache/druid/pull/9122", "merged": true, "mergeCommit": {"oid": "c9faf3e148ad1a1931b3fa5e6e7f00fb1370426c"}, "closed": true, "closedAt": "2020-02-26T16:52:39Z", "author": {"login": "gianm"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb2zKTTgH2gAyMzU5MDg5MDMwOjgxYWQzODAxYzQ4MmQwMDI2MDk5OGNkN2Q1YTkyZTQwNjEyNDgwOWI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcH7v0fgH2gAyMzU5MDg5MDMwOjMwNzRiZTgyMDY2M2NkZDZiZTIzOWJhZWE2MzAzZWIzN2E2OTIzMzQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "81ad3801c482d00260998cd7d5a92e406124809b", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/81ad3801c482d00260998cd7d5a92e406124809b", "committedDate": "2020-01-03T19:03:15Z", "message": "Add SQL GROUPING SETS support.\n\nBuilt on top of the subtotalsSpec feature in the groupBy query. This also involves\ntwo changes to subtotalsSpec:\n\n- Alter behavior so limitSpec is applied after subtotalsSpec, rather than applied to\n  each grouping set. This is more in line with SQL standard behavior. I think it is okay\n  to make this change, since the old behavior was not documented, so users should\n  hopefully not be depending on it.\n- Fix a bug where virtual columns were included in the subtotal queries, but they\n  should not have been.\n\nAlso fixes two bugs in query equality checking:\n\n- BaseQuery: Use getDuration() instead of \"duration\" in equals and hashCode, since the\n  latter is lazily initialized and might be null in one query but not the other.\n- GroupByQuery: Include subtotalsSpec in equals and hashCode."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c7cef8e5e54520fa6532f8ba2772e78da07618c", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/3c7cef8e5e54520fa6532f8ba2772e78da07618c", "committedDate": "2020-01-03T20:17:54Z", "message": "Fix bugs."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f", "committedDate": "2020-02-21T19:13:34Z", "message": "Merge branch 'master' into grouping-sets"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNTkzOTQw", "url": "https://github.com/apache/druid/pull/9122#pullrequestreview-363593940", "createdAt": "2020-02-24T18:11:05Z", "commit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "state": "APPROVED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODoxMTowNVrOFtql9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxOToyMDoxNVrOFtsuJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyODA4Nw==", "bodyText": "EqualsVerifier Test for this please", "url": "https://github.com/apache/druid/pull/9122#discussion_r383428087", "createdAt": "2020-02-24T18:11:05Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/GroupByQuery.java", "diffHunk": "@@ -1236,7 +1243,8 @@ public int hashCode()\n         dimFilter,\n         dimensions,\n         aggregatorSpecs,\n-        postAggregatorSpecs\n+        postAggregatorSpecs,\n+        subtotalsSpec", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyOTIzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When using GROUP BY GROUPING SETS, GROUP BY ROLLUP, or GROUP BY CUBE, be aware that results may not be generated in the\n          \n          \n            \n            When using `GROUP BY GROUPING SETS`, `GROUP BY ROLLUP`, or `GROUP BY CUBE`, be aware that results may not be generated in the", "url": "https://github.com/apache/druid/pull/9122#discussion_r383429231", "createdAt": "2020-02-24T18:13:27Z", "author": {"login": "suneet-s"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -86,6 +86,22 @@ trigger an aggregation query using one of Druid's [three native aggregation quer\n can refer to an expression or a select clause ordinal position (like `GROUP BY 2` to group by the second selected\n column).\n \n+The GROUP BY clause can also refer to multiple grouping sets in three ways. The most flexible is GROUP BY GROUPING SETS,\n+for example `GROUP BY GROUPING SETS ( (country, city), () )`. This example is equivalent to a `GROUP BY country, city`\n+followed by `GROUP BY ()` (a grand total). With GROUPING SETS, the underlying data is only scanned one time, leading to\n+better efficiency. Second, GROUP BY ROLLUP computes a grouping set for each level of the grouping expressions. For\n+example `GROUP BY ROLLUP (country, city)` is equivalent to `GROUP BY GROUPING SETS ( (country, city), (country), () )`\n+and will produce grouped rows for each country / city pair, along with subtotals for each country, along with a grand\n+total. Finally, GROUP BY CUBE computes a grouping set for each combination of grouping expressions. For example,\n+`GROUP BY CUBE (country, city)` is equivalent to `GROUP BY GROUPING SETS ( (country, city), (country), (city), () )`.\n+Grouping columns that do not apply to a particular row will contain `NULL`. For example, when computing\n+`GROUP BY GROUPING SETS ( (country, city), () )`, the grand total row corresponding to `()` will have `NULL` for the\n+\"country\" and \"city\" columns.\n+\n+When using GROUP BY GROUPING SETS, GROUP BY ROLLUP, or GROUP BY CUBE, be aware that results may not be generated in the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzMTQ5MQ==", "bodyText": "This is cool...  I learnt some new SQL today \ud83d\udc4d\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            [ GROUP BY [ exprs | GROUPING SETS ( (exprs), ... ) | ROLLUP (exprs) | CUBE (exprs) ] ]\n          \n          \n            \n            [ GROUP BY [ exprs | GROUPING SETS ( \\(exprs\\), ... ) | ROLLUP \\(exprs\\) | CUBE \\(exprs\\) ] ]\n          \n      \n    \n    \n  \n\nBased on the examples below, the parenthesis are required correct?\nI think in other places in the docs parenthesis don't mean literal characters, but you want them to be literal characters here?", "url": "https://github.com/apache/druid/pull/9122#discussion_r383431491", "createdAt": "2020-02-24T18:18:12Z", "author": {"login": "suneet-s"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -65,7 +65,7 @@ Druid SQL supports SELECT queries with the following structure:\n SELECT [ ALL | DISTINCT ] { * | exprs }\n FROM table\n [ WHERE expr ]\n-[ GROUP BY exprs ]\n+[ GROUP BY [ exprs | GROUPING SETS ( (exprs), ... ) | ROLLUP (exprs) | CUBE (exprs) ] ]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MTU4Ng==", "bodyText": "not really part of this change - maybe worth filing an issue for. The with... interface returns a query object, so chaining doesn't really make sense here. Maybe we should consider making that return the Builder so callers can call .build() when they're done setting all the fields. In this example it looks like it creates 4 intermediate GroupByQyery objects and a Builder for each object", "url": "https://github.com/apache/druid/pull/9122#discussion_r383441586", "createdAt": "2020-02-24T18:38:17Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/strategy/GroupByStrategyV2.java", "diffHunk": "@@ -369,13 +374,13 @@ public boolean doMergeResults(final GroupByQuery query)\n                    .map(AggregatorFactory::getCombiningFactory)\n                    .collect(Collectors.toList())\n           )\n-          .withSubtotalsSpec(null)\n-          .withDimFilter(null);\n-\n+          .withVirtualColumns(VirtualColumns.EMPTY)\n+          .withDimFilter(null)\n+          .withSubtotalsSpec(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1MzUwOQ==", "bodyText": "nit: it's cheaper to check if havingFilter != null before checking hasEffect", "url": "https://github.com/apache/druid/pull/9122#discussion_r383453509", "createdAt": "2020-02-24T19:01:18Z", "author": {"login": "suneet-s"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQuery.java", "diffHunk": "@@ -706,7 +722,9 @@ private Query computeQuery()\n   @Nullable\n   public TimeseriesQuery toTimeseriesQuery()\n   {\n-    if (grouping == null || grouping.getHavingFilter() != null) {\n+    if (grouping == null\n+        || grouping.getSubtotals().hasEffect(grouping.getDimensionSpecs())\n+        || grouping.getHavingFilter() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1Nzg2Ng==", "bodyText": "equals and hashCode for List<List> can be expensive. Is this concerning? Should we create a memoized string that represents the lists  so that the check can be faster? Or is that overkill?", "url": "https://github.com/apache/druid/pull/9122#discussion_r383457866", "createdAt": "2020-02-24T19:10:03Z", "author": {"login": "suneet-s"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/Subtotals.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rel;\n+\n+\n+import it.unimi.dsi.fastutil.ints.IntList;\n+import org.apache.druid.query.dimension.DimensionSpec;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Represents the Druid groupBy query concept of subtotals, which is similar to GROUPING SETS.\n+ */\n+public class Subtotals\n+{\n+  /**\n+   * List of subtotals: each one is a list of dimension indexes. (i.e. [0, 1] means use the first and second\n+   * dimensions).\n+   */\n+  private final List<IntList> subtotals;\n+\n+  Subtotals(List<IntList> subtotals)\n+  {\n+    this.subtotals = subtotals;\n+  }\n+\n+  public List<IntList> getSubtotals()\n+  {\n+    return subtotals;\n+  }\n+\n+  @Nullable\n+  public List<List<String>> toSubtotalsSpec(final List<DimensionSpec> dimensions)\n+  {\n+    if (hasEffect(dimensions)) {\n+      return subtotals.stream()\n+                      .map(\n+                          subtotalInts -> {\n+                            final List<String> subtotalDimensionNames = new ArrayList<>();\n+                            for (int dimIndex : subtotalInts) {\n+                              subtotalDimensionNames.add(dimensions.get(dimIndex).getOutputName());\n+                            }\n+                            return subtotalDimensionNames;\n+                          }\n+                      )\n+                      .collect(Collectors.toList());\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Returns whether this subtotals spec has an effect, and cannot be ignored.\n+   */\n+  public boolean hasEffect(final List<DimensionSpec> dimensionSpecs)\n+  {\n+    if (subtotals.isEmpty() || (subtotals.size() == 1 && subtotals.get(0).size() == dimensionSpecs.size())) {\n+      return false;\n+    } else {\n+      return true;\n+    }\n+  }\n+\n+  @Override\n+  public boolean equals(Object o)\n+  {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    Subtotals subtotals1 = (Subtotals) o;\n+    return subtotals.equals(subtotals1.subtotals);\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Objects.hash(subtotals);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2MTg4NQ==", "bodyText": "\ud83d\udc4d nice tests!\nIs GROUPING SETS ( (dummy) ) === GROUPING SETS ( () ) or should it fail?", "url": "https://github.com/apache/druid/pull/9122#discussion_r383461885", "createdAt": "2020-02-24T19:18:12Z", "author": {"login": "suneet-s"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -9579,6 +9600,538 @@ public void testGroupByTimeAndOtherDimension() throws Exception\n     );\n   }\n \n+  @Test\n+  public void testGroupingSets() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (dim2, gran), (dim2), (gran), () )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\", \"v1\"),\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", timestamp(\"2000-01-01\"), 2L},\n+            new Object[]{\"\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2000-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"abc\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithNumericDimension() throws Exception\n+  {\n+    testQuery(\n+        \"SELECT cnt, COUNT(*)\\n\"\n+        + \"FROM foo\\n\"\n+        + \"GROUP BY GROUPING SETS ( (cnt), () )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setDimensions(dimensions(new DefaultDimensionSpec(\"cnt\", \"d0\", ValueType.LONG)))\n+                        .setAggregatorSpecs(aggregators(new CountAggregatorFactory(\"a0\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"d0\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{1L, 6L},\n+            new Object[]{null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupByRollup() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY ROLLUP (dim2, gran)\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\", \"v1\"),\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", timestamp(\"2000-01-01\"), 2L},\n+            new Object[]{\"\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2000-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"abc\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupByCube() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY CUBE (dim2, gran)\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\", \"v1\"),\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", timestamp(\"2000-01-01\"), 2L},\n+            new Object[]{\"\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2000-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"abc\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithDummyDimension() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (dim2, 'dummy', gran), (dim2), (gran), ('dummy') )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v2\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v2\", \"v2\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\", \"v2\"),\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(),\n+                                ImmutableList.of(\"v2\")\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", timestamp(\"2000-01-01\"), 2L},\n+            new Object[]{\"\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2000-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"abc\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, null, 6L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsNoSuperset() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    // Note: the grouping sets are reordered in the output of this query, but this is allowed.\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (), (dim2), (gran) )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithOrderByDimension() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (), (dim2), (gran) )\\n\"\n+        + \"ORDER BY gran, dim2 DESC\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setLimitSpec(\n+                            new DefaultLimitSpec(\n+                                ImmutableList.of(\n+                                    new OrderByColumnSpec(\n+                                        \"v1\",\n+                                        Direction.ASCENDING,\n+                                        StringComparators.NUMERIC\n+                                    ),\n+                                    new OrderByColumnSpec(\n+                                        \"v0\",\n+                                        Direction.DESCENDING,\n+                                        StringComparators.LEXICOGRAPHIC\n+                                    )\n+                                ),\n+                                Integer.MAX_VALUE\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{NULL_VALUE, null, 6L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithOrderByAggregator() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (), (dim2), (gran) )\\n\"\n+        + \"ORDER BY SUM(cnt)\\n\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setLimitSpec(\n+                            new DefaultLimitSpec(\n+                                ImmutableList.of(\n+                                    new OrderByColumnSpec(\n+                                        \"a0\",\n+                                        Direction.ASCENDING,\n+                                        StringComparators.NUMERIC\n+                                    )\n+                                ),\n+                                Integer.MAX_VALUE\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithOrderByAggregatorWithLimit() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (), (dim2), (gran) )\\n\"\n+        + \"ORDER BY SUM(cnt)\\n\"\n+        + \"LIMIT 1\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setLimitSpec(\n+                            new DefaultLimitSpec(\n+                                ImmutableList.of(\n+                                    new OrderByColumnSpec(\n+                                        \"a0\",\n+                                        Direction.ASCENDING,\n+                                        StringComparators.NUMERIC\n+                                    )\n+                                ),\n+                                1\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"abc\", null, 1L}\n+        )\n+    );\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 563}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2Mjk1MA==", "bodyText": "Maybe add a test for ROLLUP (gran, dim2) ie reverse order of the select columns. Not sure if we need the same thing for CUBE since it generates the same grouping sets with the reverse order.", "url": "https://github.com/apache/druid/pull/9122#discussion_r383462950", "createdAt": "2020-02-24T19:20:15Z", "author": {"login": "suneet-s"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -9579,6 +9600,538 @@ public void testGroupByTimeAndOtherDimension() throws Exception\n     );\n   }\n \n+  @Test\n+  public void testGroupingSets() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (dim2, gran), (dim2), (gran), () )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\", \"v1\"),\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", timestamp(\"2000-01-01\"), 2L},\n+            new Object[]{\"\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2000-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"abc\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithNumericDimension() throws Exception\n+  {\n+    testQuery(\n+        \"SELECT cnt, COUNT(*)\\n\"\n+        + \"FROM foo\\n\"\n+        + \"GROUP BY GROUPING SETS ( (cnt), () )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setDimensions(dimensions(new DefaultDimensionSpec(\"cnt\", \"d0\", ValueType.LONG)))\n+                        .setAggregatorSpecs(aggregators(new CountAggregatorFactory(\"a0\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"d0\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{1L, 6L},\n+            new Object[]{null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupByRollup() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY ROLLUP (dim2, gran)\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 132}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3b0a415b9e79bc880ee9d1b6191a471efe23935", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/a3b0a415b9e79bc880ee9d1b6191a471efe23935", "committedDate": "2020-02-25T02:08:59Z", "message": "Merge branch 'master' into grouping-sets"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9ede1a829a486872daa7744949e822d28e288d7", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/a9ede1a829a486872daa7744949e822d28e288d7", "committedDate": "2020-02-25T02:17:35Z", "message": "Fix tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "922263425044d473f919565b5e5dae2b6313d43f", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/922263425044d473f919565b5e5dae2b6313d43f", "committedDate": "2020-02-25T19:57:38Z", "message": "PR updates."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NDYwMTM0", "url": "https://github.com/apache/druid/pull/9122#pullrequestreview-364460134", "createdAt": "2020-02-25T21:26:51Z", "commit": {"oid": "922263425044d473f919565b5e5dae2b6313d43f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTI1NDgx", "url": "https://github.com/apache/druid/pull/9122#pullrequestreview-364525481", "createdAt": "2020-02-25T23:28:57Z", "commit": {"oid": "922263425044d473f919565b5e5dae2b6313d43f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTI2MTQw", "url": "https://github.com/apache/druid/pull/9122#pullrequestreview-364526140", "createdAt": "2020-02-25T23:30:37Z", "commit": {"oid": "922263425044d473f919565b5e5dae2b6313d43f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzozMDozN1rOFuZIOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzozNTowOFrOFuZPdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5MDUyMQ==", "bodyText": "Should havingFilter be annotated with @Nullable for this method as well?", "url": "https://github.com/apache/druid/pull/9122#discussion_r384190521", "createdAt": "2020-02-25T23:30:37Z", "author": {"login": "ccaominh"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/Grouping.java", "diffHunk": "@@ -92,19 +104,25 @@ private Grouping(\n \n   public static Grouping create(\n       final List<DimensionExpression> dimensions,\n+      final Subtotals subtotals,\n       final List<Aggregation> aggregations,\n       final DimFilter havingFilter,\n       final RowSignature outputRowSignature\n   )\n   {\n-    return new Grouping(dimensions, aggregations, havingFilter, outputRowSignature);\n+    return new Grouping(dimensions, subtotals, aggregations, havingFilter, outputRowSignature);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "922263425044d473f919565b5e5dae2b6313d43f"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5MjM3Mw==", "bodyText": "Is there a test for this?", "url": "https://github.com/apache/druid/pull/9122#discussion_r384192373", "createdAt": "2020-02-25T23:35:08Z", "author": {"login": "ccaominh"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/Grouping.java", "diffHunk": "@@ -141,36 +159,95 @@ public RowSignature getOutputRowSignature()\n     return outputRowSignature;\n   }\n \n+  /**\n+   * Applies a post-grouping projection.\n+   *\n+   * @see DruidQuery#computeGrouping which uses this\n+   */\n+  public Grouping applyProject(final PlannerContext plannerContext, final Project project)\n+  {\n+    final List<DimensionExpression> newDimensions = new ArrayList<>();\n+    final List<Aggregation> newAggregations = new ArrayList<>(aggregations);\n+    final Subtotals newSubtotals;\n+\n+    final Projection postAggregationProjection = Projection.postAggregation(\n+        project,\n+        plannerContext,\n+        outputRowSignature,\n+        \"p\"\n+    );\n+\n+    postAggregationProjection.getPostAggregators().forEach(\n+        postAggregator -> newAggregations.add(Aggregation.create(postAggregator))\n+    );\n+\n+    // Remove literal dimensions that did not appear in the projection. This is useful for queries\n+    // like \"SELECT COUNT(*) FROM tbl GROUP BY 'dummy'\" which some tools can generate, and for which we don't\n+    // actually want to include a dimension 'dummy'.\n+    final ImmutableBitSet aggregateProjectBits = RelOptUtil.InputFinder.bits(project.getChildExps(), null);\n+    final int[] newDimIndexes = new int[dimensions.size()];\n+\n+    for (int i = 0; i < dimensions.size(); i++) {\n+      final DimensionExpression dimension = dimensions.get(i);\n+      if (Parser.parse(dimension.getDruidExpression().getExpression(), plannerContext.getExprMacroTable())\n+                .isLiteral() && !aggregateProjectBits.get(i)) {\n+        newDimIndexes[i] = -1;\n+      } else {\n+        newDimIndexes[i] = newDimensions.size();\n+        newDimensions.add(dimension);\n+      }\n+    }\n+\n+    // Renumber subtotals, if needed, to account for removed dummy dimensions.\n+    if (newDimensions.size() != dimensions.size()) {\n+      final List<IntList> newSubtotalsList = new ArrayList<>();\n+\n+      for (IntList subtotal : subtotals.getSubtotals()) {\n+        final IntList newSubtotal = new IntArrayList();\n+        for (int dimIndex : subtotal) {\n+          final int newDimIndex = newDimIndexes[dimIndex];\n+          if (newDimIndex >= 0) {\n+            newSubtotal.add(newDimIndex);\n+          }\n+        }\n+\n+        newSubtotalsList.add(newSubtotal);\n+      }\n+\n+      newSubtotals = new Subtotals(newSubtotalsList);\n+    } else {\n+      newSubtotals = subtotals;\n+    }\n+\n+    return Grouping.create(\n+        newDimensions,\n+        newSubtotals,\n+        newAggregations,\n+        havingFilter,\n+        postAggregationProjection.getOutputRowSignature()\n+    );\n+  }\n+\n   @Override\n-  public boolean equals(final Object o)\n+  public boolean equals(Object o)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "922263425044d473f919565b5e5dae2b6313d43f"}, "originalPosition": 157}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3074be820663cdd6be239baea6303eb37a692334", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/3074be820663cdd6be239baea6303eb37a692334", "committedDate": "2020-02-26T00:40:11Z", "message": "Grouping class hygiene."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3835, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}