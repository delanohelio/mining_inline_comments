{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzNTExOTMw", "number": 10027, "title": "fix query memory leak", "bodyText": "Description\nThis PR fix a bug where we can not release resources when accumulate someone segments occurs exception .\nReason\nBecause we can not cancel all futures in the com.google.common.util.concurrent.Futures.CombinedFuture immediately when exception occurs in someone future by using CombinedFuture.cancel(boolean mayInterruptIfRunning)  simply.\nLet's see a code example:\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.common.util.concurrent.ListeningExecutorService;\nimport com.google.common.util.concurrent.MoreExecutors;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Function;\n\npublic class GuavaFutureTest {\n\n\tpublic static void main(String[] args) {\n\t\tExecutorService service = Executors.newFixedThreadPool(3);\n\t\tListeningExecutorService exc = MoreExecutors.listeningDecorator(service);\n\t\tint tasks = 3;\n\t\tint cancelCount = 10;\n\t\tAtomicInteger index = new AtomicInteger(0);\n\t\tFunction<Integer, List<ListenableFuture<Object>>> function = (c) -> {\n\t\t\tList<ListenableFuture<Object>> futures = new ArrayList<>();\n\t\t\tfor(int i = 0; i < c; i++){\n\t\t\t\tListenableFuture<Object> future = exc.submit(new Callable<Object>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object call() throws Exception {\n\t\t\t\t\t\tAtomicBoolean interupted = new AtomicBoolean(false);\n\t\t\t\t\t\twhile (true && !interupted.get()){\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif(index.get() == cancelCount){\n\t\t\t\t\t\t\t\t\t//here we simulate occurs exception in some one future.\n\t\t\t\t\t\t\t\t\tthrow new RuntimeException(\"A big bug\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//print something to say the task still active.\n\t\t\t\t\t\t\t\tSystem.out.println(String.format(\"Thread[id=%s] running. %s\", Thread.currentThread().getId(), System.currentTimeMillis()));\n\t\t\t\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t\t\t\t\tindex.getAndIncrement();\n\t\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t\tinterupted.set(true);\n\t\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tfutures.add(future);\n\t\t\t}\n\t\t\treturn futures;\n\t\t};\n\n\t\tList<ListenableFuture<Object>> futures = function.apply(tasks);\n\n\t\tListenableFuture future = Futures.allAsList(futures);\n\t\ttry{\n\t\t\tfuture.get();\n\t\t}catch(Exception e){\n\t\t\tSystem.err.println(e);\n\t\t\t// here we try to cancel all tasks. however, we can see all tasks is printing message.\n\t\t\tfuture.cancel(true);\n\t\t\tSystem.out.println(\"all task should be cancelled.\");\n\t\t}\n\t}\n\n}\n\nHere is the console messages:\nThread[id=15] running. 1591945237078\nThread[id=13] running. 1591945237078\nThread[id=14] running. 1591945238078\nThread[id=13] running. 1591945241988\nall task should be cancelled.\nThread[id=14] running. 1591945241988\njava.util.concurrent.ExecutionException: java.lang.RuntimeException: A big bug\nThread[id=13] running. 1591945242988\nThread[id=14] running. 1591945242988\nThread[id=13] running. 1591945243988\nThread[id=14] running. 1591945243989\n\nI had test it from guava[version=16.0.1] to  the latest guava[version=29.0]. it's the same result.\nAccords to source code in guava[version=16.0.1], when someone future occurs error, it will set the state of combineFuture from RUNNING to COMPLETED immediately(method stack\nCombinedFuture.init()\n-> CombinedFuture.setOneValue() \n-> CombinedFuture.setExceptionAndMaybeLog() \n-> AbstractFuture.setException() -\n-> AbstractFuture.Sync.setException() \n->  AbstractFuture.Sync.complete()\n\n).\nThus when we use cancel() method which try to set state from RUNNING to ''INTERRUPTED|COMPLETED\" through CAS operation to stop all tasks, it will failed, because the state is not RUNNING anymore.\nSolution\nwe cancel all compute task manually.\n\nThis PR has:\n\n been self-reviewed.\n\n using the concurrency checklist (Remove this item if the PR doesn't have any relation to concurrency.)\n\n\n added documentation for new or modified features or behaviors.\n added Javadocs for most classes and all non-trivial methods. Linked related entities via Javadoc links.\n added or updated version, license, or notice information in licenses.yaml\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.\n added unit tests or modified existing tests to cover new code paths, ensuring the threshold for code coverage is met.\n added integration tests.\n been tested in a test Druid cluster.", "createdAt": "2020-06-12T07:24:58Z", "url": "https://github.com/apache/druid/pull/10027", "merged": true, "mergeCommit": {"oid": "a4c6d5f37e88a8152967ba68b150fcf4077092cf"}, "closed": true, "closedAt": "2020-06-27T06:31:00Z", "author": {"login": "chenyuzhi459"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcqcoA8gH2gAyNDMzNTExOTMwOmRjYmYwMmI4OWExNmZmY2RlOTQxYzNlMTY5MTdkNzUxMDM4ZjI3N2Y=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcvR3PngFqTQzODY3NzA5MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "dcbf02b89a16ffcde941c3e16917d751038f277f", "author": {"user": {"login": "chenyuzhi459", "name": null}}, "url": "https://github.com/apache/druid/commit/dcbf02b89a16ffcde941c3e16917d751038f277f", "committedDate": "2020-06-12T06:11:57Z", "message": "fix query memory leak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64698dd54627c1072651216468584d5648cd6ed4", "author": {"user": {"login": "chenyuzhi459", "name": null}}, "url": "https://github.com/apache/druid/commit/64698dd54627c1072651216468584d5648cd6ed4", "committedDate": "2020-06-12T08:04:05Z", "message": "rollup ./idea"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d390def22edc9f0dcb561d729fc30797f4a6956", "author": {"user": {"login": "chenyuzhi459", "name": null}}, "url": "https://github.com/apache/druid/commit/8d390def22edc9f0dcb561d729fc30797f4a6956", "committedDate": "2020-06-12T08:07:03Z", "message": "roll up ./idea dir"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5df370bdadee598ba3e90036c9cf25c0e49d3ca7", "author": {"user": {"login": "chenyuzhi459", "name": null}}, "url": "https://github.com/apache/druid/commit/5df370bdadee598ba3e90036c9cf25c0e49d3ca7", "committedDate": "2020-06-12T08:25:09Z", "message": "roll up .idea"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "341546694389b219bc887e425ad5ee89e7958e7d", "author": {"user": {"login": "chenyuzhi459", "name": null}}, "url": "https://github.com/apache/druid/commit/341546694389b219bc887e425ad5ee89e7958e7d", "committedDate": "2020-06-12T08:27:18Z", "message": "clean code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c82bda7d6f5dc6465797c61b12dafd8775fbf06b", "author": {"user": {"login": "chenyuzhi459", "name": null}}, "url": "https://github.com/apache/druid/commit/c82bda7d6f5dc6465797c61b12dafd8775fbf06b", "committedDate": "2020-06-12T13:02:12Z", "message": "optimize style"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMTQyNTY1", "url": "https://github.com/apache/druid/pull/10027#pullrequestreview-431142565", "createdAt": "2020-06-16T03:56:56Z", "commit": {"oid": "c82bda7d6f5dc6465797c61b12dafd8775fbf06b"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwMzo1Njo1NlrOGkKYZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNDowMjoxNVrOGkKczA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3MjAwNA==", "bodyText": "Can f.cancel(true) throw an exception? I'm not sure, but if so I guess we should catch it and keep canceling more futures.", "url": "https://github.com/apache/druid/pull/10027#discussion_r440572004", "createdAt": "2020-06-16T03:56:56Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/query/ChainedExecutionQueryRunner.java", "diffHunk": "@@ -141,34 +142,38 @@ public ChainedExecutionQueryRunner(\n                           );\n                         }\n                     )\n-                )\n-            );\n+                );\n \n-            queryWatcher.registerQueryFuture(query, futures);\n+            Function<Throwable, Void> cancelFunction = (t) -> {\n+              futures.forEach(f -> f.cancel(true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c82bda7d6f5dc6465797c61b12dafd8775fbf06b"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3MjIwNQ==", "bodyText": "This little block is used in a few places, and it would be good to include comments about why it's needed.\nCould you please move it to GuavaUtils and also make the following changes:\n\nAdd a comment about why it's needed: it's an alternative to Futures.allAsList(...).cancel, that is necessary because Futures.allAsList creates a Future that cannot be canceled if one of its constituent futures has already failed. (This comment is the real reason that it's good to have it be its own function.)\nThe function isn't doing anything with the Throwable, so it could just be void cancelAll(List<Future<T>>).\nAdd unit tests to GuavaUtilsTest.\n\nThen we can do stuff like GuavaUtils.cancelAll(futures).", "url": "https://github.com/apache/druid/pull/10027#discussion_r440572205", "createdAt": "2020-06-16T03:57:57Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/query/ChainedExecutionQueryRunner.java", "diffHunk": "@@ -141,34 +142,38 @@ public ChainedExecutionQueryRunner(\n                           );\n                         }\n                     )\n-                )\n-            );\n+                );\n \n-            queryWatcher.registerQueryFuture(query, futures);\n+            Function<Throwable, Void> cancelFunction = (t) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c82bda7d6f5dc6465797c61b12dafd8775fbf06b"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3MzEzMg==", "bodyText": "Similar comments as in ChainedExecutionQueryRunner about GuavaUtils.", "url": "https://github.com/apache/druid/pull/10027#discussion_r440573132", "createdAt": "2020-06-16T04:02:15Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/query/GroupByMergedQueryRunner.java", "diffHunk": "@@ -173,11 +173,16 @@ public T apply(Row input)\n \n   private void waitForFutureCompletion(\n       GroupByQuery query,\n-      ListenableFuture<?> future,\n+      List<ListenableFuture<Void>> futures,\n       IncrementalIndex<?> closeOnFailure\n   )\n   {\n+    Function<Throwable, Void> cancelFunction = (t) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c82bda7d6f5dc6465797c61b12dafd8775fbf06b"}, "originalPosition": 44}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "894e975399b4e9ce3552242790c40b68b4193fca", "author": {"user": {"login": "chenyuzhi459", "name": null}}, "url": "https://github.com/apache/druid/commit/894e975399b4e9ce3552242790c40b68b4193fca", "committedDate": "2020-06-17T15:24:07Z", "message": "optimize cancel function"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNzA0ODcz", "url": "https://github.com/apache/druid/pull/10027#pullrequestreview-432704873", "createdAt": "2020-06-17T19:21:36Z", "commit": {"oid": "894e975399b4e9ce3552242790c40b68b4193fca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOToyMTozNlrOGlUFTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOToyMTozNlrOGlUFTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3OTUzNA==", "bodyText": "We shouldn't chomp Throwables, because they're generally bad things that should interrupt execution. It'd be better to either assume no exceptions, i.e.:\nfutures.forEach(f -> f.cancel(true));\nOr surface Errors, but suppress and log exceptions:\nfutures.forEach(f -> {\n  try {\n    f.cancel(true);\n  } catch (Exception e) {\n    log.warn(e, \"Error while canceling future.\");\n  }\n});\nIMO, the first one is best if we can assure ourselves that ListenableFuture.cancel isn't going to throw exceptions. Looking at AbstractFuture, it seems like it won't, so the first option looks safe to me.", "url": "https://github.com/apache/druid/pull/10027#discussion_r441779534", "createdAt": "2020-06-17T19:21:36Z", "author": {"login": "gianm"}, "path": "core/src/main/java/org/apache/druid/common/guava/GuavaUtils.java", "diffHunk": "@@ -77,4 +79,24 @@ public static Long tryParseLong(@Nullable String string)\n     }\n     return arg1;\n   }\n+\n+  /**\n+   * Cancel futures manually, because sometime we can't cancel all futures in {@link com.google.common.util.concurrent.Futures.CombinedFuture}\n+   * automatically. Especially when we call {@link  com.google.common.util.concurrent.Futures#allAsList(Iterable)} to create a batch of\n+   * future.\n+   * @param futures The futures that we want to cancel\n+   * @param <T>   The result type returned by this Future's {@code get} method\n+   */\n+  public static <T, F  extends Future<T>> void cancelAll(List<F> futures){\n+    if(futures == null || futures.isEmpty()){\n+      return;\n+    }\n+    futures.forEach(f -> {\n+      try {\n+        f.cancel(true);\n+      } catch (Throwable t){\n+        //do nothing and continue the loop.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "894e975399b4e9ce3552242790c40b68b4193fca"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c52185e1aa34763eab4dd9902e609b8a7fd474f", "author": {"user": {"login": "chenyuzhi459", "name": null}}, "url": "https://github.com/apache/druid/commit/4c52185e1aa34763eab4dd9902e609b8a7fd474f", "committedDate": "2020-06-18T02:28:54Z", "message": "optimize style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "166fc326d71109719a1750c3d1c88fc217ae3b8b", "author": {"user": {"login": "chenyuzhi459", "name": null}}, "url": "https://github.com/apache/druid/commit/166fc326d71109719a1750c3d1c88fc217ae3b8b", "committedDate": "2020-06-18T14:42:24Z", "message": "add concurrentGroupTest test case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af9508b3435627162f99db79e3984a5312a54690", "author": {"user": {"login": "chenyuzhi459", "name": null}}, "url": "https://github.com/apache/druid/commit/af9508b3435627162f99db79e3984a5312a54690", "committedDate": "2020-06-18T16:38:58Z", "message": "add test case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2c07e3b815d17e2d5839cf5a624bad56e70cece", "author": {"user": {"login": "chenyuzhi459", "name": null}}, "url": "https://github.com/apache/druid/commit/f2c07e3b815d17e2d5839cf5a624bad56e70cece", "committedDate": "2020-06-19T16:29:09Z", "message": "add unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9114052a29755adc61681eba2e6538f75011f5a0", "author": {"user": {"login": "chenyuzhi459", "name": null}}, "url": "https://github.com/apache/druid/commit/9114052a29755adc61681eba2e6538f75011f5a0", "committedDate": "2020-06-20T03:39:01Z", "message": "fix code style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7734da50f0385ff92d8ace7bbeb56e25e83f1772", "author": {"user": {"login": "chenyuzhi459", "name": null}}, "url": "https://github.com/apache/druid/commit/7734da50f0385ff92d8ace7bbeb56e25e83f1772", "committedDate": "2020-06-23T09:35:07Z", "message": "optimize cancell method use"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0941b7816db0a606fe12eea8e0a1066268054ab", "author": {"user": {"login": "chenyuzhi459", "name": null}}, "url": "https://github.com/apache/druid/commit/c0941b7816db0a606fe12eea8e0a1066268054ab", "committedDate": "2020-06-23T13:49:21Z", "message": "format code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fc9d5036af8003f1a576ccab128b57571ad03fd", "author": {"user": {"login": "chenyuzhi459", "name": null}}, "url": "https://github.com/apache/druid/commit/7fc9d5036af8003f1a576ccab128b57571ad03fd", "committedDate": "2020-06-24T02:24:02Z", "message": "reback code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NzA2ODUz", "url": "https://github.com/apache/druid/pull/10027#pullrequestreview-437706853", "createdAt": "2020-06-25T17:26:25Z", "commit": {"oid": "7fc9d5036af8003f1a576ccab128b57571ad03fd"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNzoyNjoyNlrOGpEmEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNzozNDo1N1rOGpE5Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyMDA4MQ==", "bodyText": "It seems easy to forget canceling future and so error-prone. How about modifying GuavaUtils.cancelAll() to take future as well? So it would be like\n  public static <F extends Future<?>> void cancelAll(\n      boolean mayInterruptIfRunning,\n      @Nullable ListenableFuture<?> combinedFuture,\n      List<F> futures\n  )\n  {\n    final List<Future> allFuturesToCancel = new ArrayList<>(futures);\n    allFuturesToCancel.add(combinedFuture);\n    if (allFuturesToCancel.isEmpty()) {\n      return;\n    }\n    allFuturesToCancel.forEach(f -> {\n      try {\n        f.cancel(mayInterruptIfRunning);\n      }\n      catch (Throwable t) {\n        log.warn(t, \"Error while cancelling future.\");\n      }\n    });\n  }", "url": "https://github.com/apache/druid/pull/10027#discussion_r445720081", "createdAt": "2020-06-25T17:26:26Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/ChainedExecutionQueryRunner.java", "diffHunk": "@@ -141,33 +144,34 @@ public ChainedExecutionQueryRunner(\n                           );\n                         }\n                     )\n-                )\n-            );\n+                );\n \n-            queryWatcher.registerQueryFuture(query, futures);\n+            ListenableFuture<List<Iterable<T>>> future = Futures.allAsList(futures);\n+            queryWatcher.registerQueryFuture(query, future);\n \n             try {\n               return new MergeIterable<>(\n                   ordering.nullsFirst(),\n                   QueryContexts.hasTimeout(query) ?\n-                      futures.get(QueryContexts.getTimeout(query), TimeUnit.MILLISECONDS) :\n-                      futures.get()\n+                      future.get(QueryContexts.getTimeout(query), TimeUnit.MILLISECONDS) :\n+                      future.get()\n               ).iterator();\n             }\n             catch (InterruptedException e) {\n               log.noStackTrace().warn(e, \"Query interrupted, cancelling pending results, query id [%s]\", query.getId());\n-              futures.cancel(true);\n+              GuavaUtils.cancelAll(true, ImmutableList.<Future>builder().add(future).addAll(futures).build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fc9d5036af8003f1a576ccab128b57571ad03fd"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyMDQ3NA==", "bodyText": "Or, more structured way to do could be adding a new CombinedFuture like this\n  public static class CombinedFuture<V> implements Future<List<V>>\n  {\n    private final List<ListenableFuture<V>> underlyingFutures;\n    private final ListenableFuture<List<V>> combined;\n    \n    public CombinedFuture(List<ListenableFuture<V>> futures)\n    {\n      this.underlyingFutures = futures;\n      this.combined = Futures.allAsList(futures);\n    }\n\n    @Override\n    public boolean cancel(boolean mayInterruptIfRunning)\n    {\n      if (combined.isDone() || combined.isCancelled()) {\n        return false;\n      } else {\n        cancelAll(mayInterruptIfRunning, combined, underlyingFutures);\n        return true;\n      }\n    }\n\n    @Override\n    public boolean isCancelled()\n    {\n      return combined.isCancelled();\n    }\n\n    @Override\n    public boolean isDone()\n    {\n      return combined.isDone();\n    }\n\n    @Override\n    public List<V> get() throws InterruptedException, ExecutionException\n    {\n      return combined.get();\n    }\n\n    @Override\n    public List<V> get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException\n    {\n      return combined.get(timeout, unit);\n    }\n  }\nI'm fine with either way.", "url": "https://github.com/apache/druid/pull/10027#discussion_r445720474", "createdAt": "2020-06-25T17:27:09Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/ChainedExecutionQueryRunner.java", "diffHunk": "@@ -141,33 +144,34 @@ public ChainedExecutionQueryRunner(\n                           );\n                         }\n                     )\n-                )\n-            );\n+                );\n \n-            queryWatcher.registerQueryFuture(query, futures);\n+            ListenableFuture<List<Iterable<T>>> future = Futures.allAsList(futures);\n+            queryWatcher.registerQueryFuture(query, future);\n \n             try {\n               return new MergeIterable<>(\n                   ordering.nullsFirst(),\n                   QueryContexts.hasTimeout(query) ?\n-                      futures.get(QueryContexts.getTimeout(query), TimeUnit.MILLISECONDS) :\n-                      futures.get()\n+                      future.get(QueryContexts.getTimeout(query), TimeUnit.MILLISECONDS) :\n+                      future.get()\n               ).iterator();\n             }\n             catch (InterruptedException e) {\n               log.noStackTrace().warn(e, \"Query interrupted, cancelling pending results, query id [%s]\", query.getId());\n-              futures.cancel(true);\n+              GuavaUtils.cancelAll(true, ImmutableList.<Future>builder().add(future).addAll(futures).build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyMDA4MQ=="}, "originalCommit": {"oid": "7fc9d5036af8003f1a576ccab128b57571ad03fd"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyMTQ1OQ==", "bodyText": "nit: future should be canceled on exceptions too. This is nit since this class is used only by groupBy v1 which is deprecated.", "url": "https://github.com/apache/druid/pull/10027#discussion_r445721459", "createdAt": "2020-06-25T17:28:46Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/GroupByMergedQueryRunner.java", "diffHunk": "@@ -187,7 +189,7 @@ private void waitForFutureCompletion(\n     }\n     catch (InterruptedException e) {\n       log.warn(e, \"Query interrupted, cancelling pending results, query id [%s]\", query.getId());\n-      future.cancel(true);\n+      GuavaUtils.cancelAll(true, futures);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fc9d5036af8003f1a576ccab128b57571ad03fd"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyNTAyMw==", "bodyText": "nit: the variable name starting with an underscore is not Java convention. How about mergedRunner?", "url": "https://github.com/apache/druid/pull/10027#discussion_r445725023", "createdAt": "2020-06-25T17:34:57Z", "author": {"login": "jihoonson"}, "path": "processing/src/test/java/org/apache/druid/query/groupby/GroupByQueryRunnerFailureTest.java", "diffHunk": "@@ -281,4 +281,41 @@ public void testInsufficientResourcesOnBroker()\n       }\n     }\n   }\n+\n+  @Test(timeout = 60_000L)\n+  public void testTimeoutExceptionOnQueryable()\n+  {\n+    expectedException.expect(QueryInterruptedException.class);\n+    expectedException.expectCause(CoreMatchers.instanceOf(TimeoutException.class));\n+\n+    final GroupByQuery query = GroupByQuery\n+        .builder()\n+        .setDataSource(QueryRunnerTestHelper.DATA_SOURCE)\n+        .setQuerySegmentSpec(QueryRunnerTestHelper.FIRST_TO_THIRD)\n+        .setDimensions(new DefaultDimensionSpec(\"quality\", \"alias\"))\n+        .setAggregatorSpecs(new LongSumAggregatorFactory(\"rows\", \"rows\"))\n+        .setGranularity(QueryRunnerTestHelper.DAY_GRAN)\n+        .overrideContext(ImmutableMap.of(QueryContexts.TIMEOUT_KEY, 1))\n+        .build();\n+\n+    GroupByQueryRunnerFactory factory = makeQueryRunnerFactory(\n+        GroupByQueryRunnerTest.DEFAULT_MAPPER,\n+        new GroupByQueryConfig()\n+        {\n+          @Override\n+          public String getDefaultStrategy()\n+          {\n+            return \"v2\";\n+          }\n+\n+          @Override\n+          public boolean isSingleThreaded()\n+          {\n+            return true;\n+          }\n+        }\n+    );\n+    QueryRunner<ResultRow> _runnnner = factory.mergeRunners(Execs.directExecutor(), ImmutableList.of(runner));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fc9d5036af8003f1a576ccab128b57571ad03fd"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ff5917185ea805d14b136a2aeb82aebf8f36dff", "author": {"user": {"login": "chenyuzhi459", "name": null}}, "url": "https://github.com/apache/druid/commit/2ff5917185ea805d14b136a2aeb82aebf8f36dff", "committedDate": "2020-06-26T14:10:11Z", "message": "optimize cancelAll"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a51d7e16f5f15af33fa239419aaa82bffb99f8f5", "author": {"user": {"login": "chenyuzhi459", "name": null}}, "url": "https://github.com/apache/druid/commit/a51d7e16f5f15af33fa239419aaa82bffb99f8f5", "committedDate": "2020-06-26T15:38:12Z", "message": "clean code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NDU2MDI0", "url": "https://github.com/apache/druid/pull/10027#pullrequestreview-438456024", "createdAt": "2020-06-26T17:02:21Z", "commit": {"oid": "a51d7e16f5f15af33fa239419aaa82bffb99f8f5"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNzowMjoyMVrOGpoOuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNzo0MzozM1rOGppbRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMwMzkzMQ==", "bodyText": "[ERROR] /home/travis/build/apache/druid/core/src/main/java/org/apache/druid/common/guava/GuavaUtils.java:26: 'javax.annotation.Nullable' should be separated from previous imports. [ImportOrder]\nThe checkstyle wants an empty line between the Lines 26 and 27.", "url": "https://github.com/apache/druid/pull/10027#discussion_r446303931", "createdAt": "2020-06-26T17:02:21Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/common/guava/GuavaUtils.java", "diffHunk": "@@ -23,8 +23,8 @@\n import com.google.common.base.Strings;\n import com.google.common.primitives.Longs;\n import org.apache.druid.java.util.common.logger.Logger;\n-\n import javax.annotation.Nullable;\n+import java.util.ArrayList;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a51d7e16f5f15af33fa239419aaa82bffb99f8f5"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyMzUyNw==", "bodyText": "Ah makes sense \ud83d\udc4d. Would you please add a comment on this line about why we cancel it first? It would help other people to understand your intention. Maybe the comment can say \"Canceling combinedFuture first so that it can complete with INTERRUPTED as its final state. See ChainedExecutionQueryRunnerTest.testQueryTimeout()\".", "url": "https://github.com/apache/druid/pull/10027#discussion_r446323527", "createdAt": "2020-06-26T17:43:33Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/ChainedExecutionQueryRunner.java", "diffHunk": "@@ -141,33 +144,34 @@ public ChainedExecutionQueryRunner(\n                           );\n                         }\n                     )\n-                )\n-            );\n+                );\n \n-            queryWatcher.registerQueryFuture(query, futures);\n+            ListenableFuture<List<Iterable<T>>> future = Futures.allAsList(futures);\n+            queryWatcher.registerQueryFuture(query, future);\n \n             try {\n               return new MergeIterable<>(\n                   ordering.nullsFirst(),\n                   QueryContexts.hasTimeout(query) ?\n-                      futures.get(QueryContexts.getTimeout(query), TimeUnit.MILLISECONDS) :\n-                      futures.get()\n+                      future.get(QueryContexts.getTimeout(query), TimeUnit.MILLISECONDS) :\n+                      future.get()\n               ).iterator();\n             }\n             catch (InterruptedException e) {\n               log.noStackTrace().warn(e, \"Query interrupted, cancelling pending results, query id [%s]\", query.getId());\n-              futures.cancel(true);\n+              GuavaUtils.cancelAll(true, ImmutableList.<Future>builder().add(future).addAll(futures).build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyMDA4MQ=="}, "originalCommit": {"oid": "7fc9d5036af8003f1a576ccab128b57571ad03fd"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NDgyNjgw", "url": "https://github.com/apache/druid/pull/10027#pullrequestreview-438482680", "createdAt": "2020-06-26T17:44:58Z", "commit": {"oid": "a51d7e16f5f15af33fa239419aaa82bffb99f8f5"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b0bc1acc77496ae3efbfb77bcb1e63fbee9adf2", "author": {"user": {"login": "chenyuzhi459", "name": null}}, "url": "https://github.com/apache/druid/commit/2b0bc1acc77496ae3efbfb77bcb1e63fbee9adf2", "committedDate": "2020-06-27T00:24:19Z", "message": "add comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NjcxNTU5", "url": "https://github.com/apache/druid/pull/10027#pullrequestreview-438671559", "createdAt": "2020-06-27T04:29:24Z", "commit": {"oid": "2b0bc1acc77496ae3efbfb77bcb1e63fbee9adf2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4Njc3MDkx", "url": "https://github.com/apache/druid/pull/10027#pullrequestreview-438677091", "createdAt": "2020-06-27T06:29:15Z", "commit": {"oid": "2b0bc1acc77496ae3efbfb77bcb1e63fbee9adf2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2083, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}