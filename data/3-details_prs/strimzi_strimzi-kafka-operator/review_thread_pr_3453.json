{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzMjQ5NDMx", "number": 3453, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMTo1Mzo1NFrOEVYVcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozNzowN1rOE08-yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwODU0MjU4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/CertificateAuthority.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMTo1Mzo1NFrOG8GWpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMTo1Mzo1NFrOG8GWpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY3MTg0NA==", "bodyText": "should we explain what's the consequence of setting it to false? so explaining that deleting the Kafka cluster won't delete the certificate secrets?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3453#discussion_r465671844", "createdAt": "2020-08-05T11:53:54Z", "author": {"login": "ppatierno"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CertificateAuthority.java", "diffHunk": "@@ -58,6 +59,17 @@ public void setGenerateCertificateAuthority(boolean generateCertificateAuthority\n         this.generateCertificateAuthority = generateCertificateAuthority;\n     }\n \n+    @Description(\"If true then the Certificate Authority certificates secrets owner reference is set to the Kafka object. \" +\n+    \"Otherwise no owner reference is set \" +\n+    \"Default is true.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b862aa72193f5caeba255b472291ae0bbbd8561"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjAzNDAzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/CertificateAuthority.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMDo1NDo0OFrOHcKHTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMDo1NDo0OFrOHcKHTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4Nzg4NA==", "bodyText": "I think this needs to be indented with 8 spaces => that is why the CI failed.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3453#discussion_r499287884", "createdAt": "2020-10-04T20:54:48Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CertificateAuthority.java", "diffHunk": "@@ -58,6 +59,17 @@ public void setGenerateCertificateAuthority(boolean generateCertificateAuthority\n         this.generateCertificateAuthority = generateCertificateAuthority;\n     }\n \n+    @Description(\"If true then the Certificate Authority certificates secrets owner reference is set to the Kafka object. \" +\n+    \"Otherwise no owner reference is set so deleting the Kafka object won't delete the secrets.\" +\n+    \"Default is true.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a9eb4d313bd4102e8c4e9c5f841b60abd4b22"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjAzNTI3OnYy", "diffSide": "RIGHT", "path": "api/src/test/resources/io/strimzi/api/kafka/model/Kafka.out.yaml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMDo1NjoyOFrOHcKH6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMDo1NjoyOFrOHcKH6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4ODA0Mg==", "bodyText": "The default is true, so I think this should be true?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3453#discussion_r499288042", "createdAt": "2020-10-04T20:56:28Z", "author": {"login": "scholzj"}, "path": "api/src/test/resources/io/strimzi/api/kafka/model/Kafka.out.yaml", "diffHunk": "@@ -147,10 +147,12 @@ spec:\n     topicMetadataMaxAttempts: 6\n   clusterCa:\n     generateCertificateAuthority: false\n+    generateSecretOwnerReference: false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a9eb4d313bd4102e8c4e9c5f841b60abd4b22"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjAzNTMwOnYy", "diffSide": "RIGHT", "path": "api/src/test/resources/io/strimzi/api/kafka/model/Kafka.out.yaml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMDo1NjozMlrOHcKH7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMDo1NjozMlrOHcKH7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4ODA0Ng==", "bodyText": "The default is true, so I think this should be true?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3453#discussion_r499288046", "createdAt": "2020-10-04T20:56:32Z", "author": {"login": "scholzj"}, "path": "api/src/test/resources/io/strimzi/api/kafka/model/Kafka.out.yaml", "diffHunk": "@@ -147,10 +147,12 @@ spec:\n     topicMetadataMaxAttempts: 6\n   clusterCa:\n     generateCertificateAuthority: false\n+    generateSecretOwnerReference: false\n     validityDays: 395\n     renewalDays: 32\n   clientsCa:\n     generateCertificateAuthority: false\n+    generateSecretOwnerReference: false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a9eb4d313bd4102e8c4e9c5f841b60abd4b22"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjA0MjM2OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMTowNzowNlrOHcKLbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMTowNzowNlrOHcKLbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4ODk0Mw==", "bodyText": "Should this be clusterCaConfig instead of clusterCa?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3453#discussion_r499288943", "createdAt": "2020-10-04T21:07:06Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -603,7 +603,8 @@ ReconciliationState createReconciliationState(Reconciliation reconciliation, Kaf\n                                 clusterCaConfig != null ? clusterCaConfig.getCertificateExpirationPolicy() : null);\n                         clusterCa.createRenewOrReplace(\n                                 reconciliation.namespace(), reconciliation.name(), caLabels.toMap(),\n-                                ownerRef, isMaintenanceTimeWindowsSatisfied(dateSupplier));\n+                                clusterCa.isGenerateSecretOwnerReference() ? ownerRef : null, ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a9eb4d313bd4102e8c4e9c5f841b60abd4b22"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjA0MjQ3OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMTowNzoyN1rOHcKLfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMTowNzoyN1rOHcKLfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4ODk1OA==", "bodyText": "Should this be clientsCaConfig instead of clientsCa ?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3453#discussion_r499288958", "createdAt": "2020-10-04T21:07:27Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -620,7 +621,8 @@ ReconciliationState createReconciliationState(Reconciliation reconciliation, Kaf\n                                 clientsCaConfig == null || clientsCaConfig.isGenerateCertificateAuthority(),\n                                 clientsCaConfig != null ? clientsCaConfig.getCertificateExpirationPolicy() : null);\n                         clientsCa.createRenewOrReplace(reconciliation.namespace(), reconciliation.name(),\n-                                caLabels.toMap(), ownerRef, isMaintenanceTimeWindowsSatisfied(dateSupplier));\n+                                caLabels.toMap(), clientsCa.isGenerateSecretOwnerReference() ? ownerRef : null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a9eb4d313bd4102e8c4e9c5f841b60abd4b22"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjA0NDE4OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMToxMDowNFrOHcKMWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMToxMDowNFrOHcKMWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4OTE3Ng==", "bodyText": "I do not think the test here really tests what it should. I do not think it triggered the code you changed in createKafkaClusterInitialSecrets. I think you would need to capture the secrets and check it on them. You also need to make sure that in different runs, the values are configured differently to test both situations which I don't think it happening here.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3453#discussion_r499289176", "createdAt": "2020-10-04T21:10:04Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorTest.java", "diffHunk": "@@ -592,6 +592,19 @@ private void createCluster(VertxTestContext context, Kafka kafka, List<Secret> s\n             expectedSecrets.add(EntityOperator.secretName(kafkaName));\n         }\n \n+        List<Secrets> caSecrets = getInitialCertificates(kafkaName);\n+        if (getKafkaAssembly(kafkaName).getSpec().getClusterCa().isGenerateSecretOwnerReference()) {\n+            assertThat(caSecrets.get(0).getMetadata().getOwnerReferences().size(), is(1));\n+        } else {\n+            assertThat(caSecrets.get(0).getMetadata().getOwnerReferences().size(), is(0));\n+        }\n+\n+        if (getKafkaAssembly(kafkaName).getSpec().getClientsCa().isGenerateSecretOwnerReference()) {\n+            assertThat(caSecrets.get(0).getMetadata().getOwnerReferences().size(), is(1));\n+        } else {\n+            assertThat(caSecrets.get(0).getMetadata().getOwnerReferences().size(), is(0));\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a9eb4d313bd4102e8c4e9c5f841b60abd4b22"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjA1NDc4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/CertificateAuthority.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMToyNjo1MVrOHcKRsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMToyNjo1MVrOHcKRsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI5MDU0Nw==", "bodyText": "Could you add space at the end of the sentence after the .?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3453#discussion_r499290547", "createdAt": "2020-10-04T21:26:51Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CertificateAuthority.java", "diffHunk": "@@ -58,6 +59,17 @@ public void setGenerateCertificateAuthority(boolean generateCertificateAuthority\n         this.generateCertificateAuthority = generateCertificateAuthority;\n     }\n \n+    @Description(\"If true then the Certificate Authority certificates secrets owner reference is set to the Kafka object. \" +\n+    \"Otherwise no owner reference is set so deleting the Kafka object won't delete the secrets.\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126a9eb4d313bd4102e8c4e9c5f841b60abd4b22"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTYwNjA3OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorNonParametrizedTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQyMjoyMzo0OFrOHrynvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNjoyOTozOFrOHs21lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY4MDE5MQ==", "bodyText": "I think this is missing the @Test annotation?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3453#discussion_r515680191", "createdAt": "2020-11-01T22:23:48Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorNonParametrizedTest.java", "diffHunk": "@@ -148,4 +148,80 @@ public void testCustomLabelsAndAnnotations(VertxTestContext context) {\n                     async.flag();\n                 })));\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testCASecretsWithOwnerReference(VertxTestContext context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eef42a2152a89e5af3ce94503433915850598bf"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc5Nzg0NQ==", "bodyText": "True!", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3453#discussion_r516797845", "createdAt": "2020-11-03T16:29:38Z", "author": {"login": "dgdelahera"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorNonParametrizedTest.java", "diffHunk": "@@ -148,4 +148,80 @@ public void testCustomLabelsAndAnnotations(VertxTestContext context) {\n                     async.flag();\n                 })));\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testCASecretsWithOwnerReference(VertxTestContext context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY4MDE5MQ=="}, "originalCommit": {"oid": "5eef42a2152a89e5af3ce94503433915850598bf"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTYwODkzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorNonParametrizedTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQyMjoyNjozM1rOHrypIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQyMjoyNjozM1rOHrypIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY4MDU0NQ==", "bodyText": "I think this is a almost good test for the positive case. You should also add a case for the other case - that the owner reference is disabled - and check that it is indeed null. It should be easy to build on that from the", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3453#discussion_r515680545", "createdAt": "2020-11-01T22:26:33Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorNonParametrizedTest.java", "diffHunk": "@@ -148,4 +148,80 @@ public void testCustomLabelsAndAnnotations(VertxTestContext context) {\n                     async.flag();\n                 })));\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testCASecretsWithOwnerReference(VertxTestContext context) {\n+        OwnerReference ownerReference = new OwnerReferenceBuilder()\n+                    .withApiVersion(\"kafka.strimzi.io/v1beta1\")\n+                    .withKind(\"Kafka\")\n+                    .withName(NAME)\n+                    .withUid(\"random-1234\")\n+                    .withBlockOwnerDeletion(false)\n+                    .withController(false)\n+                    .build();\n+\n+\n+        Kafka kafka = new KafkaBuilder()\n+                .withNewMetadata()\n+                    .withName(NAME)\n+                    .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withNewSpec()\n+                    .withNewKafka()\n+                        .withReplicas(3)\n+                        .withNewEphemeralStorage()\n+                        .endEphemeralStorage()\n+                        .withNewTemplate()\n+                            .withNewClusterCaCert()\n+                                .withNewMetadata()\n+                                    .withOwnerReferences(ownerReference)\n+                                .endMetadata()\n+                            .endClusterCaCert()\n+                        .endTemplate()\n+                    .endKafka()\n+                    .withNewZookeeper()\n+                        .withReplicas(3)\n+                        .withNewEphemeralStorage()\n+                        .endEphemeralStorage()\n+                    .endZookeeper()\n+                .endSpec()\n+                .build();\n+        \n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(false);\n+        SecretOperator secretOps = supplier.secretOperations;\n+\n+        ArgumentCaptor<Secret> clusterCaCert = ArgumentCaptor.forClass(Secret.class);\n+        ArgumentCaptor<Secret> clusterCaKey = ArgumentCaptor.forClass(Secret.class);\n+        ArgumentCaptor<Secret> clientsCaCert = ArgumentCaptor.forClass(Secret.class);\n+        ArgumentCaptor<Secret> clientsCaKey = ArgumentCaptor.forClass(Secret.class);\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(AbstractModel.clusterCaCertSecretName(NAME)), clusterCaCert.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(AbstractModel.clusterCaKeySecretName(NAME)), clusterCaKey.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(KafkaCluster.clientsCaCertSecretName(NAME)), clientsCaCert.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(KafkaCluster.clientsCaKeySecretName(NAME)), clientsCaKey.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+\n+        KafkaAssemblyOperator op = new KafkaAssemblyOperator(vertx, new PlatformFeaturesAvailability(false, KubernetesVersion.V1_9), certManager, passwordGenerator,\n+                supplier, ResourceUtils.dummyClusterOperatorConfig(1L));\n+        Reconciliation reconciliation = new Reconciliation(\"test-trigger\", Kafka.RESOURCE_KIND, NAMESPACE, NAME);\n+\n+        Checkpoint async = context.checkpoint();\n+        \n+        op.new ReconciliationState(reconciliation, kafka).reconcileCas(() -> new Date())\n+                .onComplete(context.succeeding(c -> context.verify(() -> {\n+                    assertThat(clusterCaCert.getAllValues(), hasSize(1));\n+                    assertThat(clusterCaKey.getAllValues(), hasSize(1));\n+                    assertThat(clientsCaCert.getAllValues(), hasSize(1));\n+                    assertThat(clientsCaKey.getAllValues(), hasSize(1));\n+\n+                    Secret clusterCaCertSecret = clusterCaCert.getValue();\n+                    Secret clusterCaKeySecret = clusterCaKey.getValue();\n+                    Secret clientsCaCertSecret = clientsCaCert.getValue();\n+                    Secret clientsCaKeySecret = clientsCaKey.getValue();\n+\n+                    assertThat(clusterCaCertSecret.getMetadata().getOwnerReferences(), hasSize(1));\n+                    assertThat(clusterCaCertSecret.getMetadata().getOwnerReferences().get(0), is(ownerReference));\n+\n+                    assertThat(clientsCaCertSecret.getMetadata().getOwnerReferences(), hasSize(0));\n+\n+                    async.flag();\n+                })));\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eef42a2152a89e5af3ce94503433915850598bf"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTYxMDE0OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorNonParametrizedTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQyMjoyNzo1N1rOHrypvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNjoyOTo1MlrOHs22gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY4MDcwMw==", "bodyText": "Can you check the owner reference for all of the secrets? Although your PR affects only the cert secrets and not for the key secrets, it makes sense to test it to make sure they are not affected.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3453#discussion_r515680703", "createdAt": "2020-11-01T22:27:57Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorNonParametrizedTest.java", "diffHunk": "@@ -148,4 +148,80 @@ public void testCustomLabelsAndAnnotations(VertxTestContext context) {\n                     async.flag();\n                 })));\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testCASecretsWithOwnerReference(VertxTestContext context) {\n+        OwnerReference ownerReference = new OwnerReferenceBuilder()\n+                    .withApiVersion(\"kafka.strimzi.io/v1beta1\")\n+                    .withKind(\"Kafka\")\n+                    .withName(NAME)\n+                    .withUid(\"random-1234\")\n+                    .withBlockOwnerDeletion(false)\n+                    .withController(false)\n+                    .build();\n+\n+\n+        Kafka kafka = new KafkaBuilder()\n+                .withNewMetadata()\n+                    .withName(NAME)\n+                    .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withNewSpec()\n+                    .withNewKafka()\n+                        .withReplicas(3)\n+                        .withNewEphemeralStorage()\n+                        .endEphemeralStorage()\n+                        .withNewTemplate()\n+                            .withNewClusterCaCert()\n+                                .withNewMetadata()\n+                                    .withOwnerReferences(ownerReference)\n+                                .endMetadata()\n+                            .endClusterCaCert()\n+                        .endTemplate()\n+                    .endKafka()\n+                    .withNewZookeeper()\n+                        .withReplicas(3)\n+                        .withNewEphemeralStorage()\n+                        .endEphemeralStorage()\n+                    .endZookeeper()\n+                .endSpec()\n+                .build();\n+        \n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(false);\n+        SecretOperator secretOps = supplier.secretOperations;\n+\n+        ArgumentCaptor<Secret> clusterCaCert = ArgumentCaptor.forClass(Secret.class);\n+        ArgumentCaptor<Secret> clusterCaKey = ArgumentCaptor.forClass(Secret.class);\n+        ArgumentCaptor<Secret> clientsCaCert = ArgumentCaptor.forClass(Secret.class);\n+        ArgumentCaptor<Secret> clientsCaKey = ArgumentCaptor.forClass(Secret.class);\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(AbstractModel.clusterCaCertSecretName(NAME)), clusterCaCert.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(AbstractModel.clusterCaKeySecretName(NAME)), clusterCaKey.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(KafkaCluster.clientsCaCertSecretName(NAME)), clientsCaCert.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(KafkaCluster.clientsCaKeySecretName(NAME)), clientsCaKey.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+\n+        KafkaAssemblyOperator op = new KafkaAssemblyOperator(vertx, new PlatformFeaturesAvailability(false, KubernetesVersion.V1_9), certManager, passwordGenerator,\n+                supplier, ResourceUtils.dummyClusterOperatorConfig(1L));\n+        Reconciliation reconciliation = new Reconciliation(\"test-trigger\", Kafka.RESOURCE_KIND, NAMESPACE, NAME);\n+\n+        Checkpoint async = context.checkpoint();\n+        \n+        op.new ReconciliationState(reconciliation, kafka).reconcileCas(() -> new Date())\n+                .onComplete(context.succeeding(c -> context.verify(() -> {\n+                    assertThat(clusterCaCert.getAllValues(), hasSize(1));\n+                    assertThat(clusterCaKey.getAllValues(), hasSize(1));\n+                    assertThat(clientsCaCert.getAllValues(), hasSize(1));\n+                    assertThat(clientsCaKey.getAllValues(), hasSize(1));\n+\n+                    Secret clusterCaCertSecret = clusterCaCert.getValue();\n+                    Secret clusterCaKeySecret = clusterCaKey.getValue();\n+                    Secret clientsCaCertSecret = clientsCaCert.getValue();\n+                    Secret clientsCaKeySecret = clientsCaKey.getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eef42a2152a89e5af3ce94503433915850598bf"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc5ODA4MA==", "bodyText": "Sure!", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3453#discussion_r516798080", "createdAt": "2020-11-03T16:29:52Z", "author": {"login": "dgdelahera"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorNonParametrizedTest.java", "diffHunk": "@@ -148,4 +148,80 @@ public void testCustomLabelsAndAnnotations(VertxTestContext context) {\n                     async.flag();\n                 })));\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testCASecretsWithOwnerReference(VertxTestContext context) {\n+        OwnerReference ownerReference = new OwnerReferenceBuilder()\n+                    .withApiVersion(\"kafka.strimzi.io/v1beta1\")\n+                    .withKind(\"Kafka\")\n+                    .withName(NAME)\n+                    .withUid(\"random-1234\")\n+                    .withBlockOwnerDeletion(false)\n+                    .withController(false)\n+                    .build();\n+\n+\n+        Kafka kafka = new KafkaBuilder()\n+                .withNewMetadata()\n+                    .withName(NAME)\n+                    .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withNewSpec()\n+                    .withNewKafka()\n+                        .withReplicas(3)\n+                        .withNewEphemeralStorage()\n+                        .endEphemeralStorage()\n+                        .withNewTemplate()\n+                            .withNewClusterCaCert()\n+                                .withNewMetadata()\n+                                    .withOwnerReferences(ownerReference)\n+                                .endMetadata()\n+                            .endClusterCaCert()\n+                        .endTemplate()\n+                    .endKafka()\n+                    .withNewZookeeper()\n+                        .withReplicas(3)\n+                        .withNewEphemeralStorage()\n+                        .endEphemeralStorage()\n+                    .endZookeeper()\n+                .endSpec()\n+                .build();\n+        \n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(false);\n+        SecretOperator secretOps = supplier.secretOperations;\n+\n+        ArgumentCaptor<Secret> clusterCaCert = ArgumentCaptor.forClass(Secret.class);\n+        ArgumentCaptor<Secret> clusterCaKey = ArgumentCaptor.forClass(Secret.class);\n+        ArgumentCaptor<Secret> clientsCaCert = ArgumentCaptor.forClass(Secret.class);\n+        ArgumentCaptor<Secret> clientsCaKey = ArgumentCaptor.forClass(Secret.class);\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(AbstractModel.clusterCaCertSecretName(NAME)), clusterCaCert.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(AbstractModel.clusterCaKeySecretName(NAME)), clusterCaKey.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(KafkaCluster.clientsCaCertSecretName(NAME)), clientsCaCert.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(KafkaCluster.clientsCaKeySecretName(NAME)), clientsCaKey.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+\n+        KafkaAssemblyOperator op = new KafkaAssemblyOperator(vertx, new PlatformFeaturesAvailability(false, KubernetesVersion.V1_9), certManager, passwordGenerator,\n+                supplier, ResourceUtils.dummyClusterOperatorConfig(1L));\n+        Reconciliation reconciliation = new Reconciliation(\"test-trigger\", Kafka.RESOURCE_KIND, NAMESPACE, NAME);\n+\n+        Checkpoint async = context.checkpoint();\n+        \n+        op.new ReconciliationState(reconciliation, kafka).reconcileCas(() -> new Date())\n+                .onComplete(context.succeeding(c -> context.verify(() -> {\n+                    assertThat(clusterCaCert.getAllValues(), hasSize(1));\n+                    assertThat(clusterCaKey.getAllValues(), hasSize(1));\n+                    assertThat(clientsCaCert.getAllValues(), hasSize(1));\n+                    assertThat(clientsCaKey.getAllValues(), hasSize(1));\n+\n+                    Secret clusterCaCertSecret = clusterCaCert.getValue();\n+                    Secret clusterCaKeySecret = clusterCaKey.getValue();\n+                    Secret clientsCaCertSecret = clientsCaCert.getValue();\n+                    Secret clientsCaKeySecret = clientsCaKey.getValue();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY4MDcwMw=="}, "originalCommit": {"oid": "5eef42a2152a89e5af3ce94503433915850598bf"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTYxMDQ2OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorNonParametrizedTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQyMjoyODoyNFrOHryp6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozNDowN1rOHs9mSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY4MDc0NA==", "bodyText": "Why do you expect it to be 0 here?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3453#discussion_r515680744", "createdAt": "2020-11-01T22:28:24Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorNonParametrizedTest.java", "diffHunk": "@@ -148,4 +148,80 @@ public void testCustomLabelsAndAnnotations(VertxTestContext context) {\n                     async.flag();\n                 })));\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testCASecretsWithOwnerReference(VertxTestContext context) {\n+        OwnerReference ownerReference = new OwnerReferenceBuilder()\n+                    .withApiVersion(\"kafka.strimzi.io/v1beta1\")\n+                    .withKind(\"Kafka\")\n+                    .withName(NAME)\n+                    .withUid(\"random-1234\")\n+                    .withBlockOwnerDeletion(false)\n+                    .withController(false)\n+                    .build();\n+\n+\n+        Kafka kafka = new KafkaBuilder()\n+                .withNewMetadata()\n+                    .withName(NAME)\n+                    .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withNewSpec()\n+                    .withNewKafka()\n+                        .withReplicas(3)\n+                        .withNewEphemeralStorage()\n+                        .endEphemeralStorage()\n+                        .withNewTemplate()\n+                            .withNewClusterCaCert()\n+                                .withNewMetadata()\n+                                    .withOwnerReferences(ownerReference)\n+                                .endMetadata()\n+                            .endClusterCaCert()\n+                        .endTemplate()\n+                    .endKafka()\n+                    .withNewZookeeper()\n+                        .withReplicas(3)\n+                        .withNewEphemeralStorage()\n+                        .endEphemeralStorage()\n+                    .endZookeeper()\n+                .endSpec()\n+                .build();\n+        \n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(false);\n+        SecretOperator secretOps = supplier.secretOperations;\n+\n+        ArgumentCaptor<Secret> clusterCaCert = ArgumentCaptor.forClass(Secret.class);\n+        ArgumentCaptor<Secret> clusterCaKey = ArgumentCaptor.forClass(Secret.class);\n+        ArgumentCaptor<Secret> clientsCaCert = ArgumentCaptor.forClass(Secret.class);\n+        ArgumentCaptor<Secret> clientsCaKey = ArgumentCaptor.forClass(Secret.class);\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(AbstractModel.clusterCaCertSecretName(NAME)), clusterCaCert.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(AbstractModel.clusterCaKeySecretName(NAME)), clusterCaKey.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(KafkaCluster.clientsCaCertSecretName(NAME)), clientsCaCert.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(KafkaCluster.clientsCaKeySecretName(NAME)), clientsCaKey.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+\n+        KafkaAssemblyOperator op = new KafkaAssemblyOperator(vertx, new PlatformFeaturesAvailability(false, KubernetesVersion.V1_9), certManager, passwordGenerator,\n+                supplier, ResourceUtils.dummyClusterOperatorConfig(1L));\n+        Reconciliation reconciliation = new Reconciliation(\"test-trigger\", Kafka.RESOURCE_KIND, NAMESPACE, NAME);\n+\n+        Checkpoint async = context.checkpoint();\n+        \n+        op.new ReconciliationState(reconciliation, kafka).reconcileCas(() -> new Date())\n+                .onComplete(context.succeeding(c -> context.verify(() -> {\n+                    assertThat(clusterCaCert.getAllValues(), hasSize(1));\n+                    assertThat(clusterCaKey.getAllValues(), hasSize(1));\n+                    assertThat(clientsCaCert.getAllValues(), hasSize(1));\n+                    assertThat(clientsCaKey.getAllValues(), hasSize(1));\n+\n+                    Secret clusterCaCertSecret = clusterCaCert.getValue();\n+                    Secret clusterCaKeySecret = clusterCaKey.getValue();\n+                    Secret clientsCaCertSecret = clientsCaCert.getValue();\n+                    Secret clientsCaKeySecret = clientsCaKey.getValue();\n+\n+                    assertThat(clusterCaCertSecret.getMetadata().getOwnerReferences(), hasSize(1));\n+                    assertThat(clusterCaCertSecret.getMetadata().getOwnerReferences().get(0), is(ownerReference));\n+\n+                    assertThat(clientsCaCertSecret.getMetadata().getOwnerReferences(), hasSize(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eef42a2152a89e5af3ce94503433915850598bf"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc5OTUxMw==", "bodyText": "The clientsCaCert is created without OnwerReference, so I wanted to check here if it is null", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3453#discussion_r516799513", "createdAt": "2020-11-03T16:32:01Z", "author": {"login": "dgdelahera"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorNonParametrizedTest.java", "diffHunk": "@@ -148,4 +148,80 @@ public void testCustomLabelsAndAnnotations(VertxTestContext context) {\n                     async.flag();\n                 })));\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testCASecretsWithOwnerReference(VertxTestContext context) {\n+        OwnerReference ownerReference = new OwnerReferenceBuilder()\n+                    .withApiVersion(\"kafka.strimzi.io/v1beta1\")\n+                    .withKind(\"Kafka\")\n+                    .withName(NAME)\n+                    .withUid(\"random-1234\")\n+                    .withBlockOwnerDeletion(false)\n+                    .withController(false)\n+                    .build();\n+\n+\n+        Kafka kafka = new KafkaBuilder()\n+                .withNewMetadata()\n+                    .withName(NAME)\n+                    .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withNewSpec()\n+                    .withNewKafka()\n+                        .withReplicas(3)\n+                        .withNewEphemeralStorage()\n+                        .endEphemeralStorage()\n+                        .withNewTemplate()\n+                            .withNewClusterCaCert()\n+                                .withNewMetadata()\n+                                    .withOwnerReferences(ownerReference)\n+                                .endMetadata()\n+                            .endClusterCaCert()\n+                        .endTemplate()\n+                    .endKafka()\n+                    .withNewZookeeper()\n+                        .withReplicas(3)\n+                        .withNewEphemeralStorage()\n+                        .endEphemeralStorage()\n+                    .endZookeeper()\n+                .endSpec()\n+                .build();\n+        \n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(false);\n+        SecretOperator secretOps = supplier.secretOperations;\n+\n+        ArgumentCaptor<Secret> clusterCaCert = ArgumentCaptor.forClass(Secret.class);\n+        ArgumentCaptor<Secret> clusterCaKey = ArgumentCaptor.forClass(Secret.class);\n+        ArgumentCaptor<Secret> clientsCaCert = ArgumentCaptor.forClass(Secret.class);\n+        ArgumentCaptor<Secret> clientsCaKey = ArgumentCaptor.forClass(Secret.class);\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(AbstractModel.clusterCaCertSecretName(NAME)), clusterCaCert.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(AbstractModel.clusterCaKeySecretName(NAME)), clusterCaKey.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(KafkaCluster.clientsCaCertSecretName(NAME)), clientsCaCert.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(KafkaCluster.clientsCaKeySecretName(NAME)), clientsCaKey.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+\n+        KafkaAssemblyOperator op = new KafkaAssemblyOperator(vertx, new PlatformFeaturesAvailability(false, KubernetesVersion.V1_9), certManager, passwordGenerator,\n+                supplier, ResourceUtils.dummyClusterOperatorConfig(1L));\n+        Reconciliation reconciliation = new Reconciliation(\"test-trigger\", Kafka.RESOURCE_KIND, NAMESPACE, NAME);\n+\n+        Checkpoint async = context.checkpoint();\n+        \n+        op.new ReconciliationState(reconciliation, kafka).reconcileCas(() -> new Date())\n+                .onComplete(context.succeeding(c -> context.verify(() -> {\n+                    assertThat(clusterCaCert.getAllValues(), hasSize(1));\n+                    assertThat(clusterCaKey.getAllValues(), hasSize(1));\n+                    assertThat(clientsCaCert.getAllValues(), hasSize(1));\n+                    assertThat(clientsCaKey.getAllValues(), hasSize(1));\n+\n+                    Secret clusterCaCertSecret = clusterCaCert.getValue();\n+                    Secret clusterCaKeySecret = clusterCaKey.getValue();\n+                    Secret clientsCaCertSecret = clientsCaCert.getValue();\n+                    Secret clientsCaKeySecret = clientsCaKey.getValue();\n+\n+                    assertThat(clusterCaCertSecret.getMetadata().getOwnerReferences(), hasSize(1));\n+                    assertThat(clusterCaCertSecret.getMetadata().getOwnerReferences().get(0), is(ownerReference));\n+\n+                    assertThat(clientsCaCertSecret.getMetadata().getOwnerReferences(), hasSize(0));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY4MDc0NA=="}, "originalCommit": {"oid": "5eef42a2152a89e5af3ce94503433915850598bf"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwODYxNw==", "bodyText": "But why is it created without the owner reference? The generateSecretOwnerReference defaults to true and you did not set it differently. So it should have it in this test, or?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3453#discussion_r516908617", "createdAt": "2020-11-03T19:34:07Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorNonParametrizedTest.java", "diffHunk": "@@ -148,4 +148,80 @@ public void testCustomLabelsAndAnnotations(VertxTestContext context) {\n                     async.flag();\n                 })));\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testCASecretsWithOwnerReference(VertxTestContext context) {\n+        OwnerReference ownerReference = new OwnerReferenceBuilder()\n+                    .withApiVersion(\"kafka.strimzi.io/v1beta1\")\n+                    .withKind(\"Kafka\")\n+                    .withName(NAME)\n+                    .withUid(\"random-1234\")\n+                    .withBlockOwnerDeletion(false)\n+                    .withController(false)\n+                    .build();\n+\n+\n+        Kafka kafka = new KafkaBuilder()\n+                .withNewMetadata()\n+                    .withName(NAME)\n+                    .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withNewSpec()\n+                    .withNewKafka()\n+                        .withReplicas(3)\n+                        .withNewEphemeralStorage()\n+                        .endEphemeralStorage()\n+                        .withNewTemplate()\n+                            .withNewClusterCaCert()\n+                                .withNewMetadata()\n+                                    .withOwnerReferences(ownerReference)\n+                                .endMetadata()\n+                            .endClusterCaCert()\n+                        .endTemplate()\n+                    .endKafka()\n+                    .withNewZookeeper()\n+                        .withReplicas(3)\n+                        .withNewEphemeralStorage()\n+                        .endEphemeralStorage()\n+                    .endZookeeper()\n+                .endSpec()\n+                .build();\n+        \n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(false);\n+        SecretOperator secretOps = supplier.secretOperations;\n+\n+        ArgumentCaptor<Secret> clusterCaCert = ArgumentCaptor.forClass(Secret.class);\n+        ArgumentCaptor<Secret> clusterCaKey = ArgumentCaptor.forClass(Secret.class);\n+        ArgumentCaptor<Secret> clientsCaCert = ArgumentCaptor.forClass(Secret.class);\n+        ArgumentCaptor<Secret> clientsCaKey = ArgumentCaptor.forClass(Secret.class);\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(AbstractModel.clusterCaCertSecretName(NAME)), clusterCaCert.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(AbstractModel.clusterCaKeySecretName(NAME)), clusterCaKey.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(KafkaCluster.clientsCaCertSecretName(NAME)), clientsCaCert.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+        when(secretOps.reconcile(eq(NAMESPACE), eq(KafkaCluster.clientsCaKeySecretName(NAME)), clientsCaKey.capture())).thenAnswer(i -> Future.succeededFuture(ReconcileResult.created(i.getArgument(0))));\n+\n+        KafkaAssemblyOperator op = new KafkaAssemblyOperator(vertx, new PlatformFeaturesAvailability(false, KubernetesVersion.V1_9), certManager, passwordGenerator,\n+                supplier, ResourceUtils.dummyClusterOperatorConfig(1L));\n+        Reconciliation reconciliation = new Reconciliation(\"test-trigger\", Kafka.RESOURCE_KIND, NAMESPACE, NAME);\n+\n+        Checkpoint async = context.checkpoint();\n+        \n+        op.new ReconciliationState(reconciliation, kafka).reconcileCas(() -> new Date())\n+                .onComplete(context.succeeding(c -> context.verify(() -> {\n+                    assertThat(clusterCaCert.getAllValues(), hasSize(1));\n+                    assertThat(clusterCaKey.getAllValues(), hasSize(1));\n+                    assertThat(clientsCaCert.getAllValues(), hasSize(1));\n+                    assertThat(clientsCaKey.getAllValues(), hasSize(1));\n+\n+                    Secret clusterCaCertSecret = clusterCaCert.getValue();\n+                    Secret clusterCaKeySecret = clusterCaKey.getValue();\n+                    Secret clientsCaCertSecret = clientsCaCert.getValue();\n+                    Secret clientsCaKeySecret = clientsCaKey.getValue();\n+\n+                    assertThat(clusterCaCertSecret.getMetadata().getOwnerReferences(), hasSize(1));\n+                    assertThat(clusterCaCertSecret.getMetadata().getOwnerReferences().get(0), is(ownerReference));\n+\n+                    assertThat(clientsCaCertSecret.getMetadata().getOwnerReferences(), hasSize(0));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY4MDc0NA=="}, "originalCommit": {"oid": "5eef42a2152a89e5af3ce94503433915850598bf"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzOTYwNTIxOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorNonParametrizedTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozNzowN1rOHs9sig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTozNzowN1rOHs9sig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMDIxOA==", "bodyText": "BTW: I didn't noticed this before, but this should IMHO not even compile. There is no owner reference support in the template.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3453#discussion_r516910218", "createdAt": "2020-11-03T19:37:07Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorNonParametrizedTest.java", "diffHunk": "@@ -148,4 +148,80 @@ public void testCustomLabelsAndAnnotations(VertxTestContext context) {\n                     async.flag();\n                 })));\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testCASecretsWithOwnerReference(VertxTestContext context) {\n+        OwnerReference ownerReference = new OwnerReferenceBuilder()\n+                    .withApiVersion(\"kafka.strimzi.io/v1beta1\")\n+                    .withKind(\"Kafka\")\n+                    .withName(NAME)\n+                    .withUid(\"random-1234\")\n+                    .withBlockOwnerDeletion(false)\n+                    .withController(false)\n+                    .build();\n+\n+\n+        Kafka kafka = new KafkaBuilder()\n+                .withNewMetadata()\n+                    .withName(NAME)\n+                    .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withNewSpec()\n+                    .withNewKafka()\n+                        .withReplicas(3)\n+                        .withNewEphemeralStorage()\n+                        .endEphemeralStorage()\n+                        .withNewTemplate()\n+                            .withNewClusterCaCert()\n+                                .withNewMetadata()\n+                                    .withOwnerReferences(ownerReference)\n+                                .endMetadata()\n+                            .endClusterCaCert()\n+                        .endTemplate()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eef42a2152a89e5af3ce94503433915850598bf"}, "originalPosition": 34}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1255, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}