{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyODkzOTg4", "number": 2399, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjoyMjowM1rODYKCDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNlQyMDo0NTowMVrODavYlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjU2NzgwOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjoyMjowM1rOFd2kNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjoyMjowM1rOFd2kNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0NzAzMQ==", "bodyText": "I think we can avoid the local variable here, just chaining the setHandler on the getAsync call.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r366847031", "createdAt": "2020-01-15T12:22:03Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1223,35 +1223,28 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n         Future<ReconciliationState> getZookeeperDescription() {\n             Promise<ReconciliationState> promise = Promise.promise();\n \n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").executeBlocking(\n-                future -> {\n-                    try {\n-                        StatefulSet sts = zkSetOperations.get(namespace, ZookeeperCluster.zookeeperClusterName(name));\n-                        Storage oldStorage = getOldStorage(sts);\n+            Future<StatefulSet> futSts = zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17a4521986514c1054714290de3cf712abe7cc7e"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjU2OTA2OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjoyMjozNFrOFd2lAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjoyMjozNFrOFd2lAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0NzIzMw==", "bodyText": "ditto as above", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r366847233", "createdAt": "2020-01-15T12:22:34Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1418,30 +1411,24 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n         /*test*/ Future<ReconciliationState> getKafkaClusterDescription() {\n             Promise<ReconciliationState> promise = Promise.promise();\n \n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").<ReconciliationState>executeBlocking(\n-                future -> {\n-                    try {\n-                        StatefulSet sts = kafkaSetOperations.get(namespace, KafkaCluster.kafkaClusterName(name));\n-                        Storage oldStorage = getOldStorage(sts);\n+            Future<StatefulSet> futSts = kafkaSetOperations.getAsync(namespace, KafkaCluster.kafkaClusterName(name));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17a4521986514c1054714290de3cf712abe7cc7e"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzQ0MzYzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzoxMTo1NFrOFe4iaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzoxMTo1NFrOFe4iaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyNzkxMg==", "bodyText": "I wonder if we can further simplify this by using the compose method. It could look something like this:\nreturn zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n                    .compose(sts -> {\n                        Storage oldStorage = getOldStorage(sts);\n\n                        this.zkCluster = ZookeeperCluster.fromCrd(kafkaAssembly, versions, oldStorage);\n                        this.zkService = zkCluster.generateService();\n                        this.zkHeadlessService = zkCluster.generateHeadlessService();\n\n                        if (zkCluster.getLogging() instanceof ExternalLogging)  {\n                            return configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) zkCluster.getLogging()).getName());\n                        } else {\n                            return Future.succeededFuture(null);\n                        }\n                    })\n                    .compose(cm -> {\n                        ConfigMap logAndMetricsConfigMap = zkCluster.generateMetricsAndLogConfigMap(cm);\n                        this.zkMetricsAndLogsConfigMap = zkCluster.generateMetricsAndLogConfigMap(logAndMetricsConfigMap);\n\n                        return Future.succeededFuture(this);\n                    });\nI think the same can be applied to all of the other methods you changed.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r367927912", "createdAt": "2020-01-17T13:11:54Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1223,35 +1223,26 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n         Future<ReconciliationState> getZookeeperDescription() {\n             Promise<ReconciliationState> promise = Promise.promise();\n \n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").executeBlocking(\n-                future -> {\n-                    try {\n-                        StatefulSet sts = zkSetOperations.get(namespace, ZookeeperCluster.zookeeperClusterName(name));\n-                        Storage oldStorage = getOldStorage(sts);\n+            zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name)).setHandler(res -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5499e3da30fc946452db6878df1d8830866b76b9"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzQ0NzE1OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzoxMzoxMVrOFe4kew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzoxMzoxMVrOFe4kew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyODQ0Mw==", "bodyText": "You cannot call result() here, because that would need to wait after the future completes. The suggestion above should be able to deal with it.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r367928443", "createdAt": "2020-01-17T13:13:11Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1223,35 +1223,26 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n         Future<ReconciliationState> getZookeeperDescription() {\n             Promise<ReconciliationState> promise = Promise.promise();\n \n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").executeBlocking(\n-                future -> {\n-                    try {\n-                        StatefulSet sts = zkSetOperations.get(namespace, ZookeeperCluster.zookeeperClusterName(name));\n-                        Storage oldStorage = getOldStorage(sts);\n+            zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name)).setHandler(res -> {\n+                if (res.succeeded()) {\n+                    StatefulSet sts = res.result();\n+                    Storage oldStorage = getOldStorage(sts);\n \n-                        this.zkCluster = ZookeeperCluster.fromCrd(kafkaAssembly, versions, oldStorage);\n+                    this.zkCluster = ZookeeperCluster.fromCrd(kafkaAssembly, versions, oldStorage);\n \n-                        ConfigMap logAndMetricsConfigMap = zkCluster.generateMetricsAndLogConfigMap(zkCluster.getLogging() instanceof ExternalLogging ?\n-                                configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) zkCluster.getLogging()).getName()) :\n-                                null);\n+                    ConfigMap logAndMetricsConfigMap = zkCluster.generateMetricsAndLogConfigMap(zkCluster.getLogging() instanceof ExternalLogging ?\n+                            configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) zkCluster.getLogging()).getName()).result() :", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5499e3da30fc946452db6878df1d8830866b76b9"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzQ1MTI4OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzoxNDo1MVrOFe4nAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzoxNDo1MVrOFe4nAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyOTA4OA==", "bodyText": "Since we don't do anything asynchronous here, you can probably just do return Future.succeededFuture(this); and not use the Promise at all.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r367929088", "createdAt": "2020-01-17T13:14:51Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3077,26 +3027,9 @@ String getInternalServiceHostname(String serviceName)    {\n \n         private final Future<ReconciliationState> getKafkaExporterDescription() {\n             Promise<ReconciliationState> promise = Promise.promise();\n-\n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").<ReconciliationState>executeBlocking(\n-                future -> {\n-                    try {\n-                        this.kafkaExporter = KafkaExporter.fromCrd(kafkaAssembly, versions);\n-                        this.exporterDeployment = kafkaExporter.generateDeployment(pfa.isOpenshift(), imagePullPolicy, imagePullSecrets);\n-\n-                        future.complete(this);\n-                    } catch (Throwable e) {\n-                        future.fail(e);\n-                    }\n-                }, true,\n-                res -> {\n-                    if (res.succeeded()) {\n-                        promise.complete(res.result());\n-                    } else {\n-                        promise.fail(res.cause());\n-                    }\n-                }\n-            );\n+            this.kafkaExporter = KafkaExporter.fromCrd(kafkaAssembly, versions);\n+            this.exporterDeployment = kafkaExporter.generateDeployment(pfa.isOpenshift(), imagePullPolicy, imagePullSecrets);\n+            promise.complete(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5499e3da30fc946452db6878df1d8830866b76b9"}, "originalPosition": 270}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzQ1NDIyOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzoxNjowMVrOFe4otA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzoxNjowMVrOFe4otA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyOTUyNA==", "bodyText": "You would again need to use these for example as a compose pattern similar to what I suggested above.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r367929524", "createdAt": "2020-01-17T13:16:01Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2660,60 +2627,43 @@ int getPodIndexFromPvcName(String pvcName)  {\n \n         @SuppressWarnings(\"deprecation\")\n         private final Future<ReconciliationState> getEntityOperatorDescription() {\n-            Future<ReconciliationState> fut = Future.future();\n+            EntityOperator entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n \n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").<ReconciliationState>executeBlocking(\n-                future -> {\n-                    try {\n-                        EntityOperator entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n+            if (entityOperator != null) {\n+                EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n+                EntityUserOperator userOperator = entityOperator.getUserOperator();\n \n-                        if (entityOperator != null) {\n-                            EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n-                            EntityUserOperator userOperator = entityOperator.getUserOperator();\n+                ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator != null ?\n+                        topicOperator.generateMetricsAndLogConfigMap(topicOperator.getLogging() instanceof ExternalLogging ?\n+                                configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName()).result() :", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5499e3da30fc946452db6878df1d8830866b76b9"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTM5NzM0OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQxMzo1NzowOFrOFfK3lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwODoyNjowNVrOFfxlvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyODI0Ng==", "bodyText": "I do not think this would work. Because of the ExteralLogging is not used in Topic Operator but used in User Operator, this code will be never executed.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r368228246", "createdAt": "2020-01-18T13:57:08Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2660,60 +2616,97 @@ int getPodIndexFromPvcName(String pvcName)  {\n \n         @SuppressWarnings(\"deprecation\")\n         private final Future<ReconciliationState> getEntityOperatorDescription() {\n-            Future<ReconciliationState> fut = Future.future();\n+            EntityOperator entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n \n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").<ReconciliationState>executeBlocking(\n-                future -> {\n-                    try {\n-                        EntityOperator entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n+            if (entityOperator != null) {\n+                EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n+                EntityUserOperator userOperator = entityOperator.getUserOperator();\n \n-                        if (entityOperator != null) {\n-                            EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n-                            EntityUserOperator userOperator = entityOperator.getUserOperator();\n+                final String[] configAnnotation = {\"\"};\n \n-                            ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator != null ?\n-                                    topicOperator.generateMetricsAndLogConfigMap(topicOperator.getLogging() instanceof ExternalLogging ?\n-                                            configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName()) :\n-                                            null) : null;\n+                if (topicOperator != null && userOperator != null) {\n+                    if (topicOperator.getLogging() instanceof ExternalLogging) {\n+                        return configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName())\n+                                .compose(cm -> {\n+                                    ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator.generateMetricsAndLogConfigMap(cm);\n+                                    this.topicOperatorMetricsAndLogsConfigMap = topicOperator.generateMetricsAndLogConfigMap(topicOperatorLogAndMetricsConfigMap);\n \n-                            ConfigMap userOperatorLogAndMetricsConfigMap = userOperator != null ?\n-                                    userOperator.generateMetricsAndLogConfigMap(userOperator.getLogging() instanceof ExternalLogging ?\n-                                            configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) userOperator.getLogging()).getName()) :\n-                                            null) : null;\n+                                    configAnnotation[0] += topicOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n \n-                            String configAnnotation = \"\";\n+                                    if (userOperator.getLogging() instanceof ExternalLogging) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6267d86ffe82112df0f6cdf5ebbe36c8ccdcfd7"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgzODk5OQ==", "bodyText": "the current version is checking both Topic Operator logging \n  \n    \n      strimzi-kafka-operator/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java\n    \n    \n         Line 2675\n      in\n      6527d7a\n    \n    \n    \n    \n\n        \n          \n           topicOperator.generateMetricsAndLogConfigMap(topicOperator.getLogging() instanceof ExternalLogging ? \n        \n    \n  \n\n   and User Operator logging \n  \n    \n      strimzi-kafka-operator/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java\n    \n    \n         Line 2680\n      in\n      6527d7a\n    \n    \n    \n    \n\n        \n          \n           userOperator.generateMetricsAndLogConfigMap(userOperator.getLogging() instanceof ExternalLogging ? \n        \n    \n  \n\n\nShould we be only checking User Operator logging?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r368838999", "createdAt": "2020-01-21T07:08:38Z", "author": {"login": "RickyRajinder"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2660,60 +2616,97 @@ int getPodIndexFromPvcName(String pvcName)  {\n \n         @SuppressWarnings(\"deprecation\")\n         private final Future<ReconciliationState> getEntityOperatorDescription() {\n-            Future<ReconciliationState> fut = Future.future();\n+            EntityOperator entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n \n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").<ReconciliationState>executeBlocking(\n-                future -> {\n-                    try {\n-                        EntityOperator entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n+            if (entityOperator != null) {\n+                EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n+                EntityUserOperator userOperator = entityOperator.getUserOperator();\n \n-                        if (entityOperator != null) {\n-                            EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n-                            EntityUserOperator userOperator = entityOperator.getUserOperator();\n+                final String[] configAnnotation = {\"\"};\n \n-                            ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator != null ?\n-                                    topicOperator.generateMetricsAndLogConfigMap(topicOperator.getLogging() instanceof ExternalLogging ?\n-                                            configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName()) :\n-                                            null) : null;\n+                if (topicOperator != null && userOperator != null) {\n+                    if (topicOperator.getLogging() instanceof ExternalLogging) {\n+                        return configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName())\n+                                .compose(cm -> {\n+                                    ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator.generateMetricsAndLogConfigMap(cm);\n+                                    this.topicOperatorMetricsAndLogsConfigMap = topicOperator.generateMetricsAndLogConfigMap(topicOperatorLogAndMetricsConfigMap);\n \n-                            ConfigMap userOperatorLogAndMetricsConfigMap = userOperator != null ?\n-                                    userOperator.generateMetricsAndLogConfigMap(userOperator.getLogging() instanceof ExternalLogging ?\n-                                            configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) userOperator.getLogging()).getName()) :\n-                                            null) : null;\n+                                    configAnnotation[0] += topicOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n \n-                            String configAnnotation = \"\";\n+                                    if (userOperator.getLogging() instanceof ExternalLogging) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyODI0Ng=="}, "originalCommit": {"oid": "d6267d86ffe82112df0f6cdf5ebbe36c8ccdcfd7"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg2MjY1Mg==", "bodyText": "You need to check both. But right now you have wrapped them into each other. So when if (topicOperator.getLogging() instanceof ExternalLogging) { evalates to false, this if (userOperator.getLogging() instanceof ExternalLogging) { will be never executed.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r368862652", "createdAt": "2020-01-21T08:26:05Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2660,60 +2616,97 @@ int getPodIndexFromPvcName(String pvcName)  {\n \n         @SuppressWarnings(\"deprecation\")\n         private final Future<ReconciliationState> getEntityOperatorDescription() {\n-            Future<ReconciliationState> fut = Future.future();\n+            EntityOperator entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n \n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").<ReconciliationState>executeBlocking(\n-                future -> {\n-                    try {\n-                        EntityOperator entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n+            if (entityOperator != null) {\n+                EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n+                EntityUserOperator userOperator = entityOperator.getUserOperator();\n \n-                        if (entityOperator != null) {\n-                            EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n-                            EntityUserOperator userOperator = entityOperator.getUserOperator();\n+                final String[] configAnnotation = {\"\"};\n \n-                            ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator != null ?\n-                                    topicOperator.generateMetricsAndLogConfigMap(topicOperator.getLogging() instanceof ExternalLogging ?\n-                                            configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName()) :\n-                                            null) : null;\n+                if (topicOperator != null && userOperator != null) {\n+                    if (topicOperator.getLogging() instanceof ExternalLogging) {\n+                        return configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName())\n+                                .compose(cm -> {\n+                                    ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator.generateMetricsAndLogConfigMap(cm);\n+                                    this.topicOperatorMetricsAndLogsConfigMap = topicOperator.generateMetricsAndLogConfigMap(topicOperatorLogAndMetricsConfigMap);\n \n-                            ConfigMap userOperatorLogAndMetricsConfigMap = userOperator != null ?\n-                                    userOperator.generateMetricsAndLogConfigMap(userOperator.getLogging() instanceof ExternalLogging ?\n-                                            configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) userOperator.getLogging()).getName()) :\n-                                            null) : null;\n+                                    configAnnotation[0] += topicOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n \n-                            String configAnnotation = \"\";\n+                                    if (userOperator.getLogging() instanceof ExternalLogging) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyODI0Ng=="}, "originalCommit": {"oid": "d6267d86ffe82112df0f6cdf5ebbe36c8ccdcfd7"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTM5NzU1OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQxMzo1Nzo0MFrOFfK3sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQxMzo1Nzo0MFrOFfK3sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyODI3NA==", "bodyText": "I wonder if this could be somehow split into 3 small methods: getEntityoperatorDescription, getEntityTopicOperatorDescription and getEntityUserOperatorDescription which would split the work and make it easier to chain the async work. But that is just a quick idea, nto sure how well would it work. Right now it seems to dupliacate a bit on the variants with both operators, just one of them etc.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r368228274", "createdAt": "2020-01-18T13:57:40Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2660,60 +2616,97 @@ int getPodIndexFromPvcName(String pvcName)  {\n \n         @SuppressWarnings(\"deprecation\")\n         private final Future<ReconciliationState> getEntityOperatorDescription() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6267d86ffe82112df0f6cdf5ebbe36c8ccdcfd7"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MjMwOTA0OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMjoyOTo1MFrOFgK9nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMjoyOTo1MFrOFgK9nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI3ODM2NQ==", "bodyText": "I didn't actually run any tests with it. But I wonder if you can rewrite this whole thing with something like this?\nprivate final Future<ReconciliationState> getEntityOperatorDescription2() {\n            this.entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n\n            if (entityOperator != null) {\n                EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n                EntityUserOperator userOperator = entityOperator.getUserOperator();\n\n                Future<ConfigMap> futToConfigMap;\n\n                if (topicOperator != null && topicOperator.getLogging() instanceof ExternalLogging)  {\n                    futToConfigMap = configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName());\n                } else {\n                    futToConfigMap = Future.succeededFuture(null);\n                }\n\n                Future<ConfigMap> futUoConfigMap;\n\n                if (userOperator != null && userOperator.getLogging() instanceof ExternalLogging)  {\n                    futUoConfigMap = configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) userOperator.getLogging()).getName());\n                } else {\n                    futUoConfigMap = Future.succeededFuture(null);\n                }\n\n                return CompositeFuture.join(futToConfigMap, futUoConfigMap)\n                        .compose(res -> {\n                            ConfigMap toCm = res.resultAt(0);\n                            ConfigMap uoCm = res.resultAt(1);\n                            String configAnnotation = \"\";\n\n                            if (topicOperator != null && toCm != null)  {\n                                this.topicOperatorMetricsAndLogsConfigMap = topicOperator.generateMetricsAndLogConfigMap(toCm);\n                                configAnnotation += this.topicOperatorMetricsAndLogsConfigMap.getData().get(\"log4j2.properties\");\n                            }\n\n                            if (userOperator != null && uoCm != null)   {\n                                this.userOperatorMetricsAndLogsConfigMap = userOperator.generateMetricsAndLogConfigMap(uoCm);\n                                configAnnotation += this.userOperatorMetricsAndLogsConfigMap.getData().get(\"log4j2.properties\");\n                            }\n\n                            Map<String, String> annotations = new HashMap<>();\n                            annotations.put(io.strimzi.operator.cluster.model.TopicOperator.ANNO_STRIMZI_IO_LOGGING, configAnnotation);\n\n                            this.eoDeployment = entityOperator.generateDeployment(pfa.isOpenshift(), annotations, imagePullPolicy, imagePullSecrets);\n\n                            return Future.succeededFuture(this);\n                        });\n            } else {\n                return Future.succeededFuture(this);\n            }\n        }", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r369278365", "createdAt": "2020-01-21T22:29:50Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2660,60 +2616,112 @@ int getPodIndexFromPvcName(String pvcName)  {\n \n         @SuppressWarnings(\"deprecation\")\n         private final Future<ReconciliationState> getEntityOperatorDescription() {\n-            Future<ReconciliationState> fut = Future.future();\n+            EntityOperator entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n+\n+            if (entityOperator != null) {\n+                EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n+                EntityUserOperator userOperator = entityOperator.getUserOperator();\n+\n+                final String[] configAnnotation = {\"\"};\n+                Map<String, String> annotations = new HashMap<>();\n+\n+                if (topicOperator != null && userOperator != null) {\n+                    if (topicOperator.getLogging() instanceof ExternalLogging && userOperator.getLogging() instanceof ExternalLogging) {\n+                        return getEntityTopicOperatorDescription(configAnnotation, annotations, entityOperator).compose(to ->\n+                                getEntityUserOperatorDescription(configAnnotation, annotations, entityOperator));\n+                    } else if (topicOperator.getLogging() instanceof ExternalLogging) {\n+                        return getEntityTopicOperatorDescription(configAnnotation, annotations, entityOperator).compose(to -> {\n+                            ConfigMap userOperatorLogAndMetricsConfigMap = userOperator.generateMetricsAndLogConfigMap(null);\n+                            this.userOperatorMetricsAndLogsConfigMap = userOperatorLogAndMetricsConfigMap;\n \n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").<ReconciliationState>executeBlocking(\n-                future -> {\n-                    try {\n-                        EntityOperator entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n+                            configAnnotation[0] += userOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n+                            annotations.put(io.strimzi.operator.cluster.model.TopicOperator.ANNO_STRIMZI_IO_LOGGING, configAnnotation[0]);\n \n-                        if (entityOperator != null) {\n-                            EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n-                            EntityUserOperator userOperator = entityOperator.getUserOperator();\n+                            this.entityOperator = entityOperator;\n+                            this.eoDeployment = entityOperator.generateDeployment(pfa.isOpenshift(), annotations, imagePullPolicy, imagePullSecrets);\n \n-                            ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator != null ?\n-                                    topicOperator.generateMetricsAndLogConfigMap(topicOperator.getLogging() instanceof ExternalLogging ?\n-                                            configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName()) :\n-                                            null) : null;\n+                            return Future.succeededFuture(this);\n+                        });\n+                    } else if (userOperator.getLogging() instanceof ExternalLogging) {\n+                        return getEntityUserOperatorDescription(configAnnotation, annotations, entityOperator).compose(uo -> {\n+                            ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator.generateMetricsAndLogConfigMap(null);\n+                            this.topicOperatorMetricsAndLogsConfigMap = topicOperatorLogAndMetricsConfigMap;\n \n-                            ConfigMap userOperatorLogAndMetricsConfigMap = userOperator != null ?\n-                                    userOperator.generateMetricsAndLogConfigMap(userOperator.getLogging() instanceof ExternalLogging ?\n-                                            configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) userOperator.getLogging()).getName()) :\n-                                            null) : null;\n+                            configAnnotation[0] += topicOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n+                            annotations.put(io.strimzi.operator.cluster.model.TopicOperator.ANNO_STRIMZI_IO_LOGGING, configAnnotation[0]);\n \n-                            String configAnnotation = \"\";\n+                            this.entityOperator = entityOperator;\n+                            this.eoDeployment = entityOperator.generateDeployment(pfa.isOpenshift(), annotations, imagePullPolicy, imagePullSecrets);\n \n-                            if (topicOperatorLogAndMetricsConfigMap != null)    {\n-                                configAnnotation += topicOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n-                            }\n+                            return Future.succeededFuture(this);\n+                        });\n+                    } else {\n+                        ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator.generateMetricsAndLogConfigMap(null);\n+                        configAnnotation[0] += topicOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n \n-                            if (userOperatorLogAndMetricsConfigMap != null)    {\n-                                configAnnotation += userOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n-                            }\n+                        ConfigMap userOperatorLogAndMetricsConfigMap = userOperator.generateMetricsAndLogConfigMap(null);\n+                        configAnnotation[0] += userOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n \n-                            Map<String, String> annotations = new HashMap<>();\n-                            annotations.put(io.strimzi.operator.cluster.model.TopicOperator.ANNO_STRIMZI_IO_LOGGING, configAnnotation);\n+                        annotations.put(io.strimzi.operator.cluster.model.TopicOperator.ANNO_STRIMZI_IO_LOGGING, configAnnotation[0]);\n \n-                            this.entityOperator = entityOperator;\n-                            this.eoDeployment = entityOperator.generateDeployment(pfa.isOpenshift(), annotations, imagePullPolicy, imagePullSecrets);\n-                            this.topicOperatorMetricsAndLogsConfigMap = topicOperatorLogAndMetricsConfigMap;\n-                            this.userOperatorMetricsAndLogsConfigMap = userOperatorLogAndMetricsConfigMap;\n-                        }\n+                        this.entityOperator = entityOperator;\n+                        this.eoDeployment = entityOperator.generateDeployment(pfa.isOpenshift(), annotations, imagePullPolicy, imagePullSecrets);\n+                        this.topicOperatorMetricsAndLogsConfigMap = topicOperatorLogAndMetricsConfigMap;\n+                        this.userOperatorMetricsAndLogsConfigMap = userOperatorLogAndMetricsConfigMap;\n \n-                        future.complete(this);\n-                    } catch (Throwable e) {\n-                        future.fail(e);\n+                        return Future.succeededFuture(this);\n                     }\n-                }, true,\n-                res -> {\n-                    if (res.succeeded()) {\n-                        fut.complete(res.result());\n-                    } else {\n-                        fut.fail(res.cause());\n+                }\n+                if (topicOperator != null) {\n+                    if (topicOperator.getLogging() instanceof ExternalLogging) {\n+                        return getEntityTopicOperatorDescription(configAnnotation, annotations, entityOperator);\n                     }\n                 }\n-            );\n-            return fut;\n+                if (userOperator != null) {\n+                    if (userOperator.getLogging() instanceof ExternalLogging) {\n+                        return getEntityUserOperatorDescription(configAnnotation, annotations, entityOperator);\n+                    }\n+                }\n+            }\n+            return Future.succeededFuture(this);\n+        }\n+\n+        @SuppressWarnings(\"deprecation\")\n+        private Future<ReconciliationState> getEntityTopicOperatorDescription(final String[] configAnnotation, Map<String, String> annotations, EntityOperator entityOperator) {\n+            EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n+            return configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName())\n+                    .compose(cm -> {\n+                        ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator.generateMetricsAndLogConfigMap(cm);\n+                        this.topicOperatorMetricsAndLogsConfigMap = topicOperator.generateMetricsAndLogConfigMap(topicOperatorLogAndMetricsConfigMap);\n+\n+                        configAnnotation[0] += topicOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n+\n+                        annotations.put(io.strimzi.operator.cluster.model.TopicOperator.ANNO_STRIMZI_IO_LOGGING, configAnnotation[0]);\n+\n+                        this.entityOperator = entityOperator;\n+                        this.eoDeployment = entityOperator.generateDeployment(pfa.isOpenshift(), annotations, imagePullPolicy, imagePullSecrets);\n+\n+                        return Future.succeededFuture(null);\n+                    });\n+        }\n+\n+        @SuppressWarnings(\"deprecation\")\n+        private Future<ReconciliationState> getEntityUserOperatorDescription(final String[] configAnnotation, Map<String, String> annotations, EntityOperator entityOperator) {\n+            EntityUserOperator userOperator = entityOperator.getUserOperator();\n+            return configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) userOperator.getLogging()).getName())\n+                    .compose(cm -> {\n+                        ConfigMap userOperatorLogAndMetricsConfigMap = userOperator.generateMetricsAndLogConfigMap(cm);\n+                        this.userOperatorMetricsAndLogsConfigMap = userOperator.generateMetricsAndLogConfigMap(userOperatorLogAndMetricsConfigMap);\n+\n+                        configAnnotation[0] += userOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n+\n+                        annotations.put(io.strimzi.operator.cluster.model.TopicOperator.ANNO_STRIMZI_IO_LOGGING, configAnnotation[0]);\n+\n+                        this.entityOperator = entityOperator;\n+                        this.eoDeployment = entityOperator.generateDeployment(pfa.isOpenshift(), annotations, imagePullPolicy, imagePullSecrets);\n+\n+                        return Future.succeededFuture(this);\n+                    });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c7c2b15826ac75d40bac22aba189e599c723cec"}, "originalPosition": 304}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MzY1OTAzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNlQyMDo0NDo0OFrOFh1waA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNlQyMDo0NDo0OFrOFh1waA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAyODA3Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        if (topicOperator != null && toCm != null)  {\n          \n          \n            \n                                        if (topicOperator != null)  {", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r371028072", "createdAt": "2020-01-26T20:44:48Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2660,60 +2616,54 @@ int getPodIndexFromPvcName(String pvcName)  {\n \n         @SuppressWarnings(\"deprecation\")\n         private final Future<ReconciliationState> getEntityOperatorDescription() {\n-            Future<ReconciliationState> fut = Future.future();\n+            this.entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n \n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").<ReconciliationState>executeBlocking(\n-                future -> {\n-                    try {\n-                        EntityOperator entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n+            if (entityOperator != null) {\n+                EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n+                EntityUserOperator userOperator = entityOperator.getUserOperator();\n \n-                        if (entityOperator != null) {\n-                            EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n-                            EntityUserOperator userOperator = entityOperator.getUserOperator();\n+                Future<ConfigMap> futToConfigMap;\n \n-                            ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator != null ?\n-                                    topicOperator.generateMetricsAndLogConfigMap(topicOperator.getLogging() instanceof ExternalLogging ?\n-                                            configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName()) :\n-                                            null) : null;\n+                if (topicOperator != null && topicOperator.getLogging() instanceof ExternalLogging)  {\n+                    futToConfigMap = configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName());\n+                } else {\n+                    futToConfigMap = Future.succeededFuture(null);\n+                }\n \n-                            ConfigMap userOperatorLogAndMetricsConfigMap = userOperator != null ?\n-                                    userOperator.generateMetricsAndLogConfigMap(userOperator.getLogging() instanceof ExternalLogging ?\n-                                            configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) userOperator.getLogging()).getName()) :\n-                                            null) : null;\n+                Future<ConfigMap> futUoConfigMap;\n \n+                if (userOperator != null && userOperator.getLogging() instanceof ExternalLogging)  {\n+                    futUoConfigMap = configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) userOperator.getLogging()).getName());\n+                } else {\n+                    futUoConfigMap = Future.succeededFuture(null);\n+                }\n+\n+                return CompositeFuture.join(futToConfigMap, futUoConfigMap)\n+                        .compose(res -> {\n+                            ConfigMap toCm = res.resultAt(0);\n+                            ConfigMap uoCm = res.resultAt(1);\n                             String configAnnotation = \"\";\n \n-                            if (topicOperatorLogAndMetricsConfigMap != null)    {\n-                                configAnnotation += topicOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n+                            if (topicOperator != null && toCm != null)  {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9c3f405f15398e52981dd3908d9e96812479700"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MzY1OTExOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNlQyMDo0NTowMVrOFh1wcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNlQyMDo0NTowMVrOFh1wcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAyODA4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        if (userOperator != null && uoCm != null)   {\n          \n          \n            \n                                        if (userOperator != null)   {", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2399#discussion_r371028081", "createdAt": "2020-01-26T20:45:01Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2660,60 +2616,54 @@ int getPodIndexFromPvcName(String pvcName)  {\n \n         @SuppressWarnings(\"deprecation\")\n         private final Future<ReconciliationState> getEntityOperatorDescription() {\n-            Future<ReconciliationState> fut = Future.future();\n+            this.entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n \n-            vertx.createSharedWorkerExecutor(\"kubernetes-ops-pool\").<ReconciliationState>executeBlocking(\n-                future -> {\n-                    try {\n-                        EntityOperator entityOperator = EntityOperator.fromCrd(kafkaAssembly, versions);\n+            if (entityOperator != null) {\n+                EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n+                EntityUserOperator userOperator = entityOperator.getUserOperator();\n \n-                        if (entityOperator != null) {\n-                            EntityTopicOperator topicOperator = entityOperator.getTopicOperator();\n-                            EntityUserOperator userOperator = entityOperator.getUserOperator();\n+                Future<ConfigMap> futToConfigMap;\n \n-                            ConfigMap topicOperatorLogAndMetricsConfigMap = topicOperator != null ?\n-                                    topicOperator.generateMetricsAndLogConfigMap(topicOperator.getLogging() instanceof ExternalLogging ?\n-                                            configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName()) :\n-                                            null) : null;\n+                if (topicOperator != null && topicOperator.getLogging() instanceof ExternalLogging)  {\n+                    futToConfigMap = configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) topicOperator.getLogging()).getName());\n+                } else {\n+                    futToConfigMap = Future.succeededFuture(null);\n+                }\n \n-                            ConfigMap userOperatorLogAndMetricsConfigMap = userOperator != null ?\n-                                    userOperator.generateMetricsAndLogConfigMap(userOperator.getLogging() instanceof ExternalLogging ?\n-                                            configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) userOperator.getLogging()).getName()) :\n-                                            null) : null;\n+                Future<ConfigMap> futUoConfigMap;\n \n+                if (userOperator != null && userOperator.getLogging() instanceof ExternalLogging)  {\n+                    futUoConfigMap = configMapOperations.getAsync(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) userOperator.getLogging()).getName());\n+                } else {\n+                    futUoConfigMap = Future.succeededFuture(null);\n+                }\n+\n+                return CompositeFuture.join(futToConfigMap, futUoConfigMap)\n+                        .compose(res -> {\n+                            ConfigMap toCm = res.resultAt(0);\n+                            ConfigMap uoCm = res.resultAt(1);\n                             String configAnnotation = \"\";\n \n-                            if (topicOperatorLogAndMetricsConfigMap != null)    {\n-                                configAnnotation += topicOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n+                            if (topicOperator != null && toCm != null)  {\n+                                this.topicOperatorMetricsAndLogsConfigMap = topicOperator.generateMetricsAndLogConfigMap(toCm);\n+                                configAnnotation += this.topicOperatorMetricsAndLogsConfigMap.getData().get(\"log4j2.properties\");\n                             }\n \n-                            if (userOperatorLogAndMetricsConfigMap != null)    {\n-                                configAnnotation += userOperatorLogAndMetricsConfigMap.getData().get(\"log4j2.properties\");\n+                            if (userOperator != null && uoCm != null)   {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9c3f405f15398e52981dd3908d9e96812479700"}, "originalPosition": 211}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 606, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}