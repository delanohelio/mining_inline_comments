{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA5ODIyNjgz", "number": 3873, "reviewThreads": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwOTowNToxN1rOExzoyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMTo1MTozMVrOE7QlbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNjYxNzA3OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwOTowNToxN1rOHoGPpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODo0MToyM1rOHpfOqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwNzM5Ng==", "bodyText": "Why is this in any way relevant only to this ST? Also, sleeping for the whole reconciliation interval could be waste of time. You should check periodically with some small backoff for example to make sure you don't waste time on it.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r511807396", "createdAt": "2020-10-26T09:05:17Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,6 +100,15 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n+        LOGGER.info(\"Waiting for reconciliation to happen. \" +\n+                \"Giving some time to DNS/load balancer to propagate kafka address.\" +\n+                \"Sleeping for {}ms\", Constants.RECONCILIATION_INTERVAL);\n+        try {\n+            Thread.sleep(Constants.RECONCILIATION_INTERVAL);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef35a4e7393c0d91afbdeb2f94c3c95d3435e6c3"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI2NTMyMg==", "bodyText": "Removed with LB and External clients usage.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r513265322", "createdAt": "2020-10-28T08:41:23Z", "author": {"login": "michalxo"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,6 +100,15 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n+        LOGGER.info(\"Waiting for reconciliation to happen. \" +\n+                \"Giving some time to DNS/load balancer to propagate kafka address.\" +\n+                \"Sleeping for {}ms\", Constants.RECONCILIATION_INTERVAL);\n+        try {\n+            Thread.sleep(Constants.RECONCILIATION_INTERVAL);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwNzM5Ng=="}, "originalCommit": {"oid": "ef35a4e7393c0d91afbdeb2f94c3c95d3435e6c3"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MjMwNTExOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMjo1MToxM1rOHtWulA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTo0NTozOVrOHteCOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMyMDM0MA==", "bodyText": "I guess ideally you should also deploy some connector and send some messages to verify it is all working and is connected.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r517320340", "createdAt": "2020-11-04T12:51:13Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +103,84 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    void testRackAwareConnect() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a3b390216fae011b06b50920aa3a692238c448"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ0MDA1OQ==", "bodyText": "#3917", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r517440059", "createdAt": "2020-11-04T15:45:39Z", "author": {"login": "git175"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +103,84 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    void testRackAwareConnect() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMyMDM0MA=="}, "originalCommit": {"oid": "14a3b390216fae011b06b50920aa3a692238c448"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0Mjg2MDAwOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTowMToyN1rOHtcEJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTowMToyN1rOHtcEJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQwNzc4Mg==", "bodyText": "You should add REGRESSION tag here", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r517407782", "createdAt": "2020-11-04T15:01:27Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -56,8 +69,6 @@\n     public static final String NAMESPACE = \"specific-cluster-test\";\n \n     @Test\n-    @Tag(LOADBALANCER_SUPPORTED)\n-    @Tag(EXTERNAL_CLIENTS_USED)\n     void testRackAware() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a3b390216fae011b06b50920aa3a692238c448"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0Mjg2MDY0OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTowMTozNlrOHtcElg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTowMTozNlrOHtcElg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQwNzg5NA==", "bodyText": "Same as above", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r517407894", "createdAt": "2020-11-04T15:01:36Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +103,84 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    void testRackAwareConnect() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a3b390216fae011b06b50920aa3a692238c448"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0Mjg2MjYxOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTowMjowMFrOHtcFvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTowMjowMFrOHtcFvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQwODE4OQ==", "bodyText": "Indent", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r517408189", "createdAt": "2020-11-04T15:02:00Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +103,84 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    void testRackAwareConnect() {\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                .editKafka()\n+                .withNewRack()\n+                .withTopologyKey(rackKey)\n+                .endRack()\n+                .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                .endKafka()\n+                .endSpec().done();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a3b390216fae011b06b50920aa3a692238c448"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0Mjg2MzEyOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTowMjowOVrOHtcGEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTowMjowOVrOHtcGEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQwODI3NQ==", "bodyText": "Indent", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r517408275", "createdAt": "2020-11-04T15:02:09Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +103,84 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    void testRackAwareConnect() {\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                .editKafka()\n+                .withNewRack()\n+                .withTopologyKey(rackKey)\n+                .endRack()\n+                .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                .withNewRack()\n+                .withTopologyKey(wrongRackKey)\n+                .endRack()\n+                .endSpec()\n+                .build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a3b390216fae011b06b50920aa3a692238c448"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0Mjg2NTA2OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTowMjoyNFrOHtcHHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTowMjoyNFrOHtcHHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQwODU0Mg==", "bodyText": "indent", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r517408542", "createdAt": "2020-11-04T15:02:24Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +103,84 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    void testRackAwareConnect() {\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                .editKafka()\n+                .withNewRack()\n+                .withTopologyKey(rackKey)\n+                .endRack()\n+                .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                .withNewRack()\n+                .withTopologyKey(wrongRackKey)\n+                .endRack()\n+                .endSpec()\n+                .build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+        assertThat(kcWrongStatus.getConditions().get(0).getMessage(), containsString(\"didn't match node selector\"));\n+        KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).withPropagationPolicy(DeletionPropagation.FOREGROUND).delete();\n+        PodUtils.deletePodWithWait(connectWrongPodName);\n+\n+        LOGGER.info(\"Deploy KafkaConnect with correct rack-aware topology key: {}\", rackKey);\n+        KafkaConnectResource.kafkaConnect(CLUSTER_NAME, 2)\n+                .editSpec()\n+                .withNewRack()\n+                .withTopologyKey(rackKey)\n+                .endRack()\n+                .endSpec()\n+                .done();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a3b390216fae011b06b50920aa3a692238c448"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0Mjg5NTQzOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTowOTowN1rOHtcZ2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNToxNToyN1rOHtcrsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxMzMzNw==", "bodyText": "Wouldn't be better to check KC status instead of pod status which is set by kubernetes? If there is something useful of course.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r517413337", "createdAt": "2020-11-04T15:09:07Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +103,84 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    void testRackAwareConnect() {\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                .editKafka()\n+                .withNewRack()\n+                .withTopologyKey(rackKey)\n+                .endRack()\n+                .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                .withNewRack()\n+                .withTopologyKey(wrongRackKey)\n+                .endRack()\n+                .endSpec()\n+                .build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a3b390216fae011b06b50920aa3a692238c448"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxNzkwNw==", "bodyText": "I will check it out. Thanks for pointer.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r517417907", "createdAt": "2020-11-04T15:15:27Z", "author": {"login": "michalxo"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +103,84 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    void testRackAwareConnect() {\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                .editKafka()\n+                .withNewRack()\n+                .withTopologyKey(rackKey)\n+                .endRack()\n+                .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                .withNewRack()\n+                .withTopologyKey(wrongRackKey)\n+                .endRack()\n+                .endSpec()\n+                .build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxMzMzNw=="}, "originalCommit": {"oid": "14a3b390216fae011b06b50920aa3a692238c448"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NzM1NDE4OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDo1MDozOVrOHuG4Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDo1MDozOVrOHuG4Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODEwOTIxMQ==", "bodyText": "Didn't you had some waitFor methods which can do this in a more efficient way?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r518109211", "createdAt": "2020-11-05T14:50:39Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +109,120 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnect() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        Thread.sleep(CO_OPERATION_TIMEOUT_SHORT + 10000);\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "872a420efbc02018f9b12b676dab17786d08ca09"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NzM1OTg3OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDo1MTo0N1rOHuG7tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNTowNjozOFrOHuHoHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODExMDEzMg==", "bodyText": "I wonder if we do really want to have the error text hardcoded. It is often different with Kubernetes versions and makes the test lass portable and future-proof.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r518110132", "createdAt": "2020-11-05T14:51:47Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +109,120 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnect() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        Thread.sleep(CO_OPERATION_TIMEOUT_SHORT + 10000);\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+        assertThat(kcWrongStatus.getConditions().get(0).getMessage(), containsString(\"didn't match node selector\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "872a420efbc02018f9b12b676dab17786d08ca09"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODEyMTUwMg==", "bodyText": "Yeah, I was thinking the same if it should be regexp or this line should be completely omitted.\nI will remove it for KISS.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r518121502", "createdAt": "2020-11-05T15:06:38Z", "author": {"login": "michalxo"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +109,120 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnect() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        Thread.sleep(CO_OPERATION_TIMEOUT_SHORT + 10000);\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+        assertThat(kcWrongStatus.getConditions().get(0).getMessage(), containsString(\"didn't match node selector\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODExMDEzMg=="}, "originalCommit": {"oid": "872a420efbc02018f9b12b676dab17786d08ca09"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NzM2NTg5OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDo1MzowNFrOHuG_lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNDo1ODowNVrOH2infg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODExMTEyNg==", "bodyText": "Maybe if you already start with a wrong rack, you could also just change the Connect CR and see that it recovers instead of deleting it?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r518111126", "createdAt": "2020-11-05T14:53:04Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +109,120 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnect() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        Thread.sleep(CO_OPERATION_TIMEOUT_SHORT + 10000);\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+        assertThat(kcWrongStatus.getConditions().get(0).getMessage(), containsString(\"didn't match node selector\"));\n+        KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).withPropagationPolicy(DeletionPropagation.FOREGROUND).delete();\n+        PodUtils.deletePodWithWait(connectWrongPodName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "872a420efbc02018f9b12b676dab17786d08ca09"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODExNDg5Nw==", "bodyText": "I was thinking about it while writing this test. After your suggestion, I think that probably it should be a different test.\nOr even better this test split into two.\n\nPositive case (second portion of test)\nNegative case (incorrect rack-key) with happy-ending (edit pf CR as you suggest)\n\nWDYT @Frawless @scholzj", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r518114897", "createdAt": "2020-11-05T14:57:46Z", "author": {"login": "michalxo"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +109,120 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnect() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        Thread.sleep(CO_OPERATION_TIMEOUT_SHORT + 10000);\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+        assertThat(kcWrongStatus.getConditions().get(0).getMessage(), containsString(\"didn't match node selector\"));\n+        KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).withPropagationPolicy(DeletionPropagation.FOREGROUND).delete();\n+        PodUtils.deletePodWithWait(connectWrongPodName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODExMTEyNg=="}, "originalCommit": {"oid": "872a420efbc02018f9b12b676dab17786d08ca09"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODEyMzI0OQ==", "bodyText": "Sounds good to me.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r518123249", "createdAt": "2020-11-05T15:09:02Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +109,120 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnect() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        Thread.sleep(CO_OPERATION_TIMEOUT_SHORT + 10000);\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+        assertThat(kcWrongStatus.getConditions().get(0).getMessage(), containsString(\"didn't match node selector\"));\n+        KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).withPropagationPolicy(DeletionPropagation.FOREGROUND).delete();\n+        PodUtils.deletePodWithWait(connectWrongPodName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODExMTEyNg=="}, "originalCommit": {"oid": "872a420efbc02018f9b12b676dab17786d08ca09"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODEyNjU0Mg==", "bodyText": "Ye, sounds reasonable. What about recovery from the wrong rack? Isn't it something which could be useful for KafkaRoller coverage?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r518126542", "createdAt": "2020-11-05T15:13:30Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +109,120 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnect() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        Thread.sleep(CO_OPERATION_TIMEOUT_SHORT + 10000);\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+        assertThat(kcWrongStatus.getConditions().get(0).getMessage(), containsString(\"didn't match node selector\"));\n+        KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).withPropagationPolicy(DeletionPropagation.FOREGROUND).delete();\n+        PodUtils.deletePodWithWait(connectWrongPodName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODExMTEyNg=="}, "originalCommit": {"oid": "872a420efbc02018f9b12b676dab17786d08ca09"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjkzNTUxMg==", "bodyText": "What do you mean by recovery from wrong rack? @Frawless - Is this question targeted at me or @scholzj ?\nI added both tests now into PR. Locally they are passing, but I think they will fail in this PR's as we will miss rack-key label on nodes...", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r526935512", "createdAt": "2020-11-19T14:37:00Z", "author": {"login": "michalxo"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +109,120 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnect() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        Thread.sleep(CO_OPERATION_TIMEOUT_SHORT + 10000);\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+        assertThat(kcWrongStatus.getConditions().get(0).getMessage(), containsString(\"didn't match node selector\"));\n+        KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).withPropagationPolicy(DeletionPropagation.FOREGROUND).delete();\n+        PodUtils.deletePodWithWait(connectWrongPodName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODExMTEyNg=="}, "originalCommit": {"oid": "872a420efbc02018f9b12b676dab17786d08ca09"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjkzOTYyMg==", "bodyText": "You deploy it with the wrong one => check it fails => fix it to the correct one in the CR => check that the operator recovers from it and fixes it.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r526939622", "createdAt": "2020-11-19T14:42:21Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +109,120 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnect() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        Thread.sleep(CO_OPERATION_TIMEOUT_SHORT + 10000);\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+        assertThat(kcWrongStatus.getConditions().get(0).getMessage(), containsString(\"didn't match node selector\"));\n+        KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).withPropagationPolicy(DeletionPropagation.FOREGROUND).delete();\n+        PodUtils.deletePodWithWait(connectWrongPodName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODExMTEyNg=="}, "originalCommit": {"oid": "872a420efbc02018f9b12b676dab17786d08ca09"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk1MjMxOA==", "bodyText": "Yup, that's what I did I believe in testRackAwareConnectWrongDeployment :-)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r526952318", "createdAt": "2020-11-19T14:58:05Z", "author": {"login": "michalxo"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +109,120 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnect() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        Thread.sleep(CO_OPERATION_TIMEOUT_SHORT + 10000);\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+        assertThat(kcWrongStatus.getConditions().get(0).getMessage(), containsString(\"didn't match node selector\"));\n+        KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).withPropagationPolicy(DeletionPropagation.FOREGROUND).delete();\n+        PodUtils.deletePodWithWait(connectWrongPodName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODExMTEyNg=="}, "originalCommit": {"oid": "872a420efbc02018f9b12b676dab17786d08ca09"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDQ1OTk3OnYy", "diffSide": "RIGHT", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/kafkaUtils/KafkaConnectUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozMToyNlrOH2nGhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozMToyNlrOH2nGhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyNTc5OQ==", "bodyText": "It's not a test", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527025799", "createdAt": "2020-11-19T16:31:26Z", "author": {"login": "Frawless"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/kafkaUtils/KafkaConnectUtils.java", "diffHunk": "@@ -78,4 +80,33 @@ public static void waitForKafkaConnectConfigChange(String propertyKey, String pr\n             });\n         LOGGER.info(\"Kafka Connect property {} -> {} change\", propertyKey, propertyValue);\n     }\n+\n+    /**\n+     * Test sending and receiving messages through file sink connector (using Kafka Connect).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDQ2MDkwOnYy", "diffSide": "RIGHT", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/kafkaUtils/KafkaConnectUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozMTozOFrOH2nHJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozMTozOFrOH2nHJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyNTk1OA==", "bodyText": "Same as above", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527025958", "createdAt": "2020-11-19T16:31:38Z", "author": {"login": "Frawless"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/kafkaUtils/KafkaConnectUtils.java", "diffHunk": "@@ -78,4 +80,33 @@ public static void waitForKafkaConnectConfigChange(String propertyKey, String pr\n             });\n         LOGGER.info(\"Kafka Connect property {} -> {} change\", propertyKey, propertyValue);\n     }\n+\n+    /**\n+     * Test sending and receiving messages through file sink connector (using Kafka Connect).\n+     * @param connectPodName kafkaConnect pod name\n+     * @param topicName topic to be used\n+     * @param kafkaClientsPodName kafkaClients pod name\n+     * @param namespace namespace name\n+     * @param clusterName cluster name\n+     */\n+    public static void sendReceiveMessagesThroughConnect(String connectPodName, String topicName, String kafkaClientsPodName, String namespace, String clusterName) {\n+        LOGGER.info(\"Test sending and receiving messages through KafkaConnect\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDQ3MDM2OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozMzo0M1rOH2nNHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMTozNzozNVrOH2ywfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyNzQ4Ng==", "bodyText": "Move it to some utils class? You basically wait until KC is not ready, I don't see any specific message in status. Also, the test will wait 5 minutes until deployment will timeout. WOuldn't be enough just to wait for the pending, wait for the next reconciliation, check if the pod is still pending, and then proceed?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527027486", "createdAt": "2020-11-19T16:33:43Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,151 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnectWrongDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .addToConfig(\"key.converter.schemas.enable\", false)\n+                .addToConfig(\"value.converter.schemas.enable\", false)\n+                .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        TestUtils.waitFor(\"Wait for KafkaConnect 'Unschedulable' condition due to wrong rackKey used.\",\n+                Constants.GLOBAL_POLL_INTERVAL, CO_OPERATION_TIMEOUT_SHORT * 2, () -> {\n+                List<Condition> conditions = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getStatus().getConditions();\n+                for (Condition condition : conditions) {\n+                    if (condition.getReason().matches(\"TimeoutException\") && condition.getType().matches(\"NotReady\")) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA5MTE4OQ==", "bodyText": "Makes sense to move it to KCUtils.waitUntilCondition(Reason, Type). Good idea.\nActually it will wait only 1min as long CO_OPERATION_TIMEOUT_SHORT = Duration.ofSeconds(30).toMillis(); *2", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527091189", "createdAt": "2020-11-19T18:03:30Z", "author": {"login": "michalxo"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,151 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnectWrongDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .addToConfig(\"key.converter.schemas.enable\", false)\n+                .addToConfig(\"value.converter.schemas.enable\", false)\n+                .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        TestUtils.waitFor(\"Wait for KafkaConnect 'Unschedulable' condition due to wrong rackKey used.\",\n+                Constants.GLOBAL_POLL_INTERVAL, CO_OPERATION_TIMEOUT_SHORT * 2, () -> {\n+                List<Condition> conditions = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getStatus().getConditions();\n+                for (Condition condition : conditions) {\n+                    if (condition.getReason().matches(\"TimeoutException\") && condition.getType().matches(\"NotReady\")) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyNzQ4Ng=="}, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIxNjc2Ng==", "bodyText": "I see. Anyway, move it is still a good idea :)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527216766", "createdAt": "2020-11-19T21:37:35Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,151 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnectWrongDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .addToConfig(\"key.converter.schemas.enable\", false)\n+                .addToConfig(\"value.converter.schemas.enable\", false)\n+                .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        TestUtils.waitFor(\"Wait for KafkaConnect 'Unschedulable' condition due to wrong rackKey used.\",\n+                Constants.GLOBAL_POLL_INTERVAL, CO_OPERATION_TIMEOUT_SHORT * 2, () -> {\n+                List<Condition> conditions = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getStatus().getConditions();\n+                for (Condition condition : conditions) {\n+                    if (condition.getReason().matches(\"TimeoutException\") && condition.getType().matches(\"NotReady\")) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyNzQ4Ng=="}, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDQ3MjMxOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozNDoxMlrOH2nOXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxODowNDoxOVrOH2rICg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyNzgwNQ==", "bodyText": "Why do you assert something, which is verified a few lines above?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527027805", "createdAt": "2020-11-19T16:34:12Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,151 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnectWrongDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .addToConfig(\"key.converter.schemas.enable\", false)\n+                .addToConfig(\"value.converter.schemas.enable\", false)\n+                .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        TestUtils.waitFor(\"Wait for KafkaConnect 'Unschedulable' condition due to wrong rackKey used.\",\n+                Constants.GLOBAL_POLL_INTERVAL, CO_OPERATION_TIMEOUT_SHORT * 2, () -> {\n+                List<Condition> conditions = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getStatus().getConditions();\n+                for (Condition condition : conditions) {\n+                    if (condition.getReason().matches(\"TimeoutException\") && condition.getType().matches(\"NotReady\")) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            });\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA5MTcyMg==", "bodyText": "Thanks, left-over from previous test case (work).", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527091722", "createdAt": "2020-11-19T18:04:19Z", "author": {"login": "michalxo"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,151 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnectWrongDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .addToConfig(\"key.converter.schemas.enable\", false)\n+                .addToConfig(\"value.converter.schemas.enable\", false)\n+                .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        TestUtils.waitFor(\"Wait for KafkaConnect 'Unschedulable' condition due to wrong rackKey used.\",\n+                Constants.GLOBAL_POLL_INTERVAL, CO_OPERATION_TIMEOUT_SHORT * 2, () -> {\n+                List<Condition> conditions = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getStatus().getConditions();\n+                for (Condition condition : conditions) {\n+                    if (condition.getReason().matches(\"TimeoutException\") && condition.getType().matches(\"NotReady\")) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            });\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyNzgwNQ=="}, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDQ3NzI1OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozNTowNlrOH2nRUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozNTowNlrOH2nRUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyODU2MQ==", "bodyText": "maybe put rack key into the log as well?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527028561", "createdAt": "2020-11-19T16:35:06Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,151 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnectWrongDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .addToConfig(\"key.converter.schemas.enable\", false)\n+                .addToConfig(\"value.converter.schemas.enable\", false)\n+                .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        TestUtils.waitFor(\"Wait for KafkaConnect 'Unschedulable' condition due to wrong rackKey used.\",\n+                Constants.GLOBAL_POLL_INTERVAL, CO_OPERATION_TIMEOUT_SHORT * 2, () -> {\n+                List<Condition> conditions = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getStatus().getConditions();\n+                for (Condition condition : conditions) {\n+                    if (condition.getReason().matches(\"TimeoutException\") && condition.getType().matches(\"NotReady\")) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            });\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CLUSTER_NAME, kafkaConnect -> {\n+            kafkaConnect.getSpec().setRack(new Rack(rackKey));\n+        });\n+        KafkaConnectUtils.waitForConnectReady(CLUSTER_NAME);\n+        LOGGER.info(\"KafkaConnect is ready with changed rack key.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDQ4NTQyOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozNjo1MVrOH2nWTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMTo0ODozOVrOH2zOog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyOTgzOQ==", "bodyText": "isn't it by default applied for each KC which we create during tests?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527029839", "createdAt": "2020-11-19T16:36:51Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,151 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnectWrongDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .addToConfig(\"key.converter.schemas.enable\", false)\n+                .addToConfig(\"value.converter.schemas.enable\", false)\n+                .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        TestUtils.waitFor(\"Wait for KafkaConnect 'Unschedulable' condition due to wrong rackKey used.\",\n+                Constants.GLOBAL_POLL_INTERVAL, CO_OPERATION_TIMEOUT_SHORT * 2, () -> {\n+                List<Condition> conditions = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getStatus().getConditions();\n+                for (Condition condition : conditions) {\n+                    if (condition.getReason().matches(\"TimeoutException\") && condition.getType().matches(\"NotReady\")) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            });\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CLUSTER_NAME, kafkaConnect -> {\n+            kafkaConnect.getSpec().setRack(new Rack(rackKey));\n+        });\n+        KafkaConnectUtils.waitForConnectReady(CLUSTER_NAME);\n+        LOGGER.info(\"KafkaConnect is ready with changed rack key.\");\n+        LOGGER.info(\"Verify KafkaConnect rack key update\");\n+        kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        assertThat(kc.getSpec().getRack().getTopologyKey(), is(rackKey));\n+\n+        if (Environment.DEFAULT_TO_DENY_NETWORK_POLICIES.equals(Boolean.TRUE.toString())) {\n+            KubernetesResource.allowNetworkPolicySettingsForResource(kc, KafkaConnectResources.deploymentName(kc.getMetadata().getName()));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA5MjgwNA==", "bodyText": "No, as I am not using specifically KafkaConnectResource.deployKafkaConnect() method. @im-konge also mentioned me this today.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527092804", "createdAt": "2020-11-19T18:06:02Z", "author": {"login": "michalxo"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,151 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnectWrongDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .addToConfig(\"key.converter.schemas.enable\", false)\n+                .addToConfig(\"value.converter.schemas.enable\", false)\n+                .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        TestUtils.waitFor(\"Wait for KafkaConnect 'Unschedulable' condition due to wrong rackKey used.\",\n+                Constants.GLOBAL_POLL_INTERVAL, CO_OPERATION_TIMEOUT_SHORT * 2, () -> {\n+                List<Condition> conditions = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getStatus().getConditions();\n+                for (Condition condition : conditions) {\n+                    if (condition.getReason().matches(\"TimeoutException\") && condition.getType().matches(\"NotReady\")) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            });\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CLUSTER_NAME, kafkaConnect -> {\n+            kafkaConnect.getSpec().setRack(new Rack(rackKey));\n+        });\n+        KafkaConnectUtils.waitForConnectReady(CLUSTER_NAME);\n+        LOGGER.info(\"KafkaConnect is ready with changed rack key.\");\n+        LOGGER.info(\"Verify KafkaConnect rack key update\");\n+        kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        assertThat(kc.getSpec().getRack().getTopologyKey(), is(rackKey));\n+\n+        if (Environment.DEFAULT_TO_DENY_NETWORK_POLICIES.equals(Boolean.TRUE.toString())) {\n+            KubernetesResource.allowNetworkPolicySettingsForResource(kc, KafkaConnectResources.deploymentName(kc.getMetadata().getName()));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyOTgzOQ=="}, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIxOTY3Mw==", "bodyText": "I don't say you have to change it in this PR, but maybe we should think about applying the NP in kafkaConnectWithoutWait as we do in deployKafkaConnect", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527219673", "createdAt": "2020-11-19T21:40:38Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,151 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnectWrongDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .addToConfig(\"key.converter.schemas.enable\", false)\n+                .addToConfig(\"value.converter.schemas.enable\", false)\n+                .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        TestUtils.waitFor(\"Wait for KafkaConnect 'Unschedulable' condition due to wrong rackKey used.\",\n+                Constants.GLOBAL_POLL_INTERVAL, CO_OPERATION_TIMEOUT_SHORT * 2, () -> {\n+                List<Condition> conditions = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getStatus().getConditions();\n+                for (Condition condition : conditions) {\n+                    if (condition.getReason().matches(\"TimeoutException\") && condition.getType().matches(\"NotReady\")) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            });\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CLUSTER_NAME, kafkaConnect -> {\n+            kafkaConnect.getSpec().setRack(new Rack(rackKey));\n+        });\n+        KafkaConnectUtils.waitForConnectReady(CLUSTER_NAME);\n+        LOGGER.info(\"KafkaConnect is ready with changed rack key.\");\n+        LOGGER.info(\"Verify KafkaConnect rack key update\");\n+        kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        assertThat(kc.getSpec().getRack().getTopologyKey(), is(rackKey));\n+\n+        if (Environment.DEFAULT_TO_DENY_NETWORK_POLICIES.equals(Boolean.TRUE.toString())) {\n+            KubernetesResource.allowNetworkPolicySettingsForResource(kc, KafkaConnectResources.deploymentName(kc.getMetadata().getName()));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyOTgzOQ=="}, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIyMTcwMw==", "bodyText": "Yes, but I thought that you will add it to the KafkaConnectResource.kafkaConnectWithoutWait() method. I don't think that having it directly in a test is a good idea. But ... there comes another problem -> you have to create KafkaClients pod before creating the KafkaConnect, so you'll have to add it to all tests where the Connect is deployed via the withoutWait method.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527221703", "createdAt": "2020-11-19T21:43:34Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,151 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnectWrongDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .addToConfig(\"key.converter.schemas.enable\", false)\n+                .addToConfig(\"value.converter.schemas.enable\", false)\n+                .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        TestUtils.waitFor(\"Wait for KafkaConnect 'Unschedulable' condition due to wrong rackKey used.\",\n+                Constants.GLOBAL_POLL_INTERVAL, CO_OPERATION_TIMEOUT_SHORT * 2, () -> {\n+                List<Condition> conditions = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getStatus().getConditions();\n+                for (Condition condition : conditions) {\n+                    if (condition.getReason().matches(\"TimeoutException\") && condition.getType().matches(\"NotReady\")) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            });\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CLUSTER_NAME, kafkaConnect -> {\n+            kafkaConnect.getSpec().setRack(new Rack(rackKey));\n+        });\n+        KafkaConnectUtils.waitForConnectReady(CLUSTER_NAME);\n+        LOGGER.info(\"KafkaConnect is ready with changed rack key.\");\n+        LOGGER.info(\"Verify KafkaConnect rack key update\");\n+        kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        assertThat(kc.getSpec().getRack().getTopologyKey(), is(rackKey));\n+\n+        if (Environment.DEFAULT_TO_DENY_NETWORK_POLICIES.equals(Boolean.TRUE.toString())) {\n+            KubernetesResource.allowNetworkPolicySettingsForResource(kc, KafkaConnectResources.deploymentName(kc.getMetadata().getName()));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyOTgzOQ=="}, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIyMzU0NA==", "bodyText": "Ye, maybe we should think more about it and solve it a little bit differently to avoid the situation with clients", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527223544", "createdAt": "2020-11-19T21:47:00Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,151 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnectWrongDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .addToConfig(\"key.converter.schemas.enable\", false)\n+                .addToConfig(\"value.converter.schemas.enable\", false)\n+                .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        TestUtils.waitFor(\"Wait for KafkaConnect 'Unschedulable' condition due to wrong rackKey used.\",\n+                Constants.GLOBAL_POLL_INTERVAL, CO_OPERATION_TIMEOUT_SHORT * 2, () -> {\n+                List<Condition> conditions = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getStatus().getConditions();\n+                for (Condition condition : conditions) {\n+                    if (condition.getReason().matches(\"TimeoutException\") && condition.getType().matches(\"NotReady\")) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            });\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CLUSTER_NAME, kafkaConnect -> {\n+            kafkaConnect.getSpec().setRack(new Rack(rackKey));\n+        });\n+        KafkaConnectUtils.waitForConnectReady(CLUSTER_NAME);\n+        LOGGER.info(\"KafkaConnect is ready with changed rack key.\");\n+        LOGGER.info(\"Verify KafkaConnect rack key update\");\n+        kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        assertThat(kc.getSpec().getRack().getTopologyKey(), is(rackKey));\n+\n+        if (Environment.DEFAULT_TO_DENY_NETWORK_POLICIES.equals(Boolean.TRUE.toString())) {\n+            KubernetesResource.allowNetworkPolicySettingsForResource(kc, KafkaConnectResources.deploymentName(kc.getMetadata().getName()));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyOTgzOQ=="}, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIyNDQ4Mg==", "bodyText": "And you are using this if more than once ... so ... what about to create some different method, which will create the NP and then deploy the Connect without wait? To not add unnecessary Clients pods to other testcases?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527224482", "createdAt": "2020-11-19T21:48:39Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,151 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnectWrongDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .addToConfig(\"key.converter.schemas.enable\", false)\n+                .addToConfig(\"value.converter.schemas.enable\", false)\n+                .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        TestUtils.waitFor(\"Wait for KafkaConnect 'Unschedulable' condition due to wrong rackKey used.\",\n+                Constants.GLOBAL_POLL_INTERVAL, CO_OPERATION_TIMEOUT_SHORT * 2, () -> {\n+                List<Condition> conditions = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getStatus().getConditions();\n+                for (Condition condition : conditions) {\n+                    if (condition.getReason().matches(\"TimeoutException\") && condition.getType().matches(\"NotReady\")) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            });\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CLUSTER_NAME, kafkaConnect -> {\n+            kafkaConnect.getSpec().setRack(new Rack(rackKey));\n+        });\n+        KafkaConnectUtils.waitForConnectReady(CLUSTER_NAME);\n+        LOGGER.info(\"KafkaConnect is ready with changed rack key.\");\n+        LOGGER.info(\"Verify KafkaConnect rack key update\");\n+        kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        assertThat(kc.getSpec().getRack().getTopologyKey(), is(rackKey));\n+\n+        if (Environment.DEFAULT_TO_DENY_NETWORK_POLICIES.equals(Boolean.TRUE.toString())) {\n+            KubernetesResource.allowNetworkPolicySettingsForResource(kc, KafkaConnectResources.deploymentName(kc.getMetadata().getName()));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyOTgzOQ=="}, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDQ4NzEyOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozNzowOVrOH2nXRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozNzowOVrOH2nXRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAzMDA4NA==", "bodyText": "indent", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527030084", "createdAt": "2020-11-19T16:37:09Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,151 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnectWrongDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .addToConfig(\"key.converter.schemas.enable\", false)\n+                .addToConfig(\"value.converter.schemas.enable\", false)\n+                .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDQ5OTQxOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozOTo0NFrOH2ne8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozOTo0NFrOH2ne8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAzMjA1MQ==", "bodyText": "Same as I mentioned above", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527032051", "createdAt": "2020-11-19T16:39:44Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,151 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnectWrongDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .addToConfig(\"key.converter.schemas.enable\", false)\n+                .addToConfig(\"value.converter.schemas.enable\", false)\n+                .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        TestUtils.waitFor(\"Wait for KafkaConnect 'Unschedulable' condition due to wrong rackKey used.\",\n+                Constants.GLOBAL_POLL_INTERVAL, CO_OPERATION_TIMEOUT_SHORT * 2, () -> {\n+                List<Condition> conditions = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getStatus().getConditions();\n+                for (Condition condition : conditions) {\n+                    if (condition.getReason().matches(\"TimeoutException\") && condition.getType().matches(\"NotReady\")) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            });\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CLUSTER_NAME, kafkaConnect -> {\n+            kafkaConnect.getSpec().setRack(new Rack(rackKey));\n+        });\n+        KafkaConnectUtils.waitForConnectReady(CLUSTER_NAME);\n+        LOGGER.info(\"KafkaConnect is ready with changed rack key.\");\n+        LOGGER.info(\"Verify KafkaConnect rack key update\");\n+        kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        assertThat(kc.getSpec().getRack().getTopologyKey(), is(rackKey));\n+\n+        if (Environment.DEFAULT_TO_DENY_NETWORK_POLICIES.equals(Boolean.TRUE.toString())) {\n+            KubernetesResource.allowNetworkPolicySettingsForResource(kc, KafkaConnectResources.deploymentName(kc.getMetadata().getName()));\n+        }\n+        List<String> kcPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        KafkaConnectUtils.sendReceiveMessagesThroughConnect(kcPods.get(0), TOPIC_NAME, kafkaClientsPodName, NAMESPACE, CLUSTER_NAME);\n+    }\n+\n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    public void testRackAwareConnectCorrectDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String rackKey = \"rack-key\";\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with correct rack-aware topology key: {}\", rackKey);\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnect(CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(rackKey)\n+                    .endRack()\n+                    .addToConfig(\"key.converter.schemas.enable\", false)\n+                    .addToConfig(\"value.converter.schemas.enable\", false)\n+                    .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                    .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .endSpec().done();\n+        if (Environment.DEFAULT_TO_DENY_NETWORK_POLICIES.equals(Boolean.TRUE.toString())) {\n+            KubernetesResource.allowNetworkPolicySettingsForResource(kc, KafkaConnectResources.deploymentName(kc.getMetadata().getName()));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTcyNzYxOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMTo1MDoyNVrOH2zSog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMTo1NDoyOVrOH2zbGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIyNTUwNg==", "bodyText": "How about to add INTERNAL_CLIENTS_USED as well?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527225506", "createdAt": "2020-11-19T21:50:25Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -56,8 +75,7 @@\n     public static final String NAMESPACE = \"specific-cluster-test\";\n \n     @Test\n-    @Tag(LOADBALANCER_SUPPORTED)\n-    @Tag(EXTERNAL_CLIENTS_USED)\n+    @Tag(REGRESSION)\n     void testRackAware() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b9af81b61d1cf33d87366ab643d8b8c09e4fcd2"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIyNzY3NA==", "bodyText": "Same also for the second test", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527227674", "createdAt": "2020-11-19T21:54:29Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -56,8 +75,7 @@\n     public static final String NAMESPACE = \"specific-cluster-test\";\n \n     @Test\n-    @Tag(LOADBALANCER_SUPPORTED)\n-    @Tag(EXTERNAL_CLIENTS_USED)\n+    @Tag(REGRESSION)\n     void testRackAware() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIyNTUwNg=="}, "originalCommit": {"oid": "9b9af81b61d1cf33d87366ab643d8b8c09e4fcd2"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTczMTY1OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMTo1MTozMVrOH2zVCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMTo1MTozMVrOH2zVCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIyNjEyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n          \n          \n            \n                    KafkaClientsResource.deployKafkaClients(true, KAFKA_CLIENTS_NAME).done();\n          \n          \n            \n            ``` ?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527226120", "createdAt": "2020-11-19T21:51:31Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,147 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b9af81b61d1cf33d87366ab643d8b8c09e4fcd2"}, "originalPosition": 87}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 987, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}