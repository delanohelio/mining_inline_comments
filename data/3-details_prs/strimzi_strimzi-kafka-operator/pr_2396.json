{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyNTkxMzAw", "number": 2396, "title": "[DOC] New assembly to describe recovery of cluster from PVs", "bodyText": "Signed-off-by: prmellor pmellor@redhat.com\nDocumentation\nNew doc assembly to describe how to recover a cluster using PVs.\nassembly-cluster-recovery-volume.adoc\nI've placed this assembly into a new managing assembly, and included other post-install maintenance-type procedures. This can form the basis of a new Managing Strimzi guide eventually.\nNo changes were made to:\n\nproc-uninstalling.adoc\nproc-accessing-resource-status.adoc\n\nCaptured a couple of typos in other files.\nChecklist\nPlease go through this checklist and make sure all applicable tasks have been done\n\n Update/write design documentation in ./design\n Write tests\n Make sure all tests pass\n Update documentation\n Check RBAC rights for Kubernetes / OpenShift roles\n Try your changes from Pod inside your Kubernetes and OpenShift cluster, not just locally\n Reference relevant issue(s) and close them after merging\n Update CHANGELOG.md", "createdAt": "2020-01-14T11:44:11Z", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396", "merged": true, "mergeCommit": {"oid": "12fa8710fc470023daf53137924d42e07ab8cdce"}, "closed": true, "closedAt": "2020-01-26T11:54:22Z", "author": {"login": "PaulRMellor"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb6PWa0AH2gAyMzYyNTkxMzAwOmZlMzU2NmYzMWY5Zjg4NGQ5NzEzYzFmNWIwYzQ5MjkzNGYzOGRhOGM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb9b0P-gFqTM0Nzg0MjgxOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "fe3566f31f9f884d9713c1f5b0c492934f38da8c", "author": {"user": {"login": "PaulRMellor", "name": null}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/fe3566f31f9f884d9713c1f5b0c492934f38da8c", "committedDate": "2020-01-14T11:35:36Z", "message": "new assembly to describe recovery of cluster from PVs\n\nSigned-off-by: prmellor <pmellor@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0", "author": {"user": {"login": "PaulRMellor", "name": null}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/21a4caa8f132343629cd042f47c1b2e6a93be6e0", "committedDate": "2020-01-14T11:40:19Z", "message": "new assembly to describe recovery of cluster from PVs\n\nSigned-off-by: prmellor <pmellor@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNDgwMjk1", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#pullrequestreview-342480295", "createdAt": "2020-01-14T11:58:52Z", "commit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxMTo1ODo1MlrOFdVHNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxMTo1ODo1MlrOFdVHNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI5ODkzNA==", "bodyText": "@scholzj - do we want to show the whole example?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r366298934", "createdAt": "2020-01-14T11:58:52Z", "author": {"login": "PaulRMellor"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes.\n+\n+The procedure assumes that the Topic Operator is deployed.\n+In situations such as these, the Topic Operator identifies that topics exist in Kafka, but the `KafkaTopic` resources do not exist.\n+The `KafkaTopic` resources must be recovered before a cluster is started so that the topics are not deleted by the Topic Operator.\n+\n+If you do not use the the Topic Operator, you just need to recover the `PersistentVolumeClaim` (PVC) resources.\n+\n+.Before you begin\n+\n+In this procedure, it is essential that PVs are mounted into the correct PVC to avoid data corruption.\n+A `volumeName` is specified for the PVC and this must match the name of the PV.\n+\n+For more information, see:\n+\n+* xref:ref-persistent-storage-{context}#pvc-naming[Persistent Volume Claim naming]\n+* xref:ref-jbod-storage-{context}#jbod-pvc[JBOD and Persistent Volume Claims]\n+\n+NOTE: The procedure does not include recovery of `KafkaUser` resources, which must be recreated manually.\n+\n+.Procedure\n+\n+. Check information on the PVs in the cluster:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl get pv\n+----\n++\n+Information is presented for PVs with data.\n++\n+Example output showing columns important to this procedure:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+NAME                                         RECLAIM POLICY\n+pvc-5e9c5c7f-3317-11ea-a650-06e1eadd9a4c ... Retain\n+pvc-5e9cc72d-3317-11ea-97b0-0aef8816c7ea ... Retain\n+pvc-5ead43d1-3317-11ea-97b0-0aef8816c7ea ... Retain\n+pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c ... Retain\n+pvc-7e21042e-3317-11ea-9786-02deaf9aa87e ... Retain\n+pvc-7e226978-3317-11ea-97b0-0aef8816c7ea ... Retain\n+\n+CLAIM                                     STORAGECLASS\n+myproject/data-my-cluster-zookeeper-1 ... gp2-retain\n+myproject/data-my-cluster-zookeeper-0 ... gp2-retain\n+myproject/data-my-cluster-zookeeper-2 ... gp2-retain\n+myproject/data-0-my-cluster-kafka-0   ... gp2-retain\n+myproject/data-0-my-cluster-kafka-1   ... gp2-retain\n+myproject/data-0-my-cluster-kafka-2   ... gp2-retain\n+----\n++\n+* _NAME_ shows the name of each PV.\n+* _RECLAIM POLICY_ shows that PVs are _retained_.\n+* _CLAIM_ shows the link to the original PVCs.\n+* _STORAGECLASS_ shows the name of the storage class used for dynamic volume allocation.\n+\n+. Recreate the original namespace:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl create namespace _myproject_\n+----\n+\n+. Recreate the original PVC resource specifications, linking the PVCs to the appropriate PV:\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: v1\n+kind: PersistentVolumeClaim\n+metadata:\n+  name: data-0-my-cluster-kafka-0\n+spec:\n+  accessModes:\n+  - ReadWriteOnce\n+  resources:\n+    requests:\n+      storage: 100Gi\n+  storageClassName: gp2-retain\n+  volumeMode: Filesystem\n+  volumeName: *pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c*\n+----\n+\n+. Edit the PV specifications to delete the `claimRef` properties that bound the original PVC.\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNDgwODg5", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#pullrequestreview-342480889", "createdAt": "2020-01-14T11:59:59Z", "commit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxMTo1OTo1OVrOFdVI-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxMTo1OTo1OVrOFdVI-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI5OTM4Ng==", "bodyText": "@scholzj - wasn't sure if this instruction needed more or should be deleteall as written in draft.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r366299386", "createdAt": "2020-01-14T11:59:59Z", "author": {"login": "PaulRMellor"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes.\n+\n+The procedure assumes that the Topic Operator is deployed.\n+In situations such as these, the Topic Operator identifies that topics exist in Kafka, but the `KafkaTopic` resources do not exist.\n+The `KafkaTopic` resources must be recovered before a cluster is started so that the topics are not deleted by the Topic Operator.\n+\n+If you do not use the the Topic Operator, you just need to recover the `PersistentVolumeClaim` (PVC) resources.\n+\n+.Before you begin\n+\n+In this procedure, it is essential that PVs are mounted into the correct PVC to avoid data corruption.\n+A `volumeName` is specified for the PVC and this must match the name of the PV.\n+\n+For more information, see:\n+\n+* xref:ref-persistent-storage-{context}#pvc-naming[Persistent Volume Claim naming]\n+* xref:ref-jbod-storage-{context}#jbod-pvc[JBOD and Persistent Volume Claims]\n+\n+NOTE: The procedure does not include recovery of `KafkaUser` resources, which must be recreated manually.\n+\n+.Procedure\n+\n+. Check information on the PVs in the cluster:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl get pv\n+----\n++\n+Information is presented for PVs with data.\n++\n+Example output showing columns important to this procedure:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+NAME                                         RECLAIM POLICY\n+pvc-5e9c5c7f-3317-11ea-a650-06e1eadd9a4c ... Retain\n+pvc-5e9cc72d-3317-11ea-97b0-0aef8816c7ea ... Retain\n+pvc-5ead43d1-3317-11ea-97b0-0aef8816c7ea ... Retain\n+pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c ... Retain\n+pvc-7e21042e-3317-11ea-9786-02deaf9aa87e ... Retain\n+pvc-7e226978-3317-11ea-97b0-0aef8816c7ea ... Retain\n+\n+CLAIM                                     STORAGECLASS\n+myproject/data-my-cluster-zookeeper-1 ... gp2-retain\n+myproject/data-my-cluster-zookeeper-0 ... gp2-retain\n+myproject/data-my-cluster-zookeeper-2 ... gp2-retain\n+myproject/data-0-my-cluster-kafka-0   ... gp2-retain\n+myproject/data-0-my-cluster-kafka-1   ... gp2-retain\n+myproject/data-0-my-cluster-kafka-2   ... gp2-retain\n+----\n++\n+* _NAME_ shows the name of each PV.\n+* _RECLAIM POLICY_ shows that PVs are _retained_.\n+* _CLAIM_ shows the link to the original PVCs.\n+* _STORAGECLASS_ shows the name of the storage class used for dynamic volume allocation.\n+\n+. Recreate the original namespace:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl create namespace _myproject_\n+----\n+\n+. Recreate the original PVC resource specifications, linking the PVCs to the appropriate PV:\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: v1\n+kind: PersistentVolumeClaim\n+metadata:\n+  name: data-0-my-cluster-kafka-0\n+spec:\n+  accessModes:\n+  - ReadWriteOnce\n+  resources:\n+    requests:\n+      storage: 100Gi\n+  storageClassName: gp2-retain\n+  volumeMode: Filesystem\n+  volumeName: *pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c*\n+----\n+\n+. Edit the PV specifications to delete the `claimRef` properties that bound the original PVC.\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: v1\n+kind: PersistentVolume\n+metadata:\n+  annotations:\n+    kubernetes.io/createdby: aws-ebs-dynamic-provisioner\n+    pv.kubernetes.io/bound-by-controller: \"yes\"\n+    pv.kubernetes.io/provisioned-by: kubernetes.io/aws-ebs\n+  creationTimestamp: \"<date>\"\n+  finalizers:\n+  - kubernetes.io/pv-protection\n+  labels:\n+    failure-domain.beta.kubernetes.io/region: eu-west-1\n+    failure-domain.beta.kubernetes.io/zone: eu-west-1c\n+  name: pvc-7e226978-3317-11ea-97b0-0aef8816c7ea\n+  resourceVersion: \"39431\"\n+  selfLink: /api/v1/persistentvolumes/pvc-7e226978-3317-11ea-97b0-0aef8816c7ea\n+  uid: 7efe6b0d-3317-11ea-a650-06e1eadd9a4c\n+spec:\n+  accessModes:\n+  - ReadWriteOnce\n+  awsElasticBlockStore:\n+    fsType: xfs\n+    volumeID: aws://eu-west-1c/vol-09db3141656d1c258\n+  capacity:\n+    storage: 100Gi\n+  *claimRef:*\n+    *apiVersion: v1*\n+    *kind: PersistentVolumeClaim*\n+    *name: data-0-my-cluster-kafka-2*\n+    *namespace: myproject*\n+    *resourceVersion: \"39113\"*\n+    *uid: 54be1c60-3319-11ea-97b0-0aef8816c7ea*\n+  nodeAffinity:\n+    required:\n+      nodeSelectorTerms:\n+      - matchExpressions:\n+        - key: failure-domain.beta.kubernetes.io/zone\n+          operator: In\n+          values:\n+          - eu-west-1c\n+        - key: failure-domain.beta.kubernetes.io/region\n+          operator: In\n+          values:\n+          - eu-west-1\n+  persistentVolumeReclaimPolicy: Retain\n+  storageClassName: gp2-retain\n+  volumeMode: Filesystem\n+----\n++\n+In the example, the following properties are deleted:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+claimRef:\n+  apiVersion: v1\n+  kind: PersistentVolumeClaim\n+  name: data-0-my-cluster-kafka-2\n+  namespace: myproject\n+  resourceVersion: \"39113\"\n+  uid: 54be1c60-3319-11ea-97b0-0aef8816c7ea\n+----\n+\n+. Deploy the Cluster Operator.\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl apply -f install/cluster-operator -n _my-project_\n+----\n+\n+. Recreate your cluster.\n++\n+Follow the steps depending on whether or not you have all the `KafkaTopic` resources needed to recreate your cluster.\n++\n+--\n+*_Option 1_*: If you have *all* the `KafkaTopic` resources that existed before you lost your cluster, including internal topics such as committed offsets from `__consumer_offsets`:\n+\n+. Recreate all `KafkaTopic` resources.\n++\n+You must recreate the resources before deploying the clusters or the Topic Operator will delete the topics.\n+\n+. Deploy the Kafka cluster.\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl apply -f _kafka.yaml_\n+----\n+--\n++\n+--\n+*_Option 2_*: If you do not have all the `KafkaTopic` resources that existed before you lost your cluster:\n+\n+. Deploy the Kafka cluster, as with the first option, but without the Topic Operator by removing `topicOperator: {}` from the Kafka resource before deploying.\n++\n+If you include the Topic Operator in the deployment, the Topic Operator will delete all the topics.\n+\n+. Run an `exec` command to one of the Kafka broker pods to open the ZooKeeper shell script.\n++\n+For example, where _my-cluster-kafka-0_ is the name of the broker pod:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl exec _my-cluster-kafka-0_ bin/zookeeper-shell.sh localhost:2181\n+----\n+. Delete the whole `/strimzi` path to remove the Topic Operator storage.\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+delete /strimzi", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "originalPosition": 208}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNDgxMjgz", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#pullrequestreview-342481283", "createdAt": "2020-01-14T12:00:44Z", "commit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxMjowMDo0NFrOFdVKKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxMjowMDo0NFrOFdVKKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI5OTY4OQ==", "bodyText": "prereq?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r366299689", "createdAt": "2020-01-14T12:00:44Z", "author": {"login": "PaulRMellor"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes.\n+\n+The procedure assumes that the Topic Operator is deployed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNTIzMDI2", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#pullrequestreview-342523026", "createdAt": "2020-01-14T13:18:03Z", "commit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxMzoxODowM1rOFdXHCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxMzoxODowM1rOFdXHCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzMTY1Ng==", "bodyText": "@scholzj - do we want to say more about this?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r366331656", "createdAt": "2020-01-14T13:18:03Z", "author": {"login": "PaulRMellor"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes.\n+\n+The procedure assumes that the Topic Operator is deployed.\n+In situations such as these, the Topic Operator identifies that topics exist in Kafka, but the `KafkaTopic` resources do not exist.\n+The `KafkaTopic` resources must be recovered before a cluster is started so that the topics are not deleted by the Topic Operator.\n+\n+If you do not use the the Topic Operator, you just need to recover the `PersistentVolumeClaim` (PVC) resources.\n+\n+.Before you begin\n+\n+In this procedure, it is essential that PVs are mounted into the correct PVC to avoid data corruption.\n+A `volumeName` is specified for the PVC and this must match the name of the PV.\n+\n+For more information, see:\n+\n+* xref:ref-persistent-storage-{context}#pvc-naming[Persistent Volume Claim naming]\n+* xref:ref-jbod-storage-{context}#jbod-pvc[JBOD and Persistent Volume Claims]\n+\n+NOTE: The procedure does not include recovery of `KafkaUser` resources, which must be recreated manually.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NTMwNjgz", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#pullrequestreview-344530683", "createdAt": "2020-01-17T11:53:07Z", "commit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMTo1MzowN1rOFe21mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMjoyNDowMVrOFe3e1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkwMDA1OA==", "bodyText": "Should we define which type of cluster? Either a Kafka cluster or a Strimzi cluster.\nPersistent volumes (PVs).", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367900058", "createdAt": "2020-01-17T11:53:07Z", "author": {"login": "laidan6000"}, "path": "documentation/assemblies/managing/assembly-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,22 @@\n+// This assembly is included in:\n+//\n+// assembly-management-tasks.adoc\n+\n+[id=\"cluster-recovery_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+You can recover a cluster from persistent volumes if they are still present.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkwMDE2OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You may want to do this, for example, after:\n          \n          \n            \n            You might want to do this, for example, after:", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367900169", "createdAt": "2020-01-17T11:53:26Z", "author": {"login": "laidan6000"}, "path": "documentation/assemblies/managing/assembly-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,22 @@\n+// This assembly is included in:\n+//\n+// assembly-management-tasks.adoc\n+\n+[id=\"cluster-recovery_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+You can recover a cluster from persistent volumes if they are still present.\n+\n+You may want to do this, for example, after:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkwMDY0Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * A whole cluster is lost, but the volumes remain in the infrastructure\n          \n          \n            \n            * A whole cluster is lost, but the PVs remain in the infrastructure", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367900643", "createdAt": "2020-01-17T11:54:49Z", "author": {"login": "laidan6000"}, "path": "documentation/assemblies/managing/assembly-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,22 @@\n+// This assembly is included in:\n+//\n+// assembly-management-tasks.adoc\n+\n+[id=\"cluster-recovery_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+You can recover a cluster from persistent volumes if they are still present.\n+\n+You may want to do this, for example, after:\n+\n+* A namespace was deleted unintentionally\n+* A whole cluster is lost, but the volumes remain in the infrastructure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkwMDg4NA==", "bodyText": "Consider a more descriptive title.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367900884", "createdAt": "2020-01-17T11:55:34Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/managing/con-namespace-deletion-recovery.adoc", "diffHunk": "@@ -0,0 +1,21 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"namespace-deletion_{context}\"]\n+= Namespace deletion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkwMzIxOQ==", "bodyText": "Expenditure of memory, resources, or something else?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367903219", "createdAt": "2020-01-17T12:01:54Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/managing/con-namespace-deletion-recovery.adoc", "diffHunk": "@@ -0,0 +1,21 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"namespace-deletion_{context}\"]\n+= Namespace deletion\n+\n+Recovery from namespace deletion is possible because of the relationship between persistent volumes and namespaces.\n+A `PersistentVolume` (PV) is a storage resource that lives outside of a namespace.\n+A PV is mounted into a Kafka pod using a `PersistentVolumeClaim` (PVC), which lives inside a namespace.\n+\n+If a namespace is deleted unintentionally, you can recover it from a PV as long as it is still present.\n+\n+A reclaim policy for a PV tells a cluster how to act when a namespace is deleted.\n+If the reclaim policy is set as _Delete_, PVs are deleted when PVCs are deleted with a namespace.\n+\n+To ensure that PVs are not deleted when a namespace is deleted, the policy must be reset from _Delete_ to _Retain_.\n+You can also configure the `StorageClass` property used for dynamic volume allocation so that it creates the volumes with the appropriate reclaim policy.\n+\n+NOTE: If you are using _Retain_ as the reclaim policy, but you want to delete an entire cluster, you need to delete the PVs manually.\n+Otherwise they will not be deleted, and may cause unnecessary expenditure.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkwMzM0NA==", "bodyText": "Does this mean that the default reclaim policy is Delete?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367903344", "createdAt": "2020-01-17T12:02:19Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/managing/con-namespace-deletion-recovery.adoc", "diffHunk": "@@ -0,0 +1,21 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"namespace-deletion_{context}\"]\n+= Namespace deletion\n+\n+Recovery from namespace deletion is possible because of the relationship between persistent volumes and namespaces.\n+A `PersistentVolume` (PV) is a storage resource that lives outside of a namespace.\n+A PV is mounted into a Kafka pod using a `PersistentVolumeClaim` (PVC), which lives inside a namespace.\n+\n+If a namespace is deleted unintentionally, you can recover it from a PV as long as it is still present.\n+\n+A reclaim policy for a PV tells a cluster how to act when a namespace is deleted.\n+If the reclaim policy is set as _Delete_, PVs are deleted when PVCs are deleted with a namespace.\n+\n+To ensure that PVs are not deleted when a namespace is deleted, the policy must be reset from _Delete_ to _Retain_.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkwMzY4Nw==", "bodyText": "Again, I'm not sure this title is descriptive enough.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367903687", "createdAt": "2020-01-17T12:03:15Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/managing/con-cluster-loss-recovery.adoc", "diffHunk": "@@ -0,0 +1,10 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-loss_{context}\"]\n+= Cluster loss", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkwODMxMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This procedure describes how to recover a deleted cluster from persistent volumes.\n          \n          \n            \n            This procedure describes how to recover a deleted cluster from persistent volumes (PVs).", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367908311", "createdAt": "2020-01-17T12:17:26Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkwOTM1NQ==", "bodyText": "Suggested change:\nIf the Topic Operator is not deployed, you need to recover the PersistentVolumeClaim (PVC) resources.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367909355", "createdAt": "2020-01-17T12:20:29Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes.\n+\n+The procedure assumes that the Topic Operator is deployed.\n+In situations such as these, the Topic Operator identifies that topics exist in Kafka, but the `KafkaTopic` resources do not exist.\n+The `KafkaTopic` resources must be recovered before a cluster is started so that the topics are not deleted by the Topic Operator.\n+\n+If you do not use the the Topic Operator, you just need to recover the `PersistentVolumeClaim` (PVC) resources.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxMDIwOQ==", "bodyText": "Perhaps this line should be formatted as a warning?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367910209", "createdAt": "2020-01-17T12:22:54Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes.\n+\n+The procedure assumes that the Topic Operator is deployed.\n+In situations such as these, the Topic Operator identifies that topics exist in Kafka, but the `KafkaTopic` resources do not exist.\n+The `KafkaTopic` resources must be recovered before a cluster is started so that the topics are not deleted by the Topic Operator.\n+\n+If you do not use the the Topic Operator, you just need to recover the `PersistentVolumeClaim` (PVC) resources.\n+\n+.Before you begin\n+\n+In this procedure, it is essential that PVs are mounted into the correct PVC to avoid data corruption.\n+A `volumeName` is specified for the PVC and this must match the name of the PV.\n+\n+For more information, see:\n+\n+* xref:ref-persistent-storage-{context}#pvc-naming[Persistent Volume Claim naming]\n+* xref:ref-jbod-storage-{context}#jbod-pvc[JBOD and Persistent Volume Claims]\n+\n+NOTE: The procedure does not include recovery of `KafkaUser` resources, which must be recreated manually.\n+\n+.Procedure\n+\n+. Check information on the PVs in the cluster:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl get pv\n+----\n++\n+Information is presented for PVs with data.\n++\n+Example output showing columns important to this procedure:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+NAME                                         RECLAIM POLICY\n+pvc-5e9c5c7f-3317-11ea-a650-06e1eadd9a4c ... Retain\n+pvc-5e9cc72d-3317-11ea-97b0-0aef8816c7ea ... Retain\n+pvc-5ead43d1-3317-11ea-97b0-0aef8816c7ea ... Retain\n+pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c ... Retain\n+pvc-7e21042e-3317-11ea-9786-02deaf9aa87e ... Retain\n+pvc-7e226978-3317-11ea-97b0-0aef8816c7ea ... Retain\n+\n+CLAIM                                     STORAGECLASS\n+myproject/data-my-cluster-zookeeper-1 ... gp2-retain\n+myproject/data-my-cluster-zookeeper-0 ... gp2-retain\n+myproject/data-my-cluster-zookeeper-2 ... gp2-retain\n+myproject/data-0-my-cluster-kafka-0   ... gp2-retain\n+myproject/data-0-my-cluster-kafka-1   ... gp2-retain\n+myproject/data-0-my-cluster-kafka-2   ... gp2-retain\n+----\n++\n+* _NAME_ shows the name of each PV.\n+* _RECLAIM POLICY_ shows that PVs are _retained_.\n+* _CLAIM_ shows the link to the original PVCs.\n+* _STORAGECLASS_ shows the name of the storage class used for dynamic volume allocation.\n+\n+. Recreate the original namespace:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl create namespace _myproject_\n+----\n+\n+. Recreate the original PVC resource specifications, linking the PVCs to the appropriate PV:\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: v1\n+kind: PersistentVolumeClaim\n+metadata:\n+  name: data-0-my-cluster-kafka-0\n+spec:\n+  accessModes:\n+  - ReadWriteOnce\n+  resources:\n+    requests:\n+      storage: 100Gi\n+  storageClassName: gp2-retain\n+  volumeMode: Filesystem\n+  volumeName: *pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c*\n+----\n+\n+. Edit the PV specifications to delete the `claimRef` properties that bound the original PVC.\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: v1\n+kind: PersistentVolume\n+metadata:\n+  annotations:\n+    kubernetes.io/createdby: aws-ebs-dynamic-provisioner\n+    pv.kubernetes.io/bound-by-controller: \"yes\"\n+    pv.kubernetes.io/provisioned-by: kubernetes.io/aws-ebs\n+  creationTimestamp: \"<date>\"\n+  finalizers:\n+  - kubernetes.io/pv-protection\n+  labels:\n+    failure-domain.beta.kubernetes.io/region: eu-west-1\n+    failure-domain.beta.kubernetes.io/zone: eu-west-1c\n+  name: pvc-7e226978-3317-11ea-97b0-0aef8816c7ea\n+  resourceVersion: \"39431\"\n+  selfLink: /api/v1/persistentvolumes/pvc-7e226978-3317-11ea-97b0-0aef8816c7ea\n+  uid: 7efe6b0d-3317-11ea-a650-06e1eadd9a4c\n+spec:\n+  accessModes:\n+  - ReadWriteOnce\n+  awsElasticBlockStore:\n+    fsType: xfs\n+    volumeID: aws://eu-west-1c/vol-09db3141656d1c258\n+  capacity:\n+    storage: 100Gi\n+  *claimRef:*\n+    *apiVersion: v1*\n+    *kind: PersistentVolumeClaim*\n+    *name: data-0-my-cluster-kafka-2*\n+    *namespace: myproject*\n+    *resourceVersion: \"39113\"*\n+    *uid: 54be1c60-3319-11ea-97b0-0aef8816c7ea*\n+  nodeAffinity:\n+    required:\n+      nodeSelectorTerms:\n+      - matchExpressions:\n+        - key: failure-domain.beta.kubernetes.io/zone\n+          operator: In\n+          values:\n+          - eu-west-1c\n+        - key: failure-domain.beta.kubernetes.io/region\n+          operator: In\n+          values:\n+          - eu-west-1\n+  persistentVolumeReclaimPolicy: Retain\n+  storageClassName: gp2-retain\n+  volumeMode: Filesystem\n+----\n++\n+In the example, the following properties are deleted:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+claimRef:\n+  apiVersion: v1\n+  kind: PersistentVolumeClaim\n+  name: data-0-my-cluster-kafka-2\n+  namespace: myproject\n+  resourceVersion: \"39113\"\n+  uid: 54be1c60-3319-11ea-97b0-0aef8816c7ea\n+----\n+\n+. Deploy the Cluster Operator.\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl apply -f install/cluster-operator -n _my-project_\n+----\n+\n+. Recreate your cluster.\n++\n+Follow the steps depending on whether or not you have all the `KafkaTopic` resources needed to recreate your cluster.\n++\n+--\n+*_Option 1_*: If you have *all* the `KafkaTopic` resources that existed before you lost your cluster, including internal topics such as committed offsets from `__consumer_offsets`:\n+\n+. Recreate all `KafkaTopic` resources.\n++\n+You must recreate the resources before deploying the clusters or the Topic Operator will delete the topics.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxMDUxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            . Delete the whole `/strimzi` path to remove the Topic Operator storage.\n          \n          \n            \n            . Delete the whole `/strimzi` path to remove the Topic Operator storage:", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367910516", "createdAt": "2020-01-17T12:23:43Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes.\n+\n+The procedure assumes that the Topic Operator is deployed.\n+In situations such as these, the Topic Operator identifies that topics exist in Kafka, but the `KafkaTopic` resources do not exist.\n+The `KafkaTopic` resources must be recovered before a cluster is started so that the topics are not deleted by the Topic Operator.\n+\n+If you do not use the the Topic Operator, you just need to recover the `PersistentVolumeClaim` (PVC) resources.\n+\n+.Before you begin\n+\n+In this procedure, it is essential that PVs are mounted into the correct PVC to avoid data corruption.\n+A `volumeName` is specified for the PVC and this must match the name of the PV.\n+\n+For more information, see:\n+\n+* xref:ref-persistent-storage-{context}#pvc-naming[Persistent Volume Claim naming]\n+* xref:ref-jbod-storage-{context}#jbod-pvc[JBOD and Persistent Volume Claims]\n+\n+NOTE: The procedure does not include recovery of `KafkaUser` resources, which must be recreated manually.\n+\n+.Procedure\n+\n+. Check information on the PVs in the cluster:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl get pv\n+----\n++\n+Information is presented for PVs with data.\n++\n+Example output showing columns important to this procedure:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+NAME                                         RECLAIM POLICY\n+pvc-5e9c5c7f-3317-11ea-a650-06e1eadd9a4c ... Retain\n+pvc-5e9cc72d-3317-11ea-97b0-0aef8816c7ea ... Retain\n+pvc-5ead43d1-3317-11ea-97b0-0aef8816c7ea ... Retain\n+pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c ... Retain\n+pvc-7e21042e-3317-11ea-9786-02deaf9aa87e ... Retain\n+pvc-7e226978-3317-11ea-97b0-0aef8816c7ea ... Retain\n+\n+CLAIM                                     STORAGECLASS\n+myproject/data-my-cluster-zookeeper-1 ... gp2-retain\n+myproject/data-my-cluster-zookeeper-0 ... gp2-retain\n+myproject/data-my-cluster-zookeeper-2 ... gp2-retain\n+myproject/data-0-my-cluster-kafka-0   ... gp2-retain\n+myproject/data-0-my-cluster-kafka-1   ... gp2-retain\n+myproject/data-0-my-cluster-kafka-2   ... gp2-retain\n+----\n++\n+* _NAME_ shows the name of each PV.\n+* _RECLAIM POLICY_ shows that PVs are _retained_.\n+* _CLAIM_ shows the link to the original PVCs.\n+* _STORAGECLASS_ shows the name of the storage class used for dynamic volume allocation.\n+\n+. Recreate the original namespace:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl create namespace _myproject_\n+----\n+\n+. Recreate the original PVC resource specifications, linking the PVCs to the appropriate PV:\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: v1\n+kind: PersistentVolumeClaim\n+metadata:\n+  name: data-0-my-cluster-kafka-0\n+spec:\n+  accessModes:\n+  - ReadWriteOnce\n+  resources:\n+    requests:\n+      storage: 100Gi\n+  storageClassName: gp2-retain\n+  volumeMode: Filesystem\n+  volumeName: *pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c*\n+----\n+\n+. Edit the PV specifications to delete the `claimRef` properties that bound the original PVC.\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: v1\n+kind: PersistentVolume\n+metadata:\n+  annotations:\n+    kubernetes.io/createdby: aws-ebs-dynamic-provisioner\n+    pv.kubernetes.io/bound-by-controller: \"yes\"\n+    pv.kubernetes.io/provisioned-by: kubernetes.io/aws-ebs\n+  creationTimestamp: \"<date>\"\n+  finalizers:\n+  - kubernetes.io/pv-protection\n+  labels:\n+    failure-domain.beta.kubernetes.io/region: eu-west-1\n+    failure-domain.beta.kubernetes.io/zone: eu-west-1c\n+  name: pvc-7e226978-3317-11ea-97b0-0aef8816c7ea\n+  resourceVersion: \"39431\"\n+  selfLink: /api/v1/persistentvolumes/pvc-7e226978-3317-11ea-97b0-0aef8816c7ea\n+  uid: 7efe6b0d-3317-11ea-a650-06e1eadd9a4c\n+spec:\n+  accessModes:\n+  - ReadWriteOnce\n+  awsElasticBlockStore:\n+    fsType: xfs\n+    volumeID: aws://eu-west-1c/vol-09db3141656d1c258\n+  capacity:\n+    storage: 100Gi\n+  *claimRef:*\n+    *apiVersion: v1*\n+    *kind: PersistentVolumeClaim*\n+    *name: data-0-my-cluster-kafka-2*\n+    *namespace: myproject*\n+    *resourceVersion: \"39113\"*\n+    *uid: 54be1c60-3319-11ea-97b0-0aef8816c7ea*\n+  nodeAffinity:\n+    required:\n+      nodeSelectorTerms:\n+      - matchExpressions:\n+        - key: failure-domain.beta.kubernetes.io/zone\n+          operator: In\n+          values:\n+          - eu-west-1c\n+        - key: failure-domain.beta.kubernetes.io/region\n+          operator: In\n+          values:\n+          - eu-west-1\n+  persistentVolumeReclaimPolicy: Retain\n+  storageClassName: gp2-retain\n+  volumeMode: Filesystem\n+----\n++\n+In the example, the following properties are deleted:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+claimRef:\n+  apiVersion: v1\n+  kind: PersistentVolumeClaim\n+  name: data-0-my-cluster-kafka-2\n+  namespace: myproject\n+  resourceVersion: \"39113\"\n+  uid: 54be1c60-3319-11ea-97b0-0aef8816c7ea\n+----\n+\n+. Deploy the Cluster Operator.\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl apply -f install/cluster-operator -n _my-project_\n+----\n+\n+. Recreate your cluster.\n++\n+Follow the steps depending on whether or not you have all the `KafkaTopic` resources needed to recreate your cluster.\n++\n+--\n+*_Option 1_*: If you have *all* the `KafkaTopic` resources that existed before you lost your cluster, including internal topics such as committed offsets from `__consumer_offsets`:\n+\n+. Recreate all `KafkaTopic` resources.\n++\n+You must recreate the resources before deploying the clusters or the Topic Operator will delete the topics.\n+\n+. Deploy the Kafka cluster.\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl apply -f _kafka.yaml_\n+----\n+--\n++\n+--\n+*_Option 2_*: If you do not have all the `KafkaTopic` resources that existed before you lost your cluster:\n+\n+. Deploy the Kafka cluster, as with the first option, but without the Topic Operator by removing `topicOperator: {}` from the Kafka resource before deploying.\n++\n+If you include the Topic Operator in the deployment, the Topic Operator will delete all the topics.\n+\n+. Run an `exec` command to one of the Kafka broker pods to open the ZooKeeper shell script.\n++\n+For example, where _my-cluster-kafka-0_ is the name of the broker pod:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl exec _my-cluster-kafka-0_ bin/zookeeper-shell.sh localhost:2181\n+----\n+. Delete the whole `/strimzi` path to remove the Topic Operator storage.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxMDYxMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            . Verify the recovery by listing the `KafkaTopic` resources.\n          \n          \n            \n            . Verify the recovery by listing the `KafkaTopic` resources:", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367910612", "createdAt": "2020-01-17T12:24:01Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes.\n+\n+The procedure assumes that the Topic Operator is deployed.\n+In situations such as these, the Topic Operator identifies that topics exist in Kafka, but the `KafkaTopic` resources do not exist.\n+The `KafkaTopic` resources must be recovered before a cluster is started so that the topics are not deleted by the Topic Operator.\n+\n+If you do not use the the Topic Operator, you just need to recover the `PersistentVolumeClaim` (PVC) resources.\n+\n+.Before you begin\n+\n+In this procedure, it is essential that PVs are mounted into the correct PVC to avoid data corruption.\n+A `volumeName` is specified for the PVC and this must match the name of the PV.\n+\n+For more information, see:\n+\n+* xref:ref-persistent-storage-{context}#pvc-naming[Persistent Volume Claim naming]\n+* xref:ref-jbod-storage-{context}#jbod-pvc[JBOD and Persistent Volume Claims]\n+\n+NOTE: The procedure does not include recovery of `KafkaUser` resources, which must be recreated manually.\n+\n+.Procedure\n+\n+. Check information on the PVs in the cluster:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl get pv\n+----\n++\n+Information is presented for PVs with data.\n++\n+Example output showing columns important to this procedure:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+NAME                                         RECLAIM POLICY\n+pvc-5e9c5c7f-3317-11ea-a650-06e1eadd9a4c ... Retain\n+pvc-5e9cc72d-3317-11ea-97b0-0aef8816c7ea ... Retain\n+pvc-5ead43d1-3317-11ea-97b0-0aef8816c7ea ... Retain\n+pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c ... Retain\n+pvc-7e21042e-3317-11ea-9786-02deaf9aa87e ... Retain\n+pvc-7e226978-3317-11ea-97b0-0aef8816c7ea ... Retain\n+\n+CLAIM                                     STORAGECLASS\n+myproject/data-my-cluster-zookeeper-1 ... gp2-retain\n+myproject/data-my-cluster-zookeeper-0 ... gp2-retain\n+myproject/data-my-cluster-zookeeper-2 ... gp2-retain\n+myproject/data-0-my-cluster-kafka-0   ... gp2-retain\n+myproject/data-0-my-cluster-kafka-1   ... gp2-retain\n+myproject/data-0-my-cluster-kafka-2   ... gp2-retain\n+----\n++\n+* _NAME_ shows the name of each PV.\n+* _RECLAIM POLICY_ shows that PVs are _retained_.\n+* _CLAIM_ shows the link to the original PVCs.\n+* _STORAGECLASS_ shows the name of the storage class used for dynamic volume allocation.\n+\n+. Recreate the original namespace:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl create namespace _myproject_\n+----\n+\n+. Recreate the original PVC resource specifications, linking the PVCs to the appropriate PV:\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: v1\n+kind: PersistentVolumeClaim\n+metadata:\n+  name: data-0-my-cluster-kafka-0\n+spec:\n+  accessModes:\n+  - ReadWriteOnce\n+  resources:\n+    requests:\n+      storage: 100Gi\n+  storageClassName: gp2-retain\n+  volumeMode: Filesystem\n+  volumeName: *pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c*\n+----\n+\n+. Edit the PV specifications to delete the `claimRef` properties that bound the original PVC.\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: v1\n+kind: PersistentVolume\n+metadata:\n+  annotations:\n+    kubernetes.io/createdby: aws-ebs-dynamic-provisioner\n+    pv.kubernetes.io/bound-by-controller: \"yes\"\n+    pv.kubernetes.io/provisioned-by: kubernetes.io/aws-ebs\n+  creationTimestamp: \"<date>\"\n+  finalizers:\n+  - kubernetes.io/pv-protection\n+  labels:\n+    failure-domain.beta.kubernetes.io/region: eu-west-1\n+    failure-domain.beta.kubernetes.io/zone: eu-west-1c\n+  name: pvc-7e226978-3317-11ea-97b0-0aef8816c7ea\n+  resourceVersion: \"39431\"\n+  selfLink: /api/v1/persistentvolumes/pvc-7e226978-3317-11ea-97b0-0aef8816c7ea\n+  uid: 7efe6b0d-3317-11ea-a650-06e1eadd9a4c\n+spec:\n+  accessModes:\n+  - ReadWriteOnce\n+  awsElasticBlockStore:\n+    fsType: xfs\n+    volumeID: aws://eu-west-1c/vol-09db3141656d1c258\n+  capacity:\n+    storage: 100Gi\n+  *claimRef:*\n+    *apiVersion: v1*\n+    *kind: PersistentVolumeClaim*\n+    *name: data-0-my-cluster-kafka-2*\n+    *namespace: myproject*\n+    *resourceVersion: \"39113\"*\n+    *uid: 54be1c60-3319-11ea-97b0-0aef8816c7ea*\n+  nodeAffinity:\n+    required:\n+      nodeSelectorTerms:\n+      - matchExpressions:\n+        - key: failure-domain.beta.kubernetes.io/zone\n+          operator: In\n+          values:\n+          - eu-west-1c\n+        - key: failure-domain.beta.kubernetes.io/region\n+          operator: In\n+          values:\n+          - eu-west-1\n+  persistentVolumeReclaimPolicy: Retain\n+  storageClassName: gp2-retain\n+  volumeMode: Filesystem\n+----\n++\n+In the example, the following properties are deleted:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+claimRef:\n+  apiVersion: v1\n+  kind: PersistentVolumeClaim\n+  name: data-0-my-cluster-kafka-2\n+  namespace: myproject\n+  resourceVersion: \"39113\"\n+  uid: 54be1c60-3319-11ea-97b0-0aef8816c7ea\n+----\n+\n+. Deploy the Cluster Operator.\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl apply -f install/cluster-operator -n _my-project_\n+----\n+\n+. Recreate your cluster.\n++\n+Follow the steps depending on whether or not you have all the `KafkaTopic` resources needed to recreate your cluster.\n++\n+--\n+*_Option 1_*: If you have *all* the `KafkaTopic` resources that existed before you lost your cluster, including internal topics such as committed offsets from `__consumer_offsets`:\n+\n+. Recreate all `KafkaTopic` resources.\n++\n+You must recreate the resources before deploying the clusters or the Topic Operator will delete the topics.\n+\n+. Deploy the Kafka cluster.\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl apply -f _kafka.yaml_\n+----\n+--\n++\n+--\n+*_Option 2_*: If you do not have all the `KafkaTopic` resources that existed before you lost your cluster:\n+\n+. Deploy the Kafka cluster, as with the first option, but without the Topic Operator by removing `topicOperator: {}` from the Kafka resource before deploying.\n++\n+If you include the Topic Operator in the deployment, the Topic Operator will delete all the topics.\n+\n+. Run an `exec` command to one of the Kafka broker pods to open the ZooKeeper shell script.\n++\n+For example, where _my-cluster-kafka-0_ is the name of the broker pod:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl exec _my-cluster-kafka-0_ bin/zookeeper-shell.sh localhost:2181\n+----\n+. Delete the whole `/strimzi` path to remove the Topic Operator storage.\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+delete /strimzi\n+----\n+. Enable the Topic Operator by redeploying the Kafka cluster with `topicOperator: {}` to recreate the `KafkaTopic` resources.\n+--\n+\n+. Verify the recovery by listing the `KafkaTopic` resources.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "originalPosition": 213}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e37fe633bfd4a092fb36c4a35718ecfb804d388", "author": {"user": {"login": "PaulRMellor", "name": null}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/6e37fe633bfd4a092fb36c4a35718ecfb804d388", "committedDate": "2020-01-17T13:29:21Z", "message": "review edits DL\n\nSigned-off-by: prmellor <pmellor@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NjQzMDg0", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#pullrequestreview-344643084", "createdAt": "2020-01-17T15:12:13Z", "commit": {"oid": "6e37fe633bfd4a092fb36c4a35718ecfb804d388"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNToxMjoxM1rOFe8A6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNToyODoxMFrOFe8hPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4NDg3Mg==", "bodyText": "I think this can easily happen even without a cloud. So I would maybe leave this sentence out.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367984872", "createdAt": "2020-01-17T15:12:13Z", "author": {"login": "scholzj"}, "path": "documentation/modules/managing/con-cluster-loss-recovery.adoc", "diffHunk": "@@ -0,0 +1,10 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-loss_{context}\"]\n+= Recovery from loss of a Kafka cluster\n+\n+A Kafka cluster might be lost, for example, when using cloud computing services.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e37fe633bfd4a092fb36c4a35718ecfb804d388"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4NDkyMw==", "bodyText": "I think in the original document I meant this more as Kubernetes cluster loss, not Kafka loss.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367984923", "createdAt": "2020-01-17T15:12:20Z", "author": {"login": "scholzj"}, "path": "documentation/modules/managing/con-cluster-loss-recovery.adoc", "diffHunk": "@@ -0,0 +1,10 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-loss_{context}\"]\n+= Recovery from loss of a Kafka cluster", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e37fe633bfd4a092fb36c4a35718ecfb804d388"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4NTI0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When a cluster is lost, you can use PVs to recover the cluster if they were preserved within the infrastructure.\n          \n          \n            \n            When a cluster is lost, you can use the data from the disks / volumes to recover the cluster if they were preserved within the infrastructure.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367985244", "createdAt": "2020-01-17T15:12:58Z", "author": {"login": "scholzj"}, "path": "documentation/modules/managing/con-cluster-loss-recovery.adoc", "diffHunk": "@@ -0,0 +1,10 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-loss_{context}\"]\n+= Recovery from loss of a Kafka cluster\n+\n+A Kafka cluster might be lost, for example, when using cloud computing services.\n+When a cluster is lost, you can use PVs to recover the cluster if they were preserved within the infrastructure.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e37fe633bfd4a092fb36c4a35718ecfb804d388"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4OTI3Mg==", "bodyText": "This might be my fault because of how I put together the original document. But I think this is a bit out of order. We first say if namespace is deleteed you can recover and only then we say oh, by the way unless you changed this setting the PVs will be deleted. I think we need to put this into the right order:\n\nExplain the policy\nTell them they need to use Retain for this", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367989272", "createdAt": "2020-01-17T15:20:31Z", "author": {"login": "scholzj"}, "path": "documentation/modules/managing/con-namespace-deletion-recovery.adoc", "diffHunk": "@@ -0,0 +1,21 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"namespace-deletion_{context}\"]\n+= Cluster recovery from namespace deletion\n+\n+Recovery from namespace deletion is possible because of the relationship between persistent volumes and namespaces.\n+A `PersistentVolume` (PV) is a storage resource that lives outside of a namespace.\n+A PV is mounted into a Kafka pod using a `PersistentVolumeClaim` (PVC), which lives inside a namespace.\n+\n+If a namespace is deleted unintentionally, you can recover it from a PV as long as it is still present.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e37fe633bfd4a092fb36c4a35718ecfb804d388"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk5MDY2MA==", "bodyText": "Actually, I'm not sure the storage class is important. The storage class will be different for every user.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367990660", "createdAt": "2020-01-17T15:23:11Z", "author": {"login": "scholzj"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes (PVs).\n+\n+The procedure assumes that the Topic Operator is deployed.\n+In situations such as these, the Topic Operator identifies that topics exist in Kafka, but the `KafkaTopic` resources do not exist.\n+The `KafkaTopic` resources must be recovered before a cluster is started so that the topics are not deleted by the Topic Operator.\n+\n+If the Topic Operator is not deployed, you only need to recover the `PersistentVolumeClaim` (PVC) resources.\n+\n+.Before you begin\n+\n+In this procedure, it is essential that PVs are mounted into the correct PVC to avoid data corruption.\n+A `volumeName` is specified for the PVC and this must match the name of the PV.\n+\n+For more information, see:\n+\n+* xref:ref-persistent-storage-{context}#pvc-naming[Persistent Volume Claim naming]\n+* xref:ref-jbod-storage-{context}#jbod-pvc[JBOD and Persistent Volume Claims]\n+\n+NOTE: The procedure does not include recovery of `KafkaUser` resources, which must be recreated manually.\n+\n+.Procedure\n+\n+. Check information on the PVs in the cluster:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl get pv\n+----\n++\n+Information is presented for PVs with data.\n++\n+Example output showing columns important to this procedure:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+NAME                                         RECLAIM POLICY\n+pvc-5e9c5c7f-3317-11ea-a650-06e1eadd9a4c ... Retain\n+pvc-5e9cc72d-3317-11ea-97b0-0aef8816c7ea ... Retain\n+pvc-5ead43d1-3317-11ea-97b0-0aef8816c7ea ... Retain\n+pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c ... Retain\n+pvc-7e21042e-3317-11ea-9786-02deaf9aa87e ... Retain\n+pvc-7e226978-3317-11ea-97b0-0aef8816c7ea ... Retain\n+\n+CLAIM                                     STORAGECLASS\n+myproject/data-my-cluster-zookeeper-1 ... gp2-retain", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e37fe633bfd4a092fb36c4a35718ecfb804d388"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk5MTMzMA==", "bodyText": "Is there some way how we can put it all on the same line? It took me a while to realize these two columns were on the same line as the previous ones.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367991330", "createdAt": "2020-01-17T15:24:33Z", "author": {"login": "scholzj"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes (PVs).\n+\n+The procedure assumes that the Topic Operator is deployed.\n+In situations such as these, the Topic Operator identifies that topics exist in Kafka, but the `KafkaTopic` resources do not exist.\n+The `KafkaTopic` resources must be recovered before a cluster is started so that the topics are not deleted by the Topic Operator.\n+\n+If the Topic Operator is not deployed, you only need to recover the `PersistentVolumeClaim` (PVC) resources.\n+\n+.Before you begin\n+\n+In this procedure, it is essential that PVs are mounted into the correct PVC to avoid data corruption.\n+A `volumeName` is specified for the PVC and this must match the name of the PV.\n+\n+For more information, see:\n+\n+* xref:ref-persistent-storage-{context}#pvc-naming[Persistent Volume Claim naming]\n+* xref:ref-jbod-storage-{context}#jbod-pvc[JBOD and Persistent Volume Claims]\n+\n+NOTE: The procedure does not include recovery of `KafkaUser` resources, which must be recreated manually.\n+\n+.Procedure\n+\n+. Check information on the PVs in the cluster:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl get pv\n+----\n++\n+Information is presented for PVs with data.\n++\n+Example output showing columns important to this procedure:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+NAME                                         RECLAIM POLICY\n+pvc-5e9c5c7f-3317-11ea-a650-06e1eadd9a4c ... Retain\n+pvc-5e9cc72d-3317-11ea-97b0-0aef8816c7ea ... Retain\n+pvc-5ead43d1-3317-11ea-97b0-0aef8816c7ea ... Retain\n+pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c ... Retain\n+pvc-7e21042e-3317-11ea-9786-02deaf9aa87e ... Retain\n+pvc-7e226978-3317-11ea-97b0-0aef8816c7ea ... Retain\n+\n+CLAIM                                     STORAGECLASS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e37fe633bfd4a092fb36c4a35718ecfb804d388"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk5MjMyNA==", "bodyText": "This is what opetion 1 does. The option 2 does something different and doesn't recover the Kafkatopics. So maybe we should put here something generic?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367992324", "createdAt": "2020-01-17T15:26:30Z", "author": {"login": "scholzj"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes (PVs).\n+\n+The procedure assumes that the Topic Operator is deployed.\n+In situations such as these, the Topic Operator identifies that topics exist in Kafka, but the `KafkaTopic` resources do not exist.\n+The `KafkaTopic` resources must be recovered before a cluster is started so that the topics are not deleted by the Topic Operator.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e37fe633bfd4a092fb36c4a35718ecfb804d388"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk5MjgyNw==", "bodyText": "This might be misleading given the old deprecated topic operator. Could we add the whole entitity operator part here as example?\n  entityOperator:\n    topicOperator: {}\n    #...", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367992827", "createdAt": "2020-01-17T15:27:29Z", "author": {"login": "scholzj"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes (PVs).\n+\n+The procedure assumes that the Topic Operator is deployed.\n+In situations such as these, the Topic Operator identifies that topics exist in Kafka, but the `KafkaTopic` resources do not exist.\n+The `KafkaTopic` resources must be recovered before a cluster is started so that the topics are not deleted by the Topic Operator.\n+\n+If the Topic Operator is not deployed, you only need to recover the `PersistentVolumeClaim` (PVC) resources.\n+\n+.Before you begin\n+\n+In this procedure, it is essential that PVs are mounted into the correct PVC to avoid data corruption.\n+A `volumeName` is specified for the PVC and this must match the name of the PV.\n+\n+For more information, see:\n+\n+* xref:ref-persistent-storage-{context}#pvc-naming[Persistent Volume Claim naming]\n+* xref:ref-jbod-storage-{context}#jbod-pvc[JBOD and Persistent Volume Claims]\n+\n+NOTE: The procedure does not include recovery of `KafkaUser` resources, which must be recreated manually.\n+\n+.Procedure\n+\n+. Check information on the PVs in the cluster:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl get pv\n+----\n++\n+Information is presented for PVs with data.\n++\n+Example output showing columns important to this procedure:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+NAME                                         RECLAIM POLICY\n+pvc-5e9c5c7f-3317-11ea-a650-06e1eadd9a4c ... Retain\n+pvc-5e9cc72d-3317-11ea-97b0-0aef8816c7ea ... Retain\n+pvc-5ead43d1-3317-11ea-97b0-0aef8816c7ea ... Retain\n+pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c ... Retain\n+pvc-7e21042e-3317-11ea-9786-02deaf9aa87e ... Retain\n+pvc-7e226978-3317-11ea-97b0-0aef8816c7ea ... Retain\n+\n+CLAIM                                     STORAGECLASS\n+myproject/data-my-cluster-zookeeper-1 ... gp2-retain\n+myproject/data-my-cluster-zookeeper-0 ... gp2-retain\n+myproject/data-my-cluster-zookeeper-2 ... gp2-retain\n+myproject/data-0-my-cluster-kafka-0   ... gp2-retain\n+myproject/data-0-my-cluster-kafka-1   ... gp2-retain\n+myproject/data-0-my-cluster-kafka-2   ... gp2-retain\n+----\n++\n+* _NAME_ shows the name of each PV.\n+* _RECLAIM POLICY_ shows that PVs are _retained_.\n+* _CLAIM_ shows the link to the original PVCs.\n+* _STORAGECLASS_ shows the name of the storage class used for dynamic volume allocation.\n+\n+. Recreate the original namespace:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl create namespace _myproject_\n+----\n+\n+. Recreate the original PVC resource specifications, linking the PVCs to the appropriate PV:\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: v1\n+kind: PersistentVolumeClaim\n+metadata:\n+  name: data-0-my-cluster-kafka-0\n+spec:\n+  accessModes:\n+  - ReadWriteOnce\n+  resources:\n+    requests:\n+      storage: 100Gi\n+  storageClassName: gp2-retain\n+  volumeMode: Filesystem\n+  volumeName: *pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c*\n+----\n+\n+. Edit the PV specifications to delete the `claimRef` properties that bound the original PVC.\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: v1\n+kind: PersistentVolume\n+metadata:\n+  annotations:\n+    kubernetes.io/createdby: aws-ebs-dynamic-provisioner\n+    pv.kubernetes.io/bound-by-controller: \"yes\"\n+    pv.kubernetes.io/provisioned-by: kubernetes.io/aws-ebs\n+  creationTimestamp: \"<date>\"\n+  finalizers:\n+  - kubernetes.io/pv-protection\n+  labels:\n+    failure-domain.beta.kubernetes.io/region: eu-west-1\n+    failure-domain.beta.kubernetes.io/zone: eu-west-1c\n+  name: pvc-7e226978-3317-11ea-97b0-0aef8816c7ea\n+  resourceVersion: \"39431\"\n+  selfLink: /api/v1/persistentvolumes/pvc-7e226978-3317-11ea-97b0-0aef8816c7ea\n+  uid: 7efe6b0d-3317-11ea-a650-06e1eadd9a4c\n+spec:\n+  accessModes:\n+  - ReadWriteOnce\n+  awsElasticBlockStore:\n+    fsType: xfs\n+    volumeID: aws://eu-west-1c/vol-09db3141656d1c258\n+  capacity:\n+    storage: 100Gi\n+  *claimRef:*\n+    *apiVersion: v1*\n+    *kind: PersistentVolumeClaim*\n+    *name: data-0-my-cluster-kafka-2*\n+    *namespace: myproject*\n+    *resourceVersion: \"39113\"*\n+    *uid: 54be1c60-3319-11ea-97b0-0aef8816c7ea*\n+  nodeAffinity:\n+    required:\n+      nodeSelectorTerms:\n+      - matchExpressions:\n+        - key: failure-domain.beta.kubernetes.io/zone\n+          operator: In\n+          values:\n+          - eu-west-1c\n+        - key: failure-domain.beta.kubernetes.io/region\n+          operator: In\n+          values:\n+          - eu-west-1\n+  persistentVolumeReclaimPolicy: Retain\n+  storageClassName: gp2-retain\n+  volumeMode: Filesystem\n+----\n++\n+In the example, the following properties are deleted:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+claimRef:\n+  apiVersion: v1\n+  kind: PersistentVolumeClaim\n+  name: data-0-my-cluster-kafka-2\n+  namespace: myproject\n+  resourceVersion: \"39113\"\n+  uid: 54be1c60-3319-11ea-97b0-0aef8816c7ea\n+----\n+\n+. Deploy the Cluster Operator.\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl apply -f install/cluster-operator -n _my-project_\n+----\n+\n+. Recreate your cluster.\n++\n+Follow the steps depending on whether or not you have all the `KafkaTopic` resources needed to recreate your cluster.\n++\n+--\n+*_Option 1_*: If you have *all* the `KafkaTopic` resources that existed before you lost your cluster, including internal topics such as committed offsets from `__consumer_offsets`:\n+\n+. Recreate all `KafkaTopic` resources.\n++\n+It is essential that you recreate the resources before deploying the cluster, or the Topic Operator will delete the topics.\n+\n+. Deploy the Kafka cluster.\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl apply -f _kafka.yaml_\n+----\n+--\n++\n+--\n+*_Option 2_*: If you do not have all the `KafkaTopic` resources that existed before you lost your cluster:\n+\n+. Deploy the Kafka cluster, as with the first option, but without the Topic Operator by removing `topicOperator: {}` from the Kafka resource before deploying.\n++\n+If you include the Topic Operator in the deployment, the Topic Operator will delete all the topics.\n+\n+. Run an `exec` command to one of the Kafka broker pods to open the ZooKeeper shell script.\n++\n+For example, where _my-cluster-kafka-0_ is the name of the broker pod:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl exec _my-cluster-kafka-0_ bin/zookeeper-shell.sh localhost:2181\n+----\n+. Delete the whole `/strimzi` path to remove the Topic Operator storage:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+delete /strimzi\n+----\n+. Enable the Topic Operator by redeploying the Kafka cluster with `topicOperator: {}` to recreate the `KafkaTopic` resources.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e37fe633bfd4a092fb36c4a35718ecfb804d388"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk5MzE0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * A whole cluster is lost, but the PVs remain in the infrastructure\n          \n          \n            \n            * A whole Kubernetes cluster is lost, but the PVs remain in the infrastructure", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r367993148", "createdAt": "2020-01-17T15:28:10Z", "author": {"login": "scholzj"}, "path": "documentation/assemblies/managing/assembly-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,22 @@\n+// This assembly is included in:\n+//\n+// assembly-management-tasks.adoc\n+\n+[id=\"cluster-recovery_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+You can recover a Kafka cluster from persistent volumes (PVs) if they are still present.\n+\n+You might want to do this, for example, after:\n+\n+* A namespace was deleted unintentionally\n+* A whole cluster is lost, but the PVs remain in the infrastructure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e37fe633bfd4a092fb36c4a35718ecfb804d388"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MTg2MjI5", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#pullrequestreview-345186229", "createdAt": "2020-01-20T09:48:32Z", "commit": {"oid": "6e37fe633bfd4a092fb36c4a35718ecfb804d388"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87b257fe422e59b76b09892db9db8a38ec50cc81", "author": {"user": {"login": "PaulRMellor", "name": null}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/87b257fe422e59b76b09892db9db8a38ec50cc81", "committedDate": "2020-01-20T13:17:39Z", "message": "review edits JS\n\nSigned-off-by: prmellor <pmellor@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NzIyNzgx", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#pullrequestreview-345722781", "createdAt": "2020-01-21T09:10:13Z", "commit": {"oid": "87b257fe422e59b76b09892db9db8a38ec50cc81"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwOToxMDoxM1rOFfyv1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwOToxNjoxNVrOFfy67A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4MTYyMg==", "bodyText": "The In this situation sounds confusing for me. Because this sentence describes what would happen if we do not use any of the options. So I guess either it needs to be above the options as a general description of the issue or I would keep it here and just remove the In this situation because it sounds like this is what happens when you go OPtion 1.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r368881622", "createdAt": "2020-01-21T09:10:13Z", "author": {"login": "scholzj"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,232 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes (PVs).\n+\n+When you get to the step to recreate your cluster, you have two options:\n+\n+. Use _Option 1_ when you can recover all `KafkaTopic` resources.\n++\n+In this situation, the Topic Operator identifies that topics exist in Kafka, but the `KafkaTopic` resources do not exist.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87b257fe422e59b76b09892db9db8a38ec50cc81"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4MTk5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This time you deploy your cluster without the Topic Operator and then redeploy it so that the Topic Operator can recreate the `KafkaTopic` resources from the corresponding topics.\n          \n          \n            \n            This time you deploy your cluster without the Topic Operator, delete the Topic Operator data in Zookeeper and then redeploy it so that the Topic Operator can recreate the `KafkaTopic` resources from the corresponding topics.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r368881999", "createdAt": "2020-01-21T09:10:59Z", "author": {"login": "scholzj"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,232 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes (PVs).\n+\n+When you get to the step to recreate your cluster, you have two options:\n+\n+. Use _Option 1_ when you can recover all `KafkaTopic` resources.\n++\n+In this situation, the Topic Operator identifies that topics exist in Kafka, but the `KafkaTopic` resources do not exist.\n+The `KafkaTopic` resources must therefore be recovered before the cluster is started so that the corresponding topics are not deleted by the Topic Operator.\n+\n+. Use _Option 2_ when you are unable to recover all `KafkaTopic` resources.\n++\n+This time you deploy your cluster without the Topic Operator and then redeploy it so that the Topic Operator can recreate the `KafkaTopic` resources from the corresponding topics.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87b257fe422e59b76b09892db9db8a38ec50cc81"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4MjI0Ng==", "bodyText": "Thsi is not shown anymore, so we can probably delete it.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r368882246", "createdAt": "2020-01-21T09:11:30Z", "author": {"login": "scholzj"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,232 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes (PVs).\n+\n+When you get to the step to recreate your cluster, you have two options:\n+\n+. Use _Option 1_ when you can recover all `KafkaTopic` resources.\n++\n+In this situation, the Topic Operator identifies that topics exist in Kafka, but the `KafkaTopic` resources do not exist.\n+The `KafkaTopic` resources must therefore be recovered before the cluster is started so that the corresponding topics are not deleted by the Topic Operator.\n+\n+. Use _Option 2_ when you are unable to recover all `KafkaTopic` resources.\n++\n+This time you deploy your cluster without the Topic Operator and then redeploy it so that the Topic Operator can recreate the `KafkaTopic` resources from the corresponding topics.\n+\n+NOTE: If the Topic Operator is not deployed, you only need to recover the `PersistentVolumeClaim` (PVC) resources.\n+\n+.Before you begin\n+\n+In this procedure, it is essential that PVs are mounted into the correct PVC to avoid data corruption.\n+A `volumeName` is specified for the PVC and this must match the name of the PV.\n+\n+For more information, see:\n+\n+* xref:ref-persistent-storage-{context}#pvc-naming[Persistent Volume Claim naming]\n+* xref:ref-jbod-storage-{context}#jbod-pvc[JBOD and Persistent Volume Claims]\n+\n+NOTE: The procedure does not include recovery of `KafkaUser` resources, which must be recreated manually.\n+\n+.Procedure\n+\n+. Check information on the PVs in the cluster:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl get pv\n+----\n++\n+Information is presented for PVs with data.\n++\n+Example output showing columns important to this procedure:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+NAME                                         RECLAIM    POLICY CLAIM\n+pvc-5e9c5c7f-3317-11ea-a650-06e1eadd9a4c ... Retain ... myproject/data-my-cluster-zookeeper-1 ...\n+pvc-5e9cc72d-3317-11ea-97b0-0aef8816c7ea ... Retain ... myproject/data-my-cluster-zookeeper-0\n+pvc-5ead43d1-3317-11ea-97b0-0aef8816c7ea ... Retain ... myproject/data-my-cluster-zookeeper-2\n+pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c ... Retain ... myproject/data-0-my-cluster-kafka-0\n+pvc-7e21042e-3317-11ea-9786-02deaf9aa87e ... Retain ... myproject/data-0-my-cluster-kafka-1\n+pvc-7e226978-3317-11ea-97b0-0aef8816c7ea ... Retain ... myproject/data-0-my-cluster-kafka-2\n+----\n++\n+* _NAME_ shows the name of each PV.\n+* _RECLAIM POLICY_ shows that PVs are _retained_.\n+* _CLAIM_ shows the link to the original PVCs.\n+* _STORAGECLASS_ shows the name of the storage class used for dynamic volume allocation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87b257fe422e59b76b09892db9db8a38ec50cc81"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4MzgzNQ==", "bodyText": "I would probably leave that for another PR to make the review process easier. In general, thsi is easier:\n\nUser has to recreate all the KafkaUser resources\nIf the user wants to keep the old passwords / certificates, they have to recreate the secrets with them before creating the KafkaUSer resources\n\nultimately, there is not risk of data loss here, so IMHO not a big deal.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r368883835", "createdAt": "2020-01-21T09:14:55Z", "author": {"login": "scholzj"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes.\n+\n+The procedure assumes that the Topic Operator is deployed.\n+In situations such as these, the Topic Operator identifies that topics exist in Kafka, but the `KafkaTopic` resources do not exist.\n+The `KafkaTopic` resources must be recovered before a cluster is started so that the topics are not deleted by the Topic Operator.\n+\n+If you do not use the the Topic Operator, you just need to recover the `PersistentVolumeClaim` (PVC) resources.\n+\n+.Before you begin\n+\n+In this procedure, it is essential that PVs are mounted into the correct PVC to avoid data corruption.\n+A `volumeName` is specified for the PVC and this must match the name of the PV.\n+\n+For more information, see:\n+\n+* xref:ref-persistent-storage-{context}#pvc-naming[Persistent Volume Claim naming]\n+* xref:ref-jbod-storage-{context}#jbod-pvc[JBOD and Persistent Volume Claims]\n+\n+NOTE: The procedure does not include recovery of `KafkaUser` resources, which must be recreated manually.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzMTY1Ng=="}, "originalCommit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4NDE2OA==", "bodyText": "TBH, I don't know. What do you think would make it eaiser to understand for you?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r368884168", "createdAt": "2020-01-21T09:15:38Z", "author": {"login": "scholzj"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes.\n+\n+The procedure assumes that the Topic Operator is deployed.\n+In situations such as these, the Topic Operator identifies that topics exist in Kafka, but the `KafkaTopic` resources do not exist.\n+The `KafkaTopic` resources must be recovered before a cluster is started so that the topics are not deleted by the Topic Operator.\n+\n+If you do not use the the Topic Operator, you just need to recover the `PersistentVolumeClaim` (PVC) resources.\n+\n+.Before you begin\n+\n+In this procedure, it is essential that PVs are mounted into the correct PVC to avoid data corruption.\n+A `volumeName` is specified for the PVC and this must match the name of the PV.\n+\n+For more information, see:\n+\n+* xref:ref-persistent-storage-{context}#pvc-naming[Persistent Volume Claim naming]\n+* xref:ref-jbod-storage-{context}#jbod-pvc[JBOD and Persistent Volume Claims]\n+\n+NOTE: The procedure does not include recovery of `KafkaUser` resources, which must be recreated manually.\n+\n+.Procedure\n+\n+. Check information on the PVs in the cluster:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl get pv\n+----\n++\n+Information is presented for PVs with data.\n++\n+Example output showing columns important to this procedure:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+NAME                                         RECLAIM POLICY\n+pvc-5e9c5c7f-3317-11ea-a650-06e1eadd9a4c ... Retain\n+pvc-5e9cc72d-3317-11ea-97b0-0aef8816c7ea ... Retain\n+pvc-5ead43d1-3317-11ea-97b0-0aef8816c7ea ... Retain\n+pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c ... Retain\n+pvc-7e21042e-3317-11ea-9786-02deaf9aa87e ... Retain\n+pvc-7e226978-3317-11ea-97b0-0aef8816c7ea ... Retain\n+\n+CLAIM                                     STORAGECLASS\n+myproject/data-my-cluster-zookeeper-1 ... gp2-retain\n+myproject/data-my-cluster-zookeeper-0 ... gp2-retain\n+myproject/data-my-cluster-zookeeper-2 ... gp2-retain\n+myproject/data-0-my-cluster-kafka-0   ... gp2-retain\n+myproject/data-0-my-cluster-kafka-1   ... gp2-retain\n+myproject/data-0-my-cluster-kafka-2   ... gp2-retain\n+----\n++\n+* _NAME_ shows the name of each PV.\n+* _RECLAIM POLICY_ shows that PVs are _retained_.\n+* _CLAIM_ shows the link to the original PVCs.\n+* _STORAGECLASS_ shows the name of the storage class used for dynamic volume allocation.\n+\n+. Recreate the original namespace:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl create namespace _myproject_\n+----\n+\n+. Recreate the original PVC resource specifications, linking the PVCs to the appropriate PV:\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: v1\n+kind: PersistentVolumeClaim\n+metadata:\n+  name: data-0-my-cluster-kafka-0\n+spec:\n+  accessModes:\n+  - ReadWriteOnce\n+  resources:\n+    requests:\n+      storage: 100Gi\n+  storageClassName: gp2-retain\n+  volumeMode: Filesystem\n+  volumeName: *pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c*\n+----\n+\n+. Edit the PV specifications to delete the `claimRef` properties that bound the original PVC.\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI5ODkzNA=="}, "originalCommit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4NDQ2MA==", "bodyText": "This should be really deleteall /strimzi", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r368884460", "createdAt": "2020-01-21T09:16:15Z", "author": {"login": "scholzj"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes.\n+\n+The procedure assumes that the Topic Operator is deployed.\n+In situations such as these, the Topic Operator identifies that topics exist in Kafka, but the `KafkaTopic` resources do not exist.\n+The `KafkaTopic` resources must be recovered before a cluster is started so that the topics are not deleted by the Topic Operator.\n+\n+If you do not use the the Topic Operator, you just need to recover the `PersistentVolumeClaim` (PVC) resources.\n+\n+.Before you begin\n+\n+In this procedure, it is essential that PVs are mounted into the correct PVC to avoid data corruption.\n+A `volumeName` is specified for the PVC and this must match the name of the PV.\n+\n+For more information, see:\n+\n+* xref:ref-persistent-storage-{context}#pvc-naming[Persistent Volume Claim naming]\n+* xref:ref-jbod-storage-{context}#jbod-pvc[JBOD and Persistent Volume Claims]\n+\n+NOTE: The procedure does not include recovery of `KafkaUser` resources, which must be recreated manually.\n+\n+.Procedure\n+\n+. Check information on the PVs in the cluster:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl get pv\n+----\n++\n+Information is presented for PVs with data.\n++\n+Example output showing columns important to this procedure:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+NAME                                         RECLAIM POLICY\n+pvc-5e9c5c7f-3317-11ea-a650-06e1eadd9a4c ... Retain\n+pvc-5e9cc72d-3317-11ea-97b0-0aef8816c7ea ... Retain\n+pvc-5ead43d1-3317-11ea-97b0-0aef8816c7ea ... Retain\n+pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c ... Retain\n+pvc-7e21042e-3317-11ea-9786-02deaf9aa87e ... Retain\n+pvc-7e226978-3317-11ea-97b0-0aef8816c7ea ... Retain\n+\n+CLAIM                                     STORAGECLASS\n+myproject/data-my-cluster-zookeeper-1 ... gp2-retain\n+myproject/data-my-cluster-zookeeper-0 ... gp2-retain\n+myproject/data-my-cluster-zookeeper-2 ... gp2-retain\n+myproject/data-0-my-cluster-kafka-0   ... gp2-retain\n+myproject/data-0-my-cluster-kafka-1   ... gp2-retain\n+myproject/data-0-my-cluster-kafka-2   ... gp2-retain\n+----\n++\n+* _NAME_ shows the name of each PV.\n+* _RECLAIM POLICY_ shows that PVs are _retained_.\n+* _CLAIM_ shows the link to the original PVCs.\n+* _STORAGECLASS_ shows the name of the storage class used for dynamic volume allocation.\n+\n+. Recreate the original namespace:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl create namespace _myproject_\n+----\n+\n+. Recreate the original PVC resource specifications, linking the PVCs to the appropriate PV:\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: v1\n+kind: PersistentVolumeClaim\n+metadata:\n+  name: data-0-my-cluster-kafka-0\n+spec:\n+  accessModes:\n+  - ReadWriteOnce\n+  resources:\n+    requests:\n+      storage: 100Gi\n+  storageClassName: gp2-retain\n+  volumeMode: Filesystem\n+  volumeName: *pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c*\n+----\n+\n+. Edit the PV specifications to delete the `claimRef` properties that bound the original PVC.\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: v1\n+kind: PersistentVolume\n+metadata:\n+  annotations:\n+    kubernetes.io/createdby: aws-ebs-dynamic-provisioner\n+    pv.kubernetes.io/bound-by-controller: \"yes\"\n+    pv.kubernetes.io/provisioned-by: kubernetes.io/aws-ebs\n+  creationTimestamp: \"<date>\"\n+  finalizers:\n+  - kubernetes.io/pv-protection\n+  labels:\n+    failure-domain.beta.kubernetes.io/region: eu-west-1\n+    failure-domain.beta.kubernetes.io/zone: eu-west-1c\n+  name: pvc-7e226978-3317-11ea-97b0-0aef8816c7ea\n+  resourceVersion: \"39431\"\n+  selfLink: /api/v1/persistentvolumes/pvc-7e226978-3317-11ea-97b0-0aef8816c7ea\n+  uid: 7efe6b0d-3317-11ea-a650-06e1eadd9a4c\n+spec:\n+  accessModes:\n+  - ReadWriteOnce\n+  awsElasticBlockStore:\n+    fsType: xfs\n+    volumeID: aws://eu-west-1c/vol-09db3141656d1c258\n+  capacity:\n+    storage: 100Gi\n+  *claimRef:*\n+    *apiVersion: v1*\n+    *kind: PersistentVolumeClaim*\n+    *name: data-0-my-cluster-kafka-2*\n+    *namespace: myproject*\n+    *resourceVersion: \"39113\"*\n+    *uid: 54be1c60-3319-11ea-97b0-0aef8816c7ea*\n+  nodeAffinity:\n+    required:\n+      nodeSelectorTerms:\n+      - matchExpressions:\n+        - key: failure-domain.beta.kubernetes.io/zone\n+          operator: In\n+          values:\n+          - eu-west-1c\n+        - key: failure-domain.beta.kubernetes.io/region\n+          operator: In\n+          values:\n+          - eu-west-1\n+  persistentVolumeReclaimPolicy: Retain\n+  storageClassName: gp2-retain\n+  volumeMode: Filesystem\n+----\n++\n+In the example, the following properties are deleted:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+claimRef:\n+  apiVersion: v1\n+  kind: PersistentVolumeClaim\n+  name: data-0-my-cluster-kafka-2\n+  namespace: myproject\n+  resourceVersion: \"39113\"\n+  uid: 54be1c60-3319-11ea-97b0-0aef8816c7ea\n+----\n+\n+. Deploy the Cluster Operator.\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl apply -f install/cluster-operator -n _my-project_\n+----\n+\n+. Recreate your cluster.\n++\n+Follow the steps depending on whether or not you have all the `KafkaTopic` resources needed to recreate your cluster.\n++\n+--\n+*_Option 1_*: If you have *all* the `KafkaTopic` resources that existed before you lost your cluster, including internal topics such as committed offsets from `__consumer_offsets`:\n+\n+. Recreate all `KafkaTopic` resources.\n++\n+You must recreate the resources before deploying the clusters or the Topic Operator will delete the topics.\n+\n+. Deploy the Kafka cluster.\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl apply -f _kafka.yaml_\n+----\n+--\n++\n+--\n+*_Option 2_*: If you do not have all the `KafkaTopic` resources that existed before you lost your cluster:\n+\n+. Deploy the Kafka cluster, as with the first option, but without the Topic Operator by removing `topicOperator: {}` from the Kafka resource before deploying.\n++\n+If you include the Topic Operator in the deployment, the Topic Operator will delete all the topics.\n+\n+. Run an `exec` command to one of the Kafka broker pods to open the ZooKeeper shell script.\n++\n+For example, where _my-cluster-kafka-0_ is the name of the broker pod:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl exec _my-cluster-kafka-0_ bin/zookeeper-shell.sh localhost:2181\n+----\n+. Delete the whole `/strimzi` path to remove the Topic Operator storage.\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+delete /strimzi", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI5OTM4Ng=="}, "originalCommit": {"oid": "21a4caa8f132343629cd042f47c1b2e6a93be6e0"}, "originalPosition": 208}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19a697b27c54bd95b1023445b8c6d2514ffcc7e1", "author": {"user": {"login": "PaulRMellor", "name": null}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/19a697b27c54bd95b1023445b8c6d2514ffcc7e1", "committedDate": "2020-01-22T14:27:56Z", "message": "review edits JS\n\nSigned-off-by: prmellor <pmellor@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTI3MTc0", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#pullrequestreview-347127174", "createdAt": "2020-01-23T08:36:32Z", "commit": {"oid": "19a697b27c54bd95b1023445b8c6d2514ffcc7e1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTQ0OTAy", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#pullrequestreview-347144902", "createdAt": "2020-01-23T09:09:07Z", "commit": {"oid": "19a697b27c54bd95b1023445b8c6d2514ffcc7e1"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwOTowOTowN1rOFg3AnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwOToyMzo0MFrOFg3bMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAwMDAyOQ==", "bodyText": "\"are deleted within a namespace\"?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r370000029", "createdAt": "2020-01-23T09:09:07Z", "author": {"login": "ppatierno"}, "path": "documentation/modules/managing/con-namespace-deletion-recovery.adoc", "diffHunk": "@@ -0,0 +1,22 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"namespace-deletion_{context}\"]\n+= Recovery from namespace deletion\n+\n+Recovery from namespace deletion is possible because of the relationship between persistent volumes and namespaces.\n+A `PersistentVolume` (PV) is a storage resource that lives outside of a namespace.\n+A PV is mounted into a Kafka pod using a `PersistentVolumeClaim` (PVC), which lives inside a namespace.\n+\n+The reclaim policy for a PV tells a cluster how to act when a namespace is deleted.\n+If the reclaim policy is set as:\n+\n+*  _Delete_ (default), PVs are deleted when PVCs are deleted with a namespace", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19a697b27c54bd95b1023445b8c6d2514ffcc7e1"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAwNTU5NQ==", "bodyText": "I would say topicOperator property (or field) without the curly braces because they mean default configuration while the user could have a Kafka resource with the topic operator configuration different from the default. In this way the user will be not confused not having just curly braces which is mentioned in the doc.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r370005595", "createdAt": "2020-01-23T09:21:11Z", "author": {"login": "ppatierno"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,233 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes (PVs).\n+\n+In this situation, the Topic Operator identifies that topics exist in Kafka, but the `KafkaTopic` resources do not exist.\n+\n+When you get to the step to recreate your cluster, you have two options:\n+\n+. Use _Option 1_ when you can recover all `KafkaTopic` resources.\n++\n+The `KafkaTopic` resources must therefore be recovered before the cluster is started so that the corresponding topics are not deleted by the Topic Operator.\n+\n+. Use _Option 2_ when you are unable to recover all `KafkaTopic` resources.\n++\n+This time you deploy your cluster without the Topic Operator, delete the Topic Operator data in ZooKeeper, and then redeploy it so that the Topic Operator can recreate the `KafkaTopic` resources from the corresponding topics.\n+\n+NOTE: If the Topic Operator is not deployed, you only need to recover the `PersistentVolumeClaim` (PVC) resources.\n+\n+.Before you begin\n+\n+In this procedure, it is essential that PVs are mounted into the correct PVC to avoid data corruption.\n+A `volumeName` is specified for the PVC and this must match the name of the PV.\n+\n+For more information, see:\n+\n+* xref:ref-persistent-storage-{context}#pvc-naming[Persistent Volume Claim naming]\n+* xref:ref-jbod-storage-{context}#jbod-pvc[JBOD and Persistent Volume Claims]\n+\n+NOTE: The procedure does not include recovery of `KafkaUser` resources, which must be recreated manually.\n+If passwords and certificates need to be retained, secrets myst be recreated before creating the `KafkaUser` resources.\n+\n+.Procedure\n+\n+. Check information on the PVs in the cluster:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl get pv\n+----\n++\n+Information is presented for PVs with data.\n++\n+Example output showing columns important to this procedure:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+NAME                                         RECLAIM    POLICY CLAIM\n+pvc-5e9c5c7f-3317-11ea-a650-06e1eadd9a4c ... Retain ... myproject/data-my-cluster-zookeeper-1\n+pvc-5e9cc72d-3317-11ea-97b0-0aef8816c7ea ... Retain ... myproject/data-my-cluster-zookeeper-0\n+pvc-5ead43d1-3317-11ea-97b0-0aef8816c7ea ... Retain ... myproject/data-my-cluster-zookeeper-2\n+pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c ... Retain ... myproject/data-0-my-cluster-kafka-0\n+pvc-7e21042e-3317-11ea-9786-02deaf9aa87e ... Retain ... myproject/data-0-my-cluster-kafka-1\n+pvc-7e226978-3317-11ea-97b0-0aef8816c7ea ... Retain ... myproject/data-0-my-cluster-kafka-2\n+----\n++\n+* _NAME_ shows the name of each PV.\n+* _RECLAIM POLICY_ shows that PVs are _retained_.\n+* _CLAIM_ shows the link to the original PVCs.\n+\n+. Recreate the original namespace:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl create namespace _myproject_\n+----\n+\n+. Recreate the original PVC resource specifications, linking the PVCs to the appropriate PV:\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: v1\n+kind: PersistentVolumeClaim\n+metadata:\n+  name: data-0-my-cluster-kafka-0\n+spec:\n+  accessModes:\n+  - ReadWriteOnce\n+  resources:\n+    requests:\n+      storage: 100Gi\n+  storageClassName: gp2-retain\n+  volumeMode: Filesystem\n+  volumeName: *pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c*\n+----\n+\n+. Edit the PV specifications to delete the `claimRef` properties that bound the original PVC.\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: v1\n+kind: PersistentVolume\n+metadata:\n+  annotations:\n+    kubernetes.io/createdby: aws-ebs-dynamic-provisioner\n+    pv.kubernetes.io/bound-by-controller: \"yes\"\n+    pv.kubernetes.io/provisioned-by: kubernetes.io/aws-ebs\n+  creationTimestamp: \"<date>\"\n+  finalizers:\n+  - kubernetes.io/pv-protection\n+  labels:\n+    failure-domain.beta.kubernetes.io/region: eu-west-1\n+    failure-domain.beta.kubernetes.io/zone: eu-west-1c\n+  name: pvc-7e226978-3317-11ea-97b0-0aef8816c7ea\n+  resourceVersion: \"39431\"\n+  selfLink: /api/v1/persistentvolumes/pvc-7e226978-3317-11ea-97b0-0aef8816c7ea\n+  uid: 7efe6b0d-3317-11ea-a650-06e1eadd9a4c\n+spec:\n+  accessModes:\n+  - ReadWriteOnce\n+  awsElasticBlockStore:\n+    fsType: xfs\n+    volumeID: aws://eu-west-1c/vol-09db3141656d1c258\n+  capacity:\n+    storage: 100Gi\n+  *claimRef:*\n+    *apiVersion: v1*\n+    *kind: PersistentVolumeClaim*\n+    *name: data-0-my-cluster-kafka-2*\n+    *namespace: myproject*\n+    *resourceVersion: \"39113\"*\n+    *uid: 54be1c60-3319-11ea-97b0-0aef8816c7ea*\n+  nodeAffinity:\n+    required:\n+      nodeSelectorTerms:\n+      - matchExpressions:\n+        - key: failure-domain.beta.kubernetes.io/zone\n+          operator: In\n+          values:\n+          - eu-west-1c\n+        - key: failure-domain.beta.kubernetes.io/region\n+          operator: In\n+          values:\n+          - eu-west-1\n+  persistentVolumeReclaimPolicy: Retain\n+  storageClassName: gp2-retain\n+  volumeMode: Filesystem\n+----\n++\n+In the example, the following properties are deleted:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+claimRef:\n+  apiVersion: v1\n+  kind: PersistentVolumeClaim\n+  name: data-0-my-cluster-kafka-2\n+  namespace: myproject\n+  resourceVersion: \"39113\"\n+  uid: 54be1c60-3319-11ea-97b0-0aef8816c7ea\n+----\n+\n+. Deploy the Cluster Operator.\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl apply -f install/cluster-operator -n _my-project_\n+----\n+\n+. Recreate your cluster.\n++\n+Follow the steps depending on whether or not you have all the `KafkaTopic` resources needed to recreate your cluster.\n++\n+--\n+*_Option 1_*: If you have *all* the `KafkaTopic` resources that existed before you lost your cluster, including internal topics such as committed offsets from `__consumer_offsets`:\n+\n+. Recreate all `KafkaTopic` resources.\n++\n+It is essential that you recreate the resources before deploying the cluster, or the Topic Operator will delete the topics.\n+\n+. Deploy the Kafka cluster.\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl apply -f _kafka.yaml_\n+----\n+--\n++\n+--\n+*_Option 2_*: If you do not have all the `KafkaTopic` resources that existed before you lost your cluster:\n+\n+. Deploy the Kafka cluster, as with the first option, but without the Topic Operator by removing `topicOperator: {}` from the Kafka resource before deploying.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19a697b27c54bd95b1023445b8c6d2514ffcc7e1"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAwNjQwNw==", "bodyText": "again I would mention just to reapply the topicOperator field (no curly braces). We don't know the actual topic operator configuration that the user has in the Kafka resource.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r370006407", "createdAt": "2020-01-23T09:22:49Z", "author": {"login": "ppatierno"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,233 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes (PVs).\n+\n+In this situation, the Topic Operator identifies that topics exist in Kafka, but the `KafkaTopic` resources do not exist.\n+\n+When you get to the step to recreate your cluster, you have two options:\n+\n+. Use _Option 1_ when you can recover all `KafkaTopic` resources.\n++\n+The `KafkaTopic` resources must therefore be recovered before the cluster is started so that the corresponding topics are not deleted by the Topic Operator.\n+\n+. Use _Option 2_ when you are unable to recover all `KafkaTopic` resources.\n++\n+This time you deploy your cluster without the Topic Operator, delete the Topic Operator data in ZooKeeper, and then redeploy it so that the Topic Operator can recreate the `KafkaTopic` resources from the corresponding topics.\n+\n+NOTE: If the Topic Operator is not deployed, you only need to recover the `PersistentVolumeClaim` (PVC) resources.\n+\n+.Before you begin\n+\n+In this procedure, it is essential that PVs are mounted into the correct PVC to avoid data corruption.\n+A `volumeName` is specified for the PVC and this must match the name of the PV.\n+\n+For more information, see:\n+\n+* xref:ref-persistent-storage-{context}#pvc-naming[Persistent Volume Claim naming]\n+* xref:ref-jbod-storage-{context}#jbod-pvc[JBOD and Persistent Volume Claims]\n+\n+NOTE: The procedure does not include recovery of `KafkaUser` resources, which must be recreated manually.\n+If passwords and certificates need to be retained, secrets myst be recreated before creating the `KafkaUser` resources.\n+\n+.Procedure\n+\n+. Check information on the PVs in the cluster:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl get pv\n+----\n++\n+Information is presented for PVs with data.\n++\n+Example output showing columns important to this procedure:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+NAME                                         RECLAIM    POLICY CLAIM\n+pvc-5e9c5c7f-3317-11ea-a650-06e1eadd9a4c ... Retain ... myproject/data-my-cluster-zookeeper-1\n+pvc-5e9cc72d-3317-11ea-97b0-0aef8816c7ea ... Retain ... myproject/data-my-cluster-zookeeper-0\n+pvc-5ead43d1-3317-11ea-97b0-0aef8816c7ea ... Retain ... myproject/data-my-cluster-zookeeper-2\n+pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c ... Retain ... myproject/data-0-my-cluster-kafka-0\n+pvc-7e21042e-3317-11ea-9786-02deaf9aa87e ... Retain ... myproject/data-0-my-cluster-kafka-1\n+pvc-7e226978-3317-11ea-97b0-0aef8816c7ea ... Retain ... myproject/data-0-my-cluster-kafka-2\n+----\n++\n+* _NAME_ shows the name of each PV.\n+* _RECLAIM POLICY_ shows that PVs are _retained_.\n+* _CLAIM_ shows the link to the original PVCs.\n+\n+. Recreate the original namespace:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl create namespace _myproject_\n+----\n+\n+. Recreate the original PVC resource specifications, linking the PVCs to the appropriate PV:\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: v1\n+kind: PersistentVolumeClaim\n+metadata:\n+  name: data-0-my-cluster-kafka-0\n+spec:\n+  accessModes:\n+  - ReadWriteOnce\n+  resources:\n+    requests:\n+      storage: 100Gi\n+  storageClassName: gp2-retain\n+  volumeMode: Filesystem\n+  volumeName: *pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c*\n+----\n+\n+. Edit the PV specifications to delete the `claimRef` properties that bound the original PVC.\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: v1\n+kind: PersistentVolume\n+metadata:\n+  annotations:\n+    kubernetes.io/createdby: aws-ebs-dynamic-provisioner\n+    pv.kubernetes.io/bound-by-controller: \"yes\"\n+    pv.kubernetes.io/provisioned-by: kubernetes.io/aws-ebs\n+  creationTimestamp: \"<date>\"\n+  finalizers:\n+  - kubernetes.io/pv-protection\n+  labels:\n+    failure-domain.beta.kubernetes.io/region: eu-west-1\n+    failure-domain.beta.kubernetes.io/zone: eu-west-1c\n+  name: pvc-7e226978-3317-11ea-97b0-0aef8816c7ea\n+  resourceVersion: \"39431\"\n+  selfLink: /api/v1/persistentvolumes/pvc-7e226978-3317-11ea-97b0-0aef8816c7ea\n+  uid: 7efe6b0d-3317-11ea-a650-06e1eadd9a4c\n+spec:\n+  accessModes:\n+  - ReadWriteOnce\n+  awsElasticBlockStore:\n+    fsType: xfs\n+    volumeID: aws://eu-west-1c/vol-09db3141656d1c258\n+  capacity:\n+    storage: 100Gi\n+  *claimRef:*\n+    *apiVersion: v1*\n+    *kind: PersistentVolumeClaim*\n+    *name: data-0-my-cluster-kafka-2*\n+    *namespace: myproject*\n+    *resourceVersion: \"39113\"*\n+    *uid: 54be1c60-3319-11ea-97b0-0aef8816c7ea*\n+  nodeAffinity:\n+    required:\n+      nodeSelectorTerms:\n+      - matchExpressions:\n+        - key: failure-domain.beta.kubernetes.io/zone\n+          operator: In\n+          values:\n+          - eu-west-1c\n+        - key: failure-domain.beta.kubernetes.io/region\n+          operator: In\n+          values:\n+          - eu-west-1\n+  persistentVolumeReclaimPolicy: Retain\n+  storageClassName: gp2-retain\n+  volumeMode: Filesystem\n+----\n++\n+In the example, the following properties are deleted:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+claimRef:\n+  apiVersion: v1\n+  kind: PersistentVolumeClaim\n+  name: data-0-my-cluster-kafka-2\n+  namespace: myproject\n+  resourceVersion: \"39113\"\n+  uid: 54be1c60-3319-11ea-97b0-0aef8816c7ea\n+----\n+\n+. Deploy the Cluster Operator.\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl apply -f install/cluster-operator -n _my-project_\n+----\n+\n+. Recreate your cluster.\n++\n+Follow the steps depending on whether or not you have all the `KafkaTopic` resources needed to recreate your cluster.\n++\n+--\n+*_Option 1_*: If you have *all* the `KafkaTopic` resources that existed before you lost your cluster, including internal topics such as committed offsets from `__consumer_offsets`:\n+\n+. Recreate all `KafkaTopic` resources.\n++\n+It is essential that you recreate the resources before deploying the cluster, or the Topic Operator will delete the topics.\n+\n+. Deploy the Kafka cluster.\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl apply -f _kafka.yaml_\n+----\n+--\n++\n+--\n+*_Option 2_*: If you do not have all the `KafkaTopic` resources that existed before you lost your cluster:\n+\n+. Deploy the Kafka cluster, as with the first option, but without the Topic Operator by removing `topicOperator: {}` from the Kafka resource before deploying.\n++\n+If you include the Topic Operator in the deployment, the Topic Operator will delete all the topics.\n+\n+. Run an `exec` command to one of the Kafka broker pods to open the ZooKeeper shell script.\n++\n+For example, where _my-cluster-kafka-0_ is the name of the broker pod:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl exec _my-cluster-kafka-0_ bin/zookeeper-shell.sh localhost:2181\n+----\n+. Delete the whole `/strimzi` path to remove the Topic Operator storage:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+deleteall /strimzi\n+----\n+. Enable the Topic Operator by redeploying the Kafka cluster with `topicOperator: {}` to recreate the `KafkaTopic` resources.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19a697b27c54bd95b1023445b8c6d2514ffcc7e1"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAwNjgzNQ==", "bodyText": "and of course here we could use a comment to specify the user topic operator configuration instead of curly braces and maybe mentioning/showing { } just for using the default one.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#discussion_r370006835", "createdAt": "2020-01-23T09:23:40Z", "author": {"login": "ppatierno"}, "path": "documentation/modules/managing/proc-cluster-recovery-volume.adoc", "diffHunk": "@@ -0,0 +1,233 @@\n+// Module included in the following assembly:\n+//\n+// assembly-cluster-recovery-volume.adoc\n+\n+[id=\"cluster-recovery-volume_{context}\"]\n+= Recovering a cluster from persistent volumes\n+\n+This procedure describes how to recover a deleted cluster from persistent volumes (PVs).\n+\n+In this situation, the Topic Operator identifies that topics exist in Kafka, but the `KafkaTopic` resources do not exist.\n+\n+When you get to the step to recreate your cluster, you have two options:\n+\n+. Use _Option 1_ when you can recover all `KafkaTopic` resources.\n++\n+The `KafkaTopic` resources must therefore be recovered before the cluster is started so that the corresponding topics are not deleted by the Topic Operator.\n+\n+. Use _Option 2_ when you are unable to recover all `KafkaTopic` resources.\n++\n+This time you deploy your cluster without the Topic Operator, delete the Topic Operator data in ZooKeeper, and then redeploy it so that the Topic Operator can recreate the `KafkaTopic` resources from the corresponding topics.\n+\n+NOTE: If the Topic Operator is not deployed, you only need to recover the `PersistentVolumeClaim` (PVC) resources.\n+\n+.Before you begin\n+\n+In this procedure, it is essential that PVs are mounted into the correct PVC to avoid data corruption.\n+A `volumeName` is specified for the PVC and this must match the name of the PV.\n+\n+For more information, see:\n+\n+* xref:ref-persistent-storage-{context}#pvc-naming[Persistent Volume Claim naming]\n+* xref:ref-jbod-storage-{context}#jbod-pvc[JBOD and Persistent Volume Claims]\n+\n+NOTE: The procedure does not include recovery of `KafkaUser` resources, which must be recreated manually.\n+If passwords and certificates need to be retained, secrets myst be recreated before creating the `KafkaUser` resources.\n+\n+.Procedure\n+\n+. Check information on the PVs in the cluster:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl get pv\n+----\n++\n+Information is presented for PVs with data.\n++\n+Example output showing columns important to this procedure:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+NAME                                         RECLAIM    POLICY CLAIM\n+pvc-5e9c5c7f-3317-11ea-a650-06e1eadd9a4c ... Retain ... myproject/data-my-cluster-zookeeper-1\n+pvc-5e9cc72d-3317-11ea-97b0-0aef8816c7ea ... Retain ... myproject/data-my-cluster-zookeeper-0\n+pvc-5ead43d1-3317-11ea-97b0-0aef8816c7ea ... Retain ... myproject/data-my-cluster-zookeeper-2\n+pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c ... Retain ... myproject/data-0-my-cluster-kafka-0\n+pvc-7e21042e-3317-11ea-9786-02deaf9aa87e ... Retain ... myproject/data-0-my-cluster-kafka-1\n+pvc-7e226978-3317-11ea-97b0-0aef8816c7ea ... Retain ... myproject/data-0-my-cluster-kafka-2\n+----\n++\n+* _NAME_ shows the name of each PV.\n+* _RECLAIM POLICY_ shows that PVs are _retained_.\n+* _CLAIM_ shows the link to the original PVCs.\n+\n+. Recreate the original namespace:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl create namespace _myproject_\n+----\n+\n+. Recreate the original PVC resource specifications, linking the PVCs to the appropriate PV:\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: v1\n+kind: PersistentVolumeClaim\n+metadata:\n+  name: data-0-my-cluster-kafka-0\n+spec:\n+  accessModes:\n+  - ReadWriteOnce\n+  resources:\n+    requests:\n+      storage: 100Gi\n+  storageClassName: gp2-retain\n+  volumeMode: Filesystem\n+  volumeName: *pvc-7e1f67f9-3317-11ea-a650-06e1eadd9a4c*\n+----\n+\n+. Edit the PV specifications to delete the `claimRef` properties that bound the original PVC.\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: v1\n+kind: PersistentVolume\n+metadata:\n+  annotations:\n+    kubernetes.io/createdby: aws-ebs-dynamic-provisioner\n+    pv.kubernetes.io/bound-by-controller: \"yes\"\n+    pv.kubernetes.io/provisioned-by: kubernetes.io/aws-ebs\n+  creationTimestamp: \"<date>\"\n+  finalizers:\n+  - kubernetes.io/pv-protection\n+  labels:\n+    failure-domain.beta.kubernetes.io/region: eu-west-1\n+    failure-domain.beta.kubernetes.io/zone: eu-west-1c\n+  name: pvc-7e226978-3317-11ea-97b0-0aef8816c7ea\n+  resourceVersion: \"39431\"\n+  selfLink: /api/v1/persistentvolumes/pvc-7e226978-3317-11ea-97b0-0aef8816c7ea\n+  uid: 7efe6b0d-3317-11ea-a650-06e1eadd9a4c\n+spec:\n+  accessModes:\n+  - ReadWriteOnce\n+  awsElasticBlockStore:\n+    fsType: xfs\n+    volumeID: aws://eu-west-1c/vol-09db3141656d1c258\n+  capacity:\n+    storage: 100Gi\n+  *claimRef:*\n+    *apiVersion: v1*\n+    *kind: PersistentVolumeClaim*\n+    *name: data-0-my-cluster-kafka-2*\n+    *namespace: myproject*\n+    *resourceVersion: \"39113\"*\n+    *uid: 54be1c60-3319-11ea-97b0-0aef8816c7ea*\n+  nodeAffinity:\n+    required:\n+      nodeSelectorTerms:\n+      - matchExpressions:\n+        - key: failure-domain.beta.kubernetes.io/zone\n+          operator: In\n+          values:\n+          - eu-west-1c\n+        - key: failure-domain.beta.kubernetes.io/region\n+          operator: In\n+          values:\n+          - eu-west-1\n+  persistentVolumeReclaimPolicy: Retain\n+  storageClassName: gp2-retain\n+  volumeMode: Filesystem\n+----\n++\n+In the example, the following properties are deleted:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+claimRef:\n+  apiVersion: v1\n+  kind: PersistentVolumeClaim\n+  name: data-0-my-cluster-kafka-2\n+  namespace: myproject\n+  resourceVersion: \"39113\"\n+  uid: 54be1c60-3319-11ea-97b0-0aef8816c7ea\n+----\n+\n+. Deploy the Cluster Operator.\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl apply -f install/cluster-operator -n _my-project_\n+----\n+\n+. Recreate your cluster.\n++\n+Follow the steps depending on whether or not you have all the `KafkaTopic` resources needed to recreate your cluster.\n++\n+--\n+*_Option 1_*: If you have *all* the `KafkaTopic` resources that existed before you lost your cluster, including internal topics such as committed offsets from `__consumer_offsets`:\n+\n+. Recreate all `KafkaTopic` resources.\n++\n+It is essential that you recreate the resources before deploying the cluster, or the Topic Operator will delete the topics.\n+\n+. Deploy the Kafka cluster.\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl apply -f _kafka.yaml_\n+----\n+--\n++\n+--\n+*_Option 2_*: If you do not have all the `KafkaTopic` resources that existed before you lost your cluster:\n+\n+. Deploy the Kafka cluster, as with the first option, but without the Topic Operator by removing `topicOperator: {}` from the Kafka resource before deploying.\n++\n+If you include the Topic Operator in the deployment, the Topic Operator will delete all the topics.\n+\n+. Run an `exec` command to one of the Kafka broker pods to open the ZooKeeper shell script.\n++\n+For example, where _my-cluster-kafka-0_ is the name of the broker pod:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+kubectl exec _my-cluster-kafka-0_ bin/zookeeper-shell.sh localhost:2181\n+----\n+. Delete the whole `/strimzi` path to remove the Topic Operator storage:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+deleteall /strimzi\n+----\n+. Enable the Topic Operator by redeploying the Kafka cluster with `topicOperator: {}` to recreate the `KafkaTopic` resources.\n++\n+For example:\n++\n+[source,shell,subs=\"+quotes,attributes\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  #...\n+  entityOperator:\n+    *topicOperator: {}*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19a697b27c54bd95b1023445b8c6d2514ffcc7e1"}, "originalPosition": 223}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0cb6ad9bd2228b0f95d987cab789f79a029f45d", "author": {"user": {"login": "PaulRMellor", "name": null}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c0cb6ad9bd2228b0f95d987cab789f79a029f45d", "committedDate": "2020-01-24T09:21:42Z", "message": "review edits PP + small edit for downstream build\n\nSigned-off-by: prmellor <pmellor@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3ODQyODE5", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2396#pullrequestreview-347842819", "createdAt": "2020-01-24T09:48:49Z", "commit": {"oid": "c0cb6ad9bd2228b0f95d987cab789f79a029f45d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1794, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}