{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0NzMwMTgy", "number": 4070, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDowODo0OFrOFC1zPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDowODo0OFrOFC1zPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NTIyOTQzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDowODo0OFrOICMmow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDoxNjoxNlrOICM6mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3NDU2Mw==", "bodyText": "commented code?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/4070#discussion_r539174563", "createdAt": "2020-12-09T10:08:48Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -753,6 +753,66 @@ public void checkCustomCaSecret(CertificateAuthority ca, Secret certSecret, Secr\n                     });\n         }\n \n+        /**\n+         * Does rolling update of Kafka pods based on the annotation on Pod level\n+         *\n+         * @param sts   The Kafka StatefulSet definition needed for the rolling update\n+         *\n+         * @return  Future with the result of the rolling update\n+         */\n+        @SuppressWarnings(\"deprecation\")\n+        Future<Void> kafkaManualPodRollingUpdate(StatefulSet sts) {\n+            return podOperations.listAsync(namespace, kafkaCluster.getSelectorLabels())\n+                    .compose(pods -> {\n+                        List<String> podsToRoll = new ArrayList<>(0);\n+\n+                        for (Pod pod : pods)    {\n+                            if (Annotations.booleanAnnotation(pod, Annotations.ANNO_STRIMZI_IO_MANUAL_ROLLING_UPDATE,\n+                                    false, Annotations.ANNO_OP_STRIMZI_IO_MANUAL_ROLLING_UPDATE)) {\n+                                podsToRoll.add(pod.getMetadata().getName());\n+                            }\n+                        }\n+\n+                        if (!podsToRoll.isEmpty())  {\n+                            return maybeRollKafka(sts, pod -> {\n+                                if (pod != null && podsToRoll.contains(pod.getMetadata().getName())) {\n+                                    log.debug(\"{}: Rolling Kafka pod {} due to manual rolling update annotation on a pod\", reconciliation, pod.getMetadata().getName());\n+                                    return singletonList(\"manual rolling update annotation on a pod\");\n+                                } else {\n+                                    return null;\n+                                }\n+                            });\n+                        } else {\n+                            return Future.succeededFuture();\n+                        }\n+\n+                        /*Future<Void> podRoll = Future.succeededFuture();\n+\n+                        for (String podName : podsToRoll)   {\n+                            podRoll = podRoll.compose(ignore -> {\n+                                return maybeRollKafka(sts, pod -> {\n+                                    if (pod != null && podName.equals(pod.getMetadata().getName())) {\n+                                        log.debug(\"{}: Rolling Kafka pod {} due to manual rolling update annotation on a pod\", reconciliation, podName);\n+                                        return singletonList(\"manual rolling update annotation on a pod\");\n+                                    } else {\n+                                        return null;\n+                                    }\n+                                });\n+                            });\n+                        }\n+\n+                        return withVoid(podRoll);*/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97959eef75cf1f711018ac348b4d07d3e81ea4a7"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3OTY3NQ==", "bodyText": "Fixed. Thanks for noticing.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/4070#discussion_r539179675", "createdAt": "2020-12-09T10:16:16Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -753,6 +753,66 @@ public void checkCustomCaSecret(CertificateAuthority ca, Secret certSecret, Secr\n                     });\n         }\n \n+        /**\n+         * Does rolling update of Kafka pods based on the annotation on Pod level\n+         *\n+         * @param sts   The Kafka StatefulSet definition needed for the rolling update\n+         *\n+         * @return  Future with the result of the rolling update\n+         */\n+        @SuppressWarnings(\"deprecation\")\n+        Future<Void> kafkaManualPodRollingUpdate(StatefulSet sts) {\n+            return podOperations.listAsync(namespace, kafkaCluster.getSelectorLabels())\n+                    .compose(pods -> {\n+                        List<String> podsToRoll = new ArrayList<>(0);\n+\n+                        for (Pod pod : pods)    {\n+                            if (Annotations.booleanAnnotation(pod, Annotations.ANNO_STRIMZI_IO_MANUAL_ROLLING_UPDATE,\n+                                    false, Annotations.ANNO_OP_STRIMZI_IO_MANUAL_ROLLING_UPDATE)) {\n+                                podsToRoll.add(pod.getMetadata().getName());\n+                            }\n+                        }\n+\n+                        if (!podsToRoll.isEmpty())  {\n+                            return maybeRollKafka(sts, pod -> {\n+                                if (pod != null && podsToRoll.contains(pod.getMetadata().getName())) {\n+                                    log.debug(\"{}: Rolling Kafka pod {} due to manual rolling update annotation on a pod\", reconciliation, pod.getMetadata().getName());\n+                                    return singletonList(\"manual rolling update annotation on a pod\");\n+                                } else {\n+                                    return null;\n+                                }\n+                            });\n+                        } else {\n+                            return Future.succeededFuture();\n+                        }\n+\n+                        /*Future<Void> podRoll = Future.succeededFuture();\n+\n+                        for (String podName : podsToRoll)   {\n+                            podRoll = podRoll.compose(ignore -> {\n+                                return maybeRollKafka(sts, pod -> {\n+                                    if (pod != null && podName.equals(pod.getMetadata().getName())) {\n+                                        log.debug(\"{}: Rolling Kafka pod {} due to manual rolling update annotation on a pod\", reconciliation, podName);\n+                                        return singletonList(\"manual rolling update annotation on a pod\");\n+                                    } else {\n+                                        return null;\n+                                    }\n+                                });\n+                            });\n+                        }\n+\n+                        return withVoid(podRoll);*/", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3NDU2Mw=="}, "originalCommit": {"oid": "97959eef75cf1f711018ac348b4d07d3e81ea4a7"}, "originalPosition": 52}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 826, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}