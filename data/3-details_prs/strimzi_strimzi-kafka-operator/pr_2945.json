{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzMDU4ODQw", "number": 2945, "title": "KafkaClusterRebalance CRD and rebalance operator", "bodyText": "Type of change\n\nEnhancement / new feature\n\nDescription\nThis PR adds the new KafkaClusterRebalancer custom resource and the related operator for handling it; it has it's own state machine to allow users to create a KCR asking for a rebalance proposal to Cruise Control and then actually executing it.\nThe KCR status is updated accordingly when the operator moves through the states machine.\nWe are still working on more ITs which will be available in a different PR.\nChecklist\nPlease go through this checklist and make sure all applicable tasks have been done\n\n Update/write design documentation in ./design\n Write tests\n Make sure all tests pass\n Update documentation\n Check RBAC rights for Kubernetes / OpenShift roles\n Try your changes from Pod inside your Kubernetes and OpenShift cluster, not just locally\n Reference relevant issue(s) and close them after merging\n Update CHANGELOG.md", "createdAt": "2020-05-04T16:37:02Z", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945", "merged": true, "mergeCommit": {"oid": "a647c3039f6de529698d154e2dfa335c40301fd3"}, "closed": true, "closedAt": "2020-05-12T16:07:37Z", "author": {"login": "ppatierno"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABceEWncAFqTQwNTI0MzI1MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcgkJ6UABqjMzMjc0NTM2MjI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MjQzMjUw", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#pullrequestreview-405243250", "createdAt": "2020-05-04T18:33:59Z", "commit": {"oid": "7f47772bd80f692d74c18bc37c1d2f8a312983b6"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxODozMzo1OVrOGQM9sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxOTowNjozN1rOGQOJig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MjgwMA==", "bodyText": "I find this a bit weird. Since the CR which deploys Kafka cluster is just Kafka, should this be just KafkaRebalance?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419642800", "createdAt": "2020-05-04T18:33:59Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaClusterRebalance.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\n+import io.fabric8.kubernetes.api.model.Doneable;\n+import io.fabric8.kubernetes.api.model.ObjectMeta;\n+import io.fabric8.kubernetes.client.CustomResource;\n+import io.strimzi.api.kafka.model.status.HasStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.crdgenerator.annotations.Crd;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import io.sundr.builder.annotations.Inline;\n+import lombok.EqualsAndHashCode;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+\n+@JsonDeserialize\n+@Crd(\n+        apiVersion = KafkaClusterRebalance.CRD_API_VERSION,\n+        spec = @Crd.Spec(\n+                names = @Crd.Spec.Names(\n+                        kind = KafkaClusterRebalance.RESOURCE_KIND,\n+                        plural = KafkaClusterRebalance.RESOURCE_PLURAL,\n+                        shortNames = {KafkaClusterRebalance.SHORT_NAME}\n+                ),\n+                group = KafkaClusterRebalance.RESOURCE_GROUP,\n+                scope = KafkaClusterRebalance.SCOPE,\n+                version = KafkaClusterRebalance.V1ALPHA1,\n+                versions = {\n+                        @Crd.Spec.Version(\n+                                name = KafkaClusterRebalance.V1ALPHA1,\n+                                served = true,\n+                                storage = true\n+                        )\n+                },\n+                subresources = @Crd.Spec.Subresources(\n+                        status = @Crd.Spec.Subresources.Status()\n+                )\n+        )\n+)\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\",\n+        inline = @Inline(type = Doneable.class, prefix = \"Doneable\", value = \"done\")\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"apiVersion\", \"kind\", \"metadata\", \"spec\"})\n+@EqualsAndHashCode\n+public class KafkaClusterRebalance extends CustomResource implements UnknownPropertyPreserving, HasStatus<KafkaClusterRebalanceStatus> {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String SCOPE = \"Namespaced\";\n+    public static final String V1ALPHA1 = \"v1alpha1\";\n+    public static final List<String> VERSIONS = unmodifiableList(asList(V1ALPHA1));\n+    public static final String RESOURCE_KIND = \"KafkaClusterRebalance\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f47772bd80f692d74c18bc37c1d2f8a312983b6"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MzY3NA==", "bodyText": "We don't seem to override toString in other APi classes. Why do we need it here?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419643674", "createdAt": "2020-05-04T18:35:34Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaClusterRebalanceSpec.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({ \"goals\", \"skipHardGoalCheck\" })\n+@EqualsAndHashCode\n+public class KafkaClusterRebalanceSpec implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private List<String> goals;\n+    private boolean skipHardGoalCheck;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"A list of goals, ordered by decreasing priority, to use for generating and executing the rebalance proposal.\" +\n+            \"The supported goals are available at https://github.com/linkedin/cruise-control#goals.\" +\n+            \"If an empty goals list is provided, the goals declared in the default.goals Cruise Control configuration parameter are used.\")\n+    public List<String> getGoals() {\n+        return goals;\n+    }\n+\n+    public void setGoals(List<String> goals) {\n+        this.goals = goals;\n+    }\n+\n+    @Description(\"Whether to allow hard goals to be skipped in rebalance proposal generation. Default is false.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public boolean isSkipHardGoalCheck() {\n+        return skipHardGoalCheck;\n+    }\n+\n+    public void setSkipHardGoalCheck(boolean skipHardGoalCheck) {\n+        this.skipHardGoalCheck = skipHardGoalCheck;\n+    }\n+\n+    @Override\n+    public Map<String, Object> getAdditionalProperties() {\n+        return this.additionalProperties;\n+    }\n+\n+    @Override\n+    public void setAdditionalProperty(String name, Object value) {\n+        this.additionalProperties.put(name, value);\n+    }\n+\n+    @Override\n+    public String toString() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f47772bd80f692d74c18bc37c1d2f8a312983b6"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NDI2NQ==", "bodyText": "Is this something the user can use in any way? My understanding was that we do not allow access to the CC API.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419644265", "createdAt": "2020-05-04T18:36:27Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/status/KafkaClusterRebalanceStatus.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.status;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+import lombok.ToString;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Represents a status of the Kafka Cluster Rebalance resource\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({ \"conditions\", \"observedGeneration\", \"sessionId\", \"optimizationResult\" })\n+@EqualsAndHashCode\n+@ToString(callSuper = true)\n+public class KafkaClusterRebalanceStatus extends Status {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private String sessionId;\n+    private Map<String, Object> optimizationResult = new HashMap<>(0);\n+\n+    @Description(\"A JSON describing the optimization result\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, Object> getOptimizationResult() {\n+        return optimizationResult;\n+    }\n+\n+    public void setOptimizationResult(Map<String, Object> optimizationResult) {\n+        this.optimizationResult = optimizationResult;\n+    }\n+\n+    @Description(\"The session identifier for requests to Cruise Control pertaining to this KafkaClusterRebalance resource.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f47772bd80f692d74c18bc37c1d2f8a312983b6"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NTAyNA==", "bodyText": "Can you explain what does this do anfwhy do we need it?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419645024", "createdAt": "2020-05-04T18:37:37Z", "author": {"login": "scholzj"}, "path": "cluster-operator/pom.xml", "diffHunk": "@@ -270,6 +298,12 @@\n                     <include>kafka-versions.yaml</include>\n                 </includes>\n             </resource>\n+            <resource>\n+                <directory>src/test/resources/io/strimzi/operator/cluster/operator/assembly/CruiseControlJSON</directory>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f47772bd80f692d74c18bc37c1d2f8a312983b6"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NjM1OQ==", "bodyText": "Could we have some comment what is this be used for?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419646359", "createdAt": "2020-05-04T18:39:50Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f47772bd80f692d74c18bc37c1d2f8a312983b6"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NzI1MA==", "bodyText": "This looks like asking for a trouble .get(0).getType() ... should it instead properly find the right type?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419647250", "createdAt": "2020-05-04T18:41:21Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f47772bd80f692d74c18bc37c1d2f8a312983b6"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1MjczMQ==", "bodyText": "I tink this would better fit into io.strimzi.operator.cluster.operator.resource.cruisecontrol", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419652731", "createdAt": "2020-05-04T18:50:50Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/cruisecontrol/CruiseControlApi.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly.cruisecontrol;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f47772bd80f692d74c18bc37c1d2f8a312983b6"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1NDQ4Mg==", "bodyText": "I think we should move here also the cruise control example from ../kafka", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419654482", "createdAt": "2020-05-04T18:53:52Z", "author": {"login": "scholzj"}, "path": "examples/kafka-rebalance/kafka-cluster-rebalance.yaml", "diffHunk": "@@ -0,0 +1,10 @@\n+apiVersion: kafka.strimzi.io/v1alpha1\n+kind: KafkaClusterRebalance\n+metadata:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f47772bd80f692d74c18bc37c1d2f8a312983b6"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1NjY4Mw==", "bodyText": "Shoult this be offloaded somethere to api? It looks like it would be better fit there.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419656683", "createdAt": "2020-05-04T18:57:31Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f47772bd80f692d74c18bc37c1d2f8a312983b6"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1Njc1MA==", "bodyText": "Shoult this be offloaded somethere to api? It looks like it would be better fit there.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419656750", "createdAt": "2020-05-04T18:57:37Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f47772bd80f692d74c18bc37c1d2f8a312983b6"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1OTgyOQ==", "bodyText": "It looks like you execute this logic here only when event is triggered. Maybe I missed something, but this looks wrong. You have your own reconcileAll loop and you need to test this everytime in the loop, or?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419659829", "createdAt": "2020-05-04T19:02:39Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f47772bd80f692d74c18bc37c1d2f8a312983b6"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY2MjIxOA==", "bodyText": "Some Javadocs would not hurt ... you have getRebalanceAnnotation, rebalanceAnnotation, hasRebalanceAnnotation` ... not exactly clear what the difference is between those.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r419662218", "createdAt": "2020-05-04T19:06:37Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance, State currentState,\n+                                                                  RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaClusterRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                                      String host, CruiseControlApi apiClient,\n+                                                      RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaClusterRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance,\n+                                                                  RebalanceAnnotation rebalanceAnnotation,\n+                                                                  RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"Optimization proposal ready\");\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"Waiting for optimization proposal to be ready\");\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"Cruise Control getting rebalance proposal failed\", rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"Cruise Control getting rebalance resource failed\", getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                                String host, CruiseControlApi apiClient,\n+                                                                KafkaClusterRebalance clusterRebalance,\n+                                                                RebalanceAnnotation rebalanceAnnotation,\n+                                                                RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+            default:\n+                log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Rebalancing} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n+     * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n+     * When the rebalance is finished, the next state is {@code Ready}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then move to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n+                                                              String host, CruiseControlApi apiClient,\n+                                                              KafkaClusterRebalance clusterRebalance,\n+                                                              RebalanceAnnotation rebalanceAnnotation) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+            String sessionId = clusterRebalance.getStatus().getSessionId();\n+            AtomicInteger ccAPIErrorCount = new AtomicInteger();\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                // Check that we have not already failed to contact the API beyond the allowed number of times.\n+                if (ccAPIErrorCount.get() >= MAX_API_RETRIES) {\n+                    vertx.cancelTimer(t);\n+                    p.fail(new RuntimeException(\"Unable to reach Cruise Control API after \" + MAX_API_RETRIES + \" attempts\"));\n+                }\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                        // and the previous execution set the status and completed the future\n+                        if (state(freshClusterRebalance) == State.Rebalancing) {\n+                            if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                log.debug(\"{}: Stopping current Cruise Control rebalance user task\", reconciliation);\n+                                vertx.cancelTimer(t);\n+                                apiClient.stopExecution(host, CruiseControl.REST_API_PORT).setHandler(stopResult -> {\n+                                    if (stopResult.succeeded()) {\n+                                        p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                .withSessionId(null)\n+                                                .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                    } else {\n+                                        log.error(\"Cruise Control stopping execution failed\", stopResult.cause());\n+                                        p.fail(stopResult.cause());\n+                                    }\n+                                });\n+                            } else {\n+                                log.info(\"{}: Getting Cruise Control rebalance user task status\", reconciliation);\n+                                // TODO: If this request results in multiple errors from the server then the Rebalance state\n+                                //       will switch to NotReady -> ProposalPending -> ProposalReady even though we are in\n+                                //       an ongoing rebalance. We may need to add an Error state to the state machine.\n+                                apiClient.getUserTaskStatus(host, CruiseControl.REST_API_PORT, sessionId).setHandler(userTaskResult -> {\n+                                    if (userTaskResult.succeeded()) {\n+                                        CruiseControlResponse response = userTaskResult.result();\n+                                        JsonObject taskStatusJson = response.getJson();\n+                                        String taskStatusStr = taskStatusJson.getString(\"Status\");\n+                                        CruiseControlUserTaskStatus taskStatus = CruiseControlUserTaskStatus.lookup(taskStatusStr);\n+                                        switch (taskStatus) {\n+                                            case COMPLETED:\n+                                                vertx.cancelTimer(t);\n+                                                log.info(\"Rebalance ({}) is now complete\", sessionId);\n+                                                p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                        .withSessionId(null)\n+                                                        .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                        .addNewCondition().withType(State.Ready.toString()).endCondition().build());\n+                                                break;\n+                                            case COMPLETED_WITH_ERROR:\n+                                                // TODO: There doesn't seem to be a way to retrieve the actual error message from the user tasks endpoint?\n+                                                //       We may need to propose an upstream PR for this.\n+                                                // TODO: Once we can get the error details we need to add an error field to the Rebalance Status to hold\n+                                                //       details of any issues while rebalancing.\n+                                                log.error(\"Rebalance ({}) optimization proposal has failed to complete\", sessionId);\n+                                                vertx.cancelTimer(t);\n+                                                p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                        .withSessionId(sessionId)\n+                                                        .addNewCondition().withType(State.NotReady.toString()).endCondition().build());\n+                                                break;\n+                                            case IN_EXECUTION: // Rebalance is still in progress\n+                                                // We need to check that the status has been updated with the ongoing optimisation proposal\n+                                                // The proposal field can be empty if a rebalance(dryrun=false) was called and the optimisation\n+                                                // proposal was still being prepared (in progress). In that case the rebalance will start when\n+                                                // the proposal is complete but the optimisation proposal summary will be missing.\n+                                                if (freshClusterRebalance.getStatus().getOptimizationResult() == null ||\n+                                                        freshClusterRebalance.getStatus().getOptimizationResult().isEmpty()) {\n+                                                    log.info(\"Rebalance ({}) optimization proposal is now ready and has been added to the status\", sessionId);\n+                                                    // Cancel the timer so that the status is returned and updated.\n+                                                    vertx.cancelTimer(t);\n+                                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                            .withSessionId(sessionId)\n+                                                            .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                            .addNewCondition().withType(State.Rebalancing.toString()).endCondition().build());\n+                                                }\n+                                                ccAPIErrorCount.set(0);\n+                                                // TODO: Find out if there is any way to check the progress of a rebalance.\n+                                                //       We could parse the verbose proposal for total number of reassignments and compare to number completed (if available)?\n+                                                //       We can then update the status at this point.\n+                                                break;\n+                                            case ACTIVE: // Rebalance proposal is still being calculated\n+                                                // If a rebalance(dryrun=false) was called and the proposal is still being prepared then the task\n+                                                // will be in an ACTIVE state. When the proposal is ready it will shift to IN_EXECUTION and we will\n+                                                // check that the optimisation proposal is added to the status on the next reconcile.\n+                                                log.info(\"Rebalance ({}) optimization proposal is still being prepared\", sessionId);\n+                                                ccAPIErrorCount.set(0);\n+                                                break;\n+                                            default:\n+                                                log.error(\"Unexpected state {}\", taskStatus);\n+                                                vertx.cancelTimer(t);\n+                                                p.fail(\"Unexpected state \" + taskStatus);\n+                                                break;\n+                                        }\n+                                    } else {\n+                                        log.error(\"Cruise Control getting rebalance task status failed\", userTaskResult.cause());\n+                                        // To make sure this error is not just a temporary problem with the network we retry several times.\n+                                        // If the number of errors pass the MAX_API_ERRORS limit then the period method will fail the promise.\n+                                        ccAPIErrorCount.getAndIncrement();\n+                                    }\n+                                });\n+                            }\n+                        } else {\n+                            p.complete(freshClusterRebalance.getStatus());\n+                        }\n+                    } else {\n+                        log.error(\"Cruise Control getting rebalance resource failed\", getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Stopped} state.\n+     * If the user set strimzi.io/rebalance=refresh annotation, it calls the Cruise Control API for requesting a new rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onStop(Reconciliation reconciliation,\n+                                                       String host, CruiseControlApi apiClient,\n+                                                       RebalanceAnnotation rebalanceAnnotation,\n+                                                       RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+        } else {\n+            log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+            return Future.succeededFuture(new KafkaClusterRebalanceStatusBuilder()\n+                    .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+        }\n+    }\n+\n+    private Future<Void> reconcileClusterRebalance(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance) {\n+        if (clusterRebalance == null) {\n+            log.info(\"{}: rebalance resource deleted\", reconciliation);\n+            return Future.succeededFuture();\n+        } else {\n+            return clusterRebalanceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName())\n+                    .compose(fetchedClusterRebalance -> {\n+                        KafkaClusterRebalanceStatus clusterRebalanceStatus = fetchedClusterRebalance.getStatus();\n+                        // cluster rebalance is new or it is in one of others states\n+                        State currentState = clusterRebalanceStatus == null ? State.New :\n+                                State.valueOf(clusterRebalanceStatus.getConditions().get(0).getType());\n+                        // check annotation\n+                        RebalanceAnnotation rebalanceAnnotation = getRebalanceAnnotation(fetchedClusterRebalance);\n+                        return reconcile(reconciliation, host, apiClient, fetchedClusterRebalance, currentState, rebalanceAnnotation).mapEmpty();\n+                    }, exception -> Future.failedFuture(exception).mapEmpty());\n+        }\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> requestRebalance(Reconciliation reconciliation,\n+                                                                 String host, CruiseControlApi apiClient,\n+                                                                 boolean dryrun, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, dryrun, rebalanceOptionsBuilder, null);\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> requestRebalance(Reconciliation reconciliation, String host, CruiseControlApi apiClient,\n+        boolean dryrun, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder, String userTaskID) {\n+\n+        log.info(\"{}: Requesting Cruise Control rebalance [dryrun={}]\", reconciliation, dryrun);\n+        if (!dryrun) {\n+            rebalanceOptionsBuilder.withFullRun();\n+        }\n+        return apiClient.rebalance(host, CruiseControl.REST_API_PORT, rebalanceOptionsBuilder.build(), userTaskID)\n+                .map(response -> {\n+                    if (dryrun) {\n+                        if (response.thereIsNotEnoughDataForProposal() || response.proposalIsStillCalculating()) {\n+                            // If either there not enough data for a rebalance or it is still being processed we need to\n+                            // re-request the proposal at a later stage so we move to the PendingProposal State.\n+                            return new KafkaClusterRebalanceStatusBuilder()\n+                                    .withNewSessionId(response.getUserTaskId())\n+                                    .addNewCondition().withNewType(State.PendingProposal.toString()).endCondition().build();\n+                        }\n+                    } else {\n+                        if (response.thereIsNotEnoughDataForProposal()) {\n+                            // We do not include a session id with this status as we do not want to retrieve the state of\n+                            // this failed tasks (COMPLETED_WITH_ERROR)\n+                            return new KafkaClusterRebalanceStatusBuilder()\n+                                    .addNewCondition().withNewType(State.PendingProposal.toString()).endCondition().build();\n+                        } else if (response.proposalIsStillCalculating()) {\n+                            return new KafkaClusterRebalanceStatusBuilder()\n+                                    .withNewSessionId(response.getUserTaskId())\n+                                    .addNewCondition().withNewType(State.Rebalancing.toString()).endCondition().build();\n+                        }\n+                    }\n+\n+                    if (response.getJson().containsKey(CC_REST_API_SUMMARY)) {\n+                        // If there is enough data and the proposal is complete (the response has the \"summary\" key) then we move\n+                        // to ProposalReady for a dry run or to the Rebalancing state for a full run\n+                        State ready = dryrun ? State.ProposalReady : State.Rebalancing;\n+                        return new KafkaClusterRebalanceStatusBuilder()\n+                                .withOptimizationResult(response.getJson().getJsonObject(CC_REST_API_SUMMARY).getMap())\n+                                .addNewCondition().withNewType(ready.toString()).endCondition().build();\n+                    } else {\n+                        throw new RuntimeException(\"Rebalance returned unknown response: \" + response.toString());\n+                    }\n+                }).otherwise(t -> {\n+                    throw new RuntimeException(t.getMessage());\n+                });\n+    }\n+\n+    private RebalanceAnnotation getRebalanceAnnotation(KafkaClusterRebalance clusterRebalance) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f47772bd80f692d74c18bc37c1d2f8a312983b6"}, "originalPosition": 761}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NjU4Nzkx", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#pullrequestreview-405658791", "createdAt": "2020-05-05T10:18:15Z", "commit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "state": "COMMENTED", "comments": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMDoxODoxNVrOGQjCNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMToxNzozMlrOGQk06Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNDQwNA==", "bodyText": "Given the issue we've just had for Kafka Connect where we were passing back some json from its API which had a different ordering between reconciliations, how do we know this doesn't have the same issue?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420004404", "createdAt": "2020-05-05T10:18:15Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/status/KafkaClusterRebalanceStatus.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.status;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+import lombok.ToString;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Represents a status of the Kafka Cluster Rebalance resource\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({ \"conditions\", \"observedGeneration\", \"sessionId\", \"optimizationResult\" })\n+@EqualsAndHashCode\n+@ToString(callSuper = true)\n+public class KafkaClusterRebalanceStatus extends Status {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private String sessionId;\n+    private Map<String, Object> optimizationResult = new HashMap<>(0);\n+\n+    @Description(\"A JSON describing the optimization result\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, Object> getOptimizationResult() {\n+        return optimizationResult;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNjE1MQ==", "bodyText": "But this will add those test resources to the final artifact. Presumably you only need those resources when testing?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420006151", "createdAt": "2020-05-05T10:21:38Z", "author": {"login": "tombentley"}, "path": "cluster-operator/pom.xml", "diffHunk": "@@ -270,6 +298,12 @@\n                     <include>kafka-versions.yaml</include>\n                 </includes>\n             </resource>\n+            <resource>\n+                <directory>src/test/resources/io/strimzi/operator/cluster/operator/assembly/CruiseControlJSON</directory>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NTAyNA=="}, "originalCommit": {"oid": "7f47772bd80f692d74c18bc37c1d2f8a312983b6"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNzMwOA==", "bodyText": "Does this comment belong here? I don't understand how it does, when this bit of code is now about anomaly goals.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420007308", "createdAt": "2020-05-05T10:24:01Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -227,16 +237,64 @@ public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup ver\n     }\n \n     public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n-        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n-        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n-            if (configuration.getConfigOption(entry.getKey()) == null) {\n-                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+        CruiseControlConfiguration userConfiguration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> defaultEntry : userConfiguration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (userConfiguration.getConfigOption(defaultEntry.getKey()) == null) {\n+                userConfiguration.setConfigOption(defaultEntry.getKey(), defaultEntry.getValue());\n             }\n         }\n-        cruiseControl.setConfiguration(configuration);\n+        // Ensure that the configured anomaly.detection.goals are a sub-set of the default goals\n+        checkGoals(userConfiguration);\n+        cruiseControl.setConfiguration(userConfiguration);\n         return cruiseControl;\n     }\n \n+    /**\n+     *  This method ensures that the checks in cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java\n+     *  sanityCheckGoalNames() method (L118)  don't fail if a user submits custom default goals that have less members then the default\n+     *  anomaly.detection.goals.\n+     * @param configuration The configuration instance to be checked.\n+     * @throws UnsupportedOperationException If the configuration contains self.healing.goals configurations.\n+     */\n+    public static void checkGoals(CruiseControlConfiguration configuration) {\n+        // If self healing goals are defined then these take precedence\n+        if (configuration.getConfigOption(CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY) != null) {\n+            String selfHealingGoalsString = configuration.getConfigOption(CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY);\n+            List<String> selfHealingGoals = Arrays.asList(selfHealingGoalsString.split(\"\\\\s*,\\\\s*\"));\n+            if (!selfHealingGoals.isEmpty()) {\n+                throw new UnsupportedOperationException(\"Cruise Control's self healing functionality is not currently supported. Please remove \" +\n+                        CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY + \" config\");\n+            }\n+        }\n+\n+        // Either self.healing.goals is null or it is an empty list", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNzg4Ng==", "bodyText": "getConfigOption can take a 2nd argument which provides a default.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420007886", "createdAt": "2020-05-05T10:25:13Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -227,16 +237,64 @@ public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup ver\n     }\n \n     public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n-        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n-        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n-            if (configuration.getConfigOption(entry.getKey()) == null) {\n-                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+        CruiseControlConfiguration userConfiguration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> defaultEntry : userConfiguration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (userConfiguration.getConfigOption(defaultEntry.getKey()) == null) {\n+                userConfiguration.setConfigOption(defaultEntry.getKey(), defaultEntry.getValue());\n             }\n         }\n-        cruiseControl.setConfiguration(configuration);\n+        // Ensure that the configured anomaly.detection.goals are a sub-set of the default goals\n+        checkGoals(userConfiguration);\n+        cruiseControl.setConfiguration(userConfiguration);\n         return cruiseControl;\n     }\n \n+    /**\n+     *  This method ensures that the checks in cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java\n+     *  sanityCheckGoalNames() method (L118)  don't fail if a user submits custom default goals that have less members then the default\n+     *  anomaly.detection.goals.\n+     * @param configuration The configuration instance to be checked.\n+     * @throws UnsupportedOperationException If the configuration contains self.healing.goals configurations.\n+     */\n+    public static void checkGoals(CruiseControlConfiguration configuration) {\n+        // If self healing goals are defined then these take precedence\n+        if (configuration.getConfigOption(CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY) != null) {\n+            String selfHealingGoalsString = configuration.getConfigOption(CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY);\n+            List<String> selfHealingGoals = Arrays.asList(selfHealingGoalsString.split(\"\\\\s*,\\\\s*\"));\n+            if (!selfHealingGoals.isEmpty()) {\n+                throw new UnsupportedOperationException(\"Cruise Control's self healing functionality is not currently supported. Please remove \" +\n+                        CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY + \" config\");\n+            }\n+        }\n+\n+        // Either self.healing.goals is null or it is an empty list\n+        String anomalyGoalsString;\n+        if (configuration.getConfigOption(CRUISE_CONTROL_ANOMALY_DETECTION_CONFIG_KEY) != null) {\n+            // The user has defined some anomaly detection goals\n+            anomalyGoalsString = configuration.getConfigOption(CRUISE_CONTROL_ANOMALY_DETECTION_CONFIG_KEY);\n+        } else {\n+            // No anomaly detection goals have been defined by the user, therefore the defaults defined in Cruise Control\n+            // will be used.\n+            anomalyGoalsString = CRUISE_CONTROL_DEFAULT_ANOMALY_DETECTION_GOALS;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwODEyMQ==", "bodyText": "How do you know defaultGoalsString is not null?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420008121", "createdAt": "2020-05-05T10:25:40Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -227,16 +237,64 @@ public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup ver\n     }\n \n     public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n-        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n-        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n-            if (configuration.getConfigOption(entry.getKey()) == null) {\n-                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+        CruiseControlConfiguration userConfiguration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> defaultEntry : userConfiguration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (userConfiguration.getConfigOption(defaultEntry.getKey()) == null) {\n+                userConfiguration.setConfigOption(defaultEntry.getKey(), defaultEntry.getValue());\n             }\n         }\n-        cruiseControl.setConfiguration(configuration);\n+        // Ensure that the configured anomaly.detection.goals are a sub-set of the default goals\n+        checkGoals(userConfiguration);\n+        cruiseControl.setConfiguration(userConfiguration);\n         return cruiseControl;\n     }\n \n+    /**\n+     *  This method ensures that the checks in cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java\n+     *  sanityCheckGoalNames() method (L118)  don't fail if a user submits custom default goals that have less members then the default\n+     *  anomaly.detection.goals.\n+     * @param configuration The configuration instance to be checked.\n+     * @throws UnsupportedOperationException If the configuration contains self.healing.goals configurations.\n+     */\n+    public static void checkGoals(CruiseControlConfiguration configuration) {\n+        // If self healing goals are defined then these take precedence\n+        if (configuration.getConfigOption(CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY) != null) {\n+            String selfHealingGoalsString = configuration.getConfigOption(CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY);\n+            List<String> selfHealingGoals = Arrays.asList(selfHealingGoalsString.split(\"\\\\s*,\\\\s*\"));\n+            if (!selfHealingGoals.isEmpty()) {\n+                throw new UnsupportedOperationException(\"Cruise Control's self healing functionality is not currently supported. Please remove \" +\n+                        CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY + \" config\");\n+            }\n+        }\n+\n+        // Either self.healing.goals is null or it is an empty list\n+        String anomalyGoalsString;\n+        if (configuration.getConfigOption(CRUISE_CONTROL_ANOMALY_DETECTION_CONFIG_KEY) != null) {\n+            // The user has defined some anomaly detection goals\n+            anomalyGoalsString = configuration.getConfigOption(CRUISE_CONTROL_ANOMALY_DETECTION_CONFIG_KEY);\n+        } else {\n+            // No anomaly detection goals have been defined by the user, therefore the defaults defined in Cruise Control\n+            // will be used.\n+            anomalyGoalsString = CRUISE_CONTROL_DEFAULT_ANOMALY_DETECTION_GOALS;\n+        }\n+\n+        Set<String> anomalyDetectionGoals = new HashSet<>(Arrays.asList(anomalyGoalsString.split(\"\\\\s*,\\\\s*\")));\n+\n+        String defaultGoalsString = configuration.getConfigOption(CRUISE_CONTROL_DEFAULT_GOALS_CONFIG_KEY);\n+        Set<String> defaultGoals = new HashSet<>(Arrays.asList(defaultGoalsString.split(\"\\\\s*,\\\\s*\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwOTMyNg==", "bodyText": "The user can override goals and default.goals, so why is GOALS a better name?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420009326", "createdAt": "2020-05-05T10:28:06Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControlConfiguration.java", "diffHunk": "@@ -23,7 +23,7 @@\n      * A list of case insensitive goals that Cruise Control supports in the order of priority.\n      * The high priority goals will be executed first.\n      */\n-    private static final String DEFAULT_GOALS = \"com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\" +\n+    private static final String GOALS = \"com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAxMTEyMA==", "bodyText": "Probably these status updates should also execute within withLock().", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420011120", "createdAt": "2020-05-05T10:31:36Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAxMTUxMg==", "bodyText": "If its public we should probably add some Javadoc.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420011512", "createdAt": "2020-05-05T10:32:22Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAxMjk2Mw==", "bodyText": "I think I disagree. If we put this in api then there would be the reasonable expectation that the current enum values are exhaustive, which would mean we couldn't add a new value (should we need to) without breaking compatibility. If this is just a String from the PoV of the public API then there isn't (or shouldn't be) that expectation.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420012963", "createdAt": "2020-05-05T10:35:15Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1NjY4Mw=="}, "originalCommit": {"oid": "7f47772bd80f692d74c18bc37c1d2f8a312983b6"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAxNTE5NQ==", "bodyText": "I think we need a bit more detail here about how this operator works (e.g. mention that we're using a state machine and give an example flow).", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420015195", "createdAt": "2020-05-05T10:39:51Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAxNjQ3Nw==", "bodyText": "It's weird that the one method has no get prefix in the name, but the other has a get prefix. Can we make the consistent (preferably without the get prefix, since it's not a getter).", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420016477", "createdAt": "2020-05-05T10:42:11Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance, State currentState,\n+                                                                  RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaClusterRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                                      String host, CruiseControlApi apiClient,\n+                                                      RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaClusterRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance,\n+                                                                  RebalanceAnnotation rebalanceAnnotation,\n+                                                                  RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 440}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAxNjg5NQ==", "bodyText": "Include the reconciliation in all these debugging stmts.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420016895", "createdAt": "2020-05-05T10:43:00Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance, State currentState,\n+                                                                  RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaClusterRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                                      String host, CruiseControlApi apiClient,\n+                                                      RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaClusterRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance,\n+                                                                  RebalanceAnnotation rebalanceAnnotation,\n+                                                                  RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"Optimization proposal ready\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 455}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyMDg3MA==", "bodyText": "Note that this will result in a Future<KafkaClusterRebalanceStatus> with a null result. Is updateStatus() etc null-safe?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420020870", "createdAt": "2020-05-05T10:50:33Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance, State currentState,\n+                                                                  RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaClusterRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                                      String host, CruiseControlApi apiClient,\n+                                                      RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaClusterRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance,\n+                                                                  RebalanceAnnotation rebalanceAnnotation,\n+                                                                  RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"Optimization proposal ready\");\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"Waiting for optimization proposal to be ready\");\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"Cruise Control getting rebalance proposal failed\", rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 474}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyMjA3NA==", "bodyText": "I wonder if this is really the best exception type for this. It feels like we ought to have a common one used whenever an operator cannot connect to a managed resource. It could be used for the Kafka Connect stuff, and the Kafka Admin client connections too.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420022074", "createdAt": "2020-05-05T10:53:05Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance, State currentState,\n+                                                                  RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaClusterRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                                      String host, CruiseControlApi apiClient,\n+                                                      RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaClusterRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance,\n+                                                                  RebalanceAnnotation rebalanceAnnotation,\n+                                                                  RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"Optimization proposal ready\");\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"Waiting for optimization proposal to be ready\");\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"Cruise Control getting rebalance proposal failed\", rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"Cruise Control getting rebalance resource failed\", getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                                String host, CruiseControlApi apiClient,\n+                                                                KafkaClusterRebalance clusterRebalance,\n+                                                                RebalanceAnnotation rebalanceAnnotation,\n+                                                                RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+            default:\n+                log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Rebalancing} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n+     * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n+     * When the rebalance is finished, the next state is {@code Ready}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then move to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n+                                                              String host, CruiseControlApi apiClient,\n+                                                              KafkaClusterRebalance clusterRebalance,\n+                                                              RebalanceAnnotation rebalanceAnnotation) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+            String sessionId = clusterRebalance.getStatus().getSessionId();\n+            AtomicInteger ccAPIErrorCount = new AtomicInteger();\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                // Check that we have not already failed to contact the API beyond the allowed number of times.\n+                if (ccAPIErrorCount.get() >= MAX_API_RETRIES) {\n+                    vertx.cancelTimer(t);\n+                    p.fail(new RuntimeException(\"Unable to reach Cruise Control API after \" + MAX_API_RETRIES + \" attempts\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 555}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyMzQxMg==", "bodyText": "Is this still a TODO? Do we need to fix it?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420023412", "createdAt": "2020-05-05T10:55:46Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance, State currentState,\n+                                                                  RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaClusterRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                                      String host, CruiseControlApi apiClient,\n+                                                      RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaClusterRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance,\n+                                                                  RebalanceAnnotation rebalanceAnnotation,\n+                                                                  RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"Optimization proposal ready\");\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"Waiting for optimization proposal to be ready\");\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"Cruise Control getting rebalance proposal failed\", rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"Cruise Control getting rebalance resource failed\", getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                                String host, CruiseControlApi apiClient,\n+                                                                KafkaClusterRebalance clusterRebalance,\n+                                                                RebalanceAnnotation rebalanceAnnotation,\n+                                                                RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+            default:\n+                log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Rebalancing} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n+     * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n+     * When the rebalance is finished, the next state is {@code Ready}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then move to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n+                                                              String host, CruiseControlApi apiClient,\n+                                                              KafkaClusterRebalance clusterRebalance,\n+                                                              RebalanceAnnotation rebalanceAnnotation) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+            String sessionId = clusterRebalance.getStatus().getSessionId();\n+            AtomicInteger ccAPIErrorCount = new AtomicInteger();\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                // Check that we have not already failed to contact the API beyond the allowed number of times.\n+                if (ccAPIErrorCount.get() >= MAX_API_RETRIES) {\n+                    vertx.cancelTimer(t);\n+                    p.fail(new RuntimeException(\"Unable to reach Cruise Control API after \" + MAX_API_RETRIES + \" attempts\"));\n+                }\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                        // and the previous execution set the status and completed the future\n+                        if (state(freshClusterRebalance) == State.Rebalancing) {\n+                            if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                log.debug(\"{}: Stopping current Cruise Control rebalance user task\", reconciliation);\n+                                vertx.cancelTimer(t);\n+                                apiClient.stopExecution(host, CruiseControl.REST_API_PORT).setHandler(stopResult -> {\n+                                    if (stopResult.succeeded()) {\n+                                        p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                .withSessionId(null)\n+                                                .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                    } else {\n+                                        log.error(\"Cruise Control stopping execution failed\", stopResult.cause());\n+                                        p.fail(stopResult.cause());\n+                                    }\n+                                });\n+                            } else {\n+                                log.info(\"{}: Getting Cruise Control rebalance user task status\", reconciliation);\n+                                // TODO: If this request results in multiple errors from the server then the Rebalance state\n+                                //       will switch to NotReady -> ProposalPending -> ProposalReady even though we are in\n+                                //       an ongoing rebalance. We may need to add an Error state to the state machine.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 580}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyNDQzNQ==", "bodyText": "I think this deserves a comment.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420024435", "createdAt": "2020-05-05T10:57:52Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance, State currentState,\n+                                                                  RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaClusterRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                                      String host, CruiseControlApi apiClient,\n+                                                      RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaClusterRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance,\n+                                                                  RebalanceAnnotation rebalanceAnnotation,\n+                                                                  RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"Optimization proposal ready\");\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"Waiting for optimization proposal to be ready\");\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"Cruise Control getting rebalance proposal failed\", rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"Cruise Control getting rebalance resource failed\", getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                                String host, CruiseControlApi apiClient,\n+                                                                KafkaClusterRebalance clusterRebalance,\n+                                                                RebalanceAnnotation rebalanceAnnotation,\n+                                                                RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+            default:\n+                log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Rebalancing} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n+     * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n+     * When the rebalance is finished, the next state is {@code Ready}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then move to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n+                                                              String host, CruiseControlApi apiClient,\n+                                                              KafkaClusterRebalance clusterRebalance,\n+                                                              RebalanceAnnotation rebalanceAnnotation) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+            String sessionId = clusterRebalance.getStatus().getSessionId();\n+            AtomicInteger ccAPIErrorCount = new AtomicInteger();\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                // Check that we have not already failed to contact the API beyond the allowed number of times.\n+                if (ccAPIErrorCount.get() >= MAX_API_RETRIES) {\n+                    vertx.cancelTimer(t);\n+                    p.fail(new RuntimeException(\"Unable to reach Cruise Control API after \" + MAX_API_RETRIES + \" attempts\"));\n+                }\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                        // and the previous execution set the status and completed the future\n+                        if (state(freshClusterRebalance) == State.Rebalancing) {\n+                            if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                log.debug(\"{}: Stopping current Cruise Control rebalance user task\", reconciliation);\n+                                vertx.cancelTimer(t);\n+                                apiClient.stopExecution(host, CruiseControl.REST_API_PORT).setHandler(stopResult -> {\n+                                    if (stopResult.succeeded()) {\n+                                        p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                .withSessionId(null)\n+                                                .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                    } else {\n+                                        log.error(\"Cruise Control stopping execution failed\", stopResult.cause());\n+                                        p.fail(stopResult.cause());\n+                                    }\n+                                });\n+                            } else {\n+                                log.info(\"{}: Getting Cruise Control rebalance user task status\", reconciliation);\n+                                // TODO: If this request results in multiple errors from the server then the Rebalance state\n+                                //       will switch to NotReady -> ProposalPending -> ProposalReady even though we are in\n+                                //       an ongoing rebalance. We may need to add an Error state to the state machine.\n+                                apiClient.getUserTaskStatus(host, CruiseControl.REST_API_PORT, sessionId).setHandler(userTaskResult -> {\n+                                    if (userTaskResult.succeeded()) {\n+                                        CruiseControlResponse response = userTaskResult.result();\n+                                        JsonObject taskStatusJson = response.getJson();\n+                                        String taskStatusStr = taskStatusJson.getString(\"Status\");\n+                                        CruiseControlUserTaskStatus taskStatus = CruiseControlUserTaskStatus.lookup(taskStatusStr);\n+                                        switch (taskStatus) {\n+                                            case COMPLETED:\n+                                                vertx.cancelTimer(t);\n+                                                log.info(\"Rebalance ({}) is now complete\", sessionId);\n+                                                p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                        .withSessionId(null)\n+                                                        .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                        .addNewCondition().withType(State.Ready.toString()).endCondition().build());\n+                                                break;\n+                                            case COMPLETED_WITH_ERROR:\n+                                                // TODO: There doesn't seem to be a way to retrieve the actual error message from the user tasks endpoint?\n+                                                //       We may need to propose an upstream PR for this.\n+                                                // TODO: Once we can get the error details we need to add an error field to the Rebalance Status to hold\n+                                                //       details of any issues while rebalancing.\n+                                                log.error(\"Rebalance ({}) optimization proposal has failed to complete\", sessionId);\n+                                                vertx.cancelTimer(t);\n+                                                p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                        .withSessionId(sessionId)\n+                                                        .addNewCondition().withType(State.NotReady.toString()).endCondition().build());\n+                                                break;\n+                                            case IN_EXECUTION: // Rebalance is still in progress\n+                                                // We need to check that the status has been updated with the ongoing optimisation proposal\n+                                                // The proposal field can be empty if a rebalance(dryrun=false) was called and the optimisation\n+                                                // proposal was still being prepared (in progress). In that case the rebalance will start when\n+                                                // the proposal is complete but the optimisation proposal summary will be missing.\n+                                                if (freshClusterRebalance.getStatus().getOptimizationResult() == null ||\n+                                                        freshClusterRebalance.getStatus().getOptimizationResult().isEmpty()) {\n+                                                    log.info(\"Rebalance ({}) optimization proposal is now ready and has been added to the status\", sessionId);\n+                                                    // Cancel the timer so that the status is returned and updated.\n+                                                    vertx.cancelTimer(t);\n+                                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                            .withSessionId(sessionId)\n+                                                            .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                            .addNewCondition().withType(State.Rebalancing.toString()).endCondition().build());\n+                                                }\n+                                                ccAPIErrorCount.set(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 622}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyNDg5NA==", "bodyText": "Again the logging in this method should include the reconciliation, right?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420024894", "createdAt": "2020-05-05T10:58:49Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance, State currentState,\n+                                                                  RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaClusterRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                                      String host, CruiseControlApi apiClient,\n+                                                      RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaClusterRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance,\n+                                                                  RebalanceAnnotation rebalanceAnnotation,\n+                                                                  RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"Optimization proposal ready\");\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"Waiting for optimization proposal to be ready\");\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"Cruise Control getting rebalance proposal failed\", rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"Cruise Control getting rebalance resource failed\", getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                                String host, CruiseControlApi apiClient,\n+                                                                KafkaClusterRebalance clusterRebalance,\n+                                                                RebalanceAnnotation rebalanceAnnotation,\n+                                                                RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+            default:\n+                log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Rebalancing} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n+     * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n+     * When the rebalance is finished, the next state is {@code Ready}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then move to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n+                                                              String host, CruiseControlApi apiClient,\n+                                                              KafkaClusterRebalance clusterRebalance,\n+                                                              RebalanceAnnotation rebalanceAnnotation) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+            String sessionId = clusterRebalance.getStatus().getSessionId();\n+            AtomicInteger ccAPIErrorCount = new AtomicInteger();\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                // Check that we have not already failed to contact the API beyond the allowed number of times.\n+                if (ccAPIErrorCount.get() >= MAX_API_RETRIES) {\n+                    vertx.cancelTimer(t);\n+                    p.fail(new RuntimeException(\"Unable to reach Cruise Control API after \" + MAX_API_RETRIES + \" attempts\"));\n+                }\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                        // and the previous execution set the status and completed the future\n+                        if (state(freshClusterRebalance) == State.Rebalancing) {\n+                            if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                log.debug(\"{}: Stopping current Cruise Control rebalance user task\", reconciliation);\n+                                vertx.cancelTimer(t);\n+                                apiClient.stopExecution(host, CruiseControl.REST_API_PORT).setHandler(stopResult -> {\n+                                    if (stopResult.succeeded()) {\n+                                        p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                .withSessionId(null)\n+                                                .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                    } else {\n+                                        log.error(\"Cruise Control stopping execution failed\", stopResult.cause());\n+                                        p.fail(stopResult.cause());\n+                                    }\n+                                });\n+                            } else {\n+                                log.info(\"{}: Getting Cruise Control rebalance user task status\", reconciliation);\n+                                // TODO: If this request results in multiple errors from the server then the Rebalance state\n+                                //       will switch to NotReady -> ProposalPending -> ProposalReady even though we are in\n+                                //       an ongoing rebalance. We may need to add an Error state to the state machine.\n+                                apiClient.getUserTaskStatus(host, CruiseControl.REST_API_PORT, sessionId).setHandler(userTaskResult -> {\n+                                    if (userTaskResult.succeeded()) {\n+                                        CruiseControlResponse response = userTaskResult.result();\n+                                        JsonObject taskStatusJson = response.getJson();\n+                                        String taskStatusStr = taskStatusJson.getString(\"Status\");\n+                                        CruiseControlUserTaskStatus taskStatus = CruiseControlUserTaskStatus.lookup(taskStatusStr);\n+                                        switch (taskStatus) {\n+                                            case COMPLETED:\n+                                                vertx.cancelTimer(t);\n+                                                log.info(\"Rebalance ({}) is now complete\", sessionId);\n+                                                p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                        .withSessionId(null)\n+                                                        .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                        .addNewCondition().withType(State.Ready.toString()).endCondition().build());\n+                                                break;\n+                                            case COMPLETED_WITH_ERROR:\n+                                                // TODO: There doesn't seem to be a way to retrieve the actual error message from the user tasks endpoint?\n+                                                //       We may need to propose an upstream PR for this.\n+                                                // TODO: Once we can get the error details we need to add an error field to the Rebalance Status to hold\n+                                                //       details of any issues while rebalancing.\n+                                                log.error(\"Rebalance ({}) optimization proposal has failed to complete\", sessionId);\n+                                                vertx.cancelTimer(t);\n+                                                p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                        .withSessionId(sessionId)\n+                                                        .addNewCondition().withType(State.NotReady.toString()).endCondition().build());\n+                                                break;\n+                                            case IN_EXECUTION: // Rebalance is still in progress\n+                                                // We need to check that the status has been updated with the ongoing optimisation proposal\n+                                                // The proposal field can be empty if a rebalance(dryrun=false) was called and the optimisation\n+                                                // proposal was still being prepared (in progress). In that case the rebalance will start when\n+                                                // the proposal is complete but the optimisation proposal summary will be missing.\n+                                                if (freshClusterRebalance.getStatus().getOptimizationResult() == null ||\n+                                                        freshClusterRebalance.getStatus().getOptimizationResult().isEmpty()) {\n+                                                    log.info(\"Rebalance ({}) optimization proposal is now ready and has been added to the status\", sessionId);\n+                                                    // Cancel the timer so that the status is returned and updated.\n+                                                    vertx.cancelTimer(t);\n+                                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                            .withSessionId(sessionId)\n+                                                            .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                            .addNewCondition().withType(State.Rebalancing.toString()).endCondition().build());\n+                                                }\n+                                                ccAPIErrorCount.set(0);\n+                                                // TODO: Find out if there is any way to check the progress of a rebalance.\n+                                                //       We could parse the verbose proposal for total number of reassignments and compare to number completed (if available)?\n+                                                //       We can then update the status at this point.\n+                                                break;\n+                                            case ACTIVE: // Rebalance proposal is still being calculated\n+                                                // If a rebalance(dryrun=false) was called and the proposal is still being prepared then the task\n+                                                // will be in an ACTIVE state. When the proposal is ready it will shift to IN_EXECUTION and we will\n+                                                // check that the optimisation proposal is added to the status on the next reconcile.\n+                                                log.info(\"Rebalance ({}) optimization proposal is still being prepared\", sessionId);\n+                                                ccAPIErrorCount.set(0);\n+                                                break;\n+                                            default:\n+                                                log.error(\"Unexpected state {}\", taskStatus);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 635}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyNTUzNw==", "bodyText": "ccApiErrorCount would be more consistent with most of the rest of the project, I think. (Or have I lost this battle?)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420025537", "createdAt": "2020-05-05T11:00:13Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance, State currentState,\n+                                                                  RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaClusterRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                                      String host, CruiseControlApi apiClient,\n+                                                      RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaClusterRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance,\n+                                                                  RebalanceAnnotation rebalanceAnnotation,\n+                                                                  RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"Optimization proposal ready\");\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"Waiting for optimization proposal to be ready\");\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"Cruise Control getting rebalance proposal failed\", rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"Cruise Control getting rebalance resource failed\", getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                                String host, CruiseControlApi apiClient,\n+                                                                KafkaClusterRebalance clusterRebalance,\n+                                                                RebalanceAnnotation rebalanceAnnotation,\n+                                                                RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+            default:\n+                log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Rebalancing} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n+     * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n+     * When the rebalance is finished, the next state is {@code Ready}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then move to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n+                                                              String host, CruiseControlApi apiClient,\n+                                                              KafkaClusterRebalance clusterRebalance,\n+                                                              RebalanceAnnotation rebalanceAnnotation) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+            String sessionId = clusterRebalance.getStatus().getSessionId();\n+            AtomicInteger ccAPIErrorCount = new AtomicInteger();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 550}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyNjUzMw==", "bodyText": "Do we really need this one?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420026533", "createdAt": "2020-05-05T11:02:20Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaClusterRebalanceStatus(), clusterRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance, State currentState,\n+                                                                  RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaClusterRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                                      String host, CruiseControlApi apiClient,\n+                                                      RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaClusterRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                                  String host, CruiseControlApi apiClient,\n+                                                                  KafkaClusterRebalance clusterRebalance,\n+                                                                  RebalanceAnnotation rebalanceAnnotation,\n+                                                                  RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"Optimization proposal ready\");\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"Waiting for optimization proposal to be ready\");\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"Cruise Control getting rebalance proposal failed\", rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"Cruise Control getting rebalance resource failed\", getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                                String host, CruiseControlApi apiClient,\n+                                                                KafkaClusterRebalance clusterRebalance,\n+                                                                RebalanceAnnotation rebalanceAnnotation,\n+                                                                RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+            default:\n+                log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Rebalancing} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n+     * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n+     * When the rebalance is finished, the next state is {@code Ready}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then move to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaClusterRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n+                                                              String host, CruiseControlApi apiClient,\n+                                                              KafkaClusterRebalance clusterRebalance,\n+                                                              RebalanceAnnotation rebalanceAnnotation) {\n+        Promise<KafkaClusterRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+            String sessionId = clusterRebalance.getStatus().getSessionId();\n+            AtomicInteger ccAPIErrorCount = new AtomicInteger();\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                // Check that we have not already failed to contact the API beyond the allowed number of times.\n+                if (ccAPIErrorCount.get() >= MAX_API_RETRIES) {\n+                    vertx.cancelTimer(t);\n+                    p.fail(new RuntimeException(\"Unable to reach Cruise Control API after \" + MAX_API_RETRIES + \" attempts\"));\n+                }\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaClusterRebalance freshClusterRebalance = getResult.result();\n+                        // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                        // and the previous execution set the status and completed the future\n+                        if (state(freshClusterRebalance) == State.Rebalancing) {\n+                            if (getRebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                log.debug(\"{}: Stopping current Cruise Control rebalance user task\", reconciliation);\n+                                vertx.cancelTimer(t);\n+                                apiClient.stopExecution(host, CruiseControl.REST_API_PORT).setHandler(stopResult -> {\n+                                    if (stopResult.succeeded()) {\n+                                        p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                .withSessionId(null)\n+                                                .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                    } else {\n+                                        log.error(\"Cruise Control stopping execution failed\", stopResult.cause());\n+                                        p.fail(stopResult.cause());\n+                                    }\n+                                });\n+                            } else {\n+                                log.info(\"{}: Getting Cruise Control rebalance user task status\", reconciliation);\n+                                // TODO: If this request results in multiple errors from the server then the Rebalance state\n+                                //       will switch to NotReady -> ProposalPending -> ProposalReady even though we are in\n+                                //       an ongoing rebalance. We may need to add an Error state to the state machine.\n+                                apiClient.getUserTaskStatus(host, CruiseControl.REST_API_PORT, sessionId).setHandler(userTaskResult -> {\n+                                    if (userTaskResult.succeeded()) {\n+                                        CruiseControlResponse response = userTaskResult.result();\n+                                        JsonObject taskStatusJson = response.getJson();\n+                                        String taskStatusStr = taskStatusJson.getString(\"Status\");\n+                                        CruiseControlUserTaskStatus taskStatus = CruiseControlUserTaskStatus.lookup(taskStatusStr);\n+                                        switch (taskStatus) {\n+                                            case COMPLETED:\n+                                                vertx.cancelTimer(t);\n+                                                log.info(\"Rebalance ({}) is now complete\", sessionId);\n+                                                p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                        .withSessionId(null)\n+                                                        .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                        .addNewCondition().withType(State.Ready.toString()).endCondition().build());\n+                                                break;\n+                                            case COMPLETED_WITH_ERROR:\n+                                                // TODO: There doesn't seem to be a way to retrieve the actual error message from the user tasks endpoint?\n+                                                //       We may need to propose an upstream PR for this.\n+                                                // TODO: Once we can get the error details we need to add an error field to the Rebalance Status to hold\n+                                                //       details of any issues while rebalancing.\n+                                                log.error(\"Rebalance ({}) optimization proposal has failed to complete\", sessionId);\n+                                                vertx.cancelTimer(t);\n+                                                p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                        .withSessionId(sessionId)\n+                                                        .addNewCondition().withType(State.NotReady.toString()).endCondition().build());\n+                                                break;\n+                                            case IN_EXECUTION: // Rebalance is still in progress\n+                                                // We need to check that the status has been updated with the ongoing optimisation proposal\n+                                                // The proposal field can be empty if a rebalance(dryrun=false) was called and the optimisation\n+                                                // proposal was still being prepared (in progress). In that case the rebalance will start when\n+                                                // the proposal is complete but the optimisation proposal summary will be missing.\n+                                                if (freshClusterRebalance.getStatus().getOptimizationResult() == null ||\n+                                                        freshClusterRebalance.getStatus().getOptimizationResult().isEmpty()) {\n+                                                    log.info(\"Rebalance ({}) optimization proposal is now ready and has been added to the status\", sessionId);\n+                                                    // Cancel the timer so that the status is returned and updated.\n+                                                    vertx.cancelTimer(t);\n+                                                    p.complete(new KafkaClusterRebalanceStatusBuilder()\n+                                                            .withSessionId(sessionId)\n+                                                            .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                            .addNewCondition().withType(State.Rebalancing.toString()).endCondition().build());\n+                                                }\n+                                                ccAPIErrorCount.set(0);\n+                                                // TODO: Find out if there is any way to check the progress of a rebalance.\n+                                                //       We could parse the verbose proposal for total number of reassignments and compare to number completed (if available)?\n+                                                //       We can then update the status at this point.\n+                                                break;\n+                                            case ACTIVE: // Rebalance proposal is still being calculated\n+                                                // If a rebalance(dryrun=false) was called and the proposal is still being prepared then the task\n+                                                // will be in an ACTIVE state. When the proposal is ready it will shift to IN_EXECUTION and we will\n+                                                // check that the optimisation proposal is added to the status on the next reconcile.\n+                                                log.info(\"Rebalance ({}) optimization proposal is still being prepared\", sessionId);\n+                                                ccAPIErrorCount.set(0);\n+                                                break;\n+                                            default:\n+                                                log.error(\"Unexpected state {}\", taskStatus);\n+                                                vertx.cancelTimer(t);\n+                                                p.fail(\"Unexpected state \" + taskStatus);\n+                                                break;\n+                                        }\n+                                    } else {\n+                                        log.error(\"Cruise Control getting rebalance task status failed\", userTaskResult.cause());\n+                                        // To make sure this error is not just a temporary problem with the network we retry several times.\n+                                        // If the number of errors pass the MAX_API_ERRORS limit then the period method will fail the promise.\n+                                        ccAPIErrorCount.getAndIncrement();\n+                                    }\n+                                });\n+                            }\n+                        } else {\n+                            p.complete(freshClusterRebalance.getStatus());\n+                        }\n+                    } else {\n+                        log.error(\"Cruise Control getting rebalance resource failed\", getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Stopped} state.\n+     * If the user set strimzi.io/rebalance=refresh annotation, it calls the Cruise Control API for requesting a new rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaClusterRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaClusterRebalanceStatus> onStop(Reconciliation reconciliation,\n+                                                       String host, CruiseControlApi apiClient,\n+                                                       RebalanceAnnotation rebalanceAnnotation,\n+                                                       RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+        } else {\n+            log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+            return Future.succeededFuture(new KafkaClusterRebalanceStatusBuilder()\n+                    .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+        }\n+    }\n+\n+    private Future<Void> reconcileClusterRebalance(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance) {\n+        if (clusterRebalance == null) {\n+            log.info(\"{}: rebalance resource deleted\", reconciliation);\n+            return Future.succeededFuture();\n+        } else {\n+            return clusterRebalanceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName())\n+                    .compose(fetchedClusterRebalance -> {\n+                        KafkaClusterRebalanceStatus clusterRebalanceStatus = fetchedClusterRebalance.getStatus();\n+                        // cluster rebalance is new or it is in one of others states\n+                        State currentState = clusterRebalanceStatus == null ? State.New :\n+                                State.valueOf(clusterRebalanceStatus.getConditions().get(0).getType());\n+                        // check annotation\n+                        RebalanceAnnotation rebalanceAnnotation = getRebalanceAnnotation(fetchedClusterRebalance);\n+                        return reconcile(reconciliation, host, apiClient, fetchedClusterRebalance, currentState, rebalanceAnnotation).mapEmpty();\n+                    }, exception -> Future.failedFuture(exception).mapEmpty());\n+        }\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> requestRebalance(Reconciliation reconciliation,\n+                                                                 String host, CruiseControlApi apiClient,\n+                                                                 boolean dryrun, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, dryrun, rebalanceOptionsBuilder, null);\n+    }\n+\n+    private Future<KafkaClusterRebalanceStatus> requestRebalance(Reconciliation reconciliation, String host, CruiseControlApi apiClient,\n+        boolean dryrun, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder, String userTaskID) {\n+\n+        log.info(\"{}: Requesting Cruise Control rebalance [dryrun={}]\", reconciliation, dryrun);\n+        if (!dryrun) {\n+            rebalanceOptionsBuilder.withFullRun();\n+        }\n+        return apiClient.rebalance(host, CruiseControl.REST_API_PORT, rebalanceOptionsBuilder.build(), userTaskID)\n+                .map(response -> {\n+                    if (dryrun) {\n+                        if (response.thereIsNotEnoughDataForProposal() || response.proposalIsStillCalculating()) {\n+                            // If either there not enough data for a rebalance or it is still being processed we need to\n+                            // re-request the proposal at a later stage so we move to the PendingProposal State.\n+                            return new KafkaClusterRebalanceStatusBuilder()\n+                                    .withNewSessionId(response.getUserTaskId())\n+                                    .addNewCondition().withNewType(State.PendingProposal.toString()).endCondition().build();\n+                        }\n+                    } else {\n+                        if (response.thereIsNotEnoughDataForProposal()) {\n+                            // We do not include a session id with this status as we do not want to retrieve the state of\n+                            // this failed tasks (COMPLETED_WITH_ERROR)\n+                            return new KafkaClusterRebalanceStatusBuilder()\n+                                    .addNewCondition().withNewType(State.PendingProposal.toString()).endCondition().build();\n+                        } else if (response.proposalIsStillCalculating()) {\n+                            return new KafkaClusterRebalanceStatusBuilder()\n+                                    .withNewSessionId(response.getUserTaskId())\n+                                    .addNewCondition().withNewType(State.Rebalancing.toString()).endCondition().build();\n+                        }\n+                    }\n+\n+                    if (response.getJson().containsKey(CC_REST_API_SUMMARY)) {\n+                        // If there is enough data and the proposal is complete (the response has the \"summary\" key) then we move\n+                        // to ProposalReady for a dry run or to the Rebalancing state for a full run\n+                        State ready = dryrun ? State.ProposalReady : State.Rebalancing;\n+                        return new KafkaClusterRebalanceStatusBuilder()\n+                                .withOptimizationResult(response.getJson().getJsonObject(CC_REST_API_SUMMARY).getMap())\n+                                .addNewCondition().withNewType(ready.toString()).endCondition().build();\n+                    } else {\n+                        throw new RuntimeException(\"Rebalance returned unknown response: \" + response.toString());\n+                    }\n+                }).otherwise(t -> {\n+                    throw new RuntimeException(t.getMessage());\n+                });\n+    }\n+\n+    private RebalanceAnnotation getRebalanceAnnotation(KafkaClusterRebalance clusterRebalance) {\n+        String rebalanceAnnotationValue = rebalanceAnnotation(clusterRebalance);\n+        RebalanceAnnotation rebalanceAnnotation;\n+        try {\n+            rebalanceAnnotation = rebalanceAnnotationValue == null ?\n+                    RebalanceAnnotation.none : RebalanceAnnotation.valueOf(rebalanceAnnotationValue);\n+        } catch (IllegalArgumentException e) {\n+            rebalanceAnnotation = RebalanceAnnotation.unknown;\n+            log.warn(\"Wrong annotation value {}={} on {}/{}\",\n+                    ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotationValue,\n+                    clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName());\n+        }\n+        return rebalanceAnnotation;\n+    }\n+\n+    private String rebalanceAnnotation(KafkaClusterRebalance clusterRebalance) {\n+        return clusterRebalance.getMetadata().getAnnotations() == null ?\n+                null : clusterRebalance.getMetadata().getAnnotations().get(ANNO_STRIMZI_IO_REBALANCE);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 779}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyNjk0Ng==", "bodyText": "Please can we document all of these?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420026946", "createdAt": "2020-05-05T11:03:14Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/cruisecontrol/CruiseControlApi.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly.cruisecontrol;\n+\n+import io.vertx.core.Future;\n+\n+/**\n+ * Cruise Control REST API interface definition\n+ */\n+public interface CruiseControlApi {\n+\n+    String CC_REST_API_ERROR_KEY = \"errorMessage\";\n+    String CC_REST_API_PROGRESS_KEY = \"progress\";\n+    String CC_REST_API_USER_ID_HEADER = \"User-Task-ID\";\n+    String CC_REST_API_SUMMARY = \"summary\";\n+\n+    Future<CruiseControlResponse> getCruiseControlState(String host, int port, boolean verbose);\n+    Future<CruiseControlRebalanceResponse> rebalance(String host, int port, RebalanceOptions options, String userTaskID);\n+    Future<CruiseControlResponse> getUserTaskStatus(String host, int port, String userTaskId);\n+    Future<CruiseControlResponse> stopExecution(String host, int port);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyODMyNg==", "bodyText": "I think you should include the statusMessage. I also see scope here for some common error handling with the Kafka Connect client, but not for this PR. This comment applies to other similar places in this class.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420028326", "createdAt": "2020-05-05T11:06:01Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/cruisecontrol/CruiseControlApiImpl.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly.cruisecontrol;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpClientOptions;\n+import io.vertx.core.http.HttpClientRequest;\n+import io.vertx.core.json.Json;\n+import io.vertx.core.json.JsonObject;\n+\n+public class CruiseControlApiImpl implements CruiseControlApi {\n+\n+    private static final boolean HTTP_CLIENT_ACTIVITY_LOGGING = false;\n+\n+    private final Vertx vertx;\n+\n+    public CruiseControlApiImpl(Vertx vertx) {\n+        this.vertx = vertx;\n+    }\n+\n+    @Override\n+    public Future<CruiseControlResponse> getCruiseControlState(String host, int port, boolean verbose) {\n+        return getCruiseControlState(host, port, verbose, null);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    public Future<CruiseControlResponse> getCruiseControlState(String host, int port, boolean verbose, String userTaskId) {\n+\n+        Promise<CruiseControlResponse> result = Promise.promise();\n+        HttpClientOptions options = new HttpClientOptions().setLogActivity(HTTP_CLIENT_ACTIVITY_LOGGING);\n+\n+        String path = new PathBuilder(CruiseControlEndpoints.STATE)\n+                .addParameter(CruiseControlParameters.JSON, \"true\")\n+                .addParameter(CruiseControlParameters.VERBOSE, String.valueOf(verbose))\n+                .build();\n+\n+        HttpClientRequest request = vertx.createHttpClient(options)\n+                .get(port, host, path, response -> {\n+                    response.exceptionHandler(result::fail);\n+                    if (response.statusCode() == 200 || response.statusCode() == 201) {\n+                        String userTaskID = response.getHeader(CC_REST_API_USER_ID_HEADER);\n+                        response.bodyHandler(buffer -> {\n+                            JsonObject json = buffer.toJsonObject();\n+                            if (json.containsKey(CC_REST_API_ERROR_KEY)) {\n+                                result.fail(json.getString(CC_REST_API_ERROR_KEY));\n+                            } else {\n+                                CruiseControlResponse ccResponse = new CruiseControlResponse(userTaskID, json);\n+                                result.complete(ccResponse);\n+                            }\n+                        });\n+\n+                    } else {\n+                        result.fail(new CruiseControlRestException(\n+                                \"Unexpected status code \" + response.statusCode() + \" for GET request to \" +\n+                                host + \":\" + port + path));\n+                    }\n+                })\n+                .exceptionHandler(result::fail);\n+\n+        if (userTaskId != null) {\n+            request.putHeader(CC_REST_API_USER_ID_HEADER, userTaskId);\n+        }\n+\n+        request.end();\n+\n+        return result.future();\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    public Future<CruiseControlRebalanceResponse> rebalance(String host, int port, RebalanceOptions rbOptions, String userTaskId) {\n+\n+        if (rbOptions == null && userTaskId == null) {\n+            return Future.factory.failedFuture(\n+                    new IllegalArgumentException(\"Either rebalance options or user task ID should be supplied, both were null\"));\n+        }\n+\n+        Promise<CruiseControlRebalanceResponse> result = Promise.promise();\n+        HttpClientOptions httpOptions = new HttpClientOptions().setLogActivity(HTTP_CLIENT_ACTIVITY_LOGGING);\n+\n+        String path = new PathBuilder(CruiseControlEndpoints.REBALANCE)\n+                .addParameter(CruiseControlParameters.JSON, \"true\")\n+                .addRebalanceParameters(rbOptions)\n+                .build();\n+\n+\n+        HttpClientRequest request = vertx.createHttpClient(httpOptions)\n+                .post(port, host, path, response -> {\n+                    response.exceptionHandler(result::fail);\n+                    if (response.statusCode() == 200 || response.statusCode() == 201) {\n+                        response.bodyHandler(buffer -> {\n+                            String userTaskID = response.getHeader(CC_REST_API_USER_ID_HEADER);\n+                            JsonObject json = buffer.toJsonObject();\n+                            CruiseControlRebalanceResponse ccResponse = new CruiseControlRebalanceResponse(userTaskID, json);\n+                            result.complete(ccResponse);\n+                        });\n+                    } else if (response.statusCode() == 202) {\n+                        response.bodyHandler(buffer -> {\n+                            String userTaskID = response.getHeader(CC_REST_API_USER_ID_HEADER);\n+                            JsonObject json = buffer.toJsonObject();\n+                            CruiseControlRebalanceResponse ccResponse = new CruiseControlRebalanceResponse(userTaskID, json);\n+                            if (json.containsKey(CC_REST_API_PROGRESS_KEY)) {\n+                                // If the response contains a \"progress\" key then the rebalance proposal has not yet completed processing\n+                                ccResponse.setProposalIsStillCalculating(true);\n+                            } else {\n+                                result.fail(new CruiseControlRestException(\"202 Status code did not contain progress key. Response was: \" +\n+                                        ccResponse.getJson().toString()));\n+                            }\n+                            result.complete(ccResponse);\n+                        });\n+                    } else if (response.statusCode() == 500) {\n+                        response.bodyHandler(buffer -> {\n+                            String userTaskID = response.getHeader(CC_REST_API_USER_ID_HEADER);\n+                            JsonObject json = buffer.toJsonObject();\n+                            CruiseControlRebalanceResponse ccResponse = new CruiseControlRebalanceResponse(userTaskID, json);\n+                            if (json.containsKey(CC_REST_API_ERROR_KEY)) {\n+                                // If there was a client side error, check whether it was due to not enough data being available\n+                                if (json.getString(CC_REST_API_ERROR_KEY).contains(\"NotEnoughValidWindowsException\")) {\n+                                    ccResponse.setNotEnoughDataForProposal(true);\n+                                    result.complete(ccResponse);\n+                                } else {\n+                                    // If there was any other kind of error propagate this to the operator\n+                                    result.fail(json.getString(CC_REST_API_ERROR_KEY));\n+                                }\n+                            } else {\n+                                result.complete(ccResponse);\n+                            }\n+                        });\n+                    } else {\n+                        result.fail(new CruiseControlRestException(\n+                                \"Unexpected status code \" + response.statusCode() + \" for POST request to \" +\n+                                host + \":\" + port + path));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyOTY0OA==", "bodyText": "Just a point to note about this pattern: an enum like this works fine when all your paths are static (as here), but not when the path contains some parameters, e.g. /foo/${name}.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420029648", "createdAt": "2020-05-05T11:08:50Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/cruisecontrol/CruiseControlEndpoints.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly.cruisecontrol;\n+\n+enum CruiseControlEndpoints {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzMDkyOA==", "bodyText": "Shouldn't you URL encode the value?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420030928", "createdAt": "2020-05-05T11:11:35Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/cruisecontrol/PathBuilder.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly.cruisecontrol;\n+\n+import java.util.List;\n+\n+public class PathBuilder {\n+\n+    String constructedPath;\n+    boolean firstParam;\n+\n+    public PathBuilder(CruiseControlEndpoints endpoint) {\n+        constructedPath = endpoint.path + \"?\";\n+        firstParam = true;\n+    }\n+\n+    public PathBuilder addParameter(String parameter) {\n+        if (!firstParam) {\n+            constructedPath += \"&\";\n+        } else {\n+            firstParam = false;\n+        }\n+        constructedPath += parameter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzMTAyOA==", "bodyText": "Shouldn't you URL encode the value?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420031028", "createdAt": "2020-05-05T11:11:45Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/cruisecontrol/PathBuilder.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly.cruisecontrol;\n+\n+import java.util.List;\n+\n+public class PathBuilder {\n+\n+    String constructedPath;\n+    boolean firstParam;\n+\n+    public PathBuilder(CruiseControlEndpoints endpoint) {\n+        constructedPath = endpoint.path + \"?\";\n+        firstParam = true;\n+    }\n+\n+    public PathBuilder addParameter(String parameter) {\n+        if (!firstParam) {\n+            constructedPath += \"&\";\n+        } else {\n+            firstParam = false;\n+        }\n+        constructedPath += parameter;\n+        return this;\n+    }\n+\n+    public PathBuilder addParameter(CruiseControlParameters param, String value) {\n+        if (!firstParam) {\n+            constructedPath += \"&\";\n+        } else {\n+            firstParam = false;\n+        }\n+        constructedPath += param.asPair(value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzMTA4Ng==", "bodyText": "Shouldn't you URL encode the values?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420031086", "createdAt": "2020-05-05T11:11:54Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/cruisecontrol/PathBuilder.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly.cruisecontrol;\n+\n+import java.util.List;\n+\n+public class PathBuilder {\n+\n+    String constructedPath;\n+    boolean firstParam;\n+\n+    public PathBuilder(CruiseControlEndpoints endpoint) {\n+        constructedPath = endpoint.path + \"?\";\n+        firstParam = true;\n+    }\n+\n+    public PathBuilder addParameter(String parameter) {\n+        if (!firstParam) {\n+            constructedPath += \"&\";\n+        } else {\n+            firstParam = false;\n+        }\n+        constructedPath += parameter;\n+        return this;\n+    }\n+\n+    public PathBuilder addParameter(CruiseControlParameters param, String value) {\n+        if (!firstParam) {\n+            constructedPath += \"&\";\n+        } else {\n+            firstParam = false;\n+        }\n+        constructedPath += param.asPair(value);\n+        return this;\n+    }\n+\n+    public PathBuilder addParameter(CruiseControlParameters param, List<String> values) {\n+        if (!firstParam) {\n+            constructedPath += \"&\";\n+        } else {\n+            firstParam = false;\n+        }\n+        constructedPath += param.asList(values);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzMjQyNQ==", "bodyText": "Is the \\u0027 a java thing, or a json thing? Can't we just let the file be UTF-8 encoded and use the real value, rather than needing an escaped one?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420032425", "createdAt": "2020-05-05T11:14:49Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/resources/io/strimzi/operator/cluster/operator/assembly/CruiseControlJSON/CC-Rebalance-NotEnoughValidWindows-error.json", "diffHunk": "@@ -0,0 +1 @@\n+{\"errorMessage\":\"Error processing POST request \\u0027/rebalance\\u0027 due to: \\u0027com.linkedin.kafka.cruisecontrol.exception.KafkaCruiseControlException: com.linkedin.cruisecontrol.exception.NotEnoughValidWindowsException: There are only 0 valid windows when aggregating in range [-1, 1587403196210] for aggregation options (minValidEntityRatio\\u003d1.00, minValidEntityGroupRatio\\u003d0.00, minValidWindows\\u003d1, numEntitiesToInclude\\u003d2065, granularity\\u003dENTITY)\\u0027.\",\"stackTrace\":\"java.util.concurrent.ExecutionException: com.linkedin.kafka.cruisecontrol.exception.KafkaCruiseControlException: com.linkedin.cruisecontrol.exception.NotEnoughValidWindowsException: There are only 0 valid windows when aggregating in range [-1, 1587403196210] for aggregation options (minValidEntityRatio\\u003d1.00, minValidEntityGroupRatio\\u003d0.00, minValidWindows\\u003d1, numEntitiesToInclude\\u003d2065, granularity\\u003dENTITY)\\n\\tat java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:357)\\n\\tat java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1928)\\n\\tat com.linkedin.kafka.cruisecontrol.servlet.handler.async.AbstractAsyncRequest.getResponse(AbstractAsyncRequest.java:57)\\n\\tat com.linkedin.kafka.cruisecontrol.servlet.handler.AbstractRequest.handle(AbstractRequest.java:40)\\n\\tat com.linkedin.kafka.cruisecontrol.servlet.KafkaCruiseControlServlet.handlePost(KafkaCruiseControlServlet.java:215)\\n\\tat com.linkedin.kafka.cruisecontrol.servlet.KafkaCruiseControlServlet.doGetOrPost(KafkaCruiseControlServlet.java:123)\\n\\tat com.linkedin.kafka.cruisecontrol.servlet.KafkaCruiseControlServlet.doPost(KafkaCruiseControlServlet.java:102)\\n\\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:707)\\n\\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:790)\\n\\tat org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:755)\\n\\tat org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:547)\\n\\tat org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:233)\\n\\tat org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:1607)\\n\\tat org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:233)\\n\\tat org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1297)\\n\\tat org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:188)\\n\\tat org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:485)\\n\\tat org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:1577)\\n\\tat org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:186)\\n\\tat org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1212)\\n\\tat org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)\\n\\tat org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:127)\\n\\tat org.eclipse.jetty.server.Server.handle(Server.java:500)\\n\\tat org.eclipse.jetty.server.HttpChannel.lambda$handle$1(HttpChannel.java:383)\\n\\tat org.eclipse.jetty.server.HttpChannel.dispatch(HttpChannel.java:547)\\n\\tat org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:375)\\n\\tat org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:270)\\n\\tat org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311)\\n\\tat org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:103)\\n\\tat org.eclipse.jetty.io.ChannelEndPoint$2.run(ChannelEndPoint.java:117)\\n\\tat org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.runTask(EatWhatYouKill.java:336)\\n\\tat org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.doProduce(EatWhatYouKill.java:313)\\n\\tat org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.tryProduce(EatWhatYouKill.java:171)\\n\\tat org.eclipse.jetty.util.thread.strategy.EatWhatYouKill.run(EatWhatYouKill.java:129)\\n\\tat org.eclipse.jetty.util.thread.ReservedThreadExecutor$ReservedThread.run(ReservedThreadExecutor.java:388)\\n\\tat org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:806)\\n\\tat org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:938)\\n\\tat java.lang.Thread.run(Thread.java:748)\\nCaused by: com.linkedin.kafka.cruisecontrol.exception.KafkaCruiseControlException: com.linkedin.cruisecontrol.exception.NotEnoughValidWindowsException: There are only 0 valid windows when aggregating in range [-1, 1587403196210] for aggregation options (minValidEntityRatio\\u003d1.00, minValidEntityGroupRatio\\u003d0.00, minValidWindows\\u003d1, numEntitiesToInclude\\u003d2065, granularity\\u003dENTITY)\\n\\tat com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.GoalBasedOperationRunnable.computeResult(GoalBasedOperationRunnable.java:132)\\n\\tat com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.RebalanceRunnable.workWithoutClusterModel(RebalanceRunnable.java:121)\\n\\tat com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.GoalBasedOperationRunnable.computeResult(GoalBasedOperationRunnable.java:137)\\n\\tat com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.RebalanceRunnable.getResult(RebalanceRunnable.java:94)\\n\\tat com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.RebalanceRunnable.getResult(RebalanceRunnable.java:30)\\n\\tat com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.OperationRunnable.run(OperationRunnable.java:45)\\n\\tat com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.GoalBasedOperationRunnable.run(GoalBasedOperationRunnable.java:34)\\n\\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\\n\\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\\n\\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\\n\\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\\n\\t... 1 more\\nCaused by: com.linkedin.cruisecontrol.exception.NotEnoughValidWindowsException: There are only 0 valid windows when aggregating in range [-1, 1587403196210] for aggregation options (minValidEntityRatio\\u003d1.00, minValidEntityGroupRatio\\u003d0.00, minValidWindows\\u003d1, numEntitiesToInclude\\u003d2065, granularity\\u003dENTITY)\\n\\tat com.linkedin.cruisecontrol.monitor.sampling.aggregator.MetricSampleAggregator.validateCompleteness(MetricSampleAggregator.java:540)\\n\\tat com.linkedin.cruisecontrol.monitor.sampling.aggregator.MetricSampleAggregator.aggregate(MetricSampleAggregator.java:212)\\n\\tat com.linkedin.kafka.cruisecontrol.monitor.sampling.aggregator.KafkaPartitionMetricSampleAggregator.aggregate(KafkaPartitionMetricSampleAggregator.java:151)\\n\\tat com.linkedin.kafka.cruisecontrol.monitor.LoadMonitor.clusterModel(LoadMonitor.java:499)\\n\\tat com.linkedin.kafka.cruisecontrol.KafkaCruiseControl.clusterModel(KafkaCruiseControl.java:301)\\n\\tat com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.ProposalsRunnable.workWithClusterModel(ProposalsRunnable.java:81)\\n\\tat com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.GoalBasedOperationRunnable.computeResult(GoalBasedOperationRunnable.java:128)\\n\\t... 11 more\\n\",\"version\":1}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzMzc2OQ==", "bodyText": "Did we mean to change the status here?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420033769", "createdAt": "2020-05-05T11:17:32Z", "author": {"login": "tombentley"}, "path": "operator-common/src/main/java/io/strimzi/operator/common/operator/resource/StatusUtils.java", "diffHunk": "@@ -29,18 +29,22 @@ public static String iso8601Now() {\n     }\n \n     public static Condition buildConditionFromException(Throwable error) {\n+        return buildCondition(error == null ? \"Ready\" : \"NotReady\", error);\n+    }\n+\n+    public static Condition buildCondition(String type, Throwable error) {\n         Condition readyCondition;\n         if (error == null) {\n             readyCondition = new ConditionBuilder()\n                     .withLastTransitionTime(iso8601Now())\n-                    .withType(\"Ready\")\n-                    .withStatus(\"True\")\n+                    .withType(type)\n+                    .withStatus(\"Ready\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1Njk2NjM1", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#pullrequestreview-405696635", "createdAt": "2020-05-05T11:22:26Z", "commit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMToyMjoyN1rOGQk9eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMjowODowOVrOGQmWuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNTk2MQ==", "bodyText": "Please use the resource group defined in Constants", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420035961", "createdAt": "2020-05-05T11:22:27Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaClusterRebalance.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\n+import io.fabric8.kubernetes.api.model.Doneable;\n+import io.fabric8.kubernetes.api.model.ObjectMeta;\n+import io.fabric8.kubernetes.client.CustomResource;\n+import io.strimzi.api.kafka.model.status.HasStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.crdgenerator.annotations.Crd;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import io.sundr.builder.annotations.Inline;\n+import lombok.EqualsAndHashCode;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+\n+@JsonDeserialize\n+@Crd(\n+        apiVersion = KafkaClusterRebalance.CRD_API_VERSION,\n+        spec = @Crd.Spec(\n+                names = @Crd.Spec.Names(\n+                        kind = KafkaClusterRebalance.RESOURCE_KIND,\n+                        plural = KafkaClusterRebalance.RESOURCE_PLURAL,\n+                        shortNames = {KafkaClusterRebalance.SHORT_NAME}\n+                ),\n+                group = KafkaClusterRebalance.RESOURCE_GROUP,\n+                scope = KafkaClusterRebalance.SCOPE,\n+                version = KafkaClusterRebalance.V1ALPHA1,\n+                versions = {\n+                        @Crd.Spec.Version(\n+                                name = KafkaClusterRebalance.V1ALPHA1,\n+                                served = true,\n+                                storage = true\n+                        )\n+                },\n+                subresources = @Crd.Spec.Subresources(\n+                        status = @Crd.Spec.Subresources.Status()\n+                )\n+        )\n+)\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\",\n+        inline = @Inline(type = Doneable.class, prefix = \"Doneable\", value = \"done\")\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"apiVersion\", \"kind\", \"metadata\", \"spec\"})\n+@EqualsAndHashCode\n+public class KafkaClusterRebalance extends CustomResource implements UnknownPropertyPreserving, HasStatus<KafkaClusterRebalanceStatus> {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String SCOPE = \"Namespaced\";\n+    public static final String V1ALPHA1 = \"v1alpha1\";\n+    public static final List<String> VERSIONS = unmodifiableList(asList(V1ALPHA1));\n+    public static final String RESOURCE_KIND = \"KafkaClusterRebalance\";\n+    public static final String RESOURCE_LIST_KIND = RESOURCE_KIND + \"List\";\n+    public static final String RESOURCE_GROUP = \"kafka.strimzi.io\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNjA5Nw==", "bodyText": "when you change to KafkaRebalance ensure this is changed to kr", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420036097", "createdAt": "2020-05-05T11:22:48Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaClusterRebalance.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\n+import io.fabric8.kubernetes.api.model.Doneable;\n+import io.fabric8.kubernetes.api.model.ObjectMeta;\n+import io.fabric8.kubernetes.client.CustomResource;\n+import io.strimzi.api.kafka.model.status.HasStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.crdgenerator.annotations.Crd;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import io.sundr.builder.annotations.Inline;\n+import lombok.EqualsAndHashCode;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+\n+@JsonDeserialize\n+@Crd(\n+        apiVersion = KafkaClusterRebalance.CRD_API_VERSION,\n+        spec = @Crd.Spec(\n+                names = @Crd.Spec.Names(\n+                        kind = KafkaClusterRebalance.RESOURCE_KIND,\n+                        plural = KafkaClusterRebalance.RESOURCE_PLURAL,\n+                        shortNames = {KafkaClusterRebalance.SHORT_NAME}\n+                ),\n+                group = KafkaClusterRebalance.RESOURCE_GROUP,\n+                scope = KafkaClusterRebalance.SCOPE,\n+                version = KafkaClusterRebalance.V1ALPHA1,\n+                versions = {\n+                        @Crd.Spec.Version(\n+                                name = KafkaClusterRebalance.V1ALPHA1,\n+                                served = true,\n+                                storage = true\n+                        )\n+                },\n+                subresources = @Crd.Spec.Subresources(\n+                        status = @Crd.Spec.Subresources.Status()\n+                )\n+        )\n+)\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\",\n+        inline = @Inline(type = Doneable.class, prefix = \"Doneable\", value = \"done\")\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"apiVersion\", \"kind\", \"metadata\", \"spec\"})\n+@EqualsAndHashCode\n+public class KafkaClusterRebalance extends CustomResource implements UnknownPropertyPreserving, HasStatus<KafkaClusterRebalanceStatus> {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String SCOPE = \"Namespaced\";\n+    public static final String V1ALPHA1 = \"v1alpha1\";\n+    public static final List<String> VERSIONS = unmodifiableList(asList(V1ALPHA1));\n+    public static final String RESOURCE_KIND = \"KafkaClusterRebalance\";\n+    public static final String RESOURCE_LIST_KIND = RESOURCE_KIND + \"List\";\n+    public static final String RESOURCE_GROUP = \"kafka.strimzi.io\";\n+    public static final String RESOURCE_PLURAL = \"kafkaclusterrebalances\";\n+    public static final String RESOURCE_SINGULAR = \"kafkaclusterrebalance\";\n+    public static final String CRD_API_VERSION = \"apiextensions.k8s.io/v1beta1\";\n+    public static final String CRD_NAME = RESOURCE_PLURAL + \".\" + RESOURCE_GROUP;\n+    public static final String SHORT_NAME = \"kcr\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNjI3OA==", "bodyText": "you're missing status from the order", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420036278", "createdAt": "2020-05-05T11:23:10Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaClusterRebalance.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\n+import io.fabric8.kubernetes.api.model.Doneable;\n+import io.fabric8.kubernetes.api.model.ObjectMeta;\n+import io.fabric8.kubernetes.client.CustomResource;\n+import io.strimzi.api.kafka.model.status.HasStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.crdgenerator.annotations.Crd;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import io.sundr.builder.annotations.Inline;\n+import lombok.EqualsAndHashCode;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+\n+@JsonDeserialize\n+@Crd(\n+        apiVersion = KafkaClusterRebalance.CRD_API_VERSION,\n+        spec = @Crd.Spec(\n+                names = @Crd.Spec.Names(\n+                        kind = KafkaClusterRebalance.RESOURCE_KIND,\n+                        plural = KafkaClusterRebalance.RESOURCE_PLURAL,\n+                        shortNames = {KafkaClusterRebalance.SHORT_NAME}\n+                ),\n+                group = KafkaClusterRebalance.RESOURCE_GROUP,\n+                scope = KafkaClusterRebalance.SCOPE,\n+                version = KafkaClusterRebalance.V1ALPHA1,\n+                versions = {\n+                        @Crd.Spec.Version(\n+                                name = KafkaClusterRebalance.V1ALPHA1,\n+                                served = true,\n+                                storage = true\n+                        )\n+                },\n+                subresources = @Crd.Spec.Subresources(\n+                        status = @Crd.Spec.Subresources.Status()\n+                )\n+        )\n+)\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\",\n+        inline = @Inline(type = Doneable.class, prefix = \"Doneable\", value = \"done\")\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"apiVersion\", \"kind\", \"metadata\", \"spec\"})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNjYzMw==", "bodyText": "Ensure this string, as well as the class names are modified also.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420036633", "createdAt": "2020-05-05T11:23:55Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaClusterRebalance.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\n+import io.fabric8.kubernetes.api.model.Doneable;\n+import io.fabric8.kubernetes.api.model.ObjectMeta;\n+import io.fabric8.kubernetes.client.CustomResource;\n+import io.strimzi.api.kafka.model.status.HasStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.crdgenerator.annotations.Crd;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import io.sundr.builder.annotations.Inline;\n+import lombok.EqualsAndHashCode;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+\n+@JsonDeserialize\n+@Crd(\n+        apiVersion = KafkaClusterRebalance.CRD_API_VERSION,\n+        spec = @Crd.Spec(\n+                names = @Crd.Spec.Names(\n+                        kind = KafkaClusterRebalance.RESOURCE_KIND,\n+                        plural = KafkaClusterRebalance.RESOURCE_PLURAL,\n+                        shortNames = {KafkaClusterRebalance.SHORT_NAME}\n+                ),\n+                group = KafkaClusterRebalance.RESOURCE_GROUP,\n+                scope = KafkaClusterRebalance.SCOPE,\n+                version = KafkaClusterRebalance.V1ALPHA1,\n+                versions = {\n+                        @Crd.Spec.Version(\n+                                name = KafkaClusterRebalance.V1ALPHA1,\n+                                served = true,\n+                                storage = true\n+                        )\n+                },\n+                subresources = @Crd.Spec.Subresources(\n+                        status = @Crd.Spec.Subresources.Status()\n+                )\n+        )\n+)\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\",\n+        inline = @Inline(type = Doneable.class, prefix = \"Doneable\", value = \"done\")\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"apiVersion\", \"kind\", \"metadata\", \"spec\"})\n+@EqualsAndHashCode\n+public class KafkaClusterRebalance extends CustomResource implements UnknownPropertyPreserving, HasStatus<KafkaClusterRebalanceStatus> {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String SCOPE = \"Namespaced\";\n+    public static final String V1ALPHA1 = \"v1alpha1\";\n+    public static final List<String> VERSIONS = unmodifiableList(asList(V1ALPHA1));\n+    public static final String RESOURCE_KIND = \"KafkaClusterRebalance\";\n+    public static final String RESOURCE_LIST_KIND = RESOURCE_KIND + \"List\";\n+    public static final String RESOURCE_GROUP = \"kafka.strimzi.io\";\n+    public static final String RESOURCE_PLURAL = \"kafkaclusterrebalances\";\n+    public static final String RESOURCE_SINGULAR = \"kafkaclusterrebalance\";\n+    public static final String CRD_API_VERSION = \"apiextensions.k8s.io/v1beta1\";\n+    public static final String CRD_NAME = RESOURCE_PLURAL + \".\" + RESOURCE_GROUP;\n+    public static final String SHORT_NAME = \"kcr\";\n+    public static final List<String> RESOURCE_SHORTNAMES = singletonList(SHORT_NAME);\n+\n+    private String apiVersion;\n+    private ObjectMeta metadata;\n+    private KafkaClusterRebalanceSpec spec;\n+    private KafkaClusterRebalanceStatus status;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonProperty(\"kind\")\n+    @Override\n+    public String getKind() {\n+        return RESOURCE_KIND;\n+    }\n+\n+    @Override\n+    public String getApiVersion() {\n+        return apiVersion;\n+    }\n+\n+    @Override\n+    public void setApiVersion(String apiVersion) {\n+        this.apiVersion = apiVersion;\n+    }\n+\n+    @Override\n+    public ObjectMeta getMetadata() {\n+        return super.getMetadata();\n+    }\n+\n+    @Override\n+    public void setMetadata(ObjectMeta metadata) {\n+        super.setMetadata(metadata);\n+    }\n+\n+    @Description(\"The specification of the Kafka Cluster Rebalance.\")\n+    public KafkaClusterRebalanceSpec getSpec() {\n+        return spec;\n+    }\n+\n+    public void setSpec(KafkaClusterRebalanceSpec spec) {\n+        this.spec = spec;\n+    }\n+\n+    @Override\n+    @Description(\"The status of the Kafka Cluster Rebalance.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNjc5Mw==", "bodyText": "Again, use the Constants static string", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420036793", "createdAt": "2020-05-05T11:24:15Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaClusterRebalanceSpec.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzOTM2OQ==", "bodyText": "ditto this string change", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420039369", "createdAt": "2020-05-05T11:29:43Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/status/KafkaClusterRebalanceStatus.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.status;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+import lombok.ToString;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Represents a status of the Kafka Cluster Rebalance resource", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzOTQ0MQ==", "bodyText": "ditto", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420039441", "createdAt": "2020-05-05T11:29:51Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/status/KafkaClusterRebalanceStatus.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.status;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+import lombok.ToString;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Represents a status of the Kafka Cluster Rebalance resource\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1MzgwNw==", "bodyText": "Do we want to log.info this, seems a little noisy?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420053807", "createdAt": "2020-05-05T11:58:23Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaClusterRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaClusterRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalance;\n+import io.strimzi.api.kafka.model.KafkaClusterRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaClusterRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlResponse;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.assembly.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"Kafka Cluster Rebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ */\n+public class KafkaClusterRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaClusterRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance, Resource<KafkaClusterRebalance, DoneableKafkaClusterRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaClusterRebalanceAssemblyOperator.class.getName());\n+\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaClusterRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                                 ResourceOperatorSupplier supplier,\n+                                                 Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaClusterRebalance.RESOURCE_KIND, supplier.kafkaClusterRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.clusterRebalanceOperator = supplier.kafkaClusterRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaClusterRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createClusterRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.clusterRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaClusterRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaClusterRebalance kafkaClusterRebalance) {\n+                    log.debug(\"EventReceived {} on {} with status [{}] and {}={}\", action, kafkaClusterRebalance.getMetadata().getName(),\n+                            kafkaClusterRebalance.getStatus() != null ? kafkaClusterRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation(kafkaClusterRebalance));\n+                    String clusterName = kafkaClusterRebalance.getMetadata().getLabels() == null ? null : kafkaClusterRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+                    String clusterNamespace = kafkaClusterRebalance.getMetadata().getNamespace();\n+                    KafkaClusterRebalanceStatus desiredStatus = new KafkaClusterRebalanceStatus();\n+                    if (clusterName != null) {\n+                        kafkaOperator.getAsync(clusterNamespace, clusterName).setHandler(result -> {\n+                            if (result.succeeded()) {\n+                                Kafka kafka = result.result();\n+                                if (kafka == null) {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                    + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                    + \"' does not exist in namespace \" + clusterNamespace + \".\"));\n+\n+                                } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                    CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                    Reconciliation reconciliation = new Reconciliation(\"clusterrebalance-watch\", kafkaClusterRebalance.getKind(),\n+                                            kafkaClusterRebalance.getMetadata().getNamespace(), kafkaClusterRebalance.getMetadata().getName());\n+\n+                                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                        () -> reconcileClusterRebalance(reconciliation,\n+                                                ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost,\n+                                                apiClient, action == Action.DELETED ? null : kafkaClusterRebalance));\n+\n+                                } else {\n+                                    updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                            new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                    + \"': No deployed Cruise Control for doing a rebalance.\"));\n+                                }\n+                            } else {\n+                                updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator, result.cause());\n+                            }\n+                        });\n+                    } else {\n+                        updateStatus(kafkaClusterRebalance, desiredStatus, clusterRebalanceOperator,\n+                                new InvalidResourceException(\"Resource lacks label '\"\n+                                        + Labels.STRIMZI_CLUSTER_LABEL\n+                                        + \"': No cluster related to a possible rebalance.\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    public static Future<KafkaClusterRebalance> updateStatus(KafkaClusterRebalance clusterRebalance,\n+                                                             KafkaClusterRebalanceStatus desiredStatus,\n+                                                             CrdOperator<KubernetesClient, KafkaClusterRebalance, KafkaClusterRebalanceList, DoneableKafkaClusterRebalance> clusterRebalanceOperations,\n+                                                             Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaClusterRebalance copy = new KafkaClusterRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaClusterRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return clusterRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, clusterRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaClusterRebalance patchedClusterRebalance = new KafkaClusterRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return clusterRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.info(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 317}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1NzI4MA==", "bodyText": "I generally prefer calling context.checkpoint() outside of the sync call and calling flag() inside this handler", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420057280", "createdAt": "2020-05-05T12:05:13Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/cruisecontrol/CruiseControlClientTest.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly.cruisecontrol;\n+\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockserver.integration.ClientAndServer;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+import static io.strimzi.operator.cluster.operator.assembly.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+@ExtendWith(VertxExtension.class)\n+public class CruiseControlClientTest {\n+\n+    private static final int PORT = 1080;\n+    private static final String HOST = \"localhost\";\n+\n+    private static ClientAndServer ccServer;\n+\n+    @BeforeAll\n+    public static void setupServer() throws IOException, URISyntaxException {\n+        ccServer = MockCruiseControl.getCCServer(PORT);\n+    }\n+\n+    @AfterAll\n+    public static void stopServer() {\n+        ccServer.stop();\n+    }\n+\n+    @BeforeEach\n+    public void resetServer() {\n+        ccServer.reset();\n+    }\n+\n+    @Test\n+    public void testGetCCState(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCStateResponse(ccServer);\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        client.getCruiseControlState(HOST, PORT, false).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(\n+                    result.getJson().getJsonObject(\"ExecutorState\").getString(\"state\"),\n+                    is(\"NO_TASK_IN_PROGRESS\")));\n+            context.completeNow();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().build();\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        client.rebalance(HOST, PORT, rbOptions, null).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.REBALANCE_NO_GOALS_RESPONSE_UTID)));\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"summary\"), is(true)));\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"goalSummary\"), is(true)));\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"loadAfterOptimization\"), is(true)));\n+            context.completeNow();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalanceVerbose(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().withVerboseResponse().build();\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        client.rebalance(HOST, PORT, rbOptions, null).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.REBALANCE_NO_GOALS_VERBOSE_RESPONSE_UTID)));\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"summary\"), is(true)));\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"goalSummary\"), is(true)));\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"proposals\"), is(true)));\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"loadAfterOptimization\"), is(true)));\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"loadBeforeOptimization\"), is(true)));\n+            context.completeNow();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalanceNotEnoughValidWindowsException(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().build();\n+\n+        CruiseControlApiImpl client = new CruiseControlApiImpl(vertx);\n+\n+        client.rebalance(HOST, PORT, rbOptions, MockCruiseControl.REBALANCE_NOT_ENOUGH_VALID_WINDOWS_ERROR)\n+                .setHandler(result -> {\n+                    if (result.succeeded()) {\n+                        assertThat(result.result().thereIsNotEnoughDataForProposal(), is(true));\n+                        context.completeNow();\n+                    } else {\n+                        context.failNow(result.cause());\n+                    }\n+                });\n+    }\n+\n+    @Test\n+    public void testCCGetRebalanceUserTask(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+        String userTaskID = MockCruiseControl.REBALANCE_NO_GOALS_RESPONSE_UTID;\n+\n+        client.getUserTaskStatus(HOST, PORT, userTaskID).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.USER_TASK_REBALANCE_NO_GOALS_RESPONSE_UTID)));\n+            context.verify(() -> assertThat(result.getJson().getJsonObject(CC_REST_API_SUMMARY), is(notNullValue())));\n+            context.completeNow();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCGetRebalanceVerboseUserTask(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+        String userTaskID = MockCruiseControl.REBALANCE_NO_GOALS_VERBOSE_RESPONSE_UTID;\n+\n+        client.getUserTaskStatus(HOST, PORT, userTaskID).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.USER_TASK_REBALANCE_NO_GOALS_VERBOSE_RESPONSE_UTID)));\n+            context.verify(() -> assertThat(result.getJson().getJsonObject(CC_REST_API_SUMMARY), is(notNullValue())));\n+            context.completeNow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1NzYzNg==", "bodyText": "Similarly can we use checkpoints here", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420057636", "createdAt": "2020-05-05T12:05:48Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/cruisecontrol/MockCruiseControlTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly.cruisecontrol;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.Checkpoint;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockserver.integration.ClientAndServer;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+@ExtendWith(VertxExtension.class)\n+public class MockCruiseControlTest {\n+\n+    private static final int PORT = 1080;\n+    private static final String HOST = \"localhost\";\n+\n+    private static ClientAndServer ccServer;\n+\n+    @BeforeAll\n+    public static void startUp() throws IOException, URISyntaxException {\n+        ccServer = MockCruiseControl.getCCServer(PORT);\n+    }\n+\n+    @BeforeEach\n+    public void resetServer() {\n+        ccServer.reset();\n+    }\n+\n+    @AfterAll\n+    public static void stop() {\n+        ccServer.stop();\n+    }\n+\n+    private void runTest(Vertx vertx, VertxTestContext context, String userTaskID, int pendingCalls) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCUserTasksResponse(ccServer, pendingCalls);\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        Future<CruiseControlResponse> statusFuture = client.getUserTaskStatus(HOST, PORT, userTaskID);\n+\n+        if (pendingCalls > 0) {\n+            for (int i = 1; i <= pendingCalls; i++) {\n+                statusFuture = statusFuture.compose(response -> {\n+                    context.verify(() -> assertThat(\n+                            response.getJson().getString(\"Status\"),\n+                            is(CruiseControlUserTaskStatus.IN_EXECUTION.toString()))\n+                    );\n+                    return client.getUserTaskStatus(HOST, PORT, userTaskID);\n+                });\n+            }\n+        }\n+\n+        statusFuture.compose(response -> {\n+            context.verify(() -> assertThat(\n+                    response.getJson().getString(\"Status\"),\n+                    is(CruiseControlUserTaskStatus.COMPLETED.toString()))\n+            );\n+            return Future.succeededFuture(response);\n+        }).setHandler(context.succeeding(result -> {\n+            context.completeNow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1ODE0MQ==", "bodyText": "ditto", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420058141", "createdAt": "2020-05-05T12:06:49Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/cruisecontrol/MockCruiseControlTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly.cruisecontrol;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.Checkpoint;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockserver.integration.ClientAndServer;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+@ExtendWith(VertxExtension.class)\n+public class MockCruiseControlTest {\n+\n+    private static final int PORT = 1080;\n+    private static final String HOST = \"localhost\";\n+\n+    private static ClientAndServer ccServer;\n+\n+    @BeforeAll\n+    public static void startUp() throws IOException, URISyntaxException {\n+        ccServer = MockCruiseControl.getCCServer(PORT);\n+    }\n+\n+    @BeforeEach\n+    public void resetServer() {\n+        ccServer.reset();\n+    }\n+\n+    @AfterAll\n+    public static void stop() {\n+        ccServer.stop();\n+    }\n+\n+    private void runTest(Vertx vertx, VertxTestContext context, String userTaskID, int pendingCalls) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCUserTasksResponse(ccServer, pendingCalls);\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        Future<CruiseControlResponse> statusFuture = client.getUserTaskStatus(HOST, PORT, userTaskID);\n+\n+        if (pendingCalls > 0) {\n+            for (int i = 1; i <= pendingCalls; i++) {\n+                statusFuture = statusFuture.compose(response -> {\n+                    context.verify(() -> assertThat(\n+                            response.getJson().getString(\"Status\"),\n+                            is(CruiseControlUserTaskStatus.IN_EXECUTION.toString()))\n+                    );\n+                    return client.getUserTaskStatus(HOST, PORT, userTaskID);\n+                });\n+            }\n+        }\n+\n+        statusFuture.compose(response -> {\n+            context.verify(() -> assertThat(\n+                    response.getJson().getString(\"Status\"),\n+                    is(CruiseControlUserTaskStatus.COMPLETED.toString()))\n+            );\n+            return Future.succeededFuture(response);\n+        }).setHandler(context.succeeding(result -> {\n+            context.completeNow();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCUserTaskNoDelay(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+        runTest(vertx, context, MockCruiseControl.REBALANCE_NO_GOALS_RESPONSE_UTID, 0);\n+    }\n+\n+    @Test\n+    public void testCCUserTaskNoDelayVerbose(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+        runTest(vertx, context, MockCruiseControl.REBALANCE_NO_GOALS_VERBOSE_RESPONSE_UTID, 0);\n+    }\n+\n+    @Test\n+    public void testCCUserTaskDelay(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+        runTest(vertx, context, MockCruiseControl.REBALANCE_NO_GOALS_RESPONSE_UTID, 3);\n+    }\n+\n+    @Test\n+    public void testCCUserTaskDelayVerbose(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+        runTest(vertx, context, MockCruiseControl.REBALANCE_NO_GOALS_VERBOSE_RESPONSE_UTID, 3);\n+    }\n+\n+    @Test\n+    public void testMockCCServerPendingCallsOverride(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+        String userTaskID = MockCruiseControl.REBALANCE_NO_GOALS_RESPONSE_UTID;\n+\n+        int pendingCalls1 = 2;\n+        Checkpoint firstPending = context.checkpoint(pendingCalls1);\n+        int pendingCalls2 = 4;\n+        Checkpoint secondPending = context.checkpoint(pendingCalls2);\n+\n+        MockCruiseControl.setupCCUserTasksResponse(ccServer, pendingCalls1);\n+\n+        Future<CruiseControlResponse> statusFuture = client.getUserTaskStatus(HOST, PORT, userTaskID);\n+\n+        for (int i = 1; i <= pendingCalls1; i++) {\n+            statusFuture = statusFuture.compose(response -> {\n+                context.verify(() -> assertThat(\n+                        response.getJson().getString(\"Status\"),\n+                        is(CruiseControlUserTaskStatus.IN_EXECUTION.toString()))\n+                );\n+                firstPending.flag();\n+                return client.getUserTaskStatus(HOST, PORT, userTaskID);\n+            });\n+        }\n+\n+        statusFuture = statusFuture.compose(response -> {\n+            context.verify(() -> assertThat(\n+                    response.getJson().getString(\"Status\"),\n+                    is(CruiseControlUserTaskStatus.COMPLETED.toString()))\n+            );\n+            return Future.succeededFuture(response);\n+        });\n+\n+        statusFuture = statusFuture.compose(response -> {\n+            try {\n+                ccServer.reset();\n+                MockCruiseControl.setupCCUserTasksResponse(ccServer, pendingCalls2);\n+            } catch (IOException e) {\n+                return Future.failedFuture(e);\n+            } catch (URISyntaxException e) {\n+                return Future.failedFuture(e);\n+            }\n+            return Future.succeededFuture();\n+        });\n+\n+        statusFuture = statusFuture.compose(ignore -> client.getUserTaskStatus(HOST, PORT, userTaskID));\n+\n+        for (int i = 1; i <= pendingCalls2; i++) {\n+            statusFuture = statusFuture.compose(response -> {\n+                context.verify(() -> assertThat(\n+                        response.getJson().getString(\"Status\"),\n+                        is(CruiseControlUserTaskStatus.IN_EXECUTION.toString()))\n+                );\n+                secondPending.flag();\n+                return client.getUserTaskStatus(HOST, PORT, userTaskID);\n+            });\n+        }\n+\n+        statusFuture.compose(response -> {\n+            context.verify(() -> assertThat(\n+                    response.getJson().getJsonArray(\"userTasks\").getJsonObject(0).getString(\"Status\"),\n+                    is(CruiseControlUserTaskStatus.COMPLETED.toString()))\n+            );\n+            return Future.succeededFuture(response);\n+        }).setHandler(context.succeeding(result -> {\n+            context.completeNow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1ODgxMQ==", "bodyText": "Is there a reason we haven't inlined these JSON strings into a java class?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r420058811", "createdAt": "2020-05-05T12:08:09Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/resources/io/strimzi/operator/cluster/operator/assembly/CruiseControlJSON/CC-State-proposal-not-ready.json", "diffHunk": "@@ -0,0 +1 @@\n+{\"AnalyzerState\":{\"isProposalReady\":false,\"readyGoals\":[]},\"MonitorState\":{\"trainingPct\":9.6,\"trained\":false,\"numFlawedPartitions\":0,\"state\":\"RUNNING\",\"numTotalPartitions\":2065,\"numMonitoredWindows\":1,\"monitoringCoveragePct\":100.0,\"reasonOfLatestPauseOrResume\":\"N/A\",\"numValidPartitions\":2065},\"ExecutorState\":{\"state\":\"NO_TASK_IN_PROGRESS\"},\"AnomalyDetectorState\":{\"recentBrokerFailures\":[],\"recentGoalViolations\":[],\"selfHealingDisabled\":[\"DISK_FAILURE\",\"BROKER_FAILURE\",\"GOAL_VIOLATION\",\"METRIC_ANOMALY\",\"TOPIC_ANOMALY\"],\"balancednessScore\":100.0,\"selfHealingEnabled\":[],\"recentDiskFailures\":[],\"metrics\":{\"meanTimeToStartFixMs\":0.0,\"numSelfHealingStarted\":0,\"ongoingAnomalyDurationMs\":0,\"numSelfHealingFailedToStart\":0,\"meanTimeBetweenAnomaliesMs\":{\"TOPIC_ANOMALY\":0.0,\"GOAL_VIOLATION\":0.0,\"DISK_FAILURE\":0.0,\"BROKER_FAILURE\":0.0,\"METRIC_ANOMALY\":0.0}},\"recentMetricAnomalies\":[],\"recentTopicAnomalies\":[],\"selfHealingEnabledRatio\":{\"DISK_FAILURE\":0.0,\"BROKER_FAILURE\":0.0,\"GOAL_VIOLATION\":0.0,\"METRIC_ANOMALY\":0.0,\"TOPIC_ANOMALY\":0.0}},\"version\":1}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 1}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5eace7e99b9ed32a14efa6fb53b5fd776363db9d", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5eace7e99b9ed32a14efa6fb53b5fd776363db9d", "committedDate": "2020-05-06T05:38:43Z", "message": "Refactor checkGoals() in CruiseControl class (#55)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}, "afterCommit": {"oid": "dc9fc8bd0e0a8feb92dbbb5fb1301842be2afa53", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/dc9fc8bd0e0a8feb92dbbb5fb1301842be2afa53", "committedDate": "2020-05-06T05:40:55Z", "message": "Refactor checkGoals() in CruiseControl class (#55)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>\nSigned-off-by: Paolo Patierno <ppatierno@live.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b82860ef60cc1fcbb1816acb3dbf280e38fce181", "author": {"user": {"login": "ppatierno", "name": "Paolo Patierno"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b82860ef60cc1fcbb1816acb3dbf280e38fce181", "committedDate": "2020-05-06T07:22:40Z", "message": "Moved cruisecontrol package with API client\nMoved Kafka Cruise Control example YAML\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>"}, "afterCommit": {"oid": "b3ffdd492f81358e6e0728ed36c322bf73968b1f", "author": {"user": {"login": "ppatierno", "name": "Paolo Patierno"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b3ffdd492f81358e6e0728ed36c322bf73968b1f", "committedDate": "2020-05-06T07:26:41Z", "message": "Moved cruisecontrol package with API client\nMoved Kafka Cruise Control example YAML\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2OTM2ODgw", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#pullrequestreview-406936880", "createdAt": "2020-05-06T19:51:11Z", "commit": {"oid": "72fcd17f64761a8bd4c852466f8d875ed9a7e638"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOTo1MToxMVrOGRi7Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMToyNDoyOFrOGRmAOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTE0Ng==", "bodyText": "I think you are missing spaces at the end of the lines? They will be joined without a space between the sentences, or?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421051146", "createdAt": "2020-05-06T19:51:11Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaRebalanceSpec.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({ \"goals\", \"skipHardGoalCheck\" })\n+@EqualsAndHashCode\n+public class KafkaRebalanceSpec implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private List<String> goals;\n+    private boolean skipHardGoalCheck;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"A list of goals, ordered by decreasing priority, to use for generating and executing the rebalance proposal.\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72fcd17f64761a8bd4c852466f8d875ed9a7e638"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTg2MA==", "bodyText": "This is a bit wierd. Wouldn't it be better to say if goals is not specified, the default goals will be used? Are you 100% sure there will be never any usecase for an actual empty list of goals?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421051860", "createdAt": "2020-05-06T19:52:26Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaRebalanceSpec.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({ \"goals\", \"skipHardGoalCheck\" })\n+@EqualsAndHashCode\n+public class KafkaRebalanceSpec implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private List<String> goals;\n+    private boolean skipHardGoalCheck;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"A list of goals, ordered by decreasing priority, to use for generating and executing the rebalance proposal.\" +\n+            \"The supported goals are available at https://github.com/linkedin/cruise-control#goals.\" +\n+            \"If an empty goals list is provided, the goals declared in the default.goals Cruise Control configuration parameter are used.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72fcd17f64761a8bd4c852466f8d875ed9a7e638"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MjY4MQ==", "bodyText": "Space at the end of the sentence again?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421052681", "createdAt": "2020-05-06T19:53:53Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/status/KafkaRebalanceStatus.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.status;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+import lombok.ToString;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Represents a status of the Kafka Rebalance resource\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({ \"conditions\", \"observedGeneration\", \"sessionId\", \"optimizationResult\" })\n+@EqualsAndHashCode\n+@ToString(callSuper = true)\n+public class KafkaRebalanceStatus extends Status {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private String sessionId;\n+    private Map<String, Object> optimizationResult = new HashMap<>(0);\n+\n+    @Description(\"A JSON describing the optimization result\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, Object> getOptimizationResult() {\n+        return optimizationResult;\n+    }\n+\n+    public void setOptimizationResult(Map<String, Object> optimizationResult) {\n+        this.optimizationResult = optimizationResult;\n+    }\n+\n+    @Description(\"The session identifier for requests to Cruise Control pertaining to this KafkaRebalance resource.\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72fcd17f64761a8bd4c852466f8d875ed9a7e638"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NjY1Nw==", "bodyText": "I do not see anything what would correspond to this in the KafkaRebalanceStatus. So is this comment not valid anymore? I guess this is the status the previous Enum discussion relates to?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421086657", "createdAt": "2020-05-06T20:56:20Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72fcd17f64761a8bd4c852466f8d875ed9a7e638"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4Nzc3OQ==", "bodyText": "Since the resource seems to be used just once ... does this really need to be annotation? Have you thought about a field in .spec?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421087779", "createdAt": "2020-05-06T20:58:27Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72fcd17f64761a8bd4c852466f8d875ed9a7e638"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODY3Mg==", "bodyText": "I know his is not docs. But what happens when the rebalance is stopped? Will it revert? Will it finish the partition it is moving? Will it leave half finished things?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421088672", "createdAt": "2020-05-06T20:59:54Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72fcd17f64761a8bd4c852466f8d875ed9a7e638"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5MTY0OQ==", "bodyText": "So ... shouldn't thi have any impact on things? Such as stopping the rebalance or proposal preparation?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421091649", "createdAt": "2020-05-06T21:05:08Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaRebalance copy = new KafkaRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return kafkaRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, kafkaRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaRebalance patchedClusterRebalance = new KafkaRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return kafkaRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.debug(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance, State currentState,\n+                                                           RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                               String host, CruiseControlApi apiClient,\n+                                               RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                    String host, CruiseControlApi apiClient,\n+                                                    KafkaRebalance clusterRebalance,\n+                                                    RebalanceAnnotation rebalanceAnnotation,\n+                                                    RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            // the user fixed the error on the resource and want to \"refresh\", actually\n+            // requesting a new rebalance proposal\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            // stay in the current error state, actually failing the Future\n+            return Future.failedFuture(clusterRebalance.getStatus().getConditions().get(0).getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (rebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"{}: Optimization proposal ready\", reconciliation);\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"{}: Waiting for optimization proposal to be ready\", reconciliation);\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"{}: Cruise Control getting rebalance proposal failed\", reconciliation, rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"{}: Cruise Control getting rebalance resource failed\", reconciliation, getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                         String host, CruiseControlApi apiClient,\n+                                                         KafkaRebalance clusterRebalance,\n+                                                         RebalanceAnnotation rebalanceAnnotation,\n+                                                         RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+            default:\n+                log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Rebalancing} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n+     * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n+     * When the rebalance is finished, the next state is {@code Ready}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then move to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n+                                                       String host, CruiseControlApi apiClient,\n+                                                       KafkaRebalance clusterRebalance,\n+                                                       RebalanceAnnotation rebalanceAnnotation) {\n+        Promise<KafkaRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+            String sessionId = clusterRebalance.getStatus().getSessionId();\n+            AtomicInteger ccApiErrorCount = new AtomicInteger();\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                // Check that we have not already failed to contact the API beyond the allowed number of times.\n+                if (ccApiErrorCount.get() >= MAX_API_RETRIES) {\n+                    vertx.cancelTimer(t);\n+                    p.fail(new RuntimeException(\"Unable to reach Cruise Control API after \" + MAX_API_RETRIES + \" attempts\"));\n+                }\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.Rebalancing) {\n+                                if (rebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control rebalance user task\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    apiClient.stopExecution(host, CruiseControl.REST_API_PORT).setHandler(stopResult -> {\n+                                        if (stopResult.succeeded()) {\n+                                            p.complete(new KafkaRebalanceStatusBuilder()\n+                                                    .withSessionId(null)\n+                                                    .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                        } else {\n+                                            log.error(\"{}: Cruise Control stopping execution failed\", reconciliation, stopResult.cause());\n+                                            p.fail(stopResult.cause());\n+                                        }\n+                                    });\n+                                } else {\n+                                    log.info(\"{}: Getting Cruise Control rebalance user task status\", reconciliation);\n+                                    apiClient.getUserTaskStatus(host, CruiseControl.REST_API_PORT, sessionId).setHandler(userTaskResult -> {\n+                                        if (userTaskResult.succeeded()) {\n+                                            CruiseControlUserTaskResponse response = userTaskResult.result();\n+                                            JsonObject taskStatusJson = response.getJson();\n+                                            CruiseControlUserTaskStatus taskStatus;\n+                                            // Due to a bug in the CC rest API (https://github.com/linkedin/cruise-control/issues/1187), if we ask\n+                                            // for the status of a task that has COMPLETED_WITH_ERROR with fetch_completed_task=true, will will get\n+                                            // 500 error instead of the task status. So the client currently handles this case and sets a flag in\n+                                            // the CC response object.\n+                                            if (response.completedWithError()) {\n+                                                log.debug(\"{}: User tasks end-point returned {} for task: {}\", reconciliation,\n+                                                        CruiseControlUserTaskStatus.COMPLETED_WITH_ERROR, sessionId);\n+                                                taskStatus = CruiseControlUserTaskStatus.COMPLETED_WITH_ERROR;\n+                                            } else {\n+                                                String taskStatusStr = taskStatusJson.getString(\"Status\");\n+                                                taskStatus = CruiseControlUserTaskStatus.lookup(taskStatusStr);\n+                                            }\n+                                            switch (taskStatus) {\n+                                                case COMPLETED:\n+                                                    vertx.cancelTimer(t);\n+                                                    log.info(\"{}: Rebalance ({}) is now complete\", reconciliation, sessionId);\n+                                                    p.complete(new KafkaRebalanceStatusBuilder()\n+                                                            .withSessionId(null)\n+                                                            .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                            .addNewCondition().withType(State.Ready.toString()).endCondition().build());\n+                                                    break;\n+                                                case COMPLETED_WITH_ERROR:\n+                                                    // TODO: There doesn't seem to be a way to retrieve the actual error message from the user tasks endpoint?\n+                                                    //       We may need to propose an upstream PR for this.\n+                                                    // TODO: Once we can get the error details we need to add an error field to the Rebalance Status to hold\n+                                                    //       details of any issues while rebalancing.\n+                                                    log.error(\"{}: Rebalance ({}) optimization proposal has failed to complete\", reconciliation, sessionId);\n+                                                    vertx.cancelTimer(t);\n+                                                    p.complete(new KafkaRebalanceStatusBuilder()\n+                                                            .withSessionId(sessionId)\n+                                                            .addNewCondition().withType(State.NotReady.toString()).endCondition().build());\n+                                                    break;\n+                                                case IN_EXECUTION: // Rebalance is still in progress\n+                                                    // We need to check that the status has been updated with the ongoing optimisation proposal\n+                                                    // The proposal field can be empty if a rebalance(dryrun=false) was called and the optimisation\n+                                                    // proposal was still being prepared (in progress). In that case the rebalance will start when\n+                                                    // the proposal is complete but the optimisation proposal summary will be missing.\n+                                                    if (freshClusterRebalance.getStatus().getOptimizationResult() == null ||\n+                                                            freshClusterRebalance.getStatus().getOptimizationResult().isEmpty()) {\n+                                                        log.info(\"{}: Rebalance ({}) optimization proposal is now ready and has been added to the status\", reconciliation, sessionId);\n+                                                        // Cancel the timer so that the status is returned and updated.\n+                                                        vertx.cancelTimer(t);\n+                                                        p.complete(new KafkaRebalanceStatusBuilder()\n+                                                                .withSessionId(sessionId)\n+                                                                .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                                .addNewCondition().withType(State.Rebalancing.toString()).endCondition().build());\n+                                                    }\n+                                                    ccApiErrorCount.set(0);\n+                                                    // TODO: Find out if there is any way to check the progress of a rebalance.\n+                                                    //       We could parse the verbose proposal for total number of reassignments and compare to number completed (if available)?\n+                                                    //       We can then update the status at this point.\n+                                                    break;\n+                                                case ACTIVE: // Rebalance proposal is still being calculated\n+                                                    // If a rebalance(dryrun=false) was called and the proposal is still being prepared then the task\n+                                                    // will be in an ACTIVE state. When the proposal is ready it will shift to IN_EXECUTION and we will\n+                                                    // check that the optimisation proposal is added to the status on the next reconcile.\n+                                                    log.info(\"{}: Rebalance ({}) optimization proposal is still being prepared\", reconciliation, sessionId);\n+                                                    ccApiErrorCount.set(0);\n+                                                    break;\n+                                                default:\n+                                                    log.error(\"{}: Unexpected state {}\", reconciliation, taskStatus);\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(\"Unexpected state \" + taskStatus);\n+                                                    break;\n+                                            }\n+                                        } else {\n+                                            log.error(\"{}: Cruise Control getting rebalance task status failed\", reconciliation, userTaskResult.cause());\n+                                            // To make sure this error is not just a temporary problem with the network we retry several times.\n+                                            // If the number of errors pass the MAX_API_ERRORS limit then the period method will fail the promise.\n+                                            ccApiErrorCount.getAndIncrement();\n+                                        }\n+                                    });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"{}: Cruise Control getting rebalance resource failed\", reconciliation, getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Stopped} state.\n+     * If the user set strimzi.io/rebalance=refresh annotation, it calls the Cruise Control API for requesting a new rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onStop(Reconciliation reconciliation,\n+                                                String host, CruiseControlApi apiClient,\n+                                                RebalanceAnnotation rebalanceAnnotation,\n+                                                RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+        } else {\n+            log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+            return Future.succeededFuture(new KafkaRebalanceStatusBuilder()\n+                    .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+        }\n+    }\n+\n+    private Future<Void> reconcileRebalance(Reconciliation reconciliation, KafkaRebalance kafkaRebalance) {\n+        if (kafkaRebalance == null) {\n+            log.info(\"{}: Rebalance resource deleted\", reconciliation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "originalPosition": 708}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5NTc1MA==", "bodyText": "Wait, this sounds confusing ... this for sure does nto work synchronously but is checking the states with Cruise Control asynchronously at every reconciliation, or? So what entire period does the lock need to be hold?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421095750", "createdAt": "2020-05-06T21:12:53Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaRebalance copy = new KafkaRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72fcd17f64761a8bd4c852466f8d875ed9a7e638"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEwMTYyNw==", "bodyText": "Is the kafka-rebalance really what the users will be looking for?I'm not sure it says enougn. Why not just cruide-control. If nothing else I would cut the kafka- part since almost everything there is kafka-. But I think cruide-control or for example cluster-rebalancing would be more eye catching. A user who donwloads the examples and will see it will immediately know that we have something in this area.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421101627", "createdAt": "2020-05-06T21:24:28Z", "author": {"login": "scholzj"}, "path": "examples/kafka-rebalance/kafka-rebalance.yaml", "diffHunk": "@@ -0,0 +1,11 @@\n+apiVersion: kafka.strimzi.io/v1alpha1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72fcd17f64761a8bd4c852466f8d875ed9a7e638"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MjY3NzQw", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#pullrequestreview-407267740", "createdAt": "2020-05-07T08:44:24Z", "commit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwODo0NDoyNFrOGR0iEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwODo0NDoyNFrOGR0iEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzOTY2NA==", "bodyText": "This is fairly heavy use of the Kubernetes API if you poll this every few seconds. I wonder if this will cause any issues.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421339664", "createdAt": "2020-05-07T08:44:24Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaRebalance copy = new KafkaRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return kafkaRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, kafkaRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaRebalance patchedClusterRebalance = new KafkaRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return kafkaRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.debug(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance, State currentState,\n+                                                           RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                               String host, CruiseControlApi apiClient,\n+                                               RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                    String host, CruiseControlApi apiClient,\n+                                                    KafkaRebalance clusterRebalance,\n+                                                    RebalanceAnnotation rebalanceAnnotation,\n+                                                    RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            // the user fixed the error on the resource and want to \"refresh\", actually\n+            // requesting a new rebalance proposal\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            // stay in the current error state, actually failing the Future\n+            return Future.failedFuture(clusterRebalance.getStatus().getConditions().get(0).getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "originalPosition": 431}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3Mjc4MTE2", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#pullrequestreview-407278116", "createdAt": "2020-05-07T08:57:33Z", "commit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "state": "COMMENTED", "comments": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwODo1NzozM1rOGR1Dlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTo1MDoyM1rOGR3DaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM0ODI0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Description(\"The specification of the Kafka Rebalance.\")\n          \n          \n            \n                @Description(\"The specification of the Kafka rebalance.\")", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421348246", "createdAt": "2020-05-07T08:57:33Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaRebalance.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\n+import io.fabric8.kubernetes.api.model.Doneable;\n+import io.fabric8.kubernetes.api.model.ObjectMeta;\n+import io.fabric8.kubernetes.client.CustomResource;\n+import io.strimzi.api.kafka.model.status.HasStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.crdgenerator.annotations.Crd;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import io.sundr.builder.annotations.Inline;\n+import lombok.EqualsAndHashCode;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+\n+@JsonDeserialize\n+@Crd(\n+        apiVersion = KafkaRebalance.CRD_API_VERSION,\n+        spec = @Crd.Spec(\n+                names = @Crd.Spec.Names(\n+                        kind = KafkaRebalance.RESOURCE_KIND,\n+                        plural = KafkaRebalance.RESOURCE_PLURAL,\n+                        shortNames = {KafkaRebalance.SHORT_NAME}\n+                ),\n+                group = KafkaRebalance.RESOURCE_GROUP,\n+                scope = KafkaRebalance.SCOPE,\n+                version = KafkaRebalance.V1ALPHA1,\n+                versions = {\n+                        @Crd.Spec.Version(\n+                                name = KafkaRebalance.V1ALPHA1,\n+                                served = true,\n+                                storage = true\n+                        )\n+                },\n+                subresources = @Crd.Spec.Subresources(\n+                        status = @Crd.Spec.Subresources.Status()\n+                )\n+        )\n+)\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API,\n+        inline = @Inline(type = Doneable.class, prefix = \"Doneable\", value = \"done\")\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"apiVersion\", \"kind\", \"metadata\", \"spec\", \"status\"})\n+@EqualsAndHashCode\n+public class KafkaRebalance extends CustomResource implements UnknownPropertyPreserving, HasStatus<KafkaRebalanceStatus> {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String SCOPE = \"Namespaced\";\n+    public static final String V1ALPHA1 = Constants.V1ALPHA1;\n+    public static final List<String> VERSIONS = unmodifiableList(asList(V1ALPHA1));\n+    public static final String RESOURCE_KIND = \"KafkaRebalance\";\n+    public static final String RESOURCE_LIST_KIND = RESOURCE_KIND + \"List\";\n+    public static final String RESOURCE_GROUP = Constants.RESOURCE_GROUP_NAME;\n+    public static final String RESOURCE_PLURAL = \"kafkarebalances\";\n+    public static final String RESOURCE_SINGULAR = \"kafkarebalance\";\n+    public static final String CRD_API_VERSION = Constants.V1BETA1_API_VERSION;\n+    public static final String CRD_NAME = RESOURCE_PLURAL + \".\" + RESOURCE_GROUP;\n+    public static final String SHORT_NAME = \"kr\";\n+    public static final List<String> RESOURCE_SHORTNAMES = singletonList(SHORT_NAME);\n+\n+    private String apiVersion;\n+    private ObjectMeta metadata;\n+    private KafkaRebalanceSpec spec;\n+    private KafkaRebalanceStatus status;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonProperty(\"kind\")\n+    @Override\n+    public String getKind() {\n+        return RESOURCE_KIND;\n+    }\n+\n+    @Override\n+    public String getApiVersion() {\n+        return apiVersion;\n+    }\n+\n+    @Override\n+    public void setApiVersion(String apiVersion) {\n+        this.apiVersion = apiVersion;\n+    }\n+\n+    @Override\n+    public ObjectMeta getMetadata() {\n+        return super.getMetadata();\n+    }\n+\n+    @Override\n+    public void setMetadata(ObjectMeta metadata) {\n+        super.setMetadata(metadata);\n+    }\n+\n+    @Description(\"The specification of the Kafka Rebalance.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM0ODM1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Description(\"The status of the Kafka Rebalance.\")\n          \n          \n            \n                @Description(\"The status of the Kafka rebalance.\")", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421348357", "createdAt": "2020-05-07T08:57:45Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaRebalance.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\n+import io.fabric8.kubernetes.api.model.Doneable;\n+import io.fabric8.kubernetes.api.model.ObjectMeta;\n+import io.fabric8.kubernetes.client.CustomResource;\n+import io.strimzi.api.kafka.model.status.HasStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.crdgenerator.annotations.Crd;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import io.sundr.builder.annotations.Inline;\n+import lombok.EqualsAndHashCode;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+\n+@JsonDeserialize\n+@Crd(\n+        apiVersion = KafkaRebalance.CRD_API_VERSION,\n+        spec = @Crd.Spec(\n+                names = @Crd.Spec.Names(\n+                        kind = KafkaRebalance.RESOURCE_KIND,\n+                        plural = KafkaRebalance.RESOURCE_PLURAL,\n+                        shortNames = {KafkaRebalance.SHORT_NAME}\n+                ),\n+                group = KafkaRebalance.RESOURCE_GROUP,\n+                scope = KafkaRebalance.SCOPE,\n+                version = KafkaRebalance.V1ALPHA1,\n+                versions = {\n+                        @Crd.Spec.Version(\n+                                name = KafkaRebalance.V1ALPHA1,\n+                                served = true,\n+                                storage = true\n+                        )\n+                },\n+                subresources = @Crd.Spec.Subresources(\n+                        status = @Crd.Spec.Subresources.Status()\n+                )\n+        )\n+)\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API,\n+        inline = @Inline(type = Doneable.class, prefix = \"Doneable\", value = \"done\")\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"apiVersion\", \"kind\", \"metadata\", \"spec\", \"status\"})\n+@EqualsAndHashCode\n+public class KafkaRebalance extends CustomResource implements UnknownPropertyPreserving, HasStatus<KafkaRebalanceStatus> {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String SCOPE = \"Namespaced\";\n+    public static final String V1ALPHA1 = Constants.V1ALPHA1;\n+    public static final List<String> VERSIONS = unmodifiableList(asList(V1ALPHA1));\n+    public static final String RESOURCE_KIND = \"KafkaRebalance\";\n+    public static final String RESOURCE_LIST_KIND = RESOURCE_KIND + \"List\";\n+    public static final String RESOURCE_GROUP = Constants.RESOURCE_GROUP_NAME;\n+    public static final String RESOURCE_PLURAL = \"kafkarebalances\";\n+    public static final String RESOURCE_SINGULAR = \"kafkarebalance\";\n+    public static final String CRD_API_VERSION = Constants.V1BETA1_API_VERSION;\n+    public static final String CRD_NAME = RESOURCE_PLURAL + \".\" + RESOURCE_GROUP;\n+    public static final String SHORT_NAME = \"kr\";\n+    public static final List<String> RESOURCE_SHORTNAMES = singletonList(SHORT_NAME);\n+\n+    private String apiVersion;\n+    private ObjectMeta metadata;\n+    private KafkaRebalanceSpec spec;\n+    private KafkaRebalanceStatus status;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonProperty(\"kind\")\n+    @Override\n+    public String getKind() {\n+        return RESOURCE_KIND;\n+    }\n+\n+    @Override\n+    public String getApiVersion() {\n+        return apiVersion;\n+    }\n+\n+    @Override\n+    public void setApiVersion(String apiVersion) {\n+        this.apiVersion = apiVersion;\n+    }\n+\n+    @Override\n+    public ObjectMeta getMetadata() {\n+        return super.getMetadata();\n+    }\n+\n+    @Override\n+    public void setMetadata(ObjectMeta metadata) {\n+        super.setMetadata(metadata);\n+    }\n+\n+    @Description(\"The specification of the Kafka Rebalance.\")\n+    public KafkaRebalanceSpec getSpec() {\n+        return spec;\n+    }\n+\n+    public void setSpec(KafkaRebalanceSpec spec) {\n+        this.spec = spec;\n+    }\n+\n+    @Override\n+    @Description(\"The status of the Kafka Rebalance.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MDA5MA==", "bodyText": "Yeah, there is potentially a difference between not specifying the goals at all vs. specifying an empty list. If you're wanting to treat them as the same thing that's fine, but it's not a decision you can change later. From my understanding it wouldn't make sense to ask for a rebalance with no goals, so I think it's fine to conflate the two.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421350090", "createdAt": "2020-05-07T09:00:27Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaRebalanceSpec.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({ \"goals\", \"skipHardGoalCheck\" })\n+@EqualsAndHashCode\n+public class KafkaRebalanceSpec implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private List<String> goals;\n+    private boolean skipHardGoalCheck;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"A list of goals, ordered by decreasing priority, to use for generating and executing the rebalance proposal.\" +\n+            \"The supported goals are available at https://github.com/linkedin/cruise-control#goals.\" +\n+            \"If an empty goals list is provided, the goals declared in the default.goals Cruise Control configuration parameter are used.\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTg2MA=="}, "originalCommit": {"oid": "72fcd17f64761a8bd4c852466f8d875ed9a7e638"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MDc1MA==", "bodyText": "Out of interest what's the use case for skipping hard goals. On the face of it skipping a hard goal is worse than skipping a soft goal. It might be worth mentioning this in the @Description.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421350750", "createdAt": "2020-05-07T09:01:29Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaRebalanceSpec.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({ \"goals\", \"skipHardGoalCheck\" })\n+@EqualsAndHashCode\n+public class KafkaRebalanceSpec implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private List<String> goals;\n+    private boolean skipHardGoalCheck;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"A list of goals, ordered by decreasing priority, to use for generating and executing the rebalance proposal.\" +\n+            \"The supported goals are available at https://github.com/linkedin/cruise-control#goals.\" +\n+            \"If an empty goals list is provided, the goals declared in the default.goals Cruise Control configuration parameter are used.\")\n+    public List<String> getGoals() {\n+        return goals;\n+    }\n+\n+    public void setGoals(List<String> goals) {\n+        this.goals = goals;\n+    }\n+\n+    @Description(\"Whether to allow hard goals to be skipped in rebalance proposal generation. Default is false.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MTA2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Description(\"A JSON describing the optimization result\")\n          \n          \n            \n                @Description(\"A JSON object describing the optimization result\")", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421351067", "createdAt": "2020-05-07T09:02:06Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/status/KafkaRebalanceStatus.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.status;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+import lombok.ToString;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Represents a status of the Kafka Rebalance resource\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({ \"conditions\", \"observedGeneration\", \"sessionId\", \"optimizationResult\" })\n+@EqualsAndHashCode\n+@ToString(callSuper = true)\n+public class KafkaRebalanceStatus extends Status {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private String sessionId;\n+    private Map<String, Object> optimizationResult = new HashMap<>(0);\n+\n+    @Description(\"A JSON describing the optimization result\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MjUxMQ==", "bodyText": "Which is great and true today, but there's no harm in adding a null check in case it's not true tomorrow. Remember, the more distant the place where you know the value is always set then the more fragile it is to a future change violating the non-nullness.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421352511", "createdAt": "2020-05-07T09:04:32Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -227,16 +237,64 @@ public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup ver\n     }\n \n     public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n-        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n-        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n-            if (configuration.getConfigOption(entry.getKey()) == null) {\n-                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+        CruiseControlConfiguration userConfiguration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> defaultEntry : userConfiguration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (userConfiguration.getConfigOption(defaultEntry.getKey()) == null) {\n+                userConfiguration.setConfigOption(defaultEntry.getKey(), defaultEntry.getValue());\n             }\n         }\n-        cruiseControl.setConfiguration(configuration);\n+        // Ensure that the configured anomaly.detection.goals are a sub-set of the default goals\n+        checkGoals(userConfiguration);\n+        cruiseControl.setConfiguration(userConfiguration);\n         return cruiseControl;\n     }\n \n+    /**\n+     *  This method ensures that the checks in cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java\n+     *  sanityCheckGoalNames() method (L118)  don't fail if a user submits custom default goals that have less members then the default\n+     *  anomaly.detection.goals.\n+     * @param configuration The configuration instance to be checked.\n+     * @throws UnsupportedOperationException If the configuration contains self.healing.goals configurations.\n+     */\n+    public static void checkGoals(CruiseControlConfiguration configuration) {\n+        // If self healing goals are defined then these take precedence\n+        if (configuration.getConfigOption(CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY) != null) {\n+            String selfHealingGoalsString = configuration.getConfigOption(CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY);\n+            List<String> selfHealingGoals = Arrays.asList(selfHealingGoalsString.split(\"\\\\s*,\\\\s*\"));\n+            if (!selfHealingGoals.isEmpty()) {\n+                throw new UnsupportedOperationException(\"Cruise Control's self healing functionality is not currently supported. Please remove \" +\n+                        CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY + \" config\");\n+            }\n+        }\n+\n+        // Either self.healing.goals is null or it is an empty list\n+        String anomalyGoalsString;\n+        if (configuration.getConfigOption(CRUISE_CONTROL_ANOMALY_DETECTION_CONFIG_KEY) != null) {\n+            // The user has defined some anomaly detection goals\n+            anomalyGoalsString = configuration.getConfigOption(CRUISE_CONTROL_ANOMALY_DETECTION_CONFIG_KEY);\n+        } else {\n+            // No anomaly detection goals have been defined by the user, therefore the defaults defined in Cruise Control\n+            // will be used.\n+            anomalyGoalsString = CRUISE_CONTROL_DEFAULT_ANOMALY_DETECTION_GOALS;\n+        }\n+\n+        Set<String> anomalyDetectionGoals = new HashSet<>(Arrays.asList(anomalyGoalsString.split(\"\\\\s*,\\\\s*\")));\n+\n+        String defaultGoalsString = configuration.getConfigOption(CRUISE_CONTROL_DEFAULT_GOALS_CONFIG_KEY);\n+        Set<String> defaultGoals = new HashSet<>(Arrays.asList(defaultGoalsString.split(\"\\\\s*,\\\\s*\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwODEyMQ=="}, "originalCommit": {"oid": "e1cad47d1a4f70a812e14895e8d1eb09a3964095"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MzYzOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (anomalyDetectionGoals.size() > 0) {\n          \n          \n            \n                    if (!anomalyDetectionGoals.isEmpty()) {", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421353638", "createdAt": "2020-05-07T09:06:27Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -226,16 +236,56 @@ public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup ver\n     }\n \n     public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n-        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n-        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n-            if (configuration.getConfigOption(entry.getKey()) == null) {\n-                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+        CruiseControlConfiguration userConfiguration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> defaultEntry : userConfiguration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (userConfiguration.getConfigOption(defaultEntry.getKey()) == null) {\n+                userConfiguration.setConfigOption(defaultEntry.getKey(), defaultEntry.getValue());\n             }\n         }\n-        cruiseControl.setConfiguration(configuration);\n+        // Ensure that the configured anomaly.detection.goals are a sub-set of the default goals\n+        checkGoals(userConfiguration);\n+        cruiseControl.setConfiguration(userConfiguration);\n         return cruiseControl;\n     }\n \n+    /**\n+     *  This method ensures that the checks in cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java\n+     *  sanityCheckGoalNames() method (L118)  don't fail if a user submits custom default goals that have less members then the default\n+     *  anomaly.detection.goals.\n+     * @param configuration The configuration instance to be checked.\n+     * @throws UnsupportedOperationException If the configuration contains self.healing.goals configurations.\n+     */\n+    public static void checkGoals(CruiseControlConfiguration configuration) {\n+        // If self healing goals are defined then these take precedence.\n+        // Right now, self.healing.goals must either be null or an empty list\n+        if (configuration.getConfigOption(CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY) != null) {\n+            String selfHealingGoalsString = configuration.getConfigOption(CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY);\n+            List<String> selfHealingGoals = Arrays.asList(selfHealingGoalsString.split(\"\\\\s*,\\\\s*\"));\n+            if (!selfHealingGoals.isEmpty()) {\n+                throw new UnsupportedOperationException(\"Cruise Control's self healing functionality is not currently supported. Please remove \" +\n+                        CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY + \" config\");\n+            }\n+        }\n+\n+        // If no anomaly detection goals have been defined by the user, the defaults defined in Cruise Control will be used.\n+        String anomalyGoalsString = configuration.getConfigOption(CRUISE_CONTROL_ANOMALY_DETECTION_CONFIG_KEY, CRUISE_CONTROL_DEFAULT_ANOMALY_DETECTION_GOALS);\n+        Set<String> anomalyDetectionGoals = new HashSet<>(Arrays.asList(anomalyGoalsString.split(\"\\\\s*,\\\\s*\")));\n+\n+        String defaultGoalsString = configuration.getConfigOption(CRUISE_CONTROL_DEFAULT_GOALS_CONFIG_KEY);\n+        Set<String> defaultGoals = new HashSet<>(Arrays.asList(defaultGoalsString.split(\"\\\\s*,\\\\s*\")));\n+\n+        // Remove all the goals which are present in the default goals set from the anomaly detection goals\n+        anomalyDetectionGoals.removeAll(defaultGoals);\n+\n+        if (anomalyDetectionGoals.size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2MTUxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             * <pre><code>\n          \n          \n            \n             *   User        Kube           Operator              CC\n          \n          \n            \n             *    | Create KR  |               |                   |\n          \n          \n            \n             *    |----------->|   Watch       |                   |\n          \n          \n            \n             *    |            |-------------->|   Proposal        |\n          \n          \n            \n             *    |            |               |------------------>|\n          \n          \n            \n             *    |            |               |   Poll            |\n          \n          \n            \n             *    |            |               |------------------>|\n          \n          \n            \n             *    |            |               |   Poll            |\n          \n          \n            \n             *    |            | Update Status |------------------>|\n          \n          \n            \n             *    |            |<--------------|                   |\n          \n          \n            \n             *    |            |   Watch       |                   |\n          \n          \n            \n             *    |            |-------------->|                   |\n          \n          \n            \n             *    | Get        |               |                   |\n          \n          \n            \n             *    |----------->|               |                   |\n          \n          \n            \n             *    |            |               |                   |\n          \n          \n            \n             *    | Approve    |               |                   |\n          \n          \n            \n             *    |----------->|  Watch        |                   |\n          \n          \n            \n             *    |            |-------------->|   Rebalance       |\n          \n          \n            \n             *    |            |               |------------------>|\n          \n          \n            \n             *    |            |               |   Poll            |\n          \n          \n            \n             *    |            |               |------------------>|\n          \n          \n            \n             *    |            |               |   Poll            |\n          \n          \n            \n             *    |            | Update Status |------------------>|\n          \n          \n            \n             *    |            |<--------------|                   |\n          \n          \n            \n             *    |            |   Watch       |                   |\n          \n          \n            \n             *    |            |-------------->|                   |\n          \n          \n            \n             *    | Get        |               |                   |\n          \n          \n            \n             *    |----------->|               |                   |\n          \n          \n            \n             * </code></pre>", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421361514", "createdAt": "2020-05-07T09:19:02Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2Mjc4NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String ccHost = null;\n          \n          \n            \n                private final String ccHost = null;", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421362784", "createdAt": "2020-05-07T09:21:01Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NDAxMg==", "bodyText": "Can you do this by:\n\nHaving a protected method to return the ccHost() at the point you need it. Impl in this class returns the service address.\nUse a subclass for the test which returns something else?\n\nThat would be neater than having this field which we don't actually need in the production code.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421364012", "createdAt": "2020-05-07T09:22:58Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NTc4OQ==", "bodyText": "I still feel, like Jakub, that this is fragile. Let's do the right thing and fnd the condition that we're interested in rather than assuming that there is a nonempty list of conditions and that the one we want is the first.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421365789", "createdAt": "2020-05-07T09:25:45Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NjUxMQ==", "bodyText": "Surely the idiomatic way to do this is to set the status in the builder, rather than build and then set? Then you can inline the whole builder expression and you only need one line where you currently have 3.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421366511", "createdAt": "2020-05-07T09:26:53Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaRebalance copy = new KafkaRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MTU2OQ==", "bodyText": "How long the proposal takes will depend on many factors. I don't think we really have enough experience of the parameter space to have any intuition, but I think days is unlikely. Seconds, minutes and hours all seem likely.\nBut using a 2nd timer we are, in effect, optimising the <2 minutes case. We can form a judgement about whether this is the right way to do it when we have more experience.\nWhether a 2nd timer takes up much resources is something else where we have no data.\n\nSo I think it's better to keep it as it is and be open to revising this later when we have more of a feeling for these things. Another option would be to add some websocket notification endpoint to CC so it could tell us without our needing to poll.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421371569", "createdAt": "2020-05-07T09:35:04Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaRebalance copy = new KafkaRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5NTc1MA=="}, "originalCommit": {"oid": "72fcd17f64761a8bd4c852466f8d875ed9a7e638"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MzAxMQ==", "bodyText": "Similar to the previous comment, this looks like an NPE waiting to happen. However you obtain the condition, you should factor this chain of gets into a method.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421373011", "createdAt": "2020-05-07T09:37:32Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaRebalance copy = new KafkaRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return kafkaRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, kafkaRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3NTMxNg==", "bodyText": "It's a valid point. One thing we could do would be to utilise the watch we've already got to store the latest version when it changes and here to retrieve that. A little care other threading would be needed, but it wouldn't put any extra load on k8s.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421375316", "createdAt": "2020-05-07T09:41:14Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaRebalance copy = new KafkaRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return kafkaRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, kafkaRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaRebalance patchedClusterRebalance = new KafkaRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return kafkaRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.debug(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance, State currentState,\n+                                                           RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                               String host, CruiseControlApi apiClient,\n+                                               RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                    String host, CruiseControlApi apiClient,\n+                                                    KafkaRebalance clusterRebalance,\n+                                                    RebalanceAnnotation rebalanceAnnotation,\n+                                                    RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            // the user fixed the error on the resource and want to \"refresh\", actually\n+            // requesting a new rebalance proposal\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            // stay in the current error state, actually failing the Future\n+            return Future.failedFuture(clusterRebalance.getStatus().getConditions().get(0).getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzOTY2NA=="}, "originalCommit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "originalPosition": 431}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3NjAzMg==", "bodyText": "logging for these two cases?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421376032", "createdAt": "2020-05-07T09:42:28Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaRebalance copy = new KafkaRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return kafkaRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, kafkaRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaRebalance patchedClusterRebalance = new KafkaRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return kafkaRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.debug(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance, State currentState,\n+                                                           RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                               String host, CruiseControlApi apiClient,\n+                                               RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                    String host, CruiseControlApi apiClient,\n+                                                    KafkaRebalance clusterRebalance,\n+                                                    RebalanceAnnotation rebalanceAnnotation,\n+                                                    RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            // the user fixed the error on the resource and want to \"refresh\", actually\n+            // requesting a new rebalance proposal\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            // stay in the current error state, actually failing the Future\n+            return Future.failedFuture(clusterRebalance.getStatus().getConditions().get(0).getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (rebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"{}: Optimization proposal ready\", reconciliation);\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"{}: Waiting for optimization proposal to be ready\", reconciliation);\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"{}: Cruise Control getting rebalance proposal failed\", reconciliation, rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"{}: Cruise Control getting rebalance resource failed\", reconciliation, getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                         String host, CruiseControlApi apiClient,\n+                                                         KafkaRebalance clusterRebalance,\n+                                                         RebalanceAnnotation rebalanceAnnotation,\n+                                                         RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "originalPosition": 517}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3ODAzMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Return the {@code RebalanceAnnotation} enum value for the raw String value of the strimzio.io/rebalance annotation\n          \n          \n            \n                 * Return the {@code RebalanceAnnotation} enum value for the raw String value of the strimz.io/rebalance annotation", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421378030", "createdAt": "2020-05-07T09:45:41Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaRebalance copy = new KafkaRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return kafkaRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, kafkaRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaRebalance patchedClusterRebalance = new KafkaRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return kafkaRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.debug(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance, State currentState,\n+                                                           RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                               String host, CruiseControlApi apiClient,\n+                                               RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                    String host, CruiseControlApi apiClient,\n+                                                    KafkaRebalance clusterRebalance,\n+                                                    RebalanceAnnotation rebalanceAnnotation,\n+                                                    RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            // the user fixed the error on the resource and want to \"refresh\", actually\n+            // requesting a new rebalance proposal\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            // stay in the current error state, actually failing the Future\n+            return Future.failedFuture(clusterRebalance.getStatus().getConditions().get(0).getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (rebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"{}: Optimization proposal ready\", reconciliation);\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"{}: Waiting for optimization proposal to be ready\", reconciliation);\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"{}: Cruise Control getting rebalance proposal failed\", reconciliation, rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"{}: Cruise Control getting rebalance resource failed\", reconciliation, getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                         String host, CruiseControlApi apiClient,\n+                                                         KafkaRebalance clusterRebalance,\n+                                                         RebalanceAnnotation rebalanceAnnotation,\n+                                                         RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+            default:\n+                log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Rebalancing} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n+     * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n+     * When the rebalance is finished, the next state is {@code Ready}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then move to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n+                                                       String host, CruiseControlApi apiClient,\n+                                                       KafkaRebalance clusterRebalance,\n+                                                       RebalanceAnnotation rebalanceAnnotation) {\n+        Promise<KafkaRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+            String sessionId = clusterRebalance.getStatus().getSessionId();\n+            AtomicInteger ccApiErrorCount = new AtomicInteger();\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                // Check that we have not already failed to contact the API beyond the allowed number of times.\n+                if (ccApiErrorCount.get() >= MAX_API_RETRIES) {\n+                    vertx.cancelTimer(t);\n+                    p.fail(new RuntimeException(\"Unable to reach Cruise Control API after \" + MAX_API_RETRIES + \" attempts\"));\n+                }\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.Rebalancing) {\n+                                if (rebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control rebalance user task\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    apiClient.stopExecution(host, CruiseControl.REST_API_PORT).setHandler(stopResult -> {\n+                                        if (stopResult.succeeded()) {\n+                                            p.complete(new KafkaRebalanceStatusBuilder()\n+                                                    .withSessionId(null)\n+                                                    .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                        } else {\n+                                            log.error(\"{}: Cruise Control stopping execution failed\", reconciliation, stopResult.cause());\n+                                            p.fail(stopResult.cause());\n+                                        }\n+                                    });\n+                                } else {\n+                                    log.info(\"{}: Getting Cruise Control rebalance user task status\", reconciliation);\n+                                    apiClient.getUserTaskStatus(host, CruiseControl.REST_API_PORT, sessionId).setHandler(userTaskResult -> {\n+                                        if (userTaskResult.succeeded()) {\n+                                            CruiseControlUserTaskResponse response = userTaskResult.result();\n+                                            JsonObject taskStatusJson = response.getJson();\n+                                            CruiseControlUserTaskStatus taskStatus;\n+                                            // Due to a bug in the CC rest API (https://github.com/linkedin/cruise-control/issues/1187), if we ask\n+                                            // for the status of a task that has COMPLETED_WITH_ERROR with fetch_completed_task=true, will will get\n+                                            // 500 error instead of the task status. So the client currently handles this case and sets a flag in\n+                                            // the CC response object.\n+                                            if (response.completedWithError()) {\n+                                                log.debug(\"{}: User tasks end-point returned {} for task: {}\", reconciliation,\n+                                                        CruiseControlUserTaskStatus.COMPLETED_WITH_ERROR, sessionId);\n+                                                taskStatus = CruiseControlUserTaskStatus.COMPLETED_WITH_ERROR;\n+                                            } else {\n+                                                String taskStatusStr = taskStatusJson.getString(\"Status\");\n+                                                taskStatus = CruiseControlUserTaskStatus.lookup(taskStatusStr);\n+                                            }\n+                                            switch (taskStatus) {\n+                                                case COMPLETED:\n+                                                    vertx.cancelTimer(t);\n+                                                    log.info(\"{}: Rebalance ({}) is now complete\", reconciliation, sessionId);\n+                                                    p.complete(new KafkaRebalanceStatusBuilder()\n+                                                            .withSessionId(null)\n+                                                            .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                            .addNewCondition().withType(State.Ready.toString()).endCondition().build());\n+                                                    break;\n+                                                case COMPLETED_WITH_ERROR:\n+                                                    // TODO: There doesn't seem to be a way to retrieve the actual error message from the user tasks endpoint?\n+                                                    //       We may need to propose an upstream PR for this.\n+                                                    // TODO: Once we can get the error details we need to add an error field to the Rebalance Status to hold\n+                                                    //       details of any issues while rebalancing.\n+                                                    log.error(\"{}: Rebalance ({}) optimization proposal has failed to complete\", reconciliation, sessionId);\n+                                                    vertx.cancelTimer(t);\n+                                                    p.complete(new KafkaRebalanceStatusBuilder()\n+                                                            .withSessionId(sessionId)\n+                                                            .addNewCondition().withType(State.NotReady.toString()).endCondition().build());\n+                                                    break;\n+                                                case IN_EXECUTION: // Rebalance is still in progress\n+                                                    // We need to check that the status has been updated with the ongoing optimisation proposal\n+                                                    // The proposal field can be empty if a rebalance(dryrun=false) was called and the optimisation\n+                                                    // proposal was still being prepared (in progress). In that case the rebalance will start when\n+                                                    // the proposal is complete but the optimisation proposal summary will be missing.\n+                                                    if (freshClusterRebalance.getStatus().getOptimizationResult() == null ||\n+                                                            freshClusterRebalance.getStatus().getOptimizationResult().isEmpty()) {\n+                                                        log.info(\"{}: Rebalance ({}) optimization proposal is now ready and has been added to the status\", reconciliation, sessionId);\n+                                                        // Cancel the timer so that the status is returned and updated.\n+                                                        vertx.cancelTimer(t);\n+                                                        p.complete(new KafkaRebalanceStatusBuilder()\n+                                                                .withSessionId(sessionId)\n+                                                                .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                                .addNewCondition().withType(State.Rebalancing.toString()).endCondition().build());\n+                                                    }\n+                                                    ccApiErrorCount.set(0);\n+                                                    // TODO: Find out if there is any way to check the progress of a rebalance.\n+                                                    //       We could parse the verbose proposal for total number of reassignments and compare to number completed (if available)?\n+                                                    //       We can then update the status at this point.\n+                                                    break;\n+                                                case ACTIVE: // Rebalance proposal is still being calculated\n+                                                    // If a rebalance(dryrun=false) was called and the proposal is still being prepared then the task\n+                                                    // will be in an ACTIVE state. When the proposal is ready it will shift to IN_EXECUTION and we will\n+                                                    // check that the optimisation proposal is added to the status on the next reconcile.\n+                                                    log.info(\"{}: Rebalance ({}) optimization proposal is still being prepared\", reconciliation, sessionId);\n+                                                    ccApiErrorCount.set(0);\n+                                                    break;\n+                                                default:\n+                                                    log.error(\"{}: Unexpected state {}\", reconciliation, taskStatus);\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(\"Unexpected state \" + taskStatus);\n+                                                    break;\n+                                            }\n+                                        } else {\n+                                            log.error(\"{}: Cruise Control getting rebalance task status failed\", reconciliation, userTaskResult.cause());\n+                                            // To make sure this error is not just a temporary problem with the network we retry several times.\n+                                            // If the number of errors pass the MAX_API_ERRORS limit then the period method will fail the promise.\n+                                            ccApiErrorCount.getAndIncrement();\n+                                        }\n+                                    });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"{}: Cruise Control getting rebalance resource failed\", reconciliation, getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Stopped} state.\n+     * If the user set strimzi.io/rebalance=refresh annotation, it calls the Cruise Control API for requesting a new rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onStop(Reconciliation reconciliation,\n+                                                String host, CruiseControlApi apiClient,\n+                                                RebalanceAnnotation rebalanceAnnotation,\n+                                                RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+        } else {\n+            log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+            return Future.succeededFuture(new KafkaRebalanceStatusBuilder()\n+                    .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+        }\n+    }\n+\n+    private Future<Void> reconcileRebalance(Reconciliation reconciliation, KafkaRebalance kafkaRebalance) {\n+        if (kafkaRebalance == null) {\n+            log.info(\"{}: Rebalance resource deleted\", reconciliation);\n+            return Future.succeededFuture();\n+        } else {\n+            String clusterName = kafkaRebalance.getMetadata().getLabels() == null ? null : kafkaRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+            String clusterNamespace = kafkaRebalance.getMetadata().getNamespace();\n+            if (clusterName != null) {\n+                return kafkaOperator.getAsync(clusterNamespace, clusterName)\n+                        .compose(kafka -> {\n+                            if (kafka == null) {\n+                                log.warn(\"{}: Kafka resource '{}' identified by label '{}' does not exist in namespace {}.\",\n+                                        reconciliation, clusterName, Labels.STRIMZI_CLUSTER_LABEL, clusterNamespace);\n+                                return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator,\n+                                        new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                + \"' does not exist in namespace \" + clusterNamespace + \".\")).mapEmpty();\n+                            } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                return kafkaRebalanceOperator.getAsync(kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName())\n+                                        .compose(fetchedClusterRebalance -> {\n+                                            KafkaRebalanceStatus clusterRebalanceStatus = fetchedClusterRebalance.getStatus();\n+                                            // cluster rebalance is new or it is in one of others states\n+                                            State currentState = clusterRebalanceStatus == null ? State.New :\n+                                                    State.valueOf(clusterRebalanceStatus.getConditions().get(0).getType());\n+                                            // check annotation\n+                                            RebalanceAnnotation rebalanceAnnotation = rebalanceAnnotation(fetchedClusterRebalance);\n+                                            return reconcile(reconciliation, ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost, apiClient, fetchedClusterRebalance, currentState, rebalanceAnnotation).mapEmpty();\n+                                        }, exception -> Future.failedFuture(exception).mapEmpty());\n+\n+                            } else {\n+                                log.warn(\"{}: Kafka resouce lacks 'cruiseControl' declaration : No deployed Cruise Control for doing a rebalance.\", reconciliation);\n+                                return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator,\n+                                        new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                + \": No deployed Cruise Control for doing a rebalance.\")).mapEmpty();\n+                            }\n+                        }, exception -> updateStatus(kafkaRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception).mapEmpty());\n+            } else {\n+                log.warn(\"{}: Resource lacks label '{}': No cluster related to a possible rebalance.\", reconciliation, Labels.STRIMZI_CLUSTER_LABEL);\n+                return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator,\n+                        new InvalidResourceException(\"Resource lacks label '\"\n+                                + Labels.STRIMZI_CLUSTER_LABEL\n+                                + \"': No cluster related to a possible rebalance.\")).mapEmpty();\n+            }\n+        }\n+\n+    }\n+\n+    private Future<KafkaRebalanceStatus> requestRebalance(Reconciliation reconciliation,\n+                                                          String host, CruiseControlApi apiClient,\n+                                                          boolean dryrun, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, dryrun, rebalanceOptionsBuilder, null);\n+    }\n+\n+    private Future<KafkaRebalanceStatus> requestRebalance(Reconciliation reconciliation, String host, CruiseControlApi apiClient,\n+                                                          boolean dryrun, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder, String userTaskID) {\n+\n+        log.info(\"{}: Requesting Cruise Control rebalance [dryrun={}]\", reconciliation, dryrun);\n+        if (!dryrun) {\n+            rebalanceOptionsBuilder.withFullRun();\n+        }\n+        return apiClient.rebalance(host, CruiseControl.REST_API_PORT, rebalanceOptionsBuilder.build(), userTaskID)\n+                .map(response -> {\n+                    if (dryrun) {\n+                        if (response.thereIsNotEnoughDataForProposal() || response.proposalIsStillCalculating()) {\n+                            // If either there not enough data for a rebalance or it is still being processed we need to\n+                            // re-request the proposal at a later stage so we move to the PendingProposal State.\n+                            return new KafkaRebalanceStatusBuilder()\n+                                    .withNewSessionId(response.getUserTaskId())\n+                                    .addNewCondition().withNewType(State.PendingProposal.toString()).endCondition().build();\n+                        }\n+                    } else {\n+                        if (response.thereIsNotEnoughDataForProposal()) {\n+                            // We do not include a session id with this status as we do not want to retrieve the state of\n+                            // this failed tasks (COMPLETED_WITH_ERROR)\n+                            return new KafkaRebalanceStatusBuilder()\n+                                    .addNewCondition().withNewType(State.PendingProposal.toString()).endCondition().build();\n+                        } else if (response.proposalIsStillCalculating()) {\n+                            return new KafkaRebalanceStatusBuilder()\n+                                    .withNewSessionId(response.getUserTaskId())\n+                                    .addNewCondition().withNewType(State.Rebalancing.toString()).endCondition().build();\n+                        }\n+                    }\n+\n+                    if (response.getJson().containsKey(CC_REST_API_SUMMARY)) {\n+                        // If there is enough data and the proposal is complete (the response has the \"summary\" key) then we move\n+                        // to ProposalReady for a dry run or to the Rebalancing state for a full run\n+                        State ready = dryrun ? State.ProposalReady : State.Rebalancing;\n+                        return new KafkaRebalanceStatusBuilder()\n+                                .withNewSessionId(response.getUserTaskId())\n+                                .withOptimizationResult(response.getJson().getJsonObject(CC_REST_API_SUMMARY).getMap())\n+                                .addNewCondition().withNewType(ready.toString()).endCondition().build();\n+                    } else {\n+                        throw new RuntimeException(\"Rebalance returned unknown response: \" + response.toString());\n+                    }\n+                }).otherwise(t -> {\n+                    throw new RuntimeException(t.getMessage());\n+                });\n+    }\n+\n+    /**\n+     * Return the {@code RebalanceAnnotation} enum value for the raw String value of the strimzio.io/rebalance annotation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "originalPosition": 808}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3ODE1OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * returns {@code RebalanceAnnotation.unknown}\n          \n          \n            \n                 * returns {@code RebalanceAnnotation.unknown}.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421378158", "createdAt": "2020-05-07T09:45:53Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus,\n+                    desiredStatus.getConditions().get(0).getType());\n+        } else {\n+            throw new IllegalArgumentException(\"Status related exception and type cannot be both null\");\n+        }\n+        StatusDiff diff = new StatusDiff(clusterRebalance.getStatus(), desiredStatus);\n+        if (!diff.isEmpty()) {\n+            KafkaRebalance copy = new KafkaRebalanceBuilder(clusterRebalance).build();\n+            copy.setStatus(desiredStatus);\n+            return clusterRebalanceOperations.updateStatusAsync(copy);\n+        }\n+        return Future.succeededFuture(clusterRebalance);\n+    }\n+\n+    enum State {\n+        /**\n+         * The resource has not been observed by the operator before.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the proposal request was made and it's not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the proposal request was made and it's already ready.</dd>\n+         *     <dt>NotReady</dt><dd>If the resource is invalid and a request could not be made.</dd>\n+         * </dl>\n+         */\n+        New,\n+        /**\n+         * A proposal has been requested from Cruise Control, but is not ready yet.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>A rebalance proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>Once Cruise Control has a ready proposal.</dd>\n+         *     <dt>NotReady</dt><dd>If Cruise Control returned an error</dd>\n+         * </dl>\n+         */\n+        PendingProposal,\n+        /**\n+         * A proposal is ready and waiting for approval.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>When the user sets annotation strimzi.io/rebalance=approve.</dd>\n+         *     <dt>PendingProposal</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>When the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        ProposalReady,\n+        /**\n+         * Cruise Control is doing the rebalance for an approved proposal.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>Rebalancing</dt><dd>While the actual rebalancing is still ongoing</dd>\n+         *     <dt>Stopped</dt><dd>If the user sets annotation strimzi.io/rebalance=stop.</dd>\n+         *     <dt>Ready</dt><dd>Once the rebalancing is complete.</dd>\n+         * </dl>\n+         */\n+        Rebalancing,\n+        /**\n+         * The user has stopped the actual rebalancing by setting annotation strimzi.io/rebalance=stop\n+         * May transition back to:\n+         * <dl>\n+         *     <dt>PendingProposal</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh but the proposal is not ready yet.</dd>\n+         *     <dt>ProposalReady</dt><dd>If the user sets annotation strimzi.io/rebalance=refresh and the proposal is already ready.</dd>\n+         * </dl>\n+         */\n+        Stopped,\n+        /**\n+         * There's been some error.\n+         * Transitions to:\n+         * <dl>\n+         *     <dt>New</dt><dd>If the error was caused by the resource itself that was fixed by the user.</dd>\n+         * </dl>\n+         */\n+        NotReady,\n+        /**\n+         * The rebalance is complete and there is no transition from this state.\n+         * The resource is eligible for garbage collection after a configurable delay.\n+         * There is no transition from this state to a new one.\n+         */\n+        Ready\n+    }\n+\n+    enum RebalanceAnnotation {\n+        /**\n+         * No annotation set on the rebalance resource.\n+         */\n+        none,\n+        /**\n+         * Used to approve a rebalance proposal and trigger the actual rebalancing.\n+         * This value should only be used when in the {@code ProposalReady} state.\n+         */\n+        approve,\n+        /**\n+         * Used to stop a request for an actual ongoing rebalancing.\n+         * This value should only be used when in the {@code Rebalancing} state.\n+         */\n+        stop,\n+        /**\n+         * Used to refresh a ready rebalance proposal or to restart a stopped request for getting a rebalance proposal.\n+         * This value should only be used when in the {@code ProposalReady} or {@code Stopped} states.\n+         */\n+        refresh,\n+        /**\n+         * Any other unsupported/unknown annotation value.\n+         */\n+        unknown\n+    }\n+\n+    private Future<Void> reconcile(Reconciliation reconciliation, String host, CruiseControlApi apiClient, KafkaRebalance clusterRebalance, State currentState, RebalanceAnnotation rebalanceAnnotation) {\n+        RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder = new RebalanceOptions.RebalanceOptionsBuilder();\n+        if (clusterRebalance.getSpec().getGoals() != null) {\n+            rebalanceOptionsBuilder.withGoals(clusterRebalance.getSpec().getGoals());\n+        }\n+        if (clusterRebalance.getSpec().isSkipHardGoalCheck()) {\n+            rebalanceOptionsBuilder.withSkipHardGoalCheck();\n+        }\n+        log.info(\"{}: Rebalance action from state [{}]\", reconciliation, currentState);\n+\n+        return computeNextStatus(reconciliation, host, apiClient, clusterRebalance, currentState, rebalanceAnnotation, rebalanceOptionsBuilder)\n+                .compose(desiredStatus -> {\n+                    // due to a long rebalancing operation that takes the lock for the entire period, more events related to resource modification could be\n+                    // queued with a stale resource (updated by the rebalancing holding the lock), so we need to get the current fresh resource\n+                    return kafkaRebalanceOperator.getAsync(reconciliation.namespace(), reconciliation.name())\n+                            .compose(freshClusterRebalance -> {\n+                                if (freshClusterRebalance != null) {\n+                                    return updateStatus(freshClusterRebalance, desiredStatus, kafkaRebalanceOperator, null)\n+                                            .compose(updatedClusterRebalance -> {\n+                                                log.info(\"{}: State updated to [{}] with annotation {}={} \",\n+                                                        reconciliation,\n+                                                        updatedClusterRebalance.getStatus().getConditions().get(0).getType(),\n+                                                        ANNO_STRIMZI_IO_REBALANCE,\n+                                                        rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                if (hasRebalanceAnnotation(updatedClusterRebalance)) {\n+                                                    log.debug(\"{}: Removing annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE,\n+                                                            rawRebalanceAnnotation(updatedClusterRebalance));\n+                                                    KafkaRebalance patchedClusterRebalance = new KafkaRebalanceBuilder(updatedClusterRebalance)\n+                                                            .editMetadata().removeFromAnnotations(ANNO_STRIMZI_IO_REBALANCE).endMetadata().build();\n+\n+                                                    return kafkaRebalanceOperator.patchAsync(patchedClusterRebalance);\n+                                                } else {\n+                                                    log.debug(\"{}: No annotation {}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                                                    return Future.succeededFuture();\n+                                                }\n+                                            }).mapEmpty();\n+\n+                                } else {\n+                                    return Future.succeededFuture();\n+                                }\n+                            }, exception -> {\n+                                    log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                                    return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                            .mapEmpty();\n+                                });\n+                }, exception -> {\n+                        log.error(\"{}: Status updated to [NotReady] due to error: {}\", reconciliation, exception.getMessage());\n+                        return updateStatus(clusterRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception)\n+                                .mapEmpty();\n+                    });\n+    }\n+\n+    private Future<KafkaRebalanceStatus> computeNextStatus(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance, State currentState,\n+                                                           RebalanceAnnotation rebalanceAnnotation, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (currentState) {\n+            case New:\n+                return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+            case PendingProposal:\n+                return onPendingProposal(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case ProposalReady:\n+                return onProposalReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Rebalancing:\n+                return onRebalancing(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation);\n+            case Stopped:\n+                return onStop(reconciliation, host, apiClient, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            case Ready:\n+                // Rebalance Complete\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case NotReady:\n+                // Error case\n+                return onNotReady(reconciliation, host, apiClient, clusterRebalance, rebalanceAnnotation, rebalanceOptionsBuilder);\n+            default:\n+                return Future.failedFuture(new RuntimeException(\"Unexpected state \" + currentState));\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code New} state.\n+     * When a new {@KafkaRebalance} is created, it calls the Cruise Control API for requesting a rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNew(Reconciliation reconciliation,\n+                                               String host, CruiseControlApi apiClient,\n+                                               RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code NotReady} state.\n+     * This state indicates that the rebalance has suffered some kind of error. This could be a misconfiguration or the result\n+     * of an error during a reconcile.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onNotReady(Reconciliation reconciliation,\n+                                                    String host, CruiseControlApi apiClient,\n+                                                    KafkaRebalance clusterRebalance,\n+                                                    RebalanceAnnotation rebalanceAnnotation,\n+                                                    RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            // the user fixed the error on the resource and want to \"refresh\", actually\n+            // requesting a new rebalance proposal\n+            return onNew(reconciliation, host, apiClient, rebalanceOptionsBuilder);\n+        } else {\n+            // stay in the current error state, actually failing the Future\n+            return Future.failedFuture(clusterRebalance.getStatus().getConditions().get(0).getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code PendingProposal} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance proposal processing on Cruise Control side.\n+     * In order to do that, it calls the Cruise Control API for requesting the rebalance proposal.\n+     * When the proposal is ready, the next state is {@code ProposalReady}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it stops to polling the Cruise Control API for requesting the rebalance proposal.\n+     * If the user sets any other values for the strimzi.io/rebalance annotation, it is just ignored and the rebalance proposal request just continues.\n+     * This method holds the lock until the rebalance proposal is ready or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onPendingProposal(Reconciliation reconciliation,\n+                                                           String host, CruiseControlApi apiClient,\n+                                                           KafkaRebalance clusterRebalance,\n+                                                           RebalanceAnnotation rebalanceAnnotation,\n+                                                           RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        Promise<KafkaRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.debug(\"{}: Arming Cruise Control rebalance proposal request timer\", reconciliation);\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.PendingProposal) {\n+                                if (rebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control proposal request timer\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    p.complete(new KafkaRebalanceStatusBuilder()\n+                                            .withSessionId(null)\n+                                            .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                } else {\n+                                    requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder,\n+                                            freshClusterRebalance.getStatus().getSessionId()).setHandler(rebalanceResult -> {\n+                                                if (rebalanceResult.succeeded()) {\n+                                                    // If the returned status has an optimization result then the rebalance proposal\n+                                                    // is ready, so stop the polling\n+                                                    if (rebalanceResult.result().getOptimizationResult() != null &&\n+                                                            !rebalanceResult.result().getOptimizationResult().isEmpty()) {\n+                                                        vertx.cancelTimer(t);\n+                                                        log.debug(\"{}: Optimization proposal ready\", reconciliation);\n+                                                        p.complete(rebalanceResult.result());\n+                                                    } else {\n+                                                        log.debug(\"{}: Waiting for optimization proposal to be ready\", reconciliation);\n+                                                    }\n+                                                    // The rebalance proposal is still not ready yet, keep the timer for polling\n+                                                } else {\n+                                                    log.error(\"{}: Cruise Control getting rebalance proposal failed\", reconciliation, rebalanceResult.cause());\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(rebalanceResult.cause());\n+                                                }\n+                                            });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"{}: Cruise Control getting rebalance resource failed\", reconciliation, getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code ProposalReady} state.\n+     * It is related to the value that the user apply to the strimzi.io/rebalance annotation.\n+     * If the strimzi.io/rebalance=approve is set, it calls the Cruise Control API for executing the proposed rebalance.\n+     * If the strimzi.io/rebalance=refresh is set, it calls the Cruise Control API for for requesting/refreshing the ready rebalance proposal.\n+     * If the rebalance is immediately complete, the next state is {@code Ready}.\n+     * If the rebalance is not finished yet and Cruise Control is still taking care of processing it (the usual case), the next state is {@code Rebalancing}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onProposalReady(Reconciliation reconciliation,\n+                                                         String host, CruiseControlApi apiClient,\n+                                                         KafkaRebalance clusterRebalance,\n+                                                         RebalanceAnnotation rebalanceAnnotation,\n+                                                         RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        switch (rebalanceAnnotation) {\n+            case none:\n+                log.debug(\"{}: No {} annotation set\", reconciliation, ANNO_STRIMZI_IO_REBALANCE);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+            case approve:\n+                return requestRebalance(reconciliation, host, apiClient, false, rebalanceOptionsBuilder);\n+            case refresh:\n+                return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+            default:\n+                log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+                return Future.succeededFuture(clusterRebalance.getStatus());\n+        }\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Rebalancing} state.\n+     * It starts a periodic timer in order to check the status of the ongoing rebalance processing on Cruise Control side.\n+     * In order to do that, it calls the related Cruise Control REST API about asking the user task status.\n+     * When the rebalance is finished, the next state is {@code Ready}.\n+     * If the user sets the strimzi.io/rebalance=stop annotation, it calls the Cruise Control REST API for stopping the ongoing task\n+     * and then move to the {@code Stopped} state.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored and the user task checks just continues.\n+     * This method holds the lock until the rebalance is finished, the ongoing task is stopped or any exception is raised.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the REST API requests\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param clusterRebalance Current {@code KafkaRebalance} resource\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onRebalancing(Reconciliation reconciliation,\n+                                                       String host, CruiseControlApi apiClient,\n+                                                       KafkaRebalance clusterRebalance,\n+                                                       RebalanceAnnotation rebalanceAnnotation) {\n+        Promise<KafkaRebalanceStatus> p = Promise.promise();\n+        if (rebalanceAnnotation == RebalanceAnnotation.none) {\n+            log.info(\"{}: Arming Cruise Control rebalance user task status timer\", reconciliation);\n+            String sessionId = clusterRebalance.getStatus().getSessionId();\n+            AtomicInteger ccApiErrorCount = new AtomicInteger();\n+            vertx.setPeriodic(REBALANCE_POLLING_TIMER_MS, t -> {\n+                // Check that we have not already failed to contact the API beyond the allowed number of times.\n+                if (ccApiErrorCount.get() >= MAX_API_RETRIES) {\n+                    vertx.cancelTimer(t);\n+                    p.fail(new RuntimeException(\"Unable to reach Cruise Control API after \" + MAX_API_RETRIES + \" attempts\"));\n+                }\n+                resourceOperator.getAsync(clusterRebalance.getMetadata().getNamespace(), clusterRebalance.getMetadata().getName()).setHandler(getResult -> {\n+                    if (getResult.succeeded()) {\n+                        KafkaRebalance freshClusterRebalance = getResult.result();\n+                        // checking that the resource wasn't delete meanwhile the timer wasn't raised\n+                        if (freshClusterRebalance != null) {\n+                            // checking it is in the right state because the timer could be called again (from a delayed timer firing)\n+                            // and the previous execution set the status and completed the future\n+                            if (state(freshClusterRebalance) == State.Rebalancing) {\n+                                if (rebalanceAnnotation(freshClusterRebalance) == RebalanceAnnotation.stop) {\n+                                    log.debug(\"{}: Stopping current Cruise Control rebalance user task\", reconciliation);\n+                                    vertx.cancelTimer(t);\n+                                    apiClient.stopExecution(host, CruiseControl.REST_API_PORT).setHandler(stopResult -> {\n+                                        if (stopResult.succeeded()) {\n+                                            p.complete(new KafkaRebalanceStatusBuilder()\n+                                                    .withSessionId(null)\n+                                                    .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+                                        } else {\n+                                            log.error(\"{}: Cruise Control stopping execution failed\", reconciliation, stopResult.cause());\n+                                            p.fail(stopResult.cause());\n+                                        }\n+                                    });\n+                                } else {\n+                                    log.info(\"{}: Getting Cruise Control rebalance user task status\", reconciliation);\n+                                    apiClient.getUserTaskStatus(host, CruiseControl.REST_API_PORT, sessionId).setHandler(userTaskResult -> {\n+                                        if (userTaskResult.succeeded()) {\n+                                            CruiseControlUserTaskResponse response = userTaskResult.result();\n+                                            JsonObject taskStatusJson = response.getJson();\n+                                            CruiseControlUserTaskStatus taskStatus;\n+                                            // Due to a bug in the CC rest API (https://github.com/linkedin/cruise-control/issues/1187), if we ask\n+                                            // for the status of a task that has COMPLETED_WITH_ERROR with fetch_completed_task=true, will will get\n+                                            // 500 error instead of the task status. So the client currently handles this case and sets a flag in\n+                                            // the CC response object.\n+                                            if (response.completedWithError()) {\n+                                                log.debug(\"{}: User tasks end-point returned {} for task: {}\", reconciliation,\n+                                                        CruiseControlUserTaskStatus.COMPLETED_WITH_ERROR, sessionId);\n+                                                taskStatus = CruiseControlUserTaskStatus.COMPLETED_WITH_ERROR;\n+                                            } else {\n+                                                String taskStatusStr = taskStatusJson.getString(\"Status\");\n+                                                taskStatus = CruiseControlUserTaskStatus.lookup(taskStatusStr);\n+                                            }\n+                                            switch (taskStatus) {\n+                                                case COMPLETED:\n+                                                    vertx.cancelTimer(t);\n+                                                    log.info(\"{}: Rebalance ({}) is now complete\", reconciliation, sessionId);\n+                                                    p.complete(new KafkaRebalanceStatusBuilder()\n+                                                            .withSessionId(null)\n+                                                            .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                            .addNewCondition().withType(State.Ready.toString()).endCondition().build());\n+                                                    break;\n+                                                case COMPLETED_WITH_ERROR:\n+                                                    // TODO: There doesn't seem to be a way to retrieve the actual error message from the user tasks endpoint?\n+                                                    //       We may need to propose an upstream PR for this.\n+                                                    // TODO: Once we can get the error details we need to add an error field to the Rebalance Status to hold\n+                                                    //       details of any issues while rebalancing.\n+                                                    log.error(\"{}: Rebalance ({}) optimization proposal has failed to complete\", reconciliation, sessionId);\n+                                                    vertx.cancelTimer(t);\n+                                                    p.complete(new KafkaRebalanceStatusBuilder()\n+                                                            .withSessionId(sessionId)\n+                                                            .addNewCondition().withType(State.NotReady.toString()).endCondition().build());\n+                                                    break;\n+                                                case IN_EXECUTION: // Rebalance is still in progress\n+                                                    // We need to check that the status has been updated with the ongoing optimisation proposal\n+                                                    // The proposal field can be empty if a rebalance(dryrun=false) was called and the optimisation\n+                                                    // proposal was still being prepared (in progress). In that case the rebalance will start when\n+                                                    // the proposal is complete but the optimisation proposal summary will be missing.\n+                                                    if (freshClusterRebalance.getStatus().getOptimizationResult() == null ||\n+                                                            freshClusterRebalance.getStatus().getOptimizationResult().isEmpty()) {\n+                                                        log.info(\"{}: Rebalance ({}) optimization proposal is now ready and has been added to the status\", reconciliation, sessionId);\n+                                                        // Cancel the timer so that the status is returned and updated.\n+                                                        vertx.cancelTimer(t);\n+                                                        p.complete(new KafkaRebalanceStatusBuilder()\n+                                                                .withSessionId(sessionId)\n+                                                                .withOptimizationResult(taskStatusJson.getJsonObject(\"summary\").getMap())\n+                                                                .addNewCondition().withType(State.Rebalancing.toString()).endCondition().build());\n+                                                    }\n+                                                    ccApiErrorCount.set(0);\n+                                                    // TODO: Find out if there is any way to check the progress of a rebalance.\n+                                                    //       We could parse the verbose proposal for total number of reassignments and compare to number completed (if available)?\n+                                                    //       We can then update the status at this point.\n+                                                    break;\n+                                                case ACTIVE: // Rebalance proposal is still being calculated\n+                                                    // If a rebalance(dryrun=false) was called and the proposal is still being prepared then the task\n+                                                    // will be in an ACTIVE state. When the proposal is ready it will shift to IN_EXECUTION and we will\n+                                                    // check that the optimisation proposal is added to the status on the next reconcile.\n+                                                    log.info(\"{}: Rebalance ({}) optimization proposal is still being prepared\", reconciliation, sessionId);\n+                                                    ccApiErrorCount.set(0);\n+                                                    break;\n+                                                default:\n+                                                    log.error(\"{}: Unexpected state {}\", reconciliation, taskStatus);\n+                                                    vertx.cancelTimer(t);\n+                                                    p.fail(\"Unexpected state \" + taskStatus);\n+                                                    break;\n+                                            }\n+                                        } else {\n+                                            log.error(\"{}: Cruise Control getting rebalance task status failed\", reconciliation, userTaskResult.cause());\n+                                            // To make sure this error is not just a temporary problem with the network we retry several times.\n+                                            // If the number of errors pass the MAX_API_ERRORS limit then the period method will fail the promise.\n+                                            ccApiErrorCount.getAndIncrement();\n+                                        }\n+                                    });\n+                                }\n+                            } else {\n+                                p.complete(freshClusterRebalance.getStatus());\n+                            }\n+                        } else {\n+                            log.debug(\"{}: Rebalance resource was deleted, stopping the request time\", reconciliation);\n+                            vertx.cancelTimer(t);\n+                            p.complete();\n+                        }\n+                    } else {\n+                        log.error(\"{}: Cruise Control getting rebalance resource failed\", reconciliation, getResult.cause());\n+                        vertx.cancelTimer(t);\n+                        p.fail(getResult.cause());\n+                    }\n+                });\n+\n+            });\n+        } else {\n+            p.complete(clusterRebalance.getStatus());\n+        }\n+        return p.future();\n+    }\n+\n+    /**\n+     * This method handles the transition from {@code Stopped} state.\n+     * If the user set strimzi.io/rebalance=refresh annotation, it calls the Cruise Control API for requesting a new rebalance proposal.\n+     * If the proposal is immediately ready, the next state is {@code ProposalReady}.\n+     * If the proposal is not ready yet and Cruise Control is still taking care of processing it, the next state is {@code PendingProposal}.\n+     * If the user sets any other values for the strimzi.io/rebalance, it is just ignored.\n+     *\n+     * @param reconciliation Reconciliation information\n+     * @param host Cruise Control service to which sending the rebalance proposal request\n+     * @param apiClient Cruise Control REST API client instance\n+     * @param rebalanceAnnotation The current value for the strimzi.io/rebalance annotation\n+     * @param rebalanceOptionsBuilder builder for the Cruise Control REST API client options\n+     * @return a Future with the next {@code KafkaRebalanceStatus} bringing the state\n+     */\n+    private Future<KafkaRebalanceStatus> onStop(Reconciliation reconciliation,\n+                                                String host, CruiseControlApi apiClient,\n+                                                RebalanceAnnotation rebalanceAnnotation,\n+                                                RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        if (rebalanceAnnotation == RebalanceAnnotation.refresh) {\n+            return requestRebalance(reconciliation, host, apiClient, true, rebalanceOptionsBuilder);\n+        } else {\n+            log.warn(\"{}: Ignore annotation {}={}\", reconciliation, ANNO_STRIMZI_IO_REBALANCE, rebalanceAnnotation);\n+            return Future.succeededFuture(new KafkaRebalanceStatusBuilder()\n+                    .addNewCondition().withNewType(State.Stopped.toString()).endCondition().build());\n+        }\n+    }\n+\n+    private Future<Void> reconcileRebalance(Reconciliation reconciliation, KafkaRebalance kafkaRebalance) {\n+        if (kafkaRebalance == null) {\n+            log.info(\"{}: Rebalance resource deleted\", reconciliation);\n+            return Future.succeededFuture();\n+        } else {\n+            String clusterName = kafkaRebalance.getMetadata().getLabels() == null ? null : kafkaRebalance.getMetadata().getLabels().get(Labels.STRIMZI_CLUSTER_LABEL);\n+            String clusterNamespace = kafkaRebalance.getMetadata().getNamespace();\n+            if (clusterName != null) {\n+                return kafkaOperator.getAsync(clusterNamespace, clusterName)\n+                        .compose(kafka -> {\n+                            if (kafka == null) {\n+                                log.warn(\"{}: Kafka resource '{}' identified by label '{}' does not exist in namespace {}.\",\n+                                        reconciliation, clusterName, Labels.STRIMZI_CLUSTER_LABEL, clusterNamespace);\n+                                return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator,\n+                                        new NoSuchResourceException(\"Kafka resource '\" + clusterName\n+                                                + \"' identified by label '\" + Labels.STRIMZI_CLUSTER_LABEL\n+                                                + \"' does not exist in namespace \" + clusterNamespace + \".\")).mapEmpty();\n+                            } else if (kafka.getSpec().getCruiseControl() != null) {\n+                                CruiseControlApi apiClient = cruiseControlClientProvider.apply(vertx);\n+\n+                                return kafkaRebalanceOperator.getAsync(kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName())\n+                                        .compose(fetchedClusterRebalance -> {\n+                                            KafkaRebalanceStatus clusterRebalanceStatus = fetchedClusterRebalance.getStatus();\n+                                            // cluster rebalance is new or it is in one of others states\n+                                            State currentState = clusterRebalanceStatus == null ? State.New :\n+                                                    State.valueOf(clusterRebalanceStatus.getConditions().get(0).getType());\n+                                            // check annotation\n+                                            RebalanceAnnotation rebalanceAnnotation = rebalanceAnnotation(fetchedClusterRebalance);\n+                                            return reconcile(reconciliation, ccHost == null ? CruiseControlResources.serviceName(clusterName) : ccHost, apiClient, fetchedClusterRebalance, currentState, rebalanceAnnotation).mapEmpty();\n+                                        }, exception -> Future.failedFuture(exception).mapEmpty());\n+\n+                            } else {\n+                                log.warn(\"{}: Kafka resouce lacks 'cruiseControl' declaration : No deployed Cruise Control for doing a rebalance.\", reconciliation);\n+                                return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator,\n+                                        new InvalidResourceException(\"Kafka resouce lacks 'cruiseControl' declaration \"\n+                                                + \": No deployed Cruise Control for doing a rebalance.\")).mapEmpty();\n+                            }\n+                        }, exception -> updateStatus(kafkaRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator, exception).mapEmpty());\n+            } else {\n+                log.warn(\"{}: Resource lacks label '{}': No cluster related to a possible rebalance.\", reconciliation, Labels.STRIMZI_CLUSTER_LABEL);\n+                return updateStatus(kafkaRebalance, new KafkaRebalanceStatus(), kafkaRebalanceOperator,\n+                        new InvalidResourceException(\"Resource lacks label '\"\n+                                + Labels.STRIMZI_CLUSTER_LABEL\n+                                + \"': No cluster related to a possible rebalance.\")).mapEmpty();\n+            }\n+        }\n+\n+    }\n+\n+    private Future<KafkaRebalanceStatus> requestRebalance(Reconciliation reconciliation,\n+                                                          String host, CruiseControlApi apiClient,\n+                                                          boolean dryrun, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder) {\n+        return requestRebalance(reconciliation, host, apiClient, dryrun, rebalanceOptionsBuilder, null);\n+    }\n+\n+    private Future<KafkaRebalanceStatus> requestRebalance(Reconciliation reconciliation, String host, CruiseControlApi apiClient,\n+                                                          boolean dryrun, RebalanceOptions.RebalanceOptionsBuilder rebalanceOptionsBuilder, String userTaskID) {\n+\n+        log.info(\"{}: Requesting Cruise Control rebalance [dryrun={}]\", reconciliation, dryrun);\n+        if (!dryrun) {\n+            rebalanceOptionsBuilder.withFullRun();\n+        }\n+        return apiClient.rebalance(host, CruiseControl.REST_API_PORT, rebalanceOptionsBuilder.build(), userTaskID)\n+                .map(response -> {\n+                    if (dryrun) {\n+                        if (response.thereIsNotEnoughDataForProposal() || response.proposalIsStillCalculating()) {\n+                            // If either there not enough data for a rebalance or it is still being processed we need to\n+                            // re-request the proposal at a later stage so we move to the PendingProposal State.\n+                            return new KafkaRebalanceStatusBuilder()\n+                                    .withNewSessionId(response.getUserTaskId())\n+                                    .addNewCondition().withNewType(State.PendingProposal.toString()).endCondition().build();\n+                        }\n+                    } else {\n+                        if (response.thereIsNotEnoughDataForProposal()) {\n+                            // We do not include a session id with this status as we do not want to retrieve the state of\n+                            // this failed tasks (COMPLETED_WITH_ERROR)\n+                            return new KafkaRebalanceStatusBuilder()\n+                                    .addNewCondition().withNewType(State.PendingProposal.toString()).endCondition().build();\n+                        } else if (response.proposalIsStillCalculating()) {\n+                            return new KafkaRebalanceStatusBuilder()\n+                                    .withNewSessionId(response.getUserTaskId())\n+                                    .addNewCondition().withNewType(State.Rebalancing.toString()).endCondition().build();\n+                        }\n+                    }\n+\n+                    if (response.getJson().containsKey(CC_REST_API_SUMMARY)) {\n+                        // If there is enough data and the proposal is complete (the response has the \"summary\" key) then we move\n+                        // to ProposalReady for a dry run or to the Rebalancing state for a full run\n+                        State ready = dryrun ? State.ProposalReady : State.Rebalancing;\n+                        return new KafkaRebalanceStatusBuilder()\n+                                .withNewSessionId(response.getUserTaskId())\n+                                .withOptimizationResult(response.getJson().getJsonObject(CC_REST_API_SUMMARY).getMap())\n+                                .addNewCondition().withNewType(ready.toString()).endCondition().build();\n+                    } else {\n+                        throw new RuntimeException(\"Rebalance returned unknown response: \" + response.toString());\n+                    }\n+                }).otherwise(t -> {\n+                    throw new RuntimeException(t.getMessage());\n+                });\n+    }\n+\n+    /**\n+     * Return the {@code RebalanceAnnotation} enum value for the raw String value of the strimzio.io/rebalance annotation\n+     * set on the provided KafkaRebalance resource instance.\n+     * If the annotation is not set it returns {@code RebalanceAnnotation.none} while if it's a not valid value, it\n+     * returns {@code RebalanceAnnotation.unknown}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "originalPosition": 811}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4MDk2OQ==", "bodyText": "Is this really the only test directly covering all that code in the KafkaRebalanceAssemblyOperator, or did I miss something?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r421380969", "createdAt": "2020-05-07T09:50:23Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.api.model.ObjectMeta;\n+import io.fabric8.kubernetes.api.model.ObjectMetaBuilder;\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBridge;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.KafkaRebalanceSpec;\n+import io.strimzi.api.kafka.model.KafkaRebalanceSpecBuilder;\n+import io.strimzi.api.kafka.model.status.Condition;\n+import io.strimzi.operator.KubernetesVersion;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.MockCruiseControl;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.vertx.core.Future;\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.Checkpoint;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockserver.integration.ClientAndServer;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(VertxExtension.class)\n+public class KafkaRebalanceAssemblyOperatorTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "originalPosition": 58}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9", "author": {"user": {"login": "ppatierno", "name": "Paolo Patierno"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/624962484fec6f6ec518a4ac5a7387312b0851b9", "committedDate": "2020-05-06T21:00:36Z", "message": "Fixed tests (#59)\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>"}, "afterCommit": {"oid": "5a37cbff2d2af0c7ea040733e297d4070904a0d7", "author": {"user": {"login": "ppatierno", "name": "Paolo Patierno"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5a37cbff2d2af0c7ea040733e297d4070904a0d7", "committedDate": "2020-05-07T10:09:37Z", "message": "Fixed tests (#59)\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5MDA2MDEz", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#pullrequestreview-409006013", "createdAt": "2020-05-11T09:25:41Z", "commit": {"oid": "20e8900b5f22868803630f6b1cd95817767262db"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5MDQ3NDEx", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#pullrequestreview-409047411", "createdAt": "2020-05-11T10:24:25Z", "commit": {"oid": "20e8900b5f22868803630f6b1cd95817767262db"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMDoyNDoyNVrOGTWN5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMDozMjoyNVrOGTWeug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0MDEzMw==", "bodyText": "Do we want to limit its size to 7?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422940133", "createdAt": "2020-05-11T10:24:25Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControlConfiguration.java", "diffHunk": "@@ -40,23 +39,31 @@\n         \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderBytesInDistributionGoal,\" +\n         \"com.linkedin.kafka.cruisecontrol.analyzer.goals.PreferredLeaderElectionGoal\";\n \n+    public static final String CRUISE_CONTROL_DEFAULT_GOALS_CONFIG_KEY = \"default.goals\";\n+    public static final String CRUISE_CONTROL_SELF_HEALING_CONFIG_KEY = \"self.healing.goals\";\n+    public static final String CRUISE_CONTROL_ANOMALY_DETECTION_CONFIG_KEY = \"anomaly.detection.goals\";\n+    public static final String CRUISE_CONTROL_DEFAULT_ANOMALY_DETECTION_GOALS =\n+            \"com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal, \" +\n+                    \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal, \" +\n+                    \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskCapacityGoal\";\n+\n    /*\n     * Map containing default values for required configuration properties\n     */\n-    private static final Map<String, String> CC_DEFAULT_PROPERTIES_MAP;\n+    private static final Map<String, String> CRUISE_CONTROL_DEFAULT_PROPERTIES_MAP;\n \n     private static final List<String> FORBIDDEN_OPTIONS;\n     private static final List<String> EXCEPTIONS;\n \n     static {\n-        CC_DEFAULT_PROPERTIES_MAP = new HashMap<>();\n-        CC_DEFAULT_PROPERTIES_MAP.put(\"partition.metrics.window.ms\", Integer.toString(300_000));\n-        CC_DEFAULT_PROPERTIES_MAP.put(\"num.partition.metrics.windows\", \"1\");\n-        CC_DEFAULT_PROPERTIES_MAP.put(\"broker.metrics.window.ms\", Integer.toString(300_000));\n-        CC_DEFAULT_PROPERTIES_MAP.put(\"num.broker.metrics.windows\", \"20\");\n-        CC_DEFAULT_PROPERTIES_MAP.put(\"completed.user.task.retention.time.ms\", Long.toString(TimeUnit.DAYS.toMillis(1)));\n-        CC_DEFAULT_PROPERTIES_MAP.put(\"default.goals\", DEFAULT_GOALS);\n-        CC_DEFAULT_PROPERTIES_MAP.put(\"goals\", DEFAULT_GOALS);\n+        CRUISE_CONTROL_DEFAULT_PROPERTIES_MAP = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20e8900b5f22868803630f6b1cd95817767262db"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0MDkzMA==", "bodyText": "Do we perhaps want to clone the map to stop any objects from modifying the defaults? (This might not be neccessary though...)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422940930", "createdAt": "2020-05-11T10:25:51Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControlConfiguration.java", "diffHunk": "@@ -76,16 +83,7 @@ private CruiseControlConfiguration(String configuration, List<String> forbiddenO\n         super(configuration, forbiddenOptions);\n     }\n \n-    /**\n-     * Returns a CruiseControlConfiguration created without forbidden option filtering.\n-     * @param string A string representation of the Properties\n-     * @return The CruiseControlConfiguration\n-     */\n-    public static CruiseControlConfiguration unvalidated(String string) {\n-        return new CruiseControlConfiguration(string, emptyList());\n-    }\n-\n     public static Map<String, String> getCruiseControlDefaultPropertiesMap() {\n-        return CC_DEFAULT_PROPERTIES_MAP;\n+        return CRUISE_CONTROL_DEFAULT_PROPERTIES_MAP;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20e8900b5f22868803630f6b1cd95817767262db"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0MTIwNg==", "bodyText": "rebalacing -> rebalancing", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422941206", "createdAt": "2020-05-11T10:26:22Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,904 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20e8900b5f22868803630f6b1cd95817767262db"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0Mjg4OA==", "bodyText": "I'm in agreement here, this may well be fragile. implementing a method like Tom described should fix this.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422942888", "createdAt": "2020-05-11T10:29:27Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -0,0 +1,869 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watcher;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.KafkaList;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.DoneableKafka;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatusBuilder;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.model.InvalidResourceException;\n+import io.strimzi.operator.cluster.model.NoSuchResourceException;\n+import io.strimzi.operator.cluster.model.StatusDiff;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskResponse;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlUserTaskStatus;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.AbstractOperator;\n+import io.strimzi.operator.common.Annotations;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.Util;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.AbstractWatchableResourceOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.StatusUtils;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+\n+/**\n+ * <p>Assembly operator for a \"KafkaRebalance\" assembly, which interacts with Cruise Control REST API</p>\n+ *\n+ * <p>\n+ *     This operator takes care of the {@code KafkaRebalance} custom resources that a user can create in order\n+ *     to interact with Cruise Control REST API and execute a cluster rebalancing.\n+ *     A state machine is used for the rebalacing flow which is reflected in the {@code status} of the custom resource.\n+ *\n+ *     When a new {@code KafkaRebalance} custom resource is created, the operator sends a rebalance proposal\n+ *     request to the Cruise Control REST API and moves to the {@code PendingProposal} state. It stays in this state\n+ *     until a the rebalance proposal is ready, polling the related status on Cruise Control, and then finally moves\n+ *     to the {@code ProposalReady} state. The status of the {@code KafkaRebalance} custom resource is updated with the\n+ *     computed rebalance proposal so that the user can view it and making a decision to execute it or not.\n+ *     For starting the actual rebalancing on the cluster, the user annotate the custom resource with\n+ *     the {@code strimzi.io/rebalance=approve} annotation, triggering the operator to send a rebalance request to the\n+ *     Cruise Control REST API in order to execute the rebalancing.\n+ *     During the rebalancing, the operator state machine is in the {@code Rebalancing} state and it moves finally\n+ *     to the {@code Ready} state when the rebalancing is done.\n+ *\n+ *     The user is also able to stop an in-progress rebalance proposal computation or an actual rebalancing,\n+ *     annotating the custom resource with {@code strimzi.io/rebalance=stop} when it is in {@code PendingProposal}\n+ *     or {@code Rebalancing} state; the operator moves to the {@code Stopped} state and the user can request a new\n+ *     proposal applying the {@code strimzi.io/rebalance=refresh} annotation on the custom resource.\n+ *\n+ *     Finally, when a proposal is ready but it is stale because the user haven't approve it right after the\n+ *     computation, so that the cluster conditions could be change, he can refresh the proposal annotating\n+ *     the custom resource with the {@code strimzi.io/rebalance=refresh} annotation.\n+ * </p>\n+ */\n+public class KafkaRebalanceAssemblyOperator\n+        extends AbstractOperator<KafkaRebalance, AbstractWatchableResourceOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance, Resource<KafkaRebalance, DoneableKafkaRebalance>>> {\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceAssemblyOperator.class.getName());\n+\n+    // this annotation with related possible values (approve, stop, refresh) is set by the user for interacting\n+    // with the rebalance operator in order to start, stop or refresh rebalacing proposals and operations\n+    public static final String ANNO_STRIMZI_IO_REBALANCE = Annotations.STRIMZI_DOMAIN + \"rebalance\";\n+    private static final long REBALANCE_POLLING_TIMER_MS = 5_000;\n+    private static final int MAX_API_RETRIES = 5;\n+\n+    private final CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> kafkaRebalanceOperator;\n+    private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> kafkaOperator;\n+    private final PlatformFeaturesAvailability pfa;\n+    private final Function<Vertx, CruiseControlApi> cruiseControlClientProvider;\n+\n+    private String ccHost = null;\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+    }\n+\n+    /**\n+     * @param vertx The Vertx instance\n+     * @param pfa Platform features availability properties\n+     * @param supplier Supplies the operators for different resources\n+     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n+     *             service address will be used. This parameter is intended for use in testing.\n+     */\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier, String ccHost) {\n+        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    }\n+\n+    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n+                                          ResourceOperatorSupplier supplier,\n+                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n+        this.cruiseControlClientProvider = cruiseControlClientProvider;\n+        this.ccHost = ccHost;\n+    }\n+\n+    /**\n+     * Create a watch on {@code KafkaRebalance} in the given {@code watchNamespaceOrWildcard}.\n+     *\n+     * @param watchNamespaceOrWildcard The namespace to watch, or \"*\" to watch all namespaces.\n+     * @return A future which completes when the watch has been set up.\n+     */\n+    public Future<Void> createRebalanceWatch(String watchNamespaceOrWildcard) {\n+\n+        return Util.async(this.vertx, () -> {\n+            this.kafkaRebalanceOperator.watch(watchNamespaceOrWildcard, new Watcher<KafkaRebalance>() {\n+                @Override\n+                public void eventReceived(Action action, KafkaRebalance kafkaRebalance) {\n+                    Reconciliation reconciliation = new Reconciliation(\"kafkarebalance-watch\", kafkaRebalance.getKind(),\n+                            kafkaRebalance.getMetadata().getNamespace(), kafkaRebalance.getMetadata().getName());\n+\n+                    log.debug(\"{}: EventReceived {} on {} with status [{}] and {}={}\", reconciliation, action,\n+                            kafkaRebalance.getMetadata().getName(),\n+                            kafkaRebalance.getStatus() != null ? kafkaRebalance.getStatus().getConditions().get(0).getType() : null,\n+                            ANNO_STRIMZI_IO_REBALANCE, rawRebalanceAnnotation(kafkaRebalance));\n+\n+                    withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                        () -> reconcileRebalance(reconciliation, action == Action.DELETED ? null : kafkaRebalance));\n+                }\n+\n+                @Override\n+                public void onClose(KubernetesClientException e) {\n+                    if (e != null) {\n+                        throw e;\n+                    }\n+                }\n+\n+            });\n+            return null;\n+        });\n+    }\n+\n+    private static Future<KafkaRebalance> updateStatus(KafkaRebalance clusterRebalance,\n+                                                      KafkaRebalanceStatus desiredStatus,\n+                                                      CrdOperator<KubernetesClient, KafkaRebalance, KafkaRebalanceList, DoneableKafkaRebalance> clusterRebalanceOperations,\n+                                                      Throwable e) {\n+        if (e != null) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(clusterRebalance, desiredStatus, e);\n+        } else if (desiredStatus.getConditions() != null && desiredStatus.getConditions().get(0).getType() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NTc4OQ=="}, "originalCommit": {"oid": "624962484fec6f6ec518a4ac5a7387312b0851b9"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0MzkwMg==", "bodyText": "I wonder, if we are re-using these strings, might we want to set each as a constant in the CruiseControl class to avoid string repetition?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422943902", "createdAt": "2020-05-11T10:31:16Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -723,6 +725,41 @@ public void testRestApiPortNetworkPolicy() {\n         assertThat(rules.contains(clusterOperatorPeer), is(true));\n     }\n \n+\n+    @Test\n+    public void testGoalsCheck() {\n+\n+        String customGoals = \"com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20e8900b5f22868803630f6b1cd95817767262db"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0NDE1MQ==", "bodyText": "context.succeeding and use checkpoint flags", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422944151", "createdAt": "2020-05-11T10:31:49Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlClientTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource.cruisecontrol;\n+\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.Checkpoint;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockserver.integration.ClientAndServer;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+@ExtendWith(VertxExtension.class)\n+public class CruiseControlClientTest {\n+\n+    private static final int PORT = 1080;\n+    private static final String HOST = \"localhost\";\n+\n+    private static ClientAndServer ccServer;\n+\n+    @BeforeAll\n+    public static void setupServer() throws IOException, URISyntaxException {\n+        ccServer = MockCruiseControl.getCCServer(PORT);\n+    }\n+\n+    @AfterAll\n+    public static void stopServer() {\n+        ccServer.stop();\n+    }\n+\n+    @BeforeEach\n+    public void resetServer() {\n+        ccServer.reset();\n+    }\n+\n+    @Test\n+    public void testGetCCState(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCStateResponse(ccServer);\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        client.getCruiseControlState(HOST, PORT, false).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(\n+                    result.getJson().getJsonObject(\"ExecutorState\").getString(\"state\"),\n+                    is(\"NO_TASK_IN_PROGRESS\")));\n+            context.completeNow();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().build();\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        Checkpoint checkpoint = context.checkpoint(4);\n+        client.rebalance(HOST, PORT, rbOptions, null).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.REBALANCE_NO_GOALS_RESPONSE_UTID)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"summary\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"goalSummary\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"loadAfterOptimization\"), is(true)));\n+            checkpoint.flag();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalanceVerbose(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().withVerboseResponse().build();\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        Checkpoint checkpoint = context.checkpoint(6);\n+        client.rebalance(HOST, PORT, rbOptions, null).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.REBALANCE_NO_GOALS_VERBOSE_RESPONSE_UTID)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"summary\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"goalSummary\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"proposals\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"loadAfterOptimization\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"loadBeforeOptimization\"), is(true)));\n+            checkpoint.flag();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalanceNotEnoughValidWindowsException(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().build();\n+\n+        CruiseControlApiImpl client = new CruiseControlApiImpl(vertx);\n+\n+        client.rebalance(HOST, PORT, rbOptions, MockCruiseControl.REBALANCE_NOT_ENOUGH_VALID_WINDOWS_ERROR)\n+                .setHandler(result -> {\n+                    if (result.succeeded()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20e8900b5f22868803630f6b1cd95817767262db"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0NDM1OA==", "bodyText": "This many flags is unnecessary I believe one at the end is sufficient", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422944358", "createdAt": "2020-05-11T10:32:15Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlClientTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource.cruisecontrol;\n+\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.Checkpoint;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockserver.integration.ClientAndServer;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+@ExtendWith(VertxExtension.class)\n+public class CruiseControlClientTest {\n+\n+    private static final int PORT = 1080;\n+    private static final String HOST = \"localhost\";\n+\n+    private static ClientAndServer ccServer;\n+\n+    @BeforeAll\n+    public static void setupServer() throws IOException, URISyntaxException {\n+        ccServer = MockCruiseControl.getCCServer(PORT);\n+    }\n+\n+    @AfterAll\n+    public static void stopServer() {\n+        ccServer.stop();\n+    }\n+\n+    @BeforeEach\n+    public void resetServer() {\n+        ccServer.reset();\n+    }\n+\n+    @Test\n+    public void testGetCCState(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCStateResponse(ccServer);\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        client.getCruiseControlState(HOST, PORT, false).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(\n+                    result.getJson().getJsonObject(\"ExecutorState\").getString(\"state\"),\n+                    is(\"NO_TASK_IN_PROGRESS\")));\n+            context.completeNow();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().build();\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        Checkpoint checkpoint = context.checkpoint(4);\n+        client.rebalance(HOST, PORT, rbOptions, null).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.REBALANCE_NO_GOALS_RESPONSE_UTID)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"summary\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"goalSummary\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"loadAfterOptimization\"), is(true)));\n+            checkpoint.flag();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalanceVerbose(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().withVerboseResponse().build();\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        Checkpoint checkpoint = context.checkpoint(6);\n+        client.rebalance(HOST, PORT, rbOptions, null).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.REBALANCE_NO_GOALS_VERBOSE_RESPONSE_UTID)));\n+            checkpoint.flag();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20e8900b5f22868803630f6b1cd95817767262db"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0NDQ0Mg==", "bodyText": "ditto", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#discussion_r422944442", "createdAt": "2020-05-11T10:32:25Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlClientTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource.cruisecontrol;\n+\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.Checkpoint;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockserver.integration.ClientAndServer;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+import static io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi.CC_REST_API_SUMMARY;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+@ExtendWith(VertxExtension.class)\n+public class CruiseControlClientTest {\n+\n+    private static final int PORT = 1080;\n+    private static final String HOST = \"localhost\";\n+\n+    private static ClientAndServer ccServer;\n+\n+    @BeforeAll\n+    public static void setupServer() throws IOException, URISyntaxException {\n+        ccServer = MockCruiseControl.getCCServer(PORT);\n+    }\n+\n+    @AfterAll\n+    public static void stopServer() {\n+        ccServer.stop();\n+    }\n+\n+    @BeforeEach\n+    public void resetServer() {\n+        ccServer.reset();\n+    }\n+\n+    @Test\n+    public void testGetCCState(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCStateResponse(ccServer);\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        client.getCruiseControlState(HOST, PORT, false).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(\n+                    result.getJson().getJsonObject(\"ExecutorState\").getString(\"state\"),\n+                    is(\"NO_TASK_IN_PROGRESS\")));\n+            context.completeNow();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().build();\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        Checkpoint checkpoint = context.checkpoint(4);\n+        client.rebalance(HOST, PORT, rbOptions, null).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.REBALANCE_NO_GOALS_RESPONSE_UTID)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"summary\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"goalSummary\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"loadAfterOptimization\"), is(true)));\n+            checkpoint.flag();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalanceVerbose(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().withVerboseResponse().build();\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+\n+        Checkpoint checkpoint = context.checkpoint(6);\n+        client.rebalance(HOST, PORT, rbOptions, null).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.REBALANCE_NO_GOALS_VERBOSE_RESPONSE_UTID)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"summary\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"goalSummary\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"proposals\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"loadAfterOptimization\"), is(true)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().containsKey(\"loadBeforeOptimization\"), is(true)));\n+            checkpoint.flag();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCRebalanceNotEnoughValidWindowsException(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().build();\n+\n+        CruiseControlApiImpl client = new CruiseControlApiImpl(vertx);\n+\n+        client.rebalance(HOST, PORT, rbOptions, MockCruiseControl.REBALANCE_NOT_ENOUGH_VALID_WINDOWS_ERROR)\n+                .setHandler(result -> {\n+                    if (result.succeeded()) {\n+                        assertThat(result.result().thereIsNotEnoughDataForProposal(), is(true));\n+                        context.completeNow();\n+                    } else {\n+                        context.failNow(result.cause());\n+                    }\n+                });\n+    }\n+\n+    @Test\n+    public void testCCGetRebalanceUserTask(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+        String userTaskID = MockCruiseControl.REBALANCE_NO_GOALS_RESPONSE_UTID;\n+\n+        Checkpoint checkpoint = context.checkpoint(2);\n+        client.getUserTaskStatus(HOST, PORT, userTaskID).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.USER_TASK_REBALANCE_NO_GOALS_RESPONSE_UTID)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().getJsonObject(CC_REST_API_SUMMARY), is(notNullValue())));\n+            checkpoint.flag();\n+        }));\n+    }\n+\n+    @Test\n+    public void testCCGetRebalanceVerboseUserTask(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+        String userTaskID = MockCruiseControl.REBALANCE_NO_GOALS_VERBOSE_RESPONSE_UTID;\n+\n+        Checkpoint checkpoint = context.checkpoint(2);\n+        client.getUserTaskStatus(HOST, PORT, userTaskID).setHandler(context.succeeding(result -> {\n+            context.verify(() -> assertThat(result.getUserTaskId(), is(MockCruiseControl.USER_TASK_REBALANCE_NO_GOALS_VERBOSE_RESPONSE_UTID)));\n+            checkpoint.flag();\n+            context.verify(() -> assertThat(result.getJson().getJsonObject(CC_REST_API_SUMMARY), is(notNullValue())));\n+            checkpoint.flag();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20e8900b5f22868803630f6b1cd95817767262db"}, "originalPosition": 162}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5MTcxODEz", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#pullrequestreview-409171813", "createdAt": "2020-05-11T13:29:30Z", "commit": {"oid": "20e8900b5f22868803630f6b1cd95817767262db"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "85ec2cadce98d9a6369546e3e3a69bb8d82f948a", "author": {"user": {"login": "ppatierno", "name": "Paolo Patierno"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/85ec2cadce98d9a6369546e3e3a69bb8d82f948a", "committedDate": "2020-05-12T07:22:40Z", "message": "Rebalance operator condition refactor (#68)\n\n* Refactored Rebalance Status conditions and addressed other PR comments\r\n\r\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>\r\n\r\n* Minor fixes on status refactoring\r\n\r\nSigned-off-by: Paolo Patierno <ppatierno@live.com>\r\n\r\nCo-authored-by: Thomas Cooper <tcooper@redhat.com>"}, "afterCommit": {"oid": "483803a61a88980bf6a60487e04678db6ae599ce", "author": {"user": {"login": "ppatierno", "name": "Paolo Patierno"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/483803a61a88980bf6a60487e04678db6ae599ce", "committedDate": "2020-05-12T07:51:53Z", "message": "Rebalance operator condition refactor (#68)\n\n* Refactored Rebalance Status conditions and addressed other PR comments\r\n\r\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>\r\n\r\n* Minor fixes on status refactoring\r\n\r\nSigned-off-by: Paolo Patierno <ppatierno@live.com>\r\n\r\nCo-authored-by: Thomas Cooper <tcooper@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5Nzk5MjU1", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2945#pullrequestreview-409799255", "createdAt": "2020-05-12T08:10:03Z", "commit": {"oid": "483803a61a88980bf6a60487e04678db6ae599ce"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ae874da356e8165f927acec064ad98f3ce16307", "author": {"user": {"login": "ppatierno", "name": "Paolo Patierno"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/0ae874da356e8165f927acec064ad98f3ce16307", "committedDate": "2020-05-12T13:05:39Z", "message": "Added KafkaClusterRebalance CRD and related operator\nAdded Mock Cruise Control server and client REST API and related tests\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>\nCo-authored-by: Thomas Cooper <tcooper@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f2dde48ac80a911453d36d3d5a3df274134f664b", "author": {"user": {"login": "ppatierno", "name": "Paolo Patierno"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/f2dde48ac80a911453d36d3d5a3df274134f664b", "committedDate": "2020-05-12T12:50:34Z", "message": "Fixed wrong example path for Kafka Cruise Control\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>"}, "afterCommit": {"oid": "0ae874da356e8165f927acec064ad98f3ce16307", "author": {"user": {"login": "ppatierno", "name": "Paolo Patierno"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/0ae874da356e8165f927acec064ad98f3ce16307", "committedDate": "2020-05-12T13:05:39Z", "message": "Added KafkaClusterRebalance CRD and related operator\nAdded Mock Cruise Control server and client REST API and related tests\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>\nCo-authored-by: Thomas Cooper <tcooper@redhat.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1602, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}