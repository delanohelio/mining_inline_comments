{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk2MjkxMjIy", "number": 3736, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODoyMzo0NVrOEqNdpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNToyNTowNFrOEqXmiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjk2MjMwOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODoyMzo0NVrOHcSY6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNjo0ODo1M1rOHclgDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyMzQ2Nw==", "bodyText": "Why do we need to do this? Looks like the tests behind it anyway don't do anything.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3736#discussion_r499423467", "createdAt": "2020-10-05T08:23:45Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -260,23 +270,171 @@ void testSuperUserWithOauthAuthorization() {\n         ClientUtils.waitForClientSuccess(TEAM_A_CONSUMER_NAME, NAMESPACE, MESSAGE_COUNT);\n     }\n \n-    @Disabled(\"Will be implemented in next PR\")\n     @Test\n     @Order(7)\n+    void testSessionReAuthentication() {\n+        String topicName = TOPIC_X + \"-example-topic\";\n+        LOGGER.info(\"Verifying that team A producer is able to send messages to the {} topic -> the topic starting with 'x'\", topicName);\n+\n+        KafkaTopicResource.topic(CLUSTER_NAME, topicName).done();\n+\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withTopicName(topicName)\n+            .withMessageCount(MESSAGE_COUNT)\n+            .build();\n+\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+        ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT);\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Adding the maxSecondsWithoutReauthentication to Kafka listener with OAuth authentication\");\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setListeners(new ArrayOrObjectKafkaListenersBuilder()\n+                .addNewGenericKafkaListener()\n+                    .withName(\"tls\")\n+                    .withPort(9093)\n+                    .withType(KafkaListenerType.INTERNAL)\n+                    .withTls(true)\n+                    .withNewKafkaListenerAuthenticationOAuth()\n+                        .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n+                        .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n+                        .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n+                        .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n+                        .withUserNameClaim(keycloakInstance.getUserNameClaim())\n+                        .withTlsTrustedCertificates(\n+                            new CertSecretSourceBuilder()\n+                                .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME)\n+                                .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT)\n+                                .build())\n+                        .withDisableTlsHostnameVerification(true)\n+                        .withMaxSecondsWithoutReauthentication(30)\n+                    .endKafkaListenerAuthenticationOAuth()\n+                .endGenericKafkaListener()\n+                .build());\n+        });\n+\n+        KafkaUtils.waitForKafkaReady(CLUSTER_NAME);\n+\n+        String baseUri = \"https://\" + keycloakInstance.getHttpsUri();\n+\n+        LOGGER.info(\"Setting the master realm token's lifespan to 3600s\");\n+\n+        // get admin token for all operation on realms\n+        String userName =  new String(Base64.getDecoder().decode(kubeClient().getSecret(\"credential-example-keycloak\").getData().get(\"ADMIN_USERNAME\").getBytes()));\n+        String password = new String(Base64.getDecoder().decode(kubeClient().getSecret(\"credential-example-keycloak\").getData().get(\"ADMIN_PASSWORD\").getBytes()));\n+        String token = KeycloakUtils.getToken(baseUri, userName, password);\n+\n+        // firstly we will increase token lifespan\n+        JsonObject masterRealm = KeycloakUtils.getKeycloakRealm(baseUri, token, \"master\");\n+        masterRealm.put(\"accessTokenLifespan\", \"3600\");\n+        KeycloakUtils.putConfigurationToRealm(baseUri, token, masterRealm, \"master\");\n+\n+        // now we need to get the token with new lifespan\n+        token = KeycloakUtils.getToken(baseUri, userName, password);\n+\n+        LOGGER.info(\"Getting the {} kafka client for obtaining the Dev A Team policy for the x topics\", TEST_REALM);\n+        // we need to get clients for kafka-authz realm to access auth policies in kafka client\n+        JsonArray kafkaAuthzRealm = KeycloakUtils.getKeycloakRealmClients(baseUri, token, TEST_REALM);\n+\n+        String kafkaClientId = \"\";\n+        for (Object client : kafkaAuthzRealm) {\n+            JsonObject clientObject = new JsonObject(client.toString());\n+            if (clientObject.getString(\"clientId\").equals(\"kafka\")) {\n+                kafkaClientId = clientObject.getString(\"id\");\n+            }\n+        }\n+\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withDelayMs(1000)\n+            .build();\n+\n+        LOGGER.info(\"Deploying the Team A producer\");\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+\n+        JsonArray kafkaAuthzRealmPolicies = KeycloakUtils.getPoliciesFromRealmClient(baseUri, token, TEST_REALM, kafkaClientId);\n+\n+        JsonObject devAPolicy = new JsonObject();\n+        for (Object resource : kafkaAuthzRealmPolicies) {\n+            JsonObject resourceObject = new JsonObject(resource.toString());\n+            if (resourceObject.getValue(\"name\").toString().contains(\"Dev Team A can write to topics that start with x- on any cluster\")) {\n+                devAPolicy = resourceObject;\n+            }\n+        }\n+\n+        JsonObject newDevAPolicy = devAPolicy;\n+\n+        Map<String, String> config = new HashMap<>();\n+        config.put(\"resources\", \"[\\\"Topic:x-*\\\"]\");\n+        config.put(\"scopes\", \"[\\\"Describe\\\"]\");\n+        config.put(\"applyPolicies\", \"[\\\"Dev Team A\\\"]\");\n+\n+        newDevAPolicy.put(\"config\", config);\n+\n+        LOGGER.info(\"Changing the Dev Team A policy for topics starting with x- and checking that job will not be successful\");\n+        KeycloakUtils.updatePolicyOfRealmClient(baseUri, token, newDevAPolicy, TEST_REALM, kafkaClientId);\n+        assertThrows(WaitException.class, () -> ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT));\n+\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Changing back to the original settings and checking, if the producer will be successful\");\n+\n+        config.put(\"scopes\", \"[\\\"Describe\\\",\\\"Write\\\"]\");\n+        newDevAPolicy.put(\"config\", config);\n+\n+        KeycloakUtils.updatePolicyOfRealmClient(baseUri, token, newDevAPolicy, TEST_REALM, kafkaClientId);\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withDelayMs(1000)\n+            .build();\n+\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+        ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT);\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Changing configuration of Kafka back to it's original form\");\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setListeners(new ArrayOrObjectKafkaListenersBuilder()\n+                .addNewGenericKafkaListener()\n+                    .withName(\"tls\")\n+                    .withPort(9093)\n+                    .withType(KafkaListenerType.INTERNAL)\n+                    .withTls(true)\n+                    .withNewKafkaListenerAuthenticationOAuth()\n+                        .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n+                        .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n+                        .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n+                        .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n+                        .withUserNameClaim(keycloakInstance.getUserNameClaim())\n+                        .withTlsTrustedCertificates(\n+                            new CertSecretSourceBuilder()\n+                                .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME)\n+                                .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT)\n+                                .build())\n+                        .withDisableTlsHostnameVerification(true)\n+                    .endKafkaListenerAuthenticationOAuth()\n+                .endGenericKafkaListener()\n+                .build());\n+        });\n+\n+        KafkaUtils.waitForKafkaReady(CLUSTER_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85190d583f502d07c4c9fb2873efe0ccc480de85"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyODQ4OQ==", "bodyText": "That was just to return the changes to it's original state, so the next test will not be affected - when we add new one", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3736#discussion_r499428489", "createdAt": "2020-10-05T08:32:14Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -260,23 +270,171 @@ void testSuperUserWithOauthAuthorization() {\n         ClientUtils.waitForClientSuccess(TEAM_A_CONSUMER_NAME, NAMESPACE, MESSAGE_COUNT);\n     }\n \n-    @Disabled(\"Will be implemented in next PR\")\n     @Test\n     @Order(7)\n+    void testSessionReAuthentication() {\n+        String topicName = TOPIC_X + \"-example-topic\";\n+        LOGGER.info(\"Verifying that team A producer is able to send messages to the {} topic -> the topic starting with 'x'\", topicName);\n+\n+        KafkaTopicResource.topic(CLUSTER_NAME, topicName).done();\n+\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withTopicName(topicName)\n+            .withMessageCount(MESSAGE_COUNT)\n+            .build();\n+\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+        ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT);\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Adding the maxSecondsWithoutReauthentication to Kafka listener with OAuth authentication\");\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setListeners(new ArrayOrObjectKafkaListenersBuilder()\n+                .addNewGenericKafkaListener()\n+                    .withName(\"tls\")\n+                    .withPort(9093)\n+                    .withType(KafkaListenerType.INTERNAL)\n+                    .withTls(true)\n+                    .withNewKafkaListenerAuthenticationOAuth()\n+                        .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n+                        .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n+                        .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n+                        .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n+                        .withUserNameClaim(keycloakInstance.getUserNameClaim())\n+                        .withTlsTrustedCertificates(\n+                            new CertSecretSourceBuilder()\n+                                .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME)\n+                                .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT)\n+                                .build())\n+                        .withDisableTlsHostnameVerification(true)\n+                        .withMaxSecondsWithoutReauthentication(30)\n+                    .endKafkaListenerAuthenticationOAuth()\n+                .endGenericKafkaListener()\n+                .build());\n+        });\n+\n+        KafkaUtils.waitForKafkaReady(CLUSTER_NAME);\n+\n+        String baseUri = \"https://\" + keycloakInstance.getHttpsUri();\n+\n+        LOGGER.info(\"Setting the master realm token's lifespan to 3600s\");\n+\n+        // get admin token for all operation on realms\n+        String userName =  new String(Base64.getDecoder().decode(kubeClient().getSecret(\"credential-example-keycloak\").getData().get(\"ADMIN_USERNAME\").getBytes()));\n+        String password = new String(Base64.getDecoder().decode(kubeClient().getSecret(\"credential-example-keycloak\").getData().get(\"ADMIN_PASSWORD\").getBytes()));\n+        String token = KeycloakUtils.getToken(baseUri, userName, password);\n+\n+        // firstly we will increase token lifespan\n+        JsonObject masterRealm = KeycloakUtils.getKeycloakRealm(baseUri, token, \"master\");\n+        masterRealm.put(\"accessTokenLifespan\", \"3600\");\n+        KeycloakUtils.putConfigurationToRealm(baseUri, token, masterRealm, \"master\");\n+\n+        // now we need to get the token with new lifespan\n+        token = KeycloakUtils.getToken(baseUri, userName, password);\n+\n+        LOGGER.info(\"Getting the {} kafka client for obtaining the Dev A Team policy for the x topics\", TEST_REALM);\n+        // we need to get clients for kafka-authz realm to access auth policies in kafka client\n+        JsonArray kafkaAuthzRealm = KeycloakUtils.getKeycloakRealmClients(baseUri, token, TEST_REALM);\n+\n+        String kafkaClientId = \"\";\n+        for (Object client : kafkaAuthzRealm) {\n+            JsonObject clientObject = new JsonObject(client.toString());\n+            if (clientObject.getString(\"clientId\").equals(\"kafka\")) {\n+                kafkaClientId = clientObject.getString(\"id\");\n+            }\n+        }\n+\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withDelayMs(1000)\n+            .build();\n+\n+        LOGGER.info(\"Deploying the Team A producer\");\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+\n+        JsonArray kafkaAuthzRealmPolicies = KeycloakUtils.getPoliciesFromRealmClient(baseUri, token, TEST_REALM, kafkaClientId);\n+\n+        JsonObject devAPolicy = new JsonObject();\n+        for (Object resource : kafkaAuthzRealmPolicies) {\n+            JsonObject resourceObject = new JsonObject(resource.toString());\n+            if (resourceObject.getValue(\"name\").toString().contains(\"Dev Team A can write to topics that start with x- on any cluster\")) {\n+                devAPolicy = resourceObject;\n+            }\n+        }\n+\n+        JsonObject newDevAPolicy = devAPolicy;\n+\n+        Map<String, String> config = new HashMap<>();\n+        config.put(\"resources\", \"[\\\"Topic:x-*\\\"]\");\n+        config.put(\"scopes\", \"[\\\"Describe\\\"]\");\n+        config.put(\"applyPolicies\", \"[\\\"Dev Team A\\\"]\");\n+\n+        newDevAPolicy.put(\"config\", config);\n+\n+        LOGGER.info(\"Changing the Dev Team A policy for topics starting with x- and checking that job will not be successful\");\n+        KeycloakUtils.updatePolicyOfRealmClient(baseUri, token, newDevAPolicy, TEST_REALM, kafkaClientId);\n+        assertThrows(WaitException.class, () -> ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT));\n+\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Changing back to the original settings and checking, if the producer will be successful\");\n+\n+        config.put(\"scopes\", \"[\\\"Describe\\\",\\\"Write\\\"]\");\n+        newDevAPolicy.put(\"config\", config);\n+\n+        KeycloakUtils.updatePolicyOfRealmClient(baseUri, token, newDevAPolicy, TEST_REALM, kafkaClientId);\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withDelayMs(1000)\n+            .build();\n+\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+        ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT);\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Changing configuration of Kafka back to it's original form\");\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setListeners(new ArrayOrObjectKafkaListenersBuilder()\n+                .addNewGenericKafkaListener()\n+                    .withName(\"tls\")\n+                    .withPort(9093)\n+                    .withType(KafkaListenerType.INTERNAL)\n+                    .withTls(true)\n+                    .withNewKafkaListenerAuthenticationOAuth()\n+                        .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n+                        .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n+                        .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n+                        .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n+                        .withUserNameClaim(keycloakInstance.getUserNameClaim())\n+                        .withTlsTrustedCertificates(\n+                            new CertSecretSourceBuilder()\n+                                .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME)\n+                                .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT)\n+                                .build())\n+                        .withDisableTlsHostnameVerification(true)\n+                    .endKafkaListenerAuthenticationOAuth()\n+                .endGenericKafkaListener()\n+                .build());\n+        });\n+\n+        KafkaUtils.waitForKafkaReady(CLUSTER_NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyMzQ2Nw=="}, "originalCommit": {"oid": "85190d583f502d07c4c9fb2873efe0ccc480de85"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ3OTM5Nw==", "bodyText": "Sorry, but this code is so hard to read I can't figure out what it's supposed to do, what it is testing, why it is testing it this way ... Also so much is going on there in the details that opens all sorts of questions.\nWhy don't you add a javadoc and describe the strategy of this test, what it is testing, and how. And I'd also refactor the code so there's less code in the main test method calling out to individual tasks performed in helper methods.\nIn the test you seem to be configuring the authentication, but I don't see you configure the authorization. Therefore I would assume that the combination of oauth authentication with reauthentication enabled, and without any authorization is in effect. But then in the middle of the test you change permissions for the team-a-producer client, which would have zero effect when keycloak authorization is not used. And how is changing permissions related to testing reauthentication in the first place?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3736#discussion_r499479397", "createdAt": "2020-10-05T09:55:29Z", "author": {"login": "mstruk"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -260,23 +270,171 @@ void testSuperUserWithOauthAuthorization() {\n         ClientUtils.waitForClientSuccess(TEAM_A_CONSUMER_NAME, NAMESPACE, MESSAGE_COUNT);\n     }\n \n-    @Disabled(\"Will be implemented in next PR\")\n     @Test\n     @Order(7)\n+    void testSessionReAuthentication() {\n+        String topicName = TOPIC_X + \"-example-topic\";\n+        LOGGER.info(\"Verifying that team A producer is able to send messages to the {} topic -> the topic starting with 'x'\", topicName);\n+\n+        KafkaTopicResource.topic(CLUSTER_NAME, topicName).done();\n+\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withTopicName(topicName)\n+            .withMessageCount(MESSAGE_COUNT)\n+            .build();\n+\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+        ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT);\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Adding the maxSecondsWithoutReauthentication to Kafka listener with OAuth authentication\");\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setListeners(new ArrayOrObjectKafkaListenersBuilder()\n+                .addNewGenericKafkaListener()\n+                    .withName(\"tls\")\n+                    .withPort(9093)\n+                    .withType(KafkaListenerType.INTERNAL)\n+                    .withTls(true)\n+                    .withNewKafkaListenerAuthenticationOAuth()\n+                        .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n+                        .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n+                        .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n+                        .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n+                        .withUserNameClaim(keycloakInstance.getUserNameClaim())\n+                        .withTlsTrustedCertificates(\n+                            new CertSecretSourceBuilder()\n+                                .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME)\n+                                .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT)\n+                                .build())\n+                        .withDisableTlsHostnameVerification(true)\n+                        .withMaxSecondsWithoutReauthentication(30)\n+                    .endKafkaListenerAuthenticationOAuth()\n+                .endGenericKafkaListener()\n+                .build());\n+        });\n+\n+        KafkaUtils.waitForKafkaReady(CLUSTER_NAME);\n+\n+        String baseUri = \"https://\" + keycloakInstance.getHttpsUri();\n+\n+        LOGGER.info(\"Setting the master realm token's lifespan to 3600s\");\n+\n+        // get admin token for all operation on realms\n+        String userName =  new String(Base64.getDecoder().decode(kubeClient().getSecret(\"credential-example-keycloak\").getData().get(\"ADMIN_USERNAME\").getBytes()));\n+        String password = new String(Base64.getDecoder().decode(kubeClient().getSecret(\"credential-example-keycloak\").getData().get(\"ADMIN_PASSWORD\").getBytes()));\n+        String token = KeycloakUtils.getToken(baseUri, userName, password);\n+\n+        // firstly we will increase token lifespan\n+        JsonObject masterRealm = KeycloakUtils.getKeycloakRealm(baseUri, token, \"master\");\n+        masterRealm.put(\"accessTokenLifespan\", \"3600\");\n+        KeycloakUtils.putConfigurationToRealm(baseUri, token, masterRealm, \"master\");\n+\n+        // now we need to get the token with new lifespan\n+        token = KeycloakUtils.getToken(baseUri, userName, password);\n+\n+        LOGGER.info(\"Getting the {} kafka client for obtaining the Dev A Team policy for the x topics\", TEST_REALM);\n+        // we need to get clients for kafka-authz realm to access auth policies in kafka client\n+        JsonArray kafkaAuthzRealm = KeycloakUtils.getKeycloakRealmClients(baseUri, token, TEST_REALM);\n+\n+        String kafkaClientId = \"\";\n+        for (Object client : kafkaAuthzRealm) {\n+            JsonObject clientObject = new JsonObject(client.toString());\n+            if (clientObject.getString(\"clientId\").equals(\"kafka\")) {\n+                kafkaClientId = clientObject.getString(\"id\");\n+            }\n+        }\n+\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withDelayMs(1000)\n+            .build();\n+\n+        LOGGER.info(\"Deploying the Team A producer\");\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+\n+        JsonArray kafkaAuthzRealmPolicies = KeycloakUtils.getPoliciesFromRealmClient(baseUri, token, TEST_REALM, kafkaClientId);\n+\n+        JsonObject devAPolicy = new JsonObject();\n+        for (Object resource : kafkaAuthzRealmPolicies) {\n+            JsonObject resourceObject = new JsonObject(resource.toString());\n+            if (resourceObject.getValue(\"name\").toString().contains(\"Dev Team A can write to topics that start with x- on any cluster\")) {\n+                devAPolicy = resourceObject;\n+            }\n+        }\n+\n+        JsonObject newDevAPolicy = devAPolicy;\n+\n+        Map<String, String> config = new HashMap<>();\n+        config.put(\"resources\", \"[\\\"Topic:x-*\\\"]\");\n+        config.put(\"scopes\", \"[\\\"Describe\\\"]\");\n+        config.put(\"applyPolicies\", \"[\\\"Dev Team A\\\"]\");\n+\n+        newDevAPolicy.put(\"config\", config);\n+\n+        LOGGER.info(\"Changing the Dev Team A policy for topics starting with x- and checking that job will not be successful\");\n+        KeycloakUtils.updatePolicyOfRealmClient(baseUri, token, newDevAPolicy, TEST_REALM, kafkaClientId);\n+        assertThrows(WaitException.class, () -> ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT));\n+\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Changing back to the original settings and checking, if the producer will be successful\");\n+\n+        config.put(\"scopes\", \"[\\\"Describe\\\",\\\"Write\\\"]\");\n+        newDevAPolicy.put(\"config\", config);\n+\n+        KeycloakUtils.updatePolicyOfRealmClient(baseUri, token, newDevAPolicy, TEST_REALM, kafkaClientId);\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withDelayMs(1000)\n+            .build();\n+\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+        ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT);\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Changing configuration of Kafka back to it's original form\");\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setListeners(new ArrayOrObjectKafkaListenersBuilder()\n+                .addNewGenericKafkaListener()\n+                    .withName(\"tls\")\n+                    .withPort(9093)\n+                    .withType(KafkaListenerType.INTERNAL)\n+                    .withTls(true)\n+                    .withNewKafkaListenerAuthenticationOAuth()\n+                        .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n+                        .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n+                        .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n+                        .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n+                        .withUserNameClaim(keycloakInstance.getUserNameClaim())\n+                        .withTlsTrustedCertificates(\n+                            new CertSecretSourceBuilder()\n+                                .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME)\n+                                .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT)\n+                                .build())\n+                        .withDisableTlsHostnameVerification(true)\n+                    .endKafkaListenerAuthenticationOAuth()\n+                .endGenericKafkaListener()\n+                .build());\n+        });\n+\n+        KafkaUtils.waitForKafkaReady(CLUSTER_NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyMzQ2Nw=="}, "originalCommit": {"oid": "85190d583f502d07c4c9fb2873efe0ccc480de85"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY0MTY5Ng==", "bodyText": "Discussed offline, gonna add javadoc for the test. Any other comments were not mentioned on chat.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3736#discussion_r499641696", "createdAt": "2020-10-05T14:29:31Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -260,23 +270,171 @@ void testSuperUserWithOauthAuthorization() {\n         ClientUtils.waitForClientSuccess(TEAM_A_CONSUMER_NAME, NAMESPACE, MESSAGE_COUNT);\n     }\n \n-    @Disabled(\"Will be implemented in next PR\")\n     @Test\n     @Order(7)\n+    void testSessionReAuthentication() {\n+        String topicName = TOPIC_X + \"-example-topic\";\n+        LOGGER.info(\"Verifying that team A producer is able to send messages to the {} topic -> the topic starting with 'x'\", topicName);\n+\n+        KafkaTopicResource.topic(CLUSTER_NAME, topicName).done();\n+\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withTopicName(topicName)\n+            .withMessageCount(MESSAGE_COUNT)\n+            .build();\n+\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+        ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT);\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Adding the maxSecondsWithoutReauthentication to Kafka listener with OAuth authentication\");\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setListeners(new ArrayOrObjectKafkaListenersBuilder()\n+                .addNewGenericKafkaListener()\n+                    .withName(\"tls\")\n+                    .withPort(9093)\n+                    .withType(KafkaListenerType.INTERNAL)\n+                    .withTls(true)\n+                    .withNewKafkaListenerAuthenticationOAuth()\n+                        .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n+                        .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n+                        .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n+                        .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n+                        .withUserNameClaim(keycloakInstance.getUserNameClaim())\n+                        .withTlsTrustedCertificates(\n+                            new CertSecretSourceBuilder()\n+                                .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME)\n+                                .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT)\n+                                .build())\n+                        .withDisableTlsHostnameVerification(true)\n+                        .withMaxSecondsWithoutReauthentication(30)\n+                    .endKafkaListenerAuthenticationOAuth()\n+                .endGenericKafkaListener()\n+                .build());\n+        });\n+\n+        KafkaUtils.waitForKafkaReady(CLUSTER_NAME);\n+\n+        String baseUri = \"https://\" + keycloakInstance.getHttpsUri();\n+\n+        LOGGER.info(\"Setting the master realm token's lifespan to 3600s\");\n+\n+        // get admin token for all operation on realms\n+        String userName =  new String(Base64.getDecoder().decode(kubeClient().getSecret(\"credential-example-keycloak\").getData().get(\"ADMIN_USERNAME\").getBytes()));\n+        String password = new String(Base64.getDecoder().decode(kubeClient().getSecret(\"credential-example-keycloak\").getData().get(\"ADMIN_PASSWORD\").getBytes()));\n+        String token = KeycloakUtils.getToken(baseUri, userName, password);\n+\n+        // firstly we will increase token lifespan\n+        JsonObject masterRealm = KeycloakUtils.getKeycloakRealm(baseUri, token, \"master\");\n+        masterRealm.put(\"accessTokenLifespan\", \"3600\");\n+        KeycloakUtils.putConfigurationToRealm(baseUri, token, masterRealm, \"master\");\n+\n+        // now we need to get the token with new lifespan\n+        token = KeycloakUtils.getToken(baseUri, userName, password);\n+\n+        LOGGER.info(\"Getting the {} kafka client for obtaining the Dev A Team policy for the x topics\", TEST_REALM);\n+        // we need to get clients for kafka-authz realm to access auth policies in kafka client\n+        JsonArray kafkaAuthzRealm = KeycloakUtils.getKeycloakRealmClients(baseUri, token, TEST_REALM);\n+\n+        String kafkaClientId = \"\";\n+        for (Object client : kafkaAuthzRealm) {\n+            JsonObject clientObject = new JsonObject(client.toString());\n+            if (clientObject.getString(\"clientId\").equals(\"kafka\")) {\n+                kafkaClientId = clientObject.getString(\"id\");\n+            }\n+        }\n+\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withDelayMs(1000)\n+            .build();\n+\n+        LOGGER.info(\"Deploying the Team A producer\");\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+\n+        JsonArray kafkaAuthzRealmPolicies = KeycloakUtils.getPoliciesFromRealmClient(baseUri, token, TEST_REALM, kafkaClientId);\n+\n+        JsonObject devAPolicy = new JsonObject();\n+        for (Object resource : kafkaAuthzRealmPolicies) {\n+            JsonObject resourceObject = new JsonObject(resource.toString());\n+            if (resourceObject.getValue(\"name\").toString().contains(\"Dev Team A can write to topics that start with x- on any cluster\")) {\n+                devAPolicy = resourceObject;\n+            }\n+        }\n+\n+        JsonObject newDevAPolicy = devAPolicy;\n+\n+        Map<String, String> config = new HashMap<>();\n+        config.put(\"resources\", \"[\\\"Topic:x-*\\\"]\");\n+        config.put(\"scopes\", \"[\\\"Describe\\\"]\");\n+        config.put(\"applyPolicies\", \"[\\\"Dev Team A\\\"]\");\n+\n+        newDevAPolicy.put(\"config\", config);\n+\n+        LOGGER.info(\"Changing the Dev Team A policy for topics starting with x- and checking that job will not be successful\");\n+        KeycloakUtils.updatePolicyOfRealmClient(baseUri, token, newDevAPolicy, TEST_REALM, kafkaClientId);\n+        assertThrows(WaitException.class, () -> ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT));\n+\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Changing back to the original settings and checking, if the producer will be successful\");\n+\n+        config.put(\"scopes\", \"[\\\"Describe\\\",\\\"Write\\\"]\");\n+        newDevAPolicy.put(\"config\", config);\n+\n+        KeycloakUtils.updatePolicyOfRealmClient(baseUri, token, newDevAPolicy, TEST_REALM, kafkaClientId);\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withDelayMs(1000)\n+            .build();\n+\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+        ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT);\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Changing configuration of Kafka back to it's original form\");\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setListeners(new ArrayOrObjectKafkaListenersBuilder()\n+                .addNewGenericKafkaListener()\n+                    .withName(\"tls\")\n+                    .withPort(9093)\n+                    .withType(KafkaListenerType.INTERNAL)\n+                    .withTls(true)\n+                    .withNewKafkaListenerAuthenticationOAuth()\n+                        .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n+                        .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n+                        .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n+                        .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n+                        .withUserNameClaim(keycloakInstance.getUserNameClaim())\n+                        .withTlsTrustedCertificates(\n+                            new CertSecretSourceBuilder()\n+                                .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME)\n+                                .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT)\n+                                .build())\n+                        .withDisableTlsHostnameVerification(true)\n+                    .endKafkaListenerAuthenticationOAuth()\n+                .endGenericKafkaListener()\n+                .build());\n+        });\n+\n+        KafkaUtils.waitForKafkaReady(CLUSTER_NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyMzQ2Nw=="}, "originalCommit": {"oid": "85190d583f502d07c4c9fb2873efe0ccc480de85"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY0NjI3Mw==", "bodyText": "@scholzj about your comment -> do you think that the block is unnecessary? I'm just thinking that when we delete it now and someone will add test which will be affected by it, he will be finding where the problem is.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3736#discussion_r499646273", "createdAt": "2020-10-05T14:35:41Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -260,23 +270,171 @@ void testSuperUserWithOauthAuthorization() {\n         ClientUtils.waitForClientSuccess(TEAM_A_CONSUMER_NAME, NAMESPACE, MESSAGE_COUNT);\n     }\n \n-    @Disabled(\"Will be implemented in next PR\")\n     @Test\n     @Order(7)\n+    void testSessionReAuthentication() {\n+        String topicName = TOPIC_X + \"-example-topic\";\n+        LOGGER.info(\"Verifying that team A producer is able to send messages to the {} topic -> the topic starting with 'x'\", topicName);\n+\n+        KafkaTopicResource.topic(CLUSTER_NAME, topicName).done();\n+\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withTopicName(topicName)\n+            .withMessageCount(MESSAGE_COUNT)\n+            .build();\n+\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+        ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT);\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Adding the maxSecondsWithoutReauthentication to Kafka listener with OAuth authentication\");\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setListeners(new ArrayOrObjectKafkaListenersBuilder()\n+                .addNewGenericKafkaListener()\n+                    .withName(\"tls\")\n+                    .withPort(9093)\n+                    .withType(KafkaListenerType.INTERNAL)\n+                    .withTls(true)\n+                    .withNewKafkaListenerAuthenticationOAuth()\n+                        .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n+                        .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n+                        .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n+                        .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n+                        .withUserNameClaim(keycloakInstance.getUserNameClaim())\n+                        .withTlsTrustedCertificates(\n+                            new CertSecretSourceBuilder()\n+                                .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME)\n+                                .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT)\n+                                .build())\n+                        .withDisableTlsHostnameVerification(true)\n+                        .withMaxSecondsWithoutReauthentication(30)\n+                    .endKafkaListenerAuthenticationOAuth()\n+                .endGenericKafkaListener()\n+                .build());\n+        });\n+\n+        KafkaUtils.waitForKafkaReady(CLUSTER_NAME);\n+\n+        String baseUri = \"https://\" + keycloakInstance.getHttpsUri();\n+\n+        LOGGER.info(\"Setting the master realm token's lifespan to 3600s\");\n+\n+        // get admin token for all operation on realms\n+        String userName =  new String(Base64.getDecoder().decode(kubeClient().getSecret(\"credential-example-keycloak\").getData().get(\"ADMIN_USERNAME\").getBytes()));\n+        String password = new String(Base64.getDecoder().decode(kubeClient().getSecret(\"credential-example-keycloak\").getData().get(\"ADMIN_PASSWORD\").getBytes()));\n+        String token = KeycloakUtils.getToken(baseUri, userName, password);\n+\n+        // firstly we will increase token lifespan\n+        JsonObject masterRealm = KeycloakUtils.getKeycloakRealm(baseUri, token, \"master\");\n+        masterRealm.put(\"accessTokenLifespan\", \"3600\");\n+        KeycloakUtils.putConfigurationToRealm(baseUri, token, masterRealm, \"master\");\n+\n+        // now we need to get the token with new lifespan\n+        token = KeycloakUtils.getToken(baseUri, userName, password);\n+\n+        LOGGER.info(\"Getting the {} kafka client for obtaining the Dev A Team policy for the x topics\", TEST_REALM);\n+        // we need to get clients for kafka-authz realm to access auth policies in kafka client\n+        JsonArray kafkaAuthzRealm = KeycloakUtils.getKeycloakRealmClients(baseUri, token, TEST_REALM);\n+\n+        String kafkaClientId = \"\";\n+        for (Object client : kafkaAuthzRealm) {\n+            JsonObject clientObject = new JsonObject(client.toString());\n+            if (clientObject.getString(\"clientId\").equals(\"kafka\")) {\n+                kafkaClientId = clientObject.getString(\"id\");\n+            }\n+        }\n+\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withDelayMs(1000)\n+            .build();\n+\n+        LOGGER.info(\"Deploying the Team A producer\");\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+\n+        JsonArray kafkaAuthzRealmPolicies = KeycloakUtils.getPoliciesFromRealmClient(baseUri, token, TEST_REALM, kafkaClientId);\n+\n+        JsonObject devAPolicy = new JsonObject();\n+        for (Object resource : kafkaAuthzRealmPolicies) {\n+            JsonObject resourceObject = new JsonObject(resource.toString());\n+            if (resourceObject.getValue(\"name\").toString().contains(\"Dev Team A can write to topics that start with x- on any cluster\")) {\n+                devAPolicy = resourceObject;\n+            }\n+        }\n+\n+        JsonObject newDevAPolicy = devAPolicy;\n+\n+        Map<String, String> config = new HashMap<>();\n+        config.put(\"resources\", \"[\\\"Topic:x-*\\\"]\");\n+        config.put(\"scopes\", \"[\\\"Describe\\\"]\");\n+        config.put(\"applyPolicies\", \"[\\\"Dev Team A\\\"]\");\n+\n+        newDevAPolicy.put(\"config\", config);\n+\n+        LOGGER.info(\"Changing the Dev Team A policy for topics starting with x- and checking that job will not be successful\");\n+        KeycloakUtils.updatePolicyOfRealmClient(baseUri, token, newDevAPolicy, TEST_REALM, kafkaClientId);\n+        assertThrows(WaitException.class, () -> ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT));\n+\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Changing back to the original settings and checking, if the producer will be successful\");\n+\n+        config.put(\"scopes\", \"[\\\"Describe\\\",\\\"Write\\\"]\");\n+        newDevAPolicy.put(\"config\", config);\n+\n+        KeycloakUtils.updatePolicyOfRealmClient(baseUri, token, newDevAPolicy, TEST_REALM, kafkaClientId);\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withDelayMs(1000)\n+            .build();\n+\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+        ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT);\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Changing configuration of Kafka back to it's original form\");\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setListeners(new ArrayOrObjectKafkaListenersBuilder()\n+                .addNewGenericKafkaListener()\n+                    .withName(\"tls\")\n+                    .withPort(9093)\n+                    .withType(KafkaListenerType.INTERNAL)\n+                    .withTls(true)\n+                    .withNewKafkaListenerAuthenticationOAuth()\n+                        .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n+                        .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n+                        .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n+                        .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n+                        .withUserNameClaim(keycloakInstance.getUserNameClaim())\n+                        .withTlsTrustedCertificates(\n+                            new CertSecretSourceBuilder()\n+                                .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME)\n+                                .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT)\n+                                .build())\n+                        .withDisableTlsHostnameVerification(true)\n+                    .endKafkaListenerAuthenticationOAuth()\n+                .endGenericKafkaListener()\n+                .build());\n+        });\n+\n+        KafkaUtils.waitForKafkaReady(CLUSTER_NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyMzQ2Nw=="}, "originalCommit": {"oid": "85190d583f502d07c4c9fb2873efe0ccc480de85"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY3NDUwNg==", "bodyText": "Well, first of all I think tests relying on an order in which they are executed are not great. And when you change things there and back like here it will not safe time either. But that is probably for another PR.\nSecond, until the followup tests are added, this is just wasting time. And you do not even know what kind of settings they will need. So maybe you can just leave some comment or something for whoever might add these tests one day and remove this, or?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3736#discussion_r499674506", "createdAt": "2020-10-05T15:13:34Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -260,23 +270,171 @@ void testSuperUserWithOauthAuthorization() {\n         ClientUtils.waitForClientSuccess(TEAM_A_CONSUMER_NAME, NAMESPACE, MESSAGE_COUNT);\n     }\n \n-    @Disabled(\"Will be implemented in next PR\")\n     @Test\n     @Order(7)\n+    void testSessionReAuthentication() {\n+        String topicName = TOPIC_X + \"-example-topic\";\n+        LOGGER.info(\"Verifying that team A producer is able to send messages to the {} topic -> the topic starting with 'x'\", topicName);\n+\n+        KafkaTopicResource.topic(CLUSTER_NAME, topicName).done();\n+\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withTopicName(topicName)\n+            .withMessageCount(MESSAGE_COUNT)\n+            .build();\n+\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+        ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT);\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Adding the maxSecondsWithoutReauthentication to Kafka listener with OAuth authentication\");\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setListeners(new ArrayOrObjectKafkaListenersBuilder()\n+                .addNewGenericKafkaListener()\n+                    .withName(\"tls\")\n+                    .withPort(9093)\n+                    .withType(KafkaListenerType.INTERNAL)\n+                    .withTls(true)\n+                    .withNewKafkaListenerAuthenticationOAuth()\n+                        .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n+                        .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n+                        .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n+                        .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n+                        .withUserNameClaim(keycloakInstance.getUserNameClaim())\n+                        .withTlsTrustedCertificates(\n+                            new CertSecretSourceBuilder()\n+                                .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME)\n+                                .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT)\n+                                .build())\n+                        .withDisableTlsHostnameVerification(true)\n+                        .withMaxSecondsWithoutReauthentication(30)\n+                    .endKafkaListenerAuthenticationOAuth()\n+                .endGenericKafkaListener()\n+                .build());\n+        });\n+\n+        KafkaUtils.waitForKafkaReady(CLUSTER_NAME);\n+\n+        String baseUri = \"https://\" + keycloakInstance.getHttpsUri();\n+\n+        LOGGER.info(\"Setting the master realm token's lifespan to 3600s\");\n+\n+        // get admin token for all operation on realms\n+        String userName =  new String(Base64.getDecoder().decode(kubeClient().getSecret(\"credential-example-keycloak\").getData().get(\"ADMIN_USERNAME\").getBytes()));\n+        String password = new String(Base64.getDecoder().decode(kubeClient().getSecret(\"credential-example-keycloak\").getData().get(\"ADMIN_PASSWORD\").getBytes()));\n+        String token = KeycloakUtils.getToken(baseUri, userName, password);\n+\n+        // firstly we will increase token lifespan\n+        JsonObject masterRealm = KeycloakUtils.getKeycloakRealm(baseUri, token, \"master\");\n+        masterRealm.put(\"accessTokenLifespan\", \"3600\");\n+        KeycloakUtils.putConfigurationToRealm(baseUri, token, masterRealm, \"master\");\n+\n+        // now we need to get the token with new lifespan\n+        token = KeycloakUtils.getToken(baseUri, userName, password);\n+\n+        LOGGER.info(\"Getting the {} kafka client for obtaining the Dev A Team policy for the x topics\", TEST_REALM);\n+        // we need to get clients for kafka-authz realm to access auth policies in kafka client\n+        JsonArray kafkaAuthzRealm = KeycloakUtils.getKeycloakRealmClients(baseUri, token, TEST_REALM);\n+\n+        String kafkaClientId = \"\";\n+        for (Object client : kafkaAuthzRealm) {\n+            JsonObject clientObject = new JsonObject(client.toString());\n+            if (clientObject.getString(\"clientId\").equals(\"kafka\")) {\n+                kafkaClientId = clientObject.getString(\"id\");\n+            }\n+        }\n+\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withDelayMs(1000)\n+            .build();\n+\n+        LOGGER.info(\"Deploying the Team A producer\");\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+\n+        JsonArray kafkaAuthzRealmPolicies = KeycloakUtils.getPoliciesFromRealmClient(baseUri, token, TEST_REALM, kafkaClientId);\n+\n+        JsonObject devAPolicy = new JsonObject();\n+        for (Object resource : kafkaAuthzRealmPolicies) {\n+            JsonObject resourceObject = new JsonObject(resource.toString());\n+            if (resourceObject.getValue(\"name\").toString().contains(\"Dev Team A can write to topics that start with x- on any cluster\")) {\n+                devAPolicy = resourceObject;\n+            }\n+        }\n+\n+        JsonObject newDevAPolicy = devAPolicy;\n+\n+        Map<String, String> config = new HashMap<>();\n+        config.put(\"resources\", \"[\\\"Topic:x-*\\\"]\");\n+        config.put(\"scopes\", \"[\\\"Describe\\\"]\");\n+        config.put(\"applyPolicies\", \"[\\\"Dev Team A\\\"]\");\n+\n+        newDevAPolicy.put(\"config\", config);\n+\n+        LOGGER.info(\"Changing the Dev Team A policy for topics starting with x- and checking that job will not be successful\");\n+        KeycloakUtils.updatePolicyOfRealmClient(baseUri, token, newDevAPolicy, TEST_REALM, kafkaClientId);\n+        assertThrows(WaitException.class, () -> ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT));\n+\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Changing back to the original settings and checking, if the producer will be successful\");\n+\n+        config.put(\"scopes\", \"[\\\"Describe\\\",\\\"Write\\\"]\");\n+        newDevAPolicy.put(\"config\", config);\n+\n+        KeycloakUtils.updatePolicyOfRealmClient(baseUri, token, newDevAPolicy, TEST_REALM, kafkaClientId);\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withDelayMs(1000)\n+            .build();\n+\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+        ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT);\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Changing configuration of Kafka back to it's original form\");\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setListeners(new ArrayOrObjectKafkaListenersBuilder()\n+                .addNewGenericKafkaListener()\n+                    .withName(\"tls\")\n+                    .withPort(9093)\n+                    .withType(KafkaListenerType.INTERNAL)\n+                    .withTls(true)\n+                    .withNewKafkaListenerAuthenticationOAuth()\n+                        .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n+                        .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n+                        .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n+                        .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n+                        .withUserNameClaim(keycloakInstance.getUserNameClaim())\n+                        .withTlsTrustedCertificates(\n+                            new CertSecretSourceBuilder()\n+                                .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME)\n+                                .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT)\n+                                .build())\n+                        .withDisableTlsHostnameVerification(true)\n+                    .endKafkaListenerAuthenticationOAuth()\n+                .endGenericKafkaListener()\n+                .build());\n+        });\n+\n+        KafkaUtils.waitForKafkaReady(CLUSTER_NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyMzQ2Nw=="}, "originalCommit": {"oid": "85190d583f502d07c4c9fb2873efe0ccc480de85"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczNjU4OA==", "bodyText": "Yes, definitely. Thanks :)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3736#discussion_r499736588", "createdAt": "2020-10-05T16:48:53Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -260,23 +270,171 @@ void testSuperUserWithOauthAuthorization() {\n         ClientUtils.waitForClientSuccess(TEAM_A_CONSUMER_NAME, NAMESPACE, MESSAGE_COUNT);\n     }\n \n-    @Disabled(\"Will be implemented in next PR\")\n     @Test\n     @Order(7)\n+    void testSessionReAuthentication() {\n+        String topicName = TOPIC_X + \"-example-topic\";\n+        LOGGER.info(\"Verifying that team A producer is able to send messages to the {} topic -> the topic starting with 'x'\", topicName);\n+\n+        KafkaTopicResource.topic(CLUSTER_NAME, topicName).done();\n+\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withTopicName(topicName)\n+            .withMessageCount(MESSAGE_COUNT)\n+            .build();\n+\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+        ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT);\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Adding the maxSecondsWithoutReauthentication to Kafka listener with OAuth authentication\");\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setListeners(new ArrayOrObjectKafkaListenersBuilder()\n+                .addNewGenericKafkaListener()\n+                    .withName(\"tls\")\n+                    .withPort(9093)\n+                    .withType(KafkaListenerType.INTERNAL)\n+                    .withTls(true)\n+                    .withNewKafkaListenerAuthenticationOAuth()\n+                        .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n+                        .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n+                        .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n+                        .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n+                        .withUserNameClaim(keycloakInstance.getUserNameClaim())\n+                        .withTlsTrustedCertificates(\n+                            new CertSecretSourceBuilder()\n+                                .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME)\n+                                .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT)\n+                                .build())\n+                        .withDisableTlsHostnameVerification(true)\n+                        .withMaxSecondsWithoutReauthentication(30)\n+                    .endKafkaListenerAuthenticationOAuth()\n+                .endGenericKafkaListener()\n+                .build());\n+        });\n+\n+        KafkaUtils.waitForKafkaReady(CLUSTER_NAME);\n+\n+        String baseUri = \"https://\" + keycloakInstance.getHttpsUri();\n+\n+        LOGGER.info(\"Setting the master realm token's lifespan to 3600s\");\n+\n+        // get admin token for all operation on realms\n+        String userName =  new String(Base64.getDecoder().decode(kubeClient().getSecret(\"credential-example-keycloak\").getData().get(\"ADMIN_USERNAME\").getBytes()));\n+        String password = new String(Base64.getDecoder().decode(kubeClient().getSecret(\"credential-example-keycloak\").getData().get(\"ADMIN_PASSWORD\").getBytes()));\n+        String token = KeycloakUtils.getToken(baseUri, userName, password);\n+\n+        // firstly we will increase token lifespan\n+        JsonObject masterRealm = KeycloakUtils.getKeycloakRealm(baseUri, token, \"master\");\n+        masterRealm.put(\"accessTokenLifespan\", \"3600\");\n+        KeycloakUtils.putConfigurationToRealm(baseUri, token, masterRealm, \"master\");\n+\n+        // now we need to get the token with new lifespan\n+        token = KeycloakUtils.getToken(baseUri, userName, password);\n+\n+        LOGGER.info(\"Getting the {} kafka client for obtaining the Dev A Team policy for the x topics\", TEST_REALM);\n+        // we need to get clients for kafka-authz realm to access auth policies in kafka client\n+        JsonArray kafkaAuthzRealm = KeycloakUtils.getKeycloakRealmClients(baseUri, token, TEST_REALM);\n+\n+        String kafkaClientId = \"\";\n+        for (Object client : kafkaAuthzRealm) {\n+            JsonObject clientObject = new JsonObject(client.toString());\n+            if (clientObject.getString(\"clientId\").equals(\"kafka\")) {\n+                kafkaClientId = clientObject.getString(\"id\");\n+            }\n+        }\n+\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withDelayMs(1000)\n+            .build();\n+\n+        LOGGER.info(\"Deploying the Team A producer\");\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+\n+        JsonArray kafkaAuthzRealmPolicies = KeycloakUtils.getPoliciesFromRealmClient(baseUri, token, TEST_REALM, kafkaClientId);\n+\n+        JsonObject devAPolicy = new JsonObject();\n+        for (Object resource : kafkaAuthzRealmPolicies) {\n+            JsonObject resourceObject = new JsonObject(resource.toString());\n+            if (resourceObject.getValue(\"name\").toString().contains(\"Dev Team A can write to topics that start with x- on any cluster\")) {\n+                devAPolicy = resourceObject;\n+            }\n+        }\n+\n+        JsonObject newDevAPolicy = devAPolicy;\n+\n+        Map<String, String> config = new HashMap<>();\n+        config.put(\"resources\", \"[\\\"Topic:x-*\\\"]\");\n+        config.put(\"scopes\", \"[\\\"Describe\\\"]\");\n+        config.put(\"applyPolicies\", \"[\\\"Dev Team A\\\"]\");\n+\n+        newDevAPolicy.put(\"config\", config);\n+\n+        LOGGER.info(\"Changing the Dev Team A policy for topics starting with x- and checking that job will not be successful\");\n+        KeycloakUtils.updatePolicyOfRealmClient(baseUri, token, newDevAPolicy, TEST_REALM, kafkaClientId);\n+        assertThrows(WaitException.class, () -> ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT));\n+\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Changing back to the original settings and checking, if the producer will be successful\");\n+\n+        config.put(\"scopes\", \"[\\\"Describe\\\",\\\"Write\\\"]\");\n+        newDevAPolicy.put(\"config\", config);\n+\n+        KeycloakUtils.updatePolicyOfRealmClient(baseUri, token, newDevAPolicy, TEST_REALM, kafkaClientId);\n+        teamAOauthClientJob = teamAOauthClientJob.toBuilder()\n+            .withDelayMs(1000)\n+            .build();\n+\n+        teamAOauthClientJob.producerStrimziOauthTls(CLUSTER_NAME).done();\n+        ClientUtils.waitForClientSuccess(TEAM_A_PRODUCER_NAME, NAMESPACE, MESSAGE_COUNT);\n+        JobUtils.deleteJobWithWait(NAMESPACE, TEAM_A_PRODUCER_NAME);\n+\n+        LOGGER.info(\"Changing configuration of Kafka back to it's original form\");\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setListeners(new ArrayOrObjectKafkaListenersBuilder()\n+                .addNewGenericKafkaListener()\n+                    .withName(\"tls\")\n+                    .withPort(9093)\n+                    .withType(KafkaListenerType.INTERNAL)\n+                    .withTls(true)\n+                    .withNewKafkaListenerAuthenticationOAuth()\n+                        .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n+                        .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n+                        .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n+                        .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n+                        .withUserNameClaim(keycloakInstance.getUserNameClaim())\n+                        .withTlsTrustedCertificates(\n+                            new CertSecretSourceBuilder()\n+                                .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME)\n+                                .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT)\n+                                .build())\n+                        .withDisableTlsHostnameVerification(true)\n+                    .endKafkaListenerAuthenticationOAuth()\n+                .endGenericKafkaListener()\n+                .build());\n+        });\n+\n+        KafkaUtils.waitForKafkaReady(CLUSTER_NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyMzQ2Nw=="}, "originalCommit": {"oid": "85190d583f502d07c4c9fb2873efe0ccc480de85"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODQzNzAzOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDo0NDoyNlrOHcgZZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNjoyMDoyM1rOHckenQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY1Mjk2Ng==", "bodyText": "Add that this is supposed to succeed. Is this to make sure the initial configuration is as expected or what?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3736#discussion_r499652966", "createdAt": "2020-10-05T14:44:26Z", "author": {"login": "mstruk"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -260,23 +270,184 @@ void testSuperUserWithOauthAuthorization() {\n         ClientUtils.waitForClientSuccess(TEAM_A_CONSUMER_NAME, NAMESPACE, MESSAGE_COUNT);\n     }\n \n-    @Disabled(\"Will be implemented in next PR\")\n+    /**\n+     * 1) Try to send messages to topic starting with `x-` with producer from Dev Team A", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e3cde2fe75b7d94cfc9139b9602a6603da29937"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxOTgzNw==", "bodyText": "this is just to make sure that it's functional before the change", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3736#discussion_r499719837", "createdAt": "2020-10-05T16:20:23Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -260,23 +270,184 @@ void testSuperUserWithOauthAuthorization() {\n         ClientUtils.waitForClientSuccess(TEAM_A_CONSUMER_NAME, NAMESPACE, MESSAGE_COUNT);\n     }\n \n-    @Disabled(\"Will be implemented in next PR\")\n+    /**\n+     * 1) Try to send messages to topic starting with `x-` with producer from Dev Team A", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY1Mjk2Ng=="}, "originalCommit": {"oid": "5e3cde2fe75b7d94cfc9139b9602a6603da29937"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODQ0NDk1OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDo0NjowM1rOHcgeFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDo0NjowM1rOHcgeFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY1NDE2NA==", "bodyText": "Ok, so this activates the expiry checking on tokens, and will cause automatic client reauthentication when the maxSecondsWithoutReauthentication is reached.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3736#discussion_r499654164", "createdAt": "2020-10-05T14:46:03Z", "author": {"login": "mstruk"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -260,23 +270,184 @@ void testSuperUserWithOauthAuthorization() {\n         ClientUtils.waitForClientSuccess(TEAM_A_CONSUMER_NAME, NAMESPACE, MESSAGE_COUNT);\n     }\n \n-    @Disabled(\"Will be implemented in next PR\")\n+    /**\n+     * 1) Try to send messages to topic starting with `x-` with producer from Dev Team A\n+     * 2) Change the Oauth listener configuration -> add the maxSecondsWithoutReauthentication set to 30s", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e3cde2fe75b7d94cfc9139b9602a6603da29937"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODQ1MDEyOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDo0NzowMFrOHcghHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNjoyMzozOFrOHckmow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY1NDk0Mg==", "bodyText": "So this keeps running in the background, sending a message every second until it fails?\nOk, so I guess here we assume that now reauthentication is enabled - we are not testing here if we have successfully enabled it (maybe we didn't), we assume that it is enabled now and now we want to run the test for more than 30 seconds in order for reauthentication to kick in and we want to see the producer keep sending messages beyond 30 seconds.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3736#discussion_r499654942", "createdAt": "2020-10-05T14:47:00Z", "author": {"login": "mstruk"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -260,23 +270,184 @@ void testSuperUserWithOauthAuthorization() {\n         ClientUtils.waitForClientSuccess(TEAM_A_CONSUMER_NAME, NAMESPACE, MESSAGE_COUNT);\n     }\n \n-    @Disabled(\"Will be implemented in next PR\")\n+    /**\n+     * 1) Try to send messages to topic starting with `x-` with producer from Dev Team A\n+     * 2) Change the Oauth listener configuration -> add the maxSecondsWithoutReauthentication set to 30s\n+     * 3) Try to send messages with delay of 1000ms (in the meantime, the permissions configuration will be changed)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e3cde2fe75b7d94cfc9139b9602a6603da29937"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyMTg5MQ==", "bodyText": "yes, you can look to the log and see if the re-auth happen, but it will sometimes fail on oc cluster up, so I don't recommend to do it.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3736#discussion_r499721891", "createdAt": "2020-10-05T16:23:38Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -260,23 +270,184 @@ void testSuperUserWithOauthAuthorization() {\n         ClientUtils.waitForClientSuccess(TEAM_A_CONSUMER_NAME, NAMESPACE, MESSAGE_COUNT);\n     }\n \n-    @Disabled(\"Will be implemented in next PR\")\n+    /**\n+     * 1) Try to send messages to topic starting with `x-` with producer from Dev Team A\n+     * 2) Change the Oauth listener configuration -> add the maxSecondsWithoutReauthentication set to 30s\n+     * 3) Try to send messages with delay of 1000ms (in the meantime, the permissions configuration will be changed)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY1NDk0Mg=="}, "originalCommit": {"oid": "5e3cde2fe75b7d94cfc9139b9602a6603da29937"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODQ2MDEyOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDo0OToxMFrOHcgnYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDo0OToxMFrOHcgnYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY1NjU0Nw==", "bodyText": "Here it would be nice if some idea of why we are doing this and how it fits into testing reauthentication is outlined. It seems to me that we are conflating the refreshing of grants with reauthentication into a single test where if something fails the failure can't clearly tell us what's wrong. The connection between reauthentication and fetching of grants is that the fetching of grants will fail if the access token is expired, and reauthentication prevents access token from expiring. It's unclear what the access token time to live is (that's kafka-authz realm, not master realm), but if it is longer than 30 seconds, and reauthentication with 30s is enabled, then the token will never expire and re-fetching the grants will succeed. If reauthentication is not enabled then the token will expire eventually and the fetching of grants will fail after the token expires, but the test may not wait that long in any case.\nI guess that we assume that the enabling of reauthentication properly works and in that case we expect that token should never expire.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3736#discussion_r499656547", "createdAt": "2020-10-05T14:49:10Z", "author": {"login": "mstruk"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -260,23 +270,184 @@ void testSuperUserWithOauthAuthorization() {\n         ClientUtils.waitForClientSuccess(TEAM_A_CONSUMER_NAME, NAMESPACE, MESSAGE_COUNT);\n     }\n \n-    @Disabled(\"Will be implemented in next PR\")\n+    /**\n+     * 1) Try to send messages to topic starting with `x-` with producer from Dev Team A\n+     * 2) Change the Oauth listener configuration -> add the maxSecondsWithoutReauthentication set to 30s\n+     * 3) Try to send messages with delay of 1000ms (in the meantime, the permissions configuration will be changed)\n+     * 4) Get all configuration from the Keycloak (realms, policies) and change the policy so the Dev Team A producer should not be able to send messages to the topic\n+     *      starting with `x-` -> updating the policy through the Keycloak API", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e3cde2fe75b7d94cfc9139b9602a6603da29937"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODYyMzQ0OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNToyNTowNFrOHciNBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMDowNDo1NVrOHdX-HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY4MjU2Ng==", "bodyText": "The question here is in which cases will WaitException occur. Can it occur because the broker is slow or connection with broker is slow? If so the thing will fail due to something else - not due to TopicAuthorizationException. In that case the test will pass even though it didn't properly execute. You have to actually get to the underlying reason for failure, WaitException may not be enough to properly test the expected behaviour here.\nBut most of all, as far as I can see this test rather than test if reauthentication is activated, assumes that it is activated and properly working, and then tests some expected behavior on top of that assumption. It does not test reauthentication. It tests refreshing of grants under the assumption that reauthentication is active and working as assumed. There may be a bug in how Kafka CR is turned into Kafka Broker /tmp/strimzi.properties and even though you activate reauthentication in Kafka CR it may not actually be enabled in Kafka Broker. This test might (depending on the access token timeout) pass even if reauthentication isn't actually activated.\nIt might even pass (to my understanding, as described above) if the test cluster is simply slow and unresponsive.\nI said that testing this was tricky, so it should be worked out in a document before attempting to write a complicated test. This test will probably pass even if reauthentication doesn't work at all.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3736#discussion_r499682566", "createdAt": "2020-10-05T15:25:04Z", "author": {"login": "mstruk"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -260,23 +270,184 @@ void testSuperUserWithOauthAuthorization() {\n         ClientUtils.waitForClientSuccess(TEAM_A_CONSUMER_NAME, NAMESPACE, MESSAGE_COUNT);\n     }\n \n-    @Disabled(\"Will be implemented in next PR\")\n+    /**\n+     * 1) Try to send messages to topic starting with `x-` with producer from Dev Team A\n+     * 2) Change the Oauth listener configuration -> add the maxSecondsWithoutReauthentication set to 30s\n+     * 3) Try to send messages with delay of 1000ms (in the meantime, the permissions configuration will be changed)\n+     * 4) Get all configuration from the Keycloak (realms, policies) and change the policy so the Dev Team A producer should not be able to send messages to the topic\n+     *      starting with `x-` -> updating the policy through the Keycloak API\n+     * 5) Wait for the WaitException to appear -> as the producer doesn't have permission for sending messages, the\n+     *      job will be in error state", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e3cde2fe75b7d94cfc9139b9602a6603da29937"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0NzQxMw==", "bodyText": "Well you didn't tell me any good approach how to test it until now. I didn't got any information from you.All of this is idea from @see-quick and @Frawless, that we discussed, how I said, the best way how to test it. How I mentioned above, another way how to look if the re-auth is functional is through the log and again, how I mentioned above, we don't want to do it this way.\nAlso, some of things you described, like testing if the reauth is working properly on Kafka broker etc. is thing of the unit tests or IT, which you should write to make sure, that everything is working as expected. This should not be part of the ST. ST should test some scenario and expect some behaviour.\nIf you have better idea how to test it, which will not have any limitations and will be simple to test (like you can see in here) go on and ping me.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3736#discussion_r499747413", "createdAt": "2020-10-05T17:07:54Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -260,23 +270,184 @@ void testSuperUserWithOauthAuthorization() {\n         ClientUtils.waitForClientSuccess(TEAM_A_CONSUMER_NAME, NAMESPACE, MESSAGE_COUNT);\n     }\n \n-    @Disabled(\"Will be implemented in next PR\")\n+    /**\n+     * 1) Try to send messages to topic starting with `x-` with producer from Dev Team A\n+     * 2) Change the Oauth listener configuration -> add the maxSecondsWithoutReauthentication set to 30s\n+     * 3) Try to send messages with delay of 1000ms (in the meantime, the permissions configuration will be changed)\n+     * 4) Get all configuration from the Keycloak (realms, policies) and change the policy so the Dev Team A producer should not be able to send messages to the topic\n+     *      starting with `x-` -> updating the policy through the Keycloak API\n+     * 5) Wait for the WaitException to appear -> as the producer doesn't have permission for sending messages, the\n+     *      job will be in error state", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY4MjU2Ng=="}, "originalCommit": {"oid": "5e3cde2fe75b7d94cfc9139b9602a6603da29937"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE0NDczMg==", "bodyText": "I'll prepare a testing document, how I imagine you could test this functionality. You can always delay starting the work on an issue if you think you don't have enough information from me for example, and are waiting for me to provide clarifications, or a thorough plan or whatever - but do let me know when you need more info from me in order to be able to proceed. In this case I can see that you need it so I'll provide the plan.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3736#discussion_r500144732", "createdAt": "2020-10-06T09:45:04Z", "author": {"login": "mstruk"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -260,23 +270,184 @@ void testSuperUserWithOauthAuthorization() {\n         ClientUtils.waitForClientSuccess(TEAM_A_CONSUMER_NAME, NAMESPACE, MESSAGE_COUNT);\n     }\n \n-    @Disabled(\"Will be implemented in next PR\")\n+    /**\n+     * 1) Try to send messages to topic starting with `x-` with producer from Dev Team A\n+     * 2) Change the Oauth listener configuration -> add the maxSecondsWithoutReauthentication set to 30s\n+     * 3) Try to send messages with delay of 1000ms (in the meantime, the permissions configuration will be changed)\n+     * 4) Get all configuration from the Keycloak (realms, policies) and change the policy so the Dev Team A producer should not be able to send messages to the topic\n+     *      starting with `x-` -> updating the policy through the Keycloak API\n+     * 5) Wait for the WaitException to appear -> as the producer doesn't have permission for sending messages, the\n+     *      job will be in error state", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY4MjU2Ng=="}, "originalCommit": {"oid": "5e3cde2fe75b7d94cfc9139b9602a6603da29937"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE3MTM0MA==", "bodyText": "Okay, let's wait for some better scenario, to have it tested properly. Thanks @mstruk .", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3736#discussion_r500171340", "createdAt": "2020-10-06T10:32:41Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -260,23 +270,184 @@ void testSuperUserWithOauthAuthorization() {\n         ClientUtils.waitForClientSuccess(TEAM_A_CONSUMER_NAME, NAMESPACE, MESSAGE_COUNT);\n     }\n \n-    @Disabled(\"Will be implemented in next PR\")\n+    /**\n+     * 1) Try to send messages to topic starting with `x-` with producer from Dev Team A\n+     * 2) Change the Oauth listener configuration -> add the maxSecondsWithoutReauthentication set to 30s\n+     * 3) Try to send messages with delay of 1000ms (in the meantime, the permissions configuration will be changed)\n+     * 4) Get all configuration from the Keycloak (realms, policies) and change the policy so the Dev Team A producer should not be able to send messages to the topic\n+     *      starting with `x-` -> updating the policy through the Keycloak API\n+     * 5) Wait for the WaitException to appear -> as the producer doesn't have permission for sending messages, the\n+     *      job will be in error state", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY4MjU2Ng=="}, "originalCommit": {"oid": "5e3cde2fe75b7d94cfc9139b9602a6603da29937"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM0MjA5MA==", "bodyText": "So should we close this in the meantime?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3736#discussion_r500342090", "createdAt": "2020-10-06T14:37:48Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -260,23 +270,184 @@ void testSuperUserWithOauthAuthorization() {\n         ClientUtils.waitForClientSuccess(TEAM_A_CONSUMER_NAME, NAMESPACE, MESSAGE_COUNT);\n     }\n \n-    @Disabled(\"Will be implemented in next PR\")\n+    /**\n+     * 1) Try to send messages to topic starting with `x-` with producer from Dev Team A\n+     * 2) Change the Oauth listener configuration -> add the maxSecondsWithoutReauthentication set to 30s\n+     * 3) Try to send messages with delay of 1000ms (in the meantime, the permissions configuration will be changed)\n+     * 4) Get all configuration from the Keycloak (realms, policies) and change the policy so the Dev Team A producer should not be able to send messages to the topic\n+     *      starting with `x-` -> updating the policy through the Keycloak API\n+     * 5) Wait for the WaitException to appear -> as the producer doesn't have permission for sending messages, the\n+     *      job will be in error state", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY4MjU2Ng=="}, "originalCommit": {"oid": "5e3cde2fe75b7d94cfc9139b9602a6603da29937"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU2MzQ4NQ==", "bodyText": "Yeah, maybe we can :)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3736#discussion_r500563485", "createdAt": "2020-10-06T20:04:55Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -260,23 +270,184 @@ void testSuperUserWithOauthAuthorization() {\n         ClientUtils.waitForClientSuccess(TEAM_A_CONSUMER_NAME, NAMESPACE, MESSAGE_COUNT);\n     }\n \n-    @Disabled(\"Will be implemented in next PR\")\n+    /**\n+     * 1) Try to send messages to topic starting with `x-` with producer from Dev Team A\n+     * 2) Change the Oauth listener configuration -> add the maxSecondsWithoutReauthentication set to 30s\n+     * 3) Try to send messages with delay of 1000ms (in the meantime, the permissions configuration will be changed)\n+     * 4) Get all configuration from the Keycloak (realms, policies) and change the policy so the Dev Team A producer should not be able to send messages to the topic\n+     *      starting with `x-` -> updating the policy through the Keycloak API\n+     * 5) Wait for the WaitException to appear -> as the producer doesn't have permission for sending messages, the\n+     *      job will be in error state", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY4MjU2Ng=="}, "originalCommit": {"oid": "5e3cde2fe75b7d94cfc9139b9602a6603da29937"}, "originalPosition": 60}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1173, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}