{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3MTEwMjQx", "number": 2773, "title": "Cruise Control deployment", "bodyText": "Type of change\n\nEnhancement / new feature\n\nDescription\nGives the ability to bring up a Cruise Control instance to monitor a Strimzi Kafka cluster. Cruise Control and its configurations can be declared in a Kafka resource like this:\napiVersion: kafka.strimzi.io/v1beta1\nkind: Kafka\nmetadata:\n...\nspec:\n  kafka:\n    ...\n  cruiseControl:\n    image: <image>\n    jvmOptions: {}\n    logging: {}\n    template: {}\n    resources: {}\n    tlsSideCar: {}\n    readinessProbe: {}\n    livenessProbe: {}\n    brokerCapacity: [1]\n      disk: 100G\n      cpu: 100     # as a percentage (0-100)\n      inboundNetwork: 10000KB/s\n      outboundNetwork: 10000KB/s\n    config: [2]\n      default.goals:<list_of_goals>\n      goals: <list_of_goals>\n      intra.broker.goals: <list_of_goals>\n      hard.goals: <list_of_goals>\n      cpu.balance.threshold: 1.1\n      metadata.max.age.ms: 300000\n      send.buffer.bytes: 131072\n      ...\nAfter declaring a cruiseControl in the resource's spec, all Kafka brokers will be rerolled with a Cruise Control metric reporter which will gather metrics about the cluster and store them in a Kafka topic. The Cruise Control application will then process these metrics and use them to learn about the cluster.\nNote: This is PR exposes the full Cruise Control API, but later PRs will lock this API down, making only a subset of the operations available through another resource.\n[1] Cruise Control uses these capacity limits to determine if goals related to broker resources are being violated. (e.g. DiskCapacityGoal: violated when the disk capacity set for a broker is exceeded by the disk being used by that broker). The settings specified here will populate the capacity configuration file fed to Cruise Control (https://github.com/linkedin/cruise-control/blob/2.0.97/config/capacity.json)\n[2] Represents the Cruise Control properties file used for configuring the Cruise Control application (https://github.com/linkedin/cruise-control/wiki/Configurations) All configurations are allowed except for the FORBIDDEN CONFIG OPTIONS =  bootstrap.servers, client.id, zookeeper., network., security., failed.brokers.zk.path, webserver.http., webserver.api.urlprefix, webserver.session.path, webserver.accesslog., two.step., request.reason.required, metric.reporter.topic, partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, self.healing.\nChecklist\nPlease go through this checklist and make sure all applicable tasks have been done\n\n Update/write design documentation in ./design\n Write tests\n Make sure all tests pass\n Update documentation\n Check RBAC rights for Kubernetes / OpenShift roles\n Try your changes from Pod inside your Kubernetes and OpenShift cluster, not just locally\n Reference relevant issue(s) and close them after merging\n Update CHANGELOG.md", "createdAt": "2020-04-01T16:44:39Z", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773", "merged": true, "mergeCommit": {"oid": "1a94d2e2df6dce7ec42943e38c52a4305e203a3f"}, "closed": true, "closedAt": "2020-04-24T04:32:10Z", "author": {"login": "kyguy"}, "timelineItems": {"totalCount": 50, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTbiOoAFqTM4NTgxOTA2Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcahzNhgH2gAyMzk3MTEwMjQxOjM4ZmIwY2ZmODJjZTU0MzU4ZjFhZjY0ZGQxMzk4NzJmNTA3YjI2M2E=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1ODE5MDYy", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#pullrequestreview-385819062", "createdAt": "2020-04-01T17:55:27Z", "commit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNzo1NToyOFrOF_MGqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNzo1NToyOFrOF_MGqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMjkyMA==", "bodyText": "*Container needs capitalization in cruiseControlContainer", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r401802920", "createdAt": "2020-04-01T17:55:28Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/template/CruiseControlTemplate.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.template;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of a template for Cruise Control resources.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"deployment\", \"pod\", \"apiService\", \"podDisruptionBudget\", \"cruiseControlcontainer\", \"tlsSidecarContainer\"})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1ODM1MzA0", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#pullrequestreview-385835304", "createdAt": "2020-04-01T18:18:11Z", "commit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxODoxODoxMVrOF_M6YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxODoyNDo0NFrOF_NJSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxNjE2MQ==", "bodyText": "Minor niggle, but from a failing test point of view might the check\nassertThat(svc.getMetadata().getLabels(), is(svcLabels));\n\ngive a more informative error message on failure? This applys to all of the assertions in this file with containsAll calls", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r401816161", "createdAt": "2020-04-01T18:18:11Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));\n+\n+        // Test generated disk capacity\n+        JbodStorage jbodStorage = new JbodStorage();\n+        List<SingleVolumeStorage> volumes = new ArrayList<SingleVolumeStorage>();\n+\n+        PersistentClaimStorage p1 = new PersistentClaimStorage();\n+        p1.setId(0);\n+        p1.setSize(\"50Gi\");\n+        volumes.add(p1);\n+\n+        PersistentClaimStorage p2 = new PersistentClaimStorage();\n+        p2.setId(1);\n+        p2.setSize(\"50G\");\n+        volumes.add(p2);\n+\n+        jbodStorage.setVolumes(volumes);\n+\n+        resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withStorage(jbodStorage)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+        Capacity generatedCapacity = new Capacity(resource.getSpec());\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(generatedCapacity.getDisk())));\n+    }\n+\n+    @Test\n+    public void testFromConfigMap() {\n+        assertThat(cc.namespace, is(namespace));\n+        assertThat(cc.cluster, is(cluster));\n+        assertThat(cc.getImage(), is(ccImage));\n+    }\n+\n+    @Test\n+    public void testGenerateDeployment() {\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        assertThat(containers.size(), is(2));\n+\n+        assertThat(dep.getMetadata().getName(), is(CruiseControlResources.deploymentName(cluster)));\n+        assertThat(dep.getMetadata().getNamespace(), is(namespace));\n+        assertThat(dep.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(dep.getMetadata().getOwnerReferences().get(0), is(cc.createOwnerReference()));\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImage(), is(cc.image));\n+        assertThat(ccContainer.getLivenessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getLivenessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getReadinessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getReadinessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getEnv(), is(getExpectedEnvVars()));\n+        assertThat(ccContainer.getPorts().size(), is(1));\n+        assertThat(ccContainer.getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(ccContainer.getPorts().get(0).getProtocol(), is(\"TCP\"));\n+        assertThat(dep.getSpec().getStrategy().getType(), is(\"RollingUpdate\"));\n+\n+        // Test volumes\n+        List<Volume> volumes = dep.getSpec().getTemplate().getSpec().getVolumes();\n+        assertThat(volumes.size(), is(3));\n+\n+        Volume volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(CruiseControl.secretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(AbstractModel.clusterCaCertSecretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getConfigMap().getName(), is(CruiseControl.metricAndLogConfigsName(cluster)));\n+\n+        // Test volume mounts\n+        List<VolumeMount> volumesMounts = dep.getSpec().getTemplate().getSpec().getContainers().get(0).getVolumeMounts();\n+        assertThat(volumesMounts.size(), is(3));\n+\n+        VolumeMount volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_MOUNT));\n+    }\n+\n+    @Test\n+    public void testEnvVars()   {\n+        assertThat(cc.getEnvVars(), is(getExpectedEnvVars()));\n+    }\n+\n+    @Test\n+    public void testImagePullPolicy() {\n+        Deployment dep = cc.generateDeployment(true, null, ImagePullPolicy.ALWAYS, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.ALWAYS.toString()));\n+\n+        dep = cc.generateDeployment(true, null,  ImagePullPolicy.IFNOTPRESENT, null);\n+        containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.IFNOTPRESENT.toString()));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVars() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"test.env.two\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                       .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvTwoKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvTwoValue));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVarsWithKeyConflict() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"my-special-value\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                        .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+    }\n+\n+    @Test\n+    public void testCruiseControlNotDeployed() {\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null,  null);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        try {\n+            assertThat(cc.generateDeployment(true, null, null, null), is(nullValue()));\n+            assertThat(cc.generateService(), is(nullValue()));\n+            assertThat(cc.generateSecret(null, true), is(nullValue()));\n+        } catch (Throwable expected) {\n+            assertEquals(NullPointerException.class, expected.getClass());\n+        }\n+    }\n+\n+    @Test\n+    public void testGenerateService()   {\n+        Service svc = cc.generateService();\n+\n+        assertThat(svc.getSpec().getType(), is(\"ClusterIP\"));\n+        assertThat(svc.getMetadata().getLabels(), is(expectedLabels(cc.getServiceName())));\n+        assertThat(svc.getSpec().getSelector(), is(expectedSelectorLabels()));\n+        assertThat(svc.getSpec().getPorts().size(), is(1));\n+        assertThat(svc.getSpec().getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(svc.getSpec().getPorts().get(0).getPort(), is(new Integer(CruiseControl.REST_API_PORT)));\n+        assertThat(svc.getSpec().getPorts().get(0).getProtocol(), is(\"TCP\"));\n+\n+        checkOwnerReference(cc.createOwnerReference(), svc);\n+    }\n+\n+    @Test\n+    public void testGenerateServiceWhenDisabled()   {\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, null);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        try {\n+            assertThat(cc.generateService(), is(nullValue()));\n+        } catch (Throwable expected) {\n+            assertEquals(NullPointerException.class, expected.getClass());\n+        }\n+    }\n+\n+    @Test\n+    public void testTemplate() {\n+        Map<String, String> depLabels = TestUtils.map(\"l1\", \"v1\", \"l2\", \"v2\");\n+        Map<String, String> depAnots = TestUtils.map(\"a1\", \"v1\", \"a2\", \"v2\");\n+\n+        Map<String, String> podLabels = TestUtils.map(\"l3\", \"v3\", \"l4\", \"v4\");\n+        Map<String, String> podAnots = TestUtils.map(\"a3\", \"v3\", \"a4\", \"v4\");\n+\n+        Map<String, String> svcLabels = TestUtils.map(\"l5\", \"v5\", \"l6\", \"v6\");\n+        Map<String, String> svcAnots = TestUtils.map(\"a5\", \"v5\", \"a6\", \"v6\");\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+                .editSpec()\n+                    .withNewCruiseControl()\n+                        .withImage(ccImage)\n+                        .withNewTemplate()\n+                            .withNewDeployment()\n+                                .withNewMetadata()\n+                                    .withLabels(depLabels)\n+                                    .withAnnotations(depAnots)\n+                                .endMetadata()\n+                            .endDeployment()\n+                            .withNewPod()\n+                                .withNewMetadata()\n+                                    .withLabels(podLabels)\n+                                    .withAnnotations(podAnots)\n+                                .endMetadata()\n+                                .withNewPriorityClassName(\"top-priority\")\n+                                .withNewSchedulerName(\"my-scheduler\")\n+                            .endPod()\n+                            .withNewApiService()\n+                                .withNewMetadata()\n+                                    .withLabels(svcLabels)\n+                                    .withAnnotations(svcAnots)\n+                                .endMetadata()\n+                            .endApiService()\n+                        .endTemplate()\n+                    .endCruiseControl()\n+                .endSpec()\n+                .build();\n+\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        // Check Deployment\n+        Deployment dep = cc.generateDeployment(true, depAnots, null, null);\n+        assertThat(dep.getMetadata().getLabels().entrySet().containsAll(depLabels.entrySet()), is(true));\n+        assertThat(dep.getMetadata().getAnnotations().entrySet().containsAll(depAnots.entrySet()), is(true));\n+\n+        // Check Pods\n+        assertThat(dep.getSpec().getTemplate().getMetadata().getLabels().entrySet().containsAll(podLabels.entrySet()), is(true));\n+        assertThat(dep.getSpec().getTemplate().getMetadata().getAnnotations().entrySet().containsAll(podAnots.entrySet()), is(true));\n+        assertThat(dep.getSpec().getTemplate().getSpec().getPriorityClassName(), is(\"top-priority\"));\n+        assertThat(dep.getSpec().getTemplate().getSpec().getSchedulerName(), is(\"my-scheduler\"));\n+\n+        // Check Service\n+        Service svc = cc.generateService();\n+        assertThat(svc.getMetadata().getLabels().entrySet().containsAll(svcLabels.entrySet()), is(true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 468}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxNzE5Mw==", "bodyText": "Just to be a little more consistent with the rest of the tests in Strimzi would you opposed to using\nassertThrows(NullPointerException.class, () -> cc.generateService());", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r401817193", "createdAt": "2020-04-01T18:19:58Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));\n+\n+        // Test generated disk capacity\n+        JbodStorage jbodStorage = new JbodStorage();\n+        List<SingleVolumeStorage> volumes = new ArrayList<SingleVolumeStorage>();\n+\n+        PersistentClaimStorage p1 = new PersistentClaimStorage();\n+        p1.setId(0);\n+        p1.setSize(\"50Gi\");\n+        volumes.add(p1);\n+\n+        PersistentClaimStorage p2 = new PersistentClaimStorage();\n+        p2.setId(1);\n+        p2.setSize(\"50G\");\n+        volumes.add(p2);\n+\n+        jbodStorage.setVolumes(volumes);\n+\n+        resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withStorage(jbodStorage)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+        Capacity generatedCapacity = new Capacity(resource.getSpec());\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(generatedCapacity.getDisk())));\n+    }\n+\n+    @Test\n+    public void testFromConfigMap() {\n+        assertThat(cc.namespace, is(namespace));\n+        assertThat(cc.cluster, is(cluster));\n+        assertThat(cc.getImage(), is(ccImage));\n+    }\n+\n+    @Test\n+    public void testGenerateDeployment() {\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        assertThat(containers.size(), is(2));\n+\n+        assertThat(dep.getMetadata().getName(), is(CruiseControlResources.deploymentName(cluster)));\n+        assertThat(dep.getMetadata().getNamespace(), is(namespace));\n+        assertThat(dep.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(dep.getMetadata().getOwnerReferences().get(0), is(cc.createOwnerReference()));\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImage(), is(cc.image));\n+        assertThat(ccContainer.getLivenessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getLivenessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getReadinessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getReadinessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getEnv(), is(getExpectedEnvVars()));\n+        assertThat(ccContainer.getPorts().size(), is(1));\n+        assertThat(ccContainer.getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(ccContainer.getPorts().get(0).getProtocol(), is(\"TCP\"));\n+        assertThat(dep.getSpec().getStrategy().getType(), is(\"RollingUpdate\"));\n+\n+        // Test volumes\n+        List<Volume> volumes = dep.getSpec().getTemplate().getSpec().getVolumes();\n+        assertThat(volumes.size(), is(3));\n+\n+        Volume volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(CruiseControl.secretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(AbstractModel.clusterCaCertSecretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getConfigMap().getName(), is(CruiseControl.metricAndLogConfigsName(cluster)));\n+\n+        // Test volume mounts\n+        List<VolumeMount> volumesMounts = dep.getSpec().getTemplate().getSpec().getContainers().get(0).getVolumeMounts();\n+        assertThat(volumesMounts.size(), is(3));\n+\n+        VolumeMount volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_MOUNT));\n+    }\n+\n+    @Test\n+    public void testEnvVars()   {\n+        assertThat(cc.getEnvVars(), is(getExpectedEnvVars()));\n+    }\n+\n+    @Test\n+    public void testImagePullPolicy() {\n+        Deployment dep = cc.generateDeployment(true, null, ImagePullPolicy.ALWAYS, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.ALWAYS.toString()));\n+\n+        dep = cc.generateDeployment(true, null,  ImagePullPolicy.IFNOTPRESENT, null);\n+        containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.IFNOTPRESENT.toString()));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVars() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"test.env.two\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                       .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvTwoKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvTwoValue));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVarsWithKeyConflict() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"my-special-value\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                        .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+    }\n+\n+    @Test\n+    public void testCruiseControlNotDeployed() {\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null,  null);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        try {\n+            assertThat(cc.generateDeployment(true, null, null, null), is(nullValue()));\n+            assertThat(cc.generateService(), is(nullValue()));\n+            assertThat(cc.generateSecret(null, true), is(nullValue()));\n+        } catch (Throwable expected) {\n+            assertEquals(NullPointerException.class, expected.getClass());\n+        }\n+    }\n+\n+    @Test\n+    public void testGenerateService()   {\n+        Service svc = cc.generateService();\n+\n+        assertThat(svc.getSpec().getType(), is(\"ClusterIP\"));\n+        assertThat(svc.getMetadata().getLabels(), is(expectedLabels(cc.getServiceName())));\n+        assertThat(svc.getSpec().getSelector(), is(expectedSelectorLabels()));\n+        assertThat(svc.getSpec().getPorts().size(), is(1));\n+        assertThat(svc.getSpec().getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(svc.getSpec().getPorts().get(0).getPort(), is(new Integer(CruiseControl.REST_API_PORT)));\n+        assertThat(svc.getSpec().getPorts().get(0).getProtocol(), is(\"TCP\"));\n+\n+        checkOwnerReference(cc.createOwnerReference(), svc);\n+    }\n+\n+    @Test\n+    public void testGenerateServiceWhenDisabled()   {\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, null);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        try {\n+            assertThat(cc.generateService(), is(nullValue()));\n+        } catch (Throwable expected) {\n+            assertEquals(NullPointerException.class, expected.getClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 408}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxODcxNw==", "bodyText": "assertThat(kafkaEnvVars, hasEntry(testEnvOneKey, testEnvOneValue) suggested improvement\nAnd maybe have same for envar2?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r401818717", "createdAt": "2020-04-01T18:22:40Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));\n+\n+        // Test generated disk capacity\n+        JbodStorage jbodStorage = new JbodStorage();\n+        List<SingleVolumeStorage> volumes = new ArrayList<SingleVolumeStorage>();\n+\n+        PersistentClaimStorage p1 = new PersistentClaimStorage();\n+        p1.setId(0);\n+        p1.setSize(\"50Gi\");\n+        volumes.add(p1);\n+\n+        PersistentClaimStorage p2 = new PersistentClaimStorage();\n+        p2.setId(1);\n+        p2.setSize(\"50G\");\n+        volumes.add(p2);\n+\n+        jbodStorage.setVolumes(volumes);\n+\n+        resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withStorage(jbodStorage)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+        Capacity generatedCapacity = new Capacity(resource.getSpec());\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(generatedCapacity.getDisk())));\n+    }\n+\n+    @Test\n+    public void testFromConfigMap() {\n+        assertThat(cc.namespace, is(namespace));\n+        assertThat(cc.cluster, is(cluster));\n+        assertThat(cc.getImage(), is(ccImage));\n+    }\n+\n+    @Test\n+    public void testGenerateDeployment() {\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        assertThat(containers.size(), is(2));\n+\n+        assertThat(dep.getMetadata().getName(), is(CruiseControlResources.deploymentName(cluster)));\n+        assertThat(dep.getMetadata().getNamespace(), is(namespace));\n+        assertThat(dep.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(dep.getMetadata().getOwnerReferences().get(0), is(cc.createOwnerReference()));\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImage(), is(cc.image));\n+        assertThat(ccContainer.getLivenessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getLivenessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getReadinessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getReadinessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getEnv(), is(getExpectedEnvVars()));\n+        assertThat(ccContainer.getPorts().size(), is(1));\n+        assertThat(ccContainer.getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(ccContainer.getPorts().get(0).getProtocol(), is(\"TCP\"));\n+        assertThat(dep.getSpec().getStrategy().getType(), is(\"RollingUpdate\"));\n+\n+        // Test volumes\n+        List<Volume> volumes = dep.getSpec().getTemplate().getSpec().getVolumes();\n+        assertThat(volumes.size(), is(3));\n+\n+        Volume volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(CruiseControl.secretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(AbstractModel.clusterCaCertSecretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getConfigMap().getName(), is(CruiseControl.metricAndLogConfigsName(cluster)));\n+\n+        // Test volume mounts\n+        List<VolumeMount> volumesMounts = dep.getSpec().getTemplate().getSpec().getContainers().get(0).getVolumeMounts();\n+        assertThat(volumesMounts.size(), is(3));\n+\n+        VolumeMount volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_MOUNT));\n+    }\n+\n+    @Test\n+    public void testEnvVars()   {\n+        assertThat(cc.getEnvVars(), is(getExpectedEnvVars()));\n+    }\n+\n+    @Test\n+    public void testImagePullPolicy() {\n+        Deployment dep = cc.generateDeployment(true, null, ImagePullPolicy.ALWAYS, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.ALWAYS.toString()));\n+\n+        dep = cc.generateDeployment(true, null,  ImagePullPolicy.IFNOTPRESENT, null);\n+        containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.IFNOTPRESENT.toString()));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVars() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"test.env.two\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                       .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvTwoKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvTwoValue));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVarsWithKeyConflict() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"my-special-value\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                        .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxODg2OA==", "bodyText": "assertThat(kafkaEnvVars, hasEntry(testEnvOneKey, testEnvOneValue) suggested improvement\nAnd maybe have same for envar2?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r401818868", "createdAt": "2020-04-01T18:22:54Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));\n+\n+        // Test generated disk capacity\n+        JbodStorage jbodStorage = new JbodStorage();\n+        List<SingleVolumeStorage> volumes = new ArrayList<SingleVolumeStorage>();\n+\n+        PersistentClaimStorage p1 = new PersistentClaimStorage();\n+        p1.setId(0);\n+        p1.setSize(\"50Gi\");\n+        volumes.add(p1);\n+\n+        PersistentClaimStorage p2 = new PersistentClaimStorage();\n+        p2.setId(1);\n+        p2.setSize(\"50G\");\n+        volumes.add(p2);\n+\n+        jbodStorage.setVolumes(volumes);\n+\n+        resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withStorage(jbodStorage)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+        Capacity generatedCapacity = new Capacity(resource.getSpec());\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(generatedCapacity.getDisk())));\n+    }\n+\n+    @Test\n+    public void testFromConfigMap() {\n+        assertThat(cc.namespace, is(namespace));\n+        assertThat(cc.cluster, is(cluster));\n+        assertThat(cc.getImage(), is(ccImage));\n+    }\n+\n+    @Test\n+    public void testGenerateDeployment() {\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        assertThat(containers.size(), is(2));\n+\n+        assertThat(dep.getMetadata().getName(), is(CruiseControlResources.deploymentName(cluster)));\n+        assertThat(dep.getMetadata().getNamespace(), is(namespace));\n+        assertThat(dep.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(dep.getMetadata().getOwnerReferences().get(0), is(cc.createOwnerReference()));\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImage(), is(cc.image));\n+        assertThat(ccContainer.getLivenessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getLivenessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getReadinessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getReadinessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getEnv(), is(getExpectedEnvVars()));\n+        assertThat(ccContainer.getPorts().size(), is(1));\n+        assertThat(ccContainer.getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(ccContainer.getPorts().get(0).getProtocol(), is(\"TCP\"));\n+        assertThat(dep.getSpec().getStrategy().getType(), is(\"RollingUpdate\"));\n+\n+        // Test volumes\n+        List<Volume> volumes = dep.getSpec().getTemplate().getSpec().getVolumes();\n+        assertThat(volumes.size(), is(3));\n+\n+        Volume volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(CruiseControl.secretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(AbstractModel.clusterCaCertSecretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getConfigMap().getName(), is(CruiseControl.metricAndLogConfigsName(cluster)));\n+\n+        // Test volume mounts\n+        List<VolumeMount> volumesMounts = dep.getSpec().getTemplate().getSpec().getContainers().get(0).getVolumeMounts();\n+        assertThat(volumesMounts.size(), is(3));\n+\n+        VolumeMount volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_MOUNT));\n+    }\n+\n+    @Test\n+    public void testEnvVars()   {\n+        assertThat(cc.getEnvVars(), is(getExpectedEnvVars()));\n+    }\n+\n+    @Test\n+    public void testImagePullPolicy() {\n+        Deployment dep = cc.generateDeployment(true, null, ImagePullPolicy.ALWAYS, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.ALWAYS.toString()));\n+\n+        dep = cc.generateDeployment(true, null,  ImagePullPolicy.IFNOTPRESENT, null);\n+        containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.IFNOTPRESENT.toString()));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVars() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"test.env.two\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                       .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 331}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxOTk3Ng==", "bodyText": "Just as an aside, this might be a good function to contribute to test utils as I can see all of the tests needing to call this method!", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r401819976", "createdAt": "2020-04-01T18:24:44Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MTk0NjQz", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#pullrequestreview-386194643", "createdAt": "2020-04-02T08:08:21Z", "commit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "state": "COMMENTED", "comments": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODowODoyMVrOF_f4xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTowODoxNVrOF_iG3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyNzA0NQ==", "bodyText": "@kyguy is there a link to the documentation about all these configs?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402127045", "createdAt": "2020-04-02T08:08:21Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyNzQ1Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Description(\"The Cruise Control broker capacity config.\")\n          \n          \n            \n                @Description(\"The Cruise Control broker capacity configuration.\")", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402127453", "createdAt": "2020-04-02T08:09:02Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyNzgxMg==", "bodyText": "The class is called ...BokerCapacity, so should the property be called that too?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402127812", "createdAt": "2020-04-02T08:09:39Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public CruiseControlBrokerCapacity getCapacity() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyODExNg==", "bodyText": "We should include a link here to the place where the user can learn about what the valid configs are.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402128116", "createdAt": "2020-04-02T08:10:14Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public CruiseControlBrokerCapacity getCapacity() {\n+        return capacity;\n+    }\n+\n+    public void setCapacity(CruiseControlBrokerCapacity capacity) {\n+        this.capacity = capacity;\n+    }\n+\n+    @Description(\"The Cruise Control config. Properties with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyODc4NQ==", "bodyText": "For the cruise control pod (singular)? If so, please say so in the Description to the reader of the docs is left in no doubt about what they're configuring.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402128785", "createdAt": "2020-04-02T08:11:30Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public CruiseControlBrokerCapacity getCapacity() {\n+        return capacity;\n+    }\n+\n+    public void setCapacity(CruiseControlBrokerCapacity capacity) {\n+        this.capacity = capacity;\n+    }\n+\n+    @Description(\"The Cruise Control config. Properties with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, Object> getConfig() {\n+        return config;\n+    }\n+\n+    public void setConfig(Map<String, Object> config) {\n+        this.config = config;\n+    }\n+\n+    @Description(\"Logging configuration for Cruise Control.\")\n+    @JsonInclude(value = JsonInclude.Include.NON_NULL)\n+    public Logging getLogging() {\n+        return logging;\n+    }\n+\n+    public void setLogging(Logging logging) {\n+        this.logging = logging;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    @Description(\"JVM Options for pods\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyODk3Ng==", "bodyText": "For which container?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402128976", "createdAt": "2020-04-02T08:11:51Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public CruiseControlBrokerCapacity getCapacity() {\n+        return capacity;\n+    }\n+\n+    public void setCapacity(CruiseControlBrokerCapacity capacity) {\n+        this.capacity = capacity;\n+    }\n+\n+    @Description(\"The Cruise Control config. Properties with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, Object> getConfig() {\n+        return config;\n+    }\n+\n+    public void setConfig(Map<String, Object> config) {\n+        this.config = config;\n+    }\n+\n+    @Description(\"Logging configuration for Cruise Control.\")\n+    @JsonInclude(value = JsonInclude.Include.NON_NULL)\n+    public Logging getLogging() {\n+        return logging;\n+    }\n+\n+    public void setLogging(Logging logging) {\n+        this.logging = logging;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    @Description(\"JVM Options for pods\")\n+    public JvmOptions getJvmOptions() {\n+        return jvmOptions;\n+    }\n+\n+    public void setJvmOptions(JvmOptions jvmOptions) {\n+        this.jvmOptions = jvmOptions;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"CPU and memory resources to reserve.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyOTY4MQ==", "bodyText": "Again, no harm in being more explicit about which container", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402129681", "createdAt": "2020-04-02T08:13:06Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public CruiseControlBrokerCapacity getCapacity() {\n+        return capacity;\n+    }\n+\n+    public void setCapacity(CruiseControlBrokerCapacity capacity) {\n+        this.capacity = capacity;\n+    }\n+\n+    @Description(\"The Cruise Control config. Properties with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, Object> getConfig() {\n+        return config;\n+    }\n+\n+    public void setConfig(Map<String, Object> config) {\n+        this.config = config;\n+    }\n+\n+    @Description(\"Logging configuration for Cruise Control.\")\n+    @JsonInclude(value = JsonInclude.Include.NON_NULL)\n+    public Logging getLogging() {\n+        return logging;\n+    }\n+\n+    public void setLogging(Logging logging) {\n+        this.logging = logging;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    @Description(\"JVM Options for pods\")\n+    public JvmOptions getJvmOptions() {\n+        return jvmOptions;\n+    }\n+\n+    public void setJvmOptions(JvmOptions jvmOptions) {\n+        this.jvmOptions = jvmOptions;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"CPU and memory resources to reserve.\")\n+    public ResourceRequirements getResources() {\n+        return resources;\n+    }\n+\n+    public void setResources(ResourceRequirements resources) {\n+        this.resources = resources;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    @Description(\"Pod liveness checking.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMDE5MA==", "bodyText": "Say what happens if this is not specified (do I get a default CC or no CC?)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402130190", "createdAt": "2020-04-02T08:13:56Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaSpec.java", "diffHunk": "@@ -136,6 +137,15 @@ public void setKafkaExporter(KafkaExporterSpec kafkaExporter) {\n         this.kafkaExporter = kafkaExporter;\n     }\n \n+    @Description(\"Configuration of Cruise Control.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMDU1Nw==", "bodyText": "Are these base 10 megabytes or base 2 mebibytes? We should document it at least.\nCan we call the property diskMB (or diskMiB`) , so the unit is explicit?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402130557", "createdAt": "2020-04-02T08:14:36Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/CruiseControlBrokerCapacity.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpu\", \"networkIn\", \"networkOut\"})\n+@EqualsAndHashCode\n+public class CruiseControlBrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer disk;\n+    private Integer cpu;\n+    private Integer networkIn;\n+    private Integer networkOut;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Description(\"Broker capacity for disk in megabytes.\")\n+    public Integer getDisk() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMDk2MQ==", "bodyText": "So how does this work if the brokers have resource requests and limits for >1.0 CPU?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402130961", "createdAt": "2020-04-02T08:15:24Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/CruiseControlBrokerCapacity.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpu\", \"networkIn\", \"networkOut\"})\n+@EqualsAndHashCode\n+public class CruiseControlBrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer disk;\n+    private Integer cpu;\n+    private Integer networkIn;\n+    private Integer networkOut;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Description(\"Broker capacity for disk in megabytes.\")\n+    public Integer getDisk() {\n+        return disk;\n+    }\n+\n+    public void setDisk(Integer disk) {\n+        this.disk = disk;\n+    }\n+\n+    @Minimum(0)\n+    @Maximum(100)\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for CPU utilization as a percentage (0 - 100).\")\n+    public Integer getCpu() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMzg2Mg==", "bodyText": "Again we should make clear the units KB or KiB, and reflect that in the name. But networkInKBPerSecond is a bit confusing because people might think that the \"in\" is referring to the units be \"in KB/s\", so maybe inboundNetworkKBPerSecond is better.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402133862", "createdAt": "2020-04-02T08:20:42Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/CruiseControlBrokerCapacity.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpu\", \"networkIn\", \"networkOut\"})\n+@EqualsAndHashCode\n+public class CruiseControlBrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer disk;\n+    private Integer cpu;\n+    private Integer networkIn;\n+    private Integer networkOut;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Description(\"Broker capacity for disk in megabytes.\")\n+    public Integer getDisk() {\n+        return disk;\n+    }\n+\n+    public void setDisk(Integer disk) {\n+        this.disk = disk;\n+    }\n+\n+    @Minimum(0)\n+    @Maximum(100)\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for CPU utilization as a percentage (0 - 100).\")\n+    public Integer getCpu() {\n+        return cpu;\n+    }\n+\n+    public void setCpu(Integer cpu) {\n+        this.cpu = cpu;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for network inbound throughput in kilobytes per second.\")\n+    public Integer getNetworkIn() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMzk2Mw==", "bodyText": "Similar comments.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402133963", "createdAt": "2020-04-02T08:20:52Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/CruiseControlBrokerCapacity.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpu\", \"networkIn\", \"networkOut\"})\n+@EqualsAndHashCode\n+public class CruiseControlBrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer disk;\n+    private Integer cpu;\n+    private Integer networkIn;\n+    private Integer networkOut;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Description(\"Broker capacity for disk in megabytes.\")\n+    public Integer getDisk() {\n+        return disk;\n+    }\n+\n+    public void setDisk(Integer disk) {\n+        this.disk = disk;\n+    }\n+\n+    @Minimum(0)\n+    @Maximum(100)\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for CPU utilization as a percentage (0 - 100).\")\n+    public Integer getCpu() {\n+        return cpu;\n+    }\n+\n+    public void setCpu(Integer cpu) {\n+        this.cpu = cpu;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for network inbound throughput in kilobytes per second.\")\n+    public Integer getNetworkIn() {\n+        return networkIn;\n+    }\n+\n+    public void setNetworkIn(Integer networkIn) {\n+        this.networkIn = networkIn;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for network outbound throughput in kilobytes per second.\")\n+    public Integer getNetworkOut() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzNTYwOQ==", "bodyText": "I've opened #2779 for resolving this sort of thing once and for all.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402135609", "createdAt": "2020-04-02T08:23:44Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/template/CruiseControlTemplate.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.template;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of a template for Cruise Control resources.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"deployment\", \"pod\", \"apiService\", \"podDisruptionBudget\", \"cruiseControlcontainer\", \"tlsSidecarContainer\"})", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMjkyMA=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzOTU0Mw==", "bodyText": "Do us a favour an include a comment with that this time is in more meaningful units.\nAnd use _ as a thousands separator, it makes large literals so much easier to read!", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402139543", "createdAt": "2020-04-02T08:30:25Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControlConfiguration.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+\n+/**\n+ * Class for handling Cruise Control configuration passed by the user\n+ */\n+public class CruiseControlConfiguration extends AbstractConfiguration {\n+\n+    /**\n+     * A list of case insensitive goals that Cruise Control supports in the order of priority.\n+     * The high priority goals will be executed first.\n+     */\n+    private static final String DEFAULT_GOALS = \"com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.PotentialNwOutGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.TopicReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderBytesInDistributionGoal\";\n+\n+   /*\n+    * Map containing default values for required configuration properties\n+    */\n+    private static final Map<String, String> CC_DEFAULT_PROPERTIES_MAP;\n+\n+    private static final List<String> FORBIDDEN_OPTIONS;\n+    private static final List<String> EXCEPTIONS;\n+\n+    static {\n+        CC_DEFAULT_PROPERTIES_MAP = new HashMap<>();\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"partition.metrics.window.ms\", \"300000\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"num.partition.metrics.windows\", \"1\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"broker.metrics.window.ms\", \"300000\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"num.broker.metrics.windows\", \"20\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"completed.user.task.retention.time.ms\", \"86400000\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzOTk1MQ==", "bodyText": "Use addAll(), rather than building a new HashSet", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402139951", "createdAt": "2020-04-02T08:31:10Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -440,6 +448,24 @@ public static KafkaCluster fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup vers\n         }\n \n         KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+        CruiseControlSpec cruiseControlSpec  = kafkaSpec.getCruiseControl();\n+\n+        String metricReporters =  configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD);\n+        Set<String> metricReporterList = new HashSet<>();\n+        if (metricReporters != null) {\n+            metricReporterList = new HashSet<String>(Arrays.asList(configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD).split(\",\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0MDI0NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static long parseMemorybyFactor(String memory, String factor) {\n          \n          \n            \n                public static long parseMemoryByFactor(String memory, String factor) {", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402140245", "createdAt": "2020-04-02T08:31:39Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/StorageUtils.java", "diffHunk": "@@ -12,6 +12,17 @@\n  * Shared methods for working with Storage - for example comparing volume sizes\n  */\n public class StorageUtils {\n+    /**\n+     * Parse a K8S-style representation of a quantity of memory, such as {@code 512Mi},\n+     * into the equivalent number factor of bytes represented as a long.\n+     * @param memory The String representation of the quantity of memory.\n+     * @param factor The factor which the bytes should be converted to\n+     * @return The equivalent number factor of bytes.\n+     */\n+    public static long parseMemorybyFactor(String memory, String factor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0MDg5Mw==", "bodyText": "I think you should give an example, because this doesn't make complete sense to me.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402140893", "createdAt": "2020-04-02T08:32:41Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/StorageUtils.java", "diffHunk": "@@ -12,6 +12,17 @@\n  * Shared methods for working with Storage - for example comparing volume sizes\n  */\n public class StorageUtils {\n+    /**\n+     * Parse a K8S-style representation of a quantity of memory, such as {@code 512Mi},\n+     * into the equivalent number factor of bytes represented as a long.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0MTY5OA==", "bodyText": "Again _ as a separator.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402141698", "createdAt": "2020-04-02T08:33:57Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/cruisecontrol/Capacity.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model.cruisecontrol;\n+\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+\n+import java.util.List;\n+\n+import static io.strimzi.operator.cluster.model.StorageUtils.parseMemorybyFactor;\n+\n+public class Capacity {\n+    public static final int DEFAULT_BROKER_DISK_CAPACITY   = 100000;  // in MB\n+    public static final int DEFAULT_BROKER_CPU_CAPACITY    = 100;     // as a percentage (0-100)\n+    public static final int DEFAULT_BROKER_NW_IN_CAPACITY  = 10000;   // in KB/s\n+    public static final int DEFAULT_BROKER_NW_OUT_CAPACITY = 10000;   // in KB/s", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0MzY2OA==", "bodyText": "Why not just use a Long to avoid the possibility of overflow and hence an exception?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402143668", "createdAt": "2020-04-02T08:36:57Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/cruisecontrol/Capacity.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model.cruisecontrol;\n+\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+\n+import java.util.List;\n+\n+import static io.strimzi.operator.cluster.model.StorageUtils.parseMemorybyFactor;\n+\n+public class Capacity {\n+    public static final int DEFAULT_BROKER_DISK_CAPACITY   = 100000;  // in MB\n+    public static final int DEFAULT_BROKER_CPU_CAPACITY    = 100;     // as a percentage (0-100)\n+    public static final int DEFAULT_BROKER_NW_IN_CAPACITY  = 10000;   // in KB/s\n+    public static final int DEFAULT_BROKER_NW_OUT_CAPACITY = 10000;   // in KB/s\n+\n+    private Integer disk;\n+    private Integer cpu;\n+    private Integer networkIn;\n+    private Integer networkOut;\n+\n+    public Capacity(KafkaSpec spec) {\n+        CruiseControlBrokerCapacity bc = spec.getCruiseControl().getCapacity();\n+\n+        this.disk = bc != null && bc.getDisk() != null ? bc.getDisk() : generateDiskCapacity(spec.getKafka().getStorage());\n+        this.cpu = bc != null && bc.getCpu() != null ? bc.getCpu() : DEFAULT_BROKER_CPU_CAPACITY;\n+        this.networkIn = bc != null && bc.getNetworkIn() != null ? bc.getNetworkIn() : DEFAULT_BROKER_NW_IN_CAPACITY;\n+        this.networkOut = bc != null && bc.getNetworkOut() != null ? bc.getNetworkOut() : DEFAULT_BROKER_NW_OUT_CAPACITY;\n+    }\n+\n+    /**\n+     * Generate disk capacity configuration from the supplied storage configuration\n+     *\n+     * @param storage Storage configuration for Kafka cluster\n+     * @return Disk capacity configuration as a String\n+     */\n+    public static Integer generateDiskCapacity(Storage storage) {\n+        if (storage instanceof PersistentClaimStorage) {\n+            return getSizeInMb(((PersistentClaimStorage) storage).getSize());\n+        } else if (storage instanceof EphemeralStorage) {\n+            if (((EphemeralStorage) storage).getSizeLimit() != null) {\n+                return getSizeInMb(((EphemeralStorage) storage).getSizeLimit());\n+            } else {\n+                return DEFAULT_BROKER_DISK_CAPACITY;\n+            }\n+        } else if (storage instanceof JbodStorage) {\n+            List<SingleVolumeStorage> volumeList = ((JbodStorage) storage).getVolumes();\n+            int size = 0;\n+            for (SingleVolumeStorage volume : volumeList) {\n+                size += generateDiskCapacity(volume);\n+            }\n+            return size;\n+        } else {\n+            throw new IllegalStateException(\"The declared storage '\" + storage.getType() + \"' is not supported\");\n+        }\n+    }\n+\n+    /*\n+     * Parse a K8S-style representation of a disk size, such as {@code 100Gi},\n+     * into the equivalent number of megabytes represented as a Integer.\n+     *\n+     * @param size The String representation of the volume size.\n+     * @return The equivalent number of Megabytes.\n+     */\n+    public static Integer getSizeInMb(String size) {\n+        return Math.toIntExact(parseMemorybyFactor(size, size.charAt(size.length() - 1) == 'i' ? \"Mi\" : \"M\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0NDYxNg==", "bodyText": "Yes please! Good spot @samuel-hawker!", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402144616", "createdAt": "2020-04-02T08:38:35Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxOTk3Ng=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0NTU0Mg==", "bodyText": "Let's include the units in the env vars too, because there's nothing more embarrassing that a bug due to confused units.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402145542", "createdAt": "2020-04-02T08:40:01Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0NjIzNg==", "bodyText": "new ArrayList<>(). But I'm looking forward to the day we more the operator to Java 11 and can just write var volumes = new ArrayList<SingleVolumeStorage>();", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402146236", "createdAt": "2020-04-02T08:41:08Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));\n+\n+        // Test generated disk capacity\n+        JbodStorage jbodStorage = new JbodStorage();\n+        List<SingleVolumeStorage> volumes = new ArrayList<SingleVolumeStorage>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0ODE3OA==", "bodyText": "And let's be clear that the code above it wrong anyway. If you're expecting cc.generateService() to throw there's no point in having the assertThat and the cc.generateService() statement should be followed by a fail(), otherwise in the case of no NPE the test will erroneously pass.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402148178", "createdAt": "2020-04-02T08:44:03Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));\n+\n+        // Test generated disk capacity\n+        JbodStorage jbodStorage = new JbodStorage();\n+        List<SingleVolumeStorage> volumes = new ArrayList<SingleVolumeStorage>();\n+\n+        PersistentClaimStorage p1 = new PersistentClaimStorage();\n+        p1.setId(0);\n+        p1.setSize(\"50Gi\");\n+        volumes.add(p1);\n+\n+        PersistentClaimStorage p2 = new PersistentClaimStorage();\n+        p2.setId(1);\n+        p2.setSize(\"50G\");\n+        volumes.add(p2);\n+\n+        jbodStorage.setVolumes(volumes);\n+\n+        resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withStorage(jbodStorage)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+        Capacity generatedCapacity = new Capacity(resource.getSpec());\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(generatedCapacity.getDisk())));\n+    }\n+\n+    @Test\n+    public void testFromConfigMap() {\n+        assertThat(cc.namespace, is(namespace));\n+        assertThat(cc.cluster, is(cluster));\n+        assertThat(cc.getImage(), is(ccImage));\n+    }\n+\n+    @Test\n+    public void testGenerateDeployment() {\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        assertThat(containers.size(), is(2));\n+\n+        assertThat(dep.getMetadata().getName(), is(CruiseControlResources.deploymentName(cluster)));\n+        assertThat(dep.getMetadata().getNamespace(), is(namespace));\n+        assertThat(dep.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(dep.getMetadata().getOwnerReferences().get(0), is(cc.createOwnerReference()));\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImage(), is(cc.image));\n+        assertThat(ccContainer.getLivenessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getLivenessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getReadinessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getReadinessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getEnv(), is(getExpectedEnvVars()));\n+        assertThat(ccContainer.getPorts().size(), is(1));\n+        assertThat(ccContainer.getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(ccContainer.getPorts().get(0).getProtocol(), is(\"TCP\"));\n+        assertThat(dep.getSpec().getStrategy().getType(), is(\"RollingUpdate\"));\n+\n+        // Test volumes\n+        List<Volume> volumes = dep.getSpec().getTemplate().getSpec().getVolumes();\n+        assertThat(volumes.size(), is(3));\n+\n+        Volume volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(CruiseControl.secretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(AbstractModel.clusterCaCertSecretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getConfigMap().getName(), is(CruiseControl.metricAndLogConfigsName(cluster)));\n+\n+        // Test volume mounts\n+        List<VolumeMount> volumesMounts = dep.getSpec().getTemplate().getSpec().getContainers().get(0).getVolumeMounts();\n+        assertThat(volumesMounts.size(), is(3));\n+\n+        VolumeMount volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_MOUNT));\n+    }\n+\n+    @Test\n+    public void testEnvVars()   {\n+        assertThat(cc.getEnvVars(), is(getExpectedEnvVars()));\n+    }\n+\n+    @Test\n+    public void testImagePullPolicy() {\n+        Deployment dep = cc.generateDeployment(true, null, ImagePullPolicy.ALWAYS, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.ALWAYS.toString()));\n+\n+        dep = cc.generateDeployment(true, null,  ImagePullPolicy.IFNOTPRESENT, null);\n+        containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.IFNOTPRESENT.toString()));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVars() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"test.env.two\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                       .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvTwoKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvTwoValue));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVarsWithKeyConflict() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"my-special-value\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                        .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+    }\n+\n+    @Test\n+    public void testCruiseControlNotDeployed() {\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null,  null);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        try {\n+            assertThat(cc.generateDeployment(true, null, null, null), is(nullValue()));\n+            assertThat(cc.generateService(), is(nullValue()));\n+            assertThat(cc.generateSecret(null, true), is(nullValue()));\n+        } catch (Throwable expected) {\n+            assertEquals(NullPointerException.class, expected.getClass());\n+        }\n+    }\n+\n+    @Test\n+    public void testGenerateService()   {\n+        Service svc = cc.generateService();\n+\n+        assertThat(svc.getSpec().getType(), is(\"ClusterIP\"));\n+        assertThat(svc.getMetadata().getLabels(), is(expectedLabels(cc.getServiceName())));\n+        assertThat(svc.getSpec().getSelector(), is(expectedSelectorLabels()));\n+        assertThat(svc.getSpec().getPorts().size(), is(1));\n+        assertThat(svc.getSpec().getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(svc.getSpec().getPorts().get(0).getPort(), is(new Integer(CruiseControl.REST_API_PORT)));\n+        assertThat(svc.getSpec().getPorts().get(0).getProtocol(), is(\"TCP\"));\n+\n+        checkOwnerReference(cc.createOwnerReference(), svc);\n+    }\n+\n+    @Test\n+    public void testGenerateServiceWhenDisabled()   {\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, null);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        try {\n+            assertThat(cc.generateService(), is(nullValue()));\n+        } catch (Throwable expected) {\n+            assertEquals(NullPointerException.class, expected.getClass());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxNzE5Mw=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 408}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1MDczOA==", "bodyText": "Does this mean we're assuming at this point that all broker's have the same disk. It's not strictly true (e.g. during storage resizing I suspect it's possible for some brokers to have more than others). I guess it's not a problem if CC gets rolled following storage increase. And I don't recall whether we support decreasing storage size, but if we do that's another case to consider.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402150738", "createdAt": "2020-04-02T08:48:09Z", "author": {"login": "tombentley"}, "path": "docker-images/kafka/cruise-control-scripts/cruise_control_config_generator.sh", "diffHunk": "@@ -0,0 +1,42 @@\n+#!/usr/bin/env bash\n+\n+CC_CAPACITY_FILE=\"/tmp/capacity.json\"\n+CC_CLUSTER_CONFIG_FILE=\"/tmp/clusterConfig.json\"\n+\n+# Generate capacity file\n+cat <<EOF > $CC_CAPACITY_FILE\n+{\n+\t\"brokerCapacities\": [{\n+\t\t\"brokerId\": \"-1\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1MTE2NQ==", "bodyText": "Presumably this is us telling CC what the cluster's default min ISR is?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402151165", "createdAt": "2020-04-02T08:48:48Z", "author": {"login": "tombentley"}, "path": "docker-images/kafka/cruise-control-scripts/cruise_control_config_generator.sh", "diffHunk": "@@ -0,0 +1,42 @@\n+#!/usr/bin/env bash\n+\n+CC_CAPACITY_FILE=\"/tmp/capacity.json\"\n+CC_CLUSTER_CONFIG_FILE=\"/tmp/clusterConfig.json\"\n+\n+# Generate capacity file\n+cat <<EOF > $CC_CAPACITY_FILE\n+{\n+\t\"brokerCapacities\": [{\n+\t\t\"brokerId\": \"-1\",\n+\t\t\"capacity\": {\n+\t\t\t\"DISK\": \"$BROKER_DISK_CAPACITY\",\n+\t\t\t\"CPU\": \"$BROKER_CPU_CAPACITY\",\n+\t\t\t\"NW_IN\": \"$BROKER_NETWORK_IN_CAPACITY\",\n+\t\t\t\"NW_OUT\": \"$BROKER_NETWORK_OUT_CAPACITY\"\n+\t\t},\n+\t\t\"doc\": \"This is the default capacity. Capacity unit used for disk is in MB, cpu is in percentage, network throughput is in KB.\"\n+\t}]\n+}\n+EOF\n+\n+cat $CC_CAPACITY_FILE\n+\n+# Generate cluster config\n+cat <<EOF > $CC_CLUSTER_CONFIG_FILE\n+{\n+min.insync.replicas=$MIN_INSYNC_REPLICAS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1MjA3Mw==", "bodyText": "Do we have control over these names? If so, maybe now's the time to think about whether we should have a naming convention for \"Strimzi internal topics\" (which these effectively are).", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402152073", "createdAt": "2020-04-02T08:50:16Z", "author": {"login": "tombentley"}, "path": "docker-images/kafka/cruise-control-scripts/cruise_control_config_generator.sh", "diffHunk": "@@ -0,0 +1,42 @@\n+#!/usr/bin/env bash\n+\n+CC_CAPACITY_FILE=\"/tmp/capacity.json\"\n+CC_CLUSTER_CONFIG_FILE=\"/tmp/clusterConfig.json\"\n+\n+# Generate capacity file\n+cat <<EOF > $CC_CAPACITY_FILE\n+{\n+\t\"brokerCapacities\": [{\n+\t\t\"brokerId\": \"-1\",\n+\t\t\"capacity\": {\n+\t\t\t\"DISK\": \"$BROKER_DISK_CAPACITY\",\n+\t\t\t\"CPU\": \"$BROKER_CPU_CAPACITY\",\n+\t\t\t\"NW_IN\": \"$BROKER_NETWORK_IN_CAPACITY\",\n+\t\t\t\"NW_OUT\": \"$BROKER_NETWORK_OUT_CAPACITY\"\n+\t\t},\n+\t\t\"doc\": \"This is the default capacity. Capacity unit used for disk is in MB, cpu is in percentage, network throughput is in KB.\"\n+\t}]\n+}\n+EOF\n+\n+cat $CC_CAPACITY_FILE\n+\n+# Generate cluster config\n+cat <<EOF > $CC_CLUSTER_CONFIG_FILE\n+{\n+min.insync.replicas=$MIN_INSYNC_REPLICAS\n+}\n+EOF\n+\n+# Write the config file\n+cat <<EOF\n+bootstrap.servers=$STRIMZI_KAFKA_BOOTSTRAP_SERVERS\n+zookeeper.connect=localhost:2181\n+partition.metric.sample.store.topic=__KafkaCruiseControlPartitionMetricSamples\n+broker.metric.sample.store.topic=__KafkaCruiseControlModelTrainingSamples", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1MzI3OA==", "bodyText": "So /tmp is usually an in-memory file system these days IIRC, which means this could, hypothetically, result in the OOM killer being unleashed. Can we redirect this to CC's stdout?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402153278", "createdAt": "2020-04-02T08:52:17Z", "author": {"login": "tombentley"}, "path": "docker-images/kafka/cruise-control-scripts/cruise_control_config_generator.sh", "diffHunk": "@@ -0,0 +1,42 @@\n+#!/usr/bin/env bash\n+\n+CC_CAPACITY_FILE=\"/tmp/capacity.json\"\n+CC_CLUSTER_CONFIG_FILE=\"/tmp/clusterConfig.json\"\n+\n+# Generate capacity file\n+cat <<EOF > $CC_CAPACITY_FILE\n+{\n+\t\"brokerCapacities\": [{\n+\t\t\"brokerId\": \"-1\",\n+\t\t\"capacity\": {\n+\t\t\t\"DISK\": \"$BROKER_DISK_CAPACITY\",\n+\t\t\t\"CPU\": \"$BROKER_CPU_CAPACITY\",\n+\t\t\t\"NW_IN\": \"$BROKER_NETWORK_IN_CAPACITY\",\n+\t\t\t\"NW_OUT\": \"$BROKER_NETWORK_OUT_CAPACITY\"\n+\t\t},\n+\t\t\"doc\": \"This is the default capacity. Capacity unit used for disk is in MB, cpu is in percentage, network throughput is in KB.\"\n+\t}]\n+}\n+EOF\n+\n+cat $CC_CAPACITY_FILE\n+\n+# Generate cluster config\n+cat <<EOF > $CC_CLUSTER_CONFIG_FILE\n+{\n+min.insync.replicas=$MIN_INSYNC_REPLICAS\n+}\n+EOF\n+\n+# Write the config file\n+cat <<EOF\n+bootstrap.servers=$STRIMZI_KAFKA_BOOTSTRAP_SERVERS\n+zookeeper.connect=localhost:2181\n+partition.metric.sample.store.topic=__KafkaCruiseControlPartitionMetricSamples\n+broker.metric.sample.store.topic=__KafkaCruiseControlModelTrainingSamples\n+capacity.config.file=$CC_CAPACITY_FILE\n+cluster.configs.file=$CC_CLUSTER_CONFIG_FILE\n+webserver.accesslog.path=/tmp/access.log", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1NDg5NQ==", "bodyText": "This is basically the same file we use everywhere. Can we think about refactoring it so we actually have a single file? Opening a PR for this is fine.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402154895", "createdAt": "2020-04-02T08:54:47Z", "author": {"login": "tombentley"}, "path": "docker-images/kafka/cruise-control-scripts/cruise_control_tls_prepare_certificates.sh", "diffHunk": "@@ -0,0 +1,38 @@\n+#!/usr/bin/env bash", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1NzE4Ng==", "bodyText": "I think we should be careful with how we describe CC here. How does CC describe itself? People might misinterpret \"Kafka CruiseControl project\" to mean it's part of Apache Kafka. I think calling it CruiseControl (without the Kafka part) makes it clearer that it's an independent project.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402157186", "createdAt": "2020-04-02T08:58:18Z", "author": {"login": "tombentley"}, "path": "documentation/assemblies/cruise-control/assembly-cruise-control-concepts.adoc", "diffHunk": "@@ -0,0 +1,18 @@\n+// This assembly is included in the following assemblies:\n+//\n+// master.adoc\n+\n+[id='cruise-control-concepts-{context}']\n+= Cruise Control\n+\n+This chapter provides an overview of the Kafka cluster rebalancing features provided by the Kafka {CruiseControlProject} open source project and helps you get started using Cruise Control with {ProductName}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1Nzk2Mg==", "bodyText": "It's quite likely that the reader has no idea at this point what a \"balanced partition assignment\" is. I think you need a sentence before you even mention CC, just to guide the reader into the why why of CC before you get on to the how. Something like \"Brokers in a Kafka cluster can become unevenly loaded due to things like an uneven distribution of busy partitions.\"", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402157962", "createdAt": "2020-04-02T08:59:31Z", "author": {"login": "tombentley"}, "path": "documentation/modules/cruise-control/con-cruise-control-overview.adoc", "diffHunk": "@@ -0,0 +1,19 @@\n+// This concept is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+// Save the context of the assembly that is including this one.\n+// This is necessary for including assemblies in assemblies.\n+// See also the complementary step on the last line of this file.\n+\n+[id='con-cruise-control-overview-{context}']\n+= Cruise Control overview\n+\n+Cruise Control is a tool for simplifying the monitoring and rebalancing of partitions across a Kafka cluster.\n+You deploy Cruise Control alongside a Kafka cluster to:\n+\n+* Monitor the CPU, disk, and network load of Kafka brokers.\n+* Propose balanced partition assignments, known as partition rebalance proposals.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE2MTI5Ng==", "bodyText": "Does this belong in a procedure, rather than a concept?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402161296", "createdAt": "2020-04-02T09:04:54Z", "author": {"login": "tombentley"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000\n+      networkOut: 10000\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...\n+    resources: <4>\n+      requests:\n+        cpu: 200m\n+        memory: 64Mi\n+      limits:\n+        cpu: 500m\n+        memory: 128Mi\n+    logging: debug <5>\n+    template: <6>\n+      pod:\n+        metadata:\n+          labels:\n+            label1: value1\n+        securityContext:\n+          runAsUser: 1000001\n+          fsGroup: 0\n+        terminationGracePeriodSeconds: 120\n+    readinessProbe: <7>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+    livenessProbe: <8>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+# ...\n+----\n+<1> Number of Cruise Control application instances; set to `1` to run or `0` to pause the application.\n+<2> Specifies the Cruise Control capacity configuration. For more information, see xref:capacity_configuration[capacity configuration].\n+<3> Specifies the Cruise Control configuration. You can provide any xref:ref-cruise-control-configuration-{context}[standard configuration option] apart from those managed directly by {ProductName}.\n+<4> CPU and memory resources reserved for Cruise Control. For more information, see xref:assembly-resource-limits-and-requests-deployment-configuration-kafka[].\n+<5> Logging configuration, to log messages with a given severity (debug, info, warn, error, fatal) or above.\n+<6> xref:assembly-customizing-deployments-str[Customization of deployment templates and pods].\n+<7> xref:assembly-healthchecks-deployment-configuration-kafka[Healthcheck readiness probes].\n+<8> xref:assembly-healthchecks-deployment-configuration-kafka[Healthcheck liveness probes].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE2MjUyNA==", "bodyText": "This applies more generally to the rest of the docs too, but here would be a good place for a NOTE to say that if your String happens to look like YAML or JSON it will need to be explicitly quoted.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402162524", "createdAt": "2020-04-02T09:06:46Z", "author": {"login": "tombentley"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,92 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE2MzEyMQ==", "bodyText": "Which begs the question: What happens if the limits are violated?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402163121", "createdAt": "2020-04-02T09:07:45Z", "author": {"login": "tombentley"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,92 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE2MzQyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Since {ProductName} brokers are homogenous, Cruise Control will apply the same capacity limits to every broker it is monitoring.\n          \n          \n            \n            Since {ProductName} brokers are homogeneous, Cruise Control will apply the same capacity limits to every broker it is monitoring.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402163422", "createdAt": "2020-04-02T09:08:15Z", "author": {"login": "tombentley"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,92 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.\n+\n+Capacity limits for broker resources can be specified in the `capacity` property in `Kafka.spec.cruiseControl`.\n+Capacity limits can be set for the following broker resources in the described units:\n+\n+* `disk`  - Disk storage in MB\n+* `cpu`   - CPU utilization as a percent (0-100)\n+* `networkIn`  - Network inbound throughput in KB/s\n+* `networkOut` - Newtork outbound throughput in KB/s\n+\n+Since {ProductName} brokers are homogenous, Cruise Control will apply the same capacity limits to every broker it is monitoring.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MzY5MjMw", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#pullrequestreview-386369230", "createdAt": "2020-04-02T12:19:45Z", "commit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjoxOTo0NVrOF_ohtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjoxOTo0NVrOF_ohtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2ODU5OA==", "bodyText": "as Tom suggested above, config should also be configuration here", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402268598", "createdAt": "2020-04-02T12:19:45Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public CruiseControlBrokerCapacity getCapacity() {\n+        return capacity;\n+    }\n+\n+    public void setCapacity(CruiseControlBrokerCapacity capacity) {\n+        this.capacity = capacity;\n+    }\n+\n+    @Description(\"The Cruise Control config. Properties with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 98}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "25455e6fe2bdb3c7d08aa0c1d30de65050713eae", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/25455e6fe2bdb3c7d08aa0c1d30de65050713eae", "committedDate": "2020-04-06T22:36:48Z", "message": "Addressing more comments (refactoring capacity API, checkOwnerReferences)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}, "afterCommit": {"oid": "4a6ca6fc27e97919e7988bbda0f7f348ffd4ffb1", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/4a6ca6fc27e97919e7988bbda0f7f348ffd4ffb1", "committedDate": "2020-04-06T23:18:31Z", "message": "Addressing more comments (refactoring capacity API, checkOwnerReferences)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4a6ca6fc27e97919e7988bbda0f7f348ffd4ffb1", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/4a6ca6fc27e97919e7988bbda0f7f348ffd4ffb1", "committedDate": "2020-04-06T23:18:31Z", "message": "Addressing more comments (refactoring capacity API, checkOwnerReferences)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}, "afterCommit": {"oid": "25ae97a34e3b4b9852c5e358a59bb5033e6085a2", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/25ae97a34e3b4b9852c5e358a59bb5033e6085a2", "committedDate": "2020-04-06T23:20:25Z", "message": "Addressing more comments (refactoring capacity API, checkOwnerReferences)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "25ae97a34e3b4b9852c5e358a59bb5033e6085a2", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/25ae97a34e3b4b9852c5e358a59bb5033e6085a2", "committedDate": "2020-04-06T23:20:25Z", "message": "Addressing more comments (refactoring capacity API, checkOwnerReferences)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}, "afterCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/dfeccf9243734d19d38cea31ccf2f8f9f197a04a", "committedDate": "2020-04-06T23:21:58Z", "message": "Addressing more comments (refactoring capacity API, checkOwnerReferences)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4ODUzNTMx", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#pullrequestreview-388853531", "createdAt": "2020-04-07T07:31:45Z", "commit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzozMTo0NVrOGB2jTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwODowNToxNlrOGB3wZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NTUzMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n          \n          \n            \n                    + \"cruise.control.metrics.reporter.bootstrap.servers, sasl.interceptor.classes\";", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404595532", "createdAt": "2020-04-07T07:31:45Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NTU5Mw==", "bodyText": "I guess we should add ssl.cipher.suites and ssl.enabled.protocols to the exceptions.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404595593", "createdAt": "2020-04-07T07:31:49Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NTg2MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n          \n          \n            \n                    + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic,\"", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404595861", "createdAt": "2020-04-07T07:32:19Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NjQzMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Description(\"The Cruise Control brokerCapacity configuration.\")\n          \n          \n            \n                @Description(\"The Cruise Control `brokerCapacity` configuration.\")", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404596432", "createdAt": "2020-04-07T07:33:14Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control brokerCapacity configuration.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NjcwMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \" https://github.com/linkedin/cruise-control/wiki/Configurations Note that properties \" +\n          \n          \n            \n                        \" https://github.com/linkedin/cruise-control/wiki/Configurations. Note that properties \" +", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404596702", "createdAt": "2020-04-07T07:33:41Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control brokerCapacity configuration.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public BrokerCapacity getBrokerCapacity() {\n+        return brokerCapacity;\n+    }\n+\n+    public void setBrokerCapacity(BrokerCapacity brokerCapacity) {\n+        this.brokerCapacity = brokerCapacity;\n+    }\n+\n+    @Description(\"The Cruise Control configuration. For a full list of configuration options refer to\" +\n+            \" https://github.com/linkedin/cruise-control/wiki/Configurations Note that properties \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NjkwMg==", "bodyText": "You'll need to add the exception if they're non-empty.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404596902", "createdAt": "2020-04-07T07:34:01Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control brokerCapacity configuration.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public BrokerCapacity getBrokerCapacity() {\n+        return brokerCapacity;\n+    }\n+\n+    public void setBrokerCapacity(BrokerCapacity brokerCapacity) {\n+        this.brokerCapacity = brokerCapacity;\n+    }\n+\n+    @Description(\"The Cruise Control configuration. For a full list of configuration options refer to\" +\n+            \" https://github.com/linkedin/cruise-control/wiki/Configurations Note that properties \" +\n+            \"with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NzE3OA==", "bodyText": "Is this a log4j2 logging config or a log4j1 logging config?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404597178", "createdAt": "2020-04-07T07:34:30Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control brokerCapacity configuration.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public BrokerCapacity getBrokerCapacity() {\n+        return brokerCapacity;\n+    }\n+\n+    public void setBrokerCapacity(BrokerCapacity brokerCapacity) {\n+        this.brokerCapacity = brokerCapacity;\n+    }\n+\n+    @Description(\"The Cruise Control configuration. For a full list of configuration options refer to\" +\n+            \" https://github.com/linkedin/cruise-control/wiki/Configurations Note that properties \" +\n+            \"with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, Object> getConfig() {\n+        return config;\n+    }\n+\n+    public void setConfig(Map<String, Object> config) {\n+        this.config = config;\n+    }\n+\n+    @Description(\"Logging configuration for Cruise Control.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwNDEwNg==", "bodyText": "So the alternative to doing it like this would be to use String-typed properties and @Pattern(\"[0-9]+([KMG]i?)?B/s.\n\nIt reads nicer (outboundNetwork: 100KiB/s vs outboundNetworkKiBPerSecond: 100) and is shorter.\nIt is a little more flexible for the user to specify.\nWe could, perhaps, be relaxed about capitalisation too (cf. KiBPerSecond which will tire my pinkie pretty fast).\nIt's more consistent with how Kubernetes specifies memory usage.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404604106", "createdAt": "2020-04-07T07:46:26Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/BrokerCapacity.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"diskMiB\", \"cpuUtilization\", \"inboundNetworkKiBPerSecond\", \"outboundNetworkKiBPerSecond\"})\n+@EqualsAndHashCode\n+public class BrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer diskMiB;\n+    private Integer cpuUtilization;\n+    private Integer inboundNetworkKiBPerSecond;\n+    private Integer outboundNetworkKiBPerSecond;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Description(\"Broker capacity for disk in base 2 mebibytes.\")\n+    public Integer getDiskMiB() {\n+        return diskMiB;\n+    }\n+\n+    public void setDiskMiB(Integer diskMiB) {\n+        this.diskMiB = diskMiB;\n+    }\n+\n+    @Minimum(0)\n+    @Maximum(100)\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for CPU resource utilization as a percentage (0 - 100).\")\n+    public Integer getCpuUtilization() {\n+        return cpuUtilization;\n+    }\n+\n+    public void setCpuUtilization(Integer cpuUtilization) {\n+        this.cpuUtilization = cpuUtilization;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for network inbound throughput in base 2 kibibytes per second.\")\n+    public Integer getInboundNetworkKiBPerSecond() {\n+        return inboundNetworkKiBPerSecond;\n+    }\n+\n+    public void setInboundNetworkKiBPerSecond(Integer inboundNetworkKiBPerSecond) {\n+        this.inboundNetworkKiBPerSecond = inboundNetworkKiBPerSecond;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for network outbound throughput in base 2 kibibytes per second.\")\n+    public Integer getOutboundNetworkKiBPerSecond() {\n+        return outboundNetworkKiBPerSecond;\n+    }\n+\n+    public void setOutboundNetworkKiBPerSecond(Integer outboundNetworkKiBPerSecond) {\n+        this.outboundNetworkKiBPerSecond = outboundNetworkKiBPerSecond;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwNTY0OA==", "bodyText": "Comment that this is 1 day, or use TimeUnit.DAYS.toMillis(1)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404605648", "createdAt": "2020-04-07T07:49:08Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControlConfiguration.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+\n+/**\n+ * Class for handling Cruise Control configuration passed by the user\n+ */\n+public class CruiseControlConfiguration extends AbstractConfiguration {\n+\n+    /**\n+     * A list of case insensitive goals that Cruise Control supports in the order of priority.\n+     * The high priority goals will be executed first.\n+     */\n+    private static final String DEFAULT_GOALS = \"com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.PotentialNwOutGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.TopicReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderBytesInDistributionGoal\";\n+\n+   /*\n+    * Map containing default values for required configuration properties\n+    */\n+    private static final Map<String, String> CC_DEFAULT_PROPERTIES_MAP;\n+\n+    private static final List<String> FORBIDDEN_OPTIONS;\n+    private static final List<String> EXCEPTIONS;\n+\n+    static {\n+        CC_DEFAULT_PROPERTIES_MAP = new HashMap<>();\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"partition.metrics.window.ms\", Integer.toString(300_000));\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"num.partition.metrics.windows\", \"1\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"broker.metrics.window.ms\", Integer.toString(300_000));\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"num.broker.metrics.windows\", \"20\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"completed.user.task.retention.time.ms\", Integer.toString(86_400_000));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwNzQ1MA==", "bodyText": "I think it's better to move this down to just before the variable is first used.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404607450", "createdAt": "2020-04-07T07:52:02Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -440,6 +448,24 @@ public static KafkaCluster fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup vers\n         }\n \n         KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+        CruiseControlSpec cruiseControlSpec  = kafkaSpec.getCruiseControl();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwODIzMg==", "bodyText": "Is it legal to have whitespace in there too (between items or at each end?) org.example.Foo, com.example.Bar", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404608232", "createdAt": "2020-04-07T07:53:27Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -440,6 +448,24 @@ public static KafkaCluster fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup vers\n         }\n \n         KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+        CruiseControlSpec cruiseControlSpec  = kafkaSpec.getCruiseControl();\n+\n+        String metricReporters =  configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD);\n+        Set<String> metricReporterList = new HashSet<>();\n+        if (metricReporters != null) {\n+            addAll(metricReporterList, configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD).split(\",\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwOTUxNA==", "bodyText": "So it they added CRUISE_CONTROL_METRIC_REPORTER explicitly themselves we remove it unless they also specified a CruiseControlSpec? I think this is more or less a moot point at the moment, since there's no mechanism for people to add plugin classes to our Kafka images (apart from them building their own images, which perhaps some people do). But I would none the less argue that this is not the right thing to do.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404609514", "createdAt": "2020-04-07T07:55:36Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -440,6 +448,24 @@ public static KafkaCluster fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup vers\n         }\n \n         KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+        CruiseControlSpec cruiseControlSpec  = kafkaSpec.getCruiseControl();\n+\n+        String metricReporters =  configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD);\n+        Set<String> metricReporterList = new HashSet<>();\n+        if (metricReporters != null) {\n+            addAll(metricReporterList, configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD).split(\",\"));\n+        }\n+        if (cruiseControlSpec != null) {\n+            metricReporterList.add(CRUISE_CONTROL_METRIC_REPORTER);\n+        } else {\n+            metricReporterList.remove(CRUISE_CONTROL_METRIC_REPORTER);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMDczNA==", "bodyText": "Rounding? e.g. what happens if I ask for 100MB in GB, presumably I get 0?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404610734", "createdAt": "2020-04-07T07:57:43Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/StorageUtils.java", "diffHunk": "@@ -12,6 +12,21 @@\n  * Shared methods for working with Storage - for example comparing volume sizes\n  */\n public class StorageUtils {\n+    /**\n+     * Parse a K8S-style representation of a quantity of memory, such as {@code 512Mi},\n+     * into the equivalent number of bytes in the specified units.\n+     * For example, a memory value of \"100Gb\" and a unit value of \"Mb\" will return 100000,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMTQ5NA==", "bodyText": "So does this mean the CC doesn't really distinguish the disks as having individual sizes?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404611494", "createdAt": "2020-04-07T07:58:55Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/cruisecontrol/Capacity.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model.cruisecontrol;\n+\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+\n+import java.util.List;\n+\n+import static io.strimzi.operator.cluster.model.StorageUtils.parseMemory;\n+\n+public class Capacity {\n+    public static final long DEFAULT_BROKER_DISK_MIB_CAPACITY = 100_000;  // in MiB\n+    public static final int DEFAULT_BROKER_CPU_UTILIZATION_CAPACITY = 100;  // as a percentage (0-100)\n+    public static final int DEFAULT_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = 10_000;  // in KiB/s\n+    public static final int DEFAULT_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = 10_000;  // in KiB/s\n+\n+    private Long diskMiB;\n+    private Integer cpuUtilization;\n+    private Integer inboundNetworkKiBPerSecond;\n+    private Integer outboutNetworkKibPerSecond;\n+\n+    public Capacity(KafkaSpec spec) {\n+        BrokerCapacity bc = spec.getCruiseControl().getBrokerCapacity();\n+\n+        this.diskMiB = bc != null && bc.getDiskMiB() != null ? bc.getDiskMiB() : generateDiskCapacity(spec.getKafka().getStorage());\n+        this.cpuUtilization = bc != null && bc.getCpuUtilization() != null ? bc.getCpuUtilization() : DEFAULT_BROKER_CPU_UTILIZATION_CAPACITY;\n+        this.inboundNetworkKiBPerSecond = bc != null && bc.getInboundNetworkKiBPerSecond() != null ? bc.getInboundNetworkKiBPerSecond() : DEFAULT_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY;\n+        this.outboutNetworkKibPerSecond = bc != null && bc.getOutboundNetworkKiBPerSecond() != null ? bc.getOutboundNetworkKiBPerSecond() : DEFAULT_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY;\n+    }\n+\n+    /**\n+     * Generate diskMiB capacity configuration from the supplied storage configuration\n+     *\n+     * @param storage Storage configuration for Kafka cluster\n+     * @return Disk capacity configuration as a Long\n+     */\n+    public static Long generateDiskCapacity(Storage storage) {\n+        if (storage instanceof PersistentClaimStorage) {\n+            return getSizeInMiB(((PersistentClaimStorage) storage).getSize());\n+        } else if (storage instanceof EphemeralStorage) {\n+            if (((EphemeralStorage) storage).getSizeLimit() != null) {\n+                return getSizeInMiB(((EphemeralStorage) storage).getSizeLimit());\n+            } else {\n+                return DEFAULT_BROKER_DISK_MIB_CAPACITY;\n+            }\n+        } else if (storage instanceof JbodStorage) {\n+            List<SingleVolumeStorage> volumeList = ((JbodStorage) storage).getVolumes();\n+            long size = 0;\n+            for (SingleVolumeStorage volume : volumeList) {\n+                size += generateDiskCapacity(volume);\n+            }\n+            return size;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxNTI2OA==", "bodyText": "We'll need to update this for the ssl ones too.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404615268", "createdAt": "2020-04-07T08:05:16Z", "author": {"login": "tombentley"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MTA0NDI4", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#pullrequestreview-389104428", "createdAt": "2020-04-07T13:17:06Z", "commit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoxNzowNlrOGCDCqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNTo0NjozMVrOGC1baw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwMDE2OQ==", "bodyText": "FYI - this cross-reference is currently broken.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404800169", "createdAt": "2020-04-07T13:17:06Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.\n+A violation of a goal can cause a optimization to fail, preventing that optimization from being used to generate a partition rebalance proposal.\n+For example, an optimization that would cause a broker to exceed its CPU capacity would not be used for when the CpuCapacityGoal is set as a hard goal.\n+\n+Capacity limits for broker resources can be specified in the `brokerCapacity` property in `Kafka.spec.cruiseControl`.\n+Capacity limits can be set for the following broker resources in the described units:\n+\n+* `diskMiB`  - Disk storage in MiB\n+* `cpuUtilization`   - CPU utilization as a percent (0-100)\n+* `inboundNetworkKiBPerSecond`  - Network inbound throughput in KiB/s\n+* `outboundNetworkKiBPerSecond` - Newtork outbound throughput in KiB/s\n+\n+Since {ProductName} brokers are homogeneous, Cruise Control will apply the same capacity limits to every broker it is monitoring.\n+\n+.An example Cruise Control brokerCapacity configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    brokerCapacity:\n+      diskMiB: 100000\n+      cpuUtilization: 100\n+      inboundNetworkKiBPerSecond: 10000\n+      outboundNetworkKiBPerSecond: 10000\n+    # ...\n+----\n+\n+.Additional resources\n+For information, refer to the xref:type-CruiseControlBrokerCapacity-reference[Capacity schema reference].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgyMTg1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Brokers in a Kafka cluster can become unevenly loaded due to things like an uneven distribution of busy partitions.\n          \n          \n            \n            Brokers in a Kafka cluster can become unevenly loaded for many reasons. For example, partitions that handle large amounts of message traffic can be unevenly distributed across the available brokers.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404821851", "createdAt": "2020-04-07T13:47:01Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/con-cruise-control-overview.adoc", "diffHunk": "@@ -0,0 +1,20 @@\n+// This concept is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+// Save the context of the assembly that is including this one.\n+// This is necessary for including assemblies in assemblies.\n+// See also the complementary step on the last line of this file.\n+\n+[id='con-cruise-control-overview-{context}']\n+= Cruise Control overview\n+\n+Brokers in a Kafka cluster can become unevenly loaded due to things like an uneven distribution of busy partitions.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgyNjI4OQ==", "bodyText": "Next, I would explain that partition reassignment is usually a manual task. Perhaps you could add a sentence like the following:\n\"Monitoring broker load and reassigning busy partitions to brokers with spare capacity is time consuming and adds to the overhead of managing a Kafka cluster\"", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404826289", "createdAt": "2020-04-07T13:52:58Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/con-cruise-control-overview.adoc", "diffHunk": "@@ -0,0 +1,20 @@\n+// This concept is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+// Save the context of the assembly that is including this one.\n+// This is necessary for including assemblies in assemblies.\n+// See also the complementary step on the last line of this file.\n+\n+[id='con-cruise-control-overview-{context}']\n+= Cruise Control overview\n+\n+Brokers in a Kafka cluster can become unevenly loaded due to things like an uneven distribution of busy partitions.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgyMTg1MQ=="}, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg0Mzk3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Cruise Control is a tool for simplifying the monitoring and rebalancing of partitions across a Kafka cluster.\n          \n          \n            \n            Cruise Control is a tool for automating the monitoring and rebalancing of partitions across a Kafka cluster.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404843975", "createdAt": "2020-04-07T14:16:28Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/con-cruise-control-overview.adoc", "diffHunk": "@@ -0,0 +1,20 @@\n+// This concept is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+// Save the context of the assembly that is including this one.\n+// This is necessary for including assemblies in assemblies.\n+// See also the complementary step on the last line of this file.\n+\n+[id='con-cruise-control-overview-{context}']\n+= Cruise Control overview\n+\n+Brokers in a Kafka cluster can become unevenly loaded due to things like an uneven distribution of busy partitions.\n+Cruise Control is a tool for simplifying the monitoring and rebalancing of partitions across a Kafka cluster.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1NzAwNQ==", "bodyText": "I think we should make CC the subject of this sentence and use different terminology. Please rephrase to something like the following:\nWhen deployed alongside a Kafka cluster, Cruise Control can perform the following cluster balancing tasks:\n\nMonitoring...\nMaking optimization proposals: balanced partition assignments based on configurable optimization goals.\nExecuting partition reassignments based on optimization proposals.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404857005", "createdAt": "2020-04-07T14:33:12Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/con-cruise-control-overview.adoc", "diffHunk": "@@ -0,0 +1,20 @@\n+// This concept is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+// Save the context of the assembly that is including this one.\n+// This is necessary for including assemblies in assemblies.\n+// See also the complementary step on the last line of this file.\n+\n+[id='con-cruise-control-overview-{context}']\n+= Cruise Control overview\n+\n+Brokers in a Kafka cluster can become unevenly loaded due to things like an uneven distribution of busy partitions.\n+Cruise Control is a tool for simplifying the monitoring and rebalancing of partitions across a Kafka cluster.\n+You deploy Cruise Control alongside a Kafka cluster to:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg3MDQ3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n          \n          \n            \n            Cruise Control is configured using the `cruiseControl` property in the `Kafka` resource. Once configured, you can deploy a Cruise Control instance to your {ProductName} cluster by creating or updating the `Kafka` resource.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404870478", "createdAt": "2020-04-07T14:50:15Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg3MTY2NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <1> Number of Cruise Control application instances; set to `1` to run or `0` to pause the application.\n          \n          \n            \n            <1> Number of Cruise Control instances to create. Set to `1` to run the application or `0` to pause it.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404871664", "createdAt": "2020-04-07T14:51:45Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000\n+      networkOut: 10000\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...\n+    resources: <4>\n+      requests:\n+        cpu: 200m\n+        memory: 64Mi\n+      limits:\n+        cpu: 500m\n+        memory: 128Mi\n+    logging: debug <5>\n+    template: <6>\n+      pod:\n+        metadata:\n+          labels:\n+            label1: value1\n+        securityContext:\n+          runAsUser: 1000001\n+          fsGroup: 0\n+        terminationGracePeriodSeconds: 120\n+    readinessProbe: <7>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+    livenessProbe: <8>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+# ...\n+----\n+<1> Number of Cruise Control application instances; set to `1` to run or `0` to pause the application.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYwMTA2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n          \n          \n            \n            For an overview of the `Kafka` resource, see the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration].", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405601063", "createdAt": "2020-04-08T15:13:11Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYwMTQwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n          \n          \n            \n            You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster. Deploy one instance of Cruise Control per Kafka cluster.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405601404", "createdAt": "2020-04-08T15:13:39Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYwNDg2NQ==", "bodyText": "On balance, I think it should stay here because the example configuration is helpful within the context of the task. In other words, it doesn't seem to stand alone as a concept or reference module.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405604865", "createdAt": "2020-04-08T15:18:20Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000\n+      networkOut: 10000\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...\n+    resources: <4>\n+      requests:\n+        cpu: 200m\n+        memory: 64Mi\n+      limits:\n+        cpu: 500m\n+        memory: 128Mi\n+    logging: debug <5>\n+    template: <6>\n+      pod:\n+        metadata:\n+          labels:\n+            label1: value1\n+        securityContext:\n+          runAsUser: 1000001\n+          fsGroup: 0\n+        terminationGracePeriodSeconds: 120\n+    readinessProbe: <7>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+    livenessProbe: <8>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+# ...\n+----\n+<1> Number of Cruise Control application instances; set to `1` to run or `0` to pause the application.\n+<2> Specifies the Cruise Control capacity configuration. For more information, see xref:capacity_configuration[capacity configuration].\n+<3> Specifies the Cruise Control configuration. You can provide any xref:ref-cruise-control-configuration-{context}[standard configuration option] apart from those managed directly by {ProductName}.\n+<4> CPU and memory resources reserved for Cruise Control. For more information, see xref:assembly-resource-limits-and-requests-deployment-configuration-kafka[].\n+<5> Logging configuration, to log messages with a given severity (debug, info, warn, error, fatal) or above.\n+<6> xref:assembly-customizing-deployments-str[Customization of deployment templates and pods].\n+<7> xref:assembly-healthchecks-deployment-configuration-kafka[Healthcheck readiness probes].\n+<8> xref:assembly-healthchecks-deployment-configuration-kafka[Healthcheck liveness probes].", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE2MTI5Ng=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYwODEzOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <2> Specifies the Cruise Control capacity configuration. For more information, see xref:capacity_configuration[capacity configuration].\n          \n          \n            \n            <2> Specifies capacity limits for broker resources. For more information, see xref:capacity_configuration[Capacity configuration].", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405608138", "createdAt": "2020-04-08T15:22:38Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000\n+      networkOut: 10000\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...\n+    resources: <4>\n+      requests:\n+        cpu: 200m\n+        memory: 64Mi\n+      limits:\n+        cpu: 500m\n+        memory: 128Mi\n+    logging: debug <5>\n+    template: <6>\n+      pod:\n+        metadata:\n+          labels:\n+            label1: value1\n+        securityContext:\n+          runAsUser: 1000001\n+          fsGroup: 0\n+        terminationGracePeriodSeconds: 120\n+    readinessProbe: <7>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+    livenessProbe: <8>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+# ...\n+----\n+<1> Number of Cruise Control application instances; set to `1` to run or `0` to pause the application.\n+<2> Specifies the Cruise Control capacity configuration. For more information, see xref:capacity_configuration[capacity configuration].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYwOTU3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <3> Specifies the Cruise Control configuration. You can provide any xref:ref-cruise-control-configuration-{context}[standard configuration option] apart from those managed directly by {ProductName}.\n          \n          \n            \n            <3> Defines the Cruise Control configuration, including default and enabled optimization goals. You can provide any xref:ref-cruise-control-configuration-{context}[standard configuration option] apart from those managed directly by {ProductName}.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405609578", "createdAt": "2020-04-08T15:24:29Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000\n+      networkOut: 10000\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...\n+    resources: <4>\n+      requests:\n+        cpu: 200m\n+        memory: 64Mi\n+      limits:\n+        cpu: 500m\n+        memory: 128Mi\n+    logging: debug <5>\n+    template: <6>\n+      pod:\n+        metadata:\n+          labels:\n+            label1: value1\n+        securityContext:\n+          runAsUser: 1000001\n+          fsGroup: 0\n+        terminationGracePeriodSeconds: 120\n+    readinessProbe: <7>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+    livenessProbe: <8>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+# ...\n+----\n+<1> Number of Cruise Control application instances; set to `1` to run or `0` to pause the application.\n+<2> Specifies the Cruise Control capacity configuration. For more information, see xref:capacity_configuration[capacity configuration].\n+<3> Specifies the Cruise Control configuration. You can provide any xref:ref-cruise-control-configuration-{context}[standard configuration option] apart from those managed directly by {ProductName}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYxMTM0Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <5> Logging configuration, to log messages with a given severity (debug, info, warn, error, fatal) or above.\n          \n          \n            \n            <5>Defines the logging configuration. Messages are logged with a severity level of `debug`, `info`, `warn`, `error`, or `fatal`.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405611347", "createdAt": "2020-04-08T15:26:54Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000\n+      networkOut: 10000\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...\n+    resources: <4>\n+      requests:\n+        cpu: 200m\n+        memory: 64Mi\n+      limits:\n+        cpu: 500m\n+        memory: 128Mi\n+    logging: debug <5>\n+    template: <6>\n+      pod:\n+        metadata:\n+          labels:\n+            label1: value1\n+        securityContext:\n+          runAsUser: 1000001\n+          fsGroup: 0\n+        terminationGracePeriodSeconds: 120\n+    readinessProbe: <7>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+    livenessProbe: <8>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+# ...\n+----\n+<1> Number of Cruise Control application instances; set to `1` to run or `0` to pause the application.\n+<2> Specifies the Cruise Control capacity configuration. For more information, see xref:capacity_configuration[capacity configuration].\n+<3> Specifies the Cruise Control configuration. You can provide any xref:ref-cruise-control-configuration-{context}[standard configuration option] apart from those managed directly by {ProductName}.\n+<4> CPU and memory resources reserved for Cruise Control. For more information, see xref:assembly-resource-limits-and-requests-deployment-configuration-kafka[].\n+<5> Logging configuration, to log messages with a given severity (debug, info, warn, error, fatal) or above.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYxMjM5Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            . Verify the Cruise Control deployment:\n          \n          \n            \n            . Verify that Cruise Control was successfully deployed:", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405612392", "createdAt": "2020-04-08T15:28:12Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000\n+      networkOut: 10000\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...\n+    resources: <4>\n+      requests:\n+        cpu: 200m\n+        memory: 64Mi\n+      limits:\n+        cpu: 500m\n+        memory: 128Mi\n+    logging: debug <5>\n+    template: <6>\n+      pod:\n+        metadata:\n+          labels:\n+            label1: value1\n+        securityContext:\n+          runAsUser: 1000001\n+          fsGroup: 0\n+        terminationGracePeriodSeconds: 120\n+    readinessProbe: <7>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+    livenessProbe: <8>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+# ...\n+----\n+<1> Number of Cruise Control application instances; set to `1` to run or `0` to pause the application.\n+<2> Specifies the Cruise Control capacity configuration. For more information, see xref:capacity_configuration[capacity configuration].\n+<3> Specifies the Cruise Control configuration. You can provide any xref:ref-cruise-control-configuration-{context}[standard configuration option] apart from those managed directly by {ProductName}.\n+<4> CPU and memory resources reserved for Cruise Control. For more information, see xref:assembly-resource-limits-and-requests-deployment-configuration-kafka[].\n+<5> Logging configuration, to log messages with a given severity (debug, info, warn, error, fatal) or above.\n+<6> xref:assembly-customizing-deployments-str[Customization of deployment templates and pods].\n+<7> xref:assembly-healthchecks-deployment-configuration-kafka[Healthcheck readiness probes].\n+<8> xref:assembly-healthchecks-deployment-configuration-kafka[Healthcheck liveness probes].\n+\n+. Create or update the resource:\n++\n+[source,shell,subs=\"+quotes\"]\n+----\n+kubectl apply -f _kafka.yaml_\n+----\n+\n+. Verify the Cruise Control deployment:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYxNDExNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.\n          \n          \n            \n            Cruise Control uses _capacity limits_ to determine if optimization goals for broker resources are being broken.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405614117", "createdAt": "2020-04-08T15:30:26Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyMTM1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            A violation of a goal can cause a optimization to fail, preventing that optimization from being used to generate a partition rebalance proposal.\n          \n          \n            \n            An optimization will fail if a goal is broken, preventing the optimization from being used to generate an optimization proposal for balanced partition assignments.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405621351", "createdAt": "2020-04-08T15:40:15Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.\n+A violation of a goal can cause a optimization to fail, preventing that optimization from being used to generate a partition rebalance proposal.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyMTg5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For example, an optimization that would cause a broker to exceed its CPU capacity would not be used for when the CpuCapacityGoal is set as a hard goal.\n          \n          \n            \n            For example, an optimization that would cause a broker to exceed its CPU capacity would not be used if the `CpuCapacityGoal` is set as a hard goal.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405621890", "createdAt": "2020-04-08T15:41:02Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.\n+A violation of a goal can cause a optimization to fail, preventing that optimization from being used to generate a partition rebalance proposal.\n+For example, an optimization that would cause a broker to exceed its CPU capacity would not be used for when the CpuCapacityGoal is set as a hard goal.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyMzAwMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Capacity limits for broker resources can be specified in the `brokerCapacity` property in `Kafka.spec.cruiseControl`.\n          \n          \n            \n            You specify capacity limits for broker resources in the `brokerCapacity` property in `Kafka.spec.cruiseControl` .", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405623001", "createdAt": "2020-04-08T15:42:37Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.\n+A violation of a goal can cause a optimization to fail, preventing that optimization from being used to generate a partition rebalance proposal.\n+For example, an optimization that would cause a broker to exceed its CPU capacity would not be used for when the CpuCapacityGoal is set as a hard goal.\n+\n+Capacity limits for broker resources can be specified in the `brokerCapacity` property in `Kafka.spec.cruiseControl`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyNDc3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * `outboundNetworkKiBPerSecond` - Newtork outbound throughput in KiB/s\n          \n          \n            \n            * `outboundNetworkKiBPerSecond` - Network outbound throughput in KiB/s", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405624775", "createdAt": "2020-04-08T15:45:04Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.\n+A violation of a goal can cause a optimization to fail, preventing that optimization from being used to generate a partition rebalance proposal.\n+For example, an optimization that would cause a broker to exceed its CPU capacity would not be used for when the CpuCapacityGoal is set as a hard goal.\n+\n+Capacity limits for broker resources can be specified in the `brokerCapacity` property in `Kafka.spec.cruiseControl`.\n+Capacity limits can be set for the following broker resources in the described units:\n+\n+* `diskMiB`  - Disk storage in MiB\n+* `cpuUtilization`   - CPU utilization as a percent (0-100)\n+* `inboundNetworkKiBPerSecond`  - Network inbound throughput in KiB/s\n+* `outboundNetworkKiBPerSecond` - Newtork outbound throughput in KiB/s", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyNTQ2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Since {ProductName} brokers are homogeneous, Cruise Control will apply the same capacity limits to every broker it is monitoring.\n          \n          \n            \n            Because Kafka brokers are homogeneous, Cruise Control applies the same capacity limits to every broker it is monitoring.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405625463", "createdAt": "2020-04-08T15:46:08Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.\n+A violation of a goal can cause a optimization to fail, preventing that optimization from being used to generate a partition rebalance proposal.\n+For example, an optimization that would cause a broker to exceed its CPU capacity would not be used for when the CpuCapacityGoal is set as a hard goal.\n+\n+Capacity limits for broker resources can be specified in the `brokerCapacity` property in `Kafka.spec.cruiseControl`.\n+Capacity limits can be set for the following broker resources in the described units:\n+\n+* `diskMiB`  - Disk storage in MiB\n+* `cpuUtilization`   - CPU utilization as a percent (0-100)\n+* `inboundNetworkKiBPerSecond`  - Network inbound throughput in KiB/s\n+* `outboundNetworkKiBPerSecond` - Newtork outbound throughput in KiB/s\n+\n+Since {ProductName} brokers are homogeneous, Cruise Control will apply the same capacity limits to every broker it is monitoring.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyNTcwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For information, refer to the xref:type-CruiseControlBrokerCapacity-reference[Capacity schema reference].\n          \n          \n            \n            For more information, refer to the xref:type-CruiseControlBrokerCapacity-reference[].", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405625707", "createdAt": "2020-04-08T15:46:31Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.\n+A violation of a goal can cause a optimization to fail, preventing that optimization from being used to generate a partition rebalance proposal.\n+For example, an optimization that would cause a broker to exceed its CPU capacity would not be used for when the CpuCapacityGoal is set as a hard goal.\n+\n+Capacity limits for broker resources can be specified in the `brokerCapacity` property in `Kafka.spec.cruiseControl`.\n+Capacity limits can be set for the following broker resources in the described units:\n+\n+* `diskMiB`  - Disk storage in MiB\n+* `cpuUtilization`   - CPU utilization as a percent (0-100)\n+* `inboundNetworkKiBPerSecond`  - Network inbound throughput in KiB/s\n+* `outboundNetworkKiBPerSecond` - Newtork outbound throughput in KiB/s\n+\n+Since {ProductName} brokers are homogeneous, Cruise Control will apply the same capacity limits to every broker it is monitoring.\n+\n+.An example Cruise Control brokerCapacity configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    brokerCapacity:\n+      diskMiB: 100000\n+      cpuUtilization: 100\n+      inboundNetworkKiBPerSecond: 10000\n+      outboundNetworkKiBPerSecond: 10000\n+    # ...\n+----\n+\n+.Additional resources\n+For information, refer to the xref:type-CruiseControlBrokerCapacity-reference[Capacity schema reference].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 96}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "be06b746a395cab517807d83c9b647141883de13", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/be06b746a395cab517807d83c9b647141883de13", "committedDate": "2020-04-14T22:35:02Z", "message": "Add missing goal; bump CC version to 2.0.100\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}, "afterCommit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f", "committedDate": "2020-04-15T15:33:37Z", "message": "Fix logging and typos\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2Mjc1NDg4", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#pullrequestreview-396275488", "createdAt": "2020-04-20T09:13:12Z", "commit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f"}, "state": "APPROVED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToxMzoxMlrOGIK4yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToyNzozNlrOGILe4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyMDE3MQ==", "bodyText": "I think we should allow stuff like 1.5T and exponential notation like 2e6 (which Kube does for memory, for example).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Pattern(\"^[0-9]+([KMGTPE]i?)?$\")\n          \n          \n            \n                @Pattern(\"^[0-9]+([.][0-9]*)?([KMGTPE]i?|e[0-9]+)?$\")\n          \n      \n    \n    \n  \n\nAnd I guess to be consistent with the network settings we should allow the B suffix in there too. It's difficult because we're trying to be consistent with Kube, but what Kube does (omitting the actual unit) doesn't really work for the network rates.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411220171", "createdAt": "2020-04-20T09:13:12Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/BrokerCapacity.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpuUtilization\", \"inboundNetwork\", \"outboundNetwork\"})\n+@EqualsAndHashCode\n+public class BrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private String disk;\n+    private Integer cpuUtilization;\n+    private String inboundNetwork;\n+    private String outboundNetwork;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Pattern(\"^[0-9]+([KMGTPE]i?)?$\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyMzQ4NA==", "bodyText": "Can we explicitly say that this is in bytes per second, just to avoid people mistakenly thinking it might be in bits per second? Same for the outbound.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411223484", "createdAt": "2020-04-20T09:18:17Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/BrokerCapacity.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpuUtilization\", \"inboundNetwork\", \"outboundNetwork\"})\n+@EqualsAndHashCode\n+public class BrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private String disk;\n+    private Integer cpuUtilization;\n+    private String inboundNetwork;\n+    private String outboundNetwork;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Pattern(\"^[0-9]+([KMGTPE]i?)?$\")\n+    @Description(\"Broker capacity for disk, for example, 100Gi.\")\n+    public String getDisk() {\n+        return disk;\n+    }\n+\n+    public void setDisk(String disk) {\n+        this.disk = disk;\n+    }\n+\n+    @Minimum(0)\n+    @Maximum(100)\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for CPU resource utilization as a percentage (0 - 100).\")\n+    public Integer getCpuUtilization() {\n+        return cpuUtilization;\n+    }\n+\n+    public void setCpuUtilization(Integer cpuUtilization) {\n+        this.cpuUtilization = cpuUtilization;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Pattern(\"[0-9]+([KMG]i?)?B/s\")\n+    @Description(\"Broker capacity for network inbound throughput, for example, 10000KB/s\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyNDMwMA==", "bodyText": "I don't think we need these double empty lines (here and the following two).", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411224300", "createdAt": "2020-04-20T09:19:25Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,497 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC = \"cruise.control.metrics.topic\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC_VALUE = \"strimzi.cruisecontrol.metrics\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"/logging\";\n+\n+    private String zookeeperConnect;\n+\n+    // Configuration defaults\n+    protected static final int DEFAULT_REPLICAS = 1;\n+\n+    // Default probe settings (liveness and readiness) for health checks\n+    protected static final int DEFAULT_HEALTHCHECK_DELAY = 15;\n+    protected static final int DEFAULT_HEALTHCHECK_TIMEOUT = 5;\n+\n+    public static final Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder()\n+            .withInitialDelaySeconds(DEFAULT_HEALTHCHECK_DELAY)\n+            .withTimeoutSeconds(DEFAULT_HEALTHCHECK_TIMEOUT)\n+            .build();\n+\n+    private TlsSidecar tlsSidecar;\n+    private String tlsSidecarImage;\n+    private String minInsyncReplicas = \"1\";\n+    private Double brokerDiskMiBCapacity;\n+    private int brokerCpuUtilizationCapacity;\n+    private Double brokerInboundNetworkKiBPerSecondCapacity;\n+    private Double brokerOuboundNetworkKiBPerSecondCapacity;\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyNDY2MA==", "bodyText": "Collections.singletonList()", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411224660", "createdAt": "2020-04-20T09:19:53Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,497 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC = \"cruise.control.metrics.topic\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC_VALUE = \"strimzi.cruisecontrol.metrics\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"/logging\";\n+\n+    private String zookeeperConnect;\n+\n+    // Configuration defaults\n+    protected static final int DEFAULT_REPLICAS = 1;\n+\n+    // Default probe settings (liveness and readiness) for health checks\n+    protected static final int DEFAULT_HEALTHCHECK_DELAY = 15;\n+    protected static final int DEFAULT_HEALTHCHECK_TIMEOUT = 5;\n+\n+    public static final Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder()\n+            .withInitialDelaySeconds(DEFAULT_HEALTHCHECK_DELAY)\n+            .withTimeoutSeconds(DEFAULT_HEALTHCHECK_TIMEOUT)\n+            .build();\n+\n+    private TlsSidecar tlsSidecar;\n+    private String tlsSidecarImage;\n+    private String minInsyncReplicas = \"1\";\n+    private Double brokerDiskMiBCapacity;\n+    private int brokerCpuUtilizationCapacity;\n+    private Double brokerInboundNetworkKiBPerSecondCapacity;\n+    private Double brokerOuboundNetworkKiBPerSecondCapacity;\n+\n+\n+    public static final String REST_API_PORT_NAME = \"rest-api\";\n+    public static final int REST_API_PORT = 9090;\n+    protected static final int DEFAULT_BOOTSTRAP_SERVERS_PORT = 9092;\n+    public static final String MIN_INSYNC_REPLICAS = \"min.insync.replicas\";\n+\n+\n+    // Cruise Control configuration keys (EnvVariables)\n+    protected static final String ENV_VAR_CRUISE_CONTROL_CONFIGURATION = \"CRUISE_CONTROL_CONFIGURATION\";\n+    protected static final String ENV_VAR_ZOOKEEPER_CONNECT = \"STRIMZI_ZOOKEEPER_CONNECT\";\n+    protected static final String ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS = \"STRIMZI_KAFKA_BOOTSTRAP_SERVERS\";\n+    protected static final String ENV_VAR_MIN_INSYNC_REPLICAS = \"MIN_INSYNC_REPLICAS\";\n+    protected static final String ENV_VAR_BROKER_DISK_MIB_CAPACITY = \"BROKER_DISK_MIB_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_CPU_UTILIZATION_CAPACITY = \"BROKER_CPU_UTILIZATION_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+\n+\n+    // Templates\n+    protected List<ContainerEnvVar> templateCruiseControlContainerEnvVars;\n+    protected List<ContainerEnvVar> templateTlsSidecarContainerEnvVars;\n+\n+    private boolean isDeployed;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param resource  Kubernetes/OpenShift resource with metadata containing the namespace and cluster name\n+     */\n+    protected CruiseControl(HasMetadata resource) {\n+        super(resource, APPLICATION_NAME);\n+        this.name = CruiseControlResources.deploymentName(cluster);\n+        this.serviceName = CruiseControlResources.serviceName(cluster);\n+        this.ancillaryConfigName = metricAndLogConfigsName(cluster);\n+        this.replicas = DEFAULT_REPLICAS;\n+        this.readinessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.readinessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.mountPath = \"/var/lib/kafka\";\n+        this.logAndMetricsConfigVolumeName = LOG_AND_METRICS_CONFIG_VOLUME_NAME;\n+        this.logAndMetricsConfigMountPath = LOG_AND_METRICS_CONFIG_VOLUME_MOUNT;\n+\n+        this.zookeeperConnect = defaultZookeeperConnect(cluster);\n+    }\n+\n+    public static String metricAndLogConfigsName(String cluster) {\n+        return CruiseControlResources.logAndMetricsConfigMapName(cluster);\n+    }\n+\n+    protected void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    protected static String defaultZookeeperConnect(String cluster) {\n+        return ZookeeperCluster.serviceName(cluster) + \":\" + EntityOperatorSpec.DEFAULT_ZOOKEEPER_PORT;\n+    }\n+\n+    protected static String defaultBootstrapServers(String cluster) {\n+        return KafkaCluster.serviceName(cluster) + \":\" + DEFAULT_BOOTSTRAP_SERVERS_PORT;\n+    }\n+\n+    public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup versions) {\n+        CruiseControl cruiseControl = null;\n+        CruiseControlSpec spec  = kafkaAssembly.getSpec().getCruiseControl();\n+\n+        if (spec != null) {\n+            cruiseControl = new CruiseControl(kafkaAssembly);\n+            cruiseControl.isDeployed = true;\n+\n+            cruiseControl.setReplicas(spec.getReplicas());\n+            String image = spec.getImage();\n+            if (image == null) {\n+                image = System.getenv().get(ClusterOperatorConfig.STRIMZI_DEFAULT_CRUISE_CONTROL_IMAGE);\n+            }\n+            cruiseControl.setImage(image);\n+\n+            TlsSidecar tlsSidecar = spec.getTlsSidecar();\n+            if (tlsSidecar == null) {\n+                tlsSidecar = new TlsSidecar();\n+            }\n+\n+            String tlsSideCarImage = tlsSidecar.getImage();\n+            if (tlsSideCarImage == null) {\n+                KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+                tlsSideCarImage = System.getenv().getOrDefault(ClusterOperatorConfig.STRIMZI_DEFAULT_TLS_SIDECAR_CRUISE_CONTROL_IMAGE, versions.kafkaImage(kafkaClusterSpec.getImage(), versions.defaultVersion().version()));\n+            }\n+\n+            tlsSidecar.setImage(tlsSideCarImage);\n+            cruiseControl.tlsSidecarImage = tlsSideCarImage;\n+            cruiseControl.setTlsSidecar(tlsSidecar);\n+\n+            cruiseControl = updateConfiguration(spec, cruiseControl);\n+\n+            KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+            KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+            if (configuration.getConfigOption(MIN_INSYNC_REPLICAS) != null) {\n+                cruiseControl.minInsyncReplicas = configuration.getConfigOption(MIN_INSYNC_REPLICAS);\n+            }\n+\n+            Capacity capacity = new Capacity(kafkaAssembly.getSpec());\n+            cruiseControl.brokerDiskMiBCapacity = capacity.getDiskMiB();\n+            cruiseControl.brokerCpuUtilizationCapacity = capacity.getCpuUtilization();\n+            cruiseControl.brokerInboundNetworkKiBPerSecondCapacity = capacity.getInboundNetworkKiBPerSecond();\n+            cruiseControl.brokerOuboundNetworkKiBPerSecondCapacity = capacity.getOutboundNetworkKiBPerSecond();\n+\n+            if (spec.getReadinessProbe() != null) {\n+                cruiseControl.setReadinessProbe(spec.getReadinessProbe());\n+            }\n+\n+            if (spec.getLivenessProbe() != null) {\n+                cruiseControl.setLivenessProbe(spec.getLivenessProbe());\n+            }\n+\n+            Logging logging = spec.getLogging();\n+            cruiseControl.setLogging(logging == null ? new InlineLogging() : logging);\n+\n+            cruiseControl.setGcLoggingEnabled(spec.getJvmOptions() == null ? DEFAULT_JVM_GC_LOGGING_ENABLED : spec.getJvmOptions().isGcLoggingEnabled());\n+            cruiseControl.setJvmOptions(spec.getJvmOptions());\n+\n+            cruiseControl.setUserAffinity(affinity(spec));\n+            cruiseControl.setResources(spec.getResources());\n+            cruiseControl.setTolerations(tolerations(spec));\n+            cruiseControl.setOwnerReference(kafkaAssembly);\n+            cruiseControl = updateTemplate(spec, cruiseControl);\n+        }\n+\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (configuration.getConfigOption(entry.getKey()) == null) {\n+                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        cruiseControl.setConfiguration(configuration);\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateTemplate(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        if (spec.getTemplate() != null) {\n+            CruiseControlTemplate template = spec.getTemplate();\n+\n+            ModelUtils.parsePodTemplate(cruiseControl, template.getPod());\n+\n+            if (template.getDeployment() != null && template.getDeployment().getMetadata() != null) {\n+                cruiseControl.templateDeploymentLabels = template.getDeployment().getMetadata().getLabels();\n+                cruiseControl.templateDeploymentAnnotations = template.getDeployment().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getApiService() != null && template.getApiService().getMetadata() != null) {\n+                cruiseControl.templateServiceLabels = template.getApiService().getMetadata().getLabels();\n+                cruiseControl.templateServiceAnnotations = template.getApiService().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getCruiseControlContainer() != null && template.getCruiseControlContainer().getEnv() != null) {\n+                cruiseControl.templateCruiseControlContainerEnvVars = template.getCruiseControlContainer().getEnv();\n+            }\n+\n+            if (template.getTlsSidecarContainer() != null && template.getTlsSidecarContainer().getEnv() != null) {\n+                cruiseControl.templateTlsSidecarContainerEnvVars = template.getTlsSidecarContainer().getEnv();\n+            }\n+\n+            ModelUtils.parsePodDisruptionBudgetTemplate(cruiseControl, template.getPodDisruptionBudget());\n+        }\n+        return cruiseControl;\n+    }\n+\n+    static List<Toleration> tolerations(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getTolerations() != null) {\n+            return spec.getTemplate().getPod().getTolerations();\n+        }\n+        return null;\n+    }\n+\n+    static Affinity affinity(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getAffinity() != null) {\n+            return spec.getTemplate().getPod().getAffinity();\n+        }\n+        return null;\n+    }\n+\n+    public static String cruiseControlName(String cluster) {\n+        return CruiseControlResources.deploymentName(cluster);\n+    }\n+\n+    public static String cruiseControlServiceName(String cluster) {\n+        return CruiseControlResources.serviceName(cluster);\n+    }\n+\n+    public Service generateService() {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        List<ServicePort> ports = new ArrayList<>(1);\n+        ports.add(createServicePort(REST_API_PORT_NAME, REST_API_PORT, REST_API_PORT, \"TCP\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyNTAwMg==", "bodyText": "If you insist on doing it like this then get the right number of items:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<Volume> volumeList = new ArrayList<>(1);\n          \n          \n            \n                    List<Volume> volumeList = new ArrayList<>(3);\n          \n      \n    \n    \n  \n\nBut even better would be to use\nreturn Arrays.asList(createSecretVolume(...),\n                     createSecretVolume(...),\n                     createConfigMapVolume(...));", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411225002", "createdAt": "2020-04-20T09:20:21Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,497 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC = \"cruise.control.metrics.topic\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC_VALUE = \"strimzi.cruisecontrol.metrics\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"/logging\";\n+\n+    private String zookeeperConnect;\n+\n+    // Configuration defaults\n+    protected static final int DEFAULT_REPLICAS = 1;\n+\n+    // Default probe settings (liveness and readiness) for health checks\n+    protected static final int DEFAULT_HEALTHCHECK_DELAY = 15;\n+    protected static final int DEFAULT_HEALTHCHECK_TIMEOUT = 5;\n+\n+    public static final Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder()\n+            .withInitialDelaySeconds(DEFAULT_HEALTHCHECK_DELAY)\n+            .withTimeoutSeconds(DEFAULT_HEALTHCHECK_TIMEOUT)\n+            .build();\n+\n+    private TlsSidecar tlsSidecar;\n+    private String tlsSidecarImage;\n+    private String minInsyncReplicas = \"1\";\n+    private Double brokerDiskMiBCapacity;\n+    private int brokerCpuUtilizationCapacity;\n+    private Double brokerInboundNetworkKiBPerSecondCapacity;\n+    private Double brokerOuboundNetworkKiBPerSecondCapacity;\n+\n+\n+    public static final String REST_API_PORT_NAME = \"rest-api\";\n+    public static final int REST_API_PORT = 9090;\n+    protected static final int DEFAULT_BOOTSTRAP_SERVERS_PORT = 9092;\n+    public static final String MIN_INSYNC_REPLICAS = \"min.insync.replicas\";\n+\n+\n+    // Cruise Control configuration keys (EnvVariables)\n+    protected static final String ENV_VAR_CRUISE_CONTROL_CONFIGURATION = \"CRUISE_CONTROL_CONFIGURATION\";\n+    protected static final String ENV_VAR_ZOOKEEPER_CONNECT = \"STRIMZI_ZOOKEEPER_CONNECT\";\n+    protected static final String ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS = \"STRIMZI_KAFKA_BOOTSTRAP_SERVERS\";\n+    protected static final String ENV_VAR_MIN_INSYNC_REPLICAS = \"MIN_INSYNC_REPLICAS\";\n+    protected static final String ENV_VAR_BROKER_DISK_MIB_CAPACITY = \"BROKER_DISK_MIB_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_CPU_UTILIZATION_CAPACITY = \"BROKER_CPU_UTILIZATION_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+\n+\n+    // Templates\n+    protected List<ContainerEnvVar> templateCruiseControlContainerEnvVars;\n+    protected List<ContainerEnvVar> templateTlsSidecarContainerEnvVars;\n+\n+    private boolean isDeployed;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param resource  Kubernetes/OpenShift resource with metadata containing the namespace and cluster name\n+     */\n+    protected CruiseControl(HasMetadata resource) {\n+        super(resource, APPLICATION_NAME);\n+        this.name = CruiseControlResources.deploymentName(cluster);\n+        this.serviceName = CruiseControlResources.serviceName(cluster);\n+        this.ancillaryConfigName = metricAndLogConfigsName(cluster);\n+        this.replicas = DEFAULT_REPLICAS;\n+        this.readinessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.readinessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.mountPath = \"/var/lib/kafka\";\n+        this.logAndMetricsConfigVolumeName = LOG_AND_METRICS_CONFIG_VOLUME_NAME;\n+        this.logAndMetricsConfigMountPath = LOG_AND_METRICS_CONFIG_VOLUME_MOUNT;\n+\n+        this.zookeeperConnect = defaultZookeeperConnect(cluster);\n+    }\n+\n+    public static String metricAndLogConfigsName(String cluster) {\n+        return CruiseControlResources.logAndMetricsConfigMapName(cluster);\n+    }\n+\n+    protected void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    protected static String defaultZookeeperConnect(String cluster) {\n+        return ZookeeperCluster.serviceName(cluster) + \":\" + EntityOperatorSpec.DEFAULT_ZOOKEEPER_PORT;\n+    }\n+\n+    protected static String defaultBootstrapServers(String cluster) {\n+        return KafkaCluster.serviceName(cluster) + \":\" + DEFAULT_BOOTSTRAP_SERVERS_PORT;\n+    }\n+\n+    public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup versions) {\n+        CruiseControl cruiseControl = null;\n+        CruiseControlSpec spec  = kafkaAssembly.getSpec().getCruiseControl();\n+\n+        if (spec != null) {\n+            cruiseControl = new CruiseControl(kafkaAssembly);\n+            cruiseControl.isDeployed = true;\n+\n+            cruiseControl.setReplicas(spec.getReplicas());\n+            String image = spec.getImage();\n+            if (image == null) {\n+                image = System.getenv().get(ClusterOperatorConfig.STRIMZI_DEFAULT_CRUISE_CONTROL_IMAGE);\n+            }\n+            cruiseControl.setImage(image);\n+\n+            TlsSidecar tlsSidecar = spec.getTlsSidecar();\n+            if (tlsSidecar == null) {\n+                tlsSidecar = new TlsSidecar();\n+            }\n+\n+            String tlsSideCarImage = tlsSidecar.getImage();\n+            if (tlsSideCarImage == null) {\n+                KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+                tlsSideCarImage = System.getenv().getOrDefault(ClusterOperatorConfig.STRIMZI_DEFAULT_TLS_SIDECAR_CRUISE_CONTROL_IMAGE, versions.kafkaImage(kafkaClusterSpec.getImage(), versions.defaultVersion().version()));\n+            }\n+\n+            tlsSidecar.setImage(tlsSideCarImage);\n+            cruiseControl.tlsSidecarImage = tlsSideCarImage;\n+            cruiseControl.setTlsSidecar(tlsSidecar);\n+\n+            cruiseControl = updateConfiguration(spec, cruiseControl);\n+\n+            KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+            KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+            if (configuration.getConfigOption(MIN_INSYNC_REPLICAS) != null) {\n+                cruiseControl.minInsyncReplicas = configuration.getConfigOption(MIN_INSYNC_REPLICAS);\n+            }\n+\n+            Capacity capacity = new Capacity(kafkaAssembly.getSpec());\n+            cruiseControl.brokerDiskMiBCapacity = capacity.getDiskMiB();\n+            cruiseControl.brokerCpuUtilizationCapacity = capacity.getCpuUtilization();\n+            cruiseControl.brokerInboundNetworkKiBPerSecondCapacity = capacity.getInboundNetworkKiBPerSecond();\n+            cruiseControl.brokerOuboundNetworkKiBPerSecondCapacity = capacity.getOutboundNetworkKiBPerSecond();\n+\n+            if (spec.getReadinessProbe() != null) {\n+                cruiseControl.setReadinessProbe(spec.getReadinessProbe());\n+            }\n+\n+            if (spec.getLivenessProbe() != null) {\n+                cruiseControl.setLivenessProbe(spec.getLivenessProbe());\n+            }\n+\n+            Logging logging = spec.getLogging();\n+            cruiseControl.setLogging(logging == null ? new InlineLogging() : logging);\n+\n+            cruiseControl.setGcLoggingEnabled(spec.getJvmOptions() == null ? DEFAULT_JVM_GC_LOGGING_ENABLED : spec.getJvmOptions().isGcLoggingEnabled());\n+            cruiseControl.setJvmOptions(spec.getJvmOptions());\n+\n+            cruiseControl.setUserAffinity(affinity(spec));\n+            cruiseControl.setResources(spec.getResources());\n+            cruiseControl.setTolerations(tolerations(spec));\n+            cruiseControl.setOwnerReference(kafkaAssembly);\n+            cruiseControl = updateTemplate(spec, cruiseControl);\n+        }\n+\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (configuration.getConfigOption(entry.getKey()) == null) {\n+                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        cruiseControl.setConfiguration(configuration);\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateTemplate(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        if (spec.getTemplate() != null) {\n+            CruiseControlTemplate template = spec.getTemplate();\n+\n+            ModelUtils.parsePodTemplate(cruiseControl, template.getPod());\n+\n+            if (template.getDeployment() != null && template.getDeployment().getMetadata() != null) {\n+                cruiseControl.templateDeploymentLabels = template.getDeployment().getMetadata().getLabels();\n+                cruiseControl.templateDeploymentAnnotations = template.getDeployment().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getApiService() != null && template.getApiService().getMetadata() != null) {\n+                cruiseControl.templateServiceLabels = template.getApiService().getMetadata().getLabels();\n+                cruiseControl.templateServiceAnnotations = template.getApiService().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getCruiseControlContainer() != null && template.getCruiseControlContainer().getEnv() != null) {\n+                cruiseControl.templateCruiseControlContainerEnvVars = template.getCruiseControlContainer().getEnv();\n+            }\n+\n+            if (template.getTlsSidecarContainer() != null && template.getTlsSidecarContainer().getEnv() != null) {\n+                cruiseControl.templateTlsSidecarContainerEnvVars = template.getTlsSidecarContainer().getEnv();\n+            }\n+\n+            ModelUtils.parsePodDisruptionBudgetTemplate(cruiseControl, template.getPodDisruptionBudget());\n+        }\n+        return cruiseControl;\n+    }\n+\n+    static List<Toleration> tolerations(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getTolerations() != null) {\n+            return spec.getTemplate().getPod().getTolerations();\n+        }\n+        return null;\n+    }\n+\n+    static Affinity affinity(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getAffinity() != null) {\n+            return spec.getTemplate().getPod().getAffinity();\n+        }\n+        return null;\n+    }\n+\n+    public static String cruiseControlName(String cluster) {\n+        return CruiseControlResources.deploymentName(cluster);\n+    }\n+\n+    public static String cruiseControlServiceName(String cluster) {\n+        return CruiseControlResources.serviceName(cluster);\n+    }\n+\n+    public Service generateService() {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        List<ServicePort> ports = new ArrayList<>(1);\n+        ports.add(createServicePort(REST_API_PORT_NAME, REST_API_PORT, REST_API_PORT, \"TCP\"));\n+\n+        return createService(\"ClusterIP\", ports, templateServiceAnnotations);\n+    }\n+\n+    protected List<ContainerPort> getContainerPortList() {\n+        List<ContainerPort> portList = new ArrayList<>(1);\n+\n+        portList.add(createContainerPort(REST_API_PORT_NAME, REST_API_PORT, \"TCP\"));\n+\n+        if (isMetricsEnabled) {\n+            portList.add(createContainerPort(METRICS_PORT_NAME, METRICS_PORT, \"TCP\"));\n+        }\n+\n+        return portList;\n+    }\n+\n+    protected List<Volume> getVolumes(boolean isOpenShift) {\n+        List<Volume> volumeList = new ArrayList<>(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f"}, "originalPosition": 312}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyNTEzMw==", "bodyText": "Same comment.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411225133", "createdAt": "2020-04-20T09:20:31Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,497 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC = \"cruise.control.metrics.topic\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC_VALUE = \"strimzi.cruisecontrol.metrics\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"/logging\";\n+\n+    private String zookeeperConnect;\n+\n+    // Configuration defaults\n+    protected static final int DEFAULT_REPLICAS = 1;\n+\n+    // Default probe settings (liveness and readiness) for health checks\n+    protected static final int DEFAULT_HEALTHCHECK_DELAY = 15;\n+    protected static final int DEFAULT_HEALTHCHECK_TIMEOUT = 5;\n+\n+    public static final Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder()\n+            .withInitialDelaySeconds(DEFAULT_HEALTHCHECK_DELAY)\n+            .withTimeoutSeconds(DEFAULT_HEALTHCHECK_TIMEOUT)\n+            .build();\n+\n+    private TlsSidecar tlsSidecar;\n+    private String tlsSidecarImage;\n+    private String minInsyncReplicas = \"1\";\n+    private Double brokerDiskMiBCapacity;\n+    private int brokerCpuUtilizationCapacity;\n+    private Double brokerInboundNetworkKiBPerSecondCapacity;\n+    private Double brokerOuboundNetworkKiBPerSecondCapacity;\n+\n+\n+    public static final String REST_API_PORT_NAME = \"rest-api\";\n+    public static final int REST_API_PORT = 9090;\n+    protected static final int DEFAULT_BOOTSTRAP_SERVERS_PORT = 9092;\n+    public static final String MIN_INSYNC_REPLICAS = \"min.insync.replicas\";\n+\n+\n+    // Cruise Control configuration keys (EnvVariables)\n+    protected static final String ENV_VAR_CRUISE_CONTROL_CONFIGURATION = \"CRUISE_CONTROL_CONFIGURATION\";\n+    protected static final String ENV_VAR_ZOOKEEPER_CONNECT = \"STRIMZI_ZOOKEEPER_CONNECT\";\n+    protected static final String ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS = \"STRIMZI_KAFKA_BOOTSTRAP_SERVERS\";\n+    protected static final String ENV_VAR_MIN_INSYNC_REPLICAS = \"MIN_INSYNC_REPLICAS\";\n+    protected static final String ENV_VAR_BROKER_DISK_MIB_CAPACITY = \"BROKER_DISK_MIB_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_CPU_UTILIZATION_CAPACITY = \"BROKER_CPU_UTILIZATION_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+\n+\n+    // Templates\n+    protected List<ContainerEnvVar> templateCruiseControlContainerEnvVars;\n+    protected List<ContainerEnvVar> templateTlsSidecarContainerEnvVars;\n+\n+    private boolean isDeployed;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param resource  Kubernetes/OpenShift resource with metadata containing the namespace and cluster name\n+     */\n+    protected CruiseControl(HasMetadata resource) {\n+        super(resource, APPLICATION_NAME);\n+        this.name = CruiseControlResources.deploymentName(cluster);\n+        this.serviceName = CruiseControlResources.serviceName(cluster);\n+        this.ancillaryConfigName = metricAndLogConfigsName(cluster);\n+        this.replicas = DEFAULT_REPLICAS;\n+        this.readinessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.readinessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.mountPath = \"/var/lib/kafka\";\n+        this.logAndMetricsConfigVolumeName = LOG_AND_METRICS_CONFIG_VOLUME_NAME;\n+        this.logAndMetricsConfigMountPath = LOG_AND_METRICS_CONFIG_VOLUME_MOUNT;\n+\n+        this.zookeeperConnect = defaultZookeeperConnect(cluster);\n+    }\n+\n+    public static String metricAndLogConfigsName(String cluster) {\n+        return CruiseControlResources.logAndMetricsConfigMapName(cluster);\n+    }\n+\n+    protected void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    protected static String defaultZookeeperConnect(String cluster) {\n+        return ZookeeperCluster.serviceName(cluster) + \":\" + EntityOperatorSpec.DEFAULT_ZOOKEEPER_PORT;\n+    }\n+\n+    protected static String defaultBootstrapServers(String cluster) {\n+        return KafkaCluster.serviceName(cluster) + \":\" + DEFAULT_BOOTSTRAP_SERVERS_PORT;\n+    }\n+\n+    public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup versions) {\n+        CruiseControl cruiseControl = null;\n+        CruiseControlSpec spec  = kafkaAssembly.getSpec().getCruiseControl();\n+\n+        if (spec != null) {\n+            cruiseControl = new CruiseControl(kafkaAssembly);\n+            cruiseControl.isDeployed = true;\n+\n+            cruiseControl.setReplicas(spec.getReplicas());\n+            String image = spec.getImage();\n+            if (image == null) {\n+                image = System.getenv().get(ClusterOperatorConfig.STRIMZI_DEFAULT_CRUISE_CONTROL_IMAGE);\n+            }\n+            cruiseControl.setImage(image);\n+\n+            TlsSidecar tlsSidecar = spec.getTlsSidecar();\n+            if (tlsSidecar == null) {\n+                tlsSidecar = new TlsSidecar();\n+            }\n+\n+            String tlsSideCarImage = tlsSidecar.getImage();\n+            if (tlsSideCarImage == null) {\n+                KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+                tlsSideCarImage = System.getenv().getOrDefault(ClusterOperatorConfig.STRIMZI_DEFAULT_TLS_SIDECAR_CRUISE_CONTROL_IMAGE, versions.kafkaImage(kafkaClusterSpec.getImage(), versions.defaultVersion().version()));\n+            }\n+\n+            tlsSidecar.setImage(tlsSideCarImage);\n+            cruiseControl.tlsSidecarImage = tlsSideCarImage;\n+            cruiseControl.setTlsSidecar(tlsSidecar);\n+\n+            cruiseControl = updateConfiguration(spec, cruiseControl);\n+\n+            KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+            KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+            if (configuration.getConfigOption(MIN_INSYNC_REPLICAS) != null) {\n+                cruiseControl.minInsyncReplicas = configuration.getConfigOption(MIN_INSYNC_REPLICAS);\n+            }\n+\n+            Capacity capacity = new Capacity(kafkaAssembly.getSpec());\n+            cruiseControl.brokerDiskMiBCapacity = capacity.getDiskMiB();\n+            cruiseControl.brokerCpuUtilizationCapacity = capacity.getCpuUtilization();\n+            cruiseControl.brokerInboundNetworkKiBPerSecondCapacity = capacity.getInboundNetworkKiBPerSecond();\n+            cruiseControl.brokerOuboundNetworkKiBPerSecondCapacity = capacity.getOutboundNetworkKiBPerSecond();\n+\n+            if (spec.getReadinessProbe() != null) {\n+                cruiseControl.setReadinessProbe(spec.getReadinessProbe());\n+            }\n+\n+            if (spec.getLivenessProbe() != null) {\n+                cruiseControl.setLivenessProbe(spec.getLivenessProbe());\n+            }\n+\n+            Logging logging = spec.getLogging();\n+            cruiseControl.setLogging(logging == null ? new InlineLogging() : logging);\n+\n+            cruiseControl.setGcLoggingEnabled(spec.getJvmOptions() == null ? DEFAULT_JVM_GC_LOGGING_ENABLED : spec.getJvmOptions().isGcLoggingEnabled());\n+            cruiseControl.setJvmOptions(spec.getJvmOptions());\n+\n+            cruiseControl.setUserAffinity(affinity(spec));\n+            cruiseControl.setResources(spec.getResources());\n+            cruiseControl.setTolerations(tolerations(spec));\n+            cruiseControl.setOwnerReference(kafkaAssembly);\n+            cruiseControl = updateTemplate(spec, cruiseControl);\n+        }\n+\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (configuration.getConfigOption(entry.getKey()) == null) {\n+                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        cruiseControl.setConfiguration(configuration);\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateTemplate(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        if (spec.getTemplate() != null) {\n+            CruiseControlTemplate template = spec.getTemplate();\n+\n+            ModelUtils.parsePodTemplate(cruiseControl, template.getPod());\n+\n+            if (template.getDeployment() != null && template.getDeployment().getMetadata() != null) {\n+                cruiseControl.templateDeploymentLabels = template.getDeployment().getMetadata().getLabels();\n+                cruiseControl.templateDeploymentAnnotations = template.getDeployment().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getApiService() != null && template.getApiService().getMetadata() != null) {\n+                cruiseControl.templateServiceLabels = template.getApiService().getMetadata().getLabels();\n+                cruiseControl.templateServiceAnnotations = template.getApiService().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getCruiseControlContainer() != null && template.getCruiseControlContainer().getEnv() != null) {\n+                cruiseControl.templateCruiseControlContainerEnvVars = template.getCruiseControlContainer().getEnv();\n+            }\n+\n+            if (template.getTlsSidecarContainer() != null && template.getTlsSidecarContainer().getEnv() != null) {\n+                cruiseControl.templateTlsSidecarContainerEnvVars = template.getTlsSidecarContainer().getEnv();\n+            }\n+\n+            ModelUtils.parsePodDisruptionBudgetTemplate(cruiseControl, template.getPodDisruptionBudget());\n+        }\n+        return cruiseControl;\n+    }\n+\n+    static List<Toleration> tolerations(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getTolerations() != null) {\n+            return spec.getTemplate().getPod().getTolerations();\n+        }\n+        return null;\n+    }\n+\n+    static Affinity affinity(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getAffinity() != null) {\n+            return spec.getTemplate().getPod().getAffinity();\n+        }\n+        return null;\n+    }\n+\n+    public static String cruiseControlName(String cluster) {\n+        return CruiseControlResources.deploymentName(cluster);\n+    }\n+\n+    public static String cruiseControlServiceName(String cluster) {\n+        return CruiseControlResources.serviceName(cluster);\n+    }\n+\n+    public Service generateService() {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        List<ServicePort> ports = new ArrayList<>(1);\n+        ports.add(createServicePort(REST_API_PORT_NAME, REST_API_PORT, REST_API_PORT, \"TCP\"));\n+\n+        return createService(\"ClusterIP\", ports, templateServiceAnnotations);\n+    }\n+\n+    protected List<ContainerPort> getContainerPortList() {\n+        List<ContainerPort> portList = new ArrayList<>(1);\n+\n+        portList.add(createContainerPort(REST_API_PORT_NAME, REST_API_PORT, \"TCP\"));\n+\n+        if (isMetricsEnabled) {\n+            portList.add(createContainerPort(METRICS_PORT_NAME, METRICS_PORT, \"TCP\"));\n+        }\n+\n+        return portList;\n+    }\n+\n+    protected List<Volume> getVolumes(boolean isOpenShift) {\n+        List<Volume> volumeList = new ArrayList<>(1);\n+        volumeList.add(createSecretVolume(TLS_SIDECAR_CC_CERTS_VOLUME_NAME, CruiseControl.secretName(cluster), isOpenShift));\n+        volumeList.add(createSecretVolume(TLS_SIDECAR_CA_CERTS_VOLUME_NAME, AbstractModel.clusterCaCertSecretName(cluster), isOpenShift));\n+        volumeList.add(createConfigMapVolume(logAndMetricsConfigVolumeName, ancillaryConfigName));\n+\n+        return volumeList;\n+    }\n+\n+    protected List<VolumeMount> getVolumeMounts() {\n+        List<VolumeMount> volumeMountList = new ArrayList<>(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f"}, "originalPosition": 321}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyODA1NQ==", "bodyText": "Using \", *\" (split takes a regex) would protect you a little from people being careless with whitespace when making changes in the future.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411228055", "createdAt": "2020-04-20T09:24:51Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControlConfiguration.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+\n+/**\n+ * Class for handling Cruise Control configuration passed by the user\n+ */\n+public class CruiseControlConfiguration extends AbstractConfiguration {\n+\n+    /**\n+     * A list of case insensitive goals that Cruise Control supports in the order of priority.\n+     * The high priority goals will be executed first.\n+     */\n+    private static final String DEFAULT_GOALS = \"com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.PotentialNwOutGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.TopicReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderBytesInDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.PreferredLeaderElectionGoal\";\n+\n+   /*\n+    * Map containing default values for required configuration properties\n+    */\n+    private static final Map<String, String> CC_DEFAULT_PROPERTIES_MAP;\n+\n+    private static final List<String> FORBIDDEN_OPTIONS;\n+    private static final List<String> EXCEPTIONS;\n+\n+    static {\n+        CC_DEFAULT_PROPERTIES_MAP = new HashMap<>();\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"partition.metrics.window.ms\", Integer.toString(300_000));\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"num.partition.metrics.windows\", \"1\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"broker.metrics.window.ms\", Integer.toString(300_000));\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"num.broker.metrics.windows\", \"20\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"completed.user.task.retention.time.ms\", Long.toString(TimeUnit.DAYS.toMillis(1)));\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"default.goals\", DEFAULT_GOALS);\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"goals\", DEFAULT_GOALS);\n+\n+        FORBIDDEN_OPTIONS = asList(CruiseControlSpec.FORBIDDEN_PREFIXES.split(\", \"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyOTkyMA==", "bodyText": "Collections.singletonMap()", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411229920", "createdAt": "2020-04-20T09:27:36Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3068,6 +3083,86 @@ private boolean isPodUpToDate(StatefulSet sts, Pod pod) {\n             return stsGeneration == podGeneration;\n         }\n \n+        private final Future<ReconciliationState> getCruiseControlDescription() {\n+            CruiseControl cruiseControl = CruiseControl.fromCrd(kafkaAssembly, versions);\n+            if (cruiseControl != null) {\n+                ConfigMap logAndMetricsConfigMap = cruiseControl.generateMetricsAndLogConfigMap(\n+                        cruiseControl.getLogging() instanceof ExternalLogging ?\n+                                configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) cruiseControl.getLogging()).getName()) :\n+                                null);\n+                Map<String, String> annotations = new HashMap<>();\n+                annotations.put(CruiseControl.ANNO_STRIMZI_IO_LOGGING, logAndMetricsConfigMap.getData().get(ANCILLARY_CM_KEY_LOG_CONFIG));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTcxMzEz", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#pullrequestreview-396571313", "createdAt": "2020-04-20T15:36:35Z", "commit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f", "committedDate": "2020-04-15T15:33:37Z", "message": "Fix logging and typos\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}, "afterCommit": {"oid": "0f5eb115c5dcef25a514a32c69408f00772a994f", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/0f5eb115c5dcef25a514a32c69408f00772a994f", "committedDate": "2020-04-20T19:32:48Z", "message": "Addressing comments ( Update allowed disk capacity notation + refactoring)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MDE1MDUw", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#pullrequestreview-397015050", "createdAt": "2020-04-21T06:15:12Z", "commit": {"oid": "0f5eb115c5dcef25a514a32c69408f00772a994f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNjoxNToxM1rOGI0Ttw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNjoxOTowMlrOGI0atA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg5ODgwNw==", "bodyText": "we are in the KafkaClusterSpec, why this is about Cruise Control container resources?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411898807", "createdAt": "2020-04-21T06:15:13Z", "author": {"login": "ppatierno"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaClusterSpec.java", "diffHunk": "@@ -172,7 +174,7 @@ public void setImage(String image) {\n     }\n \n     @JsonInclude(JsonInclude.Include.NON_NULL)\n-    @Description(\"CPU and memory resources to reserve.\")\n+    @Description(\"CPU and memory resources to reserve for the Cruise Control container.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f5eb115c5dcef25a514a32c69408f00772a994f"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwMDU5Ng==", "bodyText": "Have you rebased against the latest master? Just asking because lately the Annotations.STRIMZI_DOMAIN was changed from strimzi.io to strimzi.io/. In this case, we are going to have strimzi.io//logging so you should remove the / from logging. I had the same problem with one of my latest PR :-)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411900596", "createdAt": "2020-04-21T06:19:02Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,486 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC = \"cruise.control.metrics.topic\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC_VALUE = \"strimzi.cruisecontrol.metrics\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"/logging\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f5eb115c5dcef25a514a32c69408f00772a994f"}, "originalPosition": 69}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0f5eb115c5dcef25a514a32c69408f00772a994f", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/0f5eb115c5dcef25a514a32c69408f00772a994f", "committedDate": "2020-04-20T19:32:48Z", "message": "Addressing comments ( Update allowed disk capacity notation + refactoring)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}, "afterCommit": {"oid": "d52a0be51c0ddfdcbee52a97b2b8de615a0c7b2e", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/d52a0be51c0ddfdcbee52a97b2b8de615a0c7b2e", "committedDate": "2020-04-21T13:12:15Z", "message": "Fixing more typos\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d52a0be51c0ddfdcbee52a97b2b8de615a0c7b2e", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/d52a0be51c0ddfdcbee52a97b2b8de615a0c7b2e", "committedDate": "2020-04-21T13:12:15Z", "message": "Fixing more typos\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}, "afterCommit": {"oid": "e9ac04bbe1ce2aa1fca6c9674d5d8125c0be340d", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e9ac04bbe1ce2aa1fca6c9674d5d8125c0be340d", "committedDate": "2020-04-21T13:40:38Z", "message": "Fixing more typos\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NDE1MjAw", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#pullrequestreview-397415200", "createdAt": "2020-04-21T14:56:15Z", "commit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NDIxNTQ2", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#pullrequestreview-397421546", "createdAt": "2020-04-21T15:02:24Z", "commit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NjEzMDM4", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#pullrequestreview-397613038", "createdAt": "2020-04-21T19:33:06Z", "commit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NjI0OTQ4", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#pullrequestreview-397624948", "createdAt": "2020-04-21T19:51:03Z", "commit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOTo1MTowM1rOGJVtKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDowODoyM1rOGJWXbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0NTk5Mw==", "bodyText": "Do we really need this? In other places we have 1 replica hardcoded.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r412445993", "createdAt": "2020-04-21T19:51:03Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, client.id, zookeeper., network., security., failed.brokers.zk.path,\"\n+        + \"webserver.http., webserver.api.urlprefix, webserver.session.path, webserver.accesslog., two.step., request.reason.required,\"\n+        + \"metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, partition.metric.sample.store.topic, broker.metric.sample.store.topic,\"\n+        + \"capacity.config.file, self.healing.\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1MzI1MQ==", "bodyText": "Why is this not just added to the third-party-libs for given version? You might anyway need to change it later once you need different versions for different broker.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r412453251", "createdAt": "2020-04-21T20:02:37Z", "author": {"login": "scholzj"}, "path": "docker-images/kafka/Dockerfile", "diffHunk": "@@ -49,6 +56,10 @@ COPY ./tmp/tracing-agent.jar ${KAFKA_HOME}/libs/\n #####\n COPY kafka-thirdparty-libs/${THIRD_PARTY_LIBS}/target/dependency/ ${KAFKA_HOME}/libs/\n \n+RUN  mkdir -p ${CRUISE_CONTROL_HOME}/libs/\n+COPY kafka-thirdparty-libs/cc/target/dependency/ ${CRUISE_CONTROL_HOME}/libs/\n+COPY kafka-thirdparty-libs/cc/target/dependency/cruise-control-metrics-reporter-*.jar ${KAFKA_HOME}/libs/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1Mzc0OA==", "bodyText": "Thsi section is called Add Cruise Control But it seems Cruise Control is actually added on line 60. Any reason why not move it here? Or we should at least rename this.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r412453748", "createdAt": "2020-04-21T20:03:25Z", "author": {"login": "scholzj"}, "path": "docker-images/kafka/Dockerfile", "diffHunk": "@@ -37,6 +37,13 @@ RUN curl -LO https://github.com/danielqsj/kafka_exporter/releases/download/v${KA\n \n COPY ./exporter-scripts $KAFKA_EXPORTER_HOME\n \n+#####\n+# Add Cruise Control\n+#####\n+ENV CRUISE_CONTROL_HOME=/opt/cruise-control\n+RUN mkdir $CRUISE_CONTROL_HOME\n+COPY ./cruise-control-scripts $CRUISE_CONTROL_HOME", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1NTA4MQ==", "bodyText": "Should these be deleted? Or at least comment out everything and keep the file so that the title and the TBD doesn't render?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r412455081", "createdAt": "2020-04-21T20:05:44Z", "author": {"login": "scholzj"}, "path": "documentation/modules/cruise-control/proc-executing-cruise-control-rebalance-operations.adoc", "diffHunk": "@@ -0,0 +1,9 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-executing-cruise-control-rebalance-operations-{context}']\n+= Executing a cluster rebalance\n+\n+TBD", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1NTE0OQ==", "bodyText": "Same as abive", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r412455149", "createdAt": "2020-04-21T20:05:51Z", "author": {"login": "scholzj"}, "path": "documentation/modules/cruise-control/proc-interacting-with-cruise-control-api.adoc", "diffHunk": "@@ -0,0 +1,9 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-interacting-with-cruise-control-api-{context}']\n+= Interacting with the Cruise Control API\n+\n+TBD", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1NTkyNw==", "bodyText": "So out of curiosity ... when will it do when it is deployed like this withotu any other configuration?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r412455927", "createdAt": "2020-04-21T20:06:56Z", "author": {"login": "scholzj"}, "path": "examples/kafka/kafka-cruise-control.yaml", "diffHunk": "@@ -0,0 +1,27 @@\n+apiVersion: kafka.strimzi.io/v1beta1\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  kafka:\n+    version: 2.4.0\n+    replicas: 3\n+    listeners:\n+      plain: {}\n+      tls: {}\n+    config:\n+      offsets.topic.replication.factor: 3\n+      transaction.state.log.replication.factor: 3\n+      transaction.state.log.min.isr: 2\n+      log.message.format.version: \"2.4\"\n+    storage:\n+      type: ephemeral\n+  zookeeper:\n+    replicas: 3\n+    storage:\n+      type: ephemeral\n+  entityOperator:\n+    topicOperator: {}\n+    userOperator: {}\n+  cruiseControl:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1NjgxNA==", "bodyText": "I do not see any updated to the Helm Chart REAMDE.md file. Can you update it as well please?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r412456814", "createdAt": "2020-04-21T20:08:23Z", "author": {"login": "scholzj"}, "path": "helm-charts/strimzi-kafka-operator/values.yaml", "diffHunk": "@@ -97,6 +97,16 @@ kafkaMirrorMaker2:\n     repository: strimzi\n     name: kafka\n     tagPrefix: latest\n+cruiseControl:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4MDU3ODQx", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#pullrequestreview-398057841", "createdAt": "2020-04-22T10:32:43Z", "commit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDozMjo0M1rOGJvXLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDozMjo0M1rOGJvXLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2NjM0OA==", "bodyText": "@kyguy - Does it make sense to include a goals configuration here too?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r412866348", "createdAt": "2020-04-22T10:32:43Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,106 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Cruise Control is configured using the `cruiseControl` property in the `Kafka` resource.\n+Once configured, you can deploy a Cruise Control instance to your {ProductName} cluster by creating or updating the `Kafka` resource.\n+\n+For an overview of the `Kafka` resource, see the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration].\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+Deploy one instance of Cruise Control per Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000KB/s\n+      networkOut: 10000KB/s\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4MDYwNTE5", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#pullrequestreview-398060519", "createdAt": "2020-04-22T10:36:38Z", "commit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDozNjozOFrOGJvgcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDozNjozOFrOGJvgcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2ODcyMQ==", "bodyText": "@kyguy - Please comment this out because the target procedure is not ready. Also, I think the best next step is to generate optimization proposals and use them to rebalance the cluster.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r412868721", "createdAt": "2020-04-22T10:36:38Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,106 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Cruise Control is configured using the `cruiseControl` property in the `Kafka` resource.\n+Once configured, you can deploy a Cruise Control instance to your {ProductName} cluster by creating or updating the `Kafka` resource.\n+\n+For an overview of the `Kafka` resource, see the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration].\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+Deploy one instance of Cruise Control per Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000KB/s\n+      networkOut: 10000KB/s\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...\n+    resources: <4>\n+      requests:\n+        cpu: 200m\n+        memory: 64Mi\n+      limits:\n+        cpu: 500m\n+        memory: 128Mi\n+    logging: <5>\n+        type: inline\n+        loggers:\n+          cruisecontrol.root.logger: \"INFO\"\n+    template: <6>\n+      pod:\n+        metadata:\n+          labels:\n+            label1: value1\n+        securityContext:\n+          runAsUser: 1000001\n+          fsGroup: 0\n+        terminationGracePeriodSeconds: 120\n+    readinessProbe: <7>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+    livenessProbe: <8>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+# ...\n+----\n+<1> Number of Cruise Control instances to create. Set to `1` to run the application or `0` to pause it.\n+<2> Specifies capacity limits for broker resources. For more information, see xref:capacity_configuration[Capacity configuration].\n+<3> Defines the Cruise Control configuration, including default and enabled optimization goals. You can provide any xref:ref-cruise-control-configuration-{context}[standard configuration option] apart from those managed directly by {ProductName}.\n+<4> CPU and memory resources reserved for Cruise Control. For more information, see xref:assembly-resource-limits-and-requests-deployment-configuration-kafka[].\n+<5> Defined loggers and log levels added directly (inline) or indirectly (external) through a ConfigMap. A custom ConfigMap must be placed under the log4j.properties key. Cruise Control has a single logger called cruisecontrol.root.logger. You can set the log level to INFO, ERROR, WARN, TRACE, DEBUG, FATAL or OFF. For more information, see xref:logging_configuration[Logging configuration].\n+<6> xref:assembly-customizing-deployments-str[Customization of deployment templates and pods].\n+<7> xref:assembly-healthchecks-deployment-configuration-kafka[Healthcheck readiness probes].\n+<8> xref:assembly-healthchecks-deployment-configuration-kafka[Healthcheck liveness probes].\n+\n+. Create or update the resource:\n++\n+[source,shell,subs=\"+quotes\"]\n+----\n+kubectl apply -f _kafka.yaml_\n+----\n+\n+. Verify that Cruise Control was successfully deployed:\n++\n+[source,shell,subs=\"+quotes\"]\n+----\n+kubectl get deployments -l app.kubernetes.io/name=strimzi\n+----\n+\n+.What to do next\n+\n+After configuring and deploying Cruise Control, you can xref:proc-interacting-with-cruise-control-api-{context}[interact with the Cruise Control API]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 102}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4d4038683745e449abf117c11664d4be77c01d2f", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/4d4038683745e449abf117c11664d4be77c01d2f", "committedDate": "2020-04-22T15:52:04Z", "message": "Securing communication between Cruise Control and Kafka (#37)\n\n* Adding TLS communication between CC and Kafka\r\n\r\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>\r\n\r\n* Adding TLS communication between metric reporter and Kafka\r\n\r\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>\r\n\r\n* Fixed metrics report to use TLS hostname verification (#38)\r\n\r\nMoved metrics topic to Cruise Control configuration\r\nHiding truststore and keystore passwords in the log\r\n\r\nSigned-off-by: Paolo Patierno <ppatierno@live.com>\r\n\r\nCo-authored-by: Paolo Patierno <ppatierno@live.com>"}, "afterCommit": {"oid": "b57762a5d170de91a8530da7d0e67226e950cb5c", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b57762a5d170de91a8530da7d0e67226e950cb5c", "committedDate": "2020-04-22T16:04:53Z", "message": "Securing communication between Cruise Control and Kafka (#37)\n\n* Adding TLS communication between CC and Kafka\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>\n\n* Adding TLS communication between metric reporter and Kafka\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>\n\n* Fixed metrics report to use TLS hostname verification (#38)\n\nMoved metrics topic to Cruise Control configuration\nHiding truststore and keystore passwords in the log\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>\n\nCo-authored-by: Paolo Patierno <ppatierno@live.com>\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "940f6c8b1ca412cd4d155884939b8763aae79ac9", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/940f6c8b1ca412cd4d155884939b8763aae79ac9", "committedDate": "2020-04-22T23:16:02Z", "message": "Cruise Control Deployment\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4efd009aebf5d658591becab0ea89ec6ae59bc5", "author": {"user": {"login": "tomncooper", "name": "Thomas Cooper"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/f4efd009aebf5d658591becab0ea89ec6ae59bc5", "committedDate": "2020-04-22T23:16:02Z", "message": "Added Cruise Control System Tests\n\n    - Added deployment with CC to Kafka ST resources\n    - Added pod name and deployment resources\n    - Added CC deployment system test\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fecbc816331655000a74ac893b68ea0c48e7af1", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/3fecbc816331655000a74ac893b68ea0c48e7af1", "committedDate": "2020-04-22T23:16:02Z", "message": "Add broker capacity estimation and configuration\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7653b1c5589df4aa8c930830884ef92e1b454c0", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/d7653b1c5589df4aa8c930830884ef92e1b454c0", "committedDate": "2020-04-22T23:16:02Z", "message": "Add k8s memory parsing to return different byte multiples\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7717398ad611857fa020bf4edb277fb87b778c80", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/7717398ad611857fa020bf4edb277fb87b778c80", "committedDate": "2020-04-22T23:16:02Z", "message": "Refactor Capacity constructor\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "488cc11f08cf3d80490ff302c6f9b039586ac7d9", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/488cc11f08cf3d80490ff302c6f9b039586ac7d9", "committedDate": "2020-04-22T23:16:02Z", "message": "Regenerate helm charts\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5cb50f4a8af4a58557c07fdec04607196272a31", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/a5cb50f4a8af4a58557c07fdec04607196272a31", "committedDate": "2020-04-22T23:16:02Z", "message": "Addressing some comments\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f9c7e9ce1983902f3c8140d6093d96dd264a693", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/0f9c7e9ce1983902f3c8140d6093d96dd264a693", "committedDate": "2020-04-22T23:16:02Z", "message": "Addressing more comments\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9cb6dac2bbbed14e1c337190a7b310c5e30b9f0", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/d9cb6dac2bbbed14e1c337190a7b310c5e30b9f0", "committedDate": "2020-04-22T23:16:02Z", "message": "Addressing more comments (refactoring capacity API, checkOwnerReferences)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89390d11b360ef9d1dd80ad375b10f6d9376f87e", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/89390d11b360ef9d1dd80ad375b10f6d9376f87e", "committedDate": "2020-04-22T23:16:02Z", "message": "Addressing comments ( capacity properties as strings/validate units in schema)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a90c655eb8038501b5af7388521324205e5b3e2", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/3a90c655eb8038501b5af7388521324205e5b3e2", "committedDate": "2020-04-22T23:16:02Z", "message": "Tightening capacity regex; fixing docs\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42ee71630840d04d3e085f67a6a98914578cd02f", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/42ee71630840d04d3e085f67a6a98914578cd02f", "committedDate": "2020-04-22T23:16:02Z", "message": "Another doc fix\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "955b9a06cce53f391075e820f7faa207332228cf", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/955b9a06cce53f391075e820f7faa207332228cf", "committedDate": "2020-04-22T23:16:02Z", "message": "Add missing goal; bump CC version to 2.0.100\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3dde8bfdc579a0169b7418420d1dae7d96f18c33", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/3dde8bfdc579a0169b7418420d1dae7d96f18c33", "committedDate": "2020-04-22T23:16:02Z", "message": "Fix logging and typos\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0150bfb19a5f7137eae218f7434008223605533", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c0150bfb19a5f7137eae218f7434008223605533", "committedDate": "2020-04-22T23:16:02Z", "message": "Addressing comments ( Update allowed disk capacity notation + refactoring)\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "857ccbd6bf4434919cd885811637fd2b1e131699", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/857ccbd6bf4434919cd885811637fd2b1e131699", "committedDate": "2020-04-22T23:16:02Z", "message": "Fixing more typos\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "309aeecac5f45a53b83318eb5d14d7317077dafe", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/309aeecac5f45a53b83318eb5d14d7317077dafe", "committedDate": "2020-04-22T23:16:02Z", "message": "Fixing another doc issue\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5345da76a6bb7e8485bcbc060dc6fc46d5942901", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5345da76a6bb7e8485bcbc060dc6fc46d5942901", "committedDate": "2020-04-22T23:16:02Z", "message": "Securing communication between Cruise Control and Kafka (#37)\n\n* Adding TLS communication between CC and Kafka\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>\n\n* Adding TLS communication between metric reporter and Kafka\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>\n\n* Fixed metrics report to use TLS hostname verification (#38)\n\nMoved metrics topic to Cruise Control configuration\nHiding truststore and keystore passwords in the log\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>\n\nCo-authored-by: Paolo Patierno <ppatierno@live.com>\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91ac7f21e43549dca16004910147417dbf94cb89", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/91ac7f21e43549dca16004910147417dbf94cb89", "committedDate": "2020-04-22T23:16:02Z", "message": "Removing CC replicas, refactor Dockerfile + CC dependencies\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b57762a5d170de91a8530da7d0e67226e950cb5c", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b57762a5d170de91a8530da7d0e67226e950cb5c", "committedDate": "2020-04-22T16:04:53Z", "message": "Securing communication between Cruise Control and Kafka (#37)\n\n* Adding TLS communication between CC and Kafka\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>\n\n* Adding TLS communication between metric reporter and Kafka\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>\n\n* Fixed metrics report to use TLS hostname verification (#38)\n\nMoved metrics topic to Cruise Control configuration\nHiding truststore and keystore passwords in the log\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>\n\nCo-authored-by: Paolo Patierno <ppatierno@live.com>\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}, "afterCommit": {"oid": "91ac7f21e43549dca16004910147417dbf94cb89", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/91ac7f21e43549dca16004910147417dbf94cb89", "committedDate": "2020-04-22T23:16:02Z", "message": "Removing CC replicas, refactor Dockerfile + CC dependencies\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4OTQwNjk0", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#pullrequestreview-398940694", "createdAt": "2020-04-23T09:53:05Z", "commit": {"oid": "91ac7f21e43549dca16004910147417dbf94cb89"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwOTo1MzowNVrOGKg21w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDowNjoxOVrOGKhZiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY3NzI3MQ==", "bodyText": "I think you could remove the replicas from here.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413677271", "createdAt": "2020-04-23T09:53:05Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91ac7f21e43549dca16004910147417dbf94cb89"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY3OTMzMw==", "bodyText": "I think we need to add here the securityontext form the container templates.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413679333", "createdAt": "2020-04-23T09:56:09Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"logging\";\n+\n+    private String zookeeperConnect;\n+\n+    // Configuration defaults\n+    protected static final int DEFAULT_REPLICAS = 1;\n+\n+    // Default probe settings (liveness and readiness) for health checks\n+    protected static final int DEFAULT_HEALTHCHECK_DELAY = 15;\n+    protected static final int DEFAULT_HEALTHCHECK_TIMEOUT = 5;\n+\n+    public static final Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder()\n+            .withInitialDelaySeconds(DEFAULT_HEALTHCHECK_DELAY)\n+            .withTimeoutSeconds(DEFAULT_HEALTHCHECK_TIMEOUT)\n+            .build();\n+\n+    private TlsSidecar tlsSidecar;\n+    private String tlsSidecarImage;\n+    private String minInsyncReplicas = \"1\";\n+    private Double brokerDiskMiBCapacity;\n+    private int brokerCpuUtilizationCapacity;\n+    private Double brokerInboundNetworkKiBPerSecondCapacity;\n+    private Double brokerOuboundNetworkKiBPerSecondCapacity;\n+\n+    public static final String REST_API_PORT_NAME = \"rest-api\";\n+    public static final int REST_API_PORT = 9090;\n+    protected static final int DEFAULT_BOOTSTRAP_SERVERS_PORT = 9091;\n+    public static final String MIN_INSYNC_REPLICAS = \"min.insync.replicas\";\n+\n+    // Cruise Control configuration keys (EnvVariables)\n+    protected static final String ENV_VAR_CRUISE_CONTROL_CONFIGURATION = \"CRUISE_CONTROL_CONFIGURATION\";\n+    protected static final String ENV_VAR_ZOOKEEPER_CONNECT = \"STRIMZI_ZOOKEEPER_CONNECT\";\n+    protected static final String ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS = \"STRIMZI_KAFKA_BOOTSTRAP_SERVERS\";\n+    protected static final String ENV_VAR_MIN_INSYNC_REPLICAS = \"MIN_INSYNC_REPLICAS\";\n+    protected static final String ENV_VAR_BROKER_DISK_MIB_CAPACITY = \"BROKER_DISK_MIB_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_CPU_UTILIZATION_CAPACITY = \"BROKER_CPU_UTILIZATION_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+\n+    // Templates\n+    protected List<ContainerEnvVar> templateCruiseControlContainerEnvVars;\n+    protected List<ContainerEnvVar> templateTlsSidecarContainerEnvVars;\n+\n+    private boolean isDeployed;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param resource  Kubernetes/OpenShift resource with metadata containing the namespace and cluster name\n+     */\n+    protected CruiseControl(HasMetadata resource) {\n+        super(resource, APPLICATION_NAME);\n+        this.name = CruiseControlResources.deploymentName(cluster);\n+        this.serviceName = CruiseControlResources.serviceName(cluster);\n+        this.ancillaryConfigName = metricAndLogConfigsName(cluster);\n+        this.replicas = DEFAULT_REPLICAS;\n+        this.readinessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.readinessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.mountPath = \"/var/lib/kafka\";\n+        this.logAndMetricsConfigVolumeName = LOG_AND_METRICS_CONFIG_VOLUME_NAME;\n+        this.logAndMetricsConfigMountPath = LOG_AND_METRICS_CONFIG_VOLUME_MOUNT;\n+\n+        this.zookeeperConnect = defaultZookeeperConnect(cluster);\n+    }\n+\n+    public static String metricAndLogConfigsName(String cluster) {\n+        return CruiseControlResources.logAndMetricsConfigMapName(cluster);\n+    }\n+\n+    protected void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    protected static String defaultZookeeperConnect(String cluster) {\n+        return ZookeeperCluster.serviceName(cluster) + \":\" + EntityOperatorSpec.DEFAULT_ZOOKEEPER_PORT;\n+    }\n+\n+    protected static String defaultBootstrapServers(String cluster) {\n+        return KafkaCluster.serviceName(cluster) + \":\" + DEFAULT_BOOTSTRAP_SERVERS_PORT;\n+    }\n+\n+    public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup versions) {\n+        CruiseControl cruiseControl = null;\n+        CruiseControlSpec spec  = kafkaAssembly.getSpec().getCruiseControl();\n+\n+        if (spec != null) {\n+            cruiseControl = new CruiseControl(kafkaAssembly);\n+            cruiseControl.isDeployed = true;\n+\n+            cruiseControl.setReplicas(DEFAULT_REPLICAS);\n+            String image = spec.getImage();\n+            if (image == null) {\n+                image = System.getenv().get(ClusterOperatorConfig.STRIMZI_DEFAULT_CRUISE_CONTROL_IMAGE);\n+            }\n+            cruiseControl.setImage(image);\n+\n+            TlsSidecar tlsSidecar = spec.getTlsSidecar();\n+            if (tlsSidecar == null) {\n+                tlsSidecar = new TlsSidecar();\n+            }\n+\n+            String tlsSideCarImage = tlsSidecar.getImage();\n+            if (tlsSideCarImage == null) {\n+                KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+                tlsSideCarImage = System.getenv().getOrDefault(ClusterOperatorConfig.STRIMZI_DEFAULT_TLS_SIDECAR_CRUISE_CONTROL_IMAGE, versions.kafkaImage(kafkaClusterSpec.getImage(), versions.defaultVersion().version()));\n+            }\n+\n+            tlsSidecar.setImage(tlsSideCarImage);\n+            cruiseControl.tlsSidecarImage = tlsSideCarImage;\n+            cruiseControl.setTlsSidecar(tlsSidecar);\n+\n+            cruiseControl = updateConfiguration(spec, cruiseControl);\n+\n+            KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+            KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+            if (configuration.getConfigOption(MIN_INSYNC_REPLICAS) != null) {\n+                cruiseControl.minInsyncReplicas = configuration.getConfigOption(MIN_INSYNC_REPLICAS);\n+            }\n+\n+            Capacity capacity = new Capacity(kafkaAssembly.getSpec());\n+            cruiseControl.brokerDiskMiBCapacity = capacity.getDiskMiB();\n+            cruiseControl.brokerCpuUtilizationCapacity = capacity.getCpuUtilization();\n+            cruiseControl.brokerInboundNetworkKiBPerSecondCapacity = capacity.getInboundNetworkKiBPerSecond();\n+            cruiseControl.brokerOuboundNetworkKiBPerSecondCapacity = capacity.getOutboundNetworkKiBPerSecond();\n+\n+            if (spec.getReadinessProbe() != null) {\n+                cruiseControl.setReadinessProbe(spec.getReadinessProbe());\n+            }\n+\n+            if (spec.getLivenessProbe() != null) {\n+                cruiseControl.setLivenessProbe(spec.getLivenessProbe());\n+            }\n+\n+            Logging logging = spec.getLogging();\n+            cruiseControl.setLogging(logging == null ? new InlineLogging() : logging);\n+\n+            cruiseControl.setGcLoggingEnabled(spec.getJvmOptions() == null ? DEFAULT_JVM_GC_LOGGING_ENABLED : spec.getJvmOptions().isGcLoggingEnabled());\n+            cruiseControl.setJvmOptions(spec.getJvmOptions());\n+\n+            cruiseControl.setUserAffinity(affinity(spec));\n+            cruiseControl.setResources(spec.getResources());\n+            cruiseControl.setTolerations(tolerations(spec));\n+            cruiseControl.setOwnerReference(kafkaAssembly);\n+            cruiseControl = updateTemplate(spec, cruiseControl);\n+        }\n+\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (configuration.getConfigOption(entry.getKey()) == null) {\n+                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        cruiseControl.setConfiguration(configuration);\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateTemplate(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        if (spec.getTemplate() != null) {\n+            CruiseControlTemplate template = spec.getTemplate();\n+\n+            ModelUtils.parsePodTemplate(cruiseControl, template.getPod());\n+\n+            if (template.getDeployment() != null && template.getDeployment().getMetadata() != null) {\n+                cruiseControl.templateDeploymentLabels = template.getDeployment().getMetadata().getLabels();\n+                cruiseControl.templateDeploymentAnnotations = template.getDeployment().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getApiService() != null && template.getApiService().getMetadata() != null) {\n+                cruiseControl.templateServiceLabels = template.getApiService().getMetadata().getLabels();\n+                cruiseControl.templateServiceAnnotations = template.getApiService().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getCruiseControlContainer() != null && template.getCruiseControlContainer().getEnv() != null) {\n+                cruiseControl.templateCruiseControlContainerEnvVars = template.getCruiseControlContainer().getEnv();\n+            }\n+\n+            if (template.getTlsSidecarContainer() != null && template.getTlsSidecarContainer().getEnv() != null) {\n+                cruiseControl.templateTlsSidecarContainerEnvVars = template.getTlsSidecarContainer().getEnv();\n+            }\n+\n+            ModelUtils.parsePodDisruptionBudgetTemplate(cruiseControl, template.getPodDisruptionBudget());\n+        }\n+        return cruiseControl;\n+    }\n+\n+    static List<Toleration> tolerations(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getTolerations() != null) {\n+            return spec.getTemplate().getPod().getTolerations();\n+        }\n+        return null;\n+    }\n+\n+    static Affinity affinity(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getAffinity() != null) {\n+            return spec.getTemplate().getPod().getAffinity();\n+        }\n+        return null;\n+    }\n+\n+    public static String cruiseControlName(String cluster) {\n+        return CruiseControlResources.deploymentName(cluster);\n+    }\n+\n+    public static String cruiseControlServiceName(String cluster) {\n+        return CruiseControlResources.serviceName(cluster);\n+    }\n+\n+    public Service generateService() {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        List<ServicePort> ports = Collections.singletonList(createServicePort(REST_API_PORT_NAME, REST_API_PORT, REST_API_PORT, \"TCP\"));\n+        return createService(\"ClusterIP\", ports, templateServiceAnnotations);\n+    }\n+\n+    protected List<ContainerPort> getContainerPortList() {\n+        List<ContainerPort> portList = new ArrayList<>(1);\n+\n+        portList.add(createContainerPort(REST_API_PORT_NAME, REST_API_PORT, \"TCP\"));\n+\n+        if (isMetricsEnabled) {\n+            portList.add(createContainerPort(METRICS_PORT_NAME, METRICS_PORT, \"TCP\"));\n+        }\n+\n+        return portList;\n+    }\n+\n+    protected List<Volume> getVolumes(boolean isOpenShift) {\n+        return Arrays.asList(createSecretVolume(TLS_SIDECAR_CC_CERTS_VOLUME_NAME, CruiseControl.secretName(cluster), isOpenShift),\n+                createSecretVolume(TLS_SIDECAR_CA_CERTS_VOLUME_NAME, AbstractModel.clusterCaCertSecretName(cluster), isOpenShift),\n+                createConfigMapVolume(logAndMetricsConfigVolumeName, ancillaryConfigName));\n+    }\n+\n+    protected List<VolumeMount> getVolumeMounts() {\n+        return Arrays.asList(createVolumeMount(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME, CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT),\n+                createVolumeMount(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME, CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT),\n+                createVolumeMount(logAndMetricsConfigVolumeName, logAndMetricsConfigMountPath));\n+    }\n+\n+    public Deployment generateDeployment(boolean isOpenShift, Map<String, String> annotations, ImagePullPolicy imagePullPolicy, List<LocalObjectReference> imagePullSecrets) {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        DeploymentStrategy updateStrategy = new DeploymentStrategyBuilder()\n+                .withType(\"RollingUpdate\")\n+                .withRollingUpdate(new RollingUpdateDeploymentBuilder()\n+                        .withMaxSurge(new IntOrString(1))\n+                        .withMaxUnavailable(new IntOrString(0))\n+                        .build())\n+                .build();\n+\n+        return createDeployment(\n+                updateStrategy,\n+                Collections.emptyMap(),\n+                Collections.emptyMap(),\n+                getMergedAffinity(),\n+                getInitContainers(imagePullPolicy),\n+                getContainers(imagePullPolicy),\n+                getVolumes(isOpenShift),\n+                imagePullSecrets);\n+    }\n+\n+    @Override\n+    protected List<Container> getContainers(ImagePullPolicy imagePullPolicy) {\n+        List<Container> containers = new ArrayList<>();\n+        Container container = new ContainerBuilder()\n+                .withName(CRUISE_CONTROL_CONTAINER_NAME)\n+                .withImage(getImage())\n+                .withCommand(\"/opt/cruise-control/cruise_control_run.sh\")\n+                .withEnv(getEnvVars())\n+                .withPorts(getContainerPortList())\n+                .withLivenessProbe(ModelUtils.createHttpProbe(livenessPath, REST_API_PORT_NAME, livenessProbeOptions))\n+                .withReadinessProbe(ModelUtils.createHttpProbe(readinessPath, REST_API_PORT_NAME, readinessProbeOptions))\n+                .withResources(getResources())\n+                .withVolumeMounts(getVolumeMounts())\n+                .withImagePullPolicy(determineImagePullPolicy(imagePullPolicy, getImage()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91ac7f21e43549dca16004910147417dbf94cb89"}, "originalPosition": 354}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY3OTY1Ng==", "bodyText": "We need to add here the security context from the tlsSidecar container template.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413679656", "createdAt": "2020-04-23T09:56:34Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"logging\";\n+\n+    private String zookeeperConnect;\n+\n+    // Configuration defaults\n+    protected static final int DEFAULT_REPLICAS = 1;\n+\n+    // Default probe settings (liveness and readiness) for health checks\n+    protected static final int DEFAULT_HEALTHCHECK_DELAY = 15;\n+    protected static final int DEFAULT_HEALTHCHECK_TIMEOUT = 5;\n+\n+    public static final Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder()\n+            .withInitialDelaySeconds(DEFAULT_HEALTHCHECK_DELAY)\n+            .withTimeoutSeconds(DEFAULT_HEALTHCHECK_TIMEOUT)\n+            .build();\n+\n+    private TlsSidecar tlsSidecar;\n+    private String tlsSidecarImage;\n+    private String minInsyncReplicas = \"1\";\n+    private Double brokerDiskMiBCapacity;\n+    private int brokerCpuUtilizationCapacity;\n+    private Double brokerInboundNetworkKiBPerSecondCapacity;\n+    private Double brokerOuboundNetworkKiBPerSecondCapacity;\n+\n+    public static final String REST_API_PORT_NAME = \"rest-api\";\n+    public static final int REST_API_PORT = 9090;\n+    protected static final int DEFAULT_BOOTSTRAP_SERVERS_PORT = 9091;\n+    public static final String MIN_INSYNC_REPLICAS = \"min.insync.replicas\";\n+\n+    // Cruise Control configuration keys (EnvVariables)\n+    protected static final String ENV_VAR_CRUISE_CONTROL_CONFIGURATION = \"CRUISE_CONTROL_CONFIGURATION\";\n+    protected static final String ENV_VAR_ZOOKEEPER_CONNECT = \"STRIMZI_ZOOKEEPER_CONNECT\";\n+    protected static final String ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS = \"STRIMZI_KAFKA_BOOTSTRAP_SERVERS\";\n+    protected static final String ENV_VAR_MIN_INSYNC_REPLICAS = \"MIN_INSYNC_REPLICAS\";\n+    protected static final String ENV_VAR_BROKER_DISK_MIB_CAPACITY = \"BROKER_DISK_MIB_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_CPU_UTILIZATION_CAPACITY = \"BROKER_CPU_UTILIZATION_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+\n+    // Templates\n+    protected List<ContainerEnvVar> templateCruiseControlContainerEnvVars;\n+    protected List<ContainerEnvVar> templateTlsSidecarContainerEnvVars;\n+\n+    private boolean isDeployed;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param resource  Kubernetes/OpenShift resource with metadata containing the namespace and cluster name\n+     */\n+    protected CruiseControl(HasMetadata resource) {\n+        super(resource, APPLICATION_NAME);\n+        this.name = CruiseControlResources.deploymentName(cluster);\n+        this.serviceName = CruiseControlResources.serviceName(cluster);\n+        this.ancillaryConfigName = metricAndLogConfigsName(cluster);\n+        this.replicas = DEFAULT_REPLICAS;\n+        this.readinessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.readinessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.mountPath = \"/var/lib/kafka\";\n+        this.logAndMetricsConfigVolumeName = LOG_AND_METRICS_CONFIG_VOLUME_NAME;\n+        this.logAndMetricsConfigMountPath = LOG_AND_METRICS_CONFIG_VOLUME_MOUNT;\n+\n+        this.zookeeperConnect = defaultZookeeperConnect(cluster);\n+    }\n+\n+    public static String metricAndLogConfigsName(String cluster) {\n+        return CruiseControlResources.logAndMetricsConfigMapName(cluster);\n+    }\n+\n+    protected void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    protected static String defaultZookeeperConnect(String cluster) {\n+        return ZookeeperCluster.serviceName(cluster) + \":\" + EntityOperatorSpec.DEFAULT_ZOOKEEPER_PORT;\n+    }\n+\n+    protected static String defaultBootstrapServers(String cluster) {\n+        return KafkaCluster.serviceName(cluster) + \":\" + DEFAULT_BOOTSTRAP_SERVERS_PORT;\n+    }\n+\n+    public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup versions) {\n+        CruiseControl cruiseControl = null;\n+        CruiseControlSpec spec  = kafkaAssembly.getSpec().getCruiseControl();\n+\n+        if (spec != null) {\n+            cruiseControl = new CruiseControl(kafkaAssembly);\n+            cruiseControl.isDeployed = true;\n+\n+            cruiseControl.setReplicas(DEFAULT_REPLICAS);\n+            String image = spec.getImage();\n+            if (image == null) {\n+                image = System.getenv().get(ClusterOperatorConfig.STRIMZI_DEFAULT_CRUISE_CONTROL_IMAGE);\n+            }\n+            cruiseControl.setImage(image);\n+\n+            TlsSidecar tlsSidecar = spec.getTlsSidecar();\n+            if (tlsSidecar == null) {\n+                tlsSidecar = new TlsSidecar();\n+            }\n+\n+            String tlsSideCarImage = tlsSidecar.getImage();\n+            if (tlsSideCarImage == null) {\n+                KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+                tlsSideCarImage = System.getenv().getOrDefault(ClusterOperatorConfig.STRIMZI_DEFAULT_TLS_SIDECAR_CRUISE_CONTROL_IMAGE, versions.kafkaImage(kafkaClusterSpec.getImage(), versions.defaultVersion().version()));\n+            }\n+\n+            tlsSidecar.setImage(tlsSideCarImage);\n+            cruiseControl.tlsSidecarImage = tlsSideCarImage;\n+            cruiseControl.setTlsSidecar(tlsSidecar);\n+\n+            cruiseControl = updateConfiguration(spec, cruiseControl);\n+\n+            KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+            KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+            if (configuration.getConfigOption(MIN_INSYNC_REPLICAS) != null) {\n+                cruiseControl.minInsyncReplicas = configuration.getConfigOption(MIN_INSYNC_REPLICAS);\n+            }\n+\n+            Capacity capacity = new Capacity(kafkaAssembly.getSpec());\n+            cruiseControl.brokerDiskMiBCapacity = capacity.getDiskMiB();\n+            cruiseControl.brokerCpuUtilizationCapacity = capacity.getCpuUtilization();\n+            cruiseControl.brokerInboundNetworkKiBPerSecondCapacity = capacity.getInboundNetworkKiBPerSecond();\n+            cruiseControl.brokerOuboundNetworkKiBPerSecondCapacity = capacity.getOutboundNetworkKiBPerSecond();\n+\n+            if (spec.getReadinessProbe() != null) {\n+                cruiseControl.setReadinessProbe(spec.getReadinessProbe());\n+            }\n+\n+            if (spec.getLivenessProbe() != null) {\n+                cruiseControl.setLivenessProbe(spec.getLivenessProbe());\n+            }\n+\n+            Logging logging = spec.getLogging();\n+            cruiseControl.setLogging(logging == null ? new InlineLogging() : logging);\n+\n+            cruiseControl.setGcLoggingEnabled(spec.getJvmOptions() == null ? DEFAULT_JVM_GC_LOGGING_ENABLED : spec.getJvmOptions().isGcLoggingEnabled());\n+            cruiseControl.setJvmOptions(spec.getJvmOptions());\n+\n+            cruiseControl.setUserAffinity(affinity(spec));\n+            cruiseControl.setResources(spec.getResources());\n+            cruiseControl.setTolerations(tolerations(spec));\n+            cruiseControl.setOwnerReference(kafkaAssembly);\n+            cruiseControl = updateTemplate(spec, cruiseControl);\n+        }\n+\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (configuration.getConfigOption(entry.getKey()) == null) {\n+                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        cruiseControl.setConfiguration(configuration);\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateTemplate(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        if (spec.getTemplate() != null) {\n+            CruiseControlTemplate template = spec.getTemplate();\n+\n+            ModelUtils.parsePodTemplate(cruiseControl, template.getPod());\n+\n+            if (template.getDeployment() != null && template.getDeployment().getMetadata() != null) {\n+                cruiseControl.templateDeploymentLabels = template.getDeployment().getMetadata().getLabels();\n+                cruiseControl.templateDeploymentAnnotations = template.getDeployment().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getApiService() != null && template.getApiService().getMetadata() != null) {\n+                cruiseControl.templateServiceLabels = template.getApiService().getMetadata().getLabels();\n+                cruiseControl.templateServiceAnnotations = template.getApiService().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getCruiseControlContainer() != null && template.getCruiseControlContainer().getEnv() != null) {\n+                cruiseControl.templateCruiseControlContainerEnvVars = template.getCruiseControlContainer().getEnv();\n+            }\n+\n+            if (template.getTlsSidecarContainer() != null && template.getTlsSidecarContainer().getEnv() != null) {\n+                cruiseControl.templateTlsSidecarContainerEnvVars = template.getTlsSidecarContainer().getEnv();\n+            }\n+\n+            ModelUtils.parsePodDisruptionBudgetTemplate(cruiseControl, template.getPodDisruptionBudget());\n+        }\n+        return cruiseControl;\n+    }\n+\n+    static List<Toleration> tolerations(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getTolerations() != null) {\n+            return spec.getTemplate().getPod().getTolerations();\n+        }\n+        return null;\n+    }\n+\n+    static Affinity affinity(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getAffinity() != null) {\n+            return spec.getTemplate().getPod().getAffinity();\n+        }\n+        return null;\n+    }\n+\n+    public static String cruiseControlName(String cluster) {\n+        return CruiseControlResources.deploymentName(cluster);\n+    }\n+\n+    public static String cruiseControlServiceName(String cluster) {\n+        return CruiseControlResources.serviceName(cluster);\n+    }\n+\n+    public Service generateService() {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        List<ServicePort> ports = Collections.singletonList(createServicePort(REST_API_PORT_NAME, REST_API_PORT, REST_API_PORT, \"TCP\"));\n+        return createService(\"ClusterIP\", ports, templateServiceAnnotations);\n+    }\n+\n+    protected List<ContainerPort> getContainerPortList() {\n+        List<ContainerPort> portList = new ArrayList<>(1);\n+\n+        portList.add(createContainerPort(REST_API_PORT_NAME, REST_API_PORT, \"TCP\"));\n+\n+        if (isMetricsEnabled) {\n+            portList.add(createContainerPort(METRICS_PORT_NAME, METRICS_PORT, \"TCP\"));\n+        }\n+\n+        return portList;\n+    }\n+\n+    protected List<Volume> getVolumes(boolean isOpenShift) {\n+        return Arrays.asList(createSecretVolume(TLS_SIDECAR_CC_CERTS_VOLUME_NAME, CruiseControl.secretName(cluster), isOpenShift),\n+                createSecretVolume(TLS_SIDECAR_CA_CERTS_VOLUME_NAME, AbstractModel.clusterCaCertSecretName(cluster), isOpenShift),\n+                createConfigMapVolume(logAndMetricsConfigVolumeName, ancillaryConfigName));\n+    }\n+\n+    protected List<VolumeMount> getVolumeMounts() {\n+        return Arrays.asList(createVolumeMount(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME, CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT),\n+                createVolumeMount(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME, CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT),\n+                createVolumeMount(logAndMetricsConfigVolumeName, logAndMetricsConfigMountPath));\n+    }\n+\n+    public Deployment generateDeployment(boolean isOpenShift, Map<String, String> annotations, ImagePullPolicy imagePullPolicy, List<LocalObjectReference> imagePullSecrets) {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        DeploymentStrategy updateStrategy = new DeploymentStrategyBuilder()\n+                .withType(\"RollingUpdate\")\n+                .withRollingUpdate(new RollingUpdateDeploymentBuilder()\n+                        .withMaxSurge(new IntOrString(1))\n+                        .withMaxUnavailable(new IntOrString(0))\n+                        .build())\n+                .build();\n+\n+        return createDeployment(\n+                updateStrategy,\n+                Collections.emptyMap(),\n+                Collections.emptyMap(),\n+                getMergedAffinity(),\n+                getInitContainers(imagePullPolicy),\n+                getContainers(imagePullPolicy),\n+                getVolumes(isOpenShift),\n+                imagePullSecrets);\n+    }\n+\n+    @Override\n+    protected List<Container> getContainers(ImagePullPolicy imagePullPolicy) {\n+        List<Container> containers = new ArrayList<>();\n+        Container container = new ContainerBuilder()\n+                .withName(CRUISE_CONTROL_CONTAINER_NAME)\n+                .withImage(getImage())\n+                .withCommand(\"/opt/cruise-control/cruise_control_run.sh\")\n+                .withEnv(getEnvVars())\n+                .withPorts(getContainerPortList())\n+                .withLivenessProbe(ModelUtils.createHttpProbe(livenessPath, REST_API_PORT_NAME, livenessProbeOptions))\n+                .withReadinessProbe(ModelUtils.createHttpProbe(readinessPath, REST_API_PORT_NAME, readinessProbeOptions))\n+                .withResources(getResources())\n+                .withVolumeMounts(getVolumeMounts())\n+                .withImagePullPolicy(determineImagePullPolicy(imagePullPolicy, getImage()))\n+                .build();\n+\n+        String tlsSidecarImage = this.tlsSidecarImage;\n+        if (tlsSidecar != null && tlsSidecar.getImage() != null) {\n+            tlsSidecarImage = tlsSidecar.getImage();\n+        }\n+\n+        Container tlsSidecarContainer = new ContainerBuilder()\n+                .withName(TLS_SIDECAR_NAME)\n+                .withImage(tlsSidecarImage)\n+                .withCommand(\"/opt/stunnel/cruise_control_stunnel_run.sh\")\n+                .withLivenessProbe(ModelUtils.tlsSidecarLivenessProbe(tlsSidecar))\n+                .withReadinessProbe(ModelUtils.tlsSidecarReadinessProbe(tlsSidecar))\n+                .withResources(tlsSidecar != null ? tlsSidecar.getResources() : null)\n+                .withEnv(getTlsSidecarEnvVars())\n+                .withVolumeMounts(createVolumeMount(TLS_SIDECAR_CC_CERTS_VOLUME_NAME, TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT),\n+                        createVolumeMount(TLS_SIDECAR_CA_CERTS_VOLUME_NAME, TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT))\n+                .withLifecycle(new LifecycleBuilder().withNewPreStop().withNewExec()\n+                        .withCommand(\"/opt/stunnel/cruise_control_stunnel_pre_stop.sh\",\n+                                String.valueOf(templateTerminationGracePeriodSeconds))\n+                        .endExec().endPreStop().build())\n+                .withImagePullPolicy(determineImagePullPolicy(imagePullPolicy, tlsSidecarImage))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91ac7f21e43549dca16004910147417dbf94cb89"}, "originalPosition": 376}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4MTc0Nw==", "bodyText": "Do we need to set some network policies on the CruiseControl ports?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413681747", "createdAt": "2020-04-23T09:59:45Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91ac7f21e43549dca16004910147417dbf94cb89"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NjE1Mg==", "bodyText": "This should be 2.4.1 now.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413686152", "createdAt": "2020-04-23T10:06:19Z", "author": {"login": "scholzj"}, "path": "examples/kafka/kafka-cruise-control.yaml", "diffHunk": "@@ -0,0 +1,26 @@\n+apiVersion: kafka.strimzi.io/v1beta1\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  kafka:\n+    version: 2.4.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91ac7f21e43549dca16004910147417dbf94cb89"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4OTgyMjc4", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#pullrequestreview-398982278", "createdAt": "2020-04-23T10:51:25Z", "commit": {"oid": "91ac7f21e43549dca16004910147417dbf94cb89"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDo1MToyNVrOGKjH-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDo1MToyNVrOGKjH-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcxNDQyNA==", "bodyText": "I think we should provide a default CC configuration in the example file. We could provide the full list of goals and default goals so the user can remove any they don't need and/or fine-tune the constraints.\nOtherwise, we're making the user work harder. They'll need to refer to the documentation to figure out how to set goals and capacity limits.\nI don't mind if you merge this now and we continue the discussion in later PRs.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413714424", "createdAt": "2020-04-23T10:51:25Z", "author": {"login": "laidan6000"}, "path": "examples/kafka/kafka-cruise-control.yaml", "diffHunk": "@@ -0,0 +1,26 @@\n+apiVersion: kafka.strimzi.io/v1beta1\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  kafka:\n+    version: 2.4.0\n+    replicas: 3\n+    listeners:\n+      plain: {}\n+      tls: {}\n+    config:\n+      offsets.topic.replication.factor: 3\n+      transaction.state.log.replication.factor: 3\n+      transaction.state.log.min.isr: 2\n+      log.message.format.version: \"2.4\"\n+    storage:\n+      type: ephemeral\n+  zookeeper:\n+    replicas: 3\n+    storage:\n+      type: ephemeral\n+  entityOperator:\n+    topicOperator: {}\n+    userOperator: {}\n+  cruiseControl: {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91ac7f21e43549dca16004910147417dbf94cb89"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee9b1a28e67a1a879ff96e372992fdaa0bf3d3db", "author": {"user": {"login": "ppatierno", "name": "Paolo Patierno"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/ee9b1a28e67a1a879ff96e372992fdaa0bf3d3db", "committedDate": "2020-04-23T16:20:29Z", "message": "Added security context, network policy and tests (#39)\n\n* Added security context and tests\r\n\r\nSigned-off-by: Paolo Patierno <ppatierno@live.com>\r\n\r\n* Added network policy for the cruise control REST API port\r\n\r\nSigned-off-by: Paolo Patierno <ppatierno@live.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5Mjc4NDM4", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#pullrequestreview-399278438", "createdAt": "2020-04-23T16:35:51Z", "commit": {"oid": "ee9b1a28e67a1a879ff96e372992fdaa0bf3d3db"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5Mjc4OTEw", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#pullrequestreview-399278910", "createdAt": "2020-04-23T16:36:27Z", "commit": {"oid": "ee9b1a28e67a1a879ff96e372992fdaa0bf3d3db"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bc4a05f7275595083d01e84df5568a80c900fb2", "author": {"user": {"login": "ppatierno", "name": "Paolo Patierno"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/2bc4a05f7275595083d01e84df5568a80c900fb2", "committedDate": "2020-04-23T17:06:40Z", "message": "Added CruiseControl ST to regression tests\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38fb0cff82ce54358f1af64dd139872f507b263a", "author": {"user": {"login": "ppatierno", "name": "Paolo Patierno"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/38fb0cff82ce54358f1af64dd139872f507b263a", "committedDate": "2020-04-23T19:10:55Z", "message": "Fixed NPE on Cruise Control network policy\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2166, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}