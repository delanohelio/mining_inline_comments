{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2MjE4NDgy", "number": 3926, "title": "[DOC] describe rack awareness", "bodyText": "Signed-off-by: prmellor pmellor@redhat.com\nDocumentation\nUpdate to the Using Guide to describe rack awareness for Kafka and Kafka Connect.\n\nExample yaml for Kafka and example config for Kafka Connect/S2I config both show rack property, with links to the Rack schema reference section in the appendix.\nbrokerRackInitImage property description added to the KafkaClusterSpec schema reference.\nA few legacy files related to rack awareness, added in 0.7 but not used in the docs have been deleted.\n\nChecklist\nPlease go through this checklist and make sure all applicable tasks have been done\n\n Write tests\n Make sure all tests pass\n Update documentation\n Check RBAC rights for Kubernetes / OpenShift roles\n Try your changes from Pod inside your Kubernetes and OpenShift cluster, not just locally\n Reference relevant issue(s) and close them after merging\n Update CHANGELOG.md\n Supply screenshots for visual changes, such as Grafana dashboards", "createdAt": "2020-11-05T17:21:58Z", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3926", "merged": true, "mergeCommit": {"oid": "4340086486fe41c6aeac3f34ccd60765be316d7e"}, "closed": true, "closedAt": "2020-11-12T21:16:48Z", "author": {"login": "PaulRMellor"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZlh4NAH2gAyNTE2MjE4NDgyOjNhNjFiZmQ2MjhlNGEwMTEwN2U5MTVjNjM1MjM1MGE2MmUwMTMxYjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdb5O3agFqTUyOTUwMjA4MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3a61bfd628e4a01107e915c6352350a62e0131b3", "author": {"user": {"login": "PaulRMellor", "name": null}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/3a61bfd628e4a01107e915c6352350a62e0131b3", "committedDate": "2020-11-05T17:08:50Z", "message": "[DOC] describe rack awareness\n\nSigned-off-by: prmellor <pmellor@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NjQ4NzEy", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3926#pullrequestreview-524648712", "createdAt": "2020-11-05T20:40:26Z", "commit": {"oid": "3a61bfd628e4a01107e915c6352350a62e0131b3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMDo0MDoyNlrOHuVofg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMDo0MDoyNlrOHuVofg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM1MDk3NA==", "bodyText": "This is one level higher in the YAML:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  brokerRackInitImage: my-org/my-image:latest\n          \n          \n            \n                brokerRackInitImage: my-org/my-image:latest", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3926#discussion_r518350974", "createdAt": "2020-11-05T20:40:26Z", "author": {"login": "scholzj"}, "path": "documentation/api/io.strimzi.api.kafka.model.KafkaClusterSpec.adoc", "diffHunk": "@@ -93,3 +93,33 @@ spec:\n       zookeeper.connection.timeout.ms: 6000\n     # ...\n ----\n+\n+[id='property-kafka-brokerRackInitImage-{context}']\n+=== `brokerRackInitImage`\n+\n+When rack awareness is enabled, Kafka broker pods use init container to collect the labels from the Kubernetes cluster nodes.\n+The container image used for this container can be configured using the `brokerRackInitImage` property.\n+When the `brokerRackInitImage` field is missing, the following images are used in order of priority:\n+\n+. Container image specified in `STRIMZI_DEFAULT_KAFKA_INIT_IMAGE` environment variable in the Cluster Operator configuration.\n+. `{DockerKafkaInit}` container image.\n+\n+.Example `brokerRackInitImage` configuration\n+[source,yaml,subs=attributes+]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  kafka:\n+    # ...\n+    rack:\n+      topologyKey: topology.kubernetes.io/zone\n+      brokerRackInitImage: my-org/my-image:latest", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a61bfd628e4a01107e915c6352350a62e0131b3"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a451dcea5beec5e668eeb336f8b616c8d2a8623", "author": {"user": {"login": "PaulRMellor", "name": null}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/7a451dcea5beec5e668eeb336f8b616c8d2a8623", "committedDate": "2020-11-06T14:27:39Z", "message": "review edits JS\n\nSigned-off-by: prmellor <pmellor@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1MzUxMDQ5", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3926#pullrequestreview-525351049", "createdAt": "2020-11-06T17:24:21Z", "commit": {"oid": "7a451dcea5beec5e668eeb336f8b616c8d2a8623"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzoyNDoyMlrOHu23tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzoyNjoyM1rOHu28fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg5NTU0MA==", "bodyText": "This is really related just to the client rackawareness / consuming from closest replica. Not to the broker rackawareness as suggested here. I think we need to make it clear.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3926#discussion_r518895540", "createdAt": "2020-11-06T17:24:22Z", "author": {"login": "scholzj"}, "path": "documentation/api/io.strimzi.api.kafka.model.Rack.adoc", "diffHunk": "@@ -0,0 +1,72 @@\n+Configures rack awareness to spread partition replicas across different racks.\n+\n+A _rack_ can represent an availability zone, data center, or an actual rack in your data center.\n+By configuring a `rack` for a Kafka cluster, consumers can fetch data from the closest replica.\n+This is useful for reducing the load on your network when a Kafka cluster spans multiple datacenters.\n+\n+To configure Kafka brokers for rack awareness specify:\n+\n+* A `topologyKey` value to match the label of the cluster node used by Kubernetes when scheduling Kafka broker pods to nodes\n+* The `RackAwareReplicaSelector` implementation for the Kafka `ReplicaSelector` plugin", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a451dcea5beec5e668eeb336f8b616c8d2a8623"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg5NjIxMA==", "bodyText": "I would probably move this and the first mantion of the RackAwareReplicaSelector only behind this first example.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3926#discussion_r518896210", "createdAt": "2020-11-06T17:25:26Z", "author": {"login": "scholzj"}, "path": "documentation/api/io.strimzi.api.kafka.model.Rack.adoc", "diffHunk": "@@ -0,0 +1,72 @@\n+Configures rack awareness to spread partition replicas across different racks.\n+\n+A _rack_ can represent an availability zone, data center, or an actual rack in your data center.\n+By configuring a `rack` for a Kafka cluster, consumers can fetch data from the closest replica.\n+This is useful for reducing the load on your network when a Kafka cluster spans multiple datacenters.\n+\n+To configure Kafka brokers for rack awareness specify:\n+\n+* A `topologyKey` value to match the label of the cluster node used by Kubernetes when scheduling Kafka broker pods to nodes\n+* The `RackAwareReplicaSelector` implementation for the Kafka `ReplicaSelector` plugin\n+\n+If the Kubernetes cluster is running on a cloud provider platform, the label must represent the availability zone where the node is running.\n+Usually, nodes are labeled with the `topology.kubernetes.io/zone` label (or `failure-domain.beta.kubernetes.io/zone` on older Kubernetes versions),\n+which can be used as the `topologyKey` value.\n+\n+The `ReplicaSelector` plugin provides the logic that enables clients to consume from the nearest replica.\n+Specify `RackAwareReplicaSelector` for the `replica.selector.class` to switch from the default implementation.\n+The default implementation uses `LeaderSelector` to always select the leader replica for the client.\n+By switching from the leader replica to the replica follower, there is some cost to latency.\n+If required, you can also customize your own implementation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a451dcea5beec5e668eeb336f8b616c8d2a8623"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg5NjM3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The rack awareness configuration spreads the broker pods across zones, improving resiliency, and also sets a `broker.rack` configuration for each Kafka broker.\n          \n          \n            \n            The rack awareness configuration spreads the broker pods and partition replicas across zones, improving resiliency, and also sets a `broker.rack` configuration for each Kafka broker.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3926#discussion_r518896374", "createdAt": "2020-11-06T17:25:46Z", "author": {"login": "scholzj"}, "path": "documentation/api/io.strimzi.api.kafka.model.Rack.adoc", "diffHunk": "@@ -0,0 +1,72 @@\n+Configures rack awareness to spread partition replicas across different racks.\n+\n+A _rack_ can represent an availability zone, data center, or an actual rack in your data center.\n+By configuring a `rack` for a Kafka cluster, consumers can fetch data from the closest replica.\n+This is useful for reducing the load on your network when a Kafka cluster spans multiple datacenters.\n+\n+To configure Kafka brokers for rack awareness specify:\n+\n+* A `topologyKey` value to match the label of the cluster node used by Kubernetes when scheduling Kafka broker pods to nodes\n+* The `RackAwareReplicaSelector` implementation for the Kafka `ReplicaSelector` plugin\n+\n+If the Kubernetes cluster is running on a cloud provider platform, the label must represent the availability zone where the node is running.\n+Usually, nodes are labeled with the `topology.kubernetes.io/zone` label (or `failure-domain.beta.kubernetes.io/zone` on older Kubernetes versions),\n+which can be used as the `topologyKey` value.\n+\n+The `ReplicaSelector` plugin provides the logic that enables clients to consume from the nearest replica.\n+Specify `RackAwareReplicaSelector` for the `replica.selector.class` to switch from the default implementation.\n+The default implementation uses `LeaderSelector` to always select the leader replica for the client.\n+By switching from the leader replica to the replica follower, there is some cost to latency.\n+If required, you can also customize your own implementation.\n+\n+The rack awareness configuration spreads the broker pods across zones, improving resiliency, and also sets a `broker.rack` configuration for each Kafka broker.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a451dcea5beec5e668eeb336f8b616c8d2a8623"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg5Njc2NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For clients, including Kafka Connect, you specify the same topology key as the broker that the client will use to consume messages.\n          \n          \n            \n            For Kafka Connect, you specify the same topology key as the broker that the client will use to consume messages.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3926#discussion_r518896764", "createdAt": "2020-11-06T17:26:23Z", "author": {"login": "scholzj"}, "path": "documentation/api/io.strimzi.api.kafka.model.Rack.adoc", "diffHunk": "@@ -0,0 +1,72 @@\n+Configures rack awareness to spread partition replicas across different racks.\n+\n+A _rack_ can represent an availability zone, data center, or an actual rack in your data center.\n+By configuring a `rack` for a Kafka cluster, consumers can fetch data from the closest replica.\n+This is useful for reducing the load on your network when a Kafka cluster spans multiple datacenters.\n+\n+To configure Kafka brokers for rack awareness specify:\n+\n+* A `topologyKey` value to match the label of the cluster node used by Kubernetes when scheduling Kafka broker pods to nodes\n+* The `RackAwareReplicaSelector` implementation for the Kafka `ReplicaSelector` plugin\n+\n+If the Kubernetes cluster is running on a cloud provider platform, the label must represent the availability zone where the node is running.\n+Usually, nodes are labeled with the `topology.kubernetes.io/zone` label (or `failure-domain.beta.kubernetes.io/zone` on older Kubernetes versions),\n+which can be used as the `topologyKey` value.\n+\n+The `ReplicaSelector` plugin provides the logic that enables clients to consume from the nearest replica.\n+Specify `RackAwareReplicaSelector` for the `replica.selector.class` to switch from the default implementation.\n+The default implementation uses `LeaderSelector` to always select the leader replica for the client.\n+By switching from the leader replica to the replica follower, there is some cost to latency.\n+If required, you can also customize your own implementation.\n+\n+The rack awareness configuration spreads the broker pods across zones, improving resiliency, and also sets a `broker.rack` configuration for each Kafka broker.\n+The `broker.rack` configuration assigns a rack ID to each broker.\n+\n+Consult your Kubernetes administrator regarding the node label that represents the zone or rack into which the node is deployed.\n+\n+.Example `rack` configuration for Kafka\n+[source,yaml,subs=attributes+]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  kafka:\n+    # ...\n+    rack:\n+      topologyKey: topology.kubernetes.io/zone\n+    config:\n+      # ...\n+      replica.selector.class: org.apache.kafka.common.replica.RackAwareReplicaSelector\n+    # ...\n+----\n+\n+For clients, including Kafka Connect, you specify the same topology key as the broker that the client will use to consume messages.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a451dcea5beec5e668eeb336f8b616c8d2a8623"}, "originalPosition": 45}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "463c109613de9bdcf866acf9f252bc9b93151a9c", "author": {"user": {"login": "PaulRMellor", "name": null}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/463c109613de9bdcf866acf9f252bc9b93151a9c", "committedDate": "2020-11-09T16:16:20Z", "message": "review edits JS\n\nSigned-off-by: prmellor <pmellor@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NjE5OTUz", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3926#pullrequestreview-526619953", "createdAt": "2020-11-09T20:16:21Z", "commit": {"oid": "463c109613de9bdcf866acf9f252bc9b93151a9c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3MTk1NjYz", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3926#pullrequestreview-527195663", "createdAt": "2020-11-10T13:23:56Z", "commit": {"oid": "463c109613de9bdcf866acf9f252bc9b93151a9c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxMzoyMzo1NlrOHwcVQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxMzo1MzozMVrOHwdjhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU1Nzg5MQ==", "bodyText": "I think the x-ref should be on \"rack awareness\".", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3926#discussion_r520557891", "createdAt": "2020-11-10T13:23:56Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/ref-sample-kafka-resource-config.adoc", "diffHunk": "@@ -146,7 +146,7 @@ spec:\n <18> Storage is xref:assembly-storage-{context}[configured as `ephemeral`, `persistent-claim` or `jbod`].\n <19> Storage size for xref:proc-resizing-persistent-volumes-{context}[persistent volumes may be increased] and additional xref:proc-adding-volumes-to-jbod-storage-{context}[volumes may be added to JBOD storage].\n <20> Persistent storage has xref:ref-persistent-storage-{context}[additional configuration options], such as a storage `id` and `class` for dynamic volume provisioning.\n-<21> Rack awareness is configured to xref:assembly-kafka-rack-{context}[spread replicas across different racks]. A `topology` key must match the label of a cluster node.\n+<21> Rack awareness is xref:type-Rack-reference[configured to spread replicas across different racks]. A `topology` key must match the label of a cluster node.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "463c109613de9bdcf866acf9f252bc9b93151a9c"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU1ODMzNQ==", "bodyText": "Same comment about the cross-ref.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3926#discussion_r520558335", "createdAt": "2020-11-10T13:24:35Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/configuring/proc-config-kafka-connect.adoc", "diffHunk": "@@ -159,8 +161,9 @@ Standard Apache Kafka configuration may be provided, restricted to those propert\n <12> xref:con-common-configuration-prometheus-reference[Prometheus metrics], which are enabled with configuration for the Prometheus JMX exporter in this example. You can enable metrics without further configuration using `metrics: {}`.\n <13> xref:con-common-configuration-jvm-reference[JVM configuration options] to optimize performance for the Virtual Machine (VM) running Kafka Connect.\n <14> ADVANCED OPTION: xref:con-common-configuration-images-reference[Container image configuration], which is recommended only in special situations.\n-<15> xref:assembly-customizing-kubernetes-resources-str[Template customization]. Here a pod is scheduled with anti-affinity, so the pod is not scheduled on nodes with the same hostname.\n-<16> Environment variables are also xref:ref-tracing-environment-variables-str[set for distributed tracing using Jaeger].\n+<15> Rack awareness is xref:type-Rack-reference[configured to spread replicas across different racks]. A `topology` key must match the label of a cluster node.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "463c109613de9bdcf866acf9f252bc9b93151a9c"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU1ODk1NQ==", "bodyText": "Suggested change:\nA topologyKey must match the label...", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3926#discussion_r520558955", "createdAt": "2020-11-10T13:25:35Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/configuring/proc-config-kafka-connect.adoc", "diffHunk": "@@ -159,8 +161,9 @@ Standard Apache Kafka configuration may be provided, restricted to those propert\n <12> xref:con-common-configuration-prometheus-reference[Prometheus metrics], which are enabled with configuration for the Prometheus JMX exporter in this example. You can enable metrics without further configuration using `metrics: {}`.\n <13> xref:con-common-configuration-jvm-reference[JVM configuration options] to optimize performance for the Virtual Machine (VM) running Kafka Connect.\n <14> ADVANCED OPTION: xref:con-common-configuration-images-reference[Container image configuration], which is recommended only in special situations.\n-<15> xref:assembly-customizing-kubernetes-resources-str[Template customization]. Here a pod is scheduled with anti-affinity, so the pod is not scheduled on nodes with the same hostname.\n-<16> Environment variables are also xref:ref-tracing-environment-variables-str[set for distributed tracing using Jaeger].\n+<15> Rack awareness is xref:type-Rack-reference[configured to spread replicas across different racks]. A `topology` key must match the label of a cluster node.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU1ODMzNQ=="}, "originalCommit": {"oid": "463c109613de9bdcf866acf9f252bc9b93151a9c"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU2MzQyMA==", "bodyText": "What does \"overriding container images\" refer to in this context? Omitting the brokerRackInitImage property?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3926#discussion_r520563420", "createdAt": "2020-11-10T13:32:41Z", "author": {"login": "laidan6000"}, "path": "documentation/api/io.strimzi.api.kafka.model.KafkaClusterSpec.adoc", "diffHunk": "@@ -93,3 +93,33 @@ spec:\n       zookeeper.connection.timeout.ms: 6000\n     # ...\n ----\n+\n+[id='property-kafka-brokerRackInitImage-{context}']\n+=== `brokerRackInitImage`\n+\n+When rack awareness is enabled, Kafka broker pods use init container to collect the labels from the Kubernetes cluster nodes.\n+The container image used for this container can be configured using the `brokerRackInitImage` property.\n+When the `brokerRackInitImage` field is missing, the following images are used in order of priority:\n+\n+. Container image specified in `STRIMZI_DEFAULT_KAFKA_INIT_IMAGE` environment variable in the Cluster Operator configuration.\n+. `{DockerKafkaInit}` container image.\n+\n+.Example `brokerRackInitImage` configuration\n+[source,yaml,subs=attributes+]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  kafka:\n+    # ...\n+    rack:\n+      topologyKey: topology.kubernetes.io/zone\n+    brokerRackInitImage: my-org/my-image:latest\n+    # ...\n+----\n+\n+NOTE: Overriding container images is recommended only in special situations, where you need to use a different container registry.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "463c109613de9bdcf866acf9f252bc9b93151a9c"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU2NDI2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For example, because your network does not allow access to the container repository used by Strimzi. In such a case, you should either copy the Strimzi images or build them from the source.\n          \n          \n            \n            For example, because your network does not allow access to the container registry used by Strimzi. In this case, you should either copy the Strimzi images or build them from the source.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3926#discussion_r520564263", "createdAt": "2020-11-10T13:34:04Z", "author": {"login": "laidan6000"}, "path": "documentation/api/io.strimzi.api.kafka.model.KafkaClusterSpec.adoc", "diffHunk": "@@ -93,3 +93,33 @@ spec:\n       zookeeper.connection.timeout.ms: 6000\n     # ...\n ----\n+\n+[id='property-kafka-brokerRackInitImage-{context}']\n+=== `brokerRackInitImage`\n+\n+When rack awareness is enabled, Kafka broker pods use init container to collect the labels from the Kubernetes cluster nodes.\n+The container image used for this container can be configured using the `brokerRackInitImage` property.\n+When the `brokerRackInitImage` field is missing, the following images are used in order of priority:\n+\n+. Container image specified in `STRIMZI_DEFAULT_KAFKA_INIT_IMAGE` environment variable in the Cluster Operator configuration.\n+. `{DockerKafkaInit}` container image.\n+\n+.Example `brokerRackInitImage` configuration\n+[source,yaml,subs=attributes+]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  kafka:\n+    # ...\n+    rack:\n+      topologyKey: topology.kubernetes.io/zone\n+    brokerRackInitImage: my-org/my-image:latest\n+    # ...\n+----\n+\n+NOTE: Overriding container images is recommended only in special situations, where you need to use a different container registry.\n+For example, because your network does not allow access to the container repository used by Strimzi. In such a case, you should either copy the Strimzi images or build them from the source.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "463c109613de9bdcf866acf9f252bc9b93151a9c"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU3NzkyNw==", "bodyText": "can't > cannot", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3926#discussion_r520577927", "createdAt": "2020-11-10T13:53:31Z", "author": {"login": "laidan6000"}, "path": "documentation/api/io.strimzi.api.kafka.model.Rack.adoc", "diffHunk": "@@ -0,0 +1,70 @@\n+Configures rack awareness to spread partition replicas across different racks.\n+\n+A _rack_ can represent an availability zone, data center, or an actual rack in your data center.\n+By configuring a `rack` for a Kafka cluster, consumers can fetch data from the closest replica.\n+This is useful for reducing the load on your network when a Kafka cluster spans multiple datacenters.\n+\n+To configure Kafka brokers for rack awareness, you specify a `topologyKey` value to match the label of the cluster node used by Kubernetes when scheduling Kafka broker pods to nodes.\n+\n+If the Kubernetes cluster is running on a cloud provider platform, the label must represent the availability zone where the node is running.\n+Usually, nodes are labeled with the `topology.kubernetes.io/zone` label (or `failure-domain.beta.kubernetes.io/zone` on older Kubernetes versions),\n+which can be used as the `topologyKey` value.\n+\n+The rack awareness configuration spreads the broker pods and partition replicas across zones, improving resiliency, and also sets a `broker.rack` configuration for each Kafka broker.\n+The `broker.rack` configuration assigns a rack ID to each broker.\n+\n+Consult your Kubernetes administrator regarding the node label that represents the zone or rack into which the node is deployed.\n+\n+.Example `rack` configuration for Kafka\n+[source,yaml,subs=attributes+]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  kafka:\n+    # ...\n+    rack:\n+      topologyKey: topology.kubernetes.io/zone\n+    config:\n+      # ...\n+      replica.selector.class: org.apache.kafka.common.replica.RackAwareReplicaSelector\n+    # ...\n+----\n+\n+Use the `RackAwareReplicaSelector` implementation for the Kafka `ReplicaSelector` plugin if you want clients to consume from the closest replica.\n+The `ReplicaSelector` plugin provides the logic that enables clients to consume from the nearest replica.\n+Specify `RackAwareReplicaSelector` for the `replica.selector.class` to switch from the default implementation.\n+The default implementation uses `LeaderSelector` to always select the leader replica for the client.\n+By switching from the leader replica to the replica follower, there is some cost to latency.\n+If required, you can also customize your own implementation.\n+\n+For clients, including Kafka Connect, you specify the same topology key as the broker that the client will use to consume messages.\n+\n+.Example `rack` configuration for Kafka Connect\n+[source,yaml,subs=attributes+]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: KafkaConnect\n+# ...\n+spec:\n+  kafka:\n+    # ...\n+    rack:\n+      topologyKey: topology.kubernetes.io/zone\n+    # ...\n+----\n+\n+The client is assigned a `client.rack` ID.\n+\n+`RackAwareReplicaSelector` associates matching `broker.rack` and `client.rack` IDs,\n+so the client can consume from the nearest replica.\n+\n+.Example showing client consuming from replicas in the same availability zone\n+image::rack-config-availability-zones.png[consuming from replicas in the same availability zone]\n+\n+If there are multiple replicas in the same rack, `RackAwareReplicaSelector` always selects the most up-to-date replica.\n+If the rack ID is not specified, or if it can\u2019t find a replica with the same rack ID, it will fall back to the leader replica.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "463c109613de9bdcf866acf9f252bc9b93151a9c"}, "originalPosition": 68}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "401cdad0b7e6a0e3ddcf30aca5cf7f5eddd6cc29", "author": {"user": {"login": "PaulRMellor", "name": null}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/401cdad0b7e6a0e3ddcf30aca5cf7f5eddd6cc29", "committedDate": "2020-11-11T17:29:16Z", "message": "review edits DL\n\nSigned-off-by: prmellor <pmellor@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5MjU5Njc0", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3926#pullrequestreview-529259674", "createdAt": "2020-11-12T16:23:42Z", "commit": {"oid": "401cdad0b7e6a0e3ddcf30aca5cf7f5eddd6cc29"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NTAyMDgx", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3926#pullrequestreview-529502081", "createdAt": "2020-11-12T21:14:01Z", "commit": {"oid": "401cdad0b7e6a0e3ddcf30aca5cf7f5eddd6cc29"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 889, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}