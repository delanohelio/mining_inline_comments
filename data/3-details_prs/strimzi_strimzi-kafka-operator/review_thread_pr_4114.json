{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQwNzQ2MDI0", "number": 4114, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMDoyMjoyNVrOFF3vyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTowODowM1rOFKz8Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNzAwNTUzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMDoyMjoyNVrOIGl9_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMjozMToxM1rOIHcB_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4NDQ0Ng==", "bodyText": "Not sure I understand why do we call this at the end. Could you please explain?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/4114#discussion_r543784446", "createdAt": "2020-12-16T00:22:25Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -563,6 +566,91 @@ private boolean needsReconfiguring(Reconciliation reconciliation, String connect\n         }\n     }\n \n+    private Future<Map<String, Object>> maybeRestartConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient, String connectorName, CustomResource resource, Map<String, Object> status) {\n+        if (hasRestartAnnotation(resource, connectorName)) {\n+            log.debug(\"{}: Restarting connector {}\", reconciliation, connectorName);\n+            return apiClient.restart(host, port, connectorName)\n+                    .compose(ignored -> removeRestartAnnotation(reconciliation, resource),\n+                        throwable -> {\n+                            // Ignore restart failures - just try again on the next reconcile\n+                            log.warn(\"{}: Failed to restart connector {}. {}\", reconciliation, connectorName, throwable.getMessage());\n+                            return Future.succeededFuture();\n+                        })\n+                    .compose(ignored -> apiClient.statusWithBackOff(new BackOff(200L, 2, 10), host, port,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eefc53e1a41f5a2dc0b1796298823d42f93b9519"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE2Nzg1Mw==", "bodyText": "I'm guessing because ultimately maybeCreateOrUpdateConnector needs to return the status. But it would probably be better to make pauseResume, maybeRestartConnector and maybeRestartConnectorTask all return Future<Void> and make the call the apiClient.statusWithBackOff directly from maybeCreateOrUpdateConnector.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/4114#discussion_r544167853", "createdAt": "2020-12-16T10:04:05Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -563,6 +566,91 @@ private boolean needsReconfiguring(Reconciliation reconciliation, String connect\n         }\n     }\n \n+    private Future<Map<String, Object>> maybeRestartConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient, String connectorName, CustomResource resource, Map<String, Object> status) {\n+        if (hasRestartAnnotation(resource, connectorName)) {\n+            log.debug(\"{}: Restarting connector {}\", reconciliation, connectorName);\n+            return apiClient.restart(host, port, connectorName)\n+                    .compose(ignored -> removeRestartAnnotation(reconciliation, resource),\n+                        throwable -> {\n+                            // Ignore restart failures - just try again on the next reconcile\n+                            log.warn(\"{}: Failed to restart connector {}. {}\", reconciliation, connectorName, throwable.getMessage());\n+                            return Future.succeededFuture();\n+                        })\n+                    .compose(ignored -> apiClient.statusWithBackOff(new BackOff(200L, 2, 10), host, port,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4NDQ0Ng=="}, "originalCommit": {"oid": "eefc53e1a41f5a2dc0b1796298823d42f93b9519"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIwMDcxMA==", "bodyText": "Yeah, that is why I wondered about this. If it is about the status for the KafkaConnector status field, it should be probably called only at the end.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/4114#discussion_r544200710", "createdAt": "2020-12-16T10:53:38Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -563,6 +566,91 @@ private boolean needsReconfiguring(Reconciliation reconciliation, String connect\n         }\n     }\n \n+    private Future<Map<String, Object>> maybeRestartConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient, String connectorName, CustomResource resource, Map<String, Object> status) {\n+        if (hasRestartAnnotation(resource, connectorName)) {\n+            log.debug(\"{}: Restarting connector {}\", reconciliation, connectorName);\n+            return apiClient.restart(host, port, connectorName)\n+                    .compose(ignored -> removeRestartAnnotation(reconciliation, resource),\n+                        throwable -> {\n+                            // Ignore restart failures - just try again on the next reconcile\n+                            log.warn(\"{}: Failed to restart connector {}. {}\", reconciliation, connectorName, throwable.getMessage());\n+                            return Future.succeededFuture();\n+                        })\n+                    .compose(ignored -> apiClient.statusWithBackOff(new BackOff(200L, 2, 10), host, port,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4NDQ0Ng=="}, "originalCommit": {"oid": "eefc53e1a41f5a2dc0b1796298823d42f93b9519"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY3MDIwNg==", "bodyText": "Thanks for the review - Tom is correct here & I have updated to move the apiClient.statusWithBackOff call to the end of the compose chains.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/4114#discussion_r544670206", "createdAt": "2020-12-16T22:31:13Z", "author": {"login": "ajborley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -563,6 +566,91 @@ private boolean needsReconfiguring(Reconciliation reconciliation, String connect\n         }\n     }\n \n+    private Future<Map<String, Object>> maybeRestartConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient, String connectorName, CustomResource resource, Map<String, Object> status) {\n+        if (hasRestartAnnotation(resource, connectorName)) {\n+            log.debug(\"{}: Restarting connector {}\", reconciliation, connectorName);\n+            return apiClient.restart(host, port, connectorName)\n+                    .compose(ignored -> removeRestartAnnotation(reconciliation, resource),\n+                        throwable -> {\n+                            // Ignore restart failures - just try again on the next reconcile\n+                            log.warn(\"{}: Failed to restart connector {}. {}\", reconciliation, connectorName, throwable.getMessage());\n+                            return Future.succeededFuture();\n+                        })\n+                    .compose(ignored -> apiClient.statusWithBackOff(new BackOff(200L, 2, 10), host, port,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4NDQ0Ng=="}, "originalCommit": {"oid": "eefc53e1a41f5a2dc0b1796298823d42f93b9519"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTQ4MDA1OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDowMToyOVrOIG9Q1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODoyODowNVrOIHp_lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE2NjEwMg==", "bodyText": "I wonder if we should support a list of ids. It would make it simpler to restart several failed tasks.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/4114#discussion_r544166102", "createdAt": "2020-12-16T10:01:29Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -563,6 +566,91 @@ private boolean needsReconfiguring(Reconciliation reconciliation, String connect\n         }\n     }\n \n+    private Future<Map<String, Object>> maybeRestartConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient, String connectorName, CustomResource resource, Map<String, Object> status) {\n+        if (hasRestartAnnotation(resource, connectorName)) {\n+            log.debug(\"{}: Restarting connector {}\", reconciliation, connectorName);\n+            return apiClient.restart(host, port, connectorName)\n+                    .compose(ignored -> removeRestartAnnotation(reconciliation, resource),\n+                        throwable -> {\n+                            // Ignore restart failures - just try again on the next reconcile\n+                            log.warn(\"{}: Failed to restart connector {}. {}\", reconciliation, connectorName, throwable.getMessage());\n+                            return Future.succeededFuture();\n+                        })\n+                    .compose(ignored -> apiClient.statusWithBackOff(new BackOff(200L, 2, 10), host, port,\n+                        connectorName));\n+        } else {\n+            return Future.succeededFuture(status);\n+        }\n+    }\n+\n+    private Future<Map<String, Object>> maybeRestartConnectorTask(Reconciliation reconciliation, String host, KafkaConnectApi apiClient, String connectorName, CustomResource resource, Map<String, Object> status) {\n+        int taskID = getRestartTaskAnnotationTaskID(resource, connectorName);\n+        if (taskID >= 0) {\n+            log.debug(\"{}: Restarting connector task {}:{}\", reconciliation, connectorName, taskID);\n+            return apiClient.restartTask(host, port, connectorName, taskID)\n+                    .compose(ignored -> removeRestartTaskAnnotation(reconciliation, resource),\n+                        throwable -> {\n+                            // Ignore restart failures - just try again on the next reconcile\n+                            log.warn(\"{}: Failed to restart connector task {}:{}. {}\", reconciliation, connectorName, taskID, throwable.getMessage());\n+                            return Future.succeededFuture();\n+                        })\n+                    .compose(ignored -> apiClient.statusWithBackOff(new BackOff(200L, 2, 10), host, port,\n+                        connectorName));\n+        } else {\n+            return Future.succeededFuture(status);\n+        }\n+    }\n+\n+    /**\n+     * Whether the provided resource instance is a KafkaConnector and has the strimzi.io/restart annotation\n+     *\n+     * @param resource resource instance to check\n+     * @param resource connectorName name of the connector to check\n+     * @return true if the provided resource instance has the strimzi.io/restart annotation; false otherwise\n+     */\n+    protected boolean hasRestartAnnotation(CustomResource resource, String connectorName) {\n+        return Annotations.booleanAnnotation(resource, ANNO_STRIMZI_IO_RESTART, false);\n+    }\n+\n+    /**\n+     * Return the ID of the connector task to be restarted if the provided KafkaConnector resource instance has the strimzio.io/restart-task annotation\n+     *\n+     * @param resource resource instance to check\n+     * @param connectorName KafkaConnector resource instance to check\n+     * @return the ID of the task to be restarted if the provided KafkaConnector resource instance has the strimzio.io/restart-task annotation or -1 otherwise.\n+     */\n+    protected int getRestartTaskAnnotationTaskID(CustomResource resource, String connectorName) {\n+        return Annotations.intAnnotation(resource, ANNO_STRIMZI_IO_RESTART_TASK, -1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eefc53e1a41f5a2dc0b1796298823d42f93b9519"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY3OTE5MA==", "bodyText": "Thanks for the review. I have started looking into this - it should be possible to restart tasks on a KafkaConnector resource using an annotation like: strimzi.io/restart-tasks: \"0 1 2\", although it does raise some questions:\n\nwhat should happen if one of the restart calls fails (e.g. maybe there is no task 2)? Should the annotation be altered to only include the task IDs that were not restarted, so that they can be attempted on the next reconcile?\nwhat should the annotation look like for KafkaMirrorMaker2 resources? The code currently supports annotations that address a single MM2 connector task like: strimzi.io/restart-connector-tasks: \"<MM2-connector-name>:<task-id>\". Do you think it should allow multiple MM2 connectors to be specified? Or just multiple tasks for a single connector? For example strimzi.io/restart-connector-tasks: \"<MM2-connector-name>:0 1 2\"", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/4114#discussion_r544679190", "createdAt": "2020-12-16T22:48:18Z", "author": {"login": "ajborley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -563,6 +566,91 @@ private boolean needsReconfiguring(Reconciliation reconciliation, String connect\n         }\n     }\n \n+    private Future<Map<String, Object>> maybeRestartConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient, String connectorName, CustomResource resource, Map<String, Object> status) {\n+        if (hasRestartAnnotation(resource, connectorName)) {\n+            log.debug(\"{}: Restarting connector {}\", reconciliation, connectorName);\n+            return apiClient.restart(host, port, connectorName)\n+                    .compose(ignored -> removeRestartAnnotation(reconciliation, resource),\n+                        throwable -> {\n+                            // Ignore restart failures - just try again on the next reconcile\n+                            log.warn(\"{}: Failed to restart connector {}. {}\", reconciliation, connectorName, throwable.getMessage());\n+                            return Future.succeededFuture();\n+                        })\n+                    .compose(ignored -> apiClient.statusWithBackOff(new BackOff(200L, 2, 10), host, port,\n+                        connectorName));\n+        } else {\n+            return Future.succeededFuture(status);\n+        }\n+    }\n+\n+    private Future<Map<String, Object>> maybeRestartConnectorTask(Reconciliation reconciliation, String host, KafkaConnectApi apiClient, String connectorName, CustomResource resource, Map<String, Object> status) {\n+        int taskID = getRestartTaskAnnotationTaskID(resource, connectorName);\n+        if (taskID >= 0) {\n+            log.debug(\"{}: Restarting connector task {}:{}\", reconciliation, connectorName, taskID);\n+            return apiClient.restartTask(host, port, connectorName, taskID)\n+                    .compose(ignored -> removeRestartTaskAnnotation(reconciliation, resource),\n+                        throwable -> {\n+                            // Ignore restart failures - just try again on the next reconcile\n+                            log.warn(\"{}: Failed to restart connector task {}:{}. {}\", reconciliation, connectorName, taskID, throwable.getMessage());\n+                            return Future.succeededFuture();\n+                        })\n+                    .compose(ignored -> apiClient.statusWithBackOff(new BackOff(200L, 2, 10), host, port,\n+                        connectorName));\n+        } else {\n+            return Future.succeededFuture(status);\n+        }\n+    }\n+\n+    /**\n+     * Whether the provided resource instance is a KafkaConnector and has the strimzi.io/restart annotation\n+     *\n+     * @param resource resource instance to check\n+     * @param resource connectorName name of the connector to check\n+     * @return true if the provided resource instance has the strimzi.io/restart annotation; false otherwise\n+     */\n+    protected boolean hasRestartAnnotation(CustomResource resource, String connectorName) {\n+        return Annotations.booleanAnnotation(resource, ANNO_STRIMZI_IO_RESTART, false);\n+    }\n+\n+    /**\n+     * Return the ID of the connector task to be restarted if the provided KafkaConnector resource instance has the strimzio.io/restart-task annotation\n+     *\n+     * @param resource resource instance to check\n+     * @param connectorName KafkaConnector resource instance to check\n+     * @return the ID of the task to be restarted if the provided KafkaConnector resource instance has the strimzio.io/restart-task annotation or -1 otherwise.\n+     */\n+    protected int getRestartTaskAnnotationTaskID(CustomResource resource, String connectorName) {\n+        return Annotations.intAnnotation(resource, ANNO_STRIMZI_IO_RESTART_TASK, -1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE2NjEwMg=="}, "originalCommit": {"oid": "eefc53e1a41f5a2dc0b1796298823d42f93b9519"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg5ODk2NQ==", "bodyText": "These are good points. I guess it might be a good idea to leave this idea for now and see how this stuff is used in practice. It seems like it would be easy enough to add at a later date.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/4114#discussion_r544898965", "createdAt": "2020-12-17T08:28:05Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -563,6 +566,91 @@ private boolean needsReconfiguring(Reconciliation reconciliation, String connect\n         }\n     }\n \n+    private Future<Map<String, Object>> maybeRestartConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient, String connectorName, CustomResource resource, Map<String, Object> status) {\n+        if (hasRestartAnnotation(resource, connectorName)) {\n+            log.debug(\"{}: Restarting connector {}\", reconciliation, connectorName);\n+            return apiClient.restart(host, port, connectorName)\n+                    .compose(ignored -> removeRestartAnnotation(reconciliation, resource),\n+                        throwable -> {\n+                            // Ignore restart failures - just try again on the next reconcile\n+                            log.warn(\"{}: Failed to restart connector {}. {}\", reconciliation, connectorName, throwable.getMessage());\n+                            return Future.succeededFuture();\n+                        })\n+                    .compose(ignored -> apiClient.statusWithBackOff(new BackOff(200L, 2, 10), host, port,\n+                        connectorName));\n+        } else {\n+            return Future.succeededFuture(status);\n+        }\n+    }\n+\n+    private Future<Map<String, Object>> maybeRestartConnectorTask(Reconciliation reconciliation, String host, KafkaConnectApi apiClient, String connectorName, CustomResource resource, Map<String, Object> status) {\n+        int taskID = getRestartTaskAnnotationTaskID(resource, connectorName);\n+        if (taskID >= 0) {\n+            log.debug(\"{}: Restarting connector task {}:{}\", reconciliation, connectorName, taskID);\n+            return apiClient.restartTask(host, port, connectorName, taskID)\n+                    .compose(ignored -> removeRestartTaskAnnotation(reconciliation, resource),\n+                        throwable -> {\n+                            // Ignore restart failures - just try again on the next reconcile\n+                            log.warn(\"{}: Failed to restart connector task {}:{}. {}\", reconciliation, connectorName, taskID, throwable.getMessage());\n+                            return Future.succeededFuture();\n+                        })\n+                    .compose(ignored -> apiClient.statusWithBackOff(new BackOff(200L, 2, 10), host, port,\n+                        connectorName));\n+        } else {\n+            return Future.succeededFuture(status);\n+        }\n+    }\n+\n+    /**\n+     * Whether the provided resource instance is a KafkaConnector and has the strimzi.io/restart annotation\n+     *\n+     * @param resource resource instance to check\n+     * @param resource connectorName name of the connector to check\n+     * @return true if the provided resource instance has the strimzi.io/restart annotation; false otherwise\n+     */\n+    protected boolean hasRestartAnnotation(CustomResource resource, String connectorName) {\n+        return Annotations.booleanAnnotation(resource, ANNO_STRIMZI_IO_RESTART, false);\n+    }\n+\n+    /**\n+     * Return the ID of the connector task to be restarted if the provided KafkaConnector resource instance has the strimzio.io/restart-task annotation\n+     *\n+     * @param resource resource instance to check\n+     * @param connectorName KafkaConnector resource instance to check\n+     * @return the ID of the task to be restarted if the provided KafkaConnector resource instance has the strimzio.io/restart-task annotation or -1 otherwise.\n+     */\n+    protected int getRestartTaskAnnotationTaskID(CustomResource resource, String connectorName) {\n+        return Annotations.intAnnotation(resource, ANNO_STRIMZI_IO_RESTART_TASK, -1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE2NjEwMg=="}, "originalCommit": {"oid": "eefc53e1a41f5a2dc0b1796298823d42f93b9519"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNDUxNjY1OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwODozNToyN1rOIHqQ1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxNTo0MjoyNVrOIKodmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkwMzM4Mg==", "bodyText": "I have my doubts about this, particularly in the case that the connector task doesn't exist (i.e. bad id, presumably an http 404). If it's only in the logs then the user might not realise why the annotation wasn't removed. For transient errors it will likely succeed, so leaving it in the annotation for another try is not a bad idea. But for permanent errors like non-existence its more of a problem, especially if the user doesn't have access to the logs. I think we should propagate the error as a warning in the status.\nThe error case doesn't seem to be covered by the tests.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/4114#discussion_r544903382", "createdAt": "2020-12-17T08:35:27Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -544,25 +549,98 @@ private boolean needsReconfiguring(Reconciliation reconciliation, String connect\n             boolean shouldPause = Boolean.TRUE.equals(connectorSpec.getPause());\n             if (\"RUNNING\".equals(state) && shouldPause) {\n                 log.debug(\"{}: Pausing connector {}\", reconciliation, connectorName);\n-                return apiClient.pause(host, port,\n-                        connectorName)\n-                        .compose(ignored ->\n-                                apiClient.status(host, port,\n-                                        connectorName));\n+                return apiClient.pause(host, port, connectorName);\n             } else if (\"PAUSED\".equals(state) && !shouldPause) {\n                 log.debug(\"{}: Resuming connector {}\", reconciliation, connectorName);\n-                return apiClient.resume(host, port,\n-                        connectorName)\n-                        .compose(ignored ->\n-                                apiClient.status(host, port,\n-                                        connectorName));\n-\n+                return apiClient.resume(host, port, connectorName);\n             } else {\n-                return Future.succeededFuture(status);\n+                return Future.succeededFuture();\n             }\n         }\n     }\n \n+    private Future<Void> maybeRestartConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient, String connectorName, CustomResource resource) {\n+        if (hasRestartAnnotation(resource, connectorName)) {\n+            log.debug(\"{}: Restarting connector {}\", reconciliation, connectorName);\n+            return apiClient.restart(host, port, connectorName)\n+                    .compose(ignored -> removeRestartAnnotation(reconciliation, resource),\n+                        throwable -> {\n+                            // Ignore restart failures - just try again on the next reconcile\n+                            log.warn(\"{}: Failed to restart connector {}. {}\", reconciliation, connectorName, throwable.getMessage());\n+                            return Future.succeededFuture();\n+                        });\n+        } else {\n+            return Future.succeededFuture();\n+        }\n+    }\n+\n+    private Future<Void> maybeRestartConnectorTask(Reconciliation reconciliation, String host, KafkaConnectApi apiClient, String connectorName, CustomResource resource) {\n+        int taskID = getRestartTaskAnnotationTaskID(resource, connectorName);\n+        if (taskID >= 0) {\n+            log.debug(\"{}: Restarting connector task {}:{}\", reconciliation, connectorName, taskID);\n+            return apiClient.restartTask(host, port, connectorName, taskID)\n+                    .compose(ignored -> removeRestartTaskAnnotation(reconciliation, resource),\n+                        throwable -> {\n+                            // Ignore restart failures - just try again on the next reconcile\n+                            log.warn(\"{}: Failed to restart connector task {}:{}. {}\", reconciliation, connectorName, taskID, throwable.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40ab8eda1e05204d00ecf60fc09e34720706710b"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAxOTYxMA==", "bodyText": "The latest commit adds warning status conditions to the CR when the restart or restartTask REST calls fail. Have also added failure test cases.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/4114#discussion_r548019610", "createdAt": "2020-12-23T15:42:25Z", "author": {"login": "ajborley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -544,25 +549,98 @@ private boolean needsReconfiguring(Reconciliation reconciliation, String connect\n             boolean shouldPause = Boolean.TRUE.equals(connectorSpec.getPause());\n             if (\"RUNNING\".equals(state) && shouldPause) {\n                 log.debug(\"{}: Pausing connector {}\", reconciliation, connectorName);\n-                return apiClient.pause(host, port,\n-                        connectorName)\n-                        .compose(ignored ->\n-                                apiClient.status(host, port,\n-                                        connectorName));\n+                return apiClient.pause(host, port, connectorName);\n             } else if (\"PAUSED\".equals(state) && !shouldPause) {\n                 log.debug(\"{}: Resuming connector {}\", reconciliation, connectorName);\n-                return apiClient.resume(host, port,\n-                        connectorName)\n-                        .compose(ignored ->\n-                                apiClient.status(host, port,\n-                                        connectorName));\n-\n+                return apiClient.resume(host, port, connectorName);\n             } else {\n-                return Future.succeededFuture(status);\n+                return Future.succeededFuture();\n             }\n         }\n     }\n \n+    private Future<Void> maybeRestartConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient, String connectorName, CustomResource resource) {\n+        if (hasRestartAnnotation(resource, connectorName)) {\n+            log.debug(\"{}: Restarting connector {}\", reconciliation, connectorName);\n+            return apiClient.restart(host, port, connectorName)\n+                    .compose(ignored -> removeRestartAnnotation(reconciliation, resource),\n+                        throwable -> {\n+                            // Ignore restart failures - just try again on the next reconcile\n+                            log.warn(\"{}: Failed to restart connector {}. {}\", reconciliation, connectorName, throwable.getMessage());\n+                            return Future.succeededFuture();\n+                        });\n+        } else {\n+            return Future.succeededFuture();\n+        }\n+    }\n+\n+    private Future<Void> maybeRestartConnectorTask(Reconciliation reconciliation, String host, KafkaConnectApi apiClient, String connectorName, CustomResource resource) {\n+        int taskID = getRestartTaskAnnotationTaskID(resource, connectorName);\n+        if (taskID >= 0) {\n+            log.debug(\"{}: Restarting connector task {}:{}\", reconciliation, connectorName, taskID);\n+            return apiClient.restartTask(host, port, connectorName, taskID)\n+                    .compose(ignored -> removeRestartTaskAnnotation(reconciliation, resource),\n+                        throwable -> {\n+                            // Ignore restart failures - just try again on the next reconcile\n+                            log.warn(\"{}: Failed to restart connector task {}:{}. {}\", reconciliation, connectorName, taskID, throwable.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkwMzM4Mg=="}, "originalCommit": {"oid": "40ab8eda1e05204d00ecf60fc09e34720706710b"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNzk0NjI2OnYy", "diffSide": "RIGHT", "path": "documentation/assemblies/deploying/assembly-deploy-kafka-connect.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMTozMzowNlrOIIJoRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxNTo0MDo0OVrOIKoa0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxNzI4Ng==", "bodyText": "Was it intentional to remove include::modules/proc-deploying-kafkaconnector.adoc[leveloffset=+1]? I do not see it included anywhere else.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/4114#discussion_r545417286", "createdAt": "2020-12-17T21:33:06Z", "author": {"login": "scholzj"}, "path": "documentation/assemblies/deploying/assembly-deploy-kafka-connect.adoc", "diffHunk": "@@ -34,5 +36,7 @@ include::../../modules/configuring/con-config-kafka-connect-multiple-instances.a\n include::assembly-deploy-kafka-connect-with-plugins.adoc[leveloffset=+1]\n //Overview of creating connectors through API\n include::modules/con-deploy-kafka-connect-managing-connectors.adoc[leveloffset=+1]\n-//Procedure to deploy a KafkaConnector resource\n-include::modules/proc-deploying-kafkaconnector.adoc[leveloffset=+1]\n+//Procedure to restart a Kafka connector\n+include::../../modules/proc-manual-restart-connector.adoc[leveloffset=+1]\n+//Procedure to restart a Kafka connector task\n+include::../../modules/proc-manual-restart-connector-task.adoc[leveloffset=+1]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3717e20dd2aa7ea9c78fa0d4dd13f282c20ba76"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAxODg5OQ==", "bodyText": "No, that was accidental. Thanks for spotting it, have reinstated.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/4114#discussion_r548018899", "createdAt": "2020-12-23T15:40:49Z", "author": {"login": "ajborley"}, "path": "documentation/assemblies/deploying/assembly-deploy-kafka-connect.adoc", "diffHunk": "@@ -34,5 +36,7 @@ include::../../modules/configuring/con-config-kafka-connect-multiple-instances.a\n include::assembly-deploy-kafka-connect-with-plugins.adoc[leveloffset=+1]\n //Overview of creating connectors through API\n include::modules/con-deploy-kafka-connect-managing-connectors.adoc[leveloffset=+1]\n-//Procedure to deploy a KafkaConnector resource\n-include::modules/proc-deploying-kafkaconnector.adoc[leveloffset=+1]\n+//Procedure to restart a Kafka connector\n+include::../../modules/proc-manual-restart-connector.adoc[leveloffset=+1]\n+//Procedure to restart a Kafka connector task\n+include::../../modules/proc-manual-restart-connector-task.adoc[leveloffset=+1]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxNzI4Ng=="}, "originalCommit": {"oid": "e3717e20dd2aa7ea9c78fa0d4dd13f282c20ba76"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2ODgwMTQ2OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTowNToxMlrOINp7nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTo1OToyNlrOINroCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTE4OTQwNQ==", "bodyText": "Needs amending", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/4114#discussion_r551189405", "createdAt": "2021-01-04T09:05:12Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -476,28 +480,34 @@ protected KafkaConnectApi getKafkaConnectApi() {\n      * @param apiClient The client instance.\n      * @param connectorName The connector name.\n      * @param connectorSpec The desired connector spec.\n+     * @param resource The resource that defines the connector.\n      * @return A Future whose result, when successfully completed, is a map of the current connector state.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "456fe3e859f265ed7d0d6cfa7ffc38fbb1e91fe7"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNzE2Mg==", "bodyText": "Done", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/4114#discussion_r551217162", "createdAt": "2021-01-04T09:59:26Z", "author": {"login": "ajborley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -476,28 +480,34 @@ protected KafkaConnectApi getKafkaConnectApi() {\n      * @param apiClient The client instance.\n      * @param connectorName The connector name.\n      * @param connectorSpec The desired connector spec.\n+     * @param resource The resource that defines the connector.\n      * @return A Future whose result, when successfully completed, is a map of the current connector state.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTE4OTQwNQ=="}, "originalCommit": {"oid": "456fe3e859f265ed7d0d6cfa7ffc38fbb1e91fe7"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2ODgxMTE1OnYy", "diffSide": "RIGHT", "path": "documentation/modules/proc-manual-restart-connector.adoc", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTowODowM1rOINqBBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMFQxNDoyOTo0OVrOIQ4mUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTE5MDc4OA==", "bodyText": "I wonder if this should be restart-connector, so it's consistent with restart-task?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/4114#discussion_r551190788", "createdAt": "2021-01-04T09:08:03Z", "author": {"login": "tombentley"}, "path": "documentation/modules/proc-manual-restart-connector.adoc", "diffHunk": "@@ -0,0 +1,27 @@\n+// Module included in the following assemblies:\n+//\n+//\n+\n+[id='proc-manual-restart-connector-{context}']\n+= Performing a restart of a Kafka connector\n+\n+This procedure describes how to manually trigger a restart of a Kafka connector by using a Kubernetes annotation.\n+\n+.Prerequisites\n+\n+* The Cluster Operator is running.\n+\n+.Procedure\n+\n+. Find the name of the `KafkaConnector` custom resource that controls the Kafka connector you want to restart:\n+[source,shell,subs=+quotes]\n+kubectl get KafkaConnector\n+\n+. To restart the connector, annotate the `KafkaConnector` resource in Kubernetes.\n+For example, using `kubectl annotate`:\n+[source,shell,subs=+quotes]\n+kubectl annotate KafkaConnector _KafkaConnector-name_ strimzi.io/restart=true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "456fe3e859f265ed7d0d6cfa7ffc38fbb1e91fe7"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNzE5NQ==", "bodyText": "Similar questions around this were raised in the proposal discussion:\n\nstrimzi/proposals#8 (comment)\nstrimzi/proposals#8 (comment)\nstrimzi/proposals#8 (comment)\n\nFor KafkaConnnector this PR has the 2 annotations which apply to the resource they are being applied to:\n\nstrimzi.io/restart=true\nstrimzi.io/restart-task=<TASK-ID>\n\nAnd for KafkaMirrorMaker2 this PR supports annotations that refer to a single connector or task amongst potentially many that are managed by the resource:\n\nstrimzi.io/restart-connector=<MM2-CONNECTOR-NAME>\nstrimzi.io/restart-connector-task=<MM2-CONNECTOR-NAME>:<TASK-ID>\n\nWith this style it's clear which annotations apply to which resource (and which connector/task is being restarted).\nIf people think it would be clearer, I am fine to change this to use the same annotations for both KafkaConnnector and KafkaMirrorMaker2, - e.g:\nFor KafkaConnnector:\n\nstrimzi.io/restart-connector=true\nstrimzi.io/restart-connector-task=<TASK-ID>\n\nFor KafkaMirrorMaker2:\n\nstrimzi.io/restart-connector=<MM2-CONNECTOR-NAME>\nstrimzi.io/restart-connector-task=<MM2-CONNECTOR-NAME>:<TASK-ID>\n\nWhat do you think?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/4114#discussion_r551217195", "createdAt": "2021-01-04T09:59:29Z", "author": {"login": "ajborley"}, "path": "documentation/modules/proc-manual-restart-connector.adoc", "diffHunk": "@@ -0,0 +1,27 @@\n+// Module included in the following assemblies:\n+//\n+//\n+\n+[id='proc-manual-restart-connector-{context}']\n+= Performing a restart of a Kafka connector\n+\n+This procedure describes how to manually trigger a restart of a Kafka connector by using a Kubernetes annotation.\n+\n+.Prerequisites\n+\n+* The Cluster Operator is running.\n+\n+.Procedure\n+\n+. Find the name of the `KafkaConnector` custom resource that controls the Kafka connector you want to restart:\n+[source,shell,subs=+quotes]\n+kubectl get KafkaConnector\n+\n+. To restart the connector, annotate the `KafkaConnector` resource in Kubernetes.\n+For example, using `kubectl annotate`:\n+[source,shell,subs=+quotes]\n+kubectl annotate KafkaConnector _KafkaConnector-name_ strimzi.io/restart=true", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTE5MDc4OA=="}, "originalCommit": {"oid": "456fe3e859f265ed7d0d6cfa7ffc38fbb1e91fe7"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxOTg2MA==", "bodyText": "I think I prefer the second option, even though it means the values are different between KafkaConnector and KMM2 while the keys are the same. WDYT @ppatierno ?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/4114#discussion_r551219860", "createdAt": "2021-01-04T10:05:00Z", "author": {"login": "tombentley"}, "path": "documentation/modules/proc-manual-restart-connector.adoc", "diffHunk": "@@ -0,0 +1,27 @@\n+// Module included in the following assemblies:\n+//\n+//\n+\n+[id='proc-manual-restart-connector-{context}']\n+= Performing a restart of a Kafka connector\n+\n+This procedure describes how to manually trigger a restart of a Kafka connector by using a Kubernetes annotation.\n+\n+.Prerequisites\n+\n+* The Cluster Operator is running.\n+\n+.Procedure\n+\n+. Find the name of the `KafkaConnector` custom resource that controls the Kafka connector you want to restart:\n+[source,shell,subs=+quotes]\n+kubectl get KafkaConnector\n+\n+. To restart the connector, annotate the `KafkaConnector` resource in Kubernetes.\n+For example, using `kubectl annotate`:\n+[source,shell,subs=+quotes]\n+kubectl annotate KafkaConnector _KafkaConnector-name_ strimzi.io/restart=true", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTE5MDc4OA=="}, "originalCommit": {"oid": "456fe3e859f265ed7d0d6cfa7ffc38fbb1e91fe7"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDU3NTQ0Mw==", "bodyText": "Not sure, I think I prefer the first option but I have not a strong opinion tbh. Both of them are valid. The doubt on the second option is around the fact that it could be confusing for users to see the same annotation names but getting different values (bool vs string) even if in two different resources. Anyway, I am fine with both, in the end it's a matter of documenting the difference.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/4114#discussion_r554575443", "createdAt": "2021-01-10T14:29:49Z", "author": {"login": "ppatierno"}, "path": "documentation/modules/proc-manual-restart-connector.adoc", "diffHunk": "@@ -0,0 +1,27 @@\n+// Module included in the following assemblies:\n+//\n+//\n+\n+[id='proc-manual-restart-connector-{context}']\n+= Performing a restart of a Kafka connector\n+\n+This procedure describes how to manually trigger a restart of a Kafka connector by using a Kubernetes annotation.\n+\n+.Prerequisites\n+\n+* The Cluster Operator is running.\n+\n+.Procedure\n+\n+. Find the name of the `KafkaConnector` custom resource that controls the Kafka connector you want to restart:\n+[source,shell,subs=+quotes]\n+kubectl get KafkaConnector\n+\n+. To restart the connector, annotate the `KafkaConnector` resource in Kubernetes.\n+For example, using `kubectl annotate`:\n+[source,shell,subs=+quotes]\n+kubectl annotate KafkaConnector _KafkaConnector-name_ strimzi.io/restart=true", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTE5MDc4OA=="}, "originalCommit": {"oid": "456fe3e859f265ed7d0d6cfa7ffc38fbb1e91fe7"}, "originalPosition": 23}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 862, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}