{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3MTQyNzUx", "number": 3002, "title": "Kafka Rebalance operator tests", "bodyText": "Type of change\n\nEnhancement / new feature\n\nDescription\nThis PR adds tests for the Kafka Rebalance operator, checking the internal state machine and the reconcile loop.\nChecklist\nPlease go through this checklist and make sure all applicable tasks have been done\n\n Update/write design documentation in ./design\n Write tests\n Make sure all tests pass\n Update documentation\n Check RBAC rights for Kubernetes / OpenShift roles\n Try your changes from Pod inside your Kubernetes and OpenShift cluster, not just locally\n Reference relevant issue(s) and close them after merging\n Update CHANGELOG.md", "createdAt": "2020-05-13T06:18:12Z", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002", "merged": true, "mergeCommit": {"oid": "b54c5c070447adc0bfa8795867e3539c22a6f853"}, "closed": true, "closedAt": "2020-05-15T12:07:10Z", "author": {"login": "ppatierno"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcg1bOjAFqTQxMDc0NzA4Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABchelG6AH2gAyNDE3MTQyNzUxOmExMDY2ZmE2ZTFjZTAxY2U5ZDVkOGExOGViOWNhZGNkM2U3NjhhMzU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNzQ3MDgy", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#pullrequestreview-410747082", "createdAt": "2020-05-13T09:26:23Z", "commit": {"oid": "2d3dfe79821301c894b540952e1a93116d4b3c21"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNzg3NjA4", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#pullrequestreview-410787608", "createdAt": "2020-05-13T10:20:22Z", "commit": {"oid": "2d3dfe79821301c894b540952e1a93116d4b3c21"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMDoyMDoyMlrOGUrGfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMDozNToyNlrOGUrl3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzMDg3Ng==", "bodyText": "Probably worth having an exception class for this, since fail(String) uses the unhelpful NoStackTraceThrowable which (I'm guessing) could propagate to the CR status condition.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424330876", "createdAt": "2020-05-13T10:20:22Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlApiImpl.java", "diffHunk": "@@ -116,18 +115,18 @@ public CruiseControlApiImpl(Vertx vertx) {\n                         response.bodyHandler(buffer -> {\n                             String userTaskID = response.getHeader(CC_REST_API_USER_ID_HEADER);\n                             JsonObject json = buffer.toJsonObject();\n-                            CruiseControlRebalanceResponse ccResponse = new CruiseControlRebalanceResponse(userTaskID, json);\n                             if (json.containsKey(CC_REST_API_ERROR_KEY)) {\n                                 // If there was a client side error, check whether it was due to not enough data being available\n                                 if (json.getString(CC_REST_API_ERROR_KEY).contains(\"NotEnoughValidWindowsException\")) {\n+                                    CruiseControlRebalanceResponse ccResponse = new CruiseControlRebalanceResponse(userTaskID, json);\n                                     ccResponse.setNotEnoughDataForProposal(true);\n                                     result.complete(ccResponse);\n                                 } else {\n                                     // If there was any other kind of error propagate this to the operator\n                                     result.fail(json.getString(CC_REST_API_ERROR_KEY));\n                                 }\n                             } else {\n-                                result.complete(ccResponse);\n+                                result.fail(json.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d3dfe79821301c894b540952e1a93116d4b3c21"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzMTQ2Mw==", "bodyText": "Same comment, I think we need a CruiseControlException or similar. Also is this error key the only piece of relevant info to include?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424331463", "createdAt": "2020-05-13T10:21:30Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlApiImpl.java", "diffHunk": "@@ -176,15 +175,22 @@ public CruiseControlApiImpl(Vertx vertx) {\n                         String userTaskID = response.getHeader(CC_REST_API_USER_ID_HEADER);\n                         response.bodyHandler(buffer -> {\n                             JsonObject jsonUserTask = buffer.toJsonObject().getJsonArray(\"userTasks\").getJsonObject(0);\n-                            JsonObject json = new JsonObject()\n-                                    .put(\"Status\", jsonUserTask.getString(\"Status\"))\n-                                    .put(\"summary\", ((JsonObject) Json.decodeValue(jsonUserTask.getString(\"originalResponse\"))).getJsonObject(\"summary\"));\n-                            if (json.containsKey(CC_REST_API_ERROR_KEY)) {\n-                                result.fail(json.getString(CC_REST_API_ERROR_KEY));\n-                            } else {\n-                                CruiseControlUserTaskResponse ccResponse = new CruiseControlUserTaskResponse(userTaskID, json);\n-                                result.complete(ccResponse);\n+                            // This should not be an error with a 200 status but we play it safe\n+                            if (jsonUserTask.containsKey(CC_REST_API_ERROR_KEY)) {\n+                                result.fail(jsonUserTask.getString(CC_REST_API_ERROR_KEY));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d3dfe79821301c894b540952e1a93116d4b3c21"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzMjE0Mg==", "bodyText": "Again, same comment.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424332142", "createdAt": "2020-05-13T10:22:45Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlApiImpl.java", "diffHunk": "@@ -199,6 +205,8 @@ public CruiseControlApiImpl(Vertx vertx) {\n                                 } else {\n                                     result.fail(json.getString(CC_REST_API_ERROR_KEY));\n                                 }\n+                            } else {\n+                                result.fail(json.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d3dfe79821301c894b540952e1a93116d4b3c21"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzMzY0Ng==", "bodyText": "I think a javadoc description of precisely the scenario being tested for each of the tests in the class might prove useful when maintaining them in the future.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424333646", "createdAt": "2020-05-13T10:25:21Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -90,65 +99,661 @@\n                     .build();\n \n     @BeforeAll\n-    public static void before() throws IOException, URISyntaxException {\n+    public static void beforeAll() throws IOException, URISyntaxException {\n         ccServer = MockCruiseControl.getCCServer(CruiseControl.REST_API_PORT);\n     }\n \n     @AfterAll\n-    public static void after() {\n+    public static void afterAll() {\n         ccServer.stop();\n     }\n \n     @BeforeEach\n-    public void resetServer() {\n+    public void beforeEach(Vertx vertx) {\n         ccServer.reset();\n+\n+        kubernetesClient = new MockKube()\n+                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n+                .end()\n+                .build();\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(true);\n+        PlatformFeaturesAvailability pfa = new PlatformFeaturesAvailability(true, kubernetesVersion);\n+        kcrao = new KafkaRebalanceAssemblyOperator(vertx, pfa, supplier, HOST);\n+\n+        mockRebalanceOps = supplier.kafkaRebalanceOperator;\n+        mockKafkaOps = supplier.kafkaOperator;\n+    }\n+\n+    @AfterEach\n+    public void afterEach() {\n+        if (kubernetesClient != null) {\n+            kubernetesClient.close();\n+        }\n     }\n \n     @Test\n-    public void testNewRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+    public void testNewToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d3dfe79821301c894b540952e1a93116d4b3c21"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNTA1OQ==", "bodyText": "setHandler() returns the Future on which it is called, not a new Future. Calling compose() on that sets the handler again, replacing the handler which you set by calling setHandlder().", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424335059", "createdAt": "2020-05-13T10:28:00Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -90,65 +99,661 @@\n                     .build();\n \n     @BeforeAll\n-    public static void before() throws IOException, URISyntaxException {\n+    public static void beforeAll() throws IOException, URISyntaxException {\n         ccServer = MockCruiseControl.getCCServer(CruiseControl.REST_API_PORT);\n     }\n \n     @AfterAll\n-    public static void after() {\n+    public static void afterAll() {\n         ccServer.stop();\n     }\n \n     @BeforeEach\n-    public void resetServer() {\n+    public void beforeEach(Vertx vertx) {\n         ccServer.reset();\n+\n+        kubernetesClient = new MockKube()\n+                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n+                .end()\n+                .build();\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(true);\n+        PlatformFeaturesAvailability pfa = new PlatformFeaturesAvailability(true, kubernetesVersion);\n+        kcrao = new KafkaRebalanceAssemblyOperator(vertx, pfa, supplier, HOST);\n+\n+        mockRebalanceOps = supplier.kafkaRebalanceOperator;\n+        mockKafkaOps = supplier.kafkaOperator;\n+    }\n+\n+    @AfterEach\n+    public void afterEach() {\n+        if (kubernetesClient != null) {\n+            kubernetesClient.close();\n+        }\n     }\n \n     @Test\n-    public void testNewRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+    public void testNewToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n \n-        // Setup the rebalance user tasks endpoints with the number of pending calls before a response is received.\n-        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n-        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 0);\n \n-        KubernetesClient client = new MockKube()\n-                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n-                .end()\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New directly to ProposalReady (no pending calls in the Mock server)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 2);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr1);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to ProposalReady\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToStoppedRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 5);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d3dfe79821301c894b540952e1a93116d4b3c21"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNTQ2NQ==", "bodyText": "Do this 10 seconds make the test run slow? We should avoid that if possible, and ideally avoid hard coded timeouts in tests altogether.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424335465", "createdAt": "2020-05-13T10:28:47Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -90,65 +99,661 @@\n                     .build();\n \n     @BeforeAll\n-    public static void before() throws IOException, URISyntaxException {\n+    public static void beforeAll() throws IOException, URISyntaxException {\n         ccServer = MockCruiseControl.getCCServer(CruiseControl.REST_API_PORT);\n     }\n \n     @AfterAll\n-    public static void after() {\n+    public static void afterAll() {\n         ccServer.stop();\n     }\n \n     @BeforeEach\n-    public void resetServer() {\n+    public void beforeEach(Vertx vertx) {\n         ccServer.reset();\n+\n+        kubernetesClient = new MockKube()\n+                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n+                .end()\n+                .build();\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(true);\n+        PlatformFeaturesAvailability pfa = new PlatformFeaturesAvailability(true, kubernetesVersion);\n+        kcrao = new KafkaRebalanceAssemblyOperator(vertx, pfa, supplier, HOST);\n+\n+        mockRebalanceOps = supplier.kafkaRebalanceOperator;\n+        mockKafkaOps = supplier.kafkaOperator;\n+    }\n+\n+    @AfterEach\n+    public void afterEach() {\n+        if (kubernetesClient != null) {\n+            kubernetesClient.close();\n+        }\n     }\n \n     @Test\n-    public void testNewRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+    public void testNewToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n \n-        // Setup the rebalance user tasks endpoints with the number of pending calls before a response is received.\n-        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n-        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 0);\n \n-        KubernetesClient client = new MockKube()\n-                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n-                .end()\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New directly to ProposalReady (no pending calls in the Mock server)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 2);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr1);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to ProposalReady\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToStoppedRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 5);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+\n+                    vertx.setTimer(10000, t -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d3dfe79821301c894b540952e1a93116d4b3c21"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNjcxOQ==", "bodyText": "I've seeing a very large chain of compose etc here, and (I've not looked thoroughly) I suspect there's a lot of duplication between the tests in the kinds of things the handler are doing. If so there's scope to factor out the handlers as methods, which will make the tests easier to read and maintain.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424336719", "createdAt": "2020-05-13T10:31:12Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -90,65 +99,661 @@\n                     .build();\n \n     @BeforeAll\n-    public static void before() throws IOException, URISyntaxException {\n+    public static void beforeAll() throws IOException, URISyntaxException {\n         ccServer = MockCruiseControl.getCCServer(CruiseControl.REST_API_PORT);\n     }\n \n     @AfterAll\n-    public static void after() {\n+    public static void afterAll() {\n         ccServer.stop();\n     }\n \n     @BeforeEach\n-    public void resetServer() {\n+    public void beforeEach(Vertx vertx) {\n         ccServer.reset();\n+\n+        kubernetesClient = new MockKube()\n+                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n+                .end()\n+                .build();\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(true);\n+        PlatformFeaturesAvailability pfa = new PlatformFeaturesAvailability(true, kubernetesVersion);\n+        kcrao = new KafkaRebalanceAssemblyOperator(vertx, pfa, supplier, HOST);\n+\n+        mockRebalanceOps = supplier.kafkaRebalanceOperator;\n+        mockKafkaOps = supplier.kafkaOperator;\n+    }\n+\n+    @AfterEach\n+    public void afterEach() {\n+        if (kubernetesClient != null) {\n+            kubernetesClient.close();\n+        }\n     }\n \n     @Test\n-    public void testNewRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+    public void testNewToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n \n-        // Setup the rebalance user tasks endpoints with the number of pending calls before a response is received.\n-        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n-        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 0);\n \n-        KubernetesClient client = new MockKube()\n-                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n-                .end()\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New directly to ProposalReady (no pending calls in the Mock server)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 2);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr1);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to ProposalReady\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToStoppedRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 5);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+\n+                    vertx.setTimer(10000, t -> {\n+                        // after a while, apply the \"stop\" annotation to the resource in the PendingProposal state\n+                        KafkaRebalance kr2 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                        KafkaRebalance stoppedKr = new KafkaRebalanceBuilder(kr2)\n+                                .editMetadata()\n+                                    .addToAnnotations(KafkaRebalanceAssemblyOperator.ANNO_STRIMZI_IO_REBALANCE, \"stop\")\n+                                .endMetadata()\n+                                .build();\n+\n+                        Crds.kafkaRebalanceOperation(kubernetesClient)\n+                                .inNamespace(CLUSTER_NAMESPACE)\n+                                .withName(RESOURCE_NAME)\n+                                .patch(stoppedKr);\n+                    });\n+\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr1);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from ProposalPending to Stopped\n+                    KafkaRebalance kr3 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr3, KafkaRebalanceAssemblyOperator.State.Stopped);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToStoppedAndRefreshRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 2);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+\n+                    vertx.setTimer(2000, t -> {\n+                        // after a while, apply the \"stop\" annotation to the resource in the PendingProposal state\n+                        KafkaRebalance kr2 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                        KafkaRebalance stoppedKr = new KafkaRebalanceBuilder(kr2)\n+                                .editMetadata()\n+                                    .addToAnnotations(KafkaRebalanceAssemblyOperator.ANNO_STRIMZI_IO_REBALANCE, \"stop\")\n+                                .endMetadata()\n+                                .build();\n+\n+                        Crds.kafkaRebalanceOperation(kubernetesClient)\n+                                .inNamespace(CLUSTER_NAMESPACE)\n+                                .withName(RESOURCE_NAME)\n+                                .patch(stoppedKr);\n+                    });\n+\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr1);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from ProposalPending to Stopped\n+                    KafkaRebalance kr3 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr3, KafkaRebalanceAssemblyOperator.State.Stopped);\n+                }))).compose(v -> {\n+\n+                    // apply the \"refresh\" annotation to the resource in the Stopped state\n+                    KafkaRebalance kr4 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    KafkaRebalance refreshedKr = new KafkaRebalanceBuilder(kr4)\n+                            .editMetadata()\n+                                .addToAnnotations(KafkaRebalanceAssemblyOperator.ANNO_STRIMZI_IO_REBALANCE, \"refresh\")\n+                            .endMetadata()\n+                            .build();\n+\n+                    Crds.kafkaRebalanceOperation(kubernetesClient)\n+                            .inNamespace(CLUSTER_NAMESPACE)\n+                            .withName(RESOURCE_NAME)\n+                            .patch(refreshedKr);\n+\n+                    // trigger another reconcile to process the Stopped state\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            refreshedKr);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from Stopped to PendingProposal\n+                    KafkaRebalance kr5 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr5, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr6 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr6);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from PendingProposal to ProposalReady\n+                    KafkaRebalance kr7 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr7, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d3dfe79821301c894b540952e1a93116d4b3c21"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNzk3Nw==", "bodyText": "Overall it feels like you have good coverage of various paths through the states, which is good. You don't have any coverage for error cases (like what happens if CC returns an error). Could you add some tests for that?\nHow does the CC client cope with CC not responding, does it timeout the returned Futures (in which case that would be covered by the extra testing I just described)? If not we should probably plan to add that, as I think the operator is complex enough, and it's easier to add that to the client.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424337977", "createdAt": "2020-05-13T10:33:33Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -157,25 +762,23 @@ public void testNewRebalance(Vertx vertx, VertxTestContext context) throws IOExc\n         when(mockRebalanceOps.updateStatusAsync(any(KafkaRebalance.class))).thenAnswer(invocation -> {\n             try {\n                 return Future.succeededFuture(Crds.kafkaRebalanceOperation(client)\n-                        .inNamespace(CLUSTER_NAMESPACE)\n-                        .withName(RESOURCE_NAME)\n+                        .inNamespace(namespace)\n+                        .withName(resource)\n+                        .patch(invocation.getArgument(0)));\n+            } catch (Exception e) {\n+                return Future.failedFuture(e);\n+            }\n+        });\n+        when(mockRebalanceOps.patchAsync(any(KafkaRebalance.class))).thenAnswer(invocation -> {\n+            try {\n+                return Future.succeededFuture(Crds.kafkaRebalanceOperation(client)\n+                        .inNamespace(namespace)\n+                        .withName(resource)\n                         .patch(invocation.getArgument(0)));\n             } catch (Exception e) {\n                 return Future.failedFuture(e);\n             }\n         });\n-\n-        kcrao.reconcileRebalance(\n-                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n-                kcRebalance).setHandler(context.succeeding(v -> context.verify(() -> {\n-                    KafkaRebalance kr = Crds.kafkaRebalanceOperation(client).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n-                    assertThat(kr, notNullValue());\n-                    assertThat(kr.getStatus(), notNullValue());\n-                    assertThat(kr.getStatus().getConditions(), notNullValue());\n-                    assertThat(kr.getStatus().getConditions().get(0).getType(), is(KafkaRebalanceStatus.REBALANCE_STATUS_CONDITION_TYPE));\n-                    assertThat(kr.getStatus().getConditions().get(0).getStatus(), is(KafkaRebalanceAssemblyOperator.State.ProposalReady.toString()));\n-                    context.completeNow();\n-                })));\n     }\n \n }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d3dfe79821301c894b540952e1a93116d4b3c21"}, "originalPosition": 776}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzODkwOA==", "bodyText": "Why use an if when you could write assertEquals(shouldBeEmpty, result.result().getOptimizationResult().isEmpty()) ?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424338908", "createdAt": "2020-05-13T10:35:26Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceStateMachineTest.java", "diffHunk": "@@ -0,0 +1,529 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.strimzi.api.kafka.KafkaRebalanceList;\n+import io.strimzi.api.kafka.model.DoneableKafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalance;\n+import io.strimzi.api.kafka.model.KafkaRebalanceBuilder;\n+import io.strimzi.api.kafka.model.KafkaRebalanceSpec;\n+import io.strimzi.api.kafka.model.KafkaRebalanceSpecBuilder;\n+import io.strimzi.api.kafka.model.status.Condition;\n+import io.strimzi.api.kafka.model.status.KafkaRebalanceStatus;\n+import io.strimzi.operator.KubernetesVersion;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.CruiseControl;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApi;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.CruiseControlApiImpl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.MockCruiseControl;\n+import io.strimzi.operator.cluster.operator.resource.cruisecontrol.RebalanceOptions;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockserver.integration.ClientAndServer;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(VertxExtension.class)\n+public class KafkaRebalanceStateMachineTest {\n+\n+    private static final String HOST = \"localhost\";\n+    private static final String RESOURCE_NAME = \"my-rebalance\";\n+    private static final String CLUSTER_NAMESPACE = \"cruise-control-namespace\";\n+    private static final String CLUSTER_NAME = \"kafka-cruise-control-test-cluster\";\n+\n+    private final KubernetesVersion kubernetesVersion = KubernetesVersion.V1_11;\n+\n+    private static final Logger log = LogManager.getLogger(KafkaRebalanceStateMachineTest.class.getName());\n+\n+    private static ClientAndServer ccServer;\n+\n+    @BeforeAll\n+    public static void before() throws IOException, URISyntaxException {\n+        ccServer = MockCruiseControl.getCCServer(CruiseControl.REST_API_PORT);\n+    }\n+\n+    @AfterAll\n+    public static void after() {\n+        ccServer.stop();\n+    }\n+\n+    @BeforeEach\n+    public void resetServer() {\n+        ccServer.reset();\n+    }\n+\n+    /**\n+     * Checks all conditions in the supplied status to see if type of one of them matches the supplied rebalance state.\n+     *\n+     * @param  received The status instance to be checked.\n+     * @param expectedState The expected rebalance state to be searched for.\n+     * @return True if any of the conditions in the supplied status are of a type matching the supplied expected state.\n+     */\n+    public static boolean expectedStatusCheck(KafkaRebalanceStatus received, KafkaRebalanceAssemblyOperator.State expectedState) {\n+\n+        List<String> foundStatuses = new ArrayList<>();\n+\n+        for (Condition condition :  received.getConditions()) {\n+            String status = condition.getStatus();\n+            if (status.equals(expectedState.toString())) {\n+                log.info(\"Found condition with expected state: \" + expectedState.toString());\n+                return true;\n+            } else {\n+                foundStatuses.add(status);\n+            }\n+        }\n+        log.error(\"Expected : \" + expectedState.toString() + \" but found : \" + foundStatuses);\n+        return false;\n+    }\n+\n+    /**\n+     * Creates an example {@link KafkaRebalanceBuilder} instance using the supplied state parameters.\n+     *\n+     * @param currentState The current state of the resource before being passed to computeNextStatus.\n+     * @param currentStatusSessionID The user task ID attached to the current KafkaRebalance resource. Can be null.\n+     * @param userAnnotation An annotation to be applied after the reconcile has started, for example \"approve\" or \"stop\".\n+     * @param rebalanceSpec A custom rebalance specification. If null a blank spec will be used.\n+     * @return A KafkaRebalance instance configured with the supplied parameters.\n+     */\n+    private KafkaRebalance createKafkaRebalance(KafkaRebalanceAssemblyOperator.State currentState,\n+                                                String currentStatusSessionID,\n+                                                String userAnnotation,\n+                                                KafkaRebalanceSpec rebalanceSpec) {\n+\n+        KafkaRebalanceBuilder kafkaRebalanceBuilder =\n+                new KafkaRebalanceBuilder()\n+                        .editOrNewMetadata()\n+                            .withName(RESOURCE_NAME)\n+                            .withNamespace(CLUSTER_NAMESPACE)\n+                            .withLabels(Collections.singletonMap(Labels.STRIMZI_CLUSTER_LABEL, CLUSTER_NAME))\n+                            .withAnnotations(Collections.singletonMap(KafkaRebalanceAssemblyOperator.ANNO_STRIMZI_IO_REBALANCE, userAnnotation == null ? \"none\" : userAnnotation))\n+                        .endMetadata()\n+                        .withSpec(rebalanceSpec);\n+\n+        // there is no actual status and related condition when a KafkaRebalance is just created\n+        if (currentState != KafkaRebalanceAssemblyOperator.State.New) {\n+            Condition currentRebalanceCondition = new Condition();\n+            currentRebalanceCondition.setStatus(currentState.toString());\n+            currentRebalanceCondition.setType(KafkaRebalanceStatus.REBALANCE_STATUS_CONDITION_TYPE);\n+\n+            KafkaRebalanceStatus currentStatus = new KafkaRebalanceStatus();\n+            currentStatus.setConditions(Collections.singletonList(currentRebalanceCondition));\n+            currentStatus.setSessionId(currentStatusSessionID);\n+\n+            kafkaRebalanceBuilder.withStatus(currentStatus);\n+        }\n+        return kafkaRebalanceBuilder.build();\n+    }\n+\n+    /**\n+     *  Checks the expected transition between two states of the Kafka Rebalance operator.\n+     *\n+     * @param vertx The vertx test instance.\n+     * @param context The test context instance.\n+     * @param currentState The current state of the resource before being passed to computeNextStatus.\n+     * @param nextState The expected state of the resouce after computeNextStatus has been called.\n+     * @param initialAnnotation The initial annotation attached to the Kafka Rebalance resource. For example none or refresh.\n+     * @param kcRebalance The Kafka Rebalance instance that will be returned by the resourceSupplier.\n+     * @return A future for the {@link KafkaRebalanceStatus} returned by the {@link KafkaRebalanceAssemblyOperator#computeNextStatus} method\n+     */\n+    private Future<KafkaRebalanceStatus> checkTransition(Vertx vertx, VertxTestContext context,\n+                                                         KafkaRebalanceAssemblyOperator.State currentState,\n+                                                         KafkaRebalanceAssemblyOperator.State nextState,\n+                                                         KafkaRebalanceAssemblyOperator.RebalanceAnnotation initialAnnotation,\n+                                                         KafkaRebalance kcRebalance) {\n+\n+        CruiseControlApi client = new CruiseControlApiImpl(vertx);\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(true);\n+        PlatformFeaturesAvailability pfa = new PlatformFeaturesAvailability(true, kubernetesVersion);\n+        KafkaRebalanceAssemblyOperator kcrao = new KafkaRebalanceAssemblyOperator(vertx, pfa, supplier, HOST);\n+\n+        Reconciliation recon = new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME);\n+\n+        RebalanceOptions.RebalanceOptionsBuilder rbOptions = new RebalanceOptions.RebalanceOptionsBuilder();\n+\n+        if (kcRebalance.getSpec() != null) {\n+            if (kcRebalance.getSpec().getGoals() != null) {\n+                rbOptions.withGoals(kcRebalance.getSpec().getGoals());\n+            }\n+\n+            if (kcRebalance.getSpec().isSkipHardGoalCheck()) {\n+                rbOptions.withSkipHardGoalCheck();\n+            }\n+        }\n+\n+        CrdOperator<KubernetesClient,\n+                KafkaRebalance,\n+                KafkaRebalanceList,\n+                DoneableKafkaRebalance> mockRebalanceOps = supplier.kafkaRebalanceOperator;\n+\n+        when(mockRebalanceOps.get(CLUSTER_NAMESPACE, RESOURCE_NAME)).thenReturn(kcRebalance);\n+        when(mockRebalanceOps.getAsync(CLUSTER_NAMESPACE, RESOURCE_NAME)).thenReturn(Future.succeededFuture(kcRebalance));\n+\n+        return kcrao.computeNextStatus(\n+                recon, HOST, client, kcRebalance, currentState, initialAnnotation, rbOptions).compose(result -> {\n+                    context.verify(() -> {\n+                        assertTrue(expectedStatusCheck(result, nextState));\n+                    });\n+                    return Future.succeededFuture(result);\n+                });\n+    }\n+\n+    /**\n+     *  Checks the expected transition between two states of the Kafka Rebalance operator.\n+     *\n+     * @param vertx The vertx test instance.\n+     * @param context The test context instance.\n+     * @param currentState The current state of the resource before being passed to computeNextStatus.\n+     * @param nextState The expected state of the resouce after computeNextStatus has been called.\n+     * @param initialAnnotation The initial annotation attached to the Kafka Rebalance resource. For example none or refresh.\n+     * @param userAnnotation An annotation to be applied after the reconcile has started, for example \"approve\" or \"stop\".\n+     * @param currentStatusSessionID The user task ID attached to the current KafkaRebalance resource. Can be null.\n+     * @return A future for the {@link KafkaRebalanceStatus} returned by the {@link KafkaRebalanceAssemblyOperator#computeNextStatus} method\n+     */\n+    private Future<KafkaRebalanceStatus> checkTransition(Vertx vertx, VertxTestContext context,\n+                                                         KafkaRebalanceAssemblyOperator.State currentState,\n+                                                         KafkaRebalanceAssemblyOperator.State nextState,\n+                                                         KafkaRebalanceAssemblyOperator.RebalanceAnnotation initialAnnotation,\n+                                                         String userAnnotation, String currentStatusSessionID) {\n+\n+        KafkaRebalance kcRebalance = createKafkaRebalance(currentState, currentStatusSessionID, userAnnotation, null);\n+\n+        return checkTransition(vertx, context, currentState, nextState, initialAnnotation, kcRebalance);\n+\n+    }\n+\n+    private static void defaultStatusHandler(AsyncResult<KafkaRebalanceStatus> result, VertxTestContext context) {\n+        if (result.succeeded()) {\n+            context.completeNow();\n+        } else {\n+            context.failNow(result.cause());\n+        }\n+    }\n+\n+    private static void checkOptimizationResults(AsyncResult<KafkaRebalanceStatus> result, VertxTestContext context, boolean shouldBeEmpty) {\n+        if (result.succeeded()) {\n+            if (shouldBeEmpty) {\n+                context.verify(() -> assertTrue(result.result().getOptimizationResult().isEmpty()));\n+            } else {\n+                context.verify(() -> assertFalse(result.result().getOptimizationResult().isEmpty()));\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d3dfe79821301c894b540952e1a93116d4b3c21"}, "originalPosition": 235}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMDUxOTkx", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#pullrequestreview-411051991", "createdAt": "2020-05-13T15:37:31Z", "commit": {"oid": "06fbc0dbe8c4a930b8b4e93b54b82fce4ba7503f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNTozNzozMVrOGU3nUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjoyMzozM1rOGU5nog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUzNTg4OQ==", "bodyText": "I prefer context.checkpoint()\nand a flag, more extensible and clearer timeouts", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424535889", "createdAt": "2020-05-13T15:37:31Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -90,65 +99,661 @@\n                     .build();\n \n     @BeforeAll\n-    public static void before() throws IOException, URISyntaxException {\n+    public static void beforeAll() throws IOException, URISyntaxException {\n         ccServer = MockCruiseControl.getCCServer(CruiseControl.REST_API_PORT);\n     }\n \n     @AfterAll\n-    public static void after() {\n+    public static void afterAll() {\n         ccServer.stop();\n     }\n \n     @BeforeEach\n-    public void resetServer() {\n+    public void beforeEach(Vertx vertx) {\n         ccServer.reset();\n+\n+        kubernetesClient = new MockKube()\n+                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n+                .end()\n+                .build();\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(true);\n+        PlatformFeaturesAvailability pfa = new PlatformFeaturesAvailability(true, kubernetesVersion);\n+        kcrao = new KafkaRebalanceAssemblyOperator(vertx, pfa, supplier, HOST);\n+\n+        mockRebalanceOps = supplier.kafkaRebalanceOperator;\n+        mockKafkaOps = supplier.kafkaOperator;\n+    }\n+\n+    @AfterEach\n+    public void afterEach() {\n+        if (kubernetesClient != null) {\n+            kubernetesClient.close();\n+        }\n     }\n \n     @Test\n-    public void testNewRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+    public void testNewToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n \n-        // Setup the rebalance user tasks endpoints with the number of pending calls before a response is received.\n-        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n-        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 0);\n \n-        KubernetesClient client = new MockKube()\n-                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n-                .end()\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New directly to ProposalReady (no pending calls in the Mock server)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06fbc0dbe8c4a930b8b4e93b54b82fce4ba7503f"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUzNjQzNw==", "bodyText": "ditto", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424536437", "createdAt": "2020-05-13T15:38:09Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -90,65 +99,661 @@\n                     .build();\n \n     @BeforeAll\n-    public static void before() throws IOException, URISyntaxException {\n+    public static void beforeAll() throws IOException, URISyntaxException {\n         ccServer = MockCruiseControl.getCCServer(CruiseControl.REST_API_PORT);\n     }\n \n     @AfterAll\n-    public static void after() {\n+    public static void afterAll() {\n         ccServer.stop();\n     }\n \n     @BeforeEach\n-    public void resetServer() {\n+    public void beforeEach(Vertx vertx) {\n         ccServer.reset();\n+\n+        kubernetesClient = new MockKube()\n+                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n+                .end()\n+                .build();\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(true);\n+        PlatformFeaturesAvailability pfa = new PlatformFeaturesAvailability(true, kubernetesVersion);\n+        kcrao = new KafkaRebalanceAssemblyOperator(vertx, pfa, supplier, HOST);\n+\n+        mockRebalanceOps = supplier.kafkaRebalanceOperator;\n+        mockKafkaOps = supplier.kafkaOperator;\n+    }\n+\n+    @AfterEach\n+    public void afterEach() {\n+        if (kubernetesClient != null) {\n+            kubernetesClient.close();\n+        }\n     }\n \n     @Test\n-    public void testNewRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+    public void testNewToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n \n-        // Setup the rebalance user tasks endpoints with the number of pending calls before a response is received.\n-        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n-        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 0);\n \n-        KubernetesClient client = new MockKube()\n-                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n-                .end()\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New directly to ProposalReady (no pending calls in the Mock server)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 2);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr1);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to ProposalReady\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06fbc0dbe8c4a930b8b4e93b54b82fce4ba7503f"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUzOTAyMg==", "bodyText": "Don't want to propose additional work for little value, but I do wonder if we could make some generic hamcrest matchers for states across our operators, for instance this line could be calling:\n assertThat(kr1, hasState(KafkaRebalanceAssemblyOperator.State.PendingProposal));\n\nwhere hasState is the custom matcher. An example of a custom matcher can be found in the CustomMatchers class.\nIf we made one that was abstract we could simple implement the abstract matcher for this class and make the AbstractOperatorState KafkaRebalanceAssemblyOperator.State", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424539022", "createdAt": "2020-05-13T15:41:38Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -90,65 +99,661 @@\n                     .build();\n \n     @BeforeAll\n-    public static void before() throws IOException, URISyntaxException {\n+    public static void beforeAll() throws IOException, URISyntaxException {\n         ccServer = MockCruiseControl.getCCServer(CruiseControl.REST_API_PORT);\n     }\n \n     @AfterAll\n-    public static void after() {\n+    public static void afterAll() {\n         ccServer.stop();\n     }\n \n     @BeforeEach\n-    public void resetServer() {\n+    public void beforeEach(Vertx vertx) {\n         ccServer.reset();\n+\n+        kubernetesClient = new MockKube()\n+                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n+                .end()\n+                .build();\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(true);\n+        PlatformFeaturesAvailability pfa = new PlatformFeaturesAvailability(true, kubernetesVersion);\n+        kcrao = new KafkaRebalanceAssemblyOperator(vertx, pfa, supplier, HOST);\n+\n+        mockRebalanceOps = supplier.kafkaRebalanceOperator;\n+        mockKafkaOps = supplier.kafkaOperator;\n+    }\n+\n+    @AfterEach\n+    public void afterEach() {\n+        if (kubernetesClient != null) {\n+            kubernetesClient.close();\n+        }\n     }\n \n     @Test\n-    public void testNewRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+    public void testNewToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n \n-        // Setup the rebalance user tasks endpoints with the number of pending calls before a response is received.\n-        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n-        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 0);\n \n-        KubernetesClient client = new MockKube()\n-                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n-                .end()\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New directly to ProposalReady (no pending calls in the Mock server)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 2);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06fbc0dbe8c4a930b8b4e93b54b82fce4ba7503f"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU2NjM1MA==", "bodyText": "\"", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424566350", "createdAt": "2020-05-13T16:19:58Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -90,65 +99,661 @@\n                     .build();\n \n     @BeforeAll\n-    public static void before() throws IOException, URISyntaxException {\n+    public static void beforeAll() throws IOException, URISyntaxException {\n         ccServer = MockCruiseControl.getCCServer(CruiseControl.REST_API_PORT);\n     }\n \n     @AfterAll\n-    public static void after() {\n+    public static void afterAll() {\n         ccServer.stop();\n     }\n \n     @BeforeEach\n-    public void resetServer() {\n+    public void beforeEach(Vertx vertx) {\n         ccServer.reset();\n+\n+        kubernetesClient = new MockKube()\n+                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n+                .end()\n+                .build();\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(true);\n+        PlatformFeaturesAvailability pfa = new PlatformFeaturesAvailability(true, kubernetesVersion);\n+        kcrao = new KafkaRebalanceAssemblyOperator(vertx, pfa, supplier, HOST);\n+\n+        mockRebalanceOps = supplier.kafkaRebalanceOperator;\n+        mockKafkaOps = supplier.kafkaOperator;\n+    }\n+\n+    @AfterEach\n+    public void afterEach() {\n+        if (kubernetesClient != null) {\n+            kubernetesClient.close();\n+        }\n     }\n \n     @Test\n-    public void testNewRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+    public void testNewToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n \n-        // Setup the rebalance user tasks endpoints with the number of pending calls before a response is received.\n-        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n-        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 0);\n \n-        KubernetesClient client = new MockKube()\n-                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n-                .end()\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New directly to ProposalReady (no pending calls in the Mock server)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 2);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr1);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to ProposalReady\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToStoppedRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 5);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+\n+                    vertx.setTimer(10000, t -> {\n+                        // after a while, apply the \"stop\" annotation to the resource in the PendingProposal state\n+                        KafkaRebalance kr2 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                        KafkaRebalance stoppedKr = new KafkaRebalanceBuilder(kr2)\n+                                .editMetadata()\n+                                    .addToAnnotations(KafkaRebalanceAssemblyOperator.ANNO_STRIMZI_IO_REBALANCE, \"stop\")\n+                                .endMetadata()\n+                                .build();\n+\n+                        Crds.kafkaRebalanceOperation(kubernetesClient)\n+                                .inNamespace(CLUSTER_NAMESPACE)\n+                                .withName(RESOURCE_NAME)\n+                                .patch(stoppedKr);\n+                    });\n+\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr1);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from ProposalPending to Stopped\n+                    KafkaRebalance kr3 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr3, KafkaRebalanceAssemblyOperator.State.Stopped);\n+                    context.completeNow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06fbc0dbe8c4a930b8b4e93b54b82fce4ba7503f"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU2NzIzOA==", "bodyText": "+1 to this. If we can capture some singular chunks of the compose + handlers we can turn them into re-usable pieces and the readability of each tests should go up", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424567238", "createdAt": "2020-05-13T16:21:19Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperatorTest.java", "diffHunk": "@@ -90,65 +99,661 @@\n                     .build();\n \n     @BeforeAll\n-    public static void before() throws IOException, URISyntaxException {\n+    public static void beforeAll() throws IOException, URISyntaxException {\n         ccServer = MockCruiseControl.getCCServer(CruiseControl.REST_API_PORT);\n     }\n \n     @AfterAll\n-    public static void after() {\n+    public static void afterAll() {\n         ccServer.stop();\n     }\n \n     @BeforeEach\n-    public void resetServer() {\n+    public void beforeEach(Vertx vertx) {\n         ccServer.reset();\n+\n+        kubernetesClient = new MockKube()\n+                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n+                .end()\n+                .build();\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(true);\n+        PlatformFeaturesAvailability pfa = new PlatformFeaturesAvailability(true, kubernetesVersion);\n+        kcrao = new KafkaRebalanceAssemblyOperator(vertx, pfa, supplier, HOST);\n+\n+        mockRebalanceOps = supplier.kafkaRebalanceOperator;\n+        mockKafkaOps = supplier.kafkaOperator;\n+    }\n+\n+    @AfterEach\n+    public void afterEach() {\n+        if (kubernetesClient != null) {\n+            kubernetesClient.close();\n+        }\n     }\n \n     @Test\n-    public void testNewRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+    public void testNewToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n \n-        // Setup the rebalance user tasks endpoints with the number of pending calls before a response is received.\n-        MockCruiseControl.setupCCRebalanceResponse(ccServer);\n-        MockCruiseControl.setupCCUserTasksResponse(ccServer, 0);\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 0);\n \n-        KubernetesClient client = new MockKube()\n-                .withCustomResourceDefinition(Crds.kafkaRebalance(), KafkaRebalance.class, KafkaRebalanceList.class, DoneableKafkaRebalance.class)\n-                .end()\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New directly to ProposalReady (no pending calls in the Mock server)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToProposalReadyRebalance(VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 2);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr1);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to ProposalReady\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToStoppedRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 5);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+\n+                    vertx.setTimer(10000, t -> {\n+                        // after a while, apply the \"stop\" annotation to the resource in the PendingProposal state\n+                        KafkaRebalance kr2 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                        KafkaRebalance stoppedKr = new KafkaRebalanceBuilder(kr2)\n+                                .editMetadata()\n+                                    .addToAnnotations(KafkaRebalanceAssemblyOperator.ANNO_STRIMZI_IO_REBALANCE, \"stop\")\n+                                .endMetadata()\n+                                .build();\n+\n+                        Crds.kafkaRebalanceOperation(kubernetesClient)\n+                                .inNamespace(CLUSTER_NAMESPACE)\n+                                .withName(RESOURCE_NAME)\n+                                .patch(stoppedKr);\n+                    });\n+\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr1);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from ProposalPending to Stopped\n+                    KafkaRebalance kr3 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr3, KafkaRebalanceAssemblyOperator.State.Stopped);\n+                    context.completeNow();\n+                })));\n+    }\n+\n+    @Test\n+    public void testNewToPendingProposalToStoppedAndRefreshRebalance(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        // Setup the rebalance endpoint with the number of pending calls before a response is received.\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 2);\n+\n+        KafkaRebalance kr =\n+                createKafkaRebalance(CLUSTER_NAMESPACE, CLUSTER_NAME, RESOURCE_NAME, new KafkaRebalanceSpecBuilder().build());\n+\n+        Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).create(kr);\n+\n+        when(mockKafkaOps.getAsync(CLUSTER_NAMESPACE, CLUSTER_NAME)).thenReturn(Future.succeededFuture(kafka));\n+        mockRebalanceOperator(mockRebalanceOps, CLUSTER_NAMESPACE, RESOURCE_NAME, kubernetesClient);\n+\n+        kcrao.reconcileRebalance(\n+                new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                kr).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from New to PendingProposal (due to the configured Mock server pending calls)\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr1, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+\n+                    vertx.setTimer(2000, t -> {\n+                        // after a while, apply the \"stop\" annotation to the resource in the PendingProposal state\n+                        KafkaRebalance kr2 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                        KafkaRebalance stoppedKr = new KafkaRebalanceBuilder(kr2)\n+                                .editMetadata()\n+                                    .addToAnnotations(KafkaRebalanceAssemblyOperator.ANNO_STRIMZI_IO_REBALANCE, \"stop\")\n+                                .endMetadata()\n+                                .build();\n+\n+                        Crds.kafkaRebalanceOperation(kubernetesClient)\n+                                .inNamespace(CLUSTER_NAMESPACE)\n+                                .withName(RESOURCE_NAME)\n+                                .patch(stoppedKr);\n+                    });\n+\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr1 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr1);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from ProposalPending to Stopped\n+                    KafkaRebalance kr3 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr3, KafkaRebalanceAssemblyOperator.State.Stopped);\n+                }))).compose(v -> {\n+\n+                    // apply the \"refresh\" annotation to the resource in the Stopped state\n+                    KafkaRebalance kr4 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    KafkaRebalance refreshedKr = new KafkaRebalanceBuilder(kr4)\n+                            .editMetadata()\n+                                .addToAnnotations(KafkaRebalanceAssemblyOperator.ANNO_STRIMZI_IO_REBALANCE, \"refresh\")\n+                            .endMetadata()\n+                            .build();\n+\n+                    Crds.kafkaRebalanceOperation(kubernetesClient)\n+                            .inNamespace(CLUSTER_NAMESPACE)\n+                            .withName(RESOURCE_NAME)\n+                            .patch(refreshedKr);\n+\n+                    // trigger another reconcile to process the Stopped state\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            refreshedKr);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from Stopped to PendingProposal\n+                    KafkaRebalance kr5 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr5, KafkaRebalanceAssemblyOperator.State.PendingProposal);\n+                }))).compose(v -> {\n+                    // trigger another reconcile to process the PendingProposal state\n+                    KafkaRebalance kr6 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+\n+                    return kcrao.reconcileRebalance(\n+                            new Reconciliation(\"test-trigger\", KafkaRebalance.RESOURCE_KIND, CLUSTER_NAMESPACE, RESOURCE_NAME),\n+                            kr6);\n+                }).setHandler(context.succeeding(v -> context.verify(() -> {\n+                    // the resource moved from PendingProposal to ProposalReady\n+                    KafkaRebalance kr7 = Crds.kafkaRebalanceOperation(kubernetesClient).inNamespace(CLUSTER_NAMESPACE).withName(RESOURCE_NAME).get();\n+                    assertState(kr7, KafkaRebalanceAssemblyOperator.State.ProposalReady);\n+                    context.completeNow();\n+                })));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNjcxOQ=="}, "originalCommit": {"oid": "2d3dfe79821301c894b540952e1a93116d4b3c21"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU2ODYxMw==", "bodyText": "1 is not needed here, and ditto the test, default is 1", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424568613", "createdAt": "2020-05-13T16:23:22Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlClientTest.java", "diffHunk": "@@ -114,15 +115,32 @@ public void testCCRebalanceNotEnoughValidWindowsException(Vertx vertx, VertxTest\n         Checkpoint checkpoint = context.checkpoint(1);\n         client.rebalance(HOST, PORT, rbOptions, MockCruiseControl.REBALANCE_NOT_ENOUGH_VALID_WINDOWS_ERROR)\n                 .setHandler(context.succeeding(result -> {\n-                    assertThat(result.thereIsNotEnoughDataForProposal(), is(true));\n+                    assertTrue(result.thereIsNotEnoughDataForProposal());\n+                    checkpoint.flag();\n+                }));\n+    }\n+\n+    @Test\n+    public void testCCRebalancePropsosalNotReady(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 1);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().build();\n+\n+        CruiseControlApiImpl client = new CruiseControlApiImpl(vertx);\n+\n+        Checkpoint checkpoint = context.checkpoint(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06fbc0dbe8c4a930b8b4e93b54b82fce4ba7503f"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU2ODczOA==", "bodyText": "missing context.verify", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r424568738", "createdAt": "2020-05-13T16:23:33Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlClientTest.java", "diffHunk": "@@ -114,15 +115,32 @@ public void testCCRebalanceNotEnoughValidWindowsException(Vertx vertx, VertxTest\n         Checkpoint checkpoint = context.checkpoint(1);\n         client.rebalance(HOST, PORT, rbOptions, MockCruiseControl.REBALANCE_NOT_ENOUGH_VALID_WINDOWS_ERROR)\n                 .setHandler(context.succeeding(result -> {\n-                    assertThat(result.thereIsNotEnoughDataForProposal(), is(true));\n+                    assertTrue(result.thereIsNotEnoughDataForProposal());\n+                    checkpoint.flag();\n+                }));\n+    }\n+\n+    @Test\n+    public void testCCRebalancePropsosalNotReady(Vertx vertx, VertxTestContext context) throws IOException, URISyntaxException {\n+\n+        MockCruiseControl.setupCCRebalanceResponse(ccServer, 1);\n+\n+        RebalanceOptions rbOptions = new RebalanceOptions.RebalanceOptionsBuilder().build();\n+\n+        CruiseControlApiImpl client = new CruiseControlApiImpl(vertx);\n+\n+        Checkpoint checkpoint = context.checkpoint(1);\n+        client.rebalance(HOST, PORT, rbOptions, MockCruiseControl.REBALANCE_NOT_ENOUGH_VALID_WINDOWS_ERROR)\n+                .setHandler(context.succeeding(result -> {\n+                    assertTrue(result.proposalIsStillCalculating());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06fbc0dbe8c4a930b8b4e93b54b82fce4ba7503f"}, "originalPosition": 57}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9c278bcc94747ee80568cc8cde21183c862fe67", "author": {"user": {"login": "tomncooper", "name": "Thomas Cooper"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/f9c278bcc94747ee80568cc8cde21183c862fe67", "committedDate": "2020-05-14T20:18:11Z", "message": "Added Cruise Control Tests\n\n    * Added rebalance state machine transition tests\n    * Added rebalance operator reconcile tests\n    * Updated previous client api and mock server tests for new CC\n      Status Condition format\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b601bcd6975b6be0b9982a7047e3bcbcd50eb4b2", "author": {"user": {"login": "ppatierno", "name": "Paolo Patierno"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b601bcd6975b6be0b9982a7047e3bcbcd50eb4b2", "committedDate": "2020-05-14T20:18:11Z", "message": "Added more KRAO tests\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5c278ff3757e7d7c07de8b68b723d3304571af6", "author": {"user": {"login": "tomncooper", "name": "Thomas Cooper"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c5c278ff3757e7d7c07de8b68b723d3304571af6", "committedDate": "2020-05-14T20:18:11Z", "message": "Addressed PR comments\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac5baf935673b2313235b845e3621391b8345b17", "author": {"user": {"login": "tomncooper", "name": "Thomas Cooper"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/ac5baf935673b2313235b845e3621391b8345b17", "committedDate": "2020-05-14T20:18:11Z", "message": "Addressed PR comments\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd14fd2a2d8d85cbc07f3717b2225aa0b435acc2", "author": {"user": {"login": "ppatierno", "name": "Paolo Patierno"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/dd14fd2a2d8d85cbc07f3717b2225aa0b435acc2", "committedDate": "2020-05-14T20:18:11Z", "message": "Added Javadoc\nFactored out methods for common operations\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88e42ec58fcedfb43483282ea7724c04e04d3231", "author": {"user": {"login": "ppatierno", "name": "Paolo Patierno"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/88e42ec58fcedfb43483282ea7724c04e04d3231", "committedDate": "2020-05-14T20:27:06Z", "message": "Reviewed comments\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9e9f289e69d3f3f0240438e7c56480e320326a1e", "author": {"user": {"login": "ppatierno", "name": "Paolo Patierno"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/9e9f289e69d3f3f0240438e7c56480e320326a1e", "committedDate": "2020-05-14T20:15:54Z", "message": "Reviewed comments\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>"}, "afterCommit": {"oid": "88e42ec58fcedfb43483282ea7724c04e04d3231", "author": {"user": {"login": "ppatierno", "name": "Paolo Patierno"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/88e42ec58fcedfb43483282ea7724c04e04d3231", "committedDate": "2020-05-14T20:27:06Z", "message": "Reviewed comments\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f5dfb57e12de08208a7d70e81f2c9e31eb9a875", "author": {"user": {"login": "ppatierno", "name": "Paolo Patierno"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/9f5dfb57e12de08208a7d70e81f2c9e31eb9a875", "committedDate": "2020-05-15T07:41:52Z", "message": "Fixed spotbugs and removed not needed idle timeout setting\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyNDI0NjI3", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#pullrequestreview-412424627", "createdAt": "2020-05-15T07:53:43Z", "commit": {"oid": "9f5dfb57e12de08208a7d70e81f2c9e31eb9a875"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwNzo1Mzo0M1rOGV6ToQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwNzo1NTozNlrOGV6XHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYyODU3Nw==", "bodyText": "protected or package access", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r425628577", "createdAt": "2020-05-15T07:53:43Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -143,30 +140,30 @@\n      */\n     public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n                                           ResourceOperatorSupplier supplier) {\n-        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n     }\n \n     /**\n-     * @param vertx The Vertx instance\n-     * @param pfa Platform features availability properties\n-     * @param supplier Supplies the operators for different resources\n-     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n-     *             service address will be used. This parameter is intended for use in testing.\n+     * Provides an implementation of the Cruise Control API client\n+     *\n+     * @return Cruise Control API client instance\n      */\n-    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n-                                          ResourceOperatorSupplier supplier, String ccHost) {\n-        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    public CruiseControlApi cruiseControlClientProvider() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f5dfb57e12de08208a7d70e81f2c9e31eb9a875"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYyODY0Mw==", "bodyText": "protected or package access", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r425628643", "createdAt": "2020-05-15T07:53:50Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaRebalanceAssemblyOperator.java", "diffHunk": "@@ -143,30 +140,30 @@\n      */\n     public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n                                           ResourceOperatorSupplier supplier) {\n-        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), null);\n+        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n+        this.pfa = pfa;\n+        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n+        this.kafkaOperator = supplier.kafkaOperator;\n     }\n \n     /**\n-     * @param vertx The Vertx instance\n-     * @param pfa Platform features availability properties\n-     * @param supplier Supplies the operators for different resources\n-     * @param ccHost Optional host address for the Cruise Control REST API. If this is not supplied then Cruise Control\n-     *             service address will be used. This parameter is intended for use in testing.\n+     * Provides an implementation of the Cruise Control API client\n+     *\n+     * @return Cruise Control API client instance\n      */\n-    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n-                                          ResourceOperatorSupplier supplier, String ccHost) {\n-        this(vertx, pfa, supplier, v -> new CruiseControlApiImpl(vertx), ccHost);\n+    public CruiseControlApi cruiseControlClientProvider() {\n+        return new CruiseControlApiImpl(vertx);\n     }\n \n-    public KafkaRebalanceAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n-                                          ResourceOperatorSupplier supplier,\n-                                          Function<Vertx, CruiseControlApi> cruiseControlClientProvider, String ccHost) {\n-        super(vertx, KafkaRebalance.RESOURCE_KIND, supplier.kafkaRebalanceOperator, supplier.metricsProvider);\n-        this.pfa = pfa;\n-        this.kafkaRebalanceOperator = supplier.kafkaRebalanceOperator;\n-        this.kafkaOperator = supplier.kafkaOperator;\n-        this.cruiseControlClientProvider = cruiseControlClientProvider;\n-        this.ccHost = ccHost;\n+    /**\n+     * The Cruise Control hostname to connect to\n+     *\n+     * @param clusterName the Kafka cluster resource name\n+     * @param clusterNamespace the namespace of the Kafka cluster\n+     * @return the Cruise Control hostname to connect to\n+     */\n+    public String cruiseControlHost(String clusterName, String clusterNamespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f5dfb57e12de08208a7d70e81f2c9e31eb9a875"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYyOTQ3MQ==", "bodyText": "HTTP_DEFAULT_IDLE_TIMEOUT_SECONDS", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r425629471", "createdAt": "2020-05-15T07:55:36Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlApiImpl.java", "diffHunk": "@@ -12,14 +12,24 @@\n import io.vertx.core.json.Json;\n import io.vertx.core.json.JsonObject;\n \n+import java.net.ConnectException;\n+import java.util.concurrent.TimeoutException;\n+\n public class CruiseControlApiImpl implements CruiseControlApi {\n \n     private static final boolean HTTP_CLIENT_ACTIVITY_LOGGING = false;\n+    private static final int HTTP_DEFAULT_IDLE_TIMEOUT = 0; // seconds", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f5dfb57e12de08208a7d70e81f2c9e31eb9a875"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyNDM1MTQ3", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#pullrequestreview-412435147", "createdAt": "2020-05-15T08:09:55Z", "commit": {"oid": "9f5dfb57e12de08208a7d70e81f2c9e31eb9a875"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb602034282e3d623864cb0187e8d09c2bcc97e4", "author": {"user": {"login": "ppatierno", "name": "Paolo Patierno"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/fb602034282e3d623864cb0187e8d09c2bcc97e4", "committedDate": "2020-05-15T08:19:09Z", "message": "Fixed comments\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyNDcyNjk5", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#pullrequestreview-412472699", "createdAt": "2020-05-15T09:04:06Z", "commit": {"oid": "fb602034282e3d623864cb0187e8d09c2bcc97e4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOTowNDowNlrOGV8mIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOTowNDowNlrOGV8mIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY2NjA4Mw==", "bodyText": "So by default we are not waiting at all for a slow CC response?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#discussion_r425666083", "createdAt": "2020-05-15T09:04:06Z", "author": {"login": "tomncooper"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/cruisecontrol/CruiseControlApiImpl.java", "diffHunk": "@@ -12,14 +12,24 @@\n import io.vertx.core.json.Json;\n import io.vertx.core.json.JsonObject;\n \n+import java.net.ConnectException;\n+import java.util.concurrent.TimeoutException;\n+\n public class CruiseControlApiImpl implements CruiseControlApi {\n \n     private static final boolean HTTP_CLIENT_ACTIVITY_LOGGING = false;\n+    private static final int HTTP_DEFAULT_IDLE_TIMEOUT_SECONDS = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb602034282e3d623864cb0187e8d09c2bcc97e4"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyNDc1NTY4", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3002#pullrequestreview-412475568", "createdAt": "2020-05-15T09:08:09Z", "commit": {"oid": "fb602034282e3d623864cb0187e8d09c2bcc97e4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1066fa6e1ce01ce9d5d8a18eb9cadcd3e768a35", "author": {"user": {"login": "ppatierno", "name": "Paolo Patierno"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/a1066fa6e1ce01ce9d5d8a18eb9cadcd3e768a35", "committedDate": "2020-05-15T09:23:16Z", "message": "Fixed comment\n\nSigned-off-by: Paolo Patierno <ppatierno@live.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1693, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}