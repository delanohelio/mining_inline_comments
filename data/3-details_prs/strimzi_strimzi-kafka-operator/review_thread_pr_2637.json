{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzMDQ3NTM4", "number": 2637, "reviewThreads": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNjoyODoxMFrODkuYXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMjoyMjoxNlrODlZu_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5ODM1MjMxOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ZookeeperConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNjoyODoxMFrOFxNKZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNjo1NToxNlrOFxOQtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDE5OA==", "bodyText": "Havig this here suggests this can be override and is just default. I think this should be in forbidden options + ardcoded in zookeeper_config_generator.sh. That probably applies also to 4lw.commands.whitelist, but I'm fine to leave that for other day.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387140198", "createdAt": "2020-03-03T16:28:10Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ZookeeperConfiguration.java", "diffHunk": "@@ -34,6 +34,8 @@\n         config.put(\"tickTime\", \"2000\");\n         config.put(\"initLimit\", \"5\");\n         config.put(\"syncLimit\", \"2\");\n+        config.put(\"standaloneEnabled\", \"false\");\n+        config.put(\"reconfigEnabled\", \"true\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE1ODE5OQ==", "bodyText": "Agreed.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387158199", "createdAt": "2020-03-03T16:55:16Z", "author": {"login": "tomncooper"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ZookeeperConfiguration.java", "diffHunk": "@@ -34,6 +34,8 @@\n         config.put(\"tickTime\", \"2000\");\n         config.put(\"initLimit\", \"5\");\n         config.put(\"syncLimit\", \"2\");\n+        config.put(\"standaloneEnabled\", \"false\");\n+        config.put(\"reconfigEnabled\", \"true\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDE5OA=="}, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5ODM1OTM1OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNjoyOTo0MlrOFxNOuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxODozMTo1N1rOFxRkWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MTMwNw==", "bodyText": "Should this be added tot he status in addition to printing a warning? The warning will be missed by most people.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387141307", "createdAt": "2020-03-03T16:29:42Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1356,13 +1358,21 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n             StatefulSet zkSts = zkCluster.generateStatefulSet(pfa.isOpenshift(), imagePullPolicy, imagePullSecrets);\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(Ca.ANNO_STRIMZI_IO_CLUSTER_CA_CERT_GENERATION, String.valueOf(getCaCertGeneration(this.clusterCa)));\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(AbstractModel.ANNO_STRIMZI_LOGGING_HASH, zkLoggingHash);\n+            Annotations.annotations(zkSts).put(Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, String.valueOf(zkManualScaling));\n             return withZkDiff(zkSetOperations.reconcile(namespace, zkCluster.getName(), zkSts));\n         }\n \n         Future<ReconciliationState> zkRollingUpdate() {\n-            return withVoid(zkSetOperations.maybeRollingUpdate(zkDiffs.resource(), pod ->\n-                isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)\n-            ));\n+            if (zkManualScaling && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                log.info(\"Skipping cluster roll due to ongoing manual scaling operations. \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE3NjAyOA==", "bodyText": "Would that require adding to fields to the KafkaStatus class or should we create a ZookeeperStatus class and add information there?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387176028", "createdAt": "2020-03-03T17:24:33Z", "author": {"login": "tomncooper"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1356,13 +1358,21 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n             StatefulSet zkSts = zkCluster.generateStatefulSet(pfa.isOpenshift(), imagePullPolicy, imagePullSecrets);\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(Ca.ANNO_STRIMZI_IO_CLUSTER_CA_CERT_GENERATION, String.valueOf(getCaCertGeneration(this.clusterCa)));\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(AbstractModel.ANNO_STRIMZI_LOGGING_HASH, zkLoggingHash);\n+            Annotations.annotations(zkSts).put(Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, String.valueOf(zkManualScaling));\n             return withZkDiff(zkSetOperations.reconcile(namespace, zkCluster.getName(), zkSts));\n         }\n \n         Future<ReconciliationState> zkRollingUpdate() {\n-            return withVoid(zkSetOperations.maybeRollingUpdate(zkDiffs.resource(), pod ->\n-                isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)\n-            ));\n+            if (zkManualScaling && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                log.info(\"Skipping cluster roll due to ongoing manual scaling operations. \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MTMwNw=="}, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMjM3Nw==", "bodyText": "Added KafkaStatus updates", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387212377", "createdAt": "2020-03-03T18:31:57Z", "author": {"login": "tomncooper"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1356,13 +1358,21 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n             StatefulSet zkSts = zkCluster.generateStatefulSet(pfa.isOpenshift(), imagePullPolicy, imagePullSecrets);\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(Ca.ANNO_STRIMZI_IO_CLUSTER_CA_CERT_GENERATION, String.valueOf(getCaCertGeneration(this.clusterCa)));\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(AbstractModel.ANNO_STRIMZI_LOGGING_HASH, zkLoggingHash);\n+            Annotations.annotations(zkSts).put(Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, String.valueOf(zkManualScaling));\n             return withZkDiff(zkSetOperations.reconcile(namespace, zkCluster.getName(), zkSts));\n         }\n \n         Future<ReconciliationState> zkRollingUpdate() {\n-            return withVoid(zkSetOperations.maybeRollingUpdate(zkDiffs.resource(), pod ->\n-                isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)\n-            ));\n+            if (zkManualScaling && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                log.info(\"Skipping cluster roll due to ongoing manual scaling operations. \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MTMwNw=="}, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5ODM2MjQ1OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNjozMDozM1rOFxNQyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDoxOTowMlrOFxvADw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MTgzNA==", "bodyText": "Does this TODO still apply?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387141834", "createdAt": "2020-03-03T16:30:33Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1376,20 +1386,39 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          */\n         Future<ReconciliationState> zkScaleUpInSmallSteps() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE2MTk2NA==", "bodyText": "Yes, someone could set the replica to two higher and both node would be added (without the roll). For stability we only want to add 1 node at time to the cluster. Which is still possible as things stand, but the procedure says only add one at a time.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387161964", "createdAt": "2020-03-03T17:01:08Z", "author": {"login": "tomncooper"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1376,20 +1386,39 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          */\n         Future<ReconciliationState> zkScaleUpInSmallSteps() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MTgzNA=="}, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE3MjAzNQ==", "bodyText": "To prevent this (if the user specifies more than one extra node) I think we would need to overwrite the STS zookeeper spec and apply it. Do you think that is worth it or can we rely on the user following the procedure?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387172035", "createdAt": "2020-03-03T17:17:31Z", "author": {"login": "tomncooper"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1376,20 +1386,39 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          */\n         Future<ReconciliationState> zkScaleUpInSmallSteps() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MTgzNA=="}, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI1MjExMw==", "bodyText": "I didn't realized these were connected at first. But main of this comment was whether we really need the TODO, especially with temp solution. You should either do it or remove the TODO.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387252113", "createdAt": "2020-03-03T19:44:44Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1376,20 +1386,39 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          */\n         Future<ReconciliationState> zkScaleUpInSmallSteps() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MTgzNA=="}, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY5NDYwNw==", "bodyText": "Ok, I have added logic at the start of the zkScalingSetup method to abort the reconciliation (with a status + log message) if a user tries to scale more than one zk server at a time.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387694607", "createdAt": "2020-03-04T14:19:02Z", "author": {"login": "tomncooper"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1376,20 +1386,39 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          */\n         Future<ReconciliationState> zkScaleUpInSmallSteps() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MTgzNA=="}, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5ODM2ODAxOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNjozMTo0NFrOFxNUHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxODozMToyOVrOFxRjVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MjY4Nw==", "bodyText": "Should this be named scaleInSmallSteps now?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387142687", "createdAt": "2020-03-03T16:31:44Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1376,20 +1386,39 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          */\n         Future<ReconciliationState> zkScaleUpInSmallSteps() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMjExNg==", "bodyText": "Renamed it to zkScalingSetup", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387212116", "createdAt": "2020-03-03T18:31:29Z", "author": {"login": "tomncooper"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1376,20 +1386,39 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          */\n         Future<ReconciliationState> zkScaleUpInSmallSteps() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MjY4Nw=="}, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5ODM4NTU2OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNjozNjowNVrOFxNfQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNzowODozNFrOFxOxuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0NTUzOQ==", "bodyText": "What if the anno is missing? Will this trigger or what will it do?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387145539", "createdAt": "2020-03-03T16:36:05Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1376,20 +1386,39 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          */\n         Future<ReconciliationState> zkScaleUpInSmallSteps() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n \n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                                log.info(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                                \"update process defined in the documentation should be followed\"\n+                                );\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE2NjY0OQ==", "bodyText": "That branch will only be hit if we are not scaling or if we are scaling a 3.4.14 cluster. In which case if the anno is not there it will return false and the ZK roll will proceed as zkManualScaling will be false. I will add an else clause at the end to make sure it is false.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387166649", "createdAt": "2020-03-03T17:08:34Z", "author": {"login": "tomncooper"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1376,20 +1386,39 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          */\n         Future<ReconciliationState> zkScaleUpInSmallSteps() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n \n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                                log.info(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                                \"update process defined in the documentation should be followed\"\n+                                );\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0NTUzOQ=="}, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5ODQxMzAyOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNjo0Mjo1MVrOFxNwrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxODo0NDo1MlrOFxSAHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0OTk5OQ==", "bodyText": "Does this or the scaleDown method need to be protected by the annotation as well? IIRC you said scaleup should happen node by node ... but unless this is protected, and someone changes the replicas e.g. from 3 to 7 it scale up every reocnciliation regardless whether the user finished the manual tasks, or?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387149999", "createdAt": "2020-03-03T16:42:51Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1376,20 +1386,39 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          */\n         Future<ReconciliationState> zkScaleUpInSmallSteps() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n \n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                                log.info(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                                \"update process defined in the documentation should be followed\"\n+                                );\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // We need to check if we are still in a manual scaling operation. Only the user can set this to false\n+                                // once it has been set to true.\n+                                log.info(\"Detected manual Zookeeper scaling operation in progress\");\n+                                zkManualScaling = true;\n+                            }\n+                        }\n                         return Future.succeededFuture(this);\n                     });\n         }\n \n         Future<ReconciliationState> zkScaleUp() {\n             if (zkScalingUp) {\n                 return zkSetOperations.scaleUp(namespace, zkCluster.getName(), zkCluster.getReplicas())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxOTQ4Ng==", "bodyText": "See comments above above for zkScalingSetup method. We would need to catch the scale down of more than one and overwrite the STS. Do we want to do that or rely on the method saying one at a time?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387219486", "createdAt": "2020-03-03T18:44:52Z", "author": {"login": "tomncooper"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1376,20 +1386,39 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          */\n         Future<ReconciliationState> zkScaleUpInSmallSteps() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n \n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                                log.info(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                                \"update process defined in the documentation should be followed\"\n+                                );\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // We need to check if we are still in a manual scaling operation. Only the user can set this to false\n+                                // once it has been set to true.\n+                                log.info(\"Detected manual Zookeeper scaling operation in progress\");\n+                                zkManualScaling = true;\n+                            }\n+                        }\n                         return Future.succeededFuture(this);\n                     });\n         }\n \n         Future<ReconciliationState> zkScaleUp() {\n             if (zkScalingUp) {\n                 return zkSetOperations.scaleUp(namespace, zkCluster.getName(), zkCluster.getReplicas())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0OTk5OQ=="}, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDk2NjgyOnYy", "diffSide": "RIGHT", "path": "documentation/misc/zookeeper-manual-scaling-methods.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwOTo0Mjo0MlrOFxmMjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwOTo0Mjo0MlrOFxmMjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1MDM0OQ==", "bodyText": "Please provide a brief explanation of the purpose of the procedure.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387550349", "createdAt": "2020-03-04T09:42:42Z", "author": {"login": "laidan6000"}, "path": "documentation/misc/zookeeper-manual-scaling-methods.md", "diffHunk": "@@ -0,0 +1,141 @@\n+# Zookeeper 3.5.x Manual Scaling Procedures\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTAxMzg5OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ZookeeperConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwOTo1NTo0OFrOFxmqBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwOTo1NTo0OFrOFxmqBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1Nzg5Mg==", "bodyText": "We \u2192 The Cluster Operator", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387557892", "createdAt": "2020-03-04T09:55:48Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ZookeeperConfiguration.java", "diffHunk": "@@ -29,13 +29,18 @@\n         FORBIDDEN_OPTIONS.addAll(Arrays.asList(ZookeeperClusterSpec.FORBIDDEN_PREFIXES.split(\" *, *\")));\n         // This option is handled in the Zookeeper container startup script\n         FORBIDDEN_OPTIONS.add(\"snapshot.trust.empty\");\n+        // This option would prevent scaling beyond 1 node for clusters started with a single node\n+        FORBIDDEN_OPTIONS.add(\"standaloneEnabled\");\n+        // Reconfiguration needs to be enabled to allow scaling of the cluster\n+        FORBIDDEN_OPTIONS.add(\"reconfigEnabled\");\n+        // We require access to multiple 4LW and access to the nodes is secured by the TLS-Sidecars so we set all allowed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTAzMTA0OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDowMDoyM1rOFxm0hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMTo1ODo0NFrOFxqfjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU2MDU4MA==", "bodyText": "Do you mean for the Future returned by this method to have completed before the status has been updated?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387560580", "createdAt": "2020-03-04T10:00:23Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1384,91 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = new ConditionBuilder()\n+                                    .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                    .withType(\"ZK-Manual-Scaling\");\n+\n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" annotation to false.\";\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = \"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until \" +\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" annotation is set to false.\";\n \n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+\n+                            } else {\n+                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n+                                zkManualScalingCondition\n+                                        .withStatus(\"False\")\n+                                        .withReason(\"manualScalingNotRequired\");\n+\n+                                if (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0) {\n+                                    zkManualScalingCondition\n+                                            .withMessage(\"Manual scaling of Zookeeper cluster is finished or not required\");\n+                                } else {\n+                                    zkManualScalingCondition\n+                                            .withMessage(\"Manual scaling of Zookeeper cluster is not needed for Zookeeper 3.4.x clusters\");\n+                                }\n+\n+                                zkManualScaling = false;\n+                            }\n+\n+                            KafkaStatus kStatus = this.kafkaStatus;\n+                            kStatus.setConditions(Collections.singletonList(zkManualScalingCondition.build()));\n+                            this.updateStatus(kStatus).setHandler(statusResult -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYyMDc1MQ==", "bodyText": "Good point, I will compose it with the final returned future", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387620751", "createdAt": "2020-03-04T11:58:44Z", "author": {"login": "tomncooper"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1384,91 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = new ConditionBuilder()\n+                                    .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                    .withType(\"ZK-Manual-Scaling\");\n+\n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" annotation to false.\";\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = \"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until \" +\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" annotation is set to false.\";\n \n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+\n+                            } else {\n+                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n+                                zkManualScalingCondition\n+                                        .withStatus(\"False\")\n+                                        .withReason(\"manualScalingNotRequired\");\n+\n+                                if (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0) {\n+                                    zkManualScalingCondition\n+                                            .withMessage(\"Manual scaling of Zookeeper cluster is finished or not required\");\n+                                } else {\n+                                    zkManualScalingCondition\n+                                            .withMessage(\"Manual scaling of Zookeeper cluster is not needed for Zookeeper 3.4.x clusters\");\n+                                }\n+\n+                                zkManualScaling = false;\n+                            }\n+\n+                            KafkaStatus kStatus = this.kafkaStatus;\n+                            kStatus.setConditions(Collections.singletonList(zkManualScalingCondition.build()));\n+                            this.updateStatus(kStatus).setHandler(statusResult -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU2MDU4MA=="}, "originalCommit": {"oid": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTM4ODIzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMTo1MTowOFrOFxqR5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMTo1MTowOFrOFxqR5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxNzI1Mg==", "bodyText": "Should \"3.4.99\" be in a variable. Also this line isn't very readable, would it make sense to wrap the zk version check in a helper function with a readable name?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387617252", "createdAt": "2020-03-04T11:51:08Z", "author": {"login": "katheris"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1384,91 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = new ConditionBuilder()\n+                                    .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                    .withType(\"ZK-Manual-Scaling\");\n+\n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTM5MDI3OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMTo1MTo1MFrOFxqTJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMTo1MTo1MFrOFxqTJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxNzU3NQ==", "bodyText": "There is duplicate code here, so again a helper function would read better.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387617575", "createdAt": "2020-03-04T11:51:50Z", "author": {"login": "katheris"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1384,91 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = new ConditionBuilder()\n+                                    .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                    .withType(\"ZK-Manual-Scaling\");\n+\n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" annotation to false.\";\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = \"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until \" +\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" annotation is set to false.\";\n \n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+\n+                            } else {\n+                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n+                                zkManualScalingCondition\n+                                        .withStatus(\"False\")\n+                                        .withReason(\"manualScalingNotRequired\");\n+\n+                                if (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTM5NjcxOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMTo1Mzo0OFrOFxqW3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMTo1Mzo0OFrOFxqW3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxODUyNA==", "bodyText": "Might be nice to use string formatting here rather than all the concatenations.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387618524", "createdAt": "2020-03-04T11:53:48Z", "author": {"login": "katheris"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1384,91 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = new ConditionBuilder()\n+                                    .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                    .withType(\"ZK-Manual-Scaling\");\n+\n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTQyODI4OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ZookeeperCluster.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMjowNToxMFrOFxqqMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMjowNToxMFrOFxqqMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYyMzQ3NQ==", "bodyText": "It might read easier to have an Optional here rather than the ternary operator.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387623475", "createdAt": "2020-03-04T12:05:10Z", "author": {"login": "katheris"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ZookeeperCluster.java", "diffHunk": "@@ -181,16 +182,18 @@ public static ZookeeperCluster fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup\n         if (replicas <= 0) {\n             replicas = ZookeeperClusterSpec.DEFAULT_REPLICAS;\n         }\n-\n         if (replicas == 1 && zookeeperClusterSpec.getStorage() != null && \"ephemeral\".equals(zookeeperClusterSpec.getStorage().getType())) {\n             log.warn(\"A ZooKeeper cluster with a single replica and ephemeral storage will be in a defective state after any restart or rolling update. It is recommended that a minimum of three replicas are used.\");\n         }\n-\n         zk.setReplicas(replicas);\n \n+        // Get the ZK version information from either the CRD or from the default setting\n+        KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+        String version = versions.version(kafkaClusterSpec != null ? kafkaClusterSpec.getVersion() : null).zookeeperVersion();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjAyNTgxOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDo1Mzo1MlrOFxwaAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDo1Mzo1MlrOFxwaAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcxNzYzNA==", "bodyText": "Can we put the failedResult lambda on a new line? It's easily missed otherwise.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387717634", "createdAt": "2020-03-04T14:53:52Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1384,122 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            ConditionBuilder zkManualScalingCondition = new ConditionBuilder()\n+                                    .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                    .withType(\"ZK-Manual-Scaling\");\n+\n+                            if (currentReplicas > 0 && isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log and update status with the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"replicaChangeGreaterThanOne\")\n+                                        .withStatus(\"False\")\n+                                        .withMessage(scaleErrorMessage);\n+\n+                                KafkaStatus kStatus = this.kafkaStatus;\n+                                kStatus.setConditions(Collections.singletonList(zkManualScalingCondition.build()));\n+                                return this.updateStatus(kStatus).compose(successResult -> {\n+                                    log.debug(\"Status for {} is up to date\", kafkaAssembly.getMetadata().getName());\n+                                    return Future.succeededFuture(); }, failedResult -> {\n+                                        log.error(\"Failed to set status for {}\", kafkaAssembly.getMetadata().getName());\n+                                        return Future.succeededFuture();\n+                                    }).compose(result -> Future.failedFuture(new IllegalArgumentException(scaleErrorMessage)));\n+\n+                            } else if (currentReplicas > 0 && desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = String.format(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                         \"%s annotation to false.\", Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n \n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = String.format(\"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until %s annotation is set to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+\n+                            } else {\n+                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n+                                zkManualScalingCondition\n+                                        .withStatus(\"False\")\n+                                        .withReason(\"manualScalingNotRequired\");\n+\n+                                if (isZK35x) {\n+                                    zkManualScalingCondition\n+                                            .withMessage(\"Manual scaling of Zookeeper cluster is finished or not required\");\n+                                } else {\n+                                    zkManualScalingCondition\n+                                            .withMessage(\"Manual scaling of Zookeeper cluster is not needed for Zookeeper 3.4.x clusters\");\n+                                }\n+\n+                                zkManualScaling = false;\n+                            }\n+\n+                            KafkaStatus kStatus = this.kafkaStatus;\n+                            kStatus.setConditions(Collections.singletonList(zkManualScalingCondition.build()));\n+                            return this.updateStatus(kStatus).compose(successResult -> {\n+                                log.debug(\"Status for {} is up to date\", kafkaAssembly.getMetadata().getName());\n+                                return Future.succeededFuture(); }, failedResult -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b8bc84b83bc553b0b5898bbddedb0de09e9b302"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMzEwOTA0OnYy", "diffSide": "RIGHT", "path": "documentation/misc/zookeeper-manual-scaling-methods.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOTo0Mzo0MlrOFx7H0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNjoyOTo1MFrOFyHuww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg5MzIwMQ==", "bodyText": "This needs some more explaining about the port name (why 21813 and how does it change for other ports.)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387893201", "createdAt": "2020-03-04T19:43:42Z", "author": {"login": "scholzj"}, "path": "documentation/misc/zookeeper-manual-scaling-methods.md", "diffHunk": "@@ -0,0 +1,149 @@\n+# Zookeeper 3.5.x Manual Scaling Procedures\n+\n+Zookeeper 3.5.x uses a new configuration procedure compare to 3.4.x servers. This \n+[dynamic reconfiguration](https://zookeeper.apache.org/doc/r3.5.7/zookeeperReconfig.html) means that servers need to be\n+added and removed via the Zookeeper command line client (or Admin API) in order to properly maintain a stable Zookeeper \n+cluster. \n+\n+The procedures below outline the steps required to scale up (add) and scale down (remove) servers from an existing \n+Strimzi Kafka deployment.\n+\n+## Scale up procedure\n+\n+The cluster should be scaled **one server at a time**. \n+\n+1) Create an initial Strimzi cluster with n=3 replicas (3 Kafka + 3 ZK servers).\n+\n+2) Set the replica count to n=4 in the zookeeper section of the Kafka CR.\n+\n+3) Allow the ZK server (zookeeper-3) to start up normally and establish a link to the existing quorum.\n+\n+This can be checked with the following command:\n+\n+```\n+kubectl exec -n myproject -it my-cluster-zookeeper-3 -c zookeeper -- bash -c \"echo 'srvr' | nc 127.0.0.1 21813 | grep 'Mode:'\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78764a4ea39e7beb7625e0560e4886f390c0ed90"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5OTc3OQ==", "bodyText": "You should also be more generic about the namespace (myproject) and the cluster name (my-cluster) I think.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388099779", "createdAt": "2020-03-05T06:29:50Z", "author": {"login": "ppatierno"}, "path": "documentation/misc/zookeeper-manual-scaling-methods.md", "diffHunk": "@@ -0,0 +1,149 @@\n+# Zookeeper 3.5.x Manual Scaling Procedures\n+\n+Zookeeper 3.5.x uses a new configuration procedure compare to 3.4.x servers. This \n+[dynamic reconfiguration](https://zookeeper.apache.org/doc/r3.5.7/zookeeperReconfig.html) means that servers need to be\n+added and removed via the Zookeeper command line client (or Admin API) in order to properly maintain a stable Zookeeper \n+cluster. \n+\n+The procedures below outline the steps required to scale up (add) and scale down (remove) servers from an existing \n+Strimzi Kafka deployment.\n+\n+## Scale up procedure\n+\n+The cluster should be scaled **one server at a time**. \n+\n+1) Create an initial Strimzi cluster with n=3 replicas (3 Kafka + 3 ZK servers).\n+\n+2) Set the replica count to n=4 in the zookeeper section of the Kafka CR.\n+\n+3) Allow the ZK server (zookeeper-3) to start up normally and establish a link to the existing quorum.\n+\n+This can be checked with the following command:\n+\n+```\n+kubectl exec -n myproject -it my-cluster-zookeeper-3 -c zookeeper -- bash -c \"echo 'srvr' | nc 127.0.0.1 21813 | grep 'Mode:'\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg5MzIwMQ=="}, "originalCommit": {"oid": "78764a4ea39e7beb7625e0560e4886f390c0ed90"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMzEyMzUyOnYy", "diffSide": "RIGHT", "path": "documentation/misc/zookeeper-manual-scaling-methods.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOTo0Nzo1OFrOFx7RPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOTo0Nzo1OFrOFx7RPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg5NTYxNQ==", "bodyText": "This needs to again stress out the differences ... and also point out that the server.X has different index than all the ports.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387895615", "createdAt": "2020-03-04T19:47:58Z", "author": {"login": "scholzj"}, "path": "documentation/misc/zookeeper-manual-scaling-methods.md", "diffHunk": "@@ -0,0 +1,149 @@\n+# Zookeeper 3.5.x Manual Scaling Procedures\n+\n+Zookeeper 3.5.x uses a new configuration procedure compare to 3.4.x servers. This \n+[dynamic reconfiguration](https://zookeeper.apache.org/doc/r3.5.7/zookeeperReconfig.html) means that servers need to be\n+added and removed via the Zookeeper command line client (or Admin API) in order to properly maintain a stable Zookeeper \n+cluster. \n+\n+The procedures below outline the steps required to scale up (add) and scale down (remove) servers from an existing \n+Strimzi Kafka deployment.\n+\n+## Scale up procedure\n+\n+The cluster should be scaled **one server at a time**. \n+\n+1) Create an initial Strimzi cluster with n=3 replicas (3 Kafka + 3 ZK servers).\n+\n+2) Set the replica count to n=4 in the zookeeper section of the Kafka CR.\n+\n+3) Allow the ZK server (zookeeper-3) to start up normally and establish a link to the existing quorum.\n+\n+This can be checked with the following command:\n+\n+```\n+kubectl exec -n myproject -it my-cluster-zookeeper-3 -c zookeeper -- bash -c \"echo 'srvr' | nc 127.0.0.1 21813 | grep 'Mode:'\"\n+```\n+\n+Which should show something like:\n+\n+```\n+Mode: follower\n+```\n+\n+4) Open a zookeeper-shell session on one of the nodes in the original cluster (in this case nodes 0, 1 or 2):\n+\n+```\n+kubectl exec -n myproject -it my-cluster-zookeeper-0 -c zookeeper -- ./bin/zookeeper-shell.sh localhost:21810\n+```\n+\n+5) Enter the following line to add the new server to the quorum as a voting member:\n+\n+```\n+reconfig -add server.4=127.0.0.1:28883:38883:participant;127.0.0.1:21813", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78764a4ea39e7beb7625e0560e4886f390c0ed90"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDQxMzczOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNjoyMjo0OFrOFyHnPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNjoyMjo0OFrOFyHnPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5Nzg1Mg==", "bodyText": "just one line using a ternary operator instead of this if/else block?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388097852", "createdAt": "2020-03-05T06:22:48Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -217,7 +217,15 @@ public KafkaAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n                         .build();\n             }\n \n-            status.setConditions(Collections.singletonList(readyCondition));\n+            List<Condition> oldConditions = status.getConditions();\n+            List<Condition> newConditions;\n+            if (oldConditions != null) {\n+                newConditions = new ArrayList<>(oldConditions);\n+            } else {\n+                newConditions = new ArrayList<>();\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78764a4ea39e7beb7625e0560e4886f390c0ed90"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDQxOTk2OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNjoyNjowNlrOFyHq3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNjoyNjowNlrOFyHq3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5ODc4MA==", "bodyText": "Ditto as above", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388098780", "createdAt": "2020-03-05T06:26:06Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1392,106 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (currentReplicas > 0 && isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (currentReplicas > 0 && desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = new ConditionBuilder()\n+                                    .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                    .withType(\"ZK-Manual-Scaling\");\n+\n+                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = String.format(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                         \"%s annotation to false.\", Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n \n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = String.format(\"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until %s annotation is set to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+\n+                            } else {\n+                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n+                                if (isZK35x) {\n+                                    zkManualScalingCondition\n+                                            .withStatus(\"False\")\n+                                            .withReason(\"manualScalingNotRequired\")\n+                                            .withMessage(\"Manual scaling of Zookeeper cluster is finished or not required\");\n+                                }\n+\n+                                zkManualScaling = false;\n+                            }\n+\n+                            List<Condition> oldConditions = this.kafkaStatus.getConditions();\n+                            List<Condition> newConditions;\n+                            if (oldConditions != null) {\n+                                newConditions = new ArrayList<>(oldConditions);\n+                            } else {\n+                                newConditions = new ArrayList<>();\n+                            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78764a4ea39e7beb7625e0560e4886f390c0ed90"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDQyMTIzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNjoyNjo0OFrOFyHrnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMDoxNjo0N1rOFyNuew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5ODk3Mg==", "bodyText": "I see all three conditions verifying currentReplicas > 0. What if for any reason currentReplicas is zero?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388098972", "createdAt": "2020-03-05T06:26:48Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1392,106 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (currentReplicas > 0 && isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (currentReplicas > 0 && desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78764a4ea39e7beb7625e0560e4886f390c0ed90"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE5ODAxMQ==", "bodyText": "Good catch, this was left over from the old code where if the STS was null currentReplicas would be 0. However, now all this code is already wrapped in a check for a null STS.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388198011", "createdAt": "2020-03-05T10:16:47Z", "author": {"login": "tomncooper"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1392,106 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (currentReplicas > 0 && isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (currentReplicas > 0 && desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5ODk3Mg=="}, "originalCommit": {"oid": "78764a4ea39e7beb7625e0560e4886f390c0ed90"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDQyNzI3OnYy", "diffSide": "RIGHT", "path": "documentation/misc/zookeeper-manual-scaling-methods.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNjozMDowOVrOFyHvGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNjozMDowOVrOFyHvGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5OTg2NQ==", "bodyText": "ditto as above.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388099865", "createdAt": "2020-03-05T06:30:09Z", "author": {"login": "ppatierno"}, "path": "documentation/misc/zookeeper-manual-scaling-methods.md", "diffHunk": "@@ -0,0 +1,149 @@\n+# Zookeeper 3.5.x Manual Scaling Procedures\n+\n+Zookeeper 3.5.x uses a new configuration procedure compare to 3.4.x servers. This \n+[dynamic reconfiguration](https://zookeeper.apache.org/doc/r3.5.7/zookeeperReconfig.html) means that servers need to be\n+added and removed via the Zookeeper command line client (or Admin API) in order to properly maintain a stable Zookeeper \n+cluster. \n+\n+The procedures below outline the steps required to scale up (add) and scale down (remove) servers from an existing \n+Strimzi Kafka deployment.\n+\n+## Scale up procedure\n+\n+The cluster should be scaled **one server at a time**. \n+\n+1) Create an initial Strimzi cluster with n=3 replicas (3 Kafka + 3 ZK servers).\n+\n+2) Set the replica count to n=4 in the zookeeper section of the Kafka CR.\n+\n+3) Allow the ZK server (zookeeper-3) to start up normally and establish a link to the existing quorum.\n+\n+This can be checked with the following command:\n+\n+```\n+kubectl exec -n myproject -it my-cluster-zookeeper-3 -c zookeeper -- bash -c \"echo 'srvr' | nc 127.0.0.1 21813 | grep 'Mode:'\"\n+```\n+\n+Which should show something like:\n+\n+```\n+Mode: follower\n+```\n+\n+4) Open a zookeeper-shell session on one of the nodes in the original cluster (in this case nodes 0, 1 or 2):\n+\n+```\n+kubectl exec -n myproject -it my-cluster-zookeeper-0 -c zookeeper -- ./bin/zookeeper-shell.sh localhost:21810", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78764a4ea39e7beb7625e0560e4886f390c0ed90"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDQyOTIzOnYy", "diffSide": "RIGHT", "path": "documentation/misc/zookeeper-manual-scaling-methods.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNjozMDo1OFrOFyHwHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNjozMDo1OFrOFyHwHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEwMDEyNw==", "bodyText": "you know ;-)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388100127", "createdAt": "2020-03-05T06:30:58Z", "author": {"login": "ppatierno"}, "path": "documentation/misc/zookeeper-manual-scaling-methods.md", "diffHunk": "@@ -0,0 +1,149 @@\n+# Zookeeper 3.5.x Manual Scaling Procedures\n+\n+Zookeeper 3.5.x uses a new configuration procedure compare to 3.4.x servers. This \n+[dynamic reconfiguration](https://zookeeper.apache.org/doc/r3.5.7/zookeeperReconfig.html) means that servers need to be\n+added and removed via the Zookeeper command line client (or Admin API) in order to properly maintain a stable Zookeeper \n+cluster. \n+\n+The procedures below outline the steps required to scale up (add) and scale down (remove) servers from an existing \n+Strimzi Kafka deployment.\n+\n+## Scale up procedure\n+\n+The cluster should be scaled **one server at a time**. \n+\n+1) Create an initial Strimzi cluster with n=3 replicas (3 Kafka + 3 ZK servers).\n+\n+2) Set the replica count to n=4 in the zookeeper section of the Kafka CR.\n+\n+3) Allow the ZK server (zookeeper-3) to start up normally and establish a link to the existing quorum.\n+\n+This can be checked with the following command:\n+\n+```\n+kubectl exec -n myproject -it my-cluster-zookeeper-3 -c zookeeper -- bash -c \"echo 'srvr' | nc 127.0.0.1 21813 | grep 'Mode:'\"\n+```\n+\n+Which should show something like:\n+\n+```\n+Mode: follower\n+```\n+\n+4) Open a zookeeper-shell session on one of the nodes in the original cluster (in this case nodes 0, 1 or 2):\n+\n+```\n+kubectl exec -n myproject -it my-cluster-zookeeper-0 -c zookeeper -- ./bin/zookeeper-shell.sh localhost:21810\n+```\n+\n+5) Enter the following line to add the new server to the quorum as a voting member:\n+\n+```\n+reconfig -add server.4=127.0.0.1:28883:38883:participant;127.0.0.1:21813\n+```\n+\n+This should then show the new cluster configuration:\n+\n+```\n+server.1=127.0.0.1:28880:38880:participant;127.0.0.1:21810\n+server.2=127.0.0.1:28881:38881:participant;127.0.0.1:21811\n+server.3=127.0.0.1:28882:38882:participant;127.0.0.1:21812\n+server.4=127.0.0.1:28883:38883:participant;127.0.0.1:21813\n+version=100000054\n+```\n+ \n+This new configuration will then propagate to the other servers in the ZK cluster and the new server should now be a full member of the quorum.\n+ \n+6) Increase the replica count by 1 (n=5) in the zookeeper section of the Kafka CR.\n+\n+7) Allow the ZK server (zookeeper-<n-1>) to start up normally and establish a link to the existing quorum.\n+\n+This can be checked with the following command:\n+\n+```\n+kubectl exec -n myproject -it my-cluster-zookeeper-<n-1> -c zookeeper -- bash -c \"echo 'srvr' | nc 127.0.0.1 2181<n-1> | grep 'Mode:'\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78764a4ea39e7beb7625e0560e4886f390c0ed90"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTQxNTM0OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMjowNzo1OVrOFyRGWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMzozMjo0M1rOFyTlOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1MzI3NQ==", "bodyText": "Why do you create a new ArrayList and not just add it to the existing if it exists?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388253275", "createdAt": "2020-03-05T12:07:59Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -217,7 +217,10 @@ public KafkaAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n                         .build();\n             }\n \n-            status.setConditions(Collections.singletonList(readyCondition));\n+            List<Condition> oldConditions = status.getConditions();\n+            List<Condition> newConditions = oldConditions != null ? new ArrayList<>(oldConditions) : new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4OTgwNQ==", "bodyText": "The existing list is an unmodifiable list so we have to create a modifiable copy to be able to add the new status.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388289805", "createdAt": "2020-03-05T13:24:47Z", "author": {"login": "tomncooper"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -217,7 +217,10 @@ public KafkaAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n                         .build();\n             }\n \n-            status.setConditions(Collections.singletonList(readyCondition));\n+            List<Condition> oldConditions = status.getConditions();\n+            List<Condition> newConditions = oldConditions != null ? new ArrayList<>(oldConditions) : new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1MzI3NQ=="}, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5Mzk0Ng==", "bodyText": "Ok, makes sense.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388293946", "createdAt": "2020-03-05T13:32:43Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -217,7 +217,10 @@ public KafkaAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n                         .build();\n             }\n \n-            status.setConditions(Collections.singletonList(readyCondition));\n+            List<Condition> oldConditions = status.getConditions();\n+            List<Condition> newConditions = oldConditions != null ? new ArrayList<>(oldConditions) : new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1MzI3NQ=="}, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTQxODgzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMjowOToyMVrOFyRIgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMzoyNTowMlrOFyTVhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1MzgyNQ==", "bodyText": "I guess we should probably fix the JavaDoc?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388253825", "createdAt": "2020-03-05T12:09:21Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4OTkyNA==", "bodyText": "Good point", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388289924", "createdAt": "2020-03-05T13:25:02Z", "author": {"login": "tomncooper"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1MzgyNQ=="}, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTQyNjc5OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMjoxMjoxM1rOFyRNcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMjoxMjoxM1rOFyRNcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1NTA4OA==", "bodyText": "I'm not sure I understand the comment, because at this point you do not know this is 3.4 or 3.5 - it is not part of this particular else if, or?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388255088", "createdAt": "2020-03-05T12:12:13Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTQzNTM1OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMjoxNToxNFrOFyRSzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMzoyOTo1OVrOFyTfrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1NjQ2MQ==", "bodyText": "Do we need the empty line here?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388256461", "createdAt": "2020-03-05T12:15:14Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5MjUyNA==", "bodyText": "no", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388292524", "createdAt": "2020-03-05T13:29:59Z", "author": {"login": "tomncooper"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1NjQ2MQ=="}, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTQ1MDI3OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMjoyMDozNlrOFyRcIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNDo0NjowMFrOFyWUbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1ODg1MQ==", "bodyText": "If I read the code right, the initial status from line 1435 will be there only until the next reocnciliation which will replace it with the next one. That sounds like very short time and possibly people might not see it. Maybe you can add some parts of that message here as well to make the status more clear (such as the reference to the docs etc.).", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388258851", "createdAt": "2020-03-05T12:20:36Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = null;\n+\n+                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = String.format(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                         \"%s annotation on the Zookeeper StatefulSet to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n \n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = String.format(\"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until %s annotation is set to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition = new ConditionBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMxMTUyNA==", "bodyText": "Good point, I will update the status message. However, at the moment the procedure is in a markdown file in documentation/misc. Were we going to add it to the official docs or the release notes? Is it ok just to refer to the genrnic \"docs\" ?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388311524", "createdAt": "2020-03-05T14:02:34Z", "author": {"login": "tomncooper"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = null;\n+\n+                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = String.format(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                         \"%s annotation on the Zookeeper StatefulSet to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n \n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = String.format(\"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until %s annotation is set to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition = new ConditionBuilder()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1ODg1MQ=="}, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMzODc5OQ==", "bodyText": "I think the generic reference to the docs as it is in the status above should be ok.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388338799", "createdAt": "2020-03-05T14:46:00Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = null;\n+\n+                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = String.format(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                         \"%s annotation on the Zookeeper StatefulSet to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n \n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = String.format(\"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until %s annotation is set to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition = new ConditionBuilder()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1ODg1MQ=="}, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTQ1MzEwOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMjoyMTozMlrOFyRdww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMjoyMTozMlrOFyRdww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1OTI2Nw==", "bodyText": "I don't like nitpicking about empty lines, but it really hits me in the eyes that half of the code has empty line before } and the other half doesn't.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388259267", "createdAt": "2020-03-05T12:21:32Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = null;\n+\n+                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = String.format(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                         \"%s annotation on the Zookeeper StatefulSet to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n \n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = String.format(\"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until %s annotation is set to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTQ1NTMyOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMjoyMjoxNlrOFyRfDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNDowNDowNlrOFyUtSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1OTU5Ng==", "bodyText": "Again, what is the advantage of always creating new ArrayList over using the old one if it already exists? Also, this code seems to be used now at least twice - maybe we can factor it out?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388259596", "createdAt": "2020-03-05T12:22:16Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = null;\n+\n+                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = String.format(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                         \"%s annotation on the Zookeeper StatefulSet to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n \n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = String.format(\"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until %s annotation is set to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+\n+                            } else {\n+                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n+                                zkManualScaling = false;\n+                            }\n+\n+                            if (zkManualScalingCondition != null && isZK35x) {\n+                                List<Condition> oldConditions = this.kafkaStatus.getConditions();\n+                                List<Condition> newConditions = oldConditions != null ? new ArrayList<>(oldConditions) : new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5NjcyMQ==", "bodyText": "So as above this is due to the Status object keeping the Conditions in an unmodifiable list. Should we add a method to the abstract Status class that allows adding conditions to its internal list. That would remove the need for repeating this code.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388296721", "createdAt": "2020-03-05T13:37:43Z", "author": {"login": "tomncooper"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = null;\n+\n+                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = String.format(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                         \"%s annotation on the Zookeeper StatefulSet to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n \n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = String.format(\"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until %s annotation is set to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+\n+                            } else {\n+                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n+                                zkManualScaling = false;\n+                            }\n+\n+                            if (zkManualScalingCondition != null && isZK35x) {\n+                                List<Condition> oldConditions = this.kafkaStatus.getConditions();\n+                                List<Condition> newConditions = oldConditions != null ? new ArrayList<>(oldConditions) : new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1OTU5Ng=="}, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMxMjM5Mw==", "bodyText": "Yeah, I gues either there or in some Utils. Why is it using unmodifiable list? And is it ok if you replace it with regular ArrayList then? Should it be also unmodifiable?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388312393", "createdAt": "2020-03-05T14:04:06Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = null;\n+\n+                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = String.format(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                         \"%s annotation on the Zookeeper StatefulSet to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n \n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = String.format(\"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until %s annotation is set to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+\n+                            } else {\n+                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n+                                zkManualScaling = false;\n+                            }\n+\n+                            if (zkManualScalingCondition != null && isZK35x) {\n+                                List<Condition> oldConditions = this.kafkaStatus.getConditions();\n+                                List<Condition> newConditions = oldConditions != null ? new ArrayList<>(oldConditions) : new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1OTU5Ng=="}, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 146}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 516, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}