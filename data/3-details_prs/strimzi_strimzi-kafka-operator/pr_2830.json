{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzMjI5NDAx", "number": 2830, "title": "[MO] - [system test] -> additional properties of `SSL`", "bodyText": "Signed-off-by: morsak xorsak02@stud.fit.vutbr.cz\nType of change\n\nEnhancement / new feature\n\nDescription\nThis PR adding system test for the checking configuration of the Kafka & Kafka connect additional properties of SSL\nChecklist\n\n Write tests\n Make sure all tests pass", "createdAt": "2020-04-14T14:45:08Z", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830", "merged": true, "mergeCommit": {"oid": "9efc09756e19507528fc79d6b1f81cf4f938b319"}, "closed": true, "closedAt": "2020-04-29T12:49:48Z", "author": {"login": "see-quick"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcXk04agFqTM5MzAxNDc3MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABccT6frgFqTQwMjQ0NTg5MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMDE0Nzcx", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#pullrequestreview-393014771", "createdAt": "2020-04-14T14:59:30Z", "commit": {"oid": "4496a4c4310559fc9cabbdcd210f1766e658ba40"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNDo1OTozMFrOGFS6_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNTowMDowNFrOGFS9Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIwNjA3OA==", "bodyText": "If I read the test correctly ... the configWithLowestVersionOfTls is not compatible with configWithNewestVersionOfTls ... so this should fail and you need to test that it fails IMHO?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#discussion_r408206078", "createdAt": "2020-04-14T14:59:30Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/SslConfigurationST.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest;\n+\n+import io.strimzi.api.kafka.model.KafkaConnectResources;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaConnectResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.utils.kubeUtils.objects.PodUtils;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+public class SslConfigurationST extends SecurityST {\n+\n+    private static final Logger LOGGER = LogManager.getLogger(SslConfigurationST.class);\n+\n+    @Test\n+    void testKafkaAndKafkaConnectTlsVersion() {\n+\n+        Map<String, Object> configWithNewestVersionOfTls = new HashMap<>();\n+\n+        final String tlsVersion12 = \"TLSv1.2\";\n+        final String tlsVersion1 = \"TLSv1\";\n+\n+        configWithNewestVersionOfTls.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion12);\n+        configWithNewestVersionOfTls.put(SslConfigs.SSL_PROTOCOL_CONFIG, SslConfigs.DEFAULT_SSL_PROTOCOL);\n+\n+        LOGGER.info(\"Deploying Kafka cluster with the support {} TLS\",  tlsVersion12);\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+            .editSpec()\n+                .editKafka()\n+                    .withConfig(configWithNewestVersionOfTls)\n+                .endKafka()\n+            .endSpec()\n+            .done();\n+\n+        Map<String, Object> configsFromKafkaCustomResource = KafkaResource.kafkaClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getSpec().getKafka().getConfig();\n+\n+        LOGGER.info(\"Verifying that Kafka cluster has the excepted configuration:\\n\" +\n+                \"\" + SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG + \" -> {}\\n\" +\n+                \"\" + SslConfigs.SSL_PROTOCOL_CONFIG + \" -> {}\",\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG),\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_PROTOCOL_CONFIG));\n+\n+        assertThat(configsFromKafkaCustomResource.get(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG), is(tlsVersion12));\n+        assertThat(configsFromKafkaCustomResource.get(SslConfigs.SSL_PROTOCOL_CONFIG), is(SslConfigs.DEFAULT_SSL_PROTOCOL));\n+\n+        Map<String, Object> configWithLowestVersionOfTls = new HashMap<>();\n+\n+        configWithLowestVersionOfTls.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion1);\n+        configWithLowestVersionOfTls.put(SslConfigs.SSL_PROTOCOL_CONFIG, tlsVersion1);\n+\n+        KafkaClientsResource.deployKafkaClients(KAFKA_CLIENTS_NAME).done();\n+\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+            .editSpec()\n+                .withConfig(configWithLowestVersionOfTls)\n+            .endSpec()\n+            .build());\n+\n+        PodUtils.waitUntilPodIsPresent(KafkaConnectResources.deploymentName(CLUSTER_NAME)); // pod is not ready...", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4496a4c4310559fc9cabbdcd210f1766e658ba40"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIwNjYxNA==", "bodyText": "Connect with capital C? Just a detail ...", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#discussion_r408206614", "createdAt": "2020-04-14T15:00:04Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/SslConfigurationST.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest;\n+\n+import io.strimzi.api.kafka.model.KafkaConnectResources;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaConnectResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.utils.kubeUtils.objects.PodUtils;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+public class SslConfigurationST extends SecurityST {\n+\n+    private static final Logger LOGGER = LogManager.getLogger(SslConfigurationST.class);\n+\n+    @Test\n+    void testKafkaAndKafkaConnectTlsVersion() {\n+\n+        Map<String, Object> configWithNewestVersionOfTls = new HashMap<>();\n+\n+        final String tlsVersion12 = \"TLSv1.2\";\n+        final String tlsVersion1 = \"TLSv1\";\n+\n+        configWithNewestVersionOfTls.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion12);\n+        configWithNewestVersionOfTls.put(SslConfigs.SSL_PROTOCOL_CONFIG, SslConfigs.DEFAULT_SSL_PROTOCOL);\n+\n+        LOGGER.info(\"Deploying Kafka cluster with the support {} TLS\",  tlsVersion12);\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+            .editSpec()\n+                .editKafka()\n+                    .withConfig(configWithNewestVersionOfTls)\n+                .endKafka()\n+            .endSpec()\n+            .done();\n+\n+        Map<String, Object> configsFromKafkaCustomResource = KafkaResource.kafkaClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getSpec().getKafka().getConfig();\n+\n+        LOGGER.info(\"Verifying that Kafka cluster has the excepted configuration:\\n\" +\n+                \"\" + SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG + \" -> {}\\n\" +\n+                \"\" + SslConfigs.SSL_PROTOCOL_CONFIG + \" -> {}\",\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG),\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_PROTOCOL_CONFIG));\n+\n+        assertThat(configsFromKafkaCustomResource.get(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG), is(tlsVersion12));\n+        assertThat(configsFromKafkaCustomResource.get(SslConfigs.SSL_PROTOCOL_CONFIG), is(SslConfigs.DEFAULT_SSL_PROTOCOL));\n+\n+        Map<String, Object> configWithLowestVersionOfTls = new HashMap<>();\n+\n+        configWithLowestVersionOfTls.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion1);\n+        configWithLowestVersionOfTls.put(SslConfigs.SSL_PROTOCOL_CONFIG, tlsVersion1);\n+\n+        KafkaClientsResource.deployKafkaClients(KAFKA_CLIENTS_NAME).done();\n+\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+            .editSpec()\n+                .withConfig(configWithLowestVersionOfTls)\n+            .endSpec()\n+            .build());\n+\n+        PodUtils.waitUntilPodIsPresent(KafkaConnectResources.deploymentName(CLUSTER_NAME)); // pod is not ready...\n+\n+        LOGGER.info(\"Replacing Kafka connect config to the newest(TLSv1.2) one same as the Kafka broker has.\");\n+        KafkaConnectResource.replaceKafkaConnectResource(CLUSTER_NAME, kafkaConnect -> kafkaConnect.getSpec().setConfig(configWithNewestVersionOfTls));\n+\n+        Map<String, Object> configsFromKafkaConnectCustomResource = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getSpec().getConfig();\n+\n+        LOGGER.info(\"Verifying that Kafka connect has the excepted configuration:\\n\" +\n+                \"\" + SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG + \" -> {}\\n\" +\n+                \"\" + SslConfigs.SSL_PROTOCOL_CONFIG + \" -> {}\",\n+            configsFromKafkaConnectCustomResource.get(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG),\n+            configsFromKafkaConnectCustomResource.get(SslConfigs.SSL_PROTOCOL_CONFIG));\n+\n+        assertThat(configsFromKafkaConnectCustomResource.get(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG), is(tlsVersion12));\n+        assertThat(configsFromKafkaConnectCustomResource.get(SslConfigs.SSL_PROTOCOL_CONFIG), is(SslConfigs.DEFAULT_SSL_PROTOCOL));\n+\n+        LOGGER.info(\"Verifying that Kafka connect is stable\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4496a4c4310559fc9cabbdcd210f1766e658ba40"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NDM4Nzk3", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#pullrequestreview-394438797", "createdAt": "2020-04-16T09:06:26Z", "commit": {"oid": "c73a91da86ec30fe7ec8b6369ea566ce2b8eb1c1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwOTowNjoyNlrOGGbyOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwOTowNjoyNlrOGGbyOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM5OTg2Ng==", "bodyText": "Shouldn't we reset the counter here?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#discussion_r409399866", "createdAt": "2020-04-16T09:06:26Z", "author": {"login": "Frawless"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/kubeUtils/objects/PodUtils.java", "diffHunk": "@@ -233,25 +250,27 @@ public static void waitUntilPodsStability(List<Pod> pods) {\n         int[] stabilityCounter = {0};\n \n         TestUtils.waitFor(\"Waiting for pods stability\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n-            () -> {\n-                for (Pod pod : pods) {\n-                    if (pod.getStatus().getPhase().equals(\"Running\")) {\n-                        LOGGER.info(\"Pod {} is in the {} state. Remaining seconds pod to be stable {}\",\n-                            pod.getMetadata().getName(), pod.getStatus().getPhase(),\n-                            Constants.GLOBAL_RECONCILIATION_COUNT - stabilityCounter[0]);\n-                    } else {\n-                        LOGGER.info(\"Pod {} is not stable in phase following phase {}\", pod.getMetadata().getName(), pod.getStatus().getPhase());\n-                        return false;\n-                    }\n-                }\n-                stabilityCounter[0]++;\n+            () -> verifyThatPodsAreStable(pods, stabilityCounter));\n+    }\n \n-                if (stabilityCounter[0] == Constants.GLOBAL_RECONCILIATION_COUNT) {\n-                    LOGGER.info(\"All pods are stable {}\", pods.toString());\n-                    return true;\n-                }\n+    private static boolean verifyThatPodsAreStable(List<Pod> pods, int[] stabilityCounter) {\n+        for (Pod pod : pods) {\n+            if (pod.getStatus().getPhase().equals(\"Running\")) {\n+                LOGGER.info(\"Pod {} is in the {} state. Remaining seconds pod to be stable {}\",\n+                    pod.getMetadata().getName(), pod.getStatus().getPhase(),\n+                    Constants.GLOBAL_RECONCILIATION_COUNT - stabilityCounter[0]);\n+            } else {\n+                LOGGER.info(\"Pod {} is not stable in phase following phase {}\", pod.getMetadata().getName(), pod.getStatus().getPhase());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73a91da86ec30fe7ec8b6369ea566ce2b8eb1c1"}, "originalPosition": 61}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f17c5a5528178a68580c232224f0bf24a0322a4b", "author": {"user": {"login": "see-quick", "name": "Ors\u00e1k Maro\u0161"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/f17c5a5528178a68580c232224f0bf24a0322a4b", "committedDate": "2020-04-16T12:20:12Z", "message": "[MO] - [commend] -> Jakub\n\nSigned-off-by: morsak <xorsak02@stud.fit.vutbr.cz>"}, "afterCommit": {"oid": "6950efa8d467f4019340d4ee3495ecf8a9db64be", "author": {"user": {"login": "see-quick", "name": "Ors\u00e1k Maro\u0161"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/6950efa8d467f4019340d4ee3495ecf8a9db64be", "committedDate": "2020-04-16T12:21:59Z", "message": "[MO] - [commend] -> Jakub\n\nSigned-off-by: morsak <xorsak02@stud.fit.vutbr.cz>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NzQ3Njk5", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#pullrequestreview-394747699", "createdAt": "2020-04-16T15:26:23Z", "commit": {"oid": "6950efa8d467f4019340d4ee3495ecf8a9db64be"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNToyNjoyM1rOGGq1mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNToyNjo0MVrOGGq2rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY0NjQ5MQ==", "bodyText": "I think we should add also a check that the condition is Ready now.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#discussion_r409646491", "createdAt": "2020-04-16T15:26:23Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/SslConfigurationST.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.security;\n+\n+import io.strimzi.api.kafka.model.KafkaConnectResources;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaConnectResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.utils.kafkaUtils.KafkaConnectUtils;\n+import io.strimzi.systemtest.utils.kubeUtils.objects.PodUtils;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static io.strimzi.systemtest.Constants.REGRESSION;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+@Tag(REGRESSION)\n+public class SslConfigurationST extends SecurityST {\n+\n+    private static final Logger LOGGER = LogManager.getLogger(SslConfigurationST.class);\n+\n+    @Test\n+    void testKafkaAndKafkaConnectTlsVersion() {\n+\n+        Map<String, Object> configWithNewestVersionOfTls = new HashMap<>();\n+\n+        final String tlsVersion12 = \"TLSv1.2\";\n+        final String tlsVersion1 = \"TLSv1\";\n+\n+        configWithNewestVersionOfTls.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion12);\n+        configWithNewestVersionOfTls.put(SslConfigs.SSL_PROTOCOL_CONFIG, SslConfigs.DEFAULT_SSL_PROTOCOL);\n+\n+        LOGGER.info(\"Deploying Kafka cluster with the support {} TLS\",  tlsVersion12);\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+            .editSpec()\n+                .editKafka()\n+                    .withConfig(configWithNewestVersionOfTls)\n+                .endKafka()\n+            .endSpec()\n+            .done();\n+\n+        Map<String, Object> configsFromKafkaCustomResource = KafkaResource.kafkaClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getSpec().getKafka().getConfig();\n+\n+        LOGGER.info(\"Verifying that Kafka cluster has the excepted configuration:\\n\" +\n+                \"\" + SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG + \" -> {}\\n\" +\n+                \"\" + SslConfigs.SSL_PROTOCOL_CONFIG + \" -> {}\",\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG),\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_PROTOCOL_CONFIG));\n+\n+        assertThat(configsFromKafkaCustomResource.get(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG), is(tlsVersion12));\n+        assertThat(configsFromKafkaCustomResource.get(SslConfigs.SSL_PROTOCOL_CONFIG), is(SslConfigs.DEFAULT_SSL_PROTOCOL));\n+\n+        Map<String, Object> configWithLowestVersionOfTls = new HashMap<>();\n+\n+        configWithLowestVersionOfTls.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion1);\n+        configWithLowestVersionOfTls.put(SslConfigs.SSL_PROTOCOL_CONFIG, tlsVersion1);\n+\n+        KafkaClientsResource.deployKafkaClients(KAFKA_CLIENTS_NAME).done();\n+\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+            .editSpec()\n+                .withConfig(configWithLowestVersionOfTls)\n+            .endSpec()\n+            .build());\n+\n+        LOGGER.info(\"Verifying that Kafka Connect status is NotReady because of different TLS version\");\n+\n+        KafkaConnectUtils.waitForConnectStatus(CLUSTER_NAME, \"NotReady\");\n+\n+        LOGGER.info(\"Replacing Kafka Connect config to the newest(TLSv1.2) one same as the Kafka broker has.\");\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CLUSTER_NAME, kafkaConnect -> kafkaConnect.getSpec().setConfig(configWithNewestVersionOfTls));\n+\n+        LOGGER.info(\"Verifying that Kafka Connect has the excepted configuration:\\n\" +\n+            SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG + \" -> {}\\n\" + SslConfigs.SSL_PROTOCOL_CONFIG + \" -> {}\",\n+            tlsVersion12, SslConfigs.DEFAULT_SSL_PROTOCOL);\n+\n+        KafkaConnectUtils.waitForKafkaConnectConfigChange(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion12, NAMESPACE, CLUSTER_NAME);\n+        KafkaConnectUtils.waitForKafkaConnectConfigChange(SslConfigs.SSL_PROTOCOL_CONFIG, SslConfigs.DEFAULT_SSL_PROTOCOL, NAMESPACE, CLUSTER_NAME);\n+\n+        LOGGER.info(\"Verifying that Kafka Connect is stable\");\n+\n+        PodUtils.waitUntilPodsByNameStability(KafkaConnectResources.deploymentName(CLUSTER_NAME));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6950efa8d467f4019340d4ee3495ecf8a9db64be"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY0Njc2NA==", "bodyText": "Same as above - you should also check that the KafkaConnect is now ready.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#discussion_r409646764", "createdAt": "2020-04-16T15:26:41Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/SslConfigurationST.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.security;\n+\n+import io.strimzi.api.kafka.model.KafkaConnectResources;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaConnectResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.utils.kafkaUtils.KafkaConnectUtils;\n+import io.strimzi.systemtest.utils.kubeUtils.objects.PodUtils;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static io.strimzi.systemtest.Constants.REGRESSION;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+@Tag(REGRESSION)\n+public class SslConfigurationST extends SecurityST {\n+\n+    private static final Logger LOGGER = LogManager.getLogger(SslConfigurationST.class);\n+\n+    @Test\n+    void testKafkaAndKafkaConnectTlsVersion() {\n+\n+        Map<String, Object> configWithNewestVersionOfTls = new HashMap<>();\n+\n+        final String tlsVersion12 = \"TLSv1.2\";\n+        final String tlsVersion1 = \"TLSv1\";\n+\n+        configWithNewestVersionOfTls.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion12);\n+        configWithNewestVersionOfTls.put(SslConfigs.SSL_PROTOCOL_CONFIG, SslConfigs.DEFAULT_SSL_PROTOCOL);\n+\n+        LOGGER.info(\"Deploying Kafka cluster with the support {} TLS\",  tlsVersion12);\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+            .editSpec()\n+                .editKafka()\n+                    .withConfig(configWithNewestVersionOfTls)\n+                .endKafka()\n+            .endSpec()\n+            .done();\n+\n+        Map<String, Object> configsFromKafkaCustomResource = KafkaResource.kafkaClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getSpec().getKafka().getConfig();\n+\n+        LOGGER.info(\"Verifying that Kafka cluster has the excepted configuration:\\n\" +\n+                \"\" + SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG + \" -> {}\\n\" +\n+                \"\" + SslConfigs.SSL_PROTOCOL_CONFIG + \" -> {}\",\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG),\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_PROTOCOL_CONFIG));\n+\n+        assertThat(configsFromKafkaCustomResource.get(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG), is(tlsVersion12));\n+        assertThat(configsFromKafkaCustomResource.get(SslConfigs.SSL_PROTOCOL_CONFIG), is(SslConfigs.DEFAULT_SSL_PROTOCOL));\n+\n+        Map<String, Object> configWithLowestVersionOfTls = new HashMap<>();\n+\n+        configWithLowestVersionOfTls.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion1);\n+        configWithLowestVersionOfTls.put(SslConfigs.SSL_PROTOCOL_CONFIG, tlsVersion1);\n+\n+        KafkaClientsResource.deployKafkaClients(KAFKA_CLIENTS_NAME).done();\n+\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+            .editSpec()\n+                .withConfig(configWithLowestVersionOfTls)\n+            .endSpec()\n+            .build());\n+\n+        LOGGER.info(\"Verifying that Kafka Connect status is NotReady because of different TLS version\");\n+\n+        KafkaConnectUtils.waitForConnectStatus(CLUSTER_NAME, \"NotReady\");\n+\n+        LOGGER.info(\"Replacing Kafka Connect config to the newest(TLSv1.2) one same as the Kafka broker has.\");\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CLUSTER_NAME, kafkaConnect -> kafkaConnect.getSpec().setConfig(configWithNewestVersionOfTls));\n+\n+        LOGGER.info(\"Verifying that Kafka Connect has the excepted configuration:\\n\" +\n+            SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG + \" -> {}\\n\" + SslConfigs.SSL_PROTOCOL_CONFIG + \" -> {}\",\n+            tlsVersion12, SslConfigs.DEFAULT_SSL_PROTOCOL);\n+\n+        KafkaConnectUtils.waitForKafkaConnectConfigChange(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion12, NAMESPACE, CLUSTER_NAME);\n+        KafkaConnectUtils.waitForKafkaConnectConfigChange(SslConfigs.SSL_PROTOCOL_CONFIG, SslConfigs.DEFAULT_SSL_PROTOCOL, NAMESPACE, CLUSTER_NAME);\n+\n+        LOGGER.info(\"Verifying that Kafka Connect is stable\");\n+\n+        PodUtils.waitUntilPodsByNameStability(KafkaConnectResources.deploymentName(CLUSTER_NAME));\n+    }\n+\n+    @Test\n+    void testKafkaAndKafkaConnectCipherSuites() {\n+        Map<String, Object> configWithCipherSuitesSha384 = new HashMap<>();\n+\n+        final String cipherSuitesSha384 = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+        final String cipherSuitesSha256 = \"TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\";\n+\n+        configWithCipherSuitesSha384.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, cipherSuitesSha384);\n+\n+        LOGGER.info(\"Deploying Kafka cluster with the support {} cipher algorithms\",  cipherSuitesSha384);\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+            .editSpec()\n+                .editKafka()\n+                    .withConfig(configWithCipherSuitesSha384)\n+                .endKafka()\n+            .endSpec()\n+            .done();\n+\n+        Map<String, Object> configsFromKafkaCustomResource = KafkaResource.kafkaClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getSpec().getKafka().getConfig();\n+\n+        LOGGER.info(\"Verifying that Kafka cluster has the excepted configuration:\\n\" + SslConfigs.SSL_CIPHER_SUITES_CONFIG + \" -> {}\",\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_CIPHER_SUITES_CONFIG));\n+\n+        assertThat(configsFromKafkaCustomResource.get(SslConfigs.SSL_CIPHER_SUITES_CONFIG), is(cipherSuitesSha384));\n+\n+        Map<String, Object> configWithCipherSuitesSha256 = new HashMap<>();\n+\n+        configWithCipherSuitesSha256.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, cipherSuitesSha256);\n+\n+        KafkaClientsResource.deployKafkaClients(KAFKA_CLIENTS_NAME).done();\n+\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+            .editSpec()\n+                .withConfig(configWithCipherSuitesSha256)\n+            .endSpec()\n+            .build());\n+\n+        LOGGER.info(\"Verifying that Kafka Connect status is NotReady because of different cipher suites complexity of algorithm\");\n+\n+        KafkaConnectUtils.waitForConnectStatus(CLUSTER_NAME, \"NotReady\");\n+\n+        LOGGER.info(\"Replacing Kafka Connect config to the cipher suites same as the Kafka broker has.\");\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CLUSTER_NAME, kafkaConnect -> kafkaConnect.getSpec().setConfig(configWithCipherSuitesSha384));\n+\n+        LOGGER.info(\"Verifying that Kafka Connect has the excepted configuration:\\n\" +\n+            SslConfigs.SSL_CIPHER_SUITES_CONFIG + \" -> {}\", configsFromKafkaCustomResource.get(SslConfigs.SSL_CIPHER_SUITES_CONFIG));\n+\n+        KafkaConnectUtils.waitForKafkaConnectConfigChange(SslConfigs.SSL_CIPHER_SUITES_CONFIG, cipherSuitesSha384, NAMESPACE, CLUSTER_NAME);\n+\n+        LOGGER.info(\"Verifying that Kafka Connect is stable\");\n+\n+        PodUtils.waitUntilPodsByNameStability(KafkaConnectResources.deploymentName(CLUSTER_NAME));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6950efa8d467f4019340d4ee3495ecf8a9db64be"}, "originalPosition": 149}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1MzQ5MzE5", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#pullrequestreview-395349319", "createdAt": "2020-04-17T10:43:02Z", "commit": {"oid": "6950efa8d467f4019340d4ee3495ecf8a9db64be"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2MjY2NjY0", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#pullrequestreview-396266664", "createdAt": "2020-04-20T09:01:11Z", "commit": {"oid": "49c9062fe88b80e57ab6de4db52bb6dad6861760"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxNTc1Njcx", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#pullrequestreview-401575671", "createdAt": "2020-04-28T07:42:14Z", "commit": {"oid": "49c9062fe88b80e57ab6de4db52bb6dad6861760"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwNzo0MjoxNFrOGNG-Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwODowMjowOVrOGNHvZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM5ODkyMw==", "bodyText": "I always try to start my method Javadocs with a verb (gets, waits, calculates etc), that tends to ensure that the first sentence is concise and to the point.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *  Method waitForKafkaConnectConfigChange, which will wait until the kafka connect CR config will be changed\n          \n          \n            \n                 * Waits until the kafka connect CR config has changed.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#discussion_r416398923", "createdAt": "2020-04-28T07:42:14Z", "author": {"login": "tombentley"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/kafkaUtils/KafkaConnectUtils.java", "diffHunk": "@@ -53,4 +53,22 @@ public static void waitForMessagesInKafkaConnectFileSink(String kafkaConnectPodN\n         waitForMessagesInKafkaConnectFileSink(kafkaConnectPodName, sinkFileName,\n                 \"\\\"Sending messages\\\": \\\"Hello-world - 99\\\"\");\n     }\n+\n+    /**\n+     *  Method waitForKafkaConnectConfigChange, which will wait until the kafka connect CR config will be changed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49c9062fe88b80e57ab6de4db52bb6dad6861760"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwMDgxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Method waitUntilPodsByNameStability ensuring for every pod listed for kafka or zookeeper statefulSet will be controlling\n          \n          \n            \n                 * their status in Running phase. If the pod will be running for selected time #Constants.GLOBAL_RECONCILIATION_COUNT\n          \n          \n            \n                 * pod is considered as a stable. Otherwise this procedure will be repeat.\n          \n          \n            \n                 * Waits until all matching pods are {@linkplain #verifyThatPodsAreStable(List, int) stable} in the \"Running\" phase.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#discussion_r416400819", "createdAt": "2020-04-28T07:45:16Z", "author": {"login": "tombentley"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/kubeUtils/objects/PodUtils.java", "diffHunk": "@@ -223,6 +224,22 @@ public static void waitUntilPodLabelsDeletion(String podName, String... labelKey\n         }\n     }\n \n+    /**\n+     * Method waitUntilPodsByNameStability ensuring for every pod listed for kafka or zookeeper statefulSet will be controlling\n+     * their status in Running phase. If the pod will be running for selected time #Constants.GLOBAL_RECONCILIATION_COUNT\n+     * pod is considered as a stable. Otherwise this procedure will be repeat.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49c9062fe88b80e57ab6de4db52bb6dad6861760"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwMTkyNw==", "bodyText": "It's a bit confusing that this Constants.GLOBAL_RECONCILIATION_COUNT is called a count when according to that logging it's actually a number of seconds. I think you're relying on the caller invoking this from a waitFor() which is polling once per second. I guess that's OK since this is a private method, but I wonder if this contract could be improved.\nI guess the two callers are basically the same except for how they supply the List<Pod>, right? So why not:\n\nChange the List<Pod> pods to Supplier<List<Pod>> pods\nMove the waitFor and the int[] stabilityCounter = {0}; from the callers into this method.\nCall the Supplier each time in the waitFor\n\nThat way the poll interval is defined in the same method as how you're using the stabilityCounter.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#discussion_r416401927", "createdAt": "2020-04-28T07:46:54Z", "author": {"login": "tombentley"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/kubeUtils/objects/PodUtils.java", "diffHunk": "@@ -233,25 +250,29 @@ public static void waitUntilPodsStability(List<Pod> pods) {\n         int[] stabilityCounter = {0};\n \n         TestUtils.waitFor(\"Waiting for pods stability\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n-            () -> {\n-                for (Pod pod : pods) {\n-                    if (pod.getStatus().getPhase().equals(\"Running\")) {\n-                        LOGGER.info(\"Pod {} is in the {} state. Remaining seconds pod to be stable {}\",\n-                            pod.getMetadata().getName(), pod.getStatus().getPhase(),\n-                            Constants.GLOBAL_RECONCILIATION_COUNT - stabilityCounter[0]);\n-                    } else {\n-                        LOGGER.info(\"Pod {} is not stable in phase following phase {}\", pod.getMetadata().getName(), pod.getStatus().getPhase());\n-                        return false;\n-                    }\n-                }\n-                stabilityCounter[0]++;\n+            () -> verifyThatPodsAreStable(pods, stabilityCounter));\n+    }\n \n-                if (stabilityCounter[0] == Constants.GLOBAL_RECONCILIATION_COUNT) {\n-                    LOGGER.info(\"All pods are stable {}\", pods.toString());\n-                    return true;\n-                }\n+    private static boolean verifyThatPodsAreStable(List<Pod> pods, int[] stabilityCounter) {\n+        for (Pod pod : pods) {\n+            if (pod.getStatus().getPhase().equals(\"Running\")) {\n+                LOGGER.info(\"Pod {} is in the {} state. Remaining seconds pod to be stable {}\",\n+                    pod.getMetadata().getName(), pod.getStatus().getPhase(),\n+                    Constants.GLOBAL_RECONCILIATION_COUNT - stabilityCounter[0]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49c9062fe88b80e57ab6de4db52bb6dad6861760"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwNjA5OA==", "bodyText": "Do you mean accepted rather than excepted?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#discussion_r416406098", "createdAt": "2020-04-28T07:53:44Z", "author": {"login": "tombentley"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/SslConfigurationST.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.security;\n+\n+import io.strimzi.api.kafka.model.KafkaConnectResources;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaConnectResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.utils.kafkaUtils.KafkaConnectUtils;\n+import io.strimzi.systemtest.utils.kubeUtils.objects.PodUtils;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static io.strimzi.systemtest.Constants.REGRESSION;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+@Tag(REGRESSION)\n+public class SslConfigurationST extends SecurityST {\n+\n+    private static final Logger LOGGER = LogManager.getLogger(SslConfigurationST.class);\n+\n+    @Test\n+    void testKafkaAndKafkaConnectTlsVersion() {\n+\n+        Map<String, Object> configWithNewestVersionOfTls = new HashMap<>();\n+\n+        final String tlsVersion12 = \"TLSv1.2\";\n+        final String tlsVersion1 = \"TLSv1\";\n+\n+        configWithNewestVersionOfTls.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion12);\n+        configWithNewestVersionOfTls.put(SslConfigs.SSL_PROTOCOL_CONFIG, SslConfigs.DEFAULT_SSL_PROTOCOL);\n+\n+        LOGGER.info(\"Deploying Kafka cluster with the support {} TLS\",  tlsVersion12);\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+            .editSpec()\n+                .editKafka()\n+                    .withConfig(configWithNewestVersionOfTls)\n+                .endKafka()\n+            .endSpec()\n+            .done();\n+\n+        Map<String, Object> configsFromKafkaCustomResource = KafkaResource.kafkaClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getSpec().getKafka().getConfig();\n+\n+        LOGGER.info(\"Verifying that Kafka cluster has the excepted configuration:\\n\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49c9062fe88b80e57ab6de4db52bb6dad6861760"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwNjUzNg==", "bodyText": "Why using + when you could interpolate with {}?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#discussion_r416406536", "createdAt": "2020-04-28T07:54:25Z", "author": {"login": "tombentley"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/SslConfigurationST.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.security;\n+\n+import io.strimzi.api.kafka.model.KafkaConnectResources;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaConnectResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.utils.kafkaUtils.KafkaConnectUtils;\n+import io.strimzi.systemtest.utils.kubeUtils.objects.PodUtils;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static io.strimzi.systemtest.Constants.REGRESSION;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+@Tag(REGRESSION)\n+public class SslConfigurationST extends SecurityST {\n+\n+    private static final Logger LOGGER = LogManager.getLogger(SslConfigurationST.class);\n+\n+    @Test\n+    void testKafkaAndKafkaConnectTlsVersion() {\n+\n+        Map<String, Object> configWithNewestVersionOfTls = new HashMap<>();\n+\n+        final String tlsVersion12 = \"TLSv1.2\";\n+        final String tlsVersion1 = \"TLSv1\";\n+\n+        configWithNewestVersionOfTls.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion12);\n+        configWithNewestVersionOfTls.put(SslConfigs.SSL_PROTOCOL_CONFIG, SslConfigs.DEFAULT_SSL_PROTOCOL);\n+\n+        LOGGER.info(\"Deploying Kafka cluster with the support {} TLS\",  tlsVersion12);\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+            .editSpec()\n+                .editKafka()\n+                    .withConfig(configWithNewestVersionOfTls)\n+                .endKafka()\n+            .endSpec()\n+            .done();\n+\n+        Map<String, Object> configsFromKafkaCustomResource = KafkaResource.kafkaClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getSpec().getKafka().getConfig();\n+\n+        LOGGER.info(\"Verifying that Kafka cluster has the excepted configuration:\\n\" +\n+                \"\" + SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG + \" -> {}\\n\" +\n+                \"\" + SslConfigs.SSL_PROTOCOL_CONFIG + \" -> {}\",\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG),\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_PROTOCOL_CONFIG));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49c9062fe88b80e57ab6de4db52bb6dad6861760"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwNzEzMw==", "bodyText": "Should we also assert on the NotReady reason?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#discussion_r416407133", "createdAt": "2020-04-28T07:55:25Z", "author": {"login": "tombentley"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/SslConfigurationST.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.security;\n+\n+import io.strimzi.api.kafka.model.KafkaConnectResources;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaConnectResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.utils.kafkaUtils.KafkaConnectUtils;\n+import io.strimzi.systemtest.utils.kubeUtils.objects.PodUtils;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static io.strimzi.systemtest.Constants.REGRESSION;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+@Tag(REGRESSION)\n+public class SslConfigurationST extends SecurityST {\n+\n+    private static final Logger LOGGER = LogManager.getLogger(SslConfigurationST.class);\n+\n+    @Test\n+    void testKafkaAndKafkaConnectTlsVersion() {\n+\n+        Map<String, Object> configWithNewestVersionOfTls = new HashMap<>();\n+\n+        final String tlsVersion12 = \"TLSv1.2\";\n+        final String tlsVersion1 = \"TLSv1\";\n+\n+        configWithNewestVersionOfTls.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion12);\n+        configWithNewestVersionOfTls.put(SslConfigs.SSL_PROTOCOL_CONFIG, SslConfigs.DEFAULT_SSL_PROTOCOL);\n+\n+        LOGGER.info(\"Deploying Kafka cluster with the support {} TLS\",  tlsVersion12);\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+            .editSpec()\n+                .editKafka()\n+                    .withConfig(configWithNewestVersionOfTls)\n+                .endKafka()\n+            .endSpec()\n+            .done();\n+\n+        Map<String, Object> configsFromKafkaCustomResource = KafkaResource.kafkaClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getSpec().getKafka().getConfig();\n+\n+        LOGGER.info(\"Verifying that Kafka cluster has the excepted configuration:\\n\" +\n+                \"\" + SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG + \" -> {}\\n\" +\n+                \"\" + SslConfigs.SSL_PROTOCOL_CONFIG + \" -> {}\",\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG),\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_PROTOCOL_CONFIG));\n+\n+        assertThat(configsFromKafkaCustomResource.get(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG), is(tlsVersion12));\n+        assertThat(configsFromKafkaCustomResource.get(SslConfigs.SSL_PROTOCOL_CONFIG), is(SslConfigs.DEFAULT_SSL_PROTOCOL));\n+\n+        Map<String, Object> configWithLowestVersionOfTls = new HashMap<>();\n+\n+        configWithLowestVersionOfTls.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion1);\n+        configWithLowestVersionOfTls.put(SslConfigs.SSL_PROTOCOL_CONFIG, tlsVersion1);\n+\n+        KafkaClientsResource.deployKafkaClients(KAFKA_CLIENTS_NAME).done();\n+\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+            .editSpec()\n+                .withConfig(configWithLowestVersionOfTls)\n+            .endSpec()\n+            .build());\n+\n+        LOGGER.info(\"Verifying that Kafka Connect status is NotReady because of different TLS version\");\n+\n+        KafkaConnectUtils.waitForConnectStatus(CLUSTER_NAME, \"NotReady\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49c9062fe88b80e57ab6de4db52bb6dad6861760"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwNzYxMA==", "bodyText": "Similar comments", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#discussion_r416407610", "createdAt": "2020-04-28T07:56:05Z", "author": {"login": "tombentley"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/SslConfigurationST.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.security;\n+\n+import io.strimzi.api.kafka.model.KafkaConnectResources;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaConnectResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.utils.kafkaUtils.KafkaConnectUtils;\n+import io.strimzi.systemtest.utils.kubeUtils.objects.PodUtils;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static io.strimzi.systemtest.Constants.REGRESSION;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+@Tag(REGRESSION)\n+public class SslConfigurationST extends SecurityST {\n+\n+    private static final Logger LOGGER = LogManager.getLogger(SslConfigurationST.class);\n+\n+    @Test\n+    void testKafkaAndKafkaConnectTlsVersion() {\n+\n+        Map<String, Object> configWithNewestVersionOfTls = new HashMap<>();\n+\n+        final String tlsVersion12 = \"TLSv1.2\";\n+        final String tlsVersion1 = \"TLSv1\";\n+\n+        configWithNewestVersionOfTls.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion12);\n+        configWithNewestVersionOfTls.put(SslConfigs.SSL_PROTOCOL_CONFIG, SslConfigs.DEFAULT_SSL_PROTOCOL);\n+\n+        LOGGER.info(\"Deploying Kafka cluster with the support {} TLS\",  tlsVersion12);\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+            .editSpec()\n+                .editKafka()\n+                    .withConfig(configWithNewestVersionOfTls)\n+                .endKafka()\n+            .endSpec()\n+            .done();\n+\n+        Map<String, Object> configsFromKafkaCustomResource = KafkaResource.kafkaClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getSpec().getKafka().getConfig();\n+\n+        LOGGER.info(\"Verifying that Kafka cluster has the excepted configuration:\\n\" +\n+                \"\" + SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG + \" -> {}\\n\" +\n+                \"\" + SslConfigs.SSL_PROTOCOL_CONFIG + \" -> {}\",\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG),\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_PROTOCOL_CONFIG));\n+\n+        assertThat(configsFromKafkaCustomResource.get(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG), is(tlsVersion12));\n+        assertThat(configsFromKafkaCustomResource.get(SslConfigs.SSL_PROTOCOL_CONFIG), is(SslConfigs.DEFAULT_SSL_PROTOCOL));\n+\n+        Map<String, Object> configWithLowestVersionOfTls = new HashMap<>();\n+\n+        configWithLowestVersionOfTls.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion1);\n+        configWithLowestVersionOfTls.put(SslConfigs.SSL_PROTOCOL_CONFIG, tlsVersion1);\n+\n+        KafkaClientsResource.deployKafkaClients(KAFKA_CLIENTS_NAME).done();\n+\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+            .editSpec()\n+                .withConfig(configWithLowestVersionOfTls)\n+            .endSpec()\n+            .build());\n+\n+        LOGGER.info(\"Verifying that Kafka Connect status is NotReady because of different TLS version\");\n+\n+        KafkaConnectUtils.waitForConnectStatus(CLUSTER_NAME, \"NotReady\");\n+\n+        LOGGER.info(\"Replacing Kafka Connect config to the newest(TLSv1.2) one same as the Kafka broker has.\");\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CLUSTER_NAME, kafkaConnect -> kafkaConnect.getSpec().setConfig(configWithNewestVersionOfTls));\n+\n+        LOGGER.info(\"Verifying that Kafka Connect has the excepted configuration:\\n\" +\n+            SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG + \" -> {}\\n\" + SslConfigs.SSL_PROTOCOL_CONFIG + \" -> {}\",\n+            tlsVersion12, SslConfigs.DEFAULT_SSL_PROTOCOL);\n+\n+        KafkaConnectUtils.waitForKafkaConnectConfigChange(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion12, NAMESPACE, CLUSTER_NAME);\n+        KafkaConnectUtils.waitForKafkaConnectConfigChange(SslConfigs.SSL_PROTOCOL_CONFIG, SslConfigs.DEFAULT_SSL_PROTOCOL, NAMESPACE, CLUSTER_NAME);\n+\n+        LOGGER.info(\"Verifying that Kafka Connect is stable\");\n+\n+        PodUtils.waitUntilPodsByNameStability(KafkaConnectResources.deploymentName(CLUSTER_NAME));\n+\n+        LOGGER.info(\"Verifying that Kafka Connect status is Ready because of same TLS version\");\n+\n+        KafkaConnectUtils.waitForConnectStatus(CLUSTER_NAME, \"Ready\");\n+    }\n+\n+    @Test\n+    void testKafkaAndKafkaConnectCipherSuites() {\n+        Map<String, Object> configWithCipherSuitesSha384 = new HashMap<>();\n+\n+        final String cipherSuitesSha384 = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+        final String cipherSuitesSha256 = \"TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\";\n+\n+        configWithCipherSuitesSha384.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, cipherSuitesSha384);\n+\n+        LOGGER.info(\"Deploying Kafka cluster with the support {} cipher algorithms\",  cipherSuitesSha384);\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+            .editSpec()\n+                .editKafka()\n+                    .withConfig(configWithCipherSuitesSha384)\n+                .endKafka()\n+            .endSpec()\n+            .done();\n+\n+        Map<String, Object> configsFromKafkaCustomResource = KafkaResource.kafkaClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getSpec().getKafka().getConfig();\n+\n+        LOGGER.info(\"Verifying that Kafka cluster has the excepted configuration:\\n\" + SslConfigs.SSL_CIPHER_SUITES_CONFIG + \" -> {}\",\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_CIPHER_SUITES_CONFIG));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49c9062fe88b80e57ab6de4db52bb6dad6861760"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwNzg0Mg==", "bodyText": "Again why +", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#discussion_r416407842", "createdAt": "2020-04-28T07:56:23Z", "author": {"login": "tombentley"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/SslConfigurationST.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.security;\n+\n+import io.strimzi.api.kafka.model.KafkaConnectResources;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaConnectResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.utils.kafkaUtils.KafkaConnectUtils;\n+import io.strimzi.systemtest.utils.kubeUtils.objects.PodUtils;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static io.strimzi.systemtest.Constants.REGRESSION;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+@Tag(REGRESSION)\n+public class SslConfigurationST extends SecurityST {\n+\n+    private static final Logger LOGGER = LogManager.getLogger(SslConfigurationST.class);\n+\n+    @Test\n+    void testKafkaAndKafkaConnectTlsVersion() {\n+\n+        Map<String, Object> configWithNewestVersionOfTls = new HashMap<>();\n+\n+        final String tlsVersion12 = \"TLSv1.2\";\n+        final String tlsVersion1 = \"TLSv1\";\n+\n+        configWithNewestVersionOfTls.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion12);\n+        configWithNewestVersionOfTls.put(SslConfigs.SSL_PROTOCOL_CONFIG, SslConfigs.DEFAULT_SSL_PROTOCOL);\n+\n+        LOGGER.info(\"Deploying Kafka cluster with the support {} TLS\",  tlsVersion12);\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+            .editSpec()\n+                .editKafka()\n+                    .withConfig(configWithNewestVersionOfTls)\n+                .endKafka()\n+            .endSpec()\n+            .done();\n+\n+        Map<String, Object> configsFromKafkaCustomResource = KafkaResource.kafkaClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getSpec().getKafka().getConfig();\n+\n+        LOGGER.info(\"Verifying that Kafka cluster has the excepted configuration:\\n\" +\n+                \"\" + SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG + \" -> {}\\n\" +\n+                \"\" + SslConfigs.SSL_PROTOCOL_CONFIG + \" -> {}\",\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG),\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_PROTOCOL_CONFIG));\n+\n+        assertThat(configsFromKafkaCustomResource.get(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG), is(tlsVersion12));\n+        assertThat(configsFromKafkaCustomResource.get(SslConfigs.SSL_PROTOCOL_CONFIG), is(SslConfigs.DEFAULT_SSL_PROTOCOL));\n+\n+        Map<String, Object> configWithLowestVersionOfTls = new HashMap<>();\n+\n+        configWithLowestVersionOfTls.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion1);\n+        configWithLowestVersionOfTls.put(SslConfigs.SSL_PROTOCOL_CONFIG, tlsVersion1);\n+\n+        KafkaClientsResource.deployKafkaClients(KAFKA_CLIENTS_NAME).done();\n+\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+            .editSpec()\n+                .withConfig(configWithLowestVersionOfTls)\n+            .endSpec()\n+            .build());\n+\n+        LOGGER.info(\"Verifying that Kafka Connect status is NotReady because of different TLS version\");\n+\n+        KafkaConnectUtils.waitForConnectStatus(CLUSTER_NAME, \"NotReady\");\n+\n+        LOGGER.info(\"Replacing Kafka Connect config to the newest(TLSv1.2) one same as the Kafka broker has.\");\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CLUSTER_NAME, kafkaConnect -> kafkaConnect.getSpec().setConfig(configWithNewestVersionOfTls));\n+\n+        LOGGER.info(\"Verifying that Kafka Connect has the excepted configuration:\\n\" +\n+            SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG + \" -> {}\\n\" + SslConfigs.SSL_PROTOCOL_CONFIG + \" -> {}\",\n+            tlsVersion12, SslConfigs.DEFAULT_SSL_PROTOCOL);\n+\n+        KafkaConnectUtils.waitForKafkaConnectConfigChange(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion12, NAMESPACE, CLUSTER_NAME);\n+        KafkaConnectUtils.waitForKafkaConnectConfigChange(SslConfigs.SSL_PROTOCOL_CONFIG, SslConfigs.DEFAULT_SSL_PROTOCOL, NAMESPACE, CLUSTER_NAME);\n+\n+        LOGGER.info(\"Verifying that Kafka Connect is stable\");\n+\n+        PodUtils.waitUntilPodsByNameStability(KafkaConnectResources.deploymentName(CLUSTER_NAME));\n+\n+        LOGGER.info(\"Verifying that Kafka Connect status is Ready because of same TLS version\");\n+\n+        KafkaConnectUtils.waitForConnectStatus(CLUSTER_NAME, \"Ready\");\n+    }\n+\n+    @Test\n+    void testKafkaAndKafkaConnectCipherSuites() {\n+        Map<String, Object> configWithCipherSuitesSha384 = new HashMap<>();\n+\n+        final String cipherSuitesSha384 = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+        final String cipherSuitesSha256 = \"TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\";\n+\n+        configWithCipherSuitesSha384.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, cipherSuitesSha384);\n+\n+        LOGGER.info(\"Deploying Kafka cluster with the support {} cipher algorithms\",  cipherSuitesSha384);\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+            .editSpec()\n+                .editKafka()\n+                    .withConfig(configWithCipherSuitesSha384)\n+                .endKafka()\n+            .endSpec()\n+            .done();\n+\n+        Map<String, Object> configsFromKafkaCustomResource = KafkaResource.kafkaClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getSpec().getKafka().getConfig();\n+\n+        LOGGER.info(\"Verifying that Kafka cluster has the excepted configuration:\\n\" + SslConfigs.SSL_CIPHER_SUITES_CONFIG + \" -> {}\",\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_CIPHER_SUITES_CONFIG));\n+\n+        assertThat(configsFromKafkaCustomResource.get(SslConfigs.SSL_CIPHER_SUITES_CONFIG), is(cipherSuitesSha384));\n+\n+        Map<String, Object> configWithCipherSuitesSha256 = new HashMap<>();\n+\n+        configWithCipherSuitesSha256.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, cipherSuitesSha256);\n+\n+        KafkaClientsResource.deployKafkaClients(KAFKA_CLIENTS_NAME).done();\n+\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+            .editSpec()\n+                .withConfig(configWithCipherSuitesSha256)\n+            .endSpec()\n+            .build());\n+\n+        LOGGER.info(\"Verifying that Kafka Connect status is NotReady because of different cipher suites complexity of algorithm\");\n+\n+        KafkaConnectUtils.waitForConnectStatus(CLUSTER_NAME, \"NotReady\");\n+\n+        LOGGER.info(\"Replacing Kafka Connect config to the cipher suites same as the Kafka broker has.\");\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CLUSTER_NAME, kafkaConnect -> kafkaConnect.getSpec().setConfig(configWithCipherSuitesSha384));\n+\n+        LOGGER.info(\"Verifying that Kafka Connect has the excepted configuration:\\n\" +\n+            SslConfigs.SSL_CIPHER_SUITES_CONFIG + \" -> {}\", configsFromKafkaCustomResource.get(SslConfigs.SSL_CIPHER_SUITES_CONFIG));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49c9062fe88b80e57ab6de4db52bb6dad6861760"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwODAxNQ==", "bodyText": "Again, why +?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#discussion_r416408015", "createdAt": "2020-04-28T07:56:42Z", "author": {"login": "tombentley"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/SslConfigurationST.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.security;\n+\n+import io.strimzi.api.kafka.model.KafkaConnectResources;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaConnectResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.utils.kafkaUtils.KafkaConnectUtils;\n+import io.strimzi.systemtest.utils.kubeUtils.objects.PodUtils;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static io.strimzi.systemtest.Constants.REGRESSION;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+@Tag(REGRESSION)\n+public class SslConfigurationST extends SecurityST {\n+\n+    private static final Logger LOGGER = LogManager.getLogger(SslConfigurationST.class);\n+\n+    @Test\n+    void testKafkaAndKafkaConnectTlsVersion() {\n+\n+        Map<String, Object> configWithNewestVersionOfTls = new HashMap<>();\n+\n+        final String tlsVersion12 = \"TLSv1.2\";\n+        final String tlsVersion1 = \"TLSv1\";\n+\n+        configWithNewestVersionOfTls.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion12);\n+        configWithNewestVersionOfTls.put(SslConfigs.SSL_PROTOCOL_CONFIG, SslConfigs.DEFAULT_SSL_PROTOCOL);\n+\n+        LOGGER.info(\"Deploying Kafka cluster with the support {} TLS\",  tlsVersion12);\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+            .editSpec()\n+                .editKafka()\n+                    .withConfig(configWithNewestVersionOfTls)\n+                .endKafka()\n+            .endSpec()\n+            .done();\n+\n+        Map<String, Object> configsFromKafkaCustomResource = KafkaResource.kafkaClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getSpec().getKafka().getConfig();\n+\n+        LOGGER.info(\"Verifying that Kafka cluster has the excepted configuration:\\n\" +\n+                \"\" + SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG + \" -> {}\\n\" +\n+                \"\" + SslConfigs.SSL_PROTOCOL_CONFIG + \" -> {}\",\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG),\n+            configsFromKafkaCustomResource.get(SslConfigs.SSL_PROTOCOL_CONFIG));\n+\n+        assertThat(configsFromKafkaCustomResource.get(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG), is(tlsVersion12));\n+        assertThat(configsFromKafkaCustomResource.get(SslConfigs.SSL_PROTOCOL_CONFIG), is(SslConfigs.DEFAULT_SSL_PROTOCOL));\n+\n+        Map<String, Object> configWithLowestVersionOfTls = new HashMap<>();\n+\n+        configWithLowestVersionOfTls.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsVersion1);\n+        configWithLowestVersionOfTls.put(SslConfigs.SSL_PROTOCOL_CONFIG, tlsVersion1);\n+\n+        KafkaClientsResource.deployKafkaClients(KAFKA_CLIENTS_NAME).done();\n+\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+            .editSpec()\n+                .withConfig(configWithLowestVersionOfTls)\n+            .endSpec()\n+            .build());\n+\n+        LOGGER.info(\"Verifying that Kafka Connect status is NotReady because of different TLS version\");\n+\n+        KafkaConnectUtils.waitForConnectStatus(CLUSTER_NAME, \"NotReady\");\n+\n+        LOGGER.info(\"Replacing Kafka Connect config to the newest(TLSv1.2) one same as the Kafka broker has.\");\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CLUSTER_NAME, kafkaConnect -> kafkaConnect.getSpec().setConfig(configWithNewestVersionOfTls));\n+\n+        LOGGER.info(\"Verifying that Kafka Connect has the excepted configuration:\\n\" +\n+            SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG + \" -> {}\\n\" + SslConfigs.SSL_PROTOCOL_CONFIG + \" -> {}\",\n+            tlsVersion12, SslConfigs.DEFAULT_SSL_PROTOCOL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49c9062fe88b80e57ab6de4db52bb6dad6861760"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQxMTQ5NA==", "bodyText": "You should factor out a local variable for KafkaConnectResource.kafkaConnectClient().inNamespace(namespace).withName(clusterName).get().getSpec().getConfig().get(propertyKey)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#discussion_r416411494", "createdAt": "2020-04-28T08:02:09Z", "author": {"login": "tombentley"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/kafkaUtils/KafkaConnectUtils.java", "diffHunk": "@@ -53,4 +53,22 @@ public static void waitForMessagesInKafkaConnectFileSink(String kafkaConnectPodN\n         waitForMessagesInKafkaConnectFileSink(kafkaConnectPodName, sinkFileName,\n                 \"\\\"Sending messages\\\": \\\"Hello-world - 99\\\"\");\n     }\n+\n+    /**\n+     *  Method waitForKafkaConnectConfigChange, which will wait until the kafka connect CR config will be changed\n+     * @param propertyKey property key in the Kafka Connect CR config\n+     * @param propertyValue property value in the Kafka Connect CR config\n+     * @param namespace namespace name\n+     * @param clusterName cluster name\n+     */\n+    public static void waitForKafkaConnectConfigChange(String propertyKey, String propertyValue, String namespace, String clusterName) {\n+        LOGGER.info(\"Waiting for Kafka Connect property {} -> {} change\", propertyKey, propertyValue);\n+        TestUtils.waitFor(\"Waiting for Kafka Connect config \" + propertyKey + \" -> \" + propertyValue, Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> {\n+                LOGGER.debug(\"Property key -> {}, Current property value -> {}\", propertyKey, KafkaConnectResource.kafkaConnectClient().inNamespace(namespace).withName(clusterName).get().getSpec().getConfig().get(propertyKey));\n+                LOGGER.debug(KafkaConnectResource.kafkaConnectClient().inNamespace(namespace).withName(clusterName).get().getSpec().getConfig().get(propertyKey) + \" == \" + propertyValue);\n+                return KafkaConnectResource.kafkaConnectClient().inNamespace(namespace).withName(clusterName).get().getSpec().getConfig().get(propertyKey).equals(propertyValue);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49c9062fe88b80e57ab6de4db52bb6dad6861760"}, "originalPosition": 18}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c45e7871e04b1bf9f83368b4c54d28c5be6172b", "author": {"user": {"login": "see-quick", "name": "Ors\u00e1k Maro\u0161"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/9c45e7871e04b1bf9f83368b4c54d28c5be6172b", "committedDate": "2020-04-28T10:11:51Z", "message": "[MO] - [system test] -> ssl\n\nSigned-off-by: morsak <xorsak02@stud.fit.vutbr.cz>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89410e3705ccd09839157945c01aaeef8e189c77", "author": {"user": {"login": "see-quick", "name": "Ors\u00e1k Maro\u0161"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/89410e3705ccd09839157945c01aaeef8e189c77", "committedDate": "2020-04-28T10:11:51Z", "message": "[MO] - [commends] -> Jakub\n\nSigned-off-by: morsak <xorsak02@stud.fit.vutbr.cz>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66e7c730a0c534f3449eedc99dc47be288de7add", "author": {"user": {"login": "see-quick", "name": "Ors\u00e1k Maro\u0161"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/66e7c730a0c534f3449eedc99dc47be288de7add", "committedDate": "2020-04-28T10:11:51Z", "message": "[MO] -s\n\nSigned-off-by: morsak <xorsak02@stud.fit.vutbr.cz>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12b270dc334950ce97e7593bd5f671662047e207", "author": {"user": {"login": "see-quick", "name": "Ors\u00e1k Maro\u0161"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/12b270dc334950ce97e7593bd5f671662047e207", "committedDate": "2020-04-28T10:11:51Z", "message": "[MO] - [cipher] -> adding test case for cipher version\n\nSigned-off-by: morsak <xorsak02@stud.fit.vutbr.cz>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6235d85c88e4216f22737f97cbcb59d45e3654c4", "author": {"user": {"login": "see-quick", "name": "Ors\u00e1k Maro\u0161"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/6235d85c88e4216f22737f97cbcb59d45e3654c4", "committedDate": "2020-04-28T10:11:51Z", "message": "[MO] - [tag] -> regression\n\nSigned-off-by: morsak <xorsak02@stud.fit.vutbr.cz>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2ad735bbf54ae2e78730189a1c4851c255b23cc", "author": {"user": {"login": "see-quick", "name": "Ors\u00e1k Maro\u0161"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c2ad735bbf54ae2e78730189a1c4851c255b23cc", "committedDate": "2020-04-28T10:11:51Z", "message": "s\n\nSigned-off-by: morsak <xorsak02@stud.fit.vutbr.cz>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c8994c8fb6cef1d4397245ffee97ced47a43f1e", "author": {"user": {"login": "see-quick", "name": "Ors\u00e1k Maro\u0161"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5c8994c8fb6cef1d4397245ffee97ced47a43f1e", "committedDate": "2020-04-28T10:11:51Z", "message": "[MO] - [commend] -> Jakub\n\nSigned-off-by: morsak <xorsak02@stud.fit.vutbr.cz>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ee3a8d1cbb12d6ebab8995a88d823dd919d62d2", "author": {"user": {"login": "see-quick", "name": "Ors\u00e1k Maro\u0161"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/9ee3a8d1cbb12d6ebab8995a88d823dd919d62d2", "committedDate": "2020-04-28T10:11:51Z", "message": "[MO] - [jakub] -> commends\n\nSigned-off-by: morsak <xorsak02@stud.fit.vutbr.cz>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "070db9a6f21e1d9d421abe6d55558f105c1c1113", "author": {"user": {"login": "tombentley", "name": "Tom Bentley"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/070db9a6f21e1d9d421abe6d55558f105c1c1113", "committedDate": "2020-04-28T10:16:21Z", "message": "Tom's suggestion\n\nSigned-off-by: Tom Bentley <tbentley@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4704d55f276d075067c38801fe0aba940dd73ffa", "author": {"user": {"login": "see-quick", "name": "Ors\u00e1k Maro\u0161"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/4704d55f276d075067c38801fe0aba940dd73ffa", "committedDate": "2020-04-28T10:16:21Z", "message": "[MO] -[ ss\n\nSigned-off-by: morsak <xorsak02@stud.fit.vutbr.cz>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2e626d126485b8c1ddccc53539c66b6701d0b35", "author": {"user": {"login": "see-quick", "name": "Ors\u00e1k Maro\u0161"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b2e626d126485b8c1ddccc53539c66b6701d0b35", "committedDate": "2020-04-28T10:16:58Z", "message": "ss\n\nSigned-off-by: morsak <xorsak02@stud.fit.vutbr.cz>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e4a9bbec4586e8a19ce3a5217e780335b2bbef48", "author": {"user": {"login": "see-quick", "name": "Ors\u00e1k Maro\u0161"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e4a9bbec4586e8a19ce3a5217e780335b2bbef48", "committedDate": "2020-04-28T10:06:36Z", "message": "[MO] -[ ss\n\nSigned-off-by: morsak <xorsak02@stud.fit.vutbr.cz>"}, "afterCommit": {"oid": "b2e626d126485b8c1ddccc53539c66b6701d0b35", "author": {"user": {"login": "see-quick", "name": "Ors\u00e1k Maro\u0161"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b2e626d126485b8c1ddccc53539c66b6701d0b35", "committedDate": "2020-04-28T10:16:58Z", "message": "ss\n\nSigned-off-by: morsak <xorsak02@stud.fit.vutbr.cz>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyNDQ1ODkw", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2830#pullrequestreview-402445890", "createdAt": "2020-04-29T08:08:03Z", "commit": {"oid": "b2e626d126485b8c1ddccc53539c66b6701d0b35"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1850, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}