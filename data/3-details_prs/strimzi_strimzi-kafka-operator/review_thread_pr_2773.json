{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3MTEwMjQx", "number": 2773, "reviewThreads": {"totalCount": 97, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNzo1NToyN1rODtpITw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDo1MToyNVrOD1OLvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MTg2MzgzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/template/CruiseControlTemplate.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNzo1NToyOFrOF_MGqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODoyMzo0NFrOF_gaOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMjkyMA==", "bodyText": "*Container needs capitalization in cruiseControlContainer", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r401802920", "createdAt": "2020-04-01T17:55:28Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/template/CruiseControlTemplate.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.template;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of a template for Cruise Control resources.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"deployment\", \"pod\", \"apiService\", \"podDisruptionBudget\", \"cruiseControlcontainer\", \"tlsSidecarContainer\"})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzNTYwOQ==", "bodyText": "I've opened #2779 for resolving this sort of thing once and for all.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402135609", "createdAt": "2020-04-02T08:23:44Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/template/CruiseControlTemplate.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.template;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of a template for Cruise Control resources.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"deployment\", \"pod\", \"apiService\", \"podDisruptionBudget\", \"cruiseControlcontainer\", \"tlsSidecarContainer\"})", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMjkyMA=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MTk0NTM4OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxODoxODoxMVrOF_M6YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxODoxODoxMVrOF_M6YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxNjE2MQ==", "bodyText": "Minor niggle, but from a failing test point of view might the check\nassertThat(svc.getMetadata().getLabels(), is(svcLabels));\n\ngive a more informative error message on failure? This applys to all of the assertions in this file with containsAll calls", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r401816161", "createdAt": "2020-04-01T18:18:11Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));\n+\n+        // Test generated disk capacity\n+        JbodStorage jbodStorage = new JbodStorage();\n+        List<SingleVolumeStorage> volumes = new ArrayList<SingleVolumeStorage>();\n+\n+        PersistentClaimStorage p1 = new PersistentClaimStorage();\n+        p1.setId(0);\n+        p1.setSize(\"50Gi\");\n+        volumes.add(p1);\n+\n+        PersistentClaimStorage p2 = new PersistentClaimStorage();\n+        p2.setId(1);\n+        p2.setSize(\"50G\");\n+        volumes.add(p2);\n+\n+        jbodStorage.setVolumes(volumes);\n+\n+        resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withStorage(jbodStorage)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+        Capacity generatedCapacity = new Capacity(resource.getSpec());\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(generatedCapacity.getDisk())));\n+    }\n+\n+    @Test\n+    public void testFromConfigMap() {\n+        assertThat(cc.namespace, is(namespace));\n+        assertThat(cc.cluster, is(cluster));\n+        assertThat(cc.getImage(), is(ccImage));\n+    }\n+\n+    @Test\n+    public void testGenerateDeployment() {\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        assertThat(containers.size(), is(2));\n+\n+        assertThat(dep.getMetadata().getName(), is(CruiseControlResources.deploymentName(cluster)));\n+        assertThat(dep.getMetadata().getNamespace(), is(namespace));\n+        assertThat(dep.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(dep.getMetadata().getOwnerReferences().get(0), is(cc.createOwnerReference()));\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImage(), is(cc.image));\n+        assertThat(ccContainer.getLivenessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getLivenessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getReadinessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getReadinessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getEnv(), is(getExpectedEnvVars()));\n+        assertThat(ccContainer.getPorts().size(), is(1));\n+        assertThat(ccContainer.getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(ccContainer.getPorts().get(0).getProtocol(), is(\"TCP\"));\n+        assertThat(dep.getSpec().getStrategy().getType(), is(\"RollingUpdate\"));\n+\n+        // Test volumes\n+        List<Volume> volumes = dep.getSpec().getTemplate().getSpec().getVolumes();\n+        assertThat(volumes.size(), is(3));\n+\n+        Volume volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(CruiseControl.secretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(AbstractModel.clusterCaCertSecretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getConfigMap().getName(), is(CruiseControl.metricAndLogConfigsName(cluster)));\n+\n+        // Test volume mounts\n+        List<VolumeMount> volumesMounts = dep.getSpec().getTemplate().getSpec().getContainers().get(0).getVolumeMounts();\n+        assertThat(volumesMounts.size(), is(3));\n+\n+        VolumeMount volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_MOUNT));\n+    }\n+\n+    @Test\n+    public void testEnvVars()   {\n+        assertThat(cc.getEnvVars(), is(getExpectedEnvVars()));\n+    }\n+\n+    @Test\n+    public void testImagePullPolicy() {\n+        Deployment dep = cc.generateDeployment(true, null, ImagePullPolicy.ALWAYS, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.ALWAYS.toString()));\n+\n+        dep = cc.generateDeployment(true, null,  ImagePullPolicy.IFNOTPRESENT, null);\n+        containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.IFNOTPRESENT.toString()));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVars() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"test.env.two\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                       .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvTwoKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvTwoValue));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVarsWithKeyConflict() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"my-special-value\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                        .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+    }\n+\n+    @Test\n+    public void testCruiseControlNotDeployed() {\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null,  null);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        try {\n+            assertThat(cc.generateDeployment(true, null, null, null), is(nullValue()));\n+            assertThat(cc.generateService(), is(nullValue()));\n+            assertThat(cc.generateSecret(null, true), is(nullValue()));\n+        } catch (Throwable expected) {\n+            assertEquals(NullPointerException.class, expected.getClass());\n+        }\n+    }\n+\n+    @Test\n+    public void testGenerateService()   {\n+        Service svc = cc.generateService();\n+\n+        assertThat(svc.getSpec().getType(), is(\"ClusterIP\"));\n+        assertThat(svc.getMetadata().getLabels(), is(expectedLabels(cc.getServiceName())));\n+        assertThat(svc.getSpec().getSelector(), is(expectedSelectorLabels()));\n+        assertThat(svc.getSpec().getPorts().size(), is(1));\n+        assertThat(svc.getSpec().getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(svc.getSpec().getPorts().get(0).getPort(), is(new Integer(CruiseControl.REST_API_PORT)));\n+        assertThat(svc.getSpec().getPorts().get(0).getProtocol(), is(\"TCP\"));\n+\n+        checkOwnerReference(cc.createOwnerReference(), svc);\n+    }\n+\n+    @Test\n+    public void testGenerateServiceWhenDisabled()   {\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, null);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        try {\n+            assertThat(cc.generateService(), is(nullValue()));\n+        } catch (Throwable expected) {\n+            assertEquals(NullPointerException.class, expected.getClass());\n+        }\n+    }\n+\n+    @Test\n+    public void testTemplate() {\n+        Map<String, String> depLabels = TestUtils.map(\"l1\", \"v1\", \"l2\", \"v2\");\n+        Map<String, String> depAnots = TestUtils.map(\"a1\", \"v1\", \"a2\", \"v2\");\n+\n+        Map<String, String> podLabels = TestUtils.map(\"l3\", \"v3\", \"l4\", \"v4\");\n+        Map<String, String> podAnots = TestUtils.map(\"a3\", \"v3\", \"a4\", \"v4\");\n+\n+        Map<String, String> svcLabels = TestUtils.map(\"l5\", \"v5\", \"l6\", \"v6\");\n+        Map<String, String> svcAnots = TestUtils.map(\"a5\", \"v5\", \"a6\", \"v6\");\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+                .editSpec()\n+                    .withNewCruiseControl()\n+                        .withImage(ccImage)\n+                        .withNewTemplate()\n+                            .withNewDeployment()\n+                                .withNewMetadata()\n+                                    .withLabels(depLabels)\n+                                    .withAnnotations(depAnots)\n+                                .endMetadata()\n+                            .endDeployment()\n+                            .withNewPod()\n+                                .withNewMetadata()\n+                                    .withLabels(podLabels)\n+                                    .withAnnotations(podAnots)\n+                                .endMetadata()\n+                                .withNewPriorityClassName(\"top-priority\")\n+                                .withNewSchedulerName(\"my-scheduler\")\n+                            .endPod()\n+                            .withNewApiService()\n+                                .withNewMetadata()\n+                                    .withLabels(svcLabels)\n+                                    .withAnnotations(svcAnots)\n+                                .endMetadata()\n+                            .endApiService()\n+                        .endTemplate()\n+                    .endCruiseControl()\n+                .endSpec()\n+                .build();\n+\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        // Check Deployment\n+        Deployment dep = cc.generateDeployment(true, depAnots, null, null);\n+        assertThat(dep.getMetadata().getLabels().entrySet().containsAll(depLabels.entrySet()), is(true));\n+        assertThat(dep.getMetadata().getAnnotations().entrySet().containsAll(depAnots.entrySet()), is(true));\n+\n+        // Check Pods\n+        assertThat(dep.getSpec().getTemplate().getMetadata().getLabels().entrySet().containsAll(podLabels.entrySet()), is(true));\n+        assertThat(dep.getSpec().getTemplate().getMetadata().getAnnotations().entrySet().containsAll(podAnots.entrySet()), is(true));\n+        assertThat(dep.getSpec().getTemplate().getSpec().getPriorityClassName(), is(\"top-priority\"));\n+        assertThat(dep.getSpec().getTemplate().getSpec().getSchedulerName(), is(\"my-scheduler\"));\n+\n+        // Check Service\n+        Service svc = cc.generateService();\n+        assertThat(svc.getMetadata().getLabels().entrySet().containsAll(svcLabels.entrySet()), is(true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 468}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MTk1MTg4OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxODoxOTo1OFrOF_M-aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODo0NDowM1rOF_hLUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxNzE5Mw==", "bodyText": "Just to be a little more consistent with the rest of the tests in Strimzi would you opposed to using\nassertThrows(NullPointerException.class, () -> cc.generateService());", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r401817193", "createdAt": "2020-04-01T18:19:58Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));\n+\n+        // Test generated disk capacity\n+        JbodStorage jbodStorage = new JbodStorage();\n+        List<SingleVolumeStorage> volumes = new ArrayList<SingleVolumeStorage>();\n+\n+        PersistentClaimStorage p1 = new PersistentClaimStorage();\n+        p1.setId(0);\n+        p1.setSize(\"50Gi\");\n+        volumes.add(p1);\n+\n+        PersistentClaimStorage p2 = new PersistentClaimStorage();\n+        p2.setId(1);\n+        p2.setSize(\"50G\");\n+        volumes.add(p2);\n+\n+        jbodStorage.setVolumes(volumes);\n+\n+        resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withStorage(jbodStorage)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+        Capacity generatedCapacity = new Capacity(resource.getSpec());\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(generatedCapacity.getDisk())));\n+    }\n+\n+    @Test\n+    public void testFromConfigMap() {\n+        assertThat(cc.namespace, is(namespace));\n+        assertThat(cc.cluster, is(cluster));\n+        assertThat(cc.getImage(), is(ccImage));\n+    }\n+\n+    @Test\n+    public void testGenerateDeployment() {\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        assertThat(containers.size(), is(2));\n+\n+        assertThat(dep.getMetadata().getName(), is(CruiseControlResources.deploymentName(cluster)));\n+        assertThat(dep.getMetadata().getNamespace(), is(namespace));\n+        assertThat(dep.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(dep.getMetadata().getOwnerReferences().get(0), is(cc.createOwnerReference()));\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImage(), is(cc.image));\n+        assertThat(ccContainer.getLivenessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getLivenessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getReadinessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getReadinessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getEnv(), is(getExpectedEnvVars()));\n+        assertThat(ccContainer.getPorts().size(), is(1));\n+        assertThat(ccContainer.getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(ccContainer.getPorts().get(0).getProtocol(), is(\"TCP\"));\n+        assertThat(dep.getSpec().getStrategy().getType(), is(\"RollingUpdate\"));\n+\n+        // Test volumes\n+        List<Volume> volumes = dep.getSpec().getTemplate().getSpec().getVolumes();\n+        assertThat(volumes.size(), is(3));\n+\n+        Volume volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(CruiseControl.secretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(AbstractModel.clusterCaCertSecretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getConfigMap().getName(), is(CruiseControl.metricAndLogConfigsName(cluster)));\n+\n+        // Test volume mounts\n+        List<VolumeMount> volumesMounts = dep.getSpec().getTemplate().getSpec().getContainers().get(0).getVolumeMounts();\n+        assertThat(volumesMounts.size(), is(3));\n+\n+        VolumeMount volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_MOUNT));\n+    }\n+\n+    @Test\n+    public void testEnvVars()   {\n+        assertThat(cc.getEnvVars(), is(getExpectedEnvVars()));\n+    }\n+\n+    @Test\n+    public void testImagePullPolicy() {\n+        Deployment dep = cc.generateDeployment(true, null, ImagePullPolicy.ALWAYS, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.ALWAYS.toString()));\n+\n+        dep = cc.generateDeployment(true, null,  ImagePullPolicy.IFNOTPRESENT, null);\n+        containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.IFNOTPRESENT.toString()));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVars() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"test.env.two\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                       .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvTwoKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvTwoValue));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVarsWithKeyConflict() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"my-special-value\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                        .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+    }\n+\n+    @Test\n+    public void testCruiseControlNotDeployed() {\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null,  null);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        try {\n+            assertThat(cc.generateDeployment(true, null, null, null), is(nullValue()));\n+            assertThat(cc.generateService(), is(nullValue()));\n+            assertThat(cc.generateSecret(null, true), is(nullValue()));\n+        } catch (Throwable expected) {\n+            assertEquals(NullPointerException.class, expected.getClass());\n+        }\n+    }\n+\n+    @Test\n+    public void testGenerateService()   {\n+        Service svc = cc.generateService();\n+\n+        assertThat(svc.getSpec().getType(), is(\"ClusterIP\"));\n+        assertThat(svc.getMetadata().getLabels(), is(expectedLabels(cc.getServiceName())));\n+        assertThat(svc.getSpec().getSelector(), is(expectedSelectorLabels()));\n+        assertThat(svc.getSpec().getPorts().size(), is(1));\n+        assertThat(svc.getSpec().getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(svc.getSpec().getPorts().get(0).getPort(), is(new Integer(CruiseControl.REST_API_PORT)));\n+        assertThat(svc.getSpec().getPorts().get(0).getProtocol(), is(\"TCP\"));\n+\n+        checkOwnerReference(cc.createOwnerReference(), svc);\n+    }\n+\n+    @Test\n+    public void testGenerateServiceWhenDisabled()   {\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, null);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        try {\n+            assertThat(cc.generateService(), is(nullValue()));\n+        } catch (Throwable expected) {\n+            assertEquals(NullPointerException.class, expected.getClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 408}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0ODE3OA==", "bodyText": "And let's be clear that the code above it wrong anyway. If you're expecting cc.generateService() to throw there's no point in having the assertThat and the cc.generateService() statement should be followed by a fail(), otherwise in the case of no NPE the test will erroneously pass.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402148178", "createdAt": "2020-04-02T08:44:03Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));\n+\n+        // Test generated disk capacity\n+        JbodStorage jbodStorage = new JbodStorage();\n+        List<SingleVolumeStorage> volumes = new ArrayList<SingleVolumeStorage>();\n+\n+        PersistentClaimStorage p1 = new PersistentClaimStorage();\n+        p1.setId(0);\n+        p1.setSize(\"50Gi\");\n+        volumes.add(p1);\n+\n+        PersistentClaimStorage p2 = new PersistentClaimStorage();\n+        p2.setId(1);\n+        p2.setSize(\"50G\");\n+        volumes.add(p2);\n+\n+        jbodStorage.setVolumes(volumes);\n+\n+        resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withStorage(jbodStorage)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+        Capacity generatedCapacity = new Capacity(resource.getSpec());\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(generatedCapacity.getDisk())));\n+    }\n+\n+    @Test\n+    public void testFromConfigMap() {\n+        assertThat(cc.namespace, is(namespace));\n+        assertThat(cc.cluster, is(cluster));\n+        assertThat(cc.getImage(), is(ccImage));\n+    }\n+\n+    @Test\n+    public void testGenerateDeployment() {\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        assertThat(containers.size(), is(2));\n+\n+        assertThat(dep.getMetadata().getName(), is(CruiseControlResources.deploymentName(cluster)));\n+        assertThat(dep.getMetadata().getNamespace(), is(namespace));\n+        assertThat(dep.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(dep.getMetadata().getOwnerReferences().get(0), is(cc.createOwnerReference()));\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImage(), is(cc.image));\n+        assertThat(ccContainer.getLivenessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getLivenessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getReadinessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getReadinessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getEnv(), is(getExpectedEnvVars()));\n+        assertThat(ccContainer.getPorts().size(), is(1));\n+        assertThat(ccContainer.getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(ccContainer.getPorts().get(0).getProtocol(), is(\"TCP\"));\n+        assertThat(dep.getSpec().getStrategy().getType(), is(\"RollingUpdate\"));\n+\n+        // Test volumes\n+        List<Volume> volumes = dep.getSpec().getTemplate().getSpec().getVolumes();\n+        assertThat(volumes.size(), is(3));\n+\n+        Volume volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(CruiseControl.secretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(AbstractModel.clusterCaCertSecretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getConfigMap().getName(), is(CruiseControl.metricAndLogConfigsName(cluster)));\n+\n+        // Test volume mounts\n+        List<VolumeMount> volumesMounts = dep.getSpec().getTemplate().getSpec().getContainers().get(0).getVolumeMounts();\n+        assertThat(volumesMounts.size(), is(3));\n+\n+        VolumeMount volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_MOUNT));\n+    }\n+\n+    @Test\n+    public void testEnvVars()   {\n+        assertThat(cc.getEnvVars(), is(getExpectedEnvVars()));\n+    }\n+\n+    @Test\n+    public void testImagePullPolicy() {\n+        Deployment dep = cc.generateDeployment(true, null, ImagePullPolicy.ALWAYS, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.ALWAYS.toString()));\n+\n+        dep = cc.generateDeployment(true, null,  ImagePullPolicy.IFNOTPRESENT, null);\n+        containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.IFNOTPRESENT.toString()));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVars() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"test.env.two\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                       .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvTwoKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvTwoValue));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVarsWithKeyConflict() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"my-special-value\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                        .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+    }\n+\n+    @Test\n+    public void testCruiseControlNotDeployed() {\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null,  null);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        try {\n+            assertThat(cc.generateDeployment(true, null, null, null), is(nullValue()));\n+            assertThat(cc.generateService(), is(nullValue()));\n+            assertThat(cc.generateSecret(null, true), is(nullValue()));\n+        } catch (Throwable expected) {\n+            assertEquals(NullPointerException.class, expected.getClass());\n+        }\n+    }\n+\n+    @Test\n+    public void testGenerateService()   {\n+        Service svc = cc.generateService();\n+\n+        assertThat(svc.getSpec().getType(), is(\"ClusterIP\"));\n+        assertThat(svc.getMetadata().getLabels(), is(expectedLabels(cc.getServiceName())));\n+        assertThat(svc.getSpec().getSelector(), is(expectedSelectorLabels()));\n+        assertThat(svc.getSpec().getPorts().size(), is(1));\n+        assertThat(svc.getSpec().getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(svc.getSpec().getPorts().get(0).getPort(), is(new Integer(CruiseControl.REST_API_PORT)));\n+        assertThat(svc.getSpec().getPorts().get(0).getProtocol(), is(\"TCP\"));\n+\n+        checkOwnerReference(cc.createOwnerReference(), svc);\n+    }\n+\n+    @Test\n+    public void testGenerateServiceWhenDisabled()   {\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, null);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        try {\n+            assertThat(cc.generateService(), is(nullValue()));\n+        } catch (Throwable expected) {\n+            assertEquals(NullPointerException.class, expected.getClass());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxNzE5Mw=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 408}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MTk2MTE0OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxODoyMjo0MFrOF_NEXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNToxOTo0N1rOGAaGeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxODcxNw==", "bodyText": "assertThat(kafkaEnvVars, hasEntry(testEnvOneKey, testEnvOneValue) suggested improvement\nAnd maybe have same for envar2?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r401818717", "createdAt": "2020-04-01T18:22:40Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));\n+\n+        // Test generated disk capacity\n+        JbodStorage jbodStorage = new JbodStorage();\n+        List<SingleVolumeStorage> volumes = new ArrayList<SingleVolumeStorage>();\n+\n+        PersistentClaimStorage p1 = new PersistentClaimStorage();\n+        p1.setId(0);\n+        p1.setSize(\"50Gi\");\n+        volumes.add(p1);\n+\n+        PersistentClaimStorage p2 = new PersistentClaimStorage();\n+        p2.setId(1);\n+        p2.setSize(\"50G\");\n+        volumes.add(p2);\n+\n+        jbodStorage.setVolumes(volumes);\n+\n+        resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withStorage(jbodStorage)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+        Capacity generatedCapacity = new Capacity(resource.getSpec());\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(generatedCapacity.getDisk())));\n+    }\n+\n+    @Test\n+    public void testFromConfigMap() {\n+        assertThat(cc.namespace, is(namespace));\n+        assertThat(cc.cluster, is(cluster));\n+        assertThat(cc.getImage(), is(ccImage));\n+    }\n+\n+    @Test\n+    public void testGenerateDeployment() {\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        assertThat(containers.size(), is(2));\n+\n+        assertThat(dep.getMetadata().getName(), is(CruiseControlResources.deploymentName(cluster)));\n+        assertThat(dep.getMetadata().getNamespace(), is(namespace));\n+        assertThat(dep.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(dep.getMetadata().getOwnerReferences().get(0), is(cc.createOwnerReference()));\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImage(), is(cc.image));\n+        assertThat(ccContainer.getLivenessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getLivenessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getReadinessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getReadinessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getEnv(), is(getExpectedEnvVars()));\n+        assertThat(ccContainer.getPorts().size(), is(1));\n+        assertThat(ccContainer.getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(ccContainer.getPorts().get(0).getProtocol(), is(\"TCP\"));\n+        assertThat(dep.getSpec().getStrategy().getType(), is(\"RollingUpdate\"));\n+\n+        // Test volumes\n+        List<Volume> volumes = dep.getSpec().getTemplate().getSpec().getVolumes();\n+        assertThat(volumes.size(), is(3));\n+\n+        Volume volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(CruiseControl.secretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(AbstractModel.clusterCaCertSecretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getConfigMap().getName(), is(CruiseControl.metricAndLogConfigsName(cluster)));\n+\n+        // Test volume mounts\n+        List<VolumeMount> volumesMounts = dep.getSpec().getTemplate().getSpec().getContainers().get(0).getVolumeMounts();\n+        assertThat(volumesMounts.size(), is(3));\n+\n+        VolumeMount volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_MOUNT));\n+    }\n+\n+    @Test\n+    public void testEnvVars()   {\n+        assertThat(cc.getEnvVars(), is(getExpectedEnvVars()));\n+    }\n+\n+    @Test\n+    public void testImagePullPolicy() {\n+        Deployment dep = cc.generateDeployment(true, null, ImagePullPolicy.ALWAYS, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.ALWAYS.toString()));\n+\n+        dep = cc.generateDeployment(true, null,  ImagePullPolicy.IFNOTPRESENT, null);\n+        containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.IFNOTPRESENT.toString()));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVars() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"test.env.two\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                       .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvTwoKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvTwoValue));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVarsWithKeyConflict() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"my-special-value\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                        .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYzOTk2OQ==", "bodyText": "Since kafkaEnvVars is a list instead of a map I used hasItem() instead. How does this look:\nList<EnvVar> envVarList = cc.getEnvVars();\n\nassertThat(envVarList, hasItems(new EnvVar(testEnvOneKey, testEnvOneValue, null)));\nassertThat(envVarList, hasItems(new EnvVar(testEnvTwoKey, testEnvTwoValue, null)));\n\nLet me know what you think!", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402639969", "createdAt": "2020-04-02T22:48:18Z", "author": {"login": "kyguy"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));\n+\n+        // Test generated disk capacity\n+        JbodStorage jbodStorage = new JbodStorage();\n+        List<SingleVolumeStorage> volumes = new ArrayList<SingleVolumeStorage>();\n+\n+        PersistentClaimStorage p1 = new PersistentClaimStorage();\n+        p1.setId(0);\n+        p1.setSize(\"50Gi\");\n+        volumes.add(p1);\n+\n+        PersistentClaimStorage p2 = new PersistentClaimStorage();\n+        p2.setId(1);\n+        p2.setSize(\"50G\");\n+        volumes.add(p2);\n+\n+        jbodStorage.setVolumes(volumes);\n+\n+        resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withStorage(jbodStorage)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+        Capacity generatedCapacity = new Capacity(resource.getSpec());\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(generatedCapacity.getDisk())));\n+    }\n+\n+    @Test\n+    public void testFromConfigMap() {\n+        assertThat(cc.namespace, is(namespace));\n+        assertThat(cc.cluster, is(cluster));\n+        assertThat(cc.getImage(), is(ccImage));\n+    }\n+\n+    @Test\n+    public void testGenerateDeployment() {\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        assertThat(containers.size(), is(2));\n+\n+        assertThat(dep.getMetadata().getName(), is(CruiseControlResources.deploymentName(cluster)));\n+        assertThat(dep.getMetadata().getNamespace(), is(namespace));\n+        assertThat(dep.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(dep.getMetadata().getOwnerReferences().get(0), is(cc.createOwnerReference()));\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImage(), is(cc.image));\n+        assertThat(ccContainer.getLivenessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getLivenessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getReadinessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getReadinessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getEnv(), is(getExpectedEnvVars()));\n+        assertThat(ccContainer.getPorts().size(), is(1));\n+        assertThat(ccContainer.getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(ccContainer.getPorts().get(0).getProtocol(), is(\"TCP\"));\n+        assertThat(dep.getSpec().getStrategy().getType(), is(\"RollingUpdate\"));\n+\n+        // Test volumes\n+        List<Volume> volumes = dep.getSpec().getTemplate().getSpec().getVolumes();\n+        assertThat(volumes.size(), is(3));\n+\n+        Volume volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(CruiseControl.secretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(AbstractModel.clusterCaCertSecretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getConfigMap().getName(), is(CruiseControl.metricAndLogConfigsName(cluster)));\n+\n+        // Test volume mounts\n+        List<VolumeMount> volumesMounts = dep.getSpec().getTemplate().getSpec().getContainers().get(0).getVolumeMounts();\n+        assertThat(volumesMounts.size(), is(3));\n+\n+        VolumeMount volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_MOUNT));\n+    }\n+\n+    @Test\n+    public void testEnvVars()   {\n+        assertThat(cc.getEnvVars(), is(getExpectedEnvVars()));\n+    }\n+\n+    @Test\n+    public void testImagePullPolicy() {\n+        Deployment dep = cc.generateDeployment(true, null, ImagePullPolicy.ALWAYS, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.ALWAYS.toString()));\n+\n+        dep = cc.generateDeployment(true, null,  ImagePullPolicy.IFNOTPRESENT, null);\n+        containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.IFNOTPRESENT.toString()));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVars() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"test.env.two\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                       .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvTwoKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvTwoValue));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVarsWithKeyConflict() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"my-special-value\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                        .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxODcxNw=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA4MDgyNQ==", "bodyText": "Looks good, though since hasItems takes ...items you could achieve the same with\nassertThat(envVarList, hasItems(new EnvVar(testEnvOneKey, testEnvOneValue, null),\n    new EnvVar(testEnvTwoKey, testEnvTwoValue, null)));\n\nBut this is only a suggestion , not a required change at all! :P", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r403080825", "createdAt": "2020-04-03T15:19:47Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));\n+\n+        // Test generated disk capacity\n+        JbodStorage jbodStorage = new JbodStorage();\n+        List<SingleVolumeStorage> volumes = new ArrayList<SingleVolumeStorage>();\n+\n+        PersistentClaimStorage p1 = new PersistentClaimStorage();\n+        p1.setId(0);\n+        p1.setSize(\"50Gi\");\n+        volumes.add(p1);\n+\n+        PersistentClaimStorage p2 = new PersistentClaimStorage();\n+        p2.setId(1);\n+        p2.setSize(\"50G\");\n+        volumes.add(p2);\n+\n+        jbodStorage.setVolumes(volumes);\n+\n+        resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withStorage(jbodStorage)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+        Capacity generatedCapacity = new Capacity(resource.getSpec());\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(generatedCapacity.getDisk())));\n+    }\n+\n+    @Test\n+    public void testFromConfigMap() {\n+        assertThat(cc.namespace, is(namespace));\n+        assertThat(cc.cluster, is(cluster));\n+        assertThat(cc.getImage(), is(ccImage));\n+    }\n+\n+    @Test\n+    public void testGenerateDeployment() {\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        assertThat(containers.size(), is(2));\n+\n+        assertThat(dep.getMetadata().getName(), is(CruiseControlResources.deploymentName(cluster)));\n+        assertThat(dep.getMetadata().getNamespace(), is(namespace));\n+        assertThat(dep.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(dep.getMetadata().getOwnerReferences().get(0), is(cc.createOwnerReference()));\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImage(), is(cc.image));\n+        assertThat(ccContainer.getLivenessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getLivenessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getReadinessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getReadinessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getEnv(), is(getExpectedEnvVars()));\n+        assertThat(ccContainer.getPorts().size(), is(1));\n+        assertThat(ccContainer.getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(ccContainer.getPorts().get(0).getProtocol(), is(\"TCP\"));\n+        assertThat(dep.getSpec().getStrategy().getType(), is(\"RollingUpdate\"));\n+\n+        // Test volumes\n+        List<Volume> volumes = dep.getSpec().getTemplate().getSpec().getVolumes();\n+        assertThat(volumes.size(), is(3));\n+\n+        Volume volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(CruiseControl.secretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(AbstractModel.clusterCaCertSecretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getConfigMap().getName(), is(CruiseControl.metricAndLogConfigsName(cluster)));\n+\n+        // Test volume mounts\n+        List<VolumeMount> volumesMounts = dep.getSpec().getTemplate().getSpec().getContainers().get(0).getVolumeMounts();\n+        assertThat(volumesMounts.size(), is(3));\n+\n+        VolumeMount volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_MOUNT));\n+    }\n+\n+    @Test\n+    public void testEnvVars()   {\n+        assertThat(cc.getEnvVars(), is(getExpectedEnvVars()));\n+    }\n+\n+    @Test\n+    public void testImagePullPolicy() {\n+        Deployment dep = cc.generateDeployment(true, null, ImagePullPolicy.ALWAYS, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.ALWAYS.toString()));\n+\n+        dep = cc.generateDeployment(true, null,  ImagePullPolicy.IFNOTPRESENT, null);\n+        containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.IFNOTPRESENT.toString()));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVars() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"test.env.two\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                       .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvTwoKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvTwoValue));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVarsWithKeyConflict() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"my-special-value\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                        .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxODcxNw=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 364}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MTk2MjA2OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxODoyMjo1NFrOF_NE9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMjo0ODo1M1rOF__NVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxODg2OA==", "bodyText": "assertThat(kafkaEnvVars, hasEntry(testEnvOneKey, testEnvOneValue) suggested improvement\nAnd maybe have same for envar2?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r401818868", "createdAt": "2020-04-01T18:22:54Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));\n+\n+        // Test generated disk capacity\n+        JbodStorage jbodStorage = new JbodStorage();\n+        List<SingleVolumeStorage> volumes = new ArrayList<SingleVolumeStorage>();\n+\n+        PersistentClaimStorage p1 = new PersistentClaimStorage();\n+        p1.setId(0);\n+        p1.setSize(\"50Gi\");\n+        volumes.add(p1);\n+\n+        PersistentClaimStorage p2 = new PersistentClaimStorage();\n+        p2.setId(1);\n+        p2.setSize(\"50G\");\n+        volumes.add(p2);\n+\n+        jbodStorage.setVolumes(volumes);\n+\n+        resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withStorage(jbodStorage)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+        Capacity generatedCapacity = new Capacity(resource.getSpec());\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(generatedCapacity.getDisk())));\n+    }\n+\n+    @Test\n+    public void testFromConfigMap() {\n+        assertThat(cc.namespace, is(namespace));\n+        assertThat(cc.cluster, is(cluster));\n+        assertThat(cc.getImage(), is(ccImage));\n+    }\n+\n+    @Test\n+    public void testGenerateDeployment() {\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        assertThat(containers.size(), is(2));\n+\n+        assertThat(dep.getMetadata().getName(), is(CruiseControlResources.deploymentName(cluster)));\n+        assertThat(dep.getMetadata().getNamespace(), is(namespace));\n+        assertThat(dep.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(dep.getMetadata().getOwnerReferences().get(0), is(cc.createOwnerReference()));\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImage(), is(cc.image));\n+        assertThat(ccContainer.getLivenessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getLivenessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getReadinessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getReadinessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getEnv(), is(getExpectedEnvVars()));\n+        assertThat(ccContainer.getPorts().size(), is(1));\n+        assertThat(ccContainer.getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(ccContainer.getPorts().get(0).getProtocol(), is(\"TCP\"));\n+        assertThat(dep.getSpec().getStrategy().getType(), is(\"RollingUpdate\"));\n+\n+        // Test volumes\n+        List<Volume> volumes = dep.getSpec().getTemplate().getSpec().getVolumes();\n+        assertThat(volumes.size(), is(3));\n+\n+        Volume volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(CruiseControl.secretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(AbstractModel.clusterCaCertSecretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getConfigMap().getName(), is(CruiseControl.metricAndLogConfigsName(cluster)));\n+\n+        // Test volume mounts\n+        List<VolumeMount> volumesMounts = dep.getSpec().getTemplate().getSpec().getContainers().get(0).getVolumeMounts();\n+        assertThat(volumesMounts.size(), is(3));\n+\n+        VolumeMount volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_MOUNT));\n+    }\n+\n+    @Test\n+    public void testEnvVars()   {\n+        assertThat(cc.getEnvVars(), is(getExpectedEnvVars()));\n+    }\n+\n+    @Test\n+    public void testImagePullPolicy() {\n+        Deployment dep = cc.generateDeployment(true, null, ImagePullPolicy.ALWAYS, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.ALWAYS.toString()));\n+\n+        dep = cc.generateDeployment(true, null,  ImagePullPolicy.IFNOTPRESENT, null);\n+        containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.IFNOTPRESENT.toString()));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVars() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"test.env.two\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                       .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 331}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY0MDIxNA==", "bodyText": "See above", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402640214", "createdAt": "2020-04-02T22:48:53Z", "author": {"login": "kyguy"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));\n+\n+        // Test generated disk capacity\n+        JbodStorage jbodStorage = new JbodStorage();\n+        List<SingleVolumeStorage> volumes = new ArrayList<SingleVolumeStorage>();\n+\n+        PersistentClaimStorage p1 = new PersistentClaimStorage();\n+        p1.setId(0);\n+        p1.setSize(\"50Gi\");\n+        volumes.add(p1);\n+\n+        PersistentClaimStorage p2 = new PersistentClaimStorage();\n+        p2.setId(1);\n+        p2.setSize(\"50G\");\n+        volumes.add(p2);\n+\n+        jbodStorage.setVolumes(volumes);\n+\n+        resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withStorage(jbodStorage)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+        Capacity generatedCapacity = new Capacity(resource.getSpec());\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(generatedCapacity.getDisk())));\n+    }\n+\n+    @Test\n+    public void testFromConfigMap() {\n+        assertThat(cc.namespace, is(namespace));\n+        assertThat(cc.cluster, is(cluster));\n+        assertThat(cc.getImage(), is(ccImage));\n+    }\n+\n+    @Test\n+    public void testGenerateDeployment() {\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        assertThat(containers.size(), is(2));\n+\n+        assertThat(dep.getMetadata().getName(), is(CruiseControlResources.deploymentName(cluster)));\n+        assertThat(dep.getMetadata().getNamespace(), is(namespace));\n+        assertThat(dep.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(dep.getMetadata().getOwnerReferences().get(0), is(cc.createOwnerReference()));\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImage(), is(cc.image));\n+        assertThat(ccContainer.getLivenessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getLivenessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getReadinessProbe().getInitialDelaySeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_DELAY)));\n+        assertThat(ccContainer.getReadinessProbe().getTimeoutSeconds(), is(new Integer(CruiseControl.DEFAULT_HEALTHCHECK_TIMEOUT)));\n+        assertThat(ccContainer.getEnv(), is(getExpectedEnvVars()));\n+        assertThat(ccContainer.getPorts().size(), is(1));\n+        assertThat(ccContainer.getPorts().get(0).getName(), is(CruiseControl.REST_API_PORT_NAME));\n+        assertThat(ccContainer.getPorts().get(0).getProtocol(), is(\"TCP\"));\n+        assertThat(dep.getSpec().getStrategy().getType(), is(\"RollingUpdate\"));\n+\n+        // Test volumes\n+        List<Volume> volumes = dep.getSpec().getTemplate().getSpec().getVolumes();\n+        assertThat(volumes.size(), is(3));\n+\n+        Volume volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(CruiseControl.secretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getSecret().getSecretName(), is(AbstractModel.clusterCaCertSecretName(cluster)));\n+\n+        volume = volumes.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volume, is(notNullValue()));\n+        assertThat(volume.getConfigMap().getName(), is(CruiseControl.metricAndLogConfigsName(cluster)));\n+\n+        // Test volume mounts\n+        List<VolumeMount> volumesMounts = dep.getSpec().getTemplate().getSpec().getContainers().get(0).getVolumeMounts();\n+        assertThat(volumesMounts.size(), is(3));\n+\n+        VolumeMount volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT));\n+\n+        volumeMount = volumesMounts.stream().filter(vol -> CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_NAME.equals(vol.getName())).findFirst().get();\n+        assertThat(volumeMount, is(notNullValue()));\n+        assertThat(volumeMount.getMountPath(), is(CruiseControl.LOG_AND_METRICS_CONFIG_VOLUME_MOUNT));\n+    }\n+\n+    @Test\n+    public void testEnvVars()   {\n+        assertThat(cc.getEnvVars(), is(getExpectedEnvVars()));\n+    }\n+\n+    @Test\n+    public void testImagePullPolicy() {\n+        Deployment dep = cc.generateDeployment(true, null, ImagePullPolicy.ALWAYS, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.ALWAYS.toString()));\n+\n+        dep = cc.generateDeployment(true, null,  ImagePullPolicy.IFNOTPRESENT, null);\n+        containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+        ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        assertThat(ccContainer.getImagePullPolicy(), is(ImagePullPolicy.IFNOTPRESENT.toString()));\n+    }\n+\n+    @Test\n+    public void testContainerTemplateEnvVars() {\n+        ContainerEnvVar envVar1 = new ContainerEnvVar();\n+        String testEnvOneKey = \"TEST_ENV_1\";\n+        String testEnvOneValue = \"test.env.one\";\n+        envVar1.setName(testEnvOneKey);\n+        envVar1.setValue(testEnvOneValue);\n+\n+        ContainerEnvVar envVar2 = new ContainerEnvVar();\n+        String testEnvTwoKey = \"TEST_ENV_2\";\n+        String testEnvTwoValue = \"test.env.two\";\n+        envVar2.setName(testEnvTwoKey);\n+        envVar2.setValue(testEnvTwoValue);\n+\n+        CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+                .withImage(ccImage)\n+                .withNewTemplate()\n+                    .withNewCruiseControlContainer()\n+                       .withEnv(envVar1, envVar2)\n+                    .endCruiseControlContainer()\n+                .endTemplate()\n+                .build();\n+\n+        Kafka resource = ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image,\n+                healthDelay, healthTimeout, metricsCm, kafkaConfig, zooConfig,\n+                kafkaStorage, zkStorage, null, kafkaLogJson, zooLogJson, null, cruiseControlSpec);\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+        List<EnvVar> kafkaEnvVars = cc.getEnvVars();\n+        assertThat(kafkaEnvVars.stream().filter(var -> testEnvOneKey.equals(var.getName())).map(EnvVar::getValue).findFirst().get(), is(testEnvOneValue));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxODg2OA=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 331}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MTk2OTA4OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxODoyNDo0NFrOF_NJSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQxMjozODowMlrOGA_qMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxOTk3Ng==", "bodyText": "Just as an aside, this might be a good function to contribute to test utils as I can see all of the tests needing to call this method!", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r401819976", "createdAt": "2020-04-01T18:24:44Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0NDYxNg==", "bodyText": "Yes please! Good spot @samuel-hawker!", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402144616", "createdAt": "2020-04-02T08:38:35Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxOTk3Ng=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY0MDgzNA==", "bodyText": "I'll save this for another PR if that is alright with you two, the PR already changes a lot of files!", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402640834", "createdAt": "2020-04-02T22:50:41Z", "author": {"login": "kyguy"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxOTk3Ng=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY5NjE3OQ==", "bodyText": "@kyguy for sure updating ALL the other files should be done in a different PR but here you could start to move the method in the test utils and using it. Then, again, reusing the method for ALL the other tests has to be done in a different PR. Wdyt?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r403696179", "createdAt": "2020-04-05T12:38:02Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxOTk3Ng=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5Mzk1NjY0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODowODoyMVrOF_f4xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMjo0Mzo1NVrOF__GIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyNzA0NQ==", "bodyText": "@kyguy is there a link to the documentation about all these configs?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402127045", "createdAt": "2020-04-02T08:08:21Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYzODM2OA==", "bodyText": "Just added this link[1] above the field\n[1] https://github.com/linkedin/cruise-control/wiki/Configurations", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402638368", "createdAt": "2020-04-02T22:43:55Z", "author": {"login": "kyguy"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyNzA0NQ=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5Mzk1OTM5OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODowOTowMlrOF_f6XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODowOTowMlrOF_f6XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyNzQ1Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Description(\"The Cruise Control broker capacity config.\")\n          \n          \n            \n                @Description(\"The Cruise Control broker capacity configuration.\")", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402127453", "createdAt": "2020-04-02T08:09:02Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5Mzk2MTY1OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODowOTozOVrOF_f7xA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMjo1MjowM1rOF__Rqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyNzgxMg==", "bodyText": "The class is called ...BokerCapacity, so should the property be called that too?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402127812", "createdAt": "2020-04-02T08:09:39Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public CruiseControlBrokerCapacity getCapacity() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY0MTMyMg==", "bodyText": "Refactored", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402641322", "createdAt": "2020-04-02T22:52:03Z", "author": {"login": "kyguy"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public CruiseControlBrokerCapacity getCapacity() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyNzgxMg=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5Mzk2MzU1OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODoxMDoxNFrOF_f89A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMjo1MjoyOVrOF__SNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyODExNg==", "bodyText": "We should include a link here to the place where the user can learn about what the valid configs are.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402128116", "createdAt": "2020-04-02T08:10:14Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public CruiseControlBrokerCapacity getCapacity() {\n+        return capacity;\n+    }\n+\n+    public void setCapacity(CruiseControlBrokerCapacity capacity) {\n+        this.capacity = capacity;\n+    }\n+\n+    @Description(\"The Cruise Control config. Properties with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY0MTQ2Mw==", "bodyText": "Added this link [1] to the description\n[1] https://github.com/linkedin/cruise-control/wiki/Configurations", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402641463", "createdAt": "2020-04-02T22:52:29Z", "author": {"login": "kyguy"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public CruiseControlBrokerCapacity getCapacity() {\n+        return capacity;\n+    }\n+\n+    public void setCapacity(CruiseControlBrokerCapacity capacity) {\n+        this.capacity = capacity;\n+    }\n+\n+    @Description(\"The Cruise Control config. Properties with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyODExNg=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5Mzk2NzQ4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODoxMTozMFrOF_f_kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODoxMTozMFrOF_f_kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyODc4NQ==", "bodyText": "For the cruise control pod (singular)? If so, please say so in the Description to the reader of the docs is left in no doubt about what they're configuring.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402128785", "createdAt": "2020-04-02T08:11:30Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public CruiseControlBrokerCapacity getCapacity() {\n+        return capacity;\n+    }\n+\n+    public void setCapacity(CruiseControlBrokerCapacity capacity) {\n+        this.capacity = capacity;\n+    }\n+\n+    @Description(\"The Cruise Control config. Properties with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, Object> getConfig() {\n+        return config;\n+    }\n+\n+    public void setConfig(Map<String, Object> config) {\n+        this.config = config;\n+    }\n+\n+    @Description(\"Logging configuration for Cruise Control.\")\n+    @JsonInclude(value = JsonInclude.Include.NON_NULL)\n+    public Logging getLogging() {\n+        return logging;\n+    }\n+\n+    public void setLogging(Logging logging) {\n+        this.logging = logging;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    @Description(\"JVM Options for pods\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5Mzk2ODc0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODoxMTo1MVrOF_gAUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODoxMTo1MVrOF_gAUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyODk3Ng==", "bodyText": "For which container?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402128976", "createdAt": "2020-04-02T08:11:51Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public CruiseControlBrokerCapacity getCapacity() {\n+        return capacity;\n+    }\n+\n+    public void setCapacity(CruiseControlBrokerCapacity capacity) {\n+        this.capacity = capacity;\n+    }\n+\n+    @Description(\"The Cruise Control config. Properties with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, Object> getConfig() {\n+        return config;\n+    }\n+\n+    public void setConfig(Map<String, Object> config) {\n+        this.config = config;\n+    }\n+\n+    @Description(\"Logging configuration for Cruise Control.\")\n+    @JsonInclude(value = JsonInclude.Include.NON_NULL)\n+    public Logging getLogging() {\n+        return logging;\n+    }\n+\n+    public void setLogging(Logging logging) {\n+        this.logging = logging;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    @Description(\"JVM Options for pods\")\n+    public JvmOptions getJvmOptions() {\n+        return jvmOptions;\n+    }\n+\n+    public void setJvmOptions(JvmOptions jvmOptions) {\n+        this.jvmOptions = jvmOptions;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"CPU and memory resources to reserve.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5Mzk3MzA3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODoxMzowNlrOF_gDEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODoxMzowNlrOF_gDEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyOTY4MQ==", "bodyText": "Again, no harm in being more explicit about which container", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402129681", "createdAt": "2020-04-02T08:13:06Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public CruiseControlBrokerCapacity getCapacity() {\n+        return capacity;\n+    }\n+\n+    public void setCapacity(CruiseControlBrokerCapacity capacity) {\n+        this.capacity = capacity;\n+    }\n+\n+    @Description(\"The Cruise Control config. Properties with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, Object> getConfig() {\n+        return config;\n+    }\n+\n+    public void setConfig(Map<String, Object> config) {\n+        this.config = config;\n+    }\n+\n+    @Description(\"Logging configuration for Cruise Control.\")\n+    @JsonInclude(value = JsonInclude.Include.NON_NULL)\n+    public Logging getLogging() {\n+        return logging;\n+    }\n+\n+    public void setLogging(Logging logging) {\n+        this.logging = logging;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    @Description(\"JVM Options for pods\")\n+    public JvmOptions getJvmOptions() {\n+        return jvmOptions;\n+    }\n+\n+    public void setJvmOptions(JvmOptions jvmOptions) {\n+        this.jvmOptions = jvmOptions;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"CPU and memory resources to reserve.\")\n+    public ResourceRequirements getResources() {\n+        return resources;\n+    }\n+\n+    public void setResources(ResourceRequirements resources) {\n+        this.resources = resources;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    @Description(\"Pod liveness checking.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5Mzk3NjM2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaSpec.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODoxMzo1NlrOF_gFDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODoxMzo1NlrOF_gFDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMDE5MA==", "bodyText": "Say what happens if this is not specified (do I get a default CC or no CC?)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402130190", "createdAt": "2020-04-02T08:13:56Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaSpec.java", "diffHunk": "@@ -136,6 +137,15 @@ public void setKafkaExporter(KafkaExporterSpec kafkaExporter) {\n         this.kafkaExporter = kafkaExporter;\n     }\n \n+    @Description(\"Configuration of Cruise Control.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5Mzk3ODU4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/CruiseControlBrokerCapacity.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODoxNDozNlrOF_gGfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMjozOTo1OVrOGBsgtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMDU1Nw==", "bodyText": "Are these base 10 megabytes or base 2 mebibytes? We should document it at least.\nCan we call the property diskMB (or diskMiB`) , so the unit is explicit?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402130557", "createdAt": "2020-04-02T08:14:36Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/CruiseControlBrokerCapacity.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpu\", \"networkIn\", \"networkOut\"})\n+@EqualsAndHashCode\n+public class CruiseControlBrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer disk;\n+    private Integer cpu;\n+    private Integer networkIn;\n+    private Integer networkOut;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Description(\"Broker capacity for disk in megabytes.\")\n+    public Integer getDisk() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzMTAzMA==", "bodyText": "They are in base 2 mebibytes, refactored the properties to diskMib, cpuUtilization, inboundNetworkKiBPerSecond and outboundNetworkKiBPerSecond to be more explicit and updated the documentation", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404431030", "createdAt": "2020-04-06T22:39:59Z", "author": {"login": "kyguy"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/CruiseControlBrokerCapacity.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpu\", \"networkIn\", \"networkOut\"})\n+@EqualsAndHashCode\n+public class CruiseControlBrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer disk;\n+    private Integer cpu;\n+    private Integer networkIn;\n+    private Integer networkOut;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Description(\"Broker capacity for disk in megabytes.\")\n+    public Integer getDisk() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMDU1Nw=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5Mzk4MTE1OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/CruiseControlBrokerCapacity.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODoxNToyNFrOF_gIEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMDo1NDo1NlrOGH_ZsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMDk2MQ==", "bodyText": "So how does this work if the brokers have resource requests and limits for >1.0 CPU?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402130961", "createdAt": "2020-04-02T08:15:24Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/CruiseControlBrokerCapacity.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpu\", \"networkIn\", \"networkOut\"})\n+@EqualsAndHashCode\n+public class CruiseControlBrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer disk;\n+    private Integer cpu;\n+    private Integer networkIn;\n+    private Integer networkOut;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Description(\"Broker capacity for disk in megabytes.\")\n+    public Integer getDisk() {\n+        return disk;\n+    }\n+\n+    public void setDisk(Integer disk) {\n+        this.disk = disk;\n+    }\n+\n+    @Minimum(0)\n+    @Maximum(100)\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for CPU utilization as a percentage (0 - 100).\")\n+    public Integer getCpu() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzNTcwMA==", "bodyText": "No matter how many cores are specified for a broker in the resource requests and limits, when Cruise Control is running on top of k8s Cruise Control sees those CPU cores as a single resource. Cruise Control calculates the CPU utilization by checking how often the broker's threads are running on the CPU resources available to that process, using a method [1] that respects cgroup boundaries.\nThe CC CPU capacity is the utilization(or percentage) of this broker's CPU resource that can be used before the CC considers the broker's CPU resources to have been exhausted/exceeded/violated.\n[1] https://docs.oracle.com/javase/7/docs/jre/api/management/extension/com/sun/management/OperatingSystemMXBean.html#getProcessCpuLoad()", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404435700", "createdAt": "2020-04-06T22:52:40Z", "author": {"login": "kyguy"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/CruiseControlBrokerCapacity.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpu\", \"networkIn\", \"networkOut\"})\n+@EqualsAndHashCode\n+public class CruiseControlBrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer disk;\n+    private Integer cpu;\n+    private Integer networkIn;\n+    private Integer networkOut;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Description(\"Broker capacity for disk in megabytes.\")\n+    public Integer getDisk() {\n+        return disk;\n+    }\n+\n+    public void setDisk(Integer disk) {\n+        this.disk = disk;\n+    }\n+\n+    @Minimum(0)\n+    @Maximum(100)\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for CPU utilization as a percentage (0 - 100).\")\n+    public Integer getCpu() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMDk2MQ=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAzMTk4NA==", "bodyText": "I was wrong about the method[1] respecting cgroup boundaries. It does not and it causes the CPU utilization of the brokers to be underestimated. I am currently looking into a way around this issue but in the meantime, it may be best for stripping this cpuUtilization configuration out of here before committing to a specific format. I may need to use this field to get around this problem.\nWould it be alright if I removed this cpuUtilization field for this PR and add it in at a later point in time? Or do all the properties of cruiseControl.brokerCapacity have to all be added at the same time?\n[1] https://docs.oracle.com/javase/7/docs/jre/api/management/extension/com/sun/management/OperatingSystemMXBean.html#getProcessCpuLoad()", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411031984", "createdAt": "2020-04-20T00:54:56Z", "author": {"login": "kyguy"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/CruiseControlBrokerCapacity.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpu\", \"networkIn\", \"networkOut\"})\n+@EqualsAndHashCode\n+public class CruiseControlBrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer disk;\n+    private Integer cpu;\n+    private Integer networkIn;\n+    private Integer networkOut;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Description(\"Broker capacity for disk in megabytes.\")\n+    public Integer getDisk() {\n+        return disk;\n+    }\n+\n+    public void setDisk(Integer disk) {\n+        this.disk = disk;\n+    }\n+\n+    @Minimum(0)\n+    @Maximum(100)\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for CPU utilization as a percentage (0 - 100).\")\n+    public Integer getCpu() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMDk2MQ=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5Mzk5ODk0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/CruiseControlBrokerCapacity.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODoyMDo0MlrOF_gTZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMjo0MDo0N1rOGBshxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMzg2Mg==", "bodyText": "Again we should make clear the units KB or KiB, and reflect that in the name. But networkInKBPerSecond is a bit confusing because people might think that the \"in\" is referring to the units be \"in KB/s\", so maybe inboundNetworkKBPerSecond is better.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402133862", "createdAt": "2020-04-02T08:20:42Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/CruiseControlBrokerCapacity.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpu\", \"networkIn\", \"networkOut\"})\n+@EqualsAndHashCode\n+public class CruiseControlBrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer disk;\n+    private Integer cpu;\n+    private Integer networkIn;\n+    private Integer networkOut;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Description(\"Broker capacity for disk in megabytes.\")\n+    public Integer getDisk() {\n+        return disk;\n+    }\n+\n+    public void setDisk(Integer disk) {\n+        this.disk = disk;\n+    }\n+\n+    @Minimum(0)\n+    @Maximum(100)\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for CPU utilization as a percentage (0 - 100).\")\n+    public Integer getCpu() {\n+        return cpu;\n+    }\n+\n+    public void setCpu(Integer cpu) {\n+        this.cpu = cpu;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for network inbound throughput in kilobytes per second.\")\n+    public Integer getNetworkIn() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzMTMwMA==", "bodyText": "Just refactored the properties to inboundNetworkKiBPerSecond and outboundNetworkKiBPerSecond", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404431300", "createdAt": "2020-04-06T22:40:47Z", "author": {"login": "kyguy"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/CruiseControlBrokerCapacity.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpu\", \"networkIn\", \"networkOut\"})\n+@EqualsAndHashCode\n+public class CruiseControlBrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer disk;\n+    private Integer cpu;\n+    private Integer networkIn;\n+    private Integer networkOut;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Description(\"Broker capacity for disk in megabytes.\")\n+    public Integer getDisk() {\n+        return disk;\n+    }\n+\n+    public void setDisk(Integer disk) {\n+        this.disk = disk;\n+    }\n+\n+    @Minimum(0)\n+    @Maximum(100)\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for CPU utilization as a percentage (0 - 100).\")\n+    public Integer getCpu() {\n+        return cpu;\n+    }\n+\n+    public void setCpu(Integer cpu) {\n+        this.cpu = cpu;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for network inbound throughput in kilobytes per second.\")\n+    public Integer getNetworkIn() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMzg2Mg=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5Mzk5OTYwOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/CruiseControlBrokerCapacity.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODoyMDo1MlrOF_gTyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODoyMDo1MlrOF_gTyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzMzk2Mw==", "bodyText": "Similar comments.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402133963", "createdAt": "2020-04-02T08:20:52Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/CruiseControlBrokerCapacity.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpu\", \"networkIn\", \"networkOut\"})\n+@EqualsAndHashCode\n+public class CruiseControlBrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer disk;\n+    private Integer cpu;\n+    private Integer networkIn;\n+    private Integer networkOut;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Description(\"Broker capacity for disk in megabytes.\")\n+    public Integer getDisk() {\n+        return disk;\n+    }\n+\n+    public void setDisk(Integer disk) {\n+        this.disk = disk;\n+    }\n+\n+    @Minimum(0)\n+    @Maximum(100)\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for CPU utilization as a percentage (0 - 100).\")\n+    public Integer getCpu() {\n+        return cpu;\n+    }\n+\n+    public void setCpu(Integer cpu) {\n+        this.cpu = cpu;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for network inbound throughput in kilobytes per second.\")\n+    public Integer getNetworkIn() {\n+        return networkIn;\n+    }\n+\n+    public void setNetworkIn(Integer networkIn) {\n+        this.networkIn = networkIn;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for network outbound throughput in kilobytes per second.\")\n+    public Integer getNetworkOut() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDAzNDYzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControlConfiguration.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODozMDoyNVrOF_gplw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNzozOTo1MFrOGAgS2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzOTU0Mw==", "bodyText": "Do us a favour an include a comment with that this time is in more meaningful units.\nAnd use _ as a thousands separator, it makes large literals so much easier to read!", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402139543", "createdAt": "2020-04-02T08:30:25Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControlConfiguration.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+\n+/**\n+ * Class for handling Cruise Control configuration passed by the user\n+ */\n+public class CruiseControlConfiguration extends AbstractConfiguration {\n+\n+    /**\n+     * A list of case insensitive goals that Cruise Control supports in the order of priority.\n+     * The high priority goals will be executed first.\n+     */\n+    private static final String DEFAULT_GOALS = \"com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.PotentialNwOutGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.TopicReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderBytesInDistributionGoal\";\n+\n+   /*\n+    * Map containing default values for required configuration properties\n+    */\n+    private static final Map<String, String> CC_DEFAULT_PROPERTIES_MAP;\n+\n+    private static final List<String> FORBIDDEN_OPTIONS;\n+    private static final List<String> EXCEPTIONS;\n+\n+    static {\n+        CC_DEFAULT_PROPERTIES_MAP = new HashMap<>();\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"partition.metrics.window.ms\", \"300000\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"num.partition.metrics.windows\", \"1\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"broker.metrics.window.ms\", \"300000\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"num.broker.metrics.windows\", \"20\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"completed.user.task.retention.time.ms\", \"86400000\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE4MjI5Nw==", "bodyText": "Would something like this work?\n// The maximum time in milliseconds to store the response and access details of a completed user task.\nCC_DEFAULT_PROPERTIES_MAP.put(\"completed.user.task.retention.time.ms\", Integer.toString(86_400_000));\n\nOr I could add a link to the CC configuration settings. Let me know what you think!", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r403182297", "createdAt": "2020-04-03T17:39:50Z", "author": {"login": "kyguy"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControlConfiguration.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+\n+/**\n+ * Class for handling Cruise Control configuration passed by the user\n+ */\n+public class CruiseControlConfiguration extends AbstractConfiguration {\n+\n+    /**\n+     * A list of case insensitive goals that Cruise Control supports in the order of priority.\n+     * The high priority goals will be executed first.\n+     */\n+    private static final String DEFAULT_GOALS = \"com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.PotentialNwOutGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.TopicReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderBytesInDistributionGoal\";\n+\n+   /*\n+    * Map containing default values for required configuration properties\n+    */\n+    private static final Map<String, String> CC_DEFAULT_PROPERTIES_MAP;\n+\n+    private static final List<String> FORBIDDEN_OPTIONS;\n+    private static final List<String> EXCEPTIONS;\n+\n+    static {\n+        CC_DEFAULT_PROPERTIES_MAP = new HashMap<>();\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"partition.metrics.window.ms\", \"300000\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"num.partition.metrics.windows\", \"1\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"broker.metrics.window.ms\", \"300000\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"num.broker.metrics.windows\", \"20\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"completed.user.task.retention.time.ms\", \"86400000\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzOTU0Mw=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDAzNzE5OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODozMToxMFrOF_grLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODozMToxMFrOF_grLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzOTk1MQ==", "bodyText": "Use addAll(), rather than building a new HashSet", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402139951", "createdAt": "2020-04-02T08:31:10Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -440,6 +448,24 @@ public static KafkaCluster fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup vers\n         }\n \n         KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+        CruiseControlSpec cruiseControlSpec  = kafkaSpec.getCruiseControl();\n+\n+        String metricReporters =  configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD);\n+        Set<String> metricReporterList = new HashSet<>();\n+        if (metricReporters != null) {\n+            metricReporterList = new HashSet<String>(Arrays.asList(configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD).split(\",\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDAzOTE2OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/StorageUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODozMTozOVrOF_gsVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODozMTozOVrOF_gsVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0MDI0NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static long parseMemorybyFactor(String memory, String factor) {\n          \n          \n            \n                public static long parseMemoryByFactor(String memory, String factor) {", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402140245", "createdAt": "2020-04-02T08:31:39Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/StorageUtils.java", "diffHunk": "@@ -12,6 +12,17 @@\n  * Shared methods for working with Storage - for example comparing volume sizes\n  */\n public class StorageUtils {\n+    /**\n+     * Parse a K8S-style representation of a quantity of memory, such as {@code 512Mi},\n+     * into the equivalent number factor of bytes represented as a long.\n+     * @param memory The String representation of the quantity of memory.\n+     * @param factor The factor which the bytes should be converted to\n+     * @return The equivalent number factor of bytes.\n+     */\n+    public static long parseMemorybyFactor(String memory, String factor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDA0MzE1OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/StorageUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODozMjo0MVrOF_gu3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODozMjo0MVrOF_gu3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0MDg5Mw==", "bodyText": "I think you should give an example, because this doesn't make complete sense to me.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402140893", "createdAt": "2020-04-02T08:32:41Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/StorageUtils.java", "diffHunk": "@@ -12,6 +12,17 @@\n  * Shared methods for working with Storage - for example comparing volume sizes\n  */\n public class StorageUtils {\n+    /**\n+     * Parse a K8S-style representation of a quantity of memory, such as {@code 512Mi},\n+     * into the equivalent number factor of bytes represented as a long.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDA0ODEzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/cruisecontrol/Capacity.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODozMzo1N1rOF_gyAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODozMzo1N1rOF_gyAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0MTY5OA==", "bodyText": "Again _ as a separator.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402141698", "createdAt": "2020-04-02T08:33:57Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/cruisecontrol/Capacity.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model.cruisecontrol;\n+\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+\n+import java.util.List;\n+\n+import static io.strimzi.operator.cluster.model.StorageUtils.parseMemorybyFactor;\n+\n+public class Capacity {\n+    public static final int DEFAULT_BROKER_DISK_CAPACITY   = 100000;  // in MB\n+    public static final int DEFAULT_BROKER_CPU_CAPACITY    = 100;     // as a percentage (0-100)\n+    public static final int DEFAULT_BROKER_NW_IN_CAPACITY  = 10000;   // in KB/s\n+    public static final int DEFAULT_BROKER_NW_OUT_CAPACITY = 10000;   // in KB/s", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDA2MDk4OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/cruisecontrol/Capacity.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODozNjo1N1rOF_g5tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODozNjo1N1rOF_g5tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0MzY2OA==", "bodyText": "Why not just use a Long to avoid the possibility of overflow and hence an exception?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402143668", "createdAt": "2020-04-02T08:36:57Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/cruisecontrol/Capacity.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model.cruisecontrol;\n+\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+\n+import java.util.List;\n+\n+import static io.strimzi.operator.cluster.model.StorageUtils.parseMemorybyFactor;\n+\n+public class Capacity {\n+    public static final int DEFAULT_BROKER_DISK_CAPACITY   = 100000;  // in MB\n+    public static final int DEFAULT_BROKER_CPU_CAPACITY    = 100;     // as a percentage (0-100)\n+    public static final int DEFAULT_BROKER_NW_IN_CAPACITY  = 10000;   // in KB/s\n+    public static final int DEFAULT_BROKER_NW_OUT_CAPACITY = 10000;   // in KB/s\n+\n+    private Integer disk;\n+    private Integer cpu;\n+    private Integer networkIn;\n+    private Integer networkOut;\n+\n+    public Capacity(KafkaSpec spec) {\n+        CruiseControlBrokerCapacity bc = spec.getCruiseControl().getCapacity();\n+\n+        this.disk = bc != null && bc.getDisk() != null ? bc.getDisk() : generateDiskCapacity(spec.getKafka().getStorage());\n+        this.cpu = bc != null && bc.getCpu() != null ? bc.getCpu() : DEFAULT_BROKER_CPU_CAPACITY;\n+        this.networkIn = bc != null && bc.getNetworkIn() != null ? bc.getNetworkIn() : DEFAULT_BROKER_NW_IN_CAPACITY;\n+        this.networkOut = bc != null && bc.getNetworkOut() != null ? bc.getNetworkOut() : DEFAULT_BROKER_NW_OUT_CAPACITY;\n+    }\n+\n+    /**\n+     * Generate disk capacity configuration from the supplied storage configuration\n+     *\n+     * @param storage Storage configuration for Kafka cluster\n+     * @return Disk capacity configuration as a String\n+     */\n+    public static Integer generateDiskCapacity(Storage storage) {\n+        if (storage instanceof PersistentClaimStorage) {\n+            return getSizeInMb(((PersistentClaimStorage) storage).getSize());\n+        } else if (storage instanceof EphemeralStorage) {\n+            if (((EphemeralStorage) storage).getSizeLimit() != null) {\n+                return getSizeInMb(((EphemeralStorage) storage).getSizeLimit());\n+            } else {\n+                return DEFAULT_BROKER_DISK_CAPACITY;\n+            }\n+        } else if (storage instanceof JbodStorage) {\n+            List<SingleVolumeStorage> volumeList = ((JbodStorage) storage).getVolumes();\n+            int size = 0;\n+            for (SingleVolumeStorage volume : volumeList) {\n+                size += generateDiskCapacity(volume);\n+            }\n+            return size;\n+        } else {\n+            throw new IllegalStateException(\"The declared storage '\" + storage.getType() + \"' is not supported\");\n+        }\n+    }\n+\n+    /*\n+     * Parse a K8S-style representation of a disk size, such as {@code 100Gi},\n+     * into the equivalent number of megabytes represented as a Integer.\n+     *\n+     * @param size The String representation of the volume size.\n+     * @return The equivalent number of Megabytes.\n+     */\n+    public static Integer getSizeInMb(String size) {\n+        return Math.toIntExact(parseMemorybyFactor(size, size.charAt(size.length() - 1) == 'i' ? \"Mi\" : \"M\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDA3MjU3OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODo0MDowMVrOF_hBBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODo0MDowMVrOF_hBBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0NTU0Mg==", "bodyText": "Let's include the units in the env vars too, because there's nothing more embarrassing that a bug due to confused units.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402145542", "createdAt": "2020-04-02T08:40:01Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDA3Njk5OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODo0MTowOFrOF_hDvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODo0MTowOFrOF_hDvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0NjIzNg==", "bodyText": "new ArrayList<>(). But I'm looking forward to the day we more the operator to Java 11 and can just write var volumes = new ArrayList<SingleVolumeStorage>();", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402146236", "createdAt": "2020-04-02T08:41:08Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/CruiseControlTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.EnvVarBuilder;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.OwnerReference;\n+import io.fabric8.kubernetes.api.model.Quantity;\n+import io.fabric8.kubernetes.api.model.ResourceRequirementsBuilder;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.CruiseControlSpecBuilder;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.model.Labels;\n+import io.strimzi.test.TestUtils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.CruiseControl.ENV_VAR_BROKER_NETWORK_OUT_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_CPU_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_DISK_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_IN_CAPACITY;\n+import static io.strimzi.operator.cluster.model.cruisecontrol.Capacity.DEFAULT_BROKER_NW_OUT_CAPACITY;\n+import static java.util.Collections.singletonMap;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CruiseControlTest {\n+    private final String namespace = \"test\";\n+    private final String cluster = \"foo\";\n+    private final int replicas = 1;\n+    private final String image = \"my-image:latest\";\n+    private final int healthDelay = 120;\n+    private final int healthTimeout = 30;\n+    private final String minInsyncReplicas = \"2\";\n+    private final Map<String, Object> metricsCm = singletonMap(\"animal\", \"wombat\");\n+    private final Map<String, Object> kafkaConfig = singletonMap(CruiseControl.MIN_INSYNC_REPLICAS, minInsyncReplicas);\n+    private final Map<String, Object> zooConfig = singletonMap(\"foo\", \"bar\");\n+\n+    CruiseControlConfiguration configuration = new CruiseControlConfiguration(new HashMap<String, Object>() {{\n+            putAll(configuration.getCruiseControlDefaultPropertiesMap());\n+            put(\"num.partition.metrics.windows\", \"2\");\n+        }}.entrySet()\n+    );\n+    private final Storage kafkaStorage = new EphemeralStorage();\n+    private final SingleVolumeStorage zkStorage = new EphemeralStorage();\n+    private final InlineLogging kafkaLogJson = new InlineLogging();\n+    private final InlineLogging zooLogJson = new InlineLogging();\n+    private final String version = KafkaVersionTestUtils.DEFAULT_KAFKA_VERSION;\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String kafkaHeapOpts = \"-Xms\" + AbstractModel.DEFAULT_JVM_XMS;\n+    private final String ccImage = \"my-cruise-control-image\";\n+\n+    {\n+        kafkaLogJson.setLoggers(singletonMap(\"kafka.root.logger.level\", \"OFF\"));\n+        zooLogJson.setLoggers(singletonMap(\"zookeeper.root.logger\", \"OFF\"));\n+    }\n+\n+    private final CruiseControlSpec cruiseControlSpec = new CruiseControlSpecBuilder()\n+            .withImage(ccImage)\n+            .withReplicas(replicas)\n+            .withConfig((Map) configuration.asOrderedProperties().asMap())\n+            .build();\n+\n+    private final Kafka resource =\n+            new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                    .withConfig(kafkaConfig)\n+                .endKafka()\n+                .withCruiseControl(cruiseControlSpec)\n+            .endSpec()\n+            .build();\n+\n+    private final CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+\n+    public void checkOwnerReference(OwnerReference ownerRef, HasMetadata resource)  {\n+        assertThat(resource.getMetadata().getOwnerReferences().size(), is(1));\n+        assertThat(resource.getMetadata().getOwnerReferences().get(0), is(ownerRef));\n+    }\n+\n+    private Map<String, String> expectedLabels(String name)    {\n+        return TestUtils.map(Labels.STRIMZI_CLUSTER_LABEL, this.cluster,\n+                \"my-user-label\", \"cromulent\",\n+                Labels.STRIMZI_KIND_LABEL, Kafka.RESOURCE_KIND,\n+                Labels.STRIMZI_NAME_LABEL, name,\n+                Labels.KUBERNETES_NAME_LABEL, CruiseControl.APPLICATION_NAME,\n+                Labels.KUBERNETES_INSTANCE_LABEL, this.cluster,\n+                Labels.KUBERNETES_PART_OF_LABEL, Labels.APPLICATION_NAME + \"-\" + this.cluster,\n+                Labels.KUBERNETES_MANAGED_BY_LABEL, AbstractModel.STRIMZI_CLUSTER_OPERATOR_NAME);\n+    }\n+\n+    private Map<String, String> expectedSelectorLabels()    {\n+        return Labels.fromMap(expectedLabels()).strimziSelectorLabels().toMap();\n+    }\n+\n+    private Map<String, String> expectedLabels()    {\n+        return expectedLabels(CruiseControlResources.deploymentName(cluster));\n+    }\n+\n+    private List<EnvVar> getExpectedEnvVars() {\n+        List<EnvVar> expected = new ArrayList<>();\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS).withValue(CruiseControl.defaultBootstrapServers(cluster)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_STRIMZI_KAFKA_GC_LOG_ENABLED).withValue(Boolean.toString(AbstractModel.DEFAULT_JVM_GC_LOGGING_ENABLED)).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_MIN_INSYNC_REPLICAS).withValue(minInsyncReplicas).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_DISK_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_DISK_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_CPU_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_CPU_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_IN_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_IN_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(ENV_VAR_BROKER_NETWORK_OUT_CAPACITY).withValue(Integer.toString(DEFAULT_BROKER_NW_OUT_CAPACITY)).build());\n+        expected.add(new EnvVarBuilder().withName(KafkaMirrorMakerCluster.ENV_VAR_KAFKA_HEAP_OPTS).withValue(kafkaHeapOpts).build());\n+        expected.add(new EnvVarBuilder().withName(CruiseControl.ENV_VAR_CRUISE_CONTROL_CONFIGURATION).withValue(configuration.getConfiguration()).build());\n+\n+        return expected;\n+    }\n+\n+    public String getCapacityConfigurationFromEnvVar(Kafka resource, String envVar) {\n+        CruiseControl cc = CruiseControl.fromCrd(resource, VERSIONS);\n+        Deployment dep = cc.generateDeployment(true, null, null, null);\n+        List<Container> containers = dep.getSpec().getTemplate().getSpec().getContainers();\n+\n+        // checks on the main Cruise Control container\n+        Container ccContainer = containers.stream().filter(container -> ccImage.equals(container.getImage())).findFirst().get();\n+        List<EnvVar> ccEnvVars = ccContainer.getEnv();\n+\n+        return ccEnvVars.stream().filter(var -> envVar.equals(var.getName())).map(EnvVar::getValue).findFirst().get();\n+    }\n+\n+    @Test\n+    public void testBrokerCapacities() {\n+        // Test user defined capacities\n+        CruiseControlBrokerCapacity userDefinedCapacity = new CruiseControlBrokerCapacity();\n+        userDefinedCapacity.setDisk(20000);\n+        userDefinedCapacity.setCpu(95);\n+        userDefinedCapacity.setNetworkIn(50000);\n+        userDefinedCapacity.setNetworkOut(50000);\n+\n+        Kafka resource = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas, image, healthDelay, healthTimeout))\n+            .editSpec()\n+                .editKafka()\n+                    .withVersion(version)\n+                .endKafka()\n+                .withNewCruiseControl()\n+                    .withImage(ccImage)\n+                    .withCapacity(userDefinedCapacity)\n+                .endCruiseControl()\n+            .endSpec()\n+            .build();\n+\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_DISK_CAPACITY), is(Integer.toString(userDefinedCapacity.getDisk())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_CPU_CAPACITY), is(Integer.toString(userDefinedCapacity.getCpu())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_IN_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkIn())));\n+        assertThat(getCapacityConfigurationFromEnvVar(resource, ENV_VAR_BROKER_NETWORK_OUT_CAPACITY), is(Integer.toString(userDefinedCapacity.getNetworkOut())));\n+\n+        // Test generated disk capacity\n+        JbodStorage jbodStorage = new JbodStorage();\n+        List<SingleVolumeStorage> volumes = new ArrayList<SingleVolumeStorage>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDEwNTM0OnYy", "diffSide": "RIGHT", "path": "docker-images/kafka/cruise-control-scripts/cruise_control_config_generator.sh", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODo0ODowOVrOF_hVUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNDoxMTowMlrOGBZn7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1MDczOA==", "bodyText": "Does this mean we're assuming at this point that all broker's have the same disk. It's not strictly true (e.g. during storage resizing I suspect it's possible for some brokers to have more than others). I guess it's not a problem if CC gets rolled following storage increase. And I don't recall whether we support decreasing storage size, but if we do that's another case to consider.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402150738", "createdAt": "2020-04-02T08:48:09Z", "author": {"login": "tombentley"}, "path": "docker-images/kafka/cruise-control-scripts/cruise_control_config_generator.sh", "diffHunk": "@@ -0,0 +1,42 @@\n+#!/usr/bin/env bash\n+\n+CC_CAPACITY_FILE=\"/tmp/capacity.json\"\n+CC_CLUSTER_CONFIG_FILE=\"/tmp/clusterConfig.json\"\n+\n+# Generate capacity file\n+cat <<EOF > $CC_CAPACITY_FILE\n+{\n+\t\"brokerCapacities\": [{\n+\t\t\"brokerId\": \"-1\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEyMTU4Mw==", "bodyText": "Does this mean we're assuming at this point that all broker's have the same disk.\n\nYes\n\nI guess it's not a problem if CC gets rolled following storage increase. And I don't recall whether we support decreasing storage size, but if we do that's another case to consider.\n\nCC rolls to update the storage capacity every time the storage changes in the Kafka resource", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404121583", "createdAt": "2020-04-06T14:11:02Z", "author": {"login": "kyguy"}, "path": "docker-images/kafka/cruise-control-scripts/cruise_control_config_generator.sh", "diffHunk": "@@ -0,0 +1,42 @@\n+#!/usr/bin/env bash\n+\n+CC_CAPACITY_FILE=\"/tmp/capacity.json\"\n+CC_CLUSTER_CONFIG_FILE=\"/tmp/clusterConfig.json\"\n+\n+# Generate capacity file\n+cat <<EOF > $CC_CAPACITY_FILE\n+{\n+\t\"brokerCapacities\": [{\n+\t\t\"brokerId\": \"-1\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1MDczOA=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDEwODAxOnYy", "diffSide": "RIGHT", "path": "docker-images/kafka/cruise-control-scripts/cruise_control_config_generator.sh", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODo0ODo0OFrOF_hW_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODo0ODo0OFrOF_hW_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1MTE2NQ==", "bodyText": "Presumably this is us telling CC what the cluster's default min ISR is?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402151165", "createdAt": "2020-04-02T08:48:48Z", "author": {"login": "tombentley"}, "path": "docker-images/kafka/cruise-control-scripts/cruise_control_config_generator.sh", "diffHunk": "@@ -0,0 +1,42 @@\n+#!/usr/bin/env bash\n+\n+CC_CAPACITY_FILE=\"/tmp/capacity.json\"\n+CC_CLUSTER_CONFIG_FILE=\"/tmp/clusterConfig.json\"\n+\n+# Generate capacity file\n+cat <<EOF > $CC_CAPACITY_FILE\n+{\n+\t\"brokerCapacities\": [{\n+\t\t\"brokerId\": \"-1\",\n+\t\t\"capacity\": {\n+\t\t\t\"DISK\": \"$BROKER_DISK_CAPACITY\",\n+\t\t\t\"CPU\": \"$BROKER_CPU_CAPACITY\",\n+\t\t\t\"NW_IN\": \"$BROKER_NETWORK_IN_CAPACITY\",\n+\t\t\t\"NW_OUT\": \"$BROKER_NETWORK_OUT_CAPACITY\"\n+\t\t},\n+\t\t\"doc\": \"This is the default capacity. Capacity unit used for disk is in MB, cpu is in percentage, network throughput is in KB.\"\n+\t}]\n+}\n+EOF\n+\n+cat $CC_CAPACITY_FILE\n+\n+# Generate cluster config\n+cat <<EOF > $CC_CLUSTER_CONFIG_FILE\n+{\n+min.insync.replicas=$MIN_INSYNC_REPLICAS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDExMzY5OnYy", "diffSide": "RIGHT", "path": "docker-images/kafka/cruise-control-scripts/cruise_control_config_generator.sh", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODo1MDoxNlrOF_haiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNTozNToxMVrOGBdpAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1MjA3Mw==", "bodyText": "Do we have control over these names? If so, maybe now's the time to think about whether we should have a naming convention for \"Strimzi internal topics\" (which these effectively are).", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402152073", "createdAt": "2020-04-02T08:50:16Z", "author": {"login": "tombentley"}, "path": "docker-images/kafka/cruise-control-scripts/cruise_control_config_generator.sh", "diffHunk": "@@ -0,0 +1,42 @@\n+#!/usr/bin/env bash\n+\n+CC_CAPACITY_FILE=\"/tmp/capacity.json\"\n+CC_CLUSTER_CONFIG_FILE=\"/tmp/clusterConfig.json\"\n+\n+# Generate capacity file\n+cat <<EOF > $CC_CAPACITY_FILE\n+{\n+\t\"brokerCapacities\": [{\n+\t\t\"brokerId\": \"-1\",\n+\t\t\"capacity\": {\n+\t\t\t\"DISK\": \"$BROKER_DISK_CAPACITY\",\n+\t\t\t\"CPU\": \"$BROKER_CPU_CAPACITY\",\n+\t\t\t\"NW_IN\": \"$BROKER_NETWORK_IN_CAPACITY\",\n+\t\t\t\"NW_OUT\": \"$BROKER_NETWORK_OUT_CAPACITY\"\n+\t\t},\n+\t\t\"doc\": \"This is the default capacity. Capacity unit used for disk is in MB, cpu is in percentage, network throughput is in KB.\"\n+\t}]\n+}\n+EOF\n+\n+cat $CC_CAPACITY_FILE\n+\n+# Generate cluster config\n+cat <<EOF > $CC_CLUSTER_CONFIG_FILE\n+{\n+min.insync.replicas=$MIN_INSYNC_REPLICAS\n+}\n+EOF\n+\n+# Write the config file\n+cat <<EOF\n+bootstrap.servers=$STRIMZI_KAFKA_BOOTSTRAP_SERVERS\n+zookeeper.connect=localhost:2181\n+partition.metric.sample.store.topic=__KafkaCruiseControlPartitionMetricSamples\n+broker.metric.sample.store.topic=__KafkaCruiseControlModelTrainingSamples", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY5NjUzMQ==", "bodyText": "Yeah good point. Maybe something like strimzi.cruisecontrol.partitionmetricsamples could be good to have (tbh I am not for using upper case letters in topic names ... but it's just my opinion).", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r403696531", "createdAt": "2020-04-05T12:41:15Z", "author": {"login": "ppatierno"}, "path": "docker-images/kafka/cruise-control-scripts/cruise_control_config_generator.sh", "diffHunk": "@@ -0,0 +1,42 @@\n+#!/usr/bin/env bash\n+\n+CC_CAPACITY_FILE=\"/tmp/capacity.json\"\n+CC_CLUSTER_CONFIG_FILE=\"/tmp/clusterConfig.json\"\n+\n+# Generate capacity file\n+cat <<EOF > $CC_CAPACITY_FILE\n+{\n+\t\"brokerCapacities\": [{\n+\t\t\"brokerId\": \"-1\",\n+\t\t\"capacity\": {\n+\t\t\t\"DISK\": \"$BROKER_DISK_CAPACITY\",\n+\t\t\t\"CPU\": \"$BROKER_CPU_CAPACITY\",\n+\t\t\t\"NW_IN\": \"$BROKER_NETWORK_IN_CAPACITY\",\n+\t\t\t\"NW_OUT\": \"$BROKER_NETWORK_OUT_CAPACITY\"\n+\t\t},\n+\t\t\"doc\": \"This is the default capacity. Capacity unit used for disk is in MB, cpu is in percentage, network throughput is in KB.\"\n+\t}]\n+}\n+EOF\n+\n+cat $CC_CAPACITY_FILE\n+\n+# Generate cluster config\n+cat <<EOF > $CC_CLUSTER_CONFIG_FILE\n+{\n+min.insync.replicas=$MIN_INSYNC_REPLICAS\n+}\n+EOF\n+\n+# Write the config file\n+cat <<EOF\n+bootstrap.servers=$STRIMZI_KAFKA_BOOTSTRAP_SERVERS\n+zookeeper.connect=localhost:2181\n+partition.metric.sample.store.topic=__KafkaCruiseControlPartitionMetricSamples\n+broker.metric.sample.store.topic=__KafkaCruiseControlModelTrainingSamples", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1MjA3Mw=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE4NzM5Mw==", "bodyText": "Do we have control over these names?\n\nYes\n\nYeah good point. Maybe something like strimzi.cruisecontrol.partitionmetricsamples could be good to have (tbh I am not for using upper case letters in topic names ... but it's just my opinion).\n\nI like this idea, a topic name like this is valid in Kafka and K8s, allowing the name to be consistent amongst both", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404187393", "createdAt": "2020-04-06T15:35:11Z", "author": {"login": "kyguy"}, "path": "docker-images/kafka/cruise-control-scripts/cruise_control_config_generator.sh", "diffHunk": "@@ -0,0 +1,42 @@\n+#!/usr/bin/env bash\n+\n+CC_CAPACITY_FILE=\"/tmp/capacity.json\"\n+CC_CLUSTER_CONFIG_FILE=\"/tmp/clusterConfig.json\"\n+\n+# Generate capacity file\n+cat <<EOF > $CC_CAPACITY_FILE\n+{\n+\t\"brokerCapacities\": [{\n+\t\t\"brokerId\": \"-1\",\n+\t\t\"capacity\": {\n+\t\t\t\"DISK\": \"$BROKER_DISK_CAPACITY\",\n+\t\t\t\"CPU\": \"$BROKER_CPU_CAPACITY\",\n+\t\t\t\"NW_IN\": \"$BROKER_NETWORK_IN_CAPACITY\",\n+\t\t\t\"NW_OUT\": \"$BROKER_NETWORK_OUT_CAPACITY\"\n+\t\t},\n+\t\t\"doc\": \"This is the default capacity. Capacity unit used for disk is in MB, cpu is in percentage, network throughput is in KB.\"\n+\t}]\n+}\n+EOF\n+\n+cat $CC_CAPACITY_FILE\n+\n+# Generate cluster config\n+cat <<EOF > $CC_CLUSTER_CONFIG_FILE\n+{\n+min.insync.replicas=$MIN_INSYNC_REPLICAS\n+}\n+EOF\n+\n+# Write the config file\n+cat <<EOF\n+bootstrap.servers=$STRIMZI_KAFKA_BOOTSTRAP_SERVERS\n+zookeeper.connect=localhost:2181\n+partition.metric.sample.store.topic=__KafkaCruiseControlPartitionMetricSamples\n+broker.metric.sample.store.topic=__KafkaCruiseControlModelTrainingSamples", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1MjA3Mw=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDEyMDc1OnYy", "diffSide": "RIGHT", "path": "docker-images/kafka/cruise-control-scripts/cruise_control_config_generator.sh", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODo1MjoxN1rOF_hfPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwMDowMDo1MFrOGDFFBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1MzI3OA==", "bodyText": "So /tmp is usually an in-memory file system these days IIRC, which means this could, hypothetically, result in the OOM killer being unleashed. Can we redirect this to CC's stdout?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402153278", "createdAt": "2020-04-02T08:52:17Z", "author": {"login": "tombentley"}, "path": "docker-images/kafka/cruise-control-scripts/cruise_control_config_generator.sh", "diffHunk": "@@ -0,0 +1,42 @@\n+#!/usr/bin/env bash\n+\n+CC_CAPACITY_FILE=\"/tmp/capacity.json\"\n+CC_CLUSTER_CONFIG_FILE=\"/tmp/clusterConfig.json\"\n+\n+# Generate capacity file\n+cat <<EOF > $CC_CAPACITY_FILE\n+{\n+\t\"brokerCapacities\": [{\n+\t\t\"brokerId\": \"-1\",\n+\t\t\"capacity\": {\n+\t\t\t\"DISK\": \"$BROKER_DISK_CAPACITY\",\n+\t\t\t\"CPU\": \"$BROKER_CPU_CAPACITY\",\n+\t\t\t\"NW_IN\": \"$BROKER_NETWORK_IN_CAPACITY\",\n+\t\t\t\"NW_OUT\": \"$BROKER_NETWORK_OUT_CAPACITY\"\n+\t\t},\n+\t\t\"doc\": \"This is the default capacity. Capacity unit used for disk is in MB, cpu is in percentage, network throughput is in KB.\"\n+\t}]\n+}\n+EOF\n+\n+cat $CC_CAPACITY_FILE\n+\n+# Generate cluster config\n+cat <<EOF > $CC_CLUSTER_CONFIG_FILE\n+{\n+min.insync.replicas=$MIN_INSYNC_REPLICAS\n+}\n+EOF\n+\n+# Write the config file\n+cat <<EOF\n+bootstrap.servers=$STRIMZI_KAFKA_BOOTSTRAP_SERVERS\n+zookeeper.connect=localhost:2181\n+partition.metric.sample.store.topic=__KafkaCruiseControlPartitionMetricSamples\n+broker.metric.sample.store.topic=__KafkaCruiseControlModelTrainingSamples\n+capacity.config.file=$CC_CAPACITY_FILE\n+cluster.configs.file=$CC_CLUSTER_CONFIG_FILE\n+webserver.accesslog.path=/tmp/access.log", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4MjExOQ==", "bodyText": "We can, I created a symlink from /tmp/access.log to /dev/stdout in the generation scripts.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405882119", "createdAt": "2020-04-09T00:00:50Z", "author": {"login": "kyguy"}, "path": "docker-images/kafka/cruise-control-scripts/cruise_control_config_generator.sh", "diffHunk": "@@ -0,0 +1,42 @@\n+#!/usr/bin/env bash\n+\n+CC_CAPACITY_FILE=\"/tmp/capacity.json\"\n+CC_CLUSTER_CONFIG_FILE=\"/tmp/clusterConfig.json\"\n+\n+# Generate capacity file\n+cat <<EOF > $CC_CAPACITY_FILE\n+{\n+\t\"brokerCapacities\": [{\n+\t\t\"brokerId\": \"-1\",\n+\t\t\"capacity\": {\n+\t\t\t\"DISK\": \"$BROKER_DISK_CAPACITY\",\n+\t\t\t\"CPU\": \"$BROKER_CPU_CAPACITY\",\n+\t\t\t\"NW_IN\": \"$BROKER_NETWORK_IN_CAPACITY\",\n+\t\t\t\"NW_OUT\": \"$BROKER_NETWORK_OUT_CAPACITY\"\n+\t\t},\n+\t\t\"doc\": \"This is the default capacity. Capacity unit used for disk is in MB, cpu is in percentage, network throughput is in KB.\"\n+\t}]\n+}\n+EOF\n+\n+cat $CC_CAPACITY_FILE\n+\n+# Generate cluster config\n+cat <<EOF > $CC_CLUSTER_CONFIG_FILE\n+{\n+min.insync.replicas=$MIN_INSYNC_REPLICAS\n+}\n+EOF\n+\n+# Write the config file\n+cat <<EOF\n+bootstrap.servers=$STRIMZI_KAFKA_BOOTSTRAP_SERVERS\n+zookeeper.connect=localhost:2181\n+partition.metric.sample.store.topic=__KafkaCruiseControlPartitionMetricSamples\n+broker.metric.sample.store.topic=__KafkaCruiseControlModelTrainingSamples\n+capacity.config.file=$CC_CAPACITY_FILE\n+cluster.configs.file=$CC_CLUSTER_CONFIG_FILE\n+webserver.accesslog.path=/tmp/access.log", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1MzI3OA=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDEzMDM4OnYy", "diffSide": "RIGHT", "path": "docker-images/kafka/cruise-control-scripts/cruise_control_tls_prepare_certificates.sh", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODo1NDo0N1rOF_hljw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMDoyMzo1N1rOGBofMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1NDg5NQ==", "bodyText": "This is basically the same file we use everywhere. Can we think about refactoring it so we actually have a single file? Opening a PR for this is fine.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402154895", "createdAt": "2020-04-02T08:54:47Z", "author": {"login": "tombentley"}, "path": "docker-images/kafka/cruise-control-scripts/cruise_control_tls_prepare_certificates.sh", "diffHunk": "@@ -0,0 +1,38 @@\n+#!/usr/bin/env bash", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY5NjYzNA==", "bodyText": "@kyguy I would open an issue for that so we can track for following PRs.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r403696634", "createdAt": "2020-04-05T12:41:59Z", "author": {"login": "ppatierno"}, "path": "docker-images/kafka/cruise-control-scripts/cruise_control_tls_prepare_certificates.sh", "diffHunk": "@@ -0,0 +1,38 @@\n+#!/usr/bin/env bash", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1NDg5NQ=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2NTEwNg==", "bodyText": "#2794", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404365106", "createdAt": "2020-04-06T20:23:57Z", "author": {"login": "kyguy"}, "path": "docker-images/kafka/cruise-control-scripts/cruise_control_tls_prepare_certificates.sh", "diffHunk": "@@ -0,0 +1,38 @@\n+#!/usr/bin/env bash", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1NDg5NQ=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDE0MzkwOnYy", "diffSide": "RIGHT", "path": "documentation/assemblies/cruise-control/assembly-cruise-control-concepts.adoc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODo1ODoxOFrOF_hugg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQxMjo0MzoxMVrOGA_skw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1NzE4Ng==", "bodyText": "I think we should be careful with how we describe CC here. How does CC describe itself? People might misinterpret \"Kafka CruiseControl project\" to mean it's part of Apache Kafka. I think calling it CruiseControl (without the Kafka part) makes it clearer that it's an independent project.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402157186", "createdAt": "2020-04-02T08:58:18Z", "author": {"login": "tombentley"}, "path": "documentation/assemblies/cruise-control/assembly-cruise-control-concepts.adoc", "diffHunk": "@@ -0,0 +1,18 @@\n+// This assembly is included in the following assemblies:\n+//\n+// master.adoc\n+\n+[id='cruise-control-concepts-{context}']\n+= Cruise Control\n+\n+This chapter provides an overview of the Kafka cluster rebalancing features provided by the Kafka {CruiseControlProject} open source project and helps you get started using Cruise Control with {ProductName}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY5Njc4Nw==", "bodyText": "Or maybe \"Cruise Control for Apache Kafka\" ... where at some point calling it just \"Cruise Control\" is ok because it's a shorter version.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r403696787", "createdAt": "2020-04-05T12:43:11Z", "author": {"login": "ppatierno"}, "path": "documentation/assemblies/cruise-control/assembly-cruise-control-concepts.adoc", "diffHunk": "@@ -0,0 +1,18 @@\n+// This assembly is included in the following assemblies:\n+//\n+// master.adoc\n+\n+[id='cruise-control-concepts-{context}']\n+= Cruise Control\n+\n+This chapter provides an overview of the Kafka cluster rebalancing features provided by the Kafka {CruiseControlProject} open source project and helps you get started using Cruise Control with {ProductName}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1NzE4Ng=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDE0ODc1OnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/con-cruise-control-overview.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODo1OTozMVrOF_hxig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODo1OTozMVrOF_hxig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE1Nzk2Mg==", "bodyText": "It's quite likely that the reader has no idea at this point what a \"balanced partition assignment\" is. I think you need a sentence before you even mention CC, just to guide the reader into the why why of CC before you get on to the how. Something like \"Brokers in a Kafka cluster can become unevenly loaded due to things like an uneven distribution of busy partitions.\"", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402157962", "createdAt": "2020-04-02T08:59:31Z", "author": {"login": "tombentley"}, "path": "documentation/modules/cruise-control/con-cruise-control-overview.adoc", "diffHunk": "@@ -0,0 +1,19 @@\n+// This concept is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+// Save the context of the assembly that is including this one.\n+// This is necessary for including assemblies in assemblies.\n+// See also the complementary step on the last line of this file.\n+\n+[id='con-cruise-control-overview-{context}']\n+= Cruise Control overview\n+\n+Cruise Control is a tool for simplifying the monitoring and rebalancing of partitions across a Kafka cluster.\n+You deploy Cruise Control alongside a Kafka cluster to:\n+\n+* Monitor the CPU, disk, and network load of Kafka brokers.\n+* Propose balanced partition assignments, known as partition rebalance proposals.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDE2OTQ5OnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTowNDo1NFrOF_h-kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNToxODoyMFrOGC0KAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE2MTI5Ng==", "bodyText": "Does this belong in a procedure, rather than a concept?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402161296", "createdAt": "2020-04-02T09:04:54Z", "author": {"login": "tombentley"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000\n+      networkOut: 10000\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...\n+    resources: <4>\n+      requests:\n+        cpu: 200m\n+        memory: 64Mi\n+      limits:\n+        cpu: 500m\n+        memory: 128Mi\n+    logging: debug <5>\n+    template: <6>\n+      pod:\n+        metadata:\n+          labels:\n+            label1: value1\n+        securityContext:\n+          runAsUser: 1000001\n+          fsGroup: 0\n+        terminationGracePeriodSeconds: 120\n+    readinessProbe: <7>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+    livenessProbe: <8>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+# ...\n+----\n+<1> Number of Cruise Control application instances; set to `1` to run or `0` to pause the application.\n+<2> Specifies the Cruise Control capacity configuration. For more information, see xref:capacity_configuration[capacity configuration].\n+<3> Specifies the Cruise Control configuration. You can provide any xref:ref-cruise-control-configuration-{context}[standard configuration option] apart from those managed directly by {ProductName}.\n+<4> CPU and memory resources reserved for Cruise Control. For more information, see xref:assembly-resource-limits-and-requests-deployment-configuration-kafka[].\n+<5> Logging configuration, to log messages with a given severity (debug, info, warn, error, fatal) or above.\n+<6> xref:assembly-customizing-deployments-str[Customization of deployment templates and pods].\n+<7> xref:assembly-healthchecks-deployment-configuration-kafka[Healthcheck readiness probes].\n+<8> xref:assembly-healthchecks-deployment-configuration-kafka[Healthcheck liveness probes].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA3Mzk1MA==", "bodyText": "I think it could be separated into a reference but have been shuffling these around. Let me get the final word from @laidan6000", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r403073950", "createdAt": "2020-04-03T15:09:18Z", "author": {"login": "kyguy"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000\n+      networkOut: 10000\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...\n+    resources: <4>\n+      requests:\n+        cpu: 200m\n+        memory: 64Mi\n+      limits:\n+        cpu: 500m\n+        memory: 128Mi\n+    logging: debug <5>\n+    template: <6>\n+      pod:\n+        metadata:\n+          labels:\n+            label1: value1\n+        securityContext:\n+          runAsUser: 1000001\n+          fsGroup: 0\n+        terminationGracePeriodSeconds: 120\n+    readinessProbe: <7>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+    livenessProbe: <8>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+# ...\n+----\n+<1> Number of Cruise Control application instances; set to `1` to run or `0` to pause the application.\n+<2> Specifies the Cruise Control capacity configuration. For more information, see xref:capacity_configuration[capacity configuration].\n+<3> Specifies the Cruise Control configuration. You can provide any xref:ref-cruise-control-configuration-{context}[standard configuration option] apart from those managed directly by {ProductName}.\n+<4> CPU and memory resources reserved for Cruise Control. For more information, see xref:assembly-resource-limits-and-requests-deployment-configuration-kafka[].\n+<5> Logging configuration, to log messages with a given severity (debug, info, warn, error, fatal) or above.\n+<6> xref:assembly-customizing-deployments-str[Customization of deployment templates and pods].\n+<7> xref:assembly-healthchecks-deployment-configuration-kafka[Healthcheck readiness probes].\n+<8> xref:assembly-healthchecks-deployment-configuration-kafka[Healthcheck liveness probes].", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE2MTI5Ng=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYwNDg2NQ==", "bodyText": "On balance, I think it should stay here because the example configuration is helpful within the context of the task. In other words, it doesn't seem to stand alone as a concept or reference module.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405604865", "createdAt": "2020-04-08T15:18:20Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000\n+      networkOut: 10000\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...\n+    resources: <4>\n+      requests:\n+        cpu: 200m\n+        memory: 64Mi\n+      limits:\n+        cpu: 500m\n+        memory: 128Mi\n+    logging: debug <5>\n+    template: <6>\n+      pod:\n+        metadata:\n+          labels:\n+            label1: value1\n+        securityContext:\n+          runAsUser: 1000001\n+          fsGroup: 0\n+        terminationGracePeriodSeconds: 120\n+    readinessProbe: <7>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+    livenessProbe: <8>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+# ...\n+----\n+<1> Number of Cruise Control application instances; set to `1` to run or `0` to pause the application.\n+<2> Specifies the Cruise Control capacity configuration. For more information, see xref:capacity_configuration[capacity configuration].\n+<3> Specifies the Cruise Control configuration. You can provide any xref:ref-cruise-control-configuration-{context}[standard configuration option] apart from those managed directly by {ProductName}.\n+<4> CPU and memory resources reserved for Cruise Control. For more information, see xref:assembly-resource-limits-and-requests-deployment-configuration-kafka[].\n+<5> Logging configuration, to log messages with a given severity (debug, info, warn, error, fatal) or above.\n+<6> xref:assembly-customizing-deployments-str[Customization of deployment templates and pods].\n+<7> xref:assembly-healthchecks-deployment-configuration-kafka[Healthcheck readiness probes].\n+<8> xref:assembly-healthchecks-deployment-configuration-kafka[Healthcheck liveness probes].", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE2MTI5Ng=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDE3Njg4OnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTowNjo0NlrOF_iDXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTowNjo0NlrOF_iDXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE2MjUyNA==", "bodyText": "This applies more generally to the rest of the docs too, but here would be a good place for a NOTE to say that if your String happens to look like YAML or JSON it will need to be explicitly quoted.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402162524", "createdAt": "2020-04-02T09:06:46Z", "author": {"login": "tombentley"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,92 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDE4MDcwOnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTowNzo0NVrOF_iFsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMjo0NDo0M1rOF__HVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE2MzEyMQ==", "bodyText": "Which begs the question: What happens if the limits are violated?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402163121", "createdAt": "2020-04-02T09:07:45Z", "author": {"login": "tombentley"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,92 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYzODY3OQ==", "bodyText": "Added some text:\n\nA violation of a goal can cause a optimization to fail, preventing that optimization from being used to generate a partition rebalance proposal.\nFor example, an optimization that would cause a broker to exceed its CPU capacity would not be used for when the CpuCapacityGoal is set as a hard goal", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402638679", "createdAt": "2020-04-02T22:44:43Z", "author": {"login": "kyguy"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,92 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE2MzEyMQ=="}, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDE4MjQ4OnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTowODoxNVrOF_iG3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTowODoxNVrOF_iG3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE2MzQyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Since {ProductName} brokers are homogenous, Cruise Control will apply the same capacity limits to every broker it is monitoring.\n          \n          \n            \n            Since {ProductName} brokers are homogeneous, Cruise Control will apply the same capacity limits to every broker it is monitoring.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402163422", "createdAt": "2020-04-02T09:08:15Z", "author": {"login": "tombentley"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,92 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.\n+\n+Capacity limits for broker resources can be specified in the `capacity` property in `Kafka.spec.cruiseControl`.\n+Capacity limits can be set for the following broker resources in the described units:\n+\n+* `disk`  - Disk storage in MB\n+* `cpu`   - CPU utilization as a percent (0-100)\n+* `networkIn`  - Network inbound throughput in KB/s\n+* `networkOut` - Newtork outbound throughput in KB/s\n+\n+Since {ProductName} brokers are homogenous, Cruise Control will apply the same capacity limits to every broker it is monitoring.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDgzODQyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjoxOTo0NVrOF_ohtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjoxOTo0NVrOF_ohtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2ODU5OA==", "bodyText": "as Tom suggested above, config should also be configuration here", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r402268598", "createdAt": "2020-04-02T12:19:45Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.CruiseControlBrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"capacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, capacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private CruiseControlBrokerCapacity capacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control broker capacity config.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public CruiseControlBrokerCapacity getCapacity() {\n+        return capacity;\n+    }\n+\n+    public void setCapacity(CruiseControlBrokerCapacity capacity) {\n+        this.capacity = capacity;\n+    }\n+\n+    @Description(\"The Cruise Control config. Properties with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232d8aeeff07cfabe6bfc684e5f5b19668da0983"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDY0NDcwOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzozMTo0NVrOGB2jTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzozMTo0NVrOGB2jTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NTUzMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n          \n          \n            \n                    + \"cruise.control.metrics.reporter.bootstrap.servers, sasl.interceptor.classes\";", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404595532", "createdAt": "2020-04-07T07:31:45Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDY0NTE4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzozMTo0OVrOGB2jiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNTozNzoyNFrOGDePyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NTU5Mw==", "bodyText": "I guess we should add ssl.cipher.suites and ssl.enabled.protocols to the exceptions.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404595593", "createdAt": "2020-04-07T07:31:49Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5NDQ3Mg==", "bodyText": "I am going to enable ssl configurations until I secure the communication between Cruise Control and Kafka brokers with SSL", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r406294472", "createdAt": "2020-04-09T15:37:24Z", "author": {"login": "kyguy"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NTU5Mw=="}, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDY0Njg2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzozMjoxOVrOGB2klQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzozMjoxOVrOGB2klQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NTg2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n          \n          \n            \n                    + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic,\"", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404595861", "createdAt": "2020-04-07T07:32:19Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDY1MDU4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzozMzoxNFrOGB2m0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzozMzoxNFrOGB2m0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NjQzMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Description(\"The Cruise Control brokerCapacity configuration.\")\n          \n          \n            \n                @Description(\"The Cruise Control `brokerCapacity` configuration.\")", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404596432", "createdAt": "2020-04-07T07:33:14Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control brokerCapacity configuration.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDY1MjM1OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzozMzo0MVrOGB2n3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzozMzo0MVrOGB2n3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NjcwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \" https://github.com/linkedin/cruise-control/wiki/Configurations Note that properties \" +\n          \n          \n            \n                        \" https://github.com/linkedin/cruise-control/wiki/Configurations. Note that properties \" +", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404596702", "createdAt": "2020-04-07T07:33:41Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control brokerCapacity configuration.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public BrokerCapacity getBrokerCapacity() {\n+        return brokerCapacity;\n+    }\n+\n+    public void setBrokerCapacity(BrokerCapacity brokerCapacity) {\n+        this.brokerCapacity = brokerCapacity;\n+    }\n+\n+    @Description(\"The Cruise Control configuration. For a full list of configuration options refer to\" +\n+            \" https://github.com/linkedin/cruise-control/wiki/Configurations Note that properties \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDY1MzY1OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzozNDowMVrOGB2opg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwODowOToyMFrOGCjxLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NjkwMg==", "bodyText": "You'll need to add the exception if they're non-empty.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404596902", "createdAt": "2020-04-07T07:34:01Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control brokerCapacity configuration.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public BrokerCapacity getBrokerCapacity() {\n+        return brokerCapacity;\n+    }\n+\n+    public void setBrokerCapacity(BrokerCapacity brokerCapacity) {\n+        this.brokerCapacity = brokerCapacity;\n+    }\n+\n+    @Description(\"The Cruise Control configuration. For a full list of configuration options refer to\" +\n+            \" https://github.com/linkedin/cruise-control/wiki/Configurations Note that properties \" +\n+            \"with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA0OTc2Mg==", "bodyText": "Not sure I understand, like add an exception if a user tries to use a configuration property that is forbidden?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405049762", "createdAt": "2020-04-07T19:12:38Z", "author": {"login": "kyguy"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control brokerCapacity configuration.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public BrokerCapacity getBrokerCapacity() {\n+        return brokerCapacity;\n+    }\n+\n+    public void setBrokerCapacity(BrokerCapacity brokerCapacity) {\n+        this.brokerCapacity = brokerCapacity;\n+    }\n+\n+    @Description(\"The Cruise Control configuration. For a full list of configuration options refer to\" +\n+            \" https://github.com/linkedin/cruise-control/wiki/Configurations Note that properties \" +\n+            \"with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NjkwMg=="}, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMzNjM2Nw==", "bodyText": "I meant that if you accept that the cipher suites and protocols are exceptions to the forbidden prefixes (as I mentioned elsewhere) you need to mention that here.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405336367", "createdAt": "2020-04-08T08:09:20Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control brokerCapacity configuration.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public BrokerCapacity getBrokerCapacity() {\n+        return brokerCapacity;\n+    }\n+\n+    public void setBrokerCapacity(BrokerCapacity brokerCapacity) {\n+        this.brokerCapacity = brokerCapacity;\n+    }\n+\n+    @Description(\"The Cruise Control configuration. For a full list of configuration options refer to\" +\n+            \" https://github.com/linkedin/cruise-control/wiki/Configurations Note that properties \" +\n+            \"with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NjkwMg=="}, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDY1NTQyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzozNDozMFrOGB2pug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQyMzo1Nzo1OVrOGDFBPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NzE3OA==", "bodyText": "Is this a log4j2 logging config or a log4j1 logging config?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404597178", "createdAt": "2020-04-07T07:34:30Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control brokerCapacity configuration.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public BrokerCapacity getBrokerCapacity() {\n+        return brokerCapacity;\n+    }\n+\n+    public void setBrokerCapacity(BrokerCapacity brokerCapacity) {\n+        this.brokerCapacity = brokerCapacity;\n+    }\n+\n+    @Description(\"The Cruise Control configuration. For a full list of configuration options refer to\" +\n+            \" https://github.com/linkedin/cruise-control/wiki/Configurations Note that properties \" +\n+            \"with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, Object> getConfig() {\n+        return config;\n+    }\n+\n+    public void setConfig(Map<String, Object> config) {\n+        this.config = config;\n+    }\n+\n+    @Description(\"Logging configuration for Cruise Control.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4MTE0OQ==", "bodyText": "It is log4j1, I have just updated this description to specify this", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405881149", "createdAt": "2020-04-08T23:57:59Z", "author": {"login": "kyguy"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, zookeeper., ssl., security., failed.brokers.zk.path,\"\n+        + \"webserver.http.port, webserver.http.address, webserver.api.urlprefix, metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, metric.reporter.topic.pattern,\"\n+        + \"partition.metric.sample.store.topic, broker.metric.sample.store.topic, brokerCapacity.config.file, skip.sample.store.topic.rack.awareness.check, cruise.control.metrics.topic\"\n+        + \"cruise.control.metrics.reporter.bootstrap.servers, sasl. interceptor.classes\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;\n+    }\n+\n+    public void setReplicas(int replicas) {\n+        this.replicas = replicas;\n+    }\n+\n+    @Description(\"The docker image for the pods.\")\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    public String getImage() {\n+        return image;\n+    }\n+\n+    public void setImage(String image) {\n+        this.image = image;\n+    }\n+\n+    @Description(\"TLS sidecar configuration\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public TlsSidecar getTlsSidecar() {\n+        return tlsSidecar;\n+    }\n+\n+    public void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    @Description(\"The Cruise Control brokerCapacity configuration.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public BrokerCapacity getBrokerCapacity() {\n+        return brokerCapacity;\n+    }\n+\n+    public void setBrokerCapacity(BrokerCapacity brokerCapacity) {\n+        this.brokerCapacity = brokerCapacity;\n+    }\n+\n+    @Description(\"The Cruise Control configuration. For a full list of configuration options refer to\" +\n+            \" https://github.com/linkedin/cruise-control/wiki/Configurations Note that properties \" +\n+            \"with the following prefixes cannot be set: \" + FORBIDDEN_PREFIXES)\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, Object> getConfig() {\n+        return config;\n+    }\n+\n+    public void setConfig(Map<String, Object> config) {\n+        this.config = config;\n+    }\n+\n+    @Description(\"Logging configuration for Cruise Control.\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NzE3OA=="}, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDY5ODY5OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/BrokerCapacity.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzo0NjoyNlrOGB3Eyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwMDowOTo0NlrOGDFQbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwNDEwNg==", "bodyText": "So the alternative to doing it like this would be to use String-typed properties and @Pattern(\"[0-9]+([KMG]i?)?B/s.\n\nIt reads nicer (outboundNetwork: 100KiB/s vs outboundNetworkKiBPerSecond: 100) and is shorter.\nIt is a little more flexible for the user to specify.\nWe could, perhaps, be relaxed about capitalisation too (cf. KiBPerSecond which will tire my pinkie pretty fast).\nIt's more consistent with how Kubernetes specifies memory usage.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404604106", "createdAt": "2020-04-07T07:46:26Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/BrokerCapacity.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"diskMiB\", \"cpuUtilization\", \"inboundNetworkKiBPerSecond\", \"outboundNetworkKiBPerSecond\"})\n+@EqualsAndHashCode\n+public class BrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer diskMiB;\n+    private Integer cpuUtilization;\n+    private Integer inboundNetworkKiBPerSecond;\n+    private Integer outboundNetworkKiBPerSecond;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Description(\"Broker capacity for disk in base 2 mebibytes.\")\n+    public Integer getDiskMiB() {\n+        return diskMiB;\n+    }\n+\n+    public void setDiskMiB(Integer diskMiB) {\n+        this.diskMiB = diskMiB;\n+    }\n+\n+    @Minimum(0)\n+    @Maximum(100)\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for CPU resource utilization as a percentage (0 - 100).\")\n+    public Integer getCpuUtilization() {\n+        return cpuUtilization;\n+    }\n+\n+    public void setCpuUtilization(Integer cpuUtilization) {\n+        this.cpuUtilization = cpuUtilization;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for network inbound throughput in base 2 kibibytes per second.\")\n+    public Integer getInboundNetworkKiBPerSecond() {\n+        return inboundNetworkKiBPerSecond;\n+    }\n+\n+    public void setInboundNetworkKiBPerSecond(Integer inboundNetworkKiBPerSecond) {\n+        this.inboundNetworkKiBPerSecond = inboundNetworkKiBPerSecond;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for network outbound throughput in base 2 kibibytes per second.\")\n+    public Integer getOutboundNetworkKiBPerSecond() {\n+        return outboundNetworkKiBPerSecond;\n+    }\n+\n+    public void setOutboundNetworkKiBPerSecond(Integer outboundNetworkKiBPerSecond) {\n+        this.outboundNetworkKiBPerSecond = outboundNetworkKiBPerSecond;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4NTAzOA==", "bodyText": "I like this idea, I changed diskMiB property back to disk again to follow this strategy as well. Now a user can specify disk values the same way as storage and memory values, using k8s format for memory, e.g. disk: 100M for 100 megabytes. This value is then parsed and converted to mebibytes for Cruise Control.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405885038", "createdAt": "2020-04-09T00:09:46Z", "author": {"login": "kyguy"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/BrokerCapacity.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"diskMiB\", \"cpuUtilization\", \"inboundNetworkKiBPerSecond\", \"outboundNetworkKiBPerSecond\"})\n+@EqualsAndHashCode\n+public class BrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer diskMiB;\n+    private Integer cpuUtilization;\n+    private Integer inboundNetworkKiBPerSecond;\n+    private Integer outboundNetworkKiBPerSecond;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Description(\"Broker capacity for disk in base 2 mebibytes.\")\n+    public Integer getDiskMiB() {\n+        return diskMiB;\n+    }\n+\n+    public void setDiskMiB(Integer diskMiB) {\n+        this.diskMiB = diskMiB;\n+    }\n+\n+    @Minimum(0)\n+    @Maximum(100)\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for CPU resource utilization as a percentage (0 - 100).\")\n+    public Integer getCpuUtilization() {\n+        return cpuUtilization;\n+    }\n+\n+    public void setCpuUtilization(Integer cpuUtilization) {\n+        this.cpuUtilization = cpuUtilization;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for network inbound throughput in base 2 kibibytes per second.\")\n+    public Integer getInboundNetworkKiBPerSecond() {\n+        return inboundNetworkKiBPerSecond;\n+    }\n+\n+    public void setInboundNetworkKiBPerSecond(Integer inboundNetworkKiBPerSecond) {\n+        this.inboundNetworkKiBPerSecond = inboundNetworkKiBPerSecond;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for network outbound throughput in base 2 kibibytes per second.\")\n+    public Integer getOutboundNetworkKiBPerSecond() {\n+        return outboundNetworkKiBPerSecond;\n+    }\n+\n+    public void setOutboundNetworkKiBPerSecond(Integer outboundNetworkKiBPerSecond) {\n+        this.outboundNetworkKiBPerSecond = outboundNetworkKiBPerSecond;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwNDEwNg=="}, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDcwODIxOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControlConfiguration.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzo0OTowOFrOGB3K0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzo0OTowOFrOGB3K0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwNTY0OA==", "bodyText": "Comment that this is 1 day, or use TimeUnit.DAYS.toMillis(1)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404605648", "createdAt": "2020-04-07T07:49:08Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControlConfiguration.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+\n+/**\n+ * Class for handling Cruise Control configuration passed by the user\n+ */\n+public class CruiseControlConfiguration extends AbstractConfiguration {\n+\n+    /**\n+     * A list of case insensitive goals that Cruise Control supports in the order of priority.\n+     * The high priority goals will be executed first.\n+     */\n+    private static final String DEFAULT_GOALS = \"com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.PotentialNwOutGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.TopicReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderBytesInDistributionGoal\";\n+\n+   /*\n+    * Map containing default values for required configuration properties\n+    */\n+    private static final Map<String, String> CC_DEFAULT_PROPERTIES_MAP;\n+\n+    private static final List<String> FORBIDDEN_OPTIONS;\n+    private static final List<String> EXCEPTIONS;\n+\n+    static {\n+        CC_DEFAULT_PROPERTIES_MAP = new HashMap<>();\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"partition.metrics.window.ms\", Integer.toString(300_000));\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"num.partition.metrics.windows\", \"1\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"broker.metrics.window.ms\", Integer.toString(300_000));\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"num.broker.metrics.windows\", \"20\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"completed.user.task.retention.time.ms\", Integer.toString(86_400_000));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDcxOTExOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzo1MjowMlrOGB3R2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzo1MjowMlrOGB3R2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwNzQ1MA==", "bodyText": "I think it's better to move this down to just before the variable is first used.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404607450", "createdAt": "2020-04-07T07:52:02Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -440,6 +448,24 @@ public static KafkaCluster fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup vers\n         }\n \n         KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+        CruiseControlSpec cruiseControlSpec  = kafkaSpec.getCruiseControl();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDcyMzkzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzo1MzoyN1rOGB3U6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxOTo0NzozMFrOGDm_LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwODIzMg==", "bodyText": "Is it legal to have whitespace in there too (between items or at each end?) org.example.Foo, com.example.Bar", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404608232", "createdAt": "2020-04-07T07:53:27Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -440,6 +448,24 @@ public static KafkaCluster fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup vers\n         }\n \n         KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+        CruiseControlSpec cruiseControlSpec  = kafkaSpec.getCruiseControl();\n+\n+        String metricReporters =  configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD);\n+        Set<String> metricReporterList = new HashSet<>();\n+        if (metricReporters != null) {\n+            addAll(metricReporterList, configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD).split(\",\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQzNzY3Ng==", "bodyText": "Yes, Kafka removes these whitespaces between and at the end of the elements when parsing the metric.reporter string", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r406437676", "createdAt": "2020-04-09T19:47:30Z", "author": {"login": "kyguy"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -440,6 +448,24 @@ public static KafkaCluster fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup vers\n         }\n \n         KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+        CruiseControlSpec cruiseControlSpec  = kafkaSpec.getCruiseControl();\n+\n+        String metricReporters =  configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD);\n+        Set<String> metricReporterList = new HashSet<>();\n+        if (metricReporters != null) {\n+            addAll(metricReporterList, configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD).split(\",\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwODIzMg=="}, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDczMjE1OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzo1NTozNlrOGB3Z6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMDoxMzo1MVrOGDn0IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwOTUxNA==", "bodyText": "So it they added CRUISE_CONTROL_METRIC_REPORTER explicitly themselves we remove it unless they also specified a CruiseControlSpec? I think this is more or less a moot point at the moment, since there's no mechanism for people to add plugin classes to our Kafka images (apart from them building their own images, which perhaps some people do). But I would none the less argue that this is not the right thing to do.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404609514", "createdAt": "2020-04-07T07:55:36Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -440,6 +448,24 @@ public static KafkaCluster fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup vers\n         }\n \n         KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+        CruiseControlSpec cruiseControlSpec  = kafkaSpec.getCruiseControl();\n+\n+        String metricReporters =  configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD);\n+        Set<String> metricReporterList = new HashSet<>();\n+        if (metricReporters != null) {\n+            addAll(metricReporterList, configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD).split(\",\"));\n+        }\n+        if (cruiseControlSpec != null) {\n+            metricReporterList.add(CRUISE_CONTROL_METRIC_REPORTER);\n+        } else {\n+            metricReporterList.remove(CRUISE_CONTROL_METRIC_REPORTER);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1MTIzMw==", "bodyText": "So it they added CRUISE_CONTROL_METRIC_REPORTER explicitly themselves we remove it unless they also specified a CruiseControlSpec?\n\nYes, but the main intention of this code is to stop the Cruise Control metric reporters after the Cruise Control application has been deleted. Otherwise, the Cruise Control metric reporters will continue to run and cost resources even if they are not being used.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r406451233", "createdAt": "2020-04-09T20:13:51Z", "author": {"login": "kyguy"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -440,6 +448,24 @@ public static KafkaCluster fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup vers\n         }\n \n         KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+        CruiseControlSpec cruiseControlSpec  = kafkaSpec.getCruiseControl();\n+\n+        String metricReporters =  configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD);\n+        Set<String> metricReporterList = new HashSet<>();\n+        if (metricReporters != null) {\n+            addAll(metricReporterList, configuration.getConfigOption(KAFKA_METRIC_REPORTERS_CONFIG_FIELD).split(\",\"));\n+        }\n+        if (cruiseControlSpec != null) {\n+            metricReporterList.add(CRUISE_CONTROL_METRIC_REPORTER);\n+        } else {\n+            metricReporterList.remove(CRUISE_CONTROL_METRIC_REPORTER);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYwOTUxNA=="}, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDczOTU5OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/StorageUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzo1Nzo0M1rOGB3erg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQyMzo1Njo0NlrOGDE_dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMDczNA==", "bodyText": "Rounding? e.g. what happens if I ask for 100MB in GB, presumably I get 0?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404610734", "createdAt": "2020-04-07T07:57:43Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/StorageUtils.java", "diffHunk": "@@ -12,6 +12,21 @@\n  * Shared methods for working with Storage - for example comparing volume sizes\n  */\n public class StorageUtils {\n+    /**\n+     * Parse a K8S-style representation of a quantity of memory, such as {@code 512Mi},\n+     * into the equivalent number of bytes in the specified units.\n+     * For example, a memory value of \"100Gb\" and a unit value of \"Mb\" will return 100000,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4MDY5NA==", "bodyText": "Yes the value will get truncated to 0.\nFor this reason and the fact that Cruise Control will cast these capacity values to doubles anyway, I have switched the return type and capacity types from Long to Double and updated this method to do floating point division.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405880694", "createdAt": "2020-04-08T23:56:46Z", "author": {"login": "kyguy"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/StorageUtils.java", "diffHunk": "@@ -12,6 +12,21 @@\n  * Shared methods for working with Storage - for example comparing volume sizes\n  */\n public class StorageUtils {\n+    /**\n+     * Parse a K8S-style representation of a quantity of memory, such as {@code 512Mi},\n+     * into the equivalent number of bytes in the specified units.\n+     * For example, a memory value of \"100Gb\" and a unit value of \"Mb\" will return 100000,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMDczNA=="}, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDc0NDMwOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/cruisecontrol/Capacity.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzo1ODo1NVrOGB3hpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMzoxMToyMVrOGITsEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMTQ5NA==", "bodyText": "So does this mean the CC doesn't really distinguish the disks as having individual sizes?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404611494", "createdAt": "2020-04-07T07:58:55Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/cruisecontrol/Capacity.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model.cruisecontrol;\n+\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+\n+import java.util.List;\n+\n+import static io.strimzi.operator.cluster.model.StorageUtils.parseMemory;\n+\n+public class Capacity {\n+    public static final long DEFAULT_BROKER_DISK_MIB_CAPACITY = 100_000;  // in MiB\n+    public static final int DEFAULT_BROKER_CPU_UTILIZATION_CAPACITY = 100;  // as a percentage (0-100)\n+    public static final int DEFAULT_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = 10_000;  // in KiB/s\n+    public static final int DEFAULT_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = 10_000;  // in KiB/s\n+\n+    private Long diskMiB;\n+    private Integer cpuUtilization;\n+    private Integer inboundNetworkKiBPerSecond;\n+    private Integer outboutNetworkKibPerSecond;\n+\n+    public Capacity(KafkaSpec spec) {\n+        BrokerCapacity bc = spec.getCruiseControl().getBrokerCapacity();\n+\n+        this.diskMiB = bc != null && bc.getDiskMiB() != null ? bc.getDiskMiB() : generateDiskCapacity(spec.getKafka().getStorage());\n+        this.cpuUtilization = bc != null && bc.getCpuUtilization() != null ? bc.getCpuUtilization() : DEFAULT_BROKER_CPU_UTILIZATION_CAPACITY;\n+        this.inboundNetworkKiBPerSecond = bc != null && bc.getInboundNetworkKiBPerSecond() != null ? bc.getInboundNetworkKiBPerSecond() : DEFAULT_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY;\n+        this.outboutNetworkKibPerSecond = bc != null && bc.getOutboundNetworkKiBPerSecond() != null ? bc.getOutboundNetworkKiBPerSecond() : DEFAULT_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY;\n+    }\n+\n+    /**\n+     * Generate diskMiB capacity configuration from the supplied storage configuration\n+     *\n+     * @param storage Storage configuration for Kafka cluster\n+     * @return Disk capacity configuration as a Long\n+     */\n+    public static Long generateDiskCapacity(Storage storage) {\n+        if (storage instanceof PersistentClaimStorage) {\n+            return getSizeInMiB(((PersistentClaimStorage) storage).getSize());\n+        } else if (storage instanceof EphemeralStorage) {\n+            if (((EphemeralStorage) storage).getSizeLimit() != null) {\n+                return getSizeInMiB(((EphemeralStorage) storage).getSizeLimit());\n+            } else {\n+                return DEFAULT_BROKER_DISK_MIB_CAPACITY;\n+            }\n+        } else if (storage instanceof JbodStorage) {\n+            List<SingleVolumeStorage> volumeList = ((JbodStorage) storage).getVolumes();\n+            long size = 0;\n+            for (SingleVolumeStorage volume : volumeList) {\n+                size += generateDiskCapacity(volume);\n+            }\n+            return size;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4NjkzMA==", "bodyText": "Cruise Control does distinguish the disks as having individual sizes using the adminClient.\nHowever, for balancing partitions between disks of the same broker, Cruise Control needs us to explicitly state the capacity of each disk here, which I have not done yet. This will require some extra logic.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405886930", "createdAt": "2020-04-09T00:16:41Z", "author": {"login": "kyguy"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/cruisecontrol/Capacity.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model.cruisecontrol;\n+\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+\n+import java.util.List;\n+\n+import static io.strimzi.operator.cluster.model.StorageUtils.parseMemory;\n+\n+public class Capacity {\n+    public static final long DEFAULT_BROKER_DISK_MIB_CAPACITY = 100_000;  // in MiB\n+    public static final int DEFAULT_BROKER_CPU_UTILIZATION_CAPACITY = 100;  // as a percentage (0-100)\n+    public static final int DEFAULT_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = 10_000;  // in KiB/s\n+    public static final int DEFAULT_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = 10_000;  // in KiB/s\n+\n+    private Long diskMiB;\n+    private Integer cpuUtilization;\n+    private Integer inboundNetworkKiBPerSecond;\n+    private Integer outboutNetworkKibPerSecond;\n+\n+    public Capacity(KafkaSpec spec) {\n+        BrokerCapacity bc = spec.getCruiseControl().getBrokerCapacity();\n+\n+        this.diskMiB = bc != null && bc.getDiskMiB() != null ? bc.getDiskMiB() : generateDiskCapacity(spec.getKafka().getStorage());\n+        this.cpuUtilization = bc != null && bc.getCpuUtilization() != null ? bc.getCpuUtilization() : DEFAULT_BROKER_CPU_UTILIZATION_CAPACITY;\n+        this.inboundNetworkKiBPerSecond = bc != null && bc.getInboundNetworkKiBPerSecond() != null ? bc.getInboundNetworkKiBPerSecond() : DEFAULT_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY;\n+        this.outboutNetworkKibPerSecond = bc != null && bc.getOutboundNetworkKiBPerSecond() != null ? bc.getOutboundNetworkKiBPerSecond() : DEFAULT_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY;\n+    }\n+\n+    /**\n+     * Generate diskMiB capacity configuration from the supplied storage configuration\n+     *\n+     * @param storage Storage configuration for Kafka cluster\n+     * @return Disk capacity configuration as a Long\n+     */\n+    public static Long generateDiskCapacity(Storage storage) {\n+        if (storage instanceof PersistentClaimStorage) {\n+            return getSizeInMiB(((PersistentClaimStorage) storage).getSize());\n+        } else if (storage instanceof EphemeralStorage) {\n+            if (((EphemeralStorage) storage).getSizeLimit() != null) {\n+                return getSizeInMiB(((EphemeralStorage) storage).getSizeLimit());\n+            } else {\n+                return DEFAULT_BROKER_DISK_MIB_CAPACITY;\n+            }\n+        } else if (storage instanceof JbodStorage) {\n+            List<SingleVolumeStorage> volumeList = ((JbodStorage) storage).getVolumes();\n+            long size = 0;\n+            for (SingleVolumeStorage volume : volumeList) {\n+                size += generateDiskCapacity(volume);\n+            }\n+            return size;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMTQ5NA=="}, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNDQwMQ==", "bodyText": "So will that extra logic be in this PR, or a future one?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411214401", "createdAt": "2020-04-20T09:04:18Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/cruisecontrol/Capacity.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model.cruisecontrol;\n+\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+\n+import java.util.List;\n+\n+import static io.strimzi.operator.cluster.model.StorageUtils.parseMemory;\n+\n+public class Capacity {\n+    public static final long DEFAULT_BROKER_DISK_MIB_CAPACITY = 100_000;  // in MiB\n+    public static final int DEFAULT_BROKER_CPU_UTILIZATION_CAPACITY = 100;  // as a percentage (0-100)\n+    public static final int DEFAULT_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = 10_000;  // in KiB/s\n+    public static final int DEFAULT_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = 10_000;  // in KiB/s\n+\n+    private Long diskMiB;\n+    private Integer cpuUtilization;\n+    private Integer inboundNetworkKiBPerSecond;\n+    private Integer outboutNetworkKibPerSecond;\n+\n+    public Capacity(KafkaSpec spec) {\n+        BrokerCapacity bc = spec.getCruiseControl().getBrokerCapacity();\n+\n+        this.diskMiB = bc != null && bc.getDiskMiB() != null ? bc.getDiskMiB() : generateDiskCapacity(spec.getKafka().getStorage());\n+        this.cpuUtilization = bc != null && bc.getCpuUtilization() != null ? bc.getCpuUtilization() : DEFAULT_BROKER_CPU_UTILIZATION_CAPACITY;\n+        this.inboundNetworkKiBPerSecond = bc != null && bc.getInboundNetworkKiBPerSecond() != null ? bc.getInboundNetworkKiBPerSecond() : DEFAULT_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY;\n+        this.outboutNetworkKibPerSecond = bc != null && bc.getOutboundNetworkKiBPerSecond() != null ? bc.getOutboundNetworkKiBPerSecond() : DEFAULT_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY;\n+    }\n+\n+    /**\n+     * Generate diskMiB capacity configuration from the supplied storage configuration\n+     *\n+     * @param storage Storage configuration for Kafka cluster\n+     * @return Disk capacity configuration as a Long\n+     */\n+    public static Long generateDiskCapacity(Storage storage) {\n+        if (storage instanceof PersistentClaimStorage) {\n+            return getSizeInMiB(((PersistentClaimStorage) storage).getSize());\n+        } else if (storage instanceof EphemeralStorage) {\n+            if (((EphemeralStorage) storage).getSizeLimit() != null) {\n+                return getSizeInMiB(((EphemeralStorage) storage).getSizeLimit());\n+            } else {\n+                return DEFAULT_BROKER_DISK_MIB_CAPACITY;\n+            }\n+        } else if (storage instanceof JbodStorage) {\n+            List<SingleVolumeStorage> volumeList = ((JbodStorage) storage).getVolumes();\n+            long size = 0;\n+            for (SingleVolumeStorage volume : volumeList) {\n+                size += generateDiskCapacity(volume);\n+            }\n+            return size;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMTQ5NA=="}, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM2NDM2OQ==", "bodyText": "A future one", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411364369", "createdAt": "2020-04-20T13:11:21Z", "author": {"login": "kyguy"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/cruisecontrol/Capacity.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model.cruisecontrol;\n+\n+import io.strimzi.api.kafka.model.KafkaSpec;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.storage.EphemeralStorage;\n+import io.strimzi.api.kafka.model.storage.JbodStorage;\n+import io.strimzi.api.kafka.model.storage.PersistentClaimStorage;\n+import io.strimzi.api.kafka.model.storage.SingleVolumeStorage;\n+import io.strimzi.api.kafka.model.storage.Storage;\n+\n+import java.util.List;\n+\n+import static io.strimzi.operator.cluster.model.StorageUtils.parseMemory;\n+\n+public class Capacity {\n+    public static final long DEFAULT_BROKER_DISK_MIB_CAPACITY = 100_000;  // in MiB\n+    public static final int DEFAULT_BROKER_CPU_UTILIZATION_CAPACITY = 100;  // as a percentage (0-100)\n+    public static final int DEFAULT_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = 10_000;  // in KiB/s\n+    public static final int DEFAULT_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = 10_000;  // in KiB/s\n+\n+    private Long diskMiB;\n+    private Integer cpuUtilization;\n+    private Integer inboundNetworkKiBPerSecond;\n+    private Integer outboutNetworkKibPerSecond;\n+\n+    public Capacity(KafkaSpec spec) {\n+        BrokerCapacity bc = spec.getCruiseControl().getBrokerCapacity();\n+\n+        this.diskMiB = bc != null && bc.getDiskMiB() != null ? bc.getDiskMiB() : generateDiskCapacity(spec.getKafka().getStorage());\n+        this.cpuUtilization = bc != null && bc.getCpuUtilization() != null ? bc.getCpuUtilization() : DEFAULT_BROKER_CPU_UTILIZATION_CAPACITY;\n+        this.inboundNetworkKiBPerSecond = bc != null && bc.getInboundNetworkKiBPerSecond() != null ? bc.getInboundNetworkKiBPerSecond() : DEFAULT_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY;\n+        this.outboutNetworkKibPerSecond = bc != null && bc.getOutboundNetworkKiBPerSecond() != null ? bc.getOutboundNetworkKiBPerSecond() : DEFAULT_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY;\n+    }\n+\n+    /**\n+     * Generate diskMiB capacity configuration from the supplied storage configuration\n+     *\n+     * @param storage Storage configuration for Kafka cluster\n+     * @return Disk capacity configuration as a Long\n+     */\n+    public static Long generateDiskCapacity(Storage storage) {\n+        if (storage instanceof PersistentClaimStorage) {\n+            return getSizeInMiB(((PersistentClaimStorage) storage).getSize());\n+        } else if (storage instanceof EphemeralStorage) {\n+            if (((EphemeralStorage) storage).getSizeLimit() != null) {\n+                return getSizeInMiB(((EphemeralStorage) storage).getSizeLimit());\n+            } else {\n+                return DEFAULT_BROKER_DISK_MIB_CAPACITY;\n+            }\n+        } else if (storage instanceof JbodStorage) {\n+            List<SingleVolumeStorage> volumeList = ((JbodStorage) storage).getVolumes();\n+            long size = 0;\n+            for (SingleVolumeStorage volume : volumeList) {\n+                size += generateDiskCapacity(volume);\n+            }\n+            return size;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMTQ5NA=="}, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDc2NzgwOnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwODowNToxNlrOGB3wZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTowNDozMFrOGIKiug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxNTI2OA==", "bodyText": "We'll need to update this for the ssl ones too.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404615268", "createdAt": "2020-04-07T08:05:16Z", "author": {"login": "tombentley"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1MTc0Nw==", "bodyText": "I am going to enable ssl configurations until I secure the communication between Cruise Control and Kafka brokers with SSL", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r406451747", "createdAt": "2020-04-09T20:14:51Z", "author": {"login": "kyguy"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxNTI2OA=="}, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNDUyMg==", "bodyText": "OK", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411214522", "createdAt": "2020-04-20T09:04:30Z", "author": {"login": "tombentley"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxNTI2OA=="}, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTkzMTI1OnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoxNzowNlrOGCDCqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoxNzowNlrOGCDCqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwMDE2OQ==", "bodyText": "FYI - this cross-reference is currently broken.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404800169", "createdAt": "2020-04-07T13:17:06Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.\n+A violation of a goal can cause a optimization to fail, preventing that optimization from being used to generate a partition rebalance proposal.\n+For example, an optimization that would cause a broker to exceed its CPU capacity would not be used for when the CpuCapacityGoal is set as a hard goal.\n+\n+Capacity limits for broker resources can be specified in the `brokerCapacity` property in `Kafka.spec.cruiseControl`.\n+Capacity limits can be set for the following broker resources in the described units:\n+\n+* `diskMiB`  - Disk storage in MiB\n+* `cpuUtilization`   - CPU utilization as a percent (0-100)\n+* `inboundNetworkKiBPerSecond`  - Network inbound throughput in KiB/s\n+* `outboundNetworkKiBPerSecond` - Newtork outbound throughput in KiB/s\n+\n+Since {ProductName} brokers are homogeneous, Cruise Control will apply the same capacity limits to every broker it is monitoring.\n+\n+.An example Cruise Control brokerCapacity configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    brokerCapacity:\n+      diskMiB: 100000\n+      cpuUtilization: 100\n+      inboundNetworkKiBPerSecond: 10000\n+      outboundNetworkKiBPerSecond: 10000\n+    # ...\n+----\n+\n+.Additional resources\n+For information, refer to the xref:type-CruiseControlBrokerCapacity-reference[Capacity schema reference].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjA2NjM2OnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/con-cruise-control-overview.adoc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzo0NzowMVrOGCEXWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzo1Mjo1OFrOGCEosQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgyMTg1MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Brokers in a Kafka cluster can become unevenly loaded due to things like an uneven distribution of busy partitions.\n          \n          \n            \n            Brokers in a Kafka cluster can become unevenly loaded for many reasons. For example, partitions that handle large amounts of message traffic can be unevenly distributed across the available brokers.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404821851", "createdAt": "2020-04-07T13:47:01Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/con-cruise-control-overview.adoc", "diffHunk": "@@ -0,0 +1,20 @@\n+// This concept is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+// Save the context of the assembly that is including this one.\n+// This is necessary for including assemblies in assemblies.\n+// See also the complementary step on the last line of this file.\n+\n+[id='con-cruise-control-overview-{context}']\n+= Cruise Control overview\n+\n+Brokers in a Kafka cluster can become unevenly loaded due to things like an uneven distribution of busy partitions.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgyNjI4OQ==", "bodyText": "Next, I would explain that partition reassignment is usually a manual task. Perhaps you could add a sentence like the following:\n\"Monitoring broker load and reassigning busy partitions to brokers with spare capacity is time consuming and adds to the overhead of managing a Kafka cluster\"", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404826289", "createdAt": "2020-04-07T13:52:58Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/con-cruise-control-overview.adoc", "diffHunk": "@@ -0,0 +1,20 @@\n+// This concept is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+// Save the context of the assembly that is including this one.\n+// This is necessary for including assemblies in assemblies.\n+// See also the complementary step on the last line of this file.\n+\n+[id='con-cruise-control-overview-{context}']\n+= Cruise Control overview\n+\n+Brokers in a Kafka cluster can become unevenly loaded due to things like an uneven distribution of busy partitions.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgyMTg1MQ=="}, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjIwMzM3OnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/con-cruise-control-overview.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDoxNjoyOFrOGCFtxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDoxNjoyOFrOGCFtxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg0Mzk3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Cruise Control is a tool for simplifying the monitoring and rebalancing of partitions across a Kafka cluster.\n          \n          \n            \n            Cruise Control is a tool for automating the monitoring and rebalancing of partitions across a Kafka cluster.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404843975", "createdAt": "2020-04-07T14:16:28Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/con-cruise-control-overview.adoc", "diffHunk": "@@ -0,0 +1,20 @@\n+// This concept is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+// Save the context of the assembly that is including this one.\n+// This is necessary for including assemblies in assemblies.\n+// See also the complementary step on the last line of this file.\n+\n+[id='con-cruise-control-overview-{context}']\n+= Cruise Control overview\n+\n+Brokers in a Kafka cluster can become unevenly loaded due to things like an uneven distribution of busy partitions.\n+Cruise Control is a tool for simplifying the monitoring and rebalancing of partitions across a Kafka cluster.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjI4MjgxOnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/con-cruise-control-overview.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDozMzoxMlrOGCGgrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDozMzoxMlrOGCGgrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1NzAwNQ==", "bodyText": "I think we should make CC the subject of this sentence and use different terminology. Please rephrase to something like the following:\nWhen deployed alongside a Kafka cluster, Cruise Control can perform the following cluster balancing tasks:\n\nMonitoring...\nMaking optimization proposals: balanced partition assignments based on configurable optimization goals.\nExecuting partition reassignments based on optimization proposals.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404857005", "createdAt": "2020-04-07T14:33:12Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/con-cruise-control-overview.adoc", "diffHunk": "@@ -0,0 +1,20 @@\n+// This concept is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+// Save the context of the assembly that is including this one.\n+// This is necessary for including assemblies in assemblies.\n+// See also the complementary step on the last line of this file.\n+\n+[id='con-cruise-control-overview-{context}']\n+= Cruise Control overview\n+\n+Brokers in a Kafka cluster can become unevenly loaded due to things like an uneven distribution of busy partitions.\n+Cruise Control is a tool for simplifying the monitoring and rebalancing of partitions across a Kafka cluster.\n+You deploy Cruise Control alongside a Kafka cluster to:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjM2NjAzOnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDo1MDoxNVrOGCHVTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDo1MDoxNVrOGCHVTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg3MDQ3OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n          \n          \n            \n            Cruise Control is configured using the `cruiseControl` property in the `Kafka` resource. Once configured, you can deploy a Cruise Control instance to your {ProductName} cluster by creating or updating the `Kafka` resource.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404870478", "createdAt": "2020-04-07T14:50:15Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjM3Mjk5OnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDo1MTo0NVrOGCHZ8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDo1MTo0NVrOGCHZ8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg3MTY2NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <1> Number of Cruise Control application instances; set to `1` to run or `0` to pause the application.\n          \n          \n            \n            <1> Number of Cruise Control instances to create. Set to `1` to run the application or `0` to pause it.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r404871664", "createdAt": "2020-04-07T14:51:45Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000\n+      networkOut: 10000\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...\n+    resources: <4>\n+      requests:\n+        cpu: 200m\n+        memory: 64Mi\n+      limits:\n+        cpu: 500m\n+        memory: 128Mi\n+    logging: debug <5>\n+    template: <6>\n+      pod:\n+        metadata:\n+          labels:\n+            label1: value1\n+        securityContext:\n+          runAsUser: 1000001\n+          fsGroup: 0\n+        terminationGracePeriodSeconds: 120\n+    readinessProbe: <7>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+    livenessProbe: <8>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+# ...\n+----\n+<1> Number of Cruise Control application instances; set to `1` to run or `0` to pause the application.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjk4NTAzOnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNToxMzoxMVrOGCz7Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNToxMzoxMVrOGCz7Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYwMTA2Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n          \n          \n            \n            For an overview of the `Kafka` resource, see the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration].", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405601063", "createdAt": "2020-04-08T15:13:11Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjk4NzM2OnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNToxMzozOVrOGCz8fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNToxMzozOVrOGCz8fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYwMTQwNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n          \n          \n            \n            You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster. Deploy one instance of Cruise Control per Kafka cluster.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405601404", "createdAt": "2020-04-08T15:13:39Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzAyOTg4OnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNToyMjozOFrOGC0Wyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNToyMjozOFrOGC0Wyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYwODEzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <2> Specifies the Cruise Control capacity configuration. For more information, see xref:capacity_configuration[capacity configuration].\n          \n          \n            \n            <2> Specifies capacity limits for broker resources. For more information, see xref:capacity_configuration[Capacity configuration].", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405608138", "createdAt": "2020-04-08T15:22:38Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000\n+      networkOut: 10000\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...\n+    resources: <4>\n+      requests:\n+        cpu: 200m\n+        memory: 64Mi\n+      limits:\n+        cpu: 500m\n+        memory: 128Mi\n+    logging: debug <5>\n+    template: <6>\n+      pod:\n+        metadata:\n+          labels:\n+            label1: value1\n+        securityContext:\n+          runAsUser: 1000001\n+          fsGroup: 0\n+        terminationGracePeriodSeconds: 120\n+    readinessProbe: <7>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+    livenessProbe: <8>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+# ...\n+----\n+<1> Number of Cruise Control application instances; set to `1` to run or `0` to pause the application.\n+<2> Specifies the Cruise Control capacity configuration. For more information, see xref:capacity_configuration[capacity configuration].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzAzODgyOnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNToyNDoyOVrOGC0cag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNToyNDoyOVrOGC0cag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYwOTU3OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <3> Specifies the Cruise Control configuration. You can provide any xref:ref-cruise-control-configuration-{context}[standard configuration option] apart from those managed directly by {ProductName}.\n          \n          \n            \n            <3> Defines the Cruise Control configuration, including default and enabled optimization goals. You can provide any xref:ref-cruise-control-configuration-{context}[standard configuration option] apart from those managed directly by {ProductName}.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405609578", "createdAt": "2020-04-08T15:24:29Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000\n+      networkOut: 10000\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...\n+    resources: <4>\n+      requests:\n+        cpu: 200m\n+        memory: 64Mi\n+      limits:\n+        cpu: 500m\n+        memory: 128Mi\n+    logging: debug <5>\n+    template: <6>\n+      pod:\n+        metadata:\n+          labels:\n+            label1: value1\n+        securityContext:\n+          runAsUser: 1000001\n+          fsGroup: 0\n+        terminationGracePeriodSeconds: 120\n+    readinessProbe: <7>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+    livenessProbe: <8>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+# ...\n+----\n+<1> Number of Cruise Control application instances; set to `1` to run or `0` to pause the application.\n+<2> Specifies the Cruise Control capacity configuration. For more information, see xref:capacity_configuration[capacity configuration].\n+<3> Specifies the Cruise Control configuration. You can provide any xref:ref-cruise-control-configuration-{context}[standard configuration option] apart from those managed directly by {ProductName}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzA0OTkwOnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNToyNjo1NFrOGC0jUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTozNjoxMVrOGIao9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYxMTM0Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <5> Logging configuration, to log messages with a given severity (debug, info, warn, error, fatal) or above.\n          \n          \n            \n            <5>Defines the logging configuration. Messages are logged with a severity level of `debug`, `info`, `warn`, `error`, or `fatal`.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405611347", "createdAt": "2020-04-08T15:26:54Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000\n+      networkOut: 10000\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...\n+    resources: <4>\n+      requests:\n+        cpu: 200m\n+        memory: 64Mi\n+      limits:\n+        cpu: 500m\n+        memory: 128Mi\n+    logging: debug <5>\n+    template: <6>\n+      pod:\n+        metadata:\n+          labels:\n+            label1: value1\n+        securityContext:\n+          runAsUser: 1000001\n+          fsGroup: 0\n+        terminationGracePeriodSeconds: 120\n+    readinessProbe: <7>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+    livenessProbe: <8>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+# ...\n+----\n+<1> Number of Cruise Control application instances; set to `1` to run or `0` to pause the application.\n+<2> Specifies the Cruise Control capacity configuration. For more information, see xref:capacity_configuration[capacity configuration].\n+<3> Specifies the Cruise Control configuration. You can provide any xref:ref-cruise-control-configuration-{context}[standard configuration option] apart from those managed directly by {ProductName}.\n+<4> CPU and memory resources reserved for Cruise Control. For more information, see xref:assembly-resource-limits-and-requests-deployment-configuration-kafka[].\n+<5> Logging configuration, to log messages with a given severity (debug, info, warn, error, fatal) or above.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ5Nzk2OQ==", "bodyText": "I incorrectly  defined the logging configuration here, I have just updated the docs with the correct configuration. Take a look and let me know what you think!", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r406497969", "createdAt": "2020-04-09T21:50:37Z", "author": {"login": "kyguy"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000\n+      networkOut: 10000\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...\n+    resources: <4>\n+      requests:\n+        cpu: 200m\n+        memory: 64Mi\n+      limits:\n+        cpu: 500m\n+        memory: 128Mi\n+    logging: debug <5>\n+    template: <6>\n+      pod:\n+        metadata:\n+          labels:\n+            label1: value1\n+        securityContext:\n+          runAsUser: 1000001\n+          fsGroup: 0\n+        terminationGracePeriodSeconds: 120\n+    readinessProbe: <7>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+    livenessProbe: <8>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+# ...\n+----\n+<1> Number of Cruise Control application instances; set to `1` to run or `0` to pause the application.\n+<2> Specifies the Cruise Control capacity configuration. For more information, see xref:capacity_configuration[capacity configuration].\n+<3> Specifies the Cruise Control configuration. You can provide any xref:ref-cruise-control-configuration-{context}[standard configuration option] apart from those managed directly by {ProductName}.\n+<4> CPU and memory resources reserved for Cruise Control. For more information, see xref:assembly-resource-limits-and-requests-deployment-configuration-kafka[].\n+<5> Logging configuration, to log messages with a given severity (debug, info, warn, error, fatal) or above.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYxMTM0Nw=="}, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ3ODI2MA==", "bodyText": "New version looks good.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411478260", "createdAt": "2020-04-20T15:36:11Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000\n+      networkOut: 10000\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...\n+    resources: <4>\n+      requests:\n+        cpu: 200m\n+        memory: 64Mi\n+      limits:\n+        cpu: 500m\n+        memory: 128Mi\n+    logging: debug <5>\n+    template: <6>\n+      pod:\n+        metadata:\n+          labels:\n+            label1: value1\n+        securityContext:\n+          runAsUser: 1000001\n+          fsGroup: 0\n+        terminationGracePeriodSeconds: 120\n+    readinessProbe: <7>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+    livenessProbe: <8>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+# ...\n+----\n+<1> Number of Cruise Control application instances; set to `1` to run or `0` to pause the application.\n+<2> Specifies the Cruise Control capacity configuration. For more information, see xref:capacity_configuration[capacity configuration].\n+<3> Specifies the Cruise Control configuration. You can provide any xref:ref-cruise-control-configuration-{context}[standard configuration option] apart from those managed directly by {ProductName}.\n+<4> CPU and memory resources reserved for Cruise Control. For more information, see xref:assembly-resource-limits-and-requests-deployment-configuration-kafka[].\n+<5> Logging configuration, to log messages with a given severity (debug, info, warn, error, fatal) or above.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYxMTM0Nw=="}, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzA1NjU5OnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNToyODoxMlrOGC0naA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNToyODoxMlrOGC0naA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYxMjM5Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            . Verify the Cruise Control deployment:\n          \n          \n            \n            . Verify that Cruise Control was successfully deployed:", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405612392", "createdAt": "2020-04-08T15:28:12Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,101 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Deploy Cruise Control to your {ProductName} cluster through the `cruiseControl` property in the `Kafka` resource.\n+\n+Refer to the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration] for an overview of the `Kafka` resource and its properties.\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000\n+      networkOut: 10000\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...\n+    resources: <4>\n+      requests:\n+        cpu: 200m\n+        memory: 64Mi\n+      limits:\n+        cpu: 500m\n+        memory: 128Mi\n+    logging: debug <5>\n+    template: <6>\n+      pod:\n+        metadata:\n+          labels:\n+            label1: value1\n+        securityContext:\n+          runAsUser: 1000001\n+          fsGroup: 0\n+        terminationGracePeriodSeconds: 120\n+    readinessProbe: <7>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+    livenessProbe: <8>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+# ...\n+----\n+<1> Number of Cruise Control application instances; set to `1` to run or `0` to pause the application.\n+<2> Specifies the Cruise Control capacity configuration. For more information, see xref:capacity_configuration[capacity configuration].\n+<3> Specifies the Cruise Control configuration. You can provide any xref:ref-cruise-control-configuration-{context}[standard configuration option] apart from those managed directly by {ProductName}.\n+<4> CPU and memory resources reserved for Cruise Control. For more information, see xref:assembly-resource-limits-and-requests-deployment-configuration-kafka[].\n+<5> Logging configuration, to log messages with a given severity (debug, info, warn, error, fatal) or above.\n+<6> xref:assembly-customizing-deployments-str[Customization of deployment templates and pods].\n+<7> xref:assembly-healthchecks-deployment-configuration-kafka[Healthcheck readiness probes].\n+<8> xref:assembly-healthchecks-deployment-configuration-kafka[Healthcheck liveness probes].\n+\n+. Create or update the resource:\n++\n+[source,shell,subs=\"+quotes\"]\n+----\n+kubectl apply -f _kafka.yaml_\n+----\n+\n+. Verify the Cruise Control deployment:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzA2NzMzOnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNTozMDoyNlrOGC0uJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNTozMDoyNlrOGC0uJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYxNDExNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.\n          \n          \n            \n            Cruise Control uses _capacity limits_ to determine if optimization goals for broker resources are being broken.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405614117", "createdAt": "2020-04-08T15:30:26Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzExMzI5OnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNTo0MDoxNVrOGC1KZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNTo0MDoxNVrOGC1KZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyMTM1MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            A violation of a goal can cause a optimization to fail, preventing that optimization from being used to generate a partition rebalance proposal.\n          \n          \n            \n            An optimization will fail if a goal is broken, preventing the optimization from being used to generate an optimization proposal for balanced partition assignments.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405621351", "createdAt": "2020-04-08T15:40:15Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.\n+A violation of a goal can cause a optimization to fail, preventing that optimization from being used to generate a partition rebalance proposal.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzExNjYyOnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNTo0MTowMlrOGC1Mgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNTo0MTowMlrOGC1Mgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyMTg5MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For example, an optimization that would cause a broker to exceed its CPU capacity would not be used for when the CpuCapacityGoal is set as a hard goal.\n          \n          \n            \n            For example, an optimization that would cause a broker to exceed its CPU capacity would not be used if the `CpuCapacityGoal` is set as a hard goal.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405621890", "createdAt": "2020-04-08T15:41:02Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.\n+A violation of a goal can cause a optimization to fail, preventing that optimization from being used to generate a partition rebalance proposal.\n+For example, an optimization that would cause a broker to exceed its CPU capacity would not be used for when the CpuCapacityGoal is set as a hard goal.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzEyMzM0OnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNTo0MjozN1rOGC1Q2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNTo0MjozN1rOGC1Q2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyMzAwMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Capacity limits for broker resources can be specified in the `brokerCapacity` property in `Kafka.spec.cruiseControl`.\n          \n          \n            \n            You specify capacity limits for broker resources in the `brokerCapacity` property in `Kafka.spec.cruiseControl` .", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405623001", "createdAt": "2020-04-08T15:42:37Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.\n+A violation of a goal can cause a optimization to fail, preventing that optimization from being used to generate a partition rebalance proposal.\n+For example, an optimization that would cause a broker to exceed its CPU capacity would not be used for when the CpuCapacityGoal is set as a hard goal.\n+\n+Capacity limits for broker resources can be specified in the `brokerCapacity` property in `Kafka.spec.cruiseControl`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzEzMzk5OnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNTo0NTowNFrOGC1Xxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNTo0NTowNFrOGC1Xxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyNDc3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * `outboundNetworkKiBPerSecond` - Newtork outbound throughput in KiB/s\n          \n          \n            \n            * `outboundNetworkKiBPerSecond` - Network outbound throughput in KiB/s", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405624775", "createdAt": "2020-04-08T15:45:04Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.\n+A violation of a goal can cause a optimization to fail, preventing that optimization from being used to generate a partition rebalance proposal.\n+For example, an optimization that would cause a broker to exceed its CPU capacity would not be used for when the CpuCapacityGoal is set as a hard goal.\n+\n+Capacity limits for broker resources can be specified in the `brokerCapacity` property in `Kafka.spec.cruiseControl`.\n+Capacity limits can be set for the following broker resources in the described units:\n+\n+* `diskMiB`  - Disk storage in MiB\n+* `cpuUtilization`   - CPU utilization as a percent (0-100)\n+* `inboundNetworkKiBPerSecond`  - Network inbound throughput in KiB/s\n+* `outboundNetworkKiBPerSecond` - Newtork outbound throughput in KiB/s", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzEzNzk4OnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNTo0NjowOFrOGC1adw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMTo0NTo1OVrOGDqixg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyNTQ2Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Since {ProductName} brokers are homogeneous, Cruise Control will apply the same capacity limits to every broker it is monitoring.\n          \n          \n            \n            Because Kafka brokers are homogeneous, Cruise Control applies the same capacity limits to every broker it is monitoring.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405625463", "createdAt": "2020-04-08T15:46:08Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.\n+A violation of a goal can cause a optimization to fail, preventing that optimization from being used to generate a partition rebalance proposal.\n+For example, an optimization that would cause a broker to exceed its CPU capacity would not be used for when the CpuCapacityGoal is set as a hard goal.\n+\n+Capacity limits for broker resources can be specified in the `brokerCapacity` property in `Kafka.spec.cruiseControl`.\n+Capacity limits can be set for the following broker resources in the described units:\n+\n+* `diskMiB`  - Disk storage in MiB\n+* `cpuUtilization`   - CPU utilization as a percent (0-100)\n+* `inboundNetworkKiBPerSecond`  - Network inbound throughput in KiB/s\n+* `outboundNetworkKiBPerSecond` - Newtork outbound throughput in KiB/s\n+\n+Since {ProductName} brokers are homogeneous, Cruise Control will apply the same capacity limits to every broker it is monitoring.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ5NTk0Mg==", "bodyText": "Updated to {ProductName} Kafka brokers since Kafka brokers are not necessarily homogeneous but Kafka brokers managed by Strimzi are homogeneous", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r406495942", "createdAt": "2020-04-09T21:45:59Z", "author": {"login": "kyguy"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.\n+A violation of a goal can cause a optimization to fail, preventing that optimization from being used to generate a partition rebalance proposal.\n+For example, an optimization that would cause a broker to exceed its CPU capacity would not be used for when the CpuCapacityGoal is set as a hard goal.\n+\n+Capacity limits for broker resources can be specified in the `brokerCapacity` property in `Kafka.spec.cruiseControl`.\n+Capacity limits can be set for the following broker resources in the described units:\n+\n+* `diskMiB`  - Disk storage in MiB\n+* `cpuUtilization`   - CPU utilization as a percent (0-100)\n+* `inboundNetworkKiBPerSecond`  - Network inbound throughput in KiB/s\n+* `outboundNetworkKiBPerSecond` - Newtork outbound throughput in KiB/s\n+\n+Since {ProductName} brokers are homogeneous, Cruise Control will apply the same capacity limits to every broker it is monitoring.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyNTQ2Mw=="}, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzEzOTQ3OnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNTo0NjozMVrOGC1baw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNTo0NjozMVrOGC1baw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyNTcwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For information, refer to the xref:type-CruiseControlBrokerCapacity-reference[Capacity schema reference].\n          \n          \n            \n            For more information, refer to the xref:type-CruiseControlBrokerCapacity-reference[].", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r405625707", "createdAt": "2020-04-08T15:46:31Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/ref-cruise-control-configuration.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+// Module included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='ref-cruise-control-configuration-{context}']\n+= Cruise Control configuration\n+\n+The `config` property in `Kafka.spec.cruiseControl` contains configuration options as keys with values as one of the following JSON types:\n+\n+* String\n+* Number\n+* Boolean\n+\n+NOTE: Strings that look like JSON or YAML will need to be explicitly quoted.\n+\n+You can specify and configure all the options listed in the \"Configurations\" section of the {CruiseControlConfigDocs}, apart from those managed directly by {ProductName}.\n+Specifically, you *cannot* modify configuration options with keys equal to or starting with one of the following strings:\n+\n+* `bootstrap.servers`\n+* `zookeeper.`\n+* `ssl.`\n+* `security.`\n+* `failed.brokers.zk.path`\n+* `webserver.http.port`\n+* `webserver.http.address`\n+* `webserver.api.urlprefix`\n+* `metric.reporter.sampler.bootstrap.servers`\n+* `metric.reporter.topic`\n+* `metric.reporter.topic.pattern`\n+* `partition.metric.sample.store.topic`\n+* `broker.metric.sample.store.topic`\n+* `capacity.config.file`\n+* `skip.sample.store.topic.rack.awareness.check`\n+* `cruise.control.metrics.topic`\n+* `sasl.`\n+\n+If restricted options are specified, they are ignored and a warning message is printed to the Cluster Operator log file.\n+All supported options are passed to Cruise Control.\n+\n+.An example Cruise Control configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    config:\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+    # ...\n+----\n+== Capacity configuration\n+\n+Cruise Control uses capacity limits to determine if goals related to broker resources are being violated.\n+A violation of a goal can cause a optimization to fail, preventing that optimization from being used to generate a partition rebalance proposal.\n+For example, an optimization that would cause a broker to exceed its CPU capacity would not be used for when the CpuCapacityGoal is set as a hard goal.\n+\n+Capacity limits for broker resources can be specified in the `brokerCapacity` property in `Kafka.spec.cruiseControl`.\n+Capacity limits can be set for the following broker resources in the described units:\n+\n+* `diskMiB`  - Disk storage in MiB\n+* `cpuUtilization`   - CPU utilization as a percent (0-100)\n+* `inboundNetworkKiBPerSecond`  - Network inbound throughput in KiB/s\n+* `outboundNetworkKiBPerSecond` - Newtork outbound throughput in KiB/s\n+\n+Since {ProductName} brokers are homogeneous, Cruise Control will apply the same capacity limits to every broker it is monitoring.\n+\n+.An example Cruise Control brokerCapacity configuration\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    # ...\n+    brokerCapacity:\n+      diskMiB: 100000\n+      cpuUtilization: 100\n+      inboundNetworkKiBPerSecond: 10000\n+      outboundNetworkKiBPerSecond: 10000\n+    # ...\n+----\n+\n+.Additional resources\n+For information, refer to the xref:type-CruiseControlBrokerCapacity-reference[Capacity schema reference].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfeccf9243734d19d38cea31ccf2f8f9f197a04a"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDYyMDY0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/BrokerCapacity.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToxMzoxMlrOGIK4yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDoxNTo0MVrOGIl2aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyMDE3MQ==", "bodyText": "I think we should allow stuff like 1.5T and exponential notation like 2e6 (which Kube does for memory, for example).\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Pattern(\"^[0-9]+([KMGTPE]i?)?$\")\n          \n          \n            \n                @Pattern(\"^[0-9]+([.][0-9]*)?([KMGTPE]i?|e[0-9]+)?$\")\n          \n      \n    \n    \n  \n\nAnd I guess to be consistent with the network settings we should allow the B suffix in there too. It's difficult because we're trying to be consistent with Kube, but what Kube does (omitting the actual unit) doesn't really work for the network rates.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411220171", "createdAt": "2020-04-20T09:13:12Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/BrokerCapacity.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpuUtilization\", \"inboundNetwork\", \"outboundNetwork\"})\n+@EqualsAndHashCode\n+public class BrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private String disk;\n+    private Integer cpuUtilization;\n+    private String inboundNetwork;\n+    private String outboundNetwork;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Pattern(\"^[0-9]+([KMGTPE]i?)?$\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2MTkyOQ==", "bodyText": "Updated to include . and exponential notation.\nI think we should leave the B suffix out of the disk capacity values so that it is consistent with the storage values we use for Strimzi (which follow the K8s memory format). I do still think the B suffix is very important for the network rates though! What do you think?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411661929", "createdAt": "2020-04-20T20:15:41Z", "author": {"login": "kyguy"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/BrokerCapacity.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpuUtilization\", \"inboundNetwork\", \"outboundNetwork\"})\n+@EqualsAndHashCode\n+public class BrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private String disk;\n+    private Integer cpuUtilization;\n+    private String inboundNetwork;\n+    private String outboundNetwork;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Pattern(\"^[0-9]+([KMGTPE]i?)?$\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyMDE3MQ=="}, "originalCommit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDY0MjI2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/BrokerCapacity.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToxODoxN1rOGILFvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToxODoxN1rOGILFvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyMzQ4NA==", "bodyText": "Can we explicitly say that this is in bytes per second, just to avoid people mistakenly thinking it might be in bits per second? Same for the outbound.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411223484", "createdAt": "2020-04-20T09:18:17Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/balancing/BrokerCapacity.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.balancing;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Representation of the Cruise Control broker capacity settings. Since the Kafka brokers\n+ * in Strimzi are homogeneous, the capacity values for each resource will be\n+ * used for every broker.\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"disk\", \"cpuUtilization\", \"inboundNetwork\", \"outboundNetwork\"})\n+@EqualsAndHashCode\n+public class BrokerCapacity implements UnknownPropertyPreserving, Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private String disk;\n+    private Integer cpuUtilization;\n+    private String inboundNetwork;\n+    private String outboundNetwork;\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    @Pattern(\"^[0-9]+([KMGTPE]i?)?$\")\n+    @Description(\"Broker capacity for disk, for example, 100Gi.\")\n+    public String getDisk() {\n+        return disk;\n+    }\n+\n+    public void setDisk(String disk) {\n+        this.disk = disk;\n+    }\n+\n+    @Minimum(0)\n+    @Maximum(100)\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Description(\"Broker capacity for CPU resource utilization as a percentage (0 - 100).\")\n+    public Integer getCpuUtilization() {\n+        return cpuUtilization;\n+    }\n+\n+    public void setCpuUtilization(Integer cpuUtilization) {\n+        this.cpuUtilization = cpuUtilization;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @Pattern(\"[0-9]+([KMG]i?)?B/s\")\n+    @Description(\"Broker capacity for network inbound throughput, for example, 10000KB/s\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDY0NzY5OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToxOToyNVrOGILI7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToxOToyNVrOGILI7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyNDMwMA==", "bodyText": "I don't think we need these double empty lines (here and the following two).", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411224300", "createdAt": "2020-04-20T09:19:25Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,497 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC = \"cruise.control.metrics.topic\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC_VALUE = \"strimzi.cruisecontrol.metrics\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"/logging\";\n+\n+    private String zookeeperConnect;\n+\n+    // Configuration defaults\n+    protected static final int DEFAULT_REPLICAS = 1;\n+\n+    // Default probe settings (liveness and readiness) for health checks\n+    protected static final int DEFAULT_HEALTHCHECK_DELAY = 15;\n+    protected static final int DEFAULT_HEALTHCHECK_TIMEOUT = 5;\n+\n+    public static final Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder()\n+            .withInitialDelaySeconds(DEFAULT_HEALTHCHECK_DELAY)\n+            .withTimeoutSeconds(DEFAULT_HEALTHCHECK_TIMEOUT)\n+            .build();\n+\n+    private TlsSidecar tlsSidecar;\n+    private String tlsSidecarImage;\n+    private String minInsyncReplicas = \"1\";\n+    private Double brokerDiskMiBCapacity;\n+    private int brokerCpuUtilizationCapacity;\n+    private Double brokerInboundNetworkKiBPerSecondCapacity;\n+    private Double brokerOuboundNetworkKiBPerSecondCapacity;\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDY1MDE1OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToxOTo1M1rOGILKVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToxOTo1M1rOGILKVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyNDY2MA==", "bodyText": "Collections.singletonList()", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411224660", "createdAt": "2020-04-20T09:19:53Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,497 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC = \"cruise.control.metrics.topic\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC_VALUE = \"strimzi.cruisecontrol.metrics\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"/logging\";\n+\n+    private String zookeeperConnect;\n+\n+    // Configuration defaults\n+    protected static final int DEFAULT_REPLICAS = 1;\n+\n+    // Default probe settings (liveness and readiness) for health checks\n+    protected static final int DEFAULT_HEALTHCHECK_DELAY = 15;\n+    protected static final int DEFAULT_HEALTHCHECK_TIMEOUT = 5;\n+\n+    public static final Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder()\n+            .withInitialDelaySeconds(DEFAULT_HEALTHCHECK_DELAY)\n+            .withTimeoutSeconds(DEFAULT_HEALTHCHECK_TIMEOUT)\n+            .build();\n+\n+    private TlsSidecar tlsSidecar;\n+    private String tlsSidecarImage;\n+    private String minInsyncReplicas = \"1\";\n+    private Double brokerDiskMiBCapacity;\n+    private int brokerCpuUtilizationCapacity;\n+    private Double brokerInboundNetworkKiBPerSecondCapacity;\n+    private Double brokerOuboundNetworkKiBPerSecondCapacity;\n+\n+\n+    public static final String REST_API_PORT_NAME = \"rest-api\";\n+    public static final int REST_API_PORT = 9090;\n+    protected static final int DEFAULT_BOOTSTRAP_SERVERS_PORT = 9092;\n+    public static final String MIN_INSYNC_REPLICAS = \"min.insync.replicas\";\n+\n+\n+    // Cruise Control configuration keys (EnvVariables)\n+    protected static final String ENV_VAR_CRUISE_CONTROL_CONFIGURATION = \"CRUISE_CONTROL_CONFIGURATION\";\n+    protected static final String ENV_VAR_ZOOKEEPER_CONNECT = \"STRIMZI_ZOOKEEPER_CONNECT\";\n+    protected static final String ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS = \"STRIMZI_KAFKA_BOOTSTRAP_SERVERS\";\n+    protected static final String ENV_VAR_MIN_INSYNC_REPLICAS = \"MIN_INSYNC_REPLICAS\";\n+    protected static final String ENV_VAR_BROKER_DISK_MIB_CAPACITY = \"BROKER_DISK_MIB_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_CPU_UTILIZATION_CAPACITY = \"BROKER_CPU_UTILIZATION_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+\n+\n+    // Templates\n+    protected List<ContainerEnvVar> templateCruiseControlContainerEnvVars;\n+    protected List<ContainerEnvVar> templateTlsSidecarContainerEnvVars;\n+\n+    private boolean isDeployed;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param resource  Kubernetes/OpenShift resource with metadata containing the namespace and cluster name\n+     */\n+    protected CruiseControl(HasMetadata resource) {\n+        super(resource, APPLICATION_NAME);\n+        this.name = CruiseControlResources.deploymentName(cluster);\n+        this.serviceName = CruiseControlResources.serviceName(cluster);\n+        this.ancillaryConfigName = metricAndLogConfigsName(cluster);\n+        this.replicas = DEFAULT_REPLICAS;\n+        this.readinessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.readinessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.mountPath = \"/var/lib/kafka\";\n+        this.logAndMetricsConfigVolumeName = LOG_AND_METRICS_CONFIG_VOLUME_NAME;\n+        this.logAndMetricsConfigMountPath = LOG_AND_METRICS_CONFIG_VOLUME_MOUNT;\n+\n+        this.zookeeperConnect = defaultZookeeperConnect(cluster);\n+    }\n+\n+    public static String metricAndLogConfigsName(String cluster) {\n+        return CruiseControlResources.logAndMetricsConfigMapName(cluster);\n+    }\n+\n+    protected void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    protected static String defaultZookeeperConnect(String cluster) {\n+        return ZookeeperCluster.serviceName(cluster) + \":\" + EntityOperatorSpec.DEFAULT_ZOOKEEPER_PORT;\n+    }\n+\n+    protected static String defaultBootstrapServers(String cluster) {\n+        return KafkaCluster.serviceName(cluster) + \":\" + DEFAULT_BOOTSTRAP_SERVERS_PORT;\n+    }\n+\n+    public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup versions) {\n+        CruiseControl cruiseControl = null;\n+        CruiseControlSpec spec  = kafkaAssembly.getSpec().getCruiseControl();\n+\n+        if (spec != null) {\n+            cruiseControl = new CruiseControl(kafkaAssembly);\n+            cruiseControl.isDeployed = true;\n+\n+            cruiseControl.setReplicas(spec.getReplicas());\n+            String image = spec.getImage();\n+            if (image == null) {\n+                image = System.getenv().get(ClusterOperatorConfig.STRIMZI_DEFAULT_CRUISE_CONTROL_IMAGE);\n+            }\n+            cruiseControl.setImage(image);\n+\n+            TlsSidecar tlsSidecar = spec.getTlsSidecar();\n+            if (tlsSidecar == null) {\n+                tlsSidecar = new TlsSidecar();\n+            }\n+\n+            String tlsSideCarImage = tlsSidecar.getImage();\n+            if (tlsSideCarImage == null) {\n+                KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+                tlsSideCarImage = System.getenv().getOrDefault(ClusterOperatorConfig.STRIMZI_DEFAULT_TLS_SIDECAR_CRUISE_CONTROL_IMAGE, versions.kafkaImage(kafkaClusterSpec.getImage(), versions.defaultVersion().version()));\n+            }\n+\n+            tlsSidecar.setImage(tlsSideCarImage);\n+            cruiseControl.tlsSidecarImage = tlsSideCarImage;\n+            cruiseControl.setTlsSidecar(tlsSidecar);\n+\n+            cruiseControl = updateConfiguration(spec, cruiseControl);\n+\n+            KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+            KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+            if (configuration.getConfigOption(MIN_INSYNC_REPLICAS) != null) {\n+                cruiseControl.minInsyncReplicas = configuration.getConfigOption(MIN_INSYNC_REPLICAS);\n+            }\n+\n+            Capacity capacity = new Capacity(kafkaAssembly.getSpec());\n+            cruiseControl.brokerDiskMiBCapacity = capacity.getDiskMiB();\n+            cruiseControl.brokerCpuUtilizationCapacity = capacity.getCpuUtilization();\n+            cruiseControl.brokerInboundNetworkKiBPerSecondCapacity = capacity.getInboundNetworkKiBPerSecond();\n+            cruiseControl.brokerOuboundNetworkKiBPerSecondCapacity = capacity.getOutboundNetworkKiBPerSecond();\n+\n+            if (spec.getReadinessProbe() != null) {\n+                cruiseControl.setReadinessProbe(spec.getReadinessProbe());\n+            }\n+\n+            if (spec.getLivenessProbe() != null) {\n+                cruiseControl.setLivenessProbe(spec.getLivenessProbe());\n+            }\n+\n+            Logging logging = spec.getLogging();\n+            cruiseControl.setLogging(logging == null ? new InlineLogging() : logging);\n+\n+            cruiseControl.setGcLoggingEnabled(spec.getJvmOptions() == null ? DEFAULT_JVM_GC_LOGGING_ENABLED : spec.getJvmOptions().isGcLoggingEnabled());\n+            cruiseControl.setJvmOptions(spec.getJvmOptions());\n+\n+            cruiseControl.setUserAffinity(affinity(spec));\n+            cruiseControl.setResources(spec.getResources());\n+            cruiseControl.setTolerations(tolerations(spec));\n+            cruiseControl.setOwnerReference(kafkaAssembly);\n+            cruiseControl = updateTemplate(spec, cruiseControl);\n+        }\n+\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (configuration.getConfigOption(entry.getKey()) == null) {\n+                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        cruiseControl.setConfiguration(configuration);\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateTemplate(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        if (spec.getTemplate() != null) {\n+            CruiseControlTemplate template = spec.getTemplate();\n+\n+            ModelUtils.parsePodTemplate(cruiseControl, template.getPod());\n+\n+            if (template.getDeployment() != null && template.getDeployment().getMetadata() != null) {\n+                cruiseControl.templateDeploymentLabels = template.getDeployment().getMetadata().getLabels();\n+                cruiseControl.templateDeploymentAnnotations = template.getDeployment().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getApiService() != null && template.getApiService().getMetadata() != null) {\n+                cruiseControl.templateServiceLabels = template.getApiService().getMetadata().getLabels();\n+                cruiseControl.templateServiceAnnotations = template.getApiService().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getCruiseControlContainer() != null && template.getCruiseControlContainer().getEnv() != null) {\n+                cruiseControl.templateCruiseControlContainerEnvVars = template.getCruiseControlContainer().getEnv();\n+            }\n+\n+            if (template.getTlsSidecarContainer() != null && template.getTlsSidecarContainer().getEnv() != null) {\n+                cruiseControl.templateTlsSidecarContainerEnvVars = template.getTlsSidecarContainer().getEnv();\n+            }\n+\n+            ModelUtils.parsePodDisruptionBudgetTemplate(cruiseControl, template.getPodDisruptionBudget());\n+        }\n+        return cruiseControl;\n+    }\n+\n+    static List<Toleration> tolerations(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getTolerations() != null) {\n+            return spec.getTemplate().getPod().getTolerations();\n+        }\n+        return null;\n+    }\n+\n+    static Affinity affinity(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getAffinity() != null) {\n+            return spec.getTemplate().getPod().getAffinity();\n+        }\n+        return null;\n+    }\n+\n+    public static String cruiseControlName(String cluster) {\n+        return CruiseControlResources.deploymentName(cluster);\n+    }\n+\n+    public static String cruiseControlServiceName(String cluster) {\n+        return CruiseControlResources.serviceName(cluster);\n+    }\n+\n+    public Service generateService() {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        List<ServicePort> ports = new ArrayList<>(1);\n+        ports.add(createServicePort(REST_API_PORT_NAME, REST_API_PORT, REST_API_PORT, \"TCP\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f"}, "originalPosition": 294}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDY1MjQzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToyMDoyMVrOGILLqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToyMDoyMVrOGILLqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyNTAwMg==", "bodyText": "If you insist on doing it like this then get the right number of items:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<Volume> volumeList = new ArrayList<>(1);\n          \n          \n            \n                    List<Volume> volumeList = new ArrayList<>(3);\n          \n      \n    \n    \n  \n\nBut even better would be to use\nreturn Arrays.asList(createSecretVolume(...),\n                     createSecretVolume(...),\n                     createConfigMapVolume(...));", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411225002", "createdAt": "2020-04-20T09:20:21Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,497 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC = \"cruise.control.metrics.topic\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC_VALUE = \"strimzi.cruisecontrol.metrics\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"/logging\";\n+\n+    private String zookeeperConnect;\n+\n+    // Configuration defaults\n+    protected static final int DEFAULT_REPLICAS = 1;\n+\n+    // Default probe settings (liveness and readiness) for health checks\n+    protected static final int DEFAULT_HEALTHCHECK_DELAY = 15;\n+    protected static final int DEFAULT_HEALTHCHECK_TIMEOUT = 5;\n+\n+    public static final Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder()\n+            .withInitialDelaySeconds(DEFAULT_HEALTHCHECK_DELAY)\n+            .withTimeoutSeconds(DEFAULT_HEALTHCHECK_TIMEOUT)\n+            .build();\n+\n+    private TlsSidecar tlsSidecar;\n+    private String tlsSidecarImage;\n+    private String minInsyncReplicas = \"1\";\n+    private Double brokerDiskMiBCapacity;\n+    private int brokerCpuUtilizationCapacity;\n+    private Double brokerInboundNetworkKiBPerSecondCapacity;\n+    private Double brokerOuboundNetworkKiBPerSecondCapacity;\n+\n+\n+    public static final String REST_API_PORT_NAME = \"rest-api\";\n+    public static final int REST_API_PORT = 9090;\n+    protected static final int DEFAULT_BOOTSTRAP_SERVERS_PORT = 9092;\n+    public static final String MIN_INSYNC_REPLICAS = \"min.insync.replicas\";\n+\n+\n+    // Cruise Control configuration keys (EnvVariables)\n+    protected static final String ENV_VAR_CRUISE_CONTROL_CONFIGURATION = \"CRUISE_CONTROL_CONFIGURATION\";\n+    protected static final String ENV_VAR_ZOOKEEPER_CONNECT = \"STRIMZI_ZOOKEEPER_CONNECT\";\n+    protected static final String ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS = \"STRIMZI_KAFKA_BOOTSTRAP_SERVERS\";\n+    protected static final String ENV_VAR_MIN_INSYNC_REPLICAS = \"MIN_INSYNC_REPLICAS\";\n+    protected static final String ENV_VAR_BROKER_DISK_MIB_CAPACITY = \"BROKER_DISK_MIB_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_CPU_UTILIZATION_CAPACITY = \"BROKER_CPU_UTILIZATION_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+\n+\n+    // Templates\n+    protected List<ContainerEnvVar> templateCruiseControlContainerEnvVars;\n+    protected List<ContainerEnvVar> templateTlsSidecarContainerEnvVars;\n+\n+    private boolean isDeployed;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param resource  Kubernetes/OpenShift resource with metadata containing the namespace and cluster name\n+     */\n+    protected CruiseControl(HasMetadata resource) {\n+        super(resource, APPLICATION_NAME);\n+        this.name = CruiseControlResources.deploymentName(cluster);\n+        this.serviceName = CruiseControlResources.serviceName(cluster);\n+        this.ancillaryConfigName = metricAndLogConfigsName(cluster);\n+        this.replicas = DEFAULT_REPLICAS;\n+        this.readinessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.readinessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.mountPath = \"/var/lib/kafka\";\n+        this.logAndMetricsConfigVolumeName = LOG_AND_METRICS_CONFIG_VOLUME_NAME;\n+        this.logAndMetricsConfigMountPath = LOG_AND_METRICS_CONFIG_VOLUME_MOUNT;\n+\n+        this.zookeeperConnect = defaultZookeeperConnect(cluster);\n+    }\n+\n+    public static String metricAndLogConfigsName(String cluster) {\n+        return CruiseControlResources.logAndMetricsConfigMapName(cluster);\n+    }\n+\n+    protected void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    protected static String defaultZookeeperConnect(String cluster) {\n+        return ZookeeperCluster.serviceName(cluster) + \":\" + EntityOperatorSpec.DEFAULT_ZOOKEEPER_PORT;\n+    }\n+\n+    protected static String defaultBootstrapServers(String cluster) {\n+        return KafkaCluster.serviceName(cluster) + \":\" + DEFAULT_BOOTSTRAP_SERVERS_PORT;\n+    }\n+\n+    public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup versions) {\n+        CruiseControl cruiseControl = null;\n+        CruiseControlSpec spec  = kafkaAssembly.getSpec().getCruiseControl();\n+\n+        if (spec != null) {\n+            cruiseControl = new CruiseControl(kafkaAssembly);\n+            cruiseControl.isDeployed = true;\n+\n+            cruiseControl.setReplicas(spec.getReplicas());\n+            String image = spec.getImage();\n+            if (image == null) {\n+                image = System.getenv().get(ClusterOperatorConfig.STRIMZI_DEFAULT_CRUISE_CONTROL_IMAGE);\n+            }\n+            cruiseControl.setImage(image);\n+\n+            TlsSidecar tlsSidecar = spec.getTlsSidecar();\n+            if (tlsSidecar == null) {\n+                tlsSidecar = new TlsSidecar();\n+            }\n+\n+            String tlsSideCarImage = tlsSidecar.getImage();\n+            if (tlsSideCarImage == null) {\n+                KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+                tlsSideCarImage = System.getenv().getOrDefault(ClusterOperatorConfig.STRIMZI_DEFAULT_TLS_SIDECAR_CRUISE_CONTROL_IMAGE, versions.kafkaImage(kafkaClusterSpec.getImage(), versions.defaultVersion().version()));\n+            }\n+\n+            tlsSidecar.setImage(tlsSideCarImage);\n+            cruiseControl.tlsSidecarImage = tlsSideCarImage;\n+            cruiseControl.setTlsSidecar(tlsSidecar);\n+\n+            cruiseControl = updateConfiguration(spec, cruiseControl);\n+\n+            KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+            KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+            if (configuration.getConfigOption(MIN_INSYNC_REPLICAS) != null) {\n+                cruiseControl.minInsyncReplicas = configuration.getConfigOption(MIN_INSYNC_REPLICAS);\n+            }\n+\n+            Capacity capacity = new Capacity(kafkaAssembly.getSpec());\n+            cruiseControl.brokerDiskMiBCapacity = capacity.getDiskMiB();\n+            cruiseControl.brokerCpuUtilizationCapacity = capacity.getCpuUtilization();\n+            cruiseControl.brokerInboundNetworkKiBPerSecondCapacity = capacity.getInboundNetworkKiBPerSecond();\n+            cruiseControl.brokerOuboundNetworkKiBPerSecondCapacity = capacity.getOutboundNetworkKiBPerSecond();\n+\n+            if (spec.getReadinessProbe() != null) {\n+                cruiseControl.setReadinessProbe(spec.getReadinessProbe());\n+            }\n+\n+            if (spec.getLivenessProbe() != null) {\n+                cruiseControl.setLivenessProbe(spec.getLivenessProbe());\n+            }\n+\n+            Logging logging = spec.getLogging();\n+            cruiseControl.setLogging(logging == null ? new InlineLogging() : logging);\n+\n+            cruiseControl.setGcLoggingEnabled(spec.getJvmOptions() == null ? DEFAULT_JVM_GC_LOGGING_ENABLED : spec.getJvmOptions().isGcLoggingEnabled());\n+            cruiseControl.setJvmOptions(spec.getJvmOptions());\n+\n+            cruiseControl.setUserAffinity(affinity(spec));\n+            cruiseControl.setResources(spec.getResources());\n+            cruiseControl.setTolerations(tolerations(spec));\n+            cruiseControl.setOwnerReference(kafkaAssembly);\n+            cruiseControl = updateTemplate(spec, cruiseControl);\n+        }\n+\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (configuration.getConfigOption(entry.getKey()) == null) {\n+                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        cruiseControl.setConfiguration(configuration);\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateTemplate(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        if (spec.getTemplate() != null) {\n+            CruiseControlTemplate template = spec.getTemplate();\n+\n+            ModelUtils.parsePodTemplate(cruiseControl, template.getPod());\n+\n+            if (template.getDeployment() != null && template.getDeployment().getMetadata() != null) {\n+                cruiseControl.templateDeploymentLabels = template.getDeployment().getMetadata().getLabels();\n+                cruiseControl.templateDeploymentAnnotations = template.getDeployment().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getApiService() != null && template.getApiService().getMetadata() != null) {\n+                cruiseControl.templateServiceLabels = template.getApiService().getMetadata().getLabels();\n+                cruiseControl.templateServiceAnnotations = template.getApiService().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getCruiseControlContainer() != null && template.getCruiseControlContainer().getEnv() != null) {\n+                cruiseControl.templateCruiseControlContainerEnvVars = template.getCruiseControlContainer().getEnv();\n+            }\n+\n+            if (template.getTlsSidecarContainer() != null && template.getTlsSidecarContainer().getEnv() != null) {\n+                cruiseControl.templateTlsSidecarContainerEnvVars = template.getTlsSidecarContainer().getEnv();\n+            }\n+\n+            ModelUtils.parsePodDisruptionBudgetTemplate(cruiseControl, template.getPodDisruptionBudget());\n+        }\n+        return cruiseControl;\n+    }\n+\n+    static List<Toleration> tolerations(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getTolerations() != null) {\n+            return spec.getTemplate().getPod().getTolerations();\n+        }\n+        return null;\n+    }\n+\n+    static Affinity affinity(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getAffinity() != null) {\n+            return spec.getTemplate().getPod().getAffinity();\n+        }\n+        return null;\n+    }\n+\n+    public static String cruiseControlName(String cluster) {\n+        return CruiseControlResources.deploymentName(cluster);\n+    }\n+\n+    public static String cruiseControlServiceName(String cluster) {\n+        return CruiseControlResources.serviceName(cluster);\n+    }\n+\n+    public Service generateService() {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        List<ServicePort> ports = new ArrayList<>(1);\n+        ports.add(createServicePort(REST_API_PORT_NAME, REST_API_PORT, REST_API_PORT, \"TCP\"));\n+\n+        return createService(\"ClusterIP\", ports, templateServiceAnnotations);\n+    }\n+\n+    protected List<ContainerPort> getContainerPortList() {\n+        List<ContainerPort> portList = new ArrayList<>(1);\n+\n+        portList.add(createContainerPort(REST_API_PORT_NAME, REST_API_PORT, \"TCP\"));\n+\n+        if (isMetricsEnabled) {\n+            portList.add(createContainerPort(METRICS_PORT_NAME, METRICS_PORT, \"TCP\"));\n+        }\n+\n+        return portList;\n+    }\n+\n+    protected List<Volume> getVolumes(boolean isOpenShift) {\n+        List<Volume> volumeList = new ArrayList<>(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f"}, "originalPosition": 312}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDY1MzM1OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToyMDozMVrOGILMLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToyMDozMVrOGILMLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyNTEzMw==", "bodyText": "Same comment.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411225133", "createdAt": "2020-04-20T09:20:31Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,497 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC = \"cruise.control.metrics.topic\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC_VALUE = \"strimzi.cruisecontrol.metrics\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"/logging\";\n+\n+    private String zookeeperConnect;\n+\n+    // Configuration defaults\n+    protected static final int DEFAULT_REPLICAS = 1;\n+\n+    // Default probe settings (liveness and readiness) for health checks\n+    protected static final int DEFAULT_HEALTHCHECK_DELAY = 15;\n+    protected static final int DEFAULT_HEALTHCHECK_TIMEOUT = 5;\n+\n+    public static final Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder()\n+            .withInitialDelaySeconds(DEFAULT_HEALTHCHECK_DELAY)\n+            .withTimeoutSeconds(DEFAULT_HEALTHCHECK_TIMEOUT)\n+            .build();\n+\n+    private TlsSidecar tlsSidecar;\n+    private String tlsSidecarImage;\n+    private String minInsyncReplicas = \"1\";\n+    private Double brokerDiskMiBCapacity;\n+    private int brokerCpuUtilizationCapacity;\n+    private Double brokerInboundNetworkKiBPerSecondCapacity;\n+    private Double brokerOuboundNetworkKiBPerSecondCapacity;\n+\n+\n+    public static final String REST_API_PORT_NAME = \"rest-api\";\n+    public static final int REST_API_PORT = 9090;\n+    protected static final int DEFAULT_BOOTSTRAP_SERVERS_PORT = 9092;\n+    public static final String MIN_INSYNC_REPLICAS = \"min.insync.replicas\";\n+\n+\n+    // Cruise Control configuration keys (EnvVariables)\n+    protected static final String ENV_VAR_CRUISE_CONTROL_CONFIGURATION = \"CRUISE_CONTROL_CONFIGURATION\";\n+    protected static final String ENV_VAR_ZOOKEEPER_CONNECT = \"STRIMZI_ZOOKEEPER_CONNECT\";\n+    protected static final String ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS = \"STRIMZI_KAFKA_BOOTSTRAP_SERVERS\";\n+    protected static final String ENV_VAR_MIN_INSYNC_REPLICAS = \"MIN_INSYNC_REPLICAS\";\n+    protected static final String ENV_VAR_BROKER_DISK_MIB_CAPACITY = \"BROKER_DISK_MIB_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_CPU_UTILIZATION_CAPACITY = \"BROKER_CPU_UTILIZATION_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+\n+\n+    // Templates\n+    protected List<ContainerEnvVar> templateCruiseControlContainerEnvVars;\n+    protected List<ContainerEnvVar> templateTlsSidecarContainerEnvVars;\n+\n+    private boolean isDeployed;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param resource  Kubernetes/OpenShift resource with metadata containing the namespace and cluster name\n+     */\n+    protected CruiseControl(HasMetadata resource) {\n+        super(resource, APPLICATION_NAME);\n+        this.name = CruiseControlResources.deploymentName(cluster);\n+        this.serviceName = CruiseControlResources.serviceName(cluster);\n+        this.ancillaryConfigName = metricAndLogConfigsName(cluster);\n+        this.replicas = DEFAULT_REPLICAS;\n+        this.readinessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.readinessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.mountPath = \"/var/lib/kafka\";\n+        this.logAndMetricsConfigVolumeName = LOG_AND_METRICS_CONFIG_VOLUME_NAME;\n+        this.logAndMetricsConfigMountPath = LOG_AND_METRICS_CONFIG_VOLUME_MOUNT;\n+\n+        this.zookeeperConnect = defaultZookeeperConnect(cluster);\n+    }\n+\n+    public static String metricAndLogConfigsName(String cluster) {\n+        return CruiseControlResources.logAndMetricsConfigMapName(cluster);\n+    }\n+\n+    protected void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    protected static String defaultZookeeperConnect(String cluster) {\n+        return ZookeeperCluster.serviceName(cluster) + \":\" + EntityOperatorSpec.DEFAULT_ZOOKEEPER_PORT;\n+    }\n+\n+    protected static String defaultBootstrapServers(String cluster) {\n+        return KafkaCluster.serviceName(cluster) + \":\" + DEFAULT_BOOTSTRAP_SERVERS_PORT;\n+    }\n+\n+    public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup versions) {\n+        CruiseControl cruiseControl = null;\n+        CruiseControlSpec spec  = kafkaAssembly.getSpec().getCruiseControl();\n+\n+        if (spec != null) {\n+            cruiseControl = new CruiseControl(kafkaAssembly);\n+            cruiseControl.isDeployed = true;\n+\n+            cruiseControl.setReplicas(spec.getReplicas());\n+            String image = spec.getImage();\n+            if (image == null) {\n+                image = System.getenv().get(ClusterOperatorConfig.STRIMZI_DEFAULT_CRUISE_CONTROL_IMAGE);\n+            }\n+            cruiseControl.setImage(image);\n+\n+            TlsSidecar tlsSidecar = spec.getTlsSidecar();\n+            if (tlsSidecar == null) {\n+                tlsSidecar = new TlsSidecar();\n+            }\n+\n+            String tlsSideCarImage = tlsSidecar.getImage();\n+            if (tlsSideCarImage == null) {\n+                KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+                tlsSideCarImage = System.getenv().getOrDefault(ClusterOperatorConfig.STRIMZI_DEFAULT_TLS_SIDECAR_CRUISE_CONTROL_IMAGE, versions.kafkaImage(kafkaClusterSpec.getImage(), versions.defaultVersion().version()));\n+            }\n+\n+            tlsSidecar.setImage(tlsSideCarImage);\n+            cruiseControl.tlsSidecarImage = tlsSideCarImage;\n+            cruiseControl.setTlsSidecar(tlsSidecar);\n+\n+            cruiseControl = updateConfiguration(spec, cruiseControl);\n+\n+            KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+            KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+            if (configuration.getConfigOption(MIN_INSYNC_REPLICAS) != null) {\n+                cruiseControl.minInsyncReplicas = configuration.getConfigOption(MIN_INSYNC_REPLICAS);\n+            }\n+\n+            Capacity capacity = new Capacity(kafkaAssembly.getSpec());\n+            cruiseControl.brokerDiskMiBCapacity = capacity.getDiskMiB();\n+            cruiseControl.brokerCpuUtilizationCapacity = capacity.getCpuUtilization();\n+            cruiseControl.brokerInboundNetworkKiBPerSecondCapacity = capacity.getInboundNetworkKiBPerSecond();\n+            cruiseControl.brokerOuboundNetworkKiBPerSecondCapacity = capacity.getOutboundNetworkKiBPerSecond();\n+\n+            if (spec.getReadinessProbe() != null) {\n+                cruiseControl.setReadinessProbe(spec.getReadinessProbe());\n+            }\n+\n+            if (spec.getLivenessProbe() != null) {\n+                cruiseControl.setLivenessProbe(spec.getLivenessProbe());\n+            }\n+\n+            Logging logging = spec.getLogging();\n+            cruiseControl.setLogging(logging == null ? new InlineLogging() : logging);\n+\n+            cruiseControl.setGcLoggingEnabled(spec.getJvmOptions() == null ? DEFAULT_JVM_GC_LOGGING_ENABLED : spec.getJvmOptions().isGcLoggingEnabled());\n+            cruiseControl.setJvmOptions(spec.getJvmOptions());\n+\n+            cruiseControl.setUserAffinity(affinity(spec));\n+            cruiseControl.setResources(spec.getResources());\n+            cruiseControl.setTolerations(tolerations(spec));\n+            cruiseControl.setOwnerReference(kafkaAssembly);\n+            cruiseControl = updateTemplate(spec, cruiseControl);\n+        }\n+\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (configuration.getConfigOption(entry.getKey()) == null) {\n+                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        cruiseControl.setConfiguration(configuration);\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateTemplate(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        if (spec.getTemplate() != null) {\n+            CruiseControlTemplate template = spec.getTemplate();\n+\n+            ModelUtils.parsePodTemplate(cruiseControl, template.getPod());\n+\n+            if (template.getDeployment() != null && template.getDeployment().getMetadata() != null) {\n+                cruiseControl.templateDeploymentLabels = template.getDeployment().getMetadata().getLabels();\n+                cruiseControl.templateDeploymentAnnotations = template.getDeployment().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getApiService() != null && template.getApiService().getMetadata() != null) {\n+                cruiseControl.templateServiceLabels = template.getApiService().getMetadata().getLabels();\n+                cruiseControl.templateServiceAnnotations = template.getApiService().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getCruiseControlContainer() != null && template.getCruiseControlContainer().getEnv() != null) {\n+                cruiseControl.templateCruiseControlContainerEnvVars = template.getCruiseControlContainer().getEnv();\n+            }\n+\n+            if (template.getTlsSidecarContainer() != null && template.getTlsSidecarContainer().getEnv() != null) {\n+                cruiseControl.templateTlsSidecarContainerEnvVars = template.getTlsSidecarContainer().getEnv();\n+            }\n+\n+            ModelUtils.parsePodDisruptionBudgetTemplate(cruiseControl, template.getPodDisruptionBudget());\n+        }\n+        return cruiseControl;\n+    }\n+\n+    static List<Toleration> tolerations(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getTolerations() != null) {\n+            return spec.getTemplate().getPod().getTolerations();\n+        }\n+        return null;\n+    }\n+\n+    static Affinity affinity(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getAffinity() != null) {\n+            return spec.getTemplate().getPod().getAffinity();\n+        }\n+        return null;\n+    }\n+\n+    public static String cruiseControlName(String cluster) {\n+        return CruiseControlResources.deploymentName(cluster);\n+    }\n+\n+    public static String cruiseControlServiceName(String cluster) {\n+        return CruiseControlResources.serviceName(cluster);\n+    }\n+\n+    public Service generateService() {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        List<ServicePort> ports = new ArrayList<>(1);\n+        ports.add(createServicePort(REST_API_PORT_NAME, REST_API_PORT, REST_API_PORT, \"TCP\"));\n+\n+        return createService(\"ClusterIP\", ports, templateServiceAnnotations);\n+    }\n+\n+    protected List<ContainerPort> getContainerPortList() {\n+        List<ContainerPort> portList = new ArrayList<>(1);\n+\n+        portList.add(createContainerPort(REST_API_PORT_NAME, REST_API_PORT, \"TCP\"));\n+\n+        if (isMetricsEnabled) {\n+            portList.add(createContainerPort(METRICS_PORT_NAME, METRICS_PORT, \"TCP\"));\n+        }\n+\n+        return portList;\n+    }\n+\n+    protected List<Volume> getVolumes(boolean isOpenShift) {\n+        List<Volume> volumeList = new ArrayList<>(1);\n+        volumeList.add(createSecretVolume(TLS_SIDECAR_CC_CERTS_VOLUME_NAME, CruiseControl.secretName(cluster), isOpenShift));\n+        volumeList.add(createSecretVolume(TLS_SIDECAR_CA_CERTS_VOLUME_NAME, AbstractModel.clusterCaCertSecretName(cluster), isOpenShift));\n+        volumeList.add(createConfigMapVolume(logAndMetricsConfigVolumeName, ancillaryConfigName));\n+\n+        return volumeList;\n+    }\n+\n+    protected List<VolumeMount> getVolumeMounts() {\n+        List<VolumeMount> volumeMountList = new ArrayList<>(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f"}, "originalPosition": 321}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDY3MzE3OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControlConfiguration.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToyNDo1MVrOGILXlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToyNDo1MVrOGILXlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyODA1NQ==", "bodyText": "Using \", *\" (split takes a regex) would protect you a little from people being careless with whitespace when making changes in the future.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411228055", "createdAt": "2020-04-20T09:24:51Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControlConfiguration.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+\n+/**\n+ * Class for handling Cruise Control configuration passed by the user\n+ */\n+public class CruiseControlConfiguration extends AbstractConfiguration {\n+\n+    /**\n+     * A list of case insensitive goals that Cruise Control supports in the order of priority.\n+     * The high priority goals will be executed first.\n+     */\n+    private static final String DEFAULT_GOALS = \"com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuCapacityGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.PotentialNwOutGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.DiskUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkInboundUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.NetworkOutboundUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.CpuUsageDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.TopicReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderReplicaDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.LeaderBytesInDistributionGoal,\" +\n+        \"com.linkedin.kafka.cruisecontrol.analyzer.goals.PreferredLeaderElectionGoal\";\n+\n+   /*\n+    * Map containing default values for required configuration properties\n+    */\n+    private static final Map<String, String> CC_DEFAULT_PROPERTIES_MAP;\n+\n+    private static final List<String> FORBIDDEN_OPTIONS;\n+    private static final List<String> EXCEPTIONS;\n+\n+    static {\n+        CC_DEFAULT_PROPERTIES_MAP = new HashMap<>();\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"partition.metrics.window.ms\", Integer.toString(300_000));\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"num.partition.metrics.windows\", \"1\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"broker.metrics.window.ms\", Integer.toString(300_000));\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"num.broker.metrics.windows\", \"20\");\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"completed.user.task.retention.time.ms\", Long.toString(TimeUnit.DAYS.toMillis(1)));\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"default.goals\", DEFAULT_GOALS);\n+        CC_DEFAULT_PROPERTIES_MAP.put(\"goals\", DEFAULT_GOALS);\n+\n+        FORBIDDEN_OPTIONS = asList(CruiseControlSpec.FORBIDDEN_PREFIXES.split(\", \"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDY4NTc4OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToyNzozNlrOGILe4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOToyNzozNlrOGILe4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyOTkyMA==", "bodyText": "Collections.singletonMap()", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411229920", "createdAt": "2020-04-20T09:27:36Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3068,6 +3083,86 @@ private boolean isPodUpToDate(StatefulSet sts, Pod pod) {\n             return stsGeneration == podGeneration;\n         }\n \n+        private final Future<ReconciliationState> getCruiseControlDescription() {\n+            CruiseControl cruiseControl = CruiseControl.fromCrd(kafkaAssembly, versions);\n+            if (cruiseControl != null) {\n+                ConfigMap logAndMetricsConfigMap = cruiseControl.generateMetricsAndLogConfigMap(\n+                        cruiseControl.getLogging() instanceof ExternalLogging ?\n+                                configMapOperations.get(kafkaAssembly.getMetadata().getNamespace(), ((ExternalLogging) cruiseControl.getLogging()).getName()) :\n+                                null);\n+                Map<String, String> annotations = new HashMap<>();\n+                annotations.put(CruiseControl.ANNO_STRIMZI_IO_LOGGING, logAndMetricsConfigMap.getData().get(ANCILLARY_CM_KEY_LOG_CONFIG));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf09d6839f9a6c9f66e4dfc8aa03bf7a03a56d8f"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1OTE5MTUwOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaClusterSpec.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNjoxNToxM1rOGI0Ttw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNjoxNToxM1rOGI0Ttw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg5ODgwNw==", "bodyText": "we are in the KafkaClusterSpec, why this is about Cruise Control container resources?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411898807", "createdAt": "2020-04-21T06:15:13Z", "author": {"login": "ppatierno"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaClusterSpec.java", "diffHunk": "@@ -172,7 +174,7 @@ public void setImage(String image) {\n     }\n \n     @JsonInclude(JsonInclude.Include.NON_NULL)\n-    @Description(\"CPU and memory resources to reserve.\")\n+    @Description(\"CPU and memory resources to reserve for the Cruise Control container.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f5eb115c5dcef25a514a32c69408f00772a994f"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1OTIwNDAzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNjoxOTowMlrOGI0atA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNjoxOTowMlrOGI0atA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwMDU5Ng==", "bodyText": "Have you rebased against the latest master? Just asking because lately the Annotations.STRIMZI_DOMAIN was changed from strimzi.io to strimzi.io/. In this case, we are going to have strimzi.io//logging so you should remove the / from logging. I had the same problem with one of my latest PR :-)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r411900596", "createdAt": "2020-04-21T06:19:02Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,486 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC = \"cruise.control.metrics.topic\";\n+    public static final String CRUISE_CONTROL_METRICS_TOPIC_VALUE = \"strimzi.cruisecontrol.metrics\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"/logging\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f5eb115c5dcef25a514a32c69408f00772a994f"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjgwMjMyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOTo1MTowM1rOGJVtKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMzoyNjowOVrOGKP79A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0NTk5Mw==", "bodyText": "Do we really need this? In other places we have 1 replica hardcoded.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r412445993", "createdAt": "2020-04-21T19:51:03Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, client.id, zookeeper., network., security., failed.brokers.zk.path,\"\n+        + \"webserver.http., webserver.api.urlprefix, webserver.session.path, webserver.accesslog., two.step., request.reason.required,\"\n+        + \"metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, partition.metric.sample.store.topic, broker.metric.sample.store.topic,\"\n+        + \"capacity.config.file, self.healing.\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5NjE1MA==", "bodyText": "This allows scaling the CC pod to 0 to pause the CC application without removing the CC metric reporters from the Kafka brokers. This will stop CC from processing the raw metrics and sending them to Kafka. However, the CC metric reporters will continue to push raw metrics to Kafka when the CC application is paused.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413096150", "createdAt": "2020-04-22T15:43:43Z", "author": {"login": "kyguy"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, client.id, zookeeper., network., security., failed.brokers.zk.path,\"\n+        + \"webserver.http., webserver.api.urlprefix, webserver.session.path, webserver.accesslog., two.step., request.reason.required,\"\n+        + \"metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, partition.metric.sample.store.topic, broker.metric.sample.store.topic,\"\n+        + \"capacity.config.file, self.healing.\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0NTk5Mw=="}, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5NzIxMw==", "bodyText": "Does that sound reasonable? If not, we can revert it back to it being hardcoded", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413097213", "createdAt": "2020-04-22T15:44:59Z", "author": {"login": "kyguy"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, client.id, zookeeper., network., security., failed.brokers.zk.path,\"\n+        + \"webserver.http., webserver.api.urlprefix, webserver.session.path, webserver.accesslog., two.step., request.reason.required,\"\n+        + \"metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, partition.metric.sample.store.topic, broker.metric.sample.store.topic,\"\n+        + \"capacity.config.file, self.healing.\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0NTk5Mw=="}, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwMDA1Mg==", "bodyText": "Moved the replicas property out for now as it could potential confuse users into thinking that Cruise Control deployments can scale past 1 pod, it is inconsistent with the other component deployment configurations, and it adds another property that users would need to remember to deploy Cruise Control.\nNow users can deploy Cruise Control with cruiseControl: {}\nWe can add it back in later if people find this functionality useful and want it!", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413400052", "createdAt": "2020-04-22T23:26:09Z", "author": {"login": "kyguy"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Maximum;\n+import io.strimzi.crdgenerator.annotations.Minimum;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",\n+        \"livenessProbe\", \"readinessProbe\",\n+        \"jvmOptions\", \"resources\",\n+        \"logging\", \"tlsSidecar\", \"template\", \"brokerCapacity\"})\n+@EqualsAndHashCode\n+public class CruiseControlSpec implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // For the full configuration list refer to https://github.com/linkedin/cruise-control/wiki/Configurations\n+    public static final String FORBIDDEN_PREFIXES = \"bootstrap.servers, client.id, zookeeper., network., security., failed.brokers.zk.path,\"\n+        + \"webserver.http., webserver.api.urlprefix, webserver.session.path, webserver.accesslog., two.step., request.reason.required,\"\n+        + \"metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, partition.metric.sample.store.topic, broker.metric.sample.store.topic,\"\n+        + \"capacity.config.file, self.healing.\";\n+    public static final String FORBIDDEN_PREFIX_EXCEPTIONS = \"\";\n+\n+    private int replicas;\n+    private String image;\n+    private TlsSidecar tlsSidecar;\n+    private ResourceRequirements resources;\n+    private Probe livenessProbe;\n+    private Probe readinessProbe;\n+    private JvmOptions jvmOptions;\n+    private Logging logging;\n+    private CruiseControlTemplate template;\n+    private BrokerCapacity brokerCapacity;\n+    private Map<String, Object> config = new HashMap<>(0);\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"The number of pods in the `Deployment`.\")\n+    @Minimum(0)\n+    @Maximum(1)\n+    @JsonProperty(required = true)\n+    public int getReplicas() {\n+        return replicas;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0NTk5Mw=="}, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Mjg1MDQyOnYy", "diffSide": "RIGHT", "path": "docker-images/kafka/Dockerfile", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDowMjozN1rOGJWJgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNjoyOToyOFrOGJ_jZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1MzI1MQ==", "bodyText": "Why is this not just added to the third-party-libs for given version? You might anyway need to change it later once you need different versions for different broker.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r412453251", "createdAt": "2020-04-21T20:02:37Z", "author": {"login": "scholzj"}, "path": "docker-images/kafka/Dockerfile", "diffHunk": "@@ -49,6 +56,10 @@ COPY ./tmp/tracing-agent.jar ${KAFKA_HOME}/libs/\n #####\n COPY kafka-thirdparty-libs/${THIRD_PARTY_LIBS}/target/dependency/ ${KAFKA_HOME}/libs/\n \n+RUN  mkdir -p ${CRUISE_CONTROL_HOME}/libs/\n+COPY kafka-thirdparty-libs/cc/target/dependency/ ${CRUISE_CONTROL_HOME}/libs/\n+COPY kafka-thirdparty-libs/cc/target/dependency/cruise-control-metrics-reporter-*.jar ${KAFKA_HOME}/libs/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEzMTYyMg==", "bodyText": "I'll take another look at this", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413131622", "createdAt": "2020-04-22T16:29:28Z", "author": {"login": "kyguy"}, "path": "docker-images/kafka/Dockerfile", "diffHunk": "@@ -49,6 +56,10 @@ COPY ./tmp/tracing-agent.jar ${KAFKA_HOME}/libs/\n #####\n COPY kafka-thirdparty-libs/${THIRD_PARTY_LIBS}/target/dependency/ ${KAFKA_HOME}/libs/\n \n+RUN  mkdir -p ${CRUISE_CONTROL_HOME}/libs/\n+COPY kafka-thirdparty-libs/cc/target/dependency/ ${CRUISE_CONTROL_HOME}/libs/\n+COPY kafka-thirdparty-libs/cc/target/dependency/cruise-control-metrics-reporter-*.jar ${KAFKA_HOME}/libs/", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1MzI1MQ=="}, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Mjg1MzkyOnYy", "diffSide": "RIGHT", "path": "docker-images/kafka/Dockerfile", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDowMzoyNVrOGJWLdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDowMzoyNVrOGJWLdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1Mzc0OA==", "bodyText": "Thsi section is called Add Cruise Control But it seems Cruise Control is actually added on line 60. Any reason why not move it here? Or we should at least rename this.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r412453748", "createdAt": "2020-04-21T20:03:25Z", "author": {"login": "scholzj"}, "path": "docker-images/kafka/Dockerfile", "diffHunk": "@@ -37,6 +37,13 @@ RUN curl -LO https://github.com/danielqsj/kafka_exporter/releases/download/v${KA\n \n COPY ./exporter-scripts $KAFKA_EXPORTER_HOME\n \n+#####\n+# Add Cruise Control\n+#####\n+ENV CRUISE_CONTROL_HOME=/opt/cruise-control\n+RUN mkdir $CRUISE_CONTROL_HOME\n+COPY ./cruise-control-scripts $CRUISE_CONTROL_HOME", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Mjg2MjY2OnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/proc-executing-cruise-control-rebalance-operations.adoc", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDowNTo0NFrOGJWQqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMzoyMTo1MVrOGKP1aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1NTA4MQ==", "bodyText": "Should these be deleted? Or at least comment out everything and keep the file so that the title and the TBD doesn't render?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r412455081", "createdAt": "2020-04-21T20:05:44Z", "author": {"login": "scholzj"}, "path": "documentation/modules/cruise-control/proc-executing-cruise-control-rebalance-operations.adoc", "diffHunk": "@@ -0,0 +1,9 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-executing-cruise-control-rebalance-operations-{context}']\n+= Executing a cluster rebalance\n+\n+TBD", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg3NjAwMg==", "bodyText": "Yes, good spot. In assembly-cruise-control-concepts.adoc, please comment out the include statements for these modules.\n//include::../../modules/cruise-control/proc-interacting-with-cruise-control-api.adoc[leveloffset=+1]\n\n//include::../../modules/cruise-control/proc-executing-cruise-control-rebalance-operations.adoc[leveloffset=+1]", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r412876002", "createdAt": "2020-04-22T10:48:27Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-executing-cruise-control-rebalance-operations.adoc", "diffHunk": "@@ -0,0 +1,9 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-executing-cruise-control-rebalance-operations-{context}']\n+= Executing a cluster rebalance\n+\n+TBD", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1NTA4MQ=="}, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM5ODM3OQ==", "bodyText": "Commented these out in assembly-cruise-control-concepts.adoc so they don't show up in the docs", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413398379", "createdAt": "2020-04-22T23:21:51Z", "author": {"login": "kyguy"}, "path": "documentation/modules/cruise-control/proc-executing-cruise-control-rebalance-operations.adoc", "diffHunk": "@@ -0,0 +1,9 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-executing-cruise-control-rebalance-operations-{context}']\n+= Executing a cluster rebalance\n+\n+TBD", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1NTA4MQ=="}, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Mjg2MzE0OnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/proc-interacting-with-cruise-control-api.adoc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDowNTo1MVrOGJWQ7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMzoyMToyOFrOGKP02g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1NTE0OQ==", "bodyText": "Same as abive", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r412455149", "createdAt": "2020-04-21T20:05:51Z", "author": {"login": "scholzj"}, "path": "documentation/modules/cruise-control/proc-interacting-with-cruise-control-api.adoc", "diffHunk": "@@ -0,0 +1,9 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-interacting-with-cruise-control-api-{context}']\n+= Interacting with the Cruise Control API\n+\n+TBD", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM5ODIzNA==", "bodyText": "Commented this out in assembly-cruise-control-concepts.adoc so it doesn't show up in the docs", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413398234", "createdAt": "2020-04-22T23:21:28Z", "author": {"login": "kyguy"}, "path": "documentation/modules/cruise-control/proc-interacting-with-cruise-control-api.adoc", "diffHunk": "@@ -0,0 +1,9 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-interacting-with-cruise-control-api-{context}']\n+= Interacting with the Cruise Control API\n+\n+TBD", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1NTE0OQ=="}, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Mjg2ODM4OnYy", "diffSide": "RIGHT", "path": "examples/kafka/kafka-cruise-control.yaml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDowNjo1NlrOGJWT9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMzoyMDo0NVrOGKPzZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1NTkyNw==", "bodyText": "So out of curiosity ... when will it do when it is deployed like this withotu any other configuration?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r412455927", "createdAt": "2020-04-21T20:06:56Z", "author": {"login": "scholzj"}, "path": "examples/kafka/kafka-cruise-control.yaml", "diffHunk": "@@ -0,0 +1,27 @@\n+apiVersion: kafka.strimzi.io/v1beta1\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  kafka:\n+    version: 2.4.0\n+    replicas: 3\n+    listeners:\n+      plain: {}\n+      tls: {}\n+    config:\n+      offsets.topic.replication.factor: 3\n+      transaction.state.log.replication.factor: 3\n+      transaction.state.log.min.isr: 2\n+      log.message.format.version: \"2.4\"\n+    storage:\n+      type: ephemeral\n+  zookeeper:\n+    replicas: 3\n+    storage:\n+      type: ephemeral\n+  entityOperator:\n+    topicOperator: {}\n+    userOperator: {}\n+  cruiseControl:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM5Nzg2Mg==", "bodyText": "The k8s yaml validation will throw an error\nNow that I have remove cruiseControl.replicas we can bring Cruise Control up with just cruiseControl: {}", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413397862", "createdAt": "2020-04-22T23:20:45Z", "author": {"login": "kyguy"}, "path": "examples/kafka/kafka-cruise-control.yaml", "diffHunk": "@@ -0,0 +1,27 @@\n+apiVersion: kafka.strimzi.io/v1beta1\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  kafka:\n+    version: 2.4.0\n+    replicas: 3\n+    listeners:\n+      plain: {}\n+      tls: {}\n+    config:\n+      offsets.topic.replication.factor: 3\n+      transaction.state.log.replication.factor: 3\n+      transaction.state.log.min.isr: 2\n+      log.message.format.version: \"2.4\"\n+    storage:\n+      type: ephemeral\n+  zookeeper:\n+    replicas: 3\n+    storage:\n+      type: ephemeral\n+  entityOperator:\n+    topicOperator: {}\n+    userOperator: {}\n+  cruiseControl:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1NTkyNw=="}, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Mjg3NDA2OnYy", "diffSide": "RIGHT", "path": "helm-charts/strimzi-kafka-operator/values.yaml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDowODoyM1rOGJWXbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDowODoyM1rOGJWXbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1NjgxNA==", "bodyText": "I do not see any updated to the Helm Chart REAMDE.md file. Can you update it as well please?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r412456814", "createdAt": "2020-04-21T20:08:23Z", "author": {"login": "scholzj"}, "path": "helm-charts/strimzi-kafka-operator/values.yaml", "diffHunk": "@@ -97,6 +97,16 @@ kafkaMirrorMaker2:\n     repository: strimzi\n     name: kafka\n     tagPrefix: latest\n+cruiseControl:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTcwNDMxOnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDozMjo0M1rOGJvXLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDozMjo0M1rOGJvXLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2NjM0OA==", "bodyText": "@kyguy - Does it make sense to include a goals configuration here too?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r412866348", "createdAt": "2020-04-22T10:32:43Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,106 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Cruise Control is configured using the `cruiseControl` property in the `Kafka` resource.\n+Once configured, you can deploy a Cruise Control instance to your {ProductName} cluster by creating or updating the `Kafka` resource.\n+\n+For an overview of the `Kafka` resource, see the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration].\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+Deploy one instance of Cruise Control per Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000KB/s\n+      networkOut: 10000KB/s\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTcxOTkyOnYy", "diffSide": "RIGHT", "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDozNjozOFrOGJvgcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDozNjozOFrOGJvgcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2ODcyMQ==", "bodyText": "@kyguy - Please comment this out because the target procedure is not ready. Also, I think the best next step is to generate optimization proposals and use them to rebalance the cluster.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r412868721", "createdAt": "2020-04-22T10:36:38Z", "author": {"login": "laidan6000"}, "path": "documentation/modules/cruise-control/proc-deploying-cruise-control.adoc", "diffHunk": "@@ -0,0 +1,106 @@\n+// This module is included in the following assemblies:\n+//\n+// assembly-cruise-control-concepts.adoc\n+\n+[id='proc-deploying-cruise-control-{context}']\n+= Deploying Cruise Control\n+\n+Cruise Control is configured using the `cruiseControl` property in the `Kafka` resource.\n+Once configured, you can deploy a Cruise Control instance to your {ProductName} cluster by creating or updating the `Kafka` resource.\n+\n+For an overview of the `Kafka` resource, see the xref:ref-sample-kafka-resource-config-deployment-configuration-kafka[sample Kafka YAML configuration].\n+\n+You can configure `cruiseControl` properties as part of a deployment or redeployment of a Kafka cluster.\n+Deploy one instance of Cruise Control per Kafka cluster.\n+\n+.Prerequisites\n+\n+* A Kubernetes cluster\n+* A running Cluster Operator\n+\n+.Procedure\n+\n+. Edit the `cruiseControl` property of the `Kafka` resource.\n++\n+The properties you can configure are shown in this example configuration:\n++\n+[source,yaml,subs=\"attributes+\"]\n+----\n+apiVersion: {KafkaApiVersion}\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  # ...\n+  cruiseControl:\n+    replicas: 1 <1>\n+    capacity: <2>\n+      networkIn: 10000KB/s\n+      networkOut: 10000KB/s\n+      # ...\n+    config: <3>\n+      default.goals: >\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareGoal,\n+         com.linkedin.kafka.cruisecontrol.analyzer.goals.ReplicaCapacityGoal\n+      cpu.balance.threshold: 1.1\n+      metadata.max.age.ms: 300000\n+      send.buffer.bytes: 131072\n+      # ...\n+    resources: <4>\n+      requests:\n+        cpu: 200m\n+        memory: 64Mi\n+      limits:\n+        cpu: 500m\n+        memory: 128Mi\n+    logging: <5>\n+        type: inline\n+        loggers:\n+          cruisecontrol.root.logger: \"INFO\"\n+    template: <6>\n+      pod:\n+        metadata:\n+          labels:\n+            label1: value1\n+        securityContext:\n+          runAsUser: 1000001\n+          fsGroup: 0\n+        terminationGracePeriodSeconds: 120\n+    readinessProbe: <7>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+    livenessProbe: <8>\n+      initialDelaySeconds: 15\n+      timeoutSeconds: 5\n+# ...\n+----\n+<1> Number of Cruise Control instances to create. Set to `1` to run the application or `0` to pause it.\n+<2> Specifies capacity limits for broker resources. For more information, see xref:capacity_configuration[Capacity configuration].\n+<3> Defines the Cruise Control configuration, including default and enabled optimization goals. You can provide any xref:ref-cruise-control-configuration-{context}[standard configuration option] apart from those managed directly by {ProductName}.\n+<4> CPU and memory resources reserved for Cruise Control. For more information, see xref:assembly-resource-limits-and-requests-deployment-configuration-kafka[].\n+<5> Defined loggers and log levels added directly (inline) or indirectly (external) through a ConfigMap. A custom ConfigMap must be placed under the log4j.properties key. Cruise Control has a single logger called cruisecontrol.root.logger. You can set the log level to INFO, ERROR, WARN, TRACE, DEBUG, FATAL or OFF. For more information, see xref:logging_configuration[Logging configuration].\n+<6> xref:assembly-customizing-deployments-str[Customization of deployment templates and pods].\n+<7> xref:assembly-healthchecks-deployment-configuration-kafka[Healthcheck readiness probes].\n+<8> xref:assembly-healthchecks-deployment-configuration-kafka[Healthcheck liveness probes].\n+\n+. Create or update the resource:\n++\n+[source,shell,subs=\"+quotes\"]\n+----\n+kubectl apply -f _kafka.yaml_\n+----\n+\n+. Verify that Cruise Control was successfully deployed:\n++\n+[source,shell,subs=\"+quotes\"]\n+----\n+kubectl get deployments -l app.kubernetes.io/name=strimzi\n+----\n+\n+.What to do next\n+\n+After configuring and deploying Cruise Control, you can xref:proc-interacting-with-cruise-control-api-{context}[interact with the Cruise Control API]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28d7067f7db4e525717ffd8e4c5e17d0a6d22f8"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTA5MzIxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwOTo1MzowNVrOGKg21w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwOTo1MzowNVrOGKg21w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY3NzI3MQ==", "bodyText": "I think you could remove the replicas from here.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413677271", "createdAt": "2020-04-23T09:53:05Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/CruiseControlSpec.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.ResourceRequirements;\n+import io.strimzi.api.kafka.model.balancing.BrokerCapacity;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import lombok.EqualsAndHashCode;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\n+        \"replicas\", \"image\", \"config\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91ac7f21e43549dca16004910147417dbf94cb89"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTEwNjA2OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwOTo1NjowOVrOGKg-5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwOTo1NjowOVrOGKg-5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY3OTMzMw==", "bodyText": "I think we need to add here the securityontext form the container templates.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413679333", "createdAt": "2020-04-23T09:56:09Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"logging\";\n+\n+    private String zookeeperConnect;\n+\n+    // Configuration defaults\n+    protected static final int DEFAULT_REPLICAS = 1;\n+\n+    // Default probe settings (liveness and readiness) for health checks\n+    protected static final int DEFAULT_HEALTHCHECK_DELAY = 15;\n+    protected static final int DEFAULT_HEALTHCHECK_TIMEOUT = 5;\n+\n+    public static final Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder()\n+            .withInitialDelaySeconds(DEFAULT_HEALTHCHECK_DELAY)\n+            .withTimeoutSeconds(DEFAULT_HEALTHCHECK_TIMEOUT)\n+            .build();\n+\n+    private TlsSidecar tlsSidecar;\n+    private String tlsSidecarImage;\n+    private String minInsyncReplicas = \"1\";\n+    private Double brokerDiskMiBCapacity;\n+    private int brokerCpuUtilizationCapacity;\n+    private Double brokerInboundNetworkKiBPerSecondCapacity;\n+    private Double brokerOuboundNetworkKiBPerSecondCapacity;\n+\n+    public static final String REST_API_PORT_NAME = \"rest-api\";\n+    public static final int REST_API_PORT = 9090;\n+    protected static final int DEFAULT_BOOTSTRAP_SERVERS_PORT = 9091;\n+    public static final String MIN_INSYNC_REPLICAS = \"min.insync.replicas\";\n+\n+    // Cruise Control configuration keys (EnvVariables)\n+    protected static final String ENV_VAR_CRUISE_CONTROL_CONFIGURATION = \"CRUISE_CONTROL_CONFIGURATION\";\n+    protected static final String ENV_VAR_ZOOKEEPER_CONNECT = \"STRIMZI_ZOOKEEPER_CONNECT\";\n+    protected static final String ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS = \"STRIMZI_KAFKA_BOOTSTRAP_SERVERS\";\n+    protected static final String ENV_VAR_MIN_INSYNC_REPLICAS = \"MIN_INSYNC_REPLICAS\";\n+    protected static final String ENV_VAR_BROKER_DISK_MIB_CAPACITY = \"BROKER_DISK_MIB_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_CPU_UTILIZATION_CAPACITY = \"BROKER_CPU_UTILIZATION_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+\n+    // Templates\n+    protected List<ContainerEnvVar> templateCruiseControlContainerEnvVars;\n+    protected List<ContainerEnvVar> templateTlsSidecarContainerEnvVars;\n+\n+    private boolean isDeployed;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param resource  Kubernetes/OpenShift resource with metadata containing the namespace and cluster name\n+     */\n+    protected CruiseControl(HasMetadata resource) {\n+        super(resource, APPLICATION_NAME);\n+        this.name = CruiseControlResources.deploymentName(cluster);\n+        this.serviceName = CruiseControlResources.serviceName(cluster);\n+        this.ancillaryConfigName = metricAndLogConfigsName(cluster);\n+        this.replicas = DEFAULT_REPLICAS;\n+        this.readinessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.readinessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.mountPath = \"/var/lib/kafka\";\n+        this.logAndMetricsConfigVolumeName = LOG_AND_METRICS_CONFIG_VOLUME_NAME;\n+        this.logAndMetricsConfigMountPath = LOG_AND_METRICS_CONFIG_VOLUME_MOUNT;\n+\n+        this.zookeeperConnect = defaultZookeeperConnect(cluster);\n+    }\n+\n+    public static String metricAndLogConfigsName(String cluster) {\n+        return CruiseControlResources.logAndMetricsConfigMapName(cluster);\n+    }\n+\n+    protected void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    protected static String defaultZookeeperConnect(String cluster) {\n+        return ZookeeperCluster.serviceName(cluster) + \":\" + EntityOperatorSpec.DEFAULT_ZOOKEEPER_PORT;\n+    }\n+\n+    protected static String defaultBootstrapServers(String cluster) {\n+        return KafkaCluster.serviceName(cluster) + \":\" + DEFAULT_BOOTSTRAP_SERVERS_PORT;\n+    }\n+\n+    public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup versions) {\n+        CruiseControl cruiseControl = null;\n+        CruiseControlSpec spec  = kafkaAssembly.getSpec().getCruiseControl();\n+\n+        if (spec != null) {\n+            cruiseControl = new CruiseControl(kafkaAssembly);\n+            cruiseControl.isDeployed = true;\n+\n+            cruiseControl.setReplicas(DEFAULT_REPLICAS);\n+            String image = spec.getImage();\n+            if (image == null) {\n+                image = System.getenv().get(ClusterOperatorConfig.STRIMZI_DEFAULT_CRUISE_CONTROL_IMAGE);\n+            }\n+            cruiseControl.setImage(image);\n+\n+            TlsSidecar tlsSidecar = spec.getTlsSidecar();\n+            if (tlsSidecar == null) {\n+                tlsSidecar = new TlsSidecar();\n+            }\n+\n+            String tlsSideCarImage = tlsSidecar.getImage();\n+            if (tlsSideCarImage == null) {\n+                KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+                tlsSideCarImage = System.getenv().getOrDefault(ClusterOperatorConfig.STRIMZI_DEFAULT_TLS_SIDECAR_CRUISE_CONTROL_IMAGE, versions.kafkaImage(kafkaClusterSpec.getImage(), versions.defaultVersion().version()));\n+            }\n+\n+            tlsSidecar.setImage(tlsSideCarImage);\n+            cruiseControl.tlsSidecarImage = tlsSideCarImage;\n+            cruiseControl.setTlsSidecar(tlsSidecar);\n+\n+            cruiseControl = updateConfiguration(spec, cruiseControl);\n+\n+            KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+            KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+            if (configuration.getConfigOption(MIN_INSYNC_REPLICAS) != null) {\n+                cruiseControl.minInsyncReplicas = configuration.getConfigOption(MIN_INSYNC_REPLICAS);\n+            }\n+\n+            Capacity capacity = new Capacity(kafkaAssembly.getSpec());\n+            cruiseControl.brokerDiskMiBCapacity = capacity.getDiskMiB();\n+            cruiseControl.brokerCpuUtilizationCapacity = capacity.getCpuUtilization();\n+            cruiseControl.brokerInboundNetworkKiBPerSecondCapacity = capacity.getInboundNetworkKiBPerSecond();\n+            cruiseControl.brokerOuboundNetworkKiBPerSecondCapacity = capacity.getOutboundNetworkKiBPerSecond();\n+\n+            if (spec.getReadinessProbe() != null) {\n+                cruiseControl.setReadinessProbe(spec.getReadinessProbe());\n+            }\n+\n+            if (spec.getLivenessProbe() != null) {\n+                cruiseControl.setLivenessProbe(spec.getLivenessProbe());\n+            }\n+\n+            Logging logging = spec.getLogging();\n+            cruiseControl.setLogging(logging == null ? new InlineLogging() : logging);\n+\n+            cruiseControl.setGcLoggingEnabled(spec.getJvmOptions() == null ? DEFAULT_JVM_GC_LOGGING_ENABLED : spec.getJvmOptions().isGcLoggingEnabled());\n+            cruiseControl.setJvmOptions(spec.getJvmOptions());\n+\n+            cruiseControl.setUserAffinity(affinity(spec));\n+            cruiseControl.setResources(spec.getResources());\n+            cruiseControl.setTolerations(tolerations(spec));\n+            cruiseControl.setOwnerReference(kafkaAssembly);\n+            cruiseControl = updateTemplate(spec, cruiseControl);\n+        }\n+\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (configuration.getConfigOption(entry.getKey()) == null) {\n+                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        cruiseControl.setConfiguration(configuration);\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateTemplate(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        if (spec.getTemplate() != null) {\n+            CruiseControlTemplate template = spec.getTemplate();\n+\n+            ModelUtils.parsePodTemplate(cruiseControl, template.getPod());\n+\n+            if (template.getDeployment() != null && template.getDeployment().getMetadata() != null) {\n+                cruiseControl.templateDeploymentLabels = template.getDeployment().getMetadata().getLabels();\n+                cruiseControl.templateDeploymentAnnotations = template.getDeployment().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getApiService() != null && template.getApiService().getMetadata() != null) {\n+                cruiseControl.templateServiceLabels = template.getApiService().getMetadata().getLabels();\n+                cruiseControl.templateServiceAnnotations = template.getApiService().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getCruiseControlContainer() != null && template.getCruiseControlContainer().getEnv() != null) {\n+                cruiseControl.templateCruiseControlContainerEnvVars = template.getCruiseControlContainer().getEnv();\n+            }\n+\n+            if (template.getTlsSidecarContainer() != null && template.getTlsSidecarContainer().getEnv() != null) {\n+                cruiseControl.templateTlsSidecarContainerEnvVars = template.getTlsSidecarContainer().getEnv();\n+            }\n+\n+            ModelUtils.parsePodDisruptionBudgetTemplate(cruiseControl, template.getPodDisruptionBudget());\n+        }\n+        return cruiseControl;\n+    }\n+\n+    static List<Toleration> tolerations(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getTolerations() != null) {\n+            return spec.getTemplate().getPod().getTolerations();\n+        }\n+        return null;\n+    }\n+\n+    static Affinity affinity(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getAffinity() != null) {\n+            return spec.getTemplate().getPod().getAffinity();\n+        }\n+        return null;\n+    }\n+\n+    public static String cruiseControlName(String cluster) {\n+        return CruiseControlResources.deploymentName(cluster);\n+    }\n+\n+    public static String cruiseControlServiceName(String cluster) {\n+        return CruiseControlResources.serviceName(cluster);\n+    }\n+\n+    public Service generateService() {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        List<ServicePort> ports = Collections.singletonList(createServicePort(REST_API_PORT_NAME, REST_API_PORT, REST_API_PORT, \"TCP\"));\n+        return createService(\"ClusterIP\", ports, templateServiceAnnotations);\n+    }\n+\n+    protected List<ContainerPort> getContainerPortList() {\n+        List<ContainerPort> portList = new ArrayList<>(1);\n+\n+        portList.add(createContainerPort(REST_API_PORT_NAME, REST_API_PORT, \"TCP\"));\n+\n+        if (isMetricsEnabled) {\n+            portList.add(createContainerPort(METRICS_PORT_NAME, METRICS_PORT, \"TCP\"));\n+        }\n+\n+        return portList;\n+    }\n+\n+    protected List<Volume> getVolumes(boolean isOpenShift) {\n+        return Arrays.asList(createSecretVolume(TLS_SIDECAR_CC_CERTS_VOLUME_NAME, CruiseControl.secretName(cluster), isOpenShift),\n+                createSecretVolume(TLS_SIDECAR_CA_CERTS_VOLUME_NAME, AbstractModel.clusterCaCertSecretName(cluster), isOpenShift),\n+                createConfigMapVolume(logAndMetricsConfigVolumeName, ancillaryConfigName));\n+    }\n+\n+    protected List<VolumeMount> getVolumeMounts() {\n+        return Arrays.asList(createVolumeMount(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME, CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT),\n+                createVolumeMount(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME, CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT),\n+                createVolumeMount(logAndMetricsConfigVolumeName, logAndMetricsConfigMountPath));\n+    }\n+\n+    public Deployment generateDeployment(boolean isOpenShift, Map<String, String> annotations, ImagePullPolicy imagePullPolicy, List<LocalObjectReference> imagePullSecrets) {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        DeploymentStrategy updateStrategy = new DeploymentStrategyBuilder()\n+                .withType(\"RollingUpdate\")\n+                .withRollingUpdate(new RollingUpdateDeploymentBuilder()\n+                        .withMaxSurge(new IntOrString(1))\n+                        .withMaxUnavailable(new IntOrString(0))\n+                        .build())\n+                .build();\n+\n+        return createDeployment(\n+                updateStrategy,\n+                Collections.emptyMap(),\n+                Collections.emptyMap(),\n+                getMergedAffinity(),\n+                getInitContainers(imagePullPolicy),\n+                getContainers(imagePullPolicy),\n+                getVolumes(isOpenShift),\n+                imagePullSecrets);\n+    }\n+\n+    @Override\n+    protected List<Container> getContainers(ImagePullPolicy imagePullPolicy) {\n+        List<Container> containers = new ArrayList<>();\n+        Container container = new ContainerBuilder()\n+                .withName(CRUISE_CONTROL_CONTAINER_NAME)\n+                .withImage(getImage())\n+                .withCommand(\"/opt/cruise-control/cruise_control_run.sh\")\n+                .withEnv(getEnvVars())\n+                .withPorts(getContainerPortList())\n+                .withLivenessProbe(ModelUtils.createHttpProbe(livenessPath, REST_API_PORT_NAME, livenessProbeOptions))\n+                .withReadinessProbe(ModelUtils.createHttpProbe(readinessPath, REST_API_PORT_NAME, readinessProbeOptions))\n+                .withResources(getResources())\n+                .withVolumeMounts(getVolumeMounts())\n+                .withImagePullPolicy(determineImagePullPolicy(imagePullPolicy, getImage()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91ac7f21e43549dca16004910147417dbf94cb89"}, "originalPosition": 354}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTEwODIyOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwOTo1NjozNFrOGKhAKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwOTo1NjozNFrOGKhAKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY3OTY1Ng==", "bodyText": "We need to add here the security context from the tlsSidecar container template.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413679656", "createdAt": "2020-04-23T09:56:34Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {\n+    protected static final String APPLICATION_NAME = \"cruise-control\";\n+\n+    public static final String CRUISE_CONTROL_METRIC_REPORTER = \"com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsReporter\";\n+\n+    protected static final String CRUISE_CONTROL_CONTAINER_NAME = \"cruise-control\";\n+    protected static final String TLS_SIDECAR_NAME = \"tls-sidecar\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_NAME = \"cc-certs\";\n+    protected static final String TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cc-certs/\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_NAME = \"cluster-ca-certs\";\n+    protected static final String TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT = \"/etc/tls-sidecar/cluster-ca-certs/\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_NAME = \"cruise-control-logging\";\n+    protected static final String LOG_AND_METRICS_CONFIG_VOLUME_MOUNT = \"/opt/cruise-control/custom-config/\";\n+\n+    public static final String ANNO_STRIMZI_IO_LOGGING = Annotations.STRIMZI_DOMAIN + \"logging\";\n+\n+    private String zookeeperConnect;\n+\n+    // Configuration defaults\n+    protected static final int DEFAULT_REPLICAS = 1;\n+\n+    // Default probe settings (liveness and readiness) for health checks\n+    protected static final int DEFAULT_HEALTHCHECK_DELAY = 15;\n+    protected static final int DEFAULT_HEALTHCHECK_TIMEOUT = 5;\n+\n+    public static final Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder()\n+            .withInitialDelaySeconds(DEFAULT_HEALTHCHECK_DELAY)\n+            .withTimeoutSeconds(DEFAULT_HEALTHCHECK_TIMEOUT)\n+            .build();\n+\n+    private TlsSidecar tlsSidecar;\n+    private String tlsSidecarImage;\n+    private String minInsyncReplicas = \"1\";\n+    private Double brokerDiskMiBCapacity;\n+    private int brokerCpuUtilizationCapacity;\n+    private Double brokerInboundNetworkKiBPerSecondCapacity;\n+    private Double brokerOuboundNetworkKiBPerSecondCapacity;\n+\n+    public static final String REST_API_PORT_NAME = \"rest-api\";\n+    public static final int REST_API_PORT = 9090;\n+    protected static final int DEFAULT_BOOTSTRAP_SERVERS_PORT = 9091;\n+    public static final String MIN_INSYNC_REPLICAS = \"min.insync.replicas\";\n+\n+    // Cruise Control configuration keys (EnvVariables)\n+    protected static final String ENV_VAR_CRUISE_CONTROL_CONFIGURATION = \"CRUISE_CONTROL_CONFIGURATION\";\n+    protected static final String ENV_VAR_ZOOKEEPER_CONNECT = \"STRIMZI_ZOOKEEPER_CONNECT\";\n+    protected static final String ENV_VAR_STRIMZI_KAFKA_BOOTSTRAP_SERVERS = \"STRIMZI_KAFKA_BOOTSTRAP_SERVERS\";\n+    protected static final String ENV_VAR_MIN_INSYNC_REPLICAS = \"MIN_INSYNC_REPLICAS\";\n+    protected static final String ENV_VAR_BROKER_DISK_MIB_CAPACITY = \"BROKER_DISK_MIB_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_CPU_UTILIZATION_CAPACITY = \"BROKER_CPU_UTILIZATION_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_INBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+    protected static final String ENV_VAR_BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY = \"BROKER_OUTBOUND_NETWORK_KIB_PER_SECOND_CAPACITY\";\n+\n+    // Templates\n+    protected List<ContainerEnvVar> templateCruiseControlContainerEnvVars;\n+    protected List<ContainerEnvVar> templateTlsSidecarContainerEnvVars;\n+\n+    private boolean isDeployed;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param resource  Kubernetes/OpenShift resource with metadata containing the namespace and cluster name\n+     */\n+    protected CruiseControl(HasMetadata resource) {\n+        super(resource, APPLICATION_NAME);\n+        this.name = CruiseControlResources.deploymentName(cluster);\n+        this.serviceName = CruiseControlResources.serviceName(cluster);\n+        this.ancillaryConfigName = metricAndLogConfigsName(cluster);\n+        this.replicas = DEFAULT_REPLICAS;\n+        this.readinessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessPath = \"/kafkacruisecontrol/state\";\n+        this.livenessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.readinessProbeOptions = DEFAULT_HEALTHCHECK_OPTIONS;\n+        this.mountPath = \"/var/lib/kafka\";\n+        this.logAndMetricsConfigVolumeName = LOG_AND_METRICS_CONFIG_VOLUME_NAME;\n+        this.logAndMetricsConfigMountPath = LOG_AND_METRICS_CONFIG_VOLUME_MOUNT;\n+\n+        this.zookeeperConnect = defaultZookeeperConnect(cluster);\n+    }\n+\n+    public static String metricAndLogConfigsName(String cluster) {\n+        return CruiseControlResources.logAndMetricsConfigMapName(cluster);\n+    }\n+\n+    protected void setTlsSidecar(TlsSidecar tlsSidecar) {\n+        this.tlsSidecar = tlsSidecar;\n+    }\n+\n+    protected static String defaultZookeeperConnect(String cluster) {\n+        return ZookeeperCluster.serviceName(cluster) + \":\" + EntityOperatorSpec.DEFAULT_ZOOKEEPER_PORT;\n+    }\n+\n+    protected static String defaultBootstrapServers(String cluster) {\n+        return KafkaCluster.serviceName(cluster) + \":\" + DEFAULT_BOOTSTRAP_SERVERS_PORT;\n+    }\n+\n+    public static CruiseControl fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup versions) {\n+        CruiseControl cruiseControl = null;\n+        CruiseControlSpec spec  = kafkaAssembly.getSpec().getCruiseControl();\n+\n+        if (spec != null) {\n+            cruiseControl = new CruiseControl(kafkaAssembly);\n+            cruiseControl.isDeployed = true;\n+\n+            cruiseControl.setReplicas(DEFAULT_REPLICAS);\n+            String image = spec.getImage();\n+            if (image == null) {\n+                image = System.getenv().get(ClusterOperatorConfig.STRIMZI_DEFAULT_CRUISE_CONTROL_IMAGE);\n+            }\n+            cruiseControl.setImage(image);\n+\n+            TlsSidecar tlsSidecar = spec.getTlsSidecar();\n+            if (tlsSidecar == null) {\n+                tlsSidecar = new TlsSidecar();\n+            }\n+\n+            String tlsSideCarImage = tlsSidecar.getImage();\n+            if (tlsSideCarImage == null) {\n+                KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+                tlsSideCarImage = System.getenv().getOrDefault(ClusterOperatorConfig.STRIMZI_DEFAULT_TLS_SIDECAR_CRUISE_CONTROL_IMAGE, versions.kafkaImage(kafkaClusterSpec.getImage(), versions.defaultVersion().version()));\n+            }\n+\n+            tlsSidecar.setImage(tlsSideCarImage);\n+            cruiseControl.tlsSidecarImage = tlsSideCarImage;\n+            cruiseControl.setTlsSidecar(tlsSidecar);\n+\n+            cruiseControl = updateConfiguration(spec, cruiseControl);\n+\n+            KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+            KafkaConfiguration configuration = new KafkaConfiguration(kafkaClusterSpec.getConfig().entrySet());\n+            if (configuration.getConfigOption(MIN_INSYNC_REPLICAS) != null) {\n+                cruiseControl.minInsyncReplicas = configuration.getConfigOption(MIN_INSYNC_REPLICAS);\n+            }\n+\n+            Capacity capacity = new Capacity(kafkaAssembly.getSpec());\n+            cruiseControl.brokerDiskMiBCapacity = capacity.getDiskMiB();\n+            cruiseControl.brokerCpuUtilizationCapacity = capacity.getCpuUtilization();\n+            cruiseControl.brokerInboundNetworkKiBPerSecondCapacity = capacity.getInboundNetworkKiBPerSecond();\n+            cruiseControl.brokerOuboundNetworkKiBPerSecondCapacity = capacity.getOutboundNetworkKiBPerSecond();\n+\n+            if (spec.getReadinessProbe() != null) {\n+                cruiseControl.setReadinessProbe(spec.getReadinessProbe());\n+            }\n+\n+            if (spec.getLivenessProbe() != null) {\n+                cruiseControl.setLivenessProbe(spec.getLivenessProbe());\n+            }\n+\n+            Logging logging = spec.getLogging();\n+            cruiseControl.setLogging(logging == null ? new InlineLogging() : logging);\n+\n+            cruiseControl.setGcLoggingEnabled(spec.getJvmOptions() == null ? DEFAULT_JVM_GC_LOGGING_ENABLED : spec.getJvmOptions().isGcLoggingEnabled());\n+            cruiseControl.setJvmOptions(spec.getJvmOptions());\n+\n+            cruiseControl.setUserAffinity(affinity(spec));\n+            cruiseControl.setResources(spec.getResources());\n+            cruiseControl.setTolerations(tolerations(spec));\n+            cruiseControl.setOwnerReference(kafkaAssembly);\n+            cruiseControl = updateTemplate(spec, cruiseControl);\n+        }\n+\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateConfiguration(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        CruiseControlConfiguration configuration = new CruiseControlConfiguration(spec.getConfig().entrySet());\n+        for (Map.Entry<String, String> entry : configuration.getCruiseControlDefaultPropertiesMap().entrySet()) {\n+            if (configuration.getConfigOption(entry.getKey()) == null) {\n+                configuration.setConfigOption(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        cruiseControl.setConfiguration(configuration);\n+        return cruiseControl;\n+    }\n+\n+    public static CruiseControl updateTemplate(CruiseControlSpec spec, CruiseControl cruiseControl) {\n+        if (spec.getTemplate() != null) {\n+            CruiseControlTemplate template = spec.getTemplate();\n+\n+            ModelUtils.parsePodTemplate(cruiseControl, template.getPod());\n+\n+            if (template.getDeployment() != null && template.getDeployment().getMetadata() != null) {\n+                cruiseControl.templateDeploymentLabels = template.getDeployment().getMetadata().getLabels();\n+                cruiseControl.templateDeploymentAnnotations = template.getDeployment().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getApiService() != null && template.getApiService().getMetadata() != null) {\n+                cruiseControl.templateServiceLabels = template.getApiService().getMetadata().getLabels();\n+                cruiseControl.templateServiceAnnotations = template.getApiService().getMetadata().getAnnotations();\n+            }\n+\n+            if (template.getCruiseControlContainer() != null && template.getCruiseControlContainer().getEnv() != null) {\n+                cruiseControl.templateCruiseControlContainerEnvVars = template.getCruiseControlContainer().getEnv();\n+            }\n+\n+            if (template.getTlsSidecarContainer() != null && template.getTlsSidecarContainer().getEnv() != null) {\n+                cruiseControl.templateTlsSidecarContainerEnvVars = template.getTlsSidecarContainer().getEnv();\n+            }\n+\n+            ModelUtils.parsePodDisruptionBudgetTemplate(cruiseControl, template.getPodDisruptionBudget());\n+        }\n+        return cruiseControl;\n+    }\n+\n+    static List<Toleration> tolerations(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getTolerations() != null) {\n+            return spec.getTemplate().getPod().getTolerations();\n+        }\n+        return null;\n+    }\n+\n+    static Affinity affinity(CruiseControlSpec spec) {\n+        if (spec.getTemplate() != null\n+                && spec.getTemplate().getPod() != null\n+                && spec.getTemplate().getPod().getAffinity() != null) {\n+            return spec.getTemplate().getPod().getAffinity();\n+        }\n+        return null;\n+    }\n+\n+    public static String cruiseControlName(String cluster) {\n+        return CruiseControlResources.deploymentName(cluster);\n+    }\n+\n+    public static String cruiseControlServiceName(String cluster) {\n+        return CruiseControlResources.serviceName(cluster);\n+    }\n+\n+    public Service generateService() {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        List<ServicePort> ports = Collections.singletonList(createServicePort(REST_API_PORT_NAME, REST_API_PORT, REST_API_PORT, \"TCP\"));\n+        return createService(\"ClusterIP\", ports, templateServiceAnnotations);\n+    }\n+\n+    protected List<ContainerPort> getContainerPortList() {\n+        List<ContainerPort> portList = new ArrayList<>(1);\n+\n+        portList.add(createContainerPort(REST_API_PORT_NAME, REST_API_PORT, \"TCP\"));\n+\n+        if (isMetricsEnabled) {\n+            portList.add(createContainerPort(METRICS_PORT_NAME, METRICS_PORT, \"TCP\"));\n+        }\n+\n+        return portList;\n+    }\n+\n+    protected List<Volume> getVolumes(boolean isOpenShift) {\n+        return Arrays.asList(createSecretVolume(TLS_SIDECAR_CC_CERTS_VOLUME_NAME, CruiseControl.secretName(cluster), isOpenShift),\n+                createSecretVolume(TLS_SIDECAR_CA_CERTS_VOLUME_NAME, AbstractModel.clusterCaCertSecretName(cluster), isOpenShift),\n+                createConfigMapVolume(logAndMetricsConfigVolumeName, ancillaryConfigName));\n+    }\n+\n+    protected List<VolumeMount> getVolumeMounts() {\n+        return Arrays.asList(createVolumeMount(CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_NAME, CruiseControl.TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT),\n+                createVolumeMount(CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_NAME, CruiseControl.TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT),\n+                createVolumeMount(logAndMetricsConfigVolumeName, logAndMetricsConfigMountPath));\n+    }\n+\n+    public Deployment generateDeployment(boolean isOpenShift, Map<String, String> annotations, ImagePullPolicy imagePullPolicy, List<LocalObjectReference> imagePullSecrets) {\n+        if (!isDeployed()) {\n+            return null;\n+        }\n+\n+        DeploymentStrategy updateStrategy = new DeploymentStrategyBuilder()\n+                .withType(\"RollingUpdate\")\n+                .withRollingUpdate(new RollingUpdateDeploymentBuilder()\n+                        .withMaxSurge(new IntOrString(1))\n+                        .withMaxUnavailable(new IntOrString(0))\n+                        .build())\n+                .build();\n+\n+        return createDeployment(\n+                updateStrategy,\n+                Collections.emptyMap(),\n+                Collections.emptyMap(),\n+                getMergedAffinity(),\n+                getInitContainers(imagePullPolicy),\n+                getContainers(imagePullPolicy),\n+                getVolumes(isOpenShift),\n+                imagePullSecrets);\n+    }\n+\n+    @Override\n+    protected List<Container> getContainers(ImagePullPolicy imagePullPolicy) {\n+        List<Container> containers = new ArrayList<>();\n+        Container container = new ContainerBuilder()\n+                .withName(CRUISE_CONTROL_CONTAINER_NAME)\n+                .withImage(getImage())\n+                .withCommand(\"/opt/cruise-control/cruise_control_run.sh\")\n+                .withEnv(getEnvVars())\n+                .withPorts(getContainerPortList())\n+                .withLivenessProbe(ModelUtils.createHttpProbe(livenessPath, REST_API_PORT_NAME, livenessProbeOptions))\n+                .withReadinessProbe(ModelUtils.createHttpProbe(readinessPath, REST_API_PORT_NAME, readinessProbeOptions))\n+                .withResources(getResources())\n+                .withVolumeMounts(getVolumeMounts())\n+                .withImagePullPolicy(determineImagePullPolicy(imagePullPolicy, getImage()))\n+                .build();\n+\n+        String tlsSidecarImage = this.tlsSidecarImage;\n+        if (tlsSidecar != null && tlsSidecar.getImage() != null) {\n+            tlsSidecarImage = tlsSidecar.getImage();\n+        }\n+\n+        Container tlsSidecarContainer = new ContainerBuilder()\n+                .withName(TLS_SIDECAR_NAME)\n+                .withImage(tlsSidecarImage)\n+                .withCommand(\"/opt/stunnel/cruise_control_stunnel_run.sh\")\n+                .withLivenessProbe(ModelUtils.tlsSidecarLivenessProbe(tlsSidecar))\n+                .withReadinessProbe(ModelUtils.tlsSidecarReadinessProbe(tlsSidecar))\n+                .withResources(tlsSidecar != null ? tlsSidecar.getResources() : null)\n+                .withEnv(getTlsSidecarEnvVars())\n+                .withVolumeMounts(createVolumeMount(TLS_SIDECAR_CC_CERTS_VOLUME_NAME, TLS_SIDECAR_CC_CERTS_VOLUME_MOUNT),\n+                        createVolumeMount(TLS_SIDECAR_CA_CERTS_VOLUME_NAME, TLS_SIDECAR_CA_CERTS_VOLUME_MOUNT))\n+                .withLifecycle(new LifecycleBuilder().withNewPreStop().withNewExec()\n+                        .withCommand(\"/opt/stunnel/cruise_control_stunnel_pre_stop.sh\",\n+                                String.valueOf(templateTerminationGracePeriodSeconds))\n+                        .endExec().endPreStop().build())\n+                .withImagePullPolicy(determineImagePullPolicy(imagePullPolicy, tlsSidecarImage))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91ac7f21e43549dca16004910147417dbf94cb89"}, "originalPosition": 376}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTEyMTQyOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwOTo1OTo0NVrOGKhIUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwOTo1OTo0NVrOGKhIUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4MTc0Nw==", "bodyText": "Do we need to set some network policies on the CruiseControl ports?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413681747", "createdAt": "2020-04-23T09:59:45Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/CruiseControl.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.fabric8.kubernetes.api.model.Affinity;\n+import io.fabric8.kubernetes.api.model.Container;\n+import io.fabric8.kubernetes.api.model.ContainerBuilder;\n+import io.fabric8.kubernetes.api.model.ContainerPort;\n+import io.fabric8.kubernetes.api.model.EnvVar;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.IntOrString;\n+import io.fabric8.kubernetes.api.model.LifecycleBuilder;\n+import io.fabric8.kubernetes.api.model.LocalObjectReference;\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.fabric8.kubernetes.api.model.ServicePort;\n+import io.fabric8.kubernetes.api.model.Toleration;\n+import io.fabric8.kubernetes.api.model.Volume;\n+import io.fabric8.kubernetes.api.model.VolumeMount;\n+import io.fabric8.kubernetes.api.model.apps.Deployment;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategy;\n+import io.fabric8.kubernetes.api.model.apps.DeploymentStrategyBuilder;\n+import io.fabric8.kubernetes.api.model.apps.RollingUpdateDeploymentBuilder;\n+import io.fabric8.kubernetes.api.model.policy.PodDisruptionBudget;\n+import io.strimzi.api.kafka.model.ContainerEnvVar;\n+import io.strimzi.api.kafka.model.CruiseControlResources;\n+import io.strimzi.api.kafka.model.CruiseControlSpec;\n+import io.strimzi.api.kafka.model.EntityOperatorSpec;\n+import io.strimzi.api.kafka.model.InlineLogging;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaClusterSpec;\n+import io.strimzi.api.kafka.model.Logging;\n+import io.strimzi.api.kafka.model.Probe;\n+import io.strimzi.api.kafka.model.ProbeBuilder;\n+import io.strimzi.api.kafka.model.TlsSidecar;\n+import io.strimzi.api.kafka.model.template.CruiseControlTemplate;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.model.cruisecontrol.Capacity;\n+import io.strimzi.operator.common.Annotations;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createConfigMapVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createSecretVolume;\n+import static io.strimzi.operator.cluster.model.VolumeUtils.createVolumeMount;\n+\n+public class CruiseControl extends AbstractModel {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91ac7f21e43549dca16004910147417dbf94cb89"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTE0OTcyOnYy", "diffSide": "RIGHT", "path": "examples/kafka/kafka-cruise-control.yaml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDowNjoxOVrOGKhZiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDowNjoxOVrOGKhZiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NjE1Mg==", "bodyText": "This should be 2.4.1 now.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413686152", "createdAt": "2020-04-23T10:06:19Z", "author": {"login": "scholzj"}, "path": "examples/kafka/kafka-cruise-control.yaml", "diffHunk": "@@ -0,0 +1,26 @@\n+apiVersion: kafka.strimzi.io/v1beta1\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  kafka:\n+    version: 2.4.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91ac7f21e43549dca16004910147417dbf94cb89"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTMzNTAzOnYy", "diffSide": "RIGHT", "path": "examples/kafka/kafka-cruise-control.yaml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDo1MToyNVrOGKjH-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDo1MToyNVrOGKjH-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcxNDQyNA==", "bodyText": "I think we should provide a default CC configuration in the example file. We could provide the full list of goals and default goals so the user can remove any they don't need and/or fine-tune the constraints.\nOtherwise, we're making the user work harder. They'll need to refer to the documentation to figure out how to set goals and capacity limits.\nI don't mind if you merge this now and we continue the discussion in later PRs.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2773#discussion_r413714424", "createdAt": "2020-04-23T10:51:25Z", "author": {"login": "laidan6000"}, "path": "examples/kafka/kafka-cruise-control.yaml", "diffHunk": "@@ -0,0 +1,26 @@\n+apiVersion: kafka.strimzi.io/v1beta1\n+kind: Kafka\n+metadata:\n+  name: my-cluster\n+spec:\n+  kafka:\n+    version: 2.4.0\n+    replicas: 3\n+    listeners:\n+      plain: {}\n+      tls: {}\n+    config:\n+      offsets.topic.replication.factor: 3\n+      transaction.state.log.replication.factor: 3\n+      transaction.state.log.min.isr: 2\n+      log.message.format.version: \"2.4\"\n+    storage:\n+      type: ephemeral\n+  zookeeper:\n+    replicas: 3\n+    storage:\n+      type: ephemeral\n+  entityOperator:\n+    topicOperator: {}\n+    userOperator: {}\n+  cruiseControl: {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91ac7f21e43549dca16004910147417dbf94cb89"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 388, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}