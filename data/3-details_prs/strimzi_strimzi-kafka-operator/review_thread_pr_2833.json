{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzNDY3Njc0", "number": 2833, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODoxOTo1NVrODx9w6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTo1NDoyMlrODx_9Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzE4NzYzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODoxOTo1NVrOGFu5XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMDowODoxNlrOGFy3uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2NDQxMw==", "bodyText": "I wonder if adding these status conditions means we can change the log.warns to log.debugs?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2833#discussion_r408664413", "createdAt": "2020-04-15T08:19:55Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -476,6 +478,13 @@ public static KafkaCluster fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup vers\n                 log.warn(\"Your desired Kafka storage configuration contains changes which are not allowed. As a \" +\n                         \"result, all storage changes will be ignored. Use DEBUG level logging for more information \" +\n                         \"about the detected changes.\");\n+\n+                Condition warning = StatusUtils.buildWarningCondition(\"KafkaStorage\",\n+                        \"The desired Kafka storage configuration contains changes which are not allowed. As a \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba902f0a56fd09fe8c0e97315a8044c23379246e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwMTkzOA==", "bodyText": "I think it should still remain as a warning -> that might raise attention through other ways than the condition, for exxample in some log processing pipelines etc.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2833#discussion_r408701938", "createdAt": "2020-04-15T09:22:22Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -476,6 +478,13 @@ public static KafkaCluster fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup vers\n                 log.warn(\"Your desired Kafka storage configuration contains changes which are not allowed. As a \" +\n                         \"result, all storage changes will be ignored. Use DEBUG level logging for more information \" +\n                         \"about the detected changes.\");\n+\n+                Condition warning = StatusUtils.buildWarningCondition(\"KafkaStorage\",\n+                        \"The desired Kafka storage configuration contains changes which are not allowed. As a \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2NDQxMw=="}, "originalCommit": {"oid": "ba902f0a56fd09fe8c0e97315a8044c23379246e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyOTUzMQ==", "bodyText": "Makes sense to me!", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2833#discussion_r408729531", "createdAt": "2020-04-15T10:08:16Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -476,6 +478,13 @@ public static KafkaCluster fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup vers\n                 log.warn(\"Your desired Kafka storage configuration contains changes which are not allowed. As a \" +\n                         \"result, all storage changes will be ignored. Use DEBUG level logging for more information \" +\n                         \"about the detected changes.\");\n+\n+                Condition warning = StatusUtils.buildWarningCondition(\"KafkaStorage\",\n+                        \"The desired Kafka storage configuration contains changes which are not allowed. As a \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2NDQxMw=="}, "originalCommit": {"oid": "ba902f0a56fd09fe8c0e97315a8044c23379246e"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzE5OTA3OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaStatusTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODoyMzoxMlrOGFvAsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOToyMjozNFrOGFxMZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2NjI4OA==", "bodyText": "Would be helpful for my context succeeding work if you added this test with context.succeeding and wrap it also in a context.verify", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2833#discussion_r408666288", "createdAt": "2020-04-15T08:23:12Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaStatusTest.java", "diffHunk": "@@ -957,6 +957,101 @@ public void testInitialStatusOnOldResource() throws ParseException {\n         });\n     }\n \n+    @Test\n+    public void testModelWarnings(VertxTestContext context) throws ParseException {\n+        Kafka kafka = getKafkaCrd();\n+        Kafka oldKafka = new KafkaBuilder(getKafkaCrd())\n+                .editOrNewSpec()\n+                    .editOrNewKafka()\n+                        .withNewPersistentClaimStorage()\n+                            .withNewSize(\"100Gi\")\n+                        .endPersistentClaimStorage()\n+                    .endKafka()\n+                .endSpec()\n+                .build();\n+        KafkaCluster kafkaCluster = KafkaCluster.fromCrd(oldKafka, VERSIONS);\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(false);\n+\n+        // Mock the CRD Operator for Kafka resources\n+        CrdOperator mockKafkaOps = supplier.kafkaOperator;\n+        when(mockKafkaOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(kafka));\n+\n+        ArgumentCaptor<Kafka> kafkaCaptor = ArgumentCaptor.forClass(Kafka.class);\n+        when(mockKafkaOps.updateStatusAsync(kafkaCaptor.capture())).thenReturn(Future.succeededFuture());\n+\n+        // Mock the KafkaSetOperator\n+        KafkaSetOperator mockKafkaSetOps = supplier.kafkaSetOperations;\n+        when(mockKafkaSetOps.getAsync(eq(namespace), eq(KafkaCluster.kafkaClusterName(clusterName)))).thenReturn(Future.succeededFuture(kafkaCluster.generateStatefulSet(false, null, null)));\n+\n+        // Mock the ConfigMapOperator\n+        ConfigMapOperator mockCmOps = supplier.configMapOperations;\n+        when(mockCmOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(kafkaCluster.generateMetricsAndLogConfigMap(null)));\n+\n+        // Mock Pods Operator\n+        /*Pod pod0 = new PodBuilder()\n+                .withNewMetadata()\n+                .withNewName(clusterName + \"-kafka-\" + 0)\n+                .endMetadata()\n+                .withNewStatus()\n+                .withNewHostIP(\"10.0.0.1\")\n+                .endStatus()\n+                .build();\n+\n+        Pod pod1 = new PodBuilder()\n+                .withNewMetadata()\n+                .withNewName(clusterName + \"-kafka-\" + 1)\n+                .endMetadata()\n+                .withNewStatus()\n+                .withNewHostIP(\"10.0.0.1\")\n+                .endStatus()\n+                .build();\n+\n+        Pod pod2 = new PodBuilder()\n+                .withNewMetadata()\n+                .withNewName(clusterName + \"-kafka-\" + 2)\n+                .endMetadata()\n+                .withNewStatus()\n+                .withNewHostIP(\"10.0.0.1\")\n+                .endStatus()\n+                .build();\n+\n+        List<Pod> pods = new ArrayList<>();\n+        pods.add(pod0);\n+        pods.add(pod1);\n+        pods.add(pod2);\n+\n+        PodOperator mockPodOps = supplier.podOperations;\n+        when(mockPodOps.listAsync(eq(namespace), any(Labels.class))).thenReturn(Future.succeededFuture(pods));\n+\n+        // Mock Node operator\n+        NodeOperator mockNodeOps = supplier.nodeOperator;\n+        when(mockNodeOps.listAsync(any(Labels.class))).thenReturn(Future.succeededFuture(getClusterNodes()));*/\n+\n+        MockModelWarningsStatusKafkaAssemblyOperator kao = new MockModelWarningsStatusKafkaAssemblyOperator(\n+                vertx, new PlatformFeaturesAvailability(false, kubernetesVersion),\n+                certManager,\n+                passwordGenerator,\n+                supplier,\n+                config);\n+\n+        Checkpoint async = context.checkpoint();\n+        kao.createOrUpdate(new Reconciliation(\"test-trigger\", Kafka.RESOURCE_KIND, namespace, clusterName), kafka).setHandler(res -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba902f0a56fd09fe8c0e97315a8044c23379246e"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwMjA1NA==", "bodyText": "Good point. Should be fixed now.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2833#discussion_r408702054", "createdAt": "2020-04-15T09:22:34Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaStatusTest.java", "diffHunk": "@@ -957,6 +957,101 @@ public void testInitialStatusOnOldResource() throws ParseException {\n         });\n     }\n \n+    @Test\n+    public void testModelWarnings(VertxTestContext context) throws ParseException {\n+        Kafka kafka = getKafkaCrd();\n+        Kafka oldKafka = new KafkaBuilder(getKafkaCrd())\n+                .editOrNewSpec()\n+                    .editOrNewKafka()\n+                        .withNewPersistentClaimStorage()\n+                            .withNewSize(\"100Gi\")\n+                        .endPersistentClaimStorage()\n+                    .endKafka()\n+                .endSpec()\n+                .build();\n+        KafkaCluster kafkaCluster = KafkaCluster.fromCrd(oldKafka, VERSIONS);\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(false);\n+\n+        // Mock the CRD Operator for Kafka resources\n+        CrdOperator mockKafkaOps = supplier.kafkaOperator;\n+        when(mockKafkaOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(kafka));\n+\n+        ArgumentCaptor<Kafka> kafkaCaptor = ArgumentCaptor.forClass(Kafka.class);\n+        when(mockKafkaOps.updateStatusAsync(kafkaCaptor.capture())).thenReturn(Future.succeededFuture());\n+\n+        // Mock the KafkaSetOperator\n+        KafkaSetOperator mockKafkaSetOps = supplier.kafkaSetOperations;\n+        when(mockKafkaSetOps.getAsync(eq(namespace), eq(KafkaCluster.kafkaClusterName(clusterName)))).thenReturn(Future.succeededFuture(kafkaCluster.generateStatefulSet(false, null, null)));\n+\n+        // Mock the ConfigMapOperator\n+        ConfigMapOperator mockCmOps = supplier.configMapOperations;\n+        when(mockCmOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(kafkaCluster.generateMetricsAndLogConfigMap(null)));\n+\n+        // Mock Pods Operator\n+        /*Pod pod0 = new PodBuilder()\n+                .withNewMetadata()\n+                .withNewName(clusterName + \"-kafka-\" + 0)\n+                .endMetadata()\n+                .withNewStatus()\n+                .withNewHostIP(\"10.0.0.1\")\n+                .endStatus()\n+                .build();\n+\n+        Pod pod1 = new PodBuilder()\n+                .withNewMetadata()\n+                .withNewName(clusterName + \"-kafka-\" + 1)\n+                .endMetadata()\n+                .withNewStatus()\n+                .withNewHostIP(\"10.0.0.1\")\n+                .endStatus()\n+                .build();\n+\n+        Pod pod2 = new PodBuilder()\n+                .withNewMetadata()\n+                .withNewName(clusterName + \"-kafka-\" + 2)\n+                .endMetadata()\n+                .withNewStatus()\n+                .withNewHostIP(\"10.0.0.1\")\n+                .endStatus()\n+                .build();\n+\n+        List<Pod> pods = new ArrayList<>();\n+        pods.add(pod0);\n+        pods.add(pod1);\n+        pods.add(pod2);\n+\n+        PodOperator mockPodOps = supplier.podOperations;\n+        when(mockPodOps.listAsync(eq(namespace), any(Labels.class))).thenReturn(Future.succeededFuture(pods));\n+\n+        // Mock Node operator\n+        NodeOperator mockNodeOps = supplier.nodeOperator;\n+        when(mockNodeOps.listAsync(any(Labels.class))).thenReturn(Future.succeededFuture(getClusterNodes()));*/\n+\n+        MockModelWarningsStatusKafkaAssemblyOperator kao = new MockModelWarningsStatusKafkaAssemblyOperator(\n+                vertx, new PlatformFeaturesAvailability(false, kubernetesVersion),\n+                certManager,\n+                passwordGenerator,\n+                supplier,\n+                config);\n+\n+        Checkpoint async = context.checkpoint();\n+        kao.createOrUpdate(new Reconciliation(\"test-trigger\", Kafka.RESOURCE_KIND, namespace, clusterName), kafka).setHandler(res -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2NjI4OA=="}, "originalCommit": {"oid": "ba902f0a56fd09fe8c0e97315a8044c23379246e"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzU0NzAyOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaStatusTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTo1NDoyMlrOGFyYFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTo1ODo1NFrOGFyieA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMTQyOA==", "bodyText": "what about this big commented code block?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2833#discussion_r408721428", "createdAt": "2020-04-15T09:54:22Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaStatusTest.java", "diffHunk": "@@ -957,6 +957,100 @@ public void testInitialStatusOnOldResource() throws ParseException {\n         });\n     }\n \n+    @Test\n+    public void testModelWarnings(VertxTestContext context) throws ParseException {\n+        Kafka kafka = getKafkaCrd();\n+        Kafka oldKafka = new KafkaBuilder(getKafkaCrd())\n+                .editOrNewSpec()\n+                    .editOrNewKafka()\n+                        .withNewPersistentClaimStorage()\n+                            .withNewSize(\"100Gi\")\n+                        .endPersistentClaimStorage()\n+                    .endKafka()\n+                .endSpec()\n+                .build();\n+        KafkaCluster kafkaCluster = KafkaCluster.fromCrd(oldKafka, VERSIONS);\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(false);\n+\n+        // Mock the CRD Operator for Kafka resources\n+        CrdOperator mockKafkaOps = supplier.kafkaOperator;\n+        when(mockKafkaOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(kafka));\n+\n+        ArgumentCaptor<Kafka> kafkaCaptor = ArgumentCaptor.forClass(Kafka.class);\n+        when(mockKafkaOps.updateStatusAsync(kafkaCaptor.capture())).thenReturn(Future.succeededFuture());\n+\n+        // Mock the KafkaSetOperator\n+        KafkaSetOperator mockKafkaSetOps = supplier.kafkaSetOperations;\n+        when(mockKafkaSetOps.getAsync(eq(namespace), eq(KafkaCluster.kafkaClusterName(clusterName)))).thenReturn(Future.succeededFuture(kafkaCluster.generateStatefulSet(false, null, null)));\n+\n+        // Mock the ConfigMapOperator\n+        ConfigMapOperator mockCmOps = supplier.configMapOperations;\n+        when(mockCmOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(kafkaCluster.generateMetricsAndLogConfigMap(null)));\n+\n+        // Mock Pods Operator\n+        /*Pod pod0 = new PodBuilder()\n+                .withNewMetadata()\n+                .withNewName(clusterName + \"-kafka-\" + 0)\n+                .endMetadata()\n+                .withNewStatus()\n+                .withNewHostIP(\"10.0.0.1\")\n+                .endStatus()\n+                .build();\n+\n+        Pod pod1 = new PodBuilder()\n+                .withNewMetadata()\n+                .withNewName(clusterName + \"-kafka-\" + 1)\n+                .endMetadata()\n+                .withNewStatus()\n+                .withNewHostIP(\"10.0.0.1\")\n+                .endStatus()\n+                .build();\n+\n+        Pod pod2 = new PodBuilder()\n+                .withNewMetadata()\n+                .withNewName(clusterName + \"-kafka-\" + 2)\n+                .endMetadata()\n+                .withNewStatus()\n+                .withNewHostIP(\"10.0.0.1\")\n+                .endStatus()\n+                .build();\n+\n+        List<Pod> pods = new ArrayList<>();\n+        pods.add(pod0);\n+        pods.add(pod1);\n+        pods.add(pod2);\n+\n+        PodOperator mockPodOps = supplier.podOperations;\n+        when(mockPodOps.listAsync(eq(namespace), any(Labels.class))).thenReturn(Future.succeededFuture(pods));\n+\n+        // Mock Node operator\n+        NodeOperator mockNodeOps = supplier.nodeOperator;\n+        when(mockNodeOps.listAsync(any(Labels.class))).thenReturn(Future.succeededFuture(getClusterNodes()));*/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "874b8634cd069081bcf2b65e2c15fadef29ebd7f"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyNDA4OA==", "bodyText": "Good point. Thanks.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2833#discussion_r408724088", "createdAt": "2020-04-15T09:58:54Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaStatusTest.java", "diffHunk": "@@ -957,6 +957,100 @@ public void testInitialStatusOnOldResource() throws ParseException {\n         });\n     }\n \n+    @Test\n+    public void testModelWarnings(VertxTestContext context) throws ParseException {\n+        Kafka kafka = getKafkaCrd();\n+        Kafka oldKafka = new KafkaBuilder(getKafkaCrd())\n+                .editOrNewSpec()\n+                    .editOrNewKafka()\n+                        .withNewPersistentClaimStorage()\n+                            .withNewSize(\"100Gi\")\n+                        .endPersistentClaimStorage()\n+                    .endKafka()\n+                .endSpec()\n+                .build();\n+        KafkaCluster kafkaCluster = KafkaCluster.fromCrd(oldKafka, VERSIONS);\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(false);\n+\n+        // Mock the CRD Operator for Kafka resources\n+        CrdOperator mockKafkaOps = supplier.kafkaOperator;\n+        when(mockKafkaOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(kafka));\n+\n+        ArgumentCaptor<Kafka> kafkaCaptor = ArgumentCaptor.forClass(Kafka.class);\n+        when(mockKafkaOps.updateStatusAsync(kafkaCaptor.capture())).thenReturn(Future.succeededFuture());\n+\n+        // Mock the KafkaSetOperator\n+        KafkaSetOperator mockKafkaSetOps = supplier.kafkaSetOperations;\n+        when(mockKafkaSetOps.getAsync(eq(namespace), eq(KafkaCluster.kafkaClusterName(clusterName)))).thenReturn(Future.succeededFuture(kafkaCluster.generateStatefulSet(false, null, null)));\n+\n+        // Mock the ConfigMapOperator\n+        ConfigMapOperator mockCmOps = supplier.configMapOperations;\n+        when(mockCmOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(kafkaCluster.generateMetricsAndLogConfigMap(null)));\n+\n+        // Mock Pods Operator\n+        /*Pod pod0 = new PodBuilder()\n+                .withNewMetadata()\n+                .withNewName(clusterName + \"-kafka-\" + 0)\n+                .endMetadata()\n+                .withNewStatus()\n+                .withNewHostIP(\"10.0.0.1\")\n+                .endStatus()\n+                .build();\n+\n+        Pod pod1 = new PodBuilder()\n+                .withNewMetadata()\n+                .withNewName(clusterName + \"-kafka-\" + 1)\n+                .endMetadata()\n+                .withNewStatus()\n+                .withNewHostIP(\"10.0.0.1\")\n+                .endStatus()\n+                .build();\n+\n+        Pod pod2 = new PodBuilder()\n+                .withNewMetadata()\n+                .withNewName(clusterName + \"-kafka-\" + 2)\n+                .endMetadata()\n+                .withNewStatus()\n+                .withNewHostIP(\"10.0.0.1\")\n+                .endStatus()\n+                .build();\n+\n+        List<Pod> pods = new ArrayList<>();\n+        pods.add(pod0);\n+        pods.add(pod1);\n+        pods.add(pod2);\n+\n+        PodOperator mockPodOps = supplier.podOperations;\n+        when(mockPodOps.listAsync(eq(namespace), any(Labels.class))).thenReturn(Future.succeededFuture(pods));\n+\n+        // Mock Node operator\n+        NodeOperator mockNodeOps = supplier.nodeOperator;\n+        when(mockNodeOps.listAsync(any(Labels.class))).thenReturn(Future.succeededFuture(getClusterNodes()));*/", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMTQyOA=="}, "originalCommit": {"oid": "874b8634cd069081bcf2b65e2c15fadef29ebd7f"}, "originalPosition": 84}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 155, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}