{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxMzI2NjAz", "number": 2721, "title": "Add automatic scaling of Zookeeper 3.5", "bodyText": "Type of change\n\nBugfix\nEnhancement / new feature\n\nDescription\nThis PR fixes the manual scaling of Zookeeper 3.5 limitation. When Zookeeper 3.5 is used, it now uses the ZooKeeperAdmin API to configure the members of the cluster dynamically. They mostly follow the manual guide by @tomncooper.\nThe scaling methods are separate for 3.4 and 3.5. That should make it easy to remvoe 3.4 in the future. We should anyway get back to this after support for 3.4 is dropped. One of the big limitations this PR needed to work around were the TLS sidecars which need restart to reconfigure (=> to add new nodes). Once we support 3.5 only, we should try to get rid of the sidecars and make the scaling restart less.\nThis PR also adds some tests - but the actual scalign is done mainly in system tests. The unit tests use mostly mocks. The tests are based on two separate providers whcih allow to inject mocked ZookeeperScaler and mocked ZooKeeperAdmin to test different parts of the operator.\nAs part of this I did some smaller notable changes:\n\nSome helper methods from the DefaultAdminClientProvider were moved to Util so that they can be reused\nZoo doesn't roll based on changes in spec.replicas. This is not needed, because the number of replicas is covered in environment variable. It was also causing unnecessary rolling updates the initial reconciliation failed.\nI added a dependency with the Lunux x86_64 epoll for Netty\nNew hostname was added to the Zoo certificates to allow the connections to specific nodes\nI surpressed some log messages from the ZooKeeperAdmin client. It by default first verifies hostname ased on IP and only than based on hostame. The IP validation always fails and prints an exception in log every reconciliation at DEBUG level. This looked ugly and distracting, so I got rid of it since it was anyway expected exception.\n\nChecklist\n\n Write tests\n Make sure all tests pass\n Try your changes from Pod inside your Kubernetes and OpenShift cluster, not just locally", "createdAt": "2020-03-20T02:57:59Z", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721", "merged": true, "mergeCommit": {"oid": "30253b746e9279f777c0e9ba986e25b27849fee9"}, "closed": true, "closedAt": "2020-03-21T00:08:21Z", "author": {"login": "scholzj"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcPXYBWAH2gAyMzkxMzI2NjAzOmU0ZDVlNmY3MDNmOTljNzUyMDdhOWNhNjBkOTlmMDZkMDU5ZTRjNWM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcPjZedgH2gAyMzkxMzI2NjAzOjMxZmFkOTc4OGU1MmJkYmRjZWYzMWY0ZTk1NzA2NWI1YmI3ZjJmMjk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e4d5e6f703f99c75207a9ca60d99f06d059e4c5c", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e4d5e6f703f99c75207a9ca60d99f06d059e4c5c", "committedDate": "2020-03-20T02:49:00Z", "message": "Add automatic scaling of Zookeeper 3.5\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/85c321d7a2a2e18d8103073defb1a8f9111492c2", "committedDate": "2020-03-20T02:57:48Z", "message": "Remove methods which did not get used at the end\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4MjY4NDMw", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#pullrequestreview-378268430", "createdAt": "2020-03-20T07:20:01Z", "commit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwNzoyMDowMVrOF5Jd7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwNzo1MTowOFrOF5KDOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ2ODI2OQ==", "bodyText": "Can you javadoc which suffix the result is without?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395468269", "createdAt": "2020-03-20T07:20:01Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ZookeeperCluster.java", "diffHunk": "@@ -126,6 +125,13 @@ public static String podDnsName(String namespace, String cluster, int podId) {\n                 ModelUtils.KUBERNETES_SERVICE_DNS_DOMAIN);\n     }\n \n+    public static String podDnsNameWithoutSuffix(String namespace, String cluster, int podId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ2ODQ4NQ==", "bodyText": "Elsewhere we use zk as the abbreviation for ZooKeeper. I think we should be consistent.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395468485", "createdAt": "2020-03-20T07:20:42Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -154,6 +158,7 @@\n     private final StorageClassOperator storageClassOperator;\n     private final NodeOperator nodeOperator;\n     private final CrdOperator<KubernetesClient, Kafka, KafkaList, DoneableKafka> crdOperator;\n+    private final ZookeeperScalerProvider zooScalerProvider;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ2ODk0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * USed by the Zookeeper 3.5 Admin client for scaling\n          \n          \n            \n                     * Used by the Zookeeper 3.5 Admin client for scaling", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395468948", "createdAt": "2020-03-20T07:22:13Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1371,125 +1376,229 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n             StatefulSet zkSts = zkCluster.generateStatefulSet(pfa.isOpenshift(), imagePullPolicy, imagePullSecrets);\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(Ca.ANNO_STRIMZI_IO_CLUSTER_CA_CERT_GENERATION, String.valueOf(getCaCertGeneration(this.clusterCa)));\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(AbstractModel.ANNO_STRIMZI_LOGGING_HASH, zkLoggingHash);\n-            Annotations.annotations(zkSts).put(Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, String.valueOf(zkManualScaling));\n             return withZkDiff(zkSetOperations.reconcile(namespace, zkCluster.getName(), zkSts));\n         }\n \n         Future<ReconciliationState> zkRollingUpdate() {\n-            if (zkManualScaling && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n-                log.info(\"Skipping cluster roll due to ongoing manual scaling operations. \" +\n-                        \"If you have completed the manual scaling operation then set the \" +\n-                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" to false to re-enable rolling updates.\");\n-                return Future.succeededFuture(this);\n-            } else {\n-                log.debug(\"No manual scaling operation detected, continuing with ZK cluster roll\");\n-                return withVoid(zkSetOperations.maybeRollingUpdate(zkDiffs.resource(), pod ->\n-                        isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)));\n-            }\n+            // Scale-down and Scale-up might have change the STS. we should get a fresh one.\n+            return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n+                    .compose(sts -> zkSetOperations.maybeRollingUpdate(sts,\n+                        pod -> isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)))\n+                    .map(this);\n         }\n \n         /**\n-         * This method setups to the scaling behaviour for the zookeeper cluster.\n+         * Prepares the Zookeeper connectionString\n+         * The format is host1:port1,host2:port2,...\n          *\n-         * For 3.4.x clusters the scale by one -> roll cluster -> scale by one -> roll cluster method used.\n-         * Scaling up from N to M (N > 0 and M>N) replicas is done in M-N steps.\n-         * Each step performs scale up by one replica and full rolling update of Zookeeper cluster.\n-         * This approach ensures a valid configuration of each Zk pod.\n-         * Together with modified `maybeRollingUpdate` the quorum is not lost after the scale up operation is performed.\n-         * There is one special case of scaling from standalone (single one) Zookeeper pod.\n-         * In this case quorum cannot be preserved.\n+         * USed by the Zookeeper 3.5 Admin client for scaling", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ2OTAzOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * @param connectToReplicas     Number of replicas form the ZK STS which should be used\n          \n          \n            \n                     * @param connectToReplicas     Number of replicas from the ZK STS which should be used", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395469038", "createdAt": "2020-03-20T07:22:31Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1371,125 +1376,229 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n             StatefulSet zkSts = zkCluster.generateStatefulSet(pfa.isOpenshift(), imagePullPolicy, imagePullSecrets);\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(Ca.ANNO_STRIMZI_IO_CLUSTER_CA_CERT_GENERATION, String.valueOf(getCaCertGeneration(this.clusterCa)));\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(AbstractModel.ANNO_STRIMZI_LOGGING_HASH, zkLoggingHash);\n-            Annotations.annotations(zkSts).put(Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, String.valueOf(zkManualScaling));\n             return withZkDiff(zkSetOperations.reconcile(namespace, zkCluster.getName(), zkSts));\n         }\n \n         Future<ReconciliationState> zkRollingUpdate() {\n-            if (zkManualScaling && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n-                log.info(\"Skipping cluster roll due to ongoing manual scaling operations. \" +\n-                        \"If you have completed the manual scaling operation then set the \" +\n-                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" to false to re-enable rolling updates.\");\n-                return Future.succeededFuture(this);\n-            } else {\n-                log.debug(\"No manual scaling operation detected, continuing with ZK cluster roll\");\n-                return withVoid(zkSetOperations.maybeRollingUpdate(zkDiffs.resource(), pod ->\n-                        isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)));\n-            }\n+            // Scale-down and Scale-up might have change the STS. we should get a fresh one.\n+            return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n+                    .compose(sts -> zkSetOperations.maybeRollingUpdate(sts,\n+                        pod -> isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)))\n+                    .map(this);\n         }\n \n         /**\n-         * This method setups to the scaling behaviour for the zookeeper cluster.\n+         * Prepares the Zookeeper connectionString\n+         * The format is host1:port1,host2:port2,...\n          *\n-         * For 3.4.x clusters the scale by one -> roll cluster -> scale by one -> roll cluster method used.\n-         * Scaling up from N to M (N > 0 and M>N) replicas is done in M-N steps.\n-         * Each step performs scale up by one replica and full rolling update of Zookeeper cluster.\n-         * This approach ensures a valid configuration of each Zk pod.\n-         * Together with modified `maybeRollingUpdate` the quorum is not lost after the scale up operation is performed.\n-         * There is one special case of scaling from standalone (single one) Zookeeper pod.\n-         * In this case quorum cannot be preserved.\n+         * USed by the Zookeeper 3.5 Admin client for scaling\n          *\n-         * For 3.5.x clusters scaling is limited to one server at a time (or an exception is thrown) and currently\n-         * requires user intervention to manually add/remove servers to/from the quorum.\n+         * @param connectToReplicas     Number of replicas form the ZK STS which should be used", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ2OTMwNg==", "bodyText": "Long line", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395469306", "createdAt": "2020-03-20T07:23:17Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1371,125 +1376,229 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n             StatefulSet zkSts = zkCluster.generateStatefulSet(pfa.isOpenshift(), imagePullPolicy, imagePullSecrets);\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(Ca.ANNO_STRIMZI_IO_CLUSTER_CA_CERT_GENERATION, String.valueOf(getCaCertGeneration(this.clusterCa)));\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(AbstractModel.ANNO_STRIMZI_LOGGING_HASH, zkLoggingHash);\n-            Annotations.annotations(zkSts).put(Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, String.valueOf(zkManualScaling));\n             return withZkDiff(zkSetOperations.reconcile(namespace, zkCluster.getName(), zkSts));\n         }\n \n         Future<ReconciliationState> zkRollingUpdate() {\n-            if (zkManualScaling && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n-                log.info(\"Skipping cluster roll due to ongoing manual scaling operations. \" +\n-                        \"If you have completed the manual scaling operation then set the \" +\n-                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" to false to re-enable rolling updates.\");\n-                return Future.succeededFuture(this);\n-            } else {\n-                log.debug(\"No manual scaling operation detected, continuing with ZK cluster roll\");\n-                return withVoid(zkSetOperations.maybeRollingUpdate(zkDiffs.resource(), pod ->\n-                        isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)));\n-            }\n+            // Scale-down and Scale-up might have change the STS. we should get a fresh one.\n+            return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n+                    .compose(sts -> zkSetOperations.maybeRollingUpdate(sts,\n+                        pod -> isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)))\n+                    .map(this);\n         }\n \n         /**\n-         * This method setups to the scaling behaviour for the zookeeper cluster.\n+         * Prepares the Zookeeper connectionString\n+         * The format is host1:port1,host2:port2,...\n          *\n-         * For 3.4.x clusters the scale by one -> roll cluster -> scale by one -> roll cluster method used.\n-         * Scaling up from N to M (N > 0 and M>N) replicas is done in M-N steps.\n-         * Each step performs scale up by one replica and full rolling update of Zookeeper cluster.\n-         * This approach ensures a valid configuration of each Zk pod.\n-         * Together with modified `maybeRollingUpdate` the quorum is not lost after the scale up operation is performed.\n-         * There is one special case of scaling from standalone (single one) Zookeeper pod.\n-         * In this case quorum cannot be preserved.\n+         * USed by the Zookeeper 3.5 Admin client for scaling\n          *\n-         * For 3.5.x clusters scaling is limited to one server at a time (or an exception is thrown) and currently\n-         * requires user intervention to manually add/remove servers to/from the quorum.\n+         * @param connectToReplicas     Number of replicas form the ZK STS which should be used\n+         * @return                      The generated Zookeeper connection string\n          */\n-        Future<ReconciliationState> zkScalingSetup() {\n-            return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .compose(sts -> {\n-                        if (sts != null) {\n-                            int currentReplicas = sts.getSpec().getReplicas();\n-                            int desiredReplicas = zkCluster.getReplicas();\n-                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n-                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n-\n-                            if (isZK35x && replicaDiff > 1) {\n-                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n-                                // then log the error and throw an exception halting the reconciliation.\n-                                String scaleErrorMessage = String.format(\n-                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n-                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n-                                                \"to one greater or lesser than the original value (%d).\",\n-                                        replicaDiff, currentReplicas);\n-\n-                                log.error(scaleErrorMessage);\n-\n-                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n-                            } else if (desiredReplicas > currentReplicas) {\n-                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n-                                // automatically. If it is 3.5 then it is limited to one at a time anyway by the check\n-                                // in the clause above.\n-                                zkCluster.setReplicas(currentReplicas + 1);\n-                                zkScalingUp = true;\n-                            } else if (desiredReplicas < currentReplicas) {\n-                                zkScalingDown = true;\n-                            }\n+        String zkConnectionString(int connectToReplicas)  {\n+            // Prepare Zoo connection string. We want to connect only to nodes which existed before\n+            // scaling and will exist after it is finished\n+            List<String> zooNodes = new ArrayList<>(connectToReplicas);\n \n-                            ConditionBuilder zkManualScalingCondition = null;\n-\n-                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n-                                // This is a scale up or down of a ZK 3.5.x cluster\n-                                String scaleMessage = String.format(\n-                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n-                                        \"update process defined in the documentation should be followed. When finished set \" +\n-                                         \"%s annotation on the Zookeeper StatefulSet to false.\",\n-                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n-\n-                                log.info(scaleMessage);\n-\n-                                zkManualScalingCondition = new ConditionBuilder()\n-                                        .withLastTransitionTime(ModelUtils.formatTimestamp(dateSupplier()))\n-                                        .withType(\"ZK-Manual-Scaling\")\n-                                        .withReason(\"replicaChange\")\n-                                        .withStatus(\"True\")\n-                                        .withMessage(scaleMessage);\n-\n-                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n-                                zkManualScaling = true;\n-                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n-                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n-                                // only the user can set it to false.\n-                                String scaleMessage = String.format(\"Detected manual Zookeeper 3.5.x scaling operation in progress. \" +\n-                                                \"After following the manual process defined in the documentation, set %s annotation on the \" +\n-                                                \"Zookeeper stateful set to false.\",\n-                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n-\n-                                log.info(scaleMessage);\n-\n-                                zkManualScalingCondition = new ConditionBuilder()\n-                                        .withLastTransitionTime(ModelUtils.formatTimestamp(dateSupplier()))\n-                                        .withType(\"ZK-Manual-Scaling\")\n-                                        .withReason(\"manualScaleAnnotationSet\")\n-                                        .withStatus(\"True\")\n-                                        .withMessage(scaleMessage);\n-\n-                                zkManualScaling = true;\n-                            } else {\n-                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n-                                zkManualScaling = false;\n-                            }\n+            for (int i = 0; i < connectToReplicas; i++)   {\n+                zooNodes.add(String.format(\"%s.%s.%s.svc:%d\", zkCluster.getPodName(i), KafkaResources.zookeeperHeadlessServiceName(name), namespace, ZookeeperCluster.CLIENT_PORT));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ2OTU5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * for given cluster. The ZookeeperScaler instance created by this method should be clsoe dmanually after it is\n          \n          \n            \n                     * for the given cluster. The ZookeeperScaler instance created by this method should be closed manually after it is", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395469591", "createdAt": "2020-03-20T07:24:04Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1371,125 +1376,229 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n             StatefulSet zkSts = zkCluster.generateStatefulSet(pfa.isOpenshift(), imagePullPolicy, imagePullSecrets);\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(Ca.ANNO_STRIMZI_IO_CLUSTER_CA_CERT_GENERATION, String.valueOf(getCaCertGeneration(this.clusterCa)));\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(AbstractModel.ANNO_STRIMZI_LOGGING_HASH, zkLoggingHash);\n-            Annotations.annotations(zkSts).put(Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, String.valueOf(zkManualScaling));\n             return withZkDiff(zkSetOperations.reconcile(namespace, zkCluster.getName(), zkSts));\n         }\n \n         Future<ReconciliationState> zkRollingUpdate() {\n-            if (zkManualScaling && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n-                log.info(\"Skipping cluster roll due to ongoing manual scaling operations. \" +\n-                        \"If you have completed the manual scaling operation then set the \" +\n-                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" to false to re-enable rolling updates.\");\n-                return Future.succeededFuture(this);\n-            } else {\n-                log.debug(\"No manual scaling operation detected, continuing with ZK cluster roll\");\n-                return withVoid(zkSetOperations.maybeRollingUpdate(zkDiffs.resource(), pod ->\n-                        isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)));\n-            }\n+            // Scale-down and Scale-up might have change the STS. we should get a fresh one.\n+            return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n+                    .compose(sts -> zkSetOperations.maybeRollingUpdate(sts,\n+                        pod -> isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)))\n+                    .map(this);\n         }\n \n         /**\n-         * This method setups to the scaling behaviour for the zookeeper cluster.\n+         * Prepares the Zookeeper connectionString\n+         * The format is host1:port1,host2:port2,...\n          *\n-         * For 3.4.x clusters the scale by one -> roll cluster -> scale by one -> roll cluster method used.\n-         * Scaling up from N to M (N > 0 and M>N) replicas is done in M-N steps.\n-         * Each step performs scale up by one replica and full rolling update of Zookeeper cluster.\n-         * This approach ensures a valid configuration of each Zk pod.\n-         * Together with modified `maybeRollingUpdate` the quorum is not lost after the scale up operation is performed.\n-         * There is one special case of scaling from standalone (single one) Zookeeper pod.\n-         * In this case quorum cannot be preserved.\n+         * USed by the Zookeeper 3.5 Admin client for scaling\n          *\n-         * For 3.5.x clusters scaling is limited to one server at a time (or an exception is thrown) and currently\n-         * requires user intervention to manually add/remove servers to/from the quorum.\n+         * @param connectToReplicas     Number of replicas form the ZK STS which should be used\n+         * @return                      The generated Zookeeper connection string\n          */\n-        Future<ReconciliationState> zkScalingSetup() {\n-            return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .compose(sts -> {\n-                        if (sts != null) {\n-                            int currentReplicas = sts.getSpec().getReplicas();\n-                            int desiredReplicas = zkCluster.getReplicas();\n-                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n-                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n-\n-                            if (isZK35x && replicaDiff > 1) {\n-                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n-                                // then log the error and throw an exception halting the reconciliation.\n-                                String scaleErrorMessage = String.format(\n-                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n-                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n-                                                \"to one greater or lesser than the original value (%d).\",\n-                                        replicaDiff, currentReplicas);\n-\n-                                log.error(scaleErrorMessage);\n-\n-                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n-                            } else if (desiredReplicas > currentReplicas) {\n-                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n-                                // automatically. If it is 3.5 then it is limited to one at a time anyway by the check\n-                                // in the clause above.\n-                                zkCluster.setReplicas(currentReplicas + 1);\n-                                zkScalingUp = true;\n-                            } else if (desiredReplicas < currentReplicas) {\n-                                zkScalingDown = true;\n-                            }\n+        String zkConnectionString(int connectToReplicas)  {\n+            // Prepare Zoo connection string. We want to connect only to nodes which existed before\n+            // scaling and will exist after it is finished\n+            List<String> zooNodes = new ArrayList<>(connectToReplicas);\n \n-                            ConditionBuilder zkManualScalingCondition = null;\n-\n-                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n-                                // This is a scale up or down of a ZK 3.5.x cluster\n-                                String scaleMessage = String.format(\n-                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n-                                        \"update process defined in the documentation should be followed. When finished set \" +\n-                                         \"%s annotation on the Zookeeper StatefulSet to false.\",\n-                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n-\n-                                log.info(scaleMessage);\n-\n-                                zkManualScalingCondition = new ConditionBuilder()\n-                                        .withLastTransitionTime(ModelUtils.formatTimestamp(dateSupplier()))\n-                                        .withType(\"ZK-Manual-Scaling\")\n-                                        .withReason(\"replicaChange\")\n-                                        .withStatus(\"True\")\n-                                        .withMessage(scaleMessage);\n-\n-                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n-                                zkManualScaling = true;\n-                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n-                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n-                                // only the user can set it to false.\n-                                String scaleMessage = String.format(\"Detected manual Zookeeper 3.5.x scaling operation in progress. \" +\n-                                                \"After following the manual process defined in the documentation, set %s annotation on the \" +\n-                                                \"Zookeeper stateful set to false.\",\n-                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n-\n-                                log.info(scaleMessage);\n-\n-                                zkManualScalingCondition = new ConditionBuilder()\n-                                        .withLastTransitionTime(ModelUtils.formatTimestamp(dateSupplier()))\n-                                        .withType(\"ZK-Manual-Scaling\")\n-                                        .withReason(\"manualScaleAnnotationSet\")\n-                                        .withStatus(\"True\")\n-                                        .withMessage(scaleMessage);\n-\n-                                zkManualScaling = true;\n-                            } else {\n-                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n-                                zkManualScaling = false;\n-                            }\n+            for (int i = 0; i < connectToReplicas; i++)   {\n+                zooNodes.add(String.format(\"%s.%s.%s.svc:%d\", zkCluster.getPodName(i), KafkaResources.zookeeperHeadlessServiceName(name), namespace, ZookeeperCluster.CLIENT_PORT));\n+            }\n \n-                            if (zkManualScalingCondition != null && isZK35x) {\n-                                this.kafkaStatus.addCondition(zkManualScalingCondition.build());\n-                            }\n+            return  String.join(\",\", zooNodes);\n+        }\n+\n+        /**\n+         * Helper method for getting the required secrets with certificates and creating the ZookeeperScaler instance\n+         * for given cluster. The ZookeeperScaler instance created by this method should be clsoe dmanually after it is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3MjI4MA==", "bodyText": "Why currentServers and not currentConfiguration?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395472280", "createdAt": "2020-03-20T07:33:26Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(ignore -> getConfig())\n+                .compose(servers -> scaleTo(servers, scaleTo))\n+                .compose(ignore -> closeConnectionAsync());\n+    }\n+\n+    /**\n+     * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes\n+     * the certificate files.\n+     */\n+    @Override\n+    public void close() {\n+        closeConnectionSync();\n+\n+        if (trustStoreFile != null) {\n+            if (!trustStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", trustStoreFile);\n+            }\n+        }\n+\n+        if (keyStoreFile != null)   {\n+            if (!keyStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", keyStoreFile);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method used to create the Zookeeper Admin client and connect it to Zookeeper\n+     *\n+     * @return      Future indicating success or failure\n+     */\n+    private Future<Void> connect()    {\n+        Promise<Void> connected = Promise.promise();\n+\n+        try {\n+            long timer = vertx.setTimer(operationTimeoutMs, ignored -> {\n+                if (!connected.future().isComplete()) {\n+                    log.debug(\"Failed to connected to {} to scale Zookeeper for {} ms. The connection will be closed.\", this.zookeeperConnectionString, operationTimeoutMs);\n+                    closeConnectionSync();\n+                    connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + this.zookeeperConnectionString + \" for \" + operationTimeoutMs + \" ms\"));\n+                }\n+            });\n+\n+            zkAdmin = zooAdminProvider.createZookeeperAdmin(this.zookeeperConnectionString, 10_000, watchedEvent -> {\n+                switch (watchedEvent.getState()) {\n+                    case SyncConnected:\n+                        if (!connected.future().isComplete()) {\n+                            log.debug(\"Successfully connected to {} to scale Zookeeper\", zookeeperConnectionString);\n+                            connected.tryComplete();\n+                        }\n+                        break;\n+                    default:\n+                        if (!connected.future().isComplete()) {\n+                            log.warn(\"Failed to connect to {} to scale Zookeeper because of state {}\", zookeeperConnectionString, watchedEvent.getState());\n+                            closeConnectionSync();\n+                            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \" - got state \" + watchedEvent.getState()));\n+                        }\n+                }\n+\n+                vertx.cancelTimer(timer);\n+            }, getClientConfig());\n+        } catch (IOException e)   {\n+            log.warn(\"Failed to connect to {} to scale Zookeeper\", zookeeperConnectionString, e);\n+            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString, e));\n+        }\n+\n+        return connected.future();\n+    }\n+\n+    /**\n+     * Internal method to scale Zookeeper up or down or check configuration. It will:\n+     *     1) Compare the current configuration with the desired configuration\n+     *     2) Update the configuration if needed\n+     *\n+     * @param currentServers    Current configuration", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3Mjk1MQ==", "bodyText": "Probably worth having a ZookeeperScalingException if these can end up in the status of the CR.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395472951", "createdAt": "2020-03-20T07:35:49Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(ignore -> getConfig())\n+                .compose(servers -> scaleTo(servers, scaleTo))\n+                .compose(ignore -> closeConnectionAsync());\n+    }\n+\n+    /**\n+     * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes\n+     * the certificate files.\n+     */\n+    @Override\n+    public void close() {\n+        closeConnectionSync();\n+\n+        if (trustStoreFile != null) {\n+            if (!trustStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", trustStoreFile);\n+            }\n+        }\n+\n+        if (keyStoreFile != null)   {\n+            if (!keyStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", keyStoreFile);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method used to create the Zookeeper Admin client and connect it to Zookeeper\n+     *\n+     * @return      Future indicating success or failure\n+     */\n+    private Future<Void> connect()    {\n+        Promise<Void> connected = Promise.promise();\n+\n+        try {\n+            long timer = vertx.setTimer(operationTimeoutMs, ignored -> {\n+                if (!connected.future().isComplete()) {\n+                    log.debug(\"Failed to connected to {} to scale Zookeeper for {} ms. The connection will be closed.\", this.zookeeperConnectionString, operationTimeoutMs);\n+                    closeConnectionSync();\n+                    connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + this.zookeeperConnectionString + \" for \" + operationTimeoutMs + \" ms\"));\n+                }\n+            });\n+\n+            zkAdmin = zooAdminProvider.createZookeeperAdmin(this.zookeeperConnectionString, 10_000, watchedEvent -> {\n+                switch (watchedEvent.getState()) {\n+                    case SyncConnected:\n+                        if (!connected.future().isComplete()) {\n+                            log.debug(\"Successfully connected to {} to scale Zookeeper\", zookeeperConnectionString);\n+                            connected.tryComplete();\n+                        }\n+                        break;\n+                    default:\n+                        if (!connected.future().isComplete()) {\n+                            log.warn(\"Failed to connect to {} to scale Zookeeper because of state {}\", zookeeperConnectionString, watchedEvent.getState());\n+                            closeConnectionSync();\n+                            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \" - got state \" + watchedEvent.getState()));\n+                        }\n+                }\n+\n+                vertx.cancelTimer(timer);\n+            }, getClientConfig());\n+        } catch (IOException e)   {\n+            log.warn(\"Failed to connect to {} to scale Zookeeper\", zookeeperConnectionString, e);\n+            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString, e));\n+        }\n+\n+        return connected.future();\n+    }\n+\n+    /**\n+     * Internal method to scale Zookeeper up or down or check configuration. It will:\n+     *     1) Compare the current configuration with the desired configuration\n+     *     2) Update the configuration if needed\n+     *\n+     * @param currentServers    Current configuration\n+     * @param scaleTo           Desired scale\n+     * @return                  Future indicating success or failure\n+     */\n+    private Future<Void> scaleTo(Map<String, String> currentServers, int scaleTo) {\n+        Map<String, String> desiredServers = generateConfig(scaleTo);\n+\n+        if (isDifferent(currentServers, desiredServers))    {\n+            log.debug(\"The Zookeeper server configuration needs to be updated\");\n+            return updateConfig(desiredServers).map((Void) null);\n+        } else {\n+            log.debug(\"The Zookeeper server configuration is already up to date\");\n+            return Future.succeededFuture();\n+        }\n+    }\n+\n+    /**\n+     * Gets the current configuration from Zookeeper.\n+     *\n+     * @return  Future containing Map with the current Zookeeper configuration\n+     */\n+    private Future<Map<String, String>> getConfig()    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                byte[] config = zkAdmin.getConfig(false, null);\n+                Map<String, String> servers = parseConfig(config);\n+                log.debug(\"Current Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to get current Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to get current Zookeeper server configuration\", e));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3MzE0OQ==", "bodyText": "Timeout?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395473149", "createdAt": "2020-03-20T07:36:26Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(ignore -> getConfig())\n+                .compose(servers -> scaleTo(servers, scaleTo))\n+                .compose(ignore -> closeConnectionAsync());\n+    }\n+\n+    /**\n+     * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes\n+     * the certificate files.\n+     */\n+    @Override\n+    public void close() {\n+        closeConnectionSync();\n+\n+        if (trustStoreFile != null) {\n+            if (!trustStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", trustStoreFile);\n+            }\n+        }\n+\n+        if (keyStoreFile != null)   {\n+            if (!keyStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", keyStoreFile);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method used to create the Zookeeper Admin client and connect it to Zookeeper\n+     *\n+     * @return      Future indicating success or failure\n+     */\n+    private Future<Void> connect()    {\n+        Promise<Void> connected = Promise.promise();\n+\n+        try {\n+            long timer = vertx.setTimer(operationTimeoutMs, ignored -> {\n+                if (!connected.future().isComplete()) {\n+                    log.debug(\"Failed to connected to {} to scale Zookeeper for {} ms. The connection will be closed.\", this.zookeeperConnectionString, operationTimeoutMs);\n+                    closeConnectionSync();\n+                    connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + this.zookeeperConnectionString + \" for \" + operationTimeoutMs + \" ms\"));\n+                }\n+            });\n+\n+            zkAdmin = zooAdminProvider.createZookeeperAdmin(this.zookeeperConnectionString, 10_000, watchedEvent -> {\n+                switch (watchedEvent.getState()) {\n+                    case SyncConnected:\n+                        if (!connected.future().isComplete()) {\n+                            log.debug(\"Successfully connected to {} to scale Zookeeper\", zookeeperConnectionString);\n+                            connected.tryComplete();\n+                        }\n+                        break;\n+                    default:\n+                        if (!connected.future().isComplete()) {\n+                            log.warn(\"Failed to connect to {} to scale Zookeeper because of state {}\", zookeeperConnectionString, watchedEvent.getState());\n+                            closeConnectionSync();\n+                            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \" - got state \" + watchedEvent.getState()));\n+                        }\n+                }\n+\n+                vertx.cancelTimer(timer);\n+            }, getClientConfig());\n+        } catch (IOException e)   {\n+            log.warn(\"Failed to connect to {} to scale Zookeeper\", zookeeperConnectionString, e);\n+            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString, e));\n+        }\n+\n+        return connected.future();\n+    }\n+\n+    /**\n+     * Internal method to scale Zookeeper up or down or check configuration. It will:\n+     *     1) Compare the current configuration with the desired configuration\n+     *     2) Update the configuration if needed\n+     *\n+     * @param currentServers    Current configuration\n+     * @param scaleTo           Desired scale\n+     * @return                  Future indicating success or failure\n+     */\n+    private Future<Void> scaleTo(Map<String, String> currentServers, int scaleTo) {\n+        Map<String, String> desiredServers = generateConfig(scaleTo);\n+\n+        if (isDifferent(currentServers, desiredServers))    {\n+            log.debug(\"The Zookeeper server configuration needs to be updated\");\n+            return updateConfig(desiredServers).map((Void) null);\n+        } else {\n+            log.debug(\"The Zookeeper server configuration is already up to date\");\n+            return Future.succeededFuture();\n+        }\n+    }\n+\n+    /**\n+     * Gets the current configuration from Zookeeper.\n+     *\n+     * @return  Future containing Map with the current Zookeeper configuration\n+     */\n+    private Future<Map<String, String>> getConfig()    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                byte[] config = zkAdmin.getConfig(false, null);\n+                Map<String, String> servers = parseConfig(config);\n+                log.debug(\"Current Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to get current Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to get current Zookeeper server configuration\", e));\n+            }\n+        }, false, configPromise);\n+\n+        return configPromise.future();\n+    }\n+\n+    /**\n+     * Updates the configuration in the Zookeeper cluster\n+     *\n+     * @param newServers    New configuration which will be used for the update\n+     * @return              Future with the updated configuration\n+     */\n+    private Future<Map<String, String>> updateConfig(Map<String, String> newServers)    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                log.debug(\"Updating Zookeeper configuration to {}\", newServers);\n+                byte[] newConfig = zkAdmin.reconfigure(null, null, serversMapToList(newServers), -1, null);\n+                Map<String, String> servers = parseConfig(newConfig);\n+\n+                log.debug(\"New Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to update Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to update Zookeeper server configuration\", e));\n+            }\n+        }, false, configPromise);\n+\n+        return configPromise.future();\n+    }\n+\n+    /**\n+     * Closes the Zookeeper connection asynchronously\n+     *\n+     * @return\n+     */\n+    private Future<Void> closeConnectionAsync() {\n+        Promise<Void> closePromise = Promise.promise();\n+\n+        log.debug(\"Closing Zookeeper connection to {}\", zookeeperConnectionString);\n+\n+        vertx.executeBlocking(promise -> {\n+            closeConnectionSync();\n+            promise.complete();\n+        }, true, closePromise);\n+\n+        return closePromise.future();\n+    }\n+\n+    /**\n+     * Closes the Zookeeper connection synchronously\n+     */\n+    private void closeConnectionSync() {\n+        if (zkAdmin != null)    {\n+            try {\n+                zkAdmin.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3Mzc1NQ==", "bodyText": "I guess quoting is not necessary? Value can never contain and \\n, right? And I assume key can never contain =.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395473755", "createdAt": "2020-03-20T07:38:14Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(ignore -> getConfig())\n+                .compose(servers -> scaleTo(servers, scaleTo))\n+                .compose(ignore -> closeConnectionAsync());\n+    }\n+\n+    /**\n+     * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes\n+     * the certificate files.\n+     */\n+    @Override\n+    public void close() {\n+        closeConnectionSync();\n+\n+        if (trustStoreFile != null) {\n+            if (!trustStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", trustStoreFile);\n+            }\n+        }\n+\n+        if (keyStoreFile != null)   {\n+            if (!keyStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", keyStoreFile);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method used to create the Zookeeper Admin client and connect it to Zookeeper\n+     *\n+     * @return      Future indicating success or failure\n+     */\n+    private Future<Void> connect()    {\n+        Promise<Void> connected = Promise.promise();\n+\n+        try {\n+            long timer = vertx.setTimer(operationTimeoutMs, ignored -> {\n+                if (!connected.future().isComplete()) {\n+                    log.debug(\"Failed to connected to {} to scale Zookeeper for {} ms. The connection will be closed.\", this.zookeeperConnectionString, operationTimeoutMs);\n+                    closeConnectionSync();\n+                    connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + this.zookeeperConnectionString + \" for \" + operationTimeoutMs + \" ms\"));\n+                }\n+            });\n+\n+            zkAdmin = zooAdminProvider.createZookeeperAdmin(this.zookeeperConnectionString, 10_000, watchedEvent -> {\n+                switch (watchedEvent.getState()) {\n+                    case SyncConnected:\n+                        if (!connected.future().isComplete()) {\n+                            log.debug(\"Successfully connected to {} to scale Zookeeper\", zookeeperConnectionString);\n+                            connected.tryComplete();\n+                        }\n+                        break;\n+                    default:\n+                        if (!connected.future().isComplete()) {\n+                            log.warn(\"Failed to connect to {} to scale Zookeeper because of state {}\", zookeeperConnectionString, watchedEvent.getState());\n+                            closeConnectionSync();\n+                            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \" - got state \" + watchedEvent.getState()));\n+                        }\n+                }\n+\n+                vertx.cancelTimer(timer);\n+            }, getClientConfig());\n+        } catch (IOException e)   {\n+            log.warn(\"Failed to connect to {} to scale Zookeeper\", zookeeperConnectionString, e);\n+            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString, e));\n+        }\n+\n+        return connected.future();\n+    }\n+\n+    /**\n+     * Internal method to scale Zookeeper up or down or check configuration. It will:\n+     *     1) Compare the current configuration with the desired configuration\n+     *     2) Update the configuration if needed\n+     *\n+     * @param currentServers    Current configuration\n+     * @param scaleTo           Desired scale\n+     * @return                  Future indicating success or failure\n+     */\n+    private Future<Void> scaleTo(Map<String, String> currentServers, int scaleTo) {\n+        Map<String, String> desiredServers = generateConfig(scaleTo);\n+\n+        if (isDifferent(currentServers, desiredServers))    {\n+            log.debug(\"The Zookeeper server configuration needs to be updated\");\n+            return updateConfig(desiredServers).map((Void) null);\n+        } else {\n+            log.debug(\"The Zookeeper server configuration is already up to date\");\n+            return Future.succeededFuture();\n+        }\n+    }\n+\n+    /**\n+     * Gets the current configuration from Zookeeper.\n+     *\n+     * @return  Future containing Map with the current Zookeeper configuration\n+     */\n+    private Future<Map<String, String>> getConfig()    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                byte[] config = zkAdmin.getConfig(false, null);\n+                Map<String, String> servers = parseConfig(config);\n+                log.debug(\"Current Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to get current Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to get current Zookeeper server configuration\", e));\n+            }\n+        }, false, configPromise);\n+\n+        return configPromise.future();\n+    }\n+\n+    /**\n+     * Updates the configuration in the Zookeeper cluster\n+     *\n+     * @param newServers    New configuration which will be used for the update\n+     * @return              Future with the updated configuration\n+     */\n+    private Future<Map<String, String>> updateConfig(Map<String, String> newServers)    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                log.debug(\"Updating Zookeeper configuration to {}\", newServers);\n+                byte[] newConfig = zkAdmin.reconfigure(null, null, serversMapToList(newServers), -1, null);\n+                Map<String, String> servers = parseConfig(newConfig);\n+\n+                log.debug(\"New Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to update Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to update Zookeeper server configuration\", e));\n+            }\n+        }, false, configPromise);\n+\n+        return configPromise.future();\n+    }\n+\n+    /**\n+     * Closes the Zookeeper connection asynchronously\n+     *\n+     * @return\n+     */\n+    private Future<Void> closeConnectionAsync() {\n+        Promise<Void> closePromise = Promise.promise();\n+\n+        log.debug(\"Closing Zookeeper connection to {}\", zookeeperConnectionString);\n+\n+        vertx.executeBlocking(promise -> {\n+            closeConnectionSync();\n+            promise.complete();\n+        }, true, closePromise);\n+\n+        return closePromise.future();\n+    }\n+\n+    /**\n+     * Closes the Zookeeper connection synchronously\n+     */\n+    private void closeConnectionSync() {\n+        if (zkAdmin != null)    {\n+            try {\n+                zkAdmin.close();\n+            } catch (InterruptedException e) {\n+                log.warn(\"Failed to close the ZooKeeperAdmin\", e);\n+            } finally {\n+                zkAdmin = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates the TLS configuration for Zookeeper.\n+     *\n+     * @return\n+     */\n+    private ZKClientConfig getClientConfig()  {\n+        ZKClientConfig clientConfig = new ZKClientConfig();\n+\n+        clientConfig.setProperty(\"zookeeper.clientCnxnSocket\", \"org.apache.zookeeper.ClientCnxnSocketNetty\");\n+        clientConfig.setProperty(\"zookeeper.client.secure\", \"true\");\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.location\", trustStoreFile.getAbsolutePath());\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.password\", trustStorePassword);\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.type\", \"PKCS12\");\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.location\", keyStoreFile.getAbsolutePath());\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.password\", keyStorePassword);\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.type\", \"PKCS12\");\n+\n+        return clientConfig;\n+    }\n+\n+    /**\n+     * Converts the map with configuration to List of Strings which is the format in which the ZookeeperAdmin client\n+     * expects the new configuration.\n+     *\n+     * @param servers   Map with Zookeeper configuration\n+     * @return          List with Zookeeper configuration\n+     */\n+    /*test*/ static List<String> serversMapToList(Map<String, String> servers)  {\n+        List<String> serversList = new ArrayList<String>(servers.size());\n+\n+        for (Map.Entry entry : servers.entrySet())  {\n+            serversList.add(String.format(\"%s=%s\", entry.getKey(), entry.getValue()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3NDEwNw==", "bodyText": "It wasn't clear to me what \"During the parsing, only server configurations are used.\" meany until I read the code.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395474107", "createdAt": "2020-03-20T07:39:22Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(ignore -> getConfig())\n+                .compose(servers -> scaleTo(servers, scaleTo))\n+                .compose(ignore -> closeConnectionAsync());\n+    }\n+\n+    /**\n+     * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes\n+     * the certificate files.\n+     */\n+    @Override\n+    public void close() {\n+        closeConnectionSync();\n+\n+        if (trustStoreFile != null) {\n+            if (!trustStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", trustStoreFile);\n+            }\n+        }\n+\n+        if (keyStoreFile != null)   {\n+            if (!keyStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", keyStoreFile);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method used to create the Zookeeper Admin client and connect it to Zookeeper\n+     *\n+     * @return      Future indicating success or failure\n+     */\n+    private Future<Void> connect()    {\n+        Promise<Void> connected = Promise.promise();\n+\n+        try {\n+            long timer = vertx.setTimer(operationTimeoutMs, ignored -> {\n+                if (!connected.future().isComplete()) {\n+                    log.debug(\"Failed to connected to {} to scale Zookeeper for {} ms. The connection will be closed.\", this.zookeeperConnectionString, operationTimeoutMs);\n+                    closeConnectionSync();\n+                    connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + this.zookeeperConnectionString + \" for \" + operationTimeoutMs + \" ms\"));\n+                }\n+            });\n+\n+            zkAdmin = zooAdminProvider.createZookeeperAdmin(this.zookeeperConnectionString, 10_000, watchedEvent -> {\n+                switch (watchedEvent.getState()) {\n+                    case SyncConnected:\n+                        if (!connected.future().isComplete()) {\n+                            log.debug(\"Successfully connected to {} to scale Zookeeper\", zookeeperConnectionString);\n+                            connected.tryComplete();\n+                        }\n+                        break;\n+                    default:\n+                        if (!connected.future().isComplete()) {\n+                            log.warn(\"Failed to connect to {} to scale Zookeeper because of state {}\", zookeeperConnectionString, watchedEvent.getState());\n+                            closeConnectionSync();\n+                            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \" - got state \" + watchedEvent.getState()));\n+                        }\n+                }\n+\n+                vertx.cancelTimer(timer);\n+            }, getClientConfig());\n+        } catch (IOException e)   {\n+            log.warn(\"Failed to connect to {} to scale Zookeeper\", zookeeperConnectionString, e);\n+            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString, e));\n+        }\n+\n+        return connected.future();\n+    }\n+\n+    /**\n+     * Internal method to scale Zookeeper up or down or check configuration. It will:\n+     *     1) Compare the current configuration with the desired configuration\n+     *     2) Update the configuration if needed\n+     *\n+     * @param currentServers    Current configuration\n+     * @param scaleTo           Desired scale\n+     * @return                  Future indicating success or failure\n+     */\n+    private Future<Void> scaleTo(Map<String, String> currentServers, int scaleTo) {\n+        Map<String, String> desiredServers = generateConfig(scaleTo);\n+\n+        if (isDifferent(currentServers, desiredServers))    {\n+            log.debug(\"The Zookeeper server configuration needs to be updated\");\n+            return updateConfig(desiredServers).map((Void) null);\n+        } else {\n+            log.debug(\"The Zookeeper server configuration is already up to date\");\n+            return Future.succeededFuture();\n+        }\n+    }\n+\n+    /**\n+     * Gets the current configuration from Zookeeper.\n+     *\n+     * @return  Future containing Map with the current Zookeeper configuration\n+     */\n+    private Future<Map<String, String>> getConfig()    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                byte[] config = zkAdmin.getConfig(false, null);\n+                Map<String, String> servers = parseConfig(config);\n+                log.debug(\"Current Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to get current Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to get current Zookeeper server configuration\", e));\n+            }\n+        }, false, configPromise);\n+\n+        return configPromise.future();\n+    }\n+\n+    /**\n+     * Updates the configuration in the Zookeeper cluster\n+     *\n+     * @param newServers    New configuration which will be used for the update\n+     * @return              Future with the updated configuration\n+     */\n+    private Future<Map<String, String>> updateConfig(Map<String, String> newServers)    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                log.debug(\"Updating Zookeeper configuration to {}\", newServers);\n+                byte[] newConfig = zkAdmin.reconfigure(null, null, serversMapToList(newServers), -1, null);\n+                Map<String, String> servers = parseConfig(newConfig);\n+\n+                log.debug(\"New Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to update Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to update Zookeeper server configuration\", e));\n+            }\n+        }, false, configPromise);\n+\n+        return configPromise.future();\n+    }\n+\n+    /**\n+     * Closes the Zookeeper connection asynchronously\n+     *\n+     * @return\n+     */\n+    private Future<Void> closeConnectionAsync() {\n+        Promise<Void> closePromise = Promise.promise();\n+\n+        log.debug(\"Closing Zookeeper connection to {}\", zookeeperConnectionString);\n+\n+        vertx.executeBlocking(promise -> {\n+            closeConnectionSync();\n+            promise.complete();\n+        }, true, closePromise);\n+\n+        return closePromise.future();\n+    }\n+\n+    /**\n+     * Closes the Zookeeper connection synchronously\n+     */\n+    private void closeConnectionSync() {\n+        if (zkAdmin != null)    {\n+            try {\n+                zkAdmin.close();\n+            } catch (InterruptedException e) {\n+                log.warn(\"Failed to close the ZooKeeperAdmin\", e);\n+            } finally {\n+                zkAdmin = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates the TLS configuration for Zookeeper.\n+     *\n+     * @return\n+     */\n+    private ZKClientConfig getClientConfig()  {\n+        ZKClientConfig clientConfig = new ZKClientConfig();\n+\n+        clientConfig.setProperty(\"zookeeper.clientCnxnSocket\", \"org.apache.zookeeper.ClientCnxnSocketNetty\");\n+        clientConfig.setProperty(\"zookeeper.client.secure\", \"true\");\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.location\", trustStoreFile.getAbsolutePath());\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.password\", trustStorePassword);\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.type\", \"PKCS12\");\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.location\", keyStoreFile.getAbsolutePath());\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.password\", keyStorePassword);\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.type\", \"PKCS12\");\n+\n+        return clientConfig;\n+    }\n+\n+    /**\n+     * Converts the map with configuration to List of Strings which is the format in which the ZookeeperAdmin client\n+     * expects the new configuration.\n+     *\n+     * @param servers   Map with Zookeeper configuration\n+     * @return          List with Zookeeper configuration\n+     */\n+    /*test*/ static List<String> serversMapToList(Map<String, String> servers)  {\n+        List<String> serversList = new ArrayList<String>(servers.size());\n+\n+        for (Map.Entry entry : servers.entrySet())  {\n+            serversList.add(String.format(\"%s=%s\", entry.getKey(), entry.getValue()));\n+        }\n+\n+        return serversList;\n+    }\n+\n+    /**\n+     * Parse the byte array we get from Zookeeper into a map we use internally. During the parsing, only server\n+     * configurations are used. The version field is ignored.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3NDc0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param scale     Nubber of nodes which the Zookeeper cluster should have\n          \n          \n            \n                 * @param scale     Number of nodes which the Zookeeper cluster should have", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395474748", "createdAt": "2020-03-20T07:41:27Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(ignore -> getConfig())\n+                .compose(servers -> scaleTo(servers, scaleTo))\n+                .compose(ignore -> closeConnectionAsync());\n+    }\n+\n+    /**\n+     * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes\n+     * the certificate files.\n+     */\n+    @Override\n+    public void close() {\n+        closeConnectionSync();\n+\n+        if (trustStoreFile != null) {\n+            if (!trustStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", trustStoreFile);\n+            }\n+        }\n+\n+        if (keyStoreFile != null)   {\n+            if (!keyStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", keyStoreFile);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method used to create the Zookeeper Admin client and connect it to Zookeeper\n+     *\n+     * @return      Future indicating success or failure\n+     */\n+    private Future<Void> connect()    {\n+        Promise<Void> connected = Promise.promise();\n+\n+        try {\n+            long timer = vertx.setTimer(operationTimeoutMs, ignored -> {\n+                if (!connected.future().isComplete()) {\n+                    log.debug(\"Failed to connected to {} to scale Zookeeper for {} ms. The connection will be closed.\", this.zookeeperConnectionString, operationTimeoutMs);\n+                    closeConnectionSync();\n+                    connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + this.zookeeperConnectionString + \" for \" + operationTimeoutMs + \" ms\"));\n+                }\n+            });\n+\n+            zkAdmin = zooAdminProvider.createZookeeperAdmin(this.zookeeperConnectionString, 10_000, watchedEvent -> {\n+                switch (watchedEvent.getState()) {\n+                    case SyncConnected:\n+                        if (!connected.future().isComplete()) {\n+                            log.debug(\"Successfully connected to {} to scale Zookeeper\", zookeeperConnectionString);\n+                            connected.tryComplete();\n+                        }\n+                        break;\n+                    default:\n+                        if (!connected.future().isComplete()) {\n+                            log.warn(\"Failed to connect to {} to scale Zookeeper because of state {}\", zookeeperConnectionString, watchedEvent.getState());\n+                            closeConnectionSync();\n+                            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \" - got state \" + watchedEvent.getState()));\n+                        }\n+                }\n+\n+                vertx.cancelTimer(timer);\n+            }, getClientConfig());\n+        } catch (IOException e)   {\n+            log.warn(\"Failed to connect to {} to scale Zookeeper\", zookeeperConnectionString, e);\n+            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString, e));\n+        }\n+\n+        return connected.future();\n+    }\n+\n+    /**\n+     * Internal method to scale Zookeeper up or down or check configuration. It will:\n+     *     1) Compare the current configuration with the desired configuration\n+     *     2) Update the configuration if needed\n+     *\n+     * @param currentServers    Current configuration\n+     * @param scaleTo           Desired scale\n+     * @return                  Future indicating success or failure\n+     */\n+    private Future<Void> scaleTo(Map<String, String> currentServers, int scaleTo) {\n+        Map<String, String> desiredServers = generateConfig(scaleTo);\n+\n+        if (isDifferent(currentServers, desiredServers))    {\n+            log.debug(\"The Zookeeper server configuration needs to be updated\");\n+            return updateConfig(desiredServers).map((Void) null);\n+        } else {\n+            log.debug(\"The Zookeeper server configuration is already up to date\");\n+            return Future.succeededFuture();\n+        }\n+    }\n+\n+    /**\n+     * Gets the current configuration from Zookeeper.\n+     *\n+     * @return  Future containing Map with the current Zookeeper configuration\n+     */\n+    private Future<Map<String, String>> getConfig()    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                byte[] config = zkAdmin.getConfig(false, null);\n+                Map<String, String> servers = parseConfig(config);\n+                log.debug(\"Current Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to get current Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to get current Zookeeper server configuration\", e));\n+            }\n+        }, false, configPromise);\n+\n+        return configPromise.future();\n+    }\n+\n+    /**\n+     * Updates the configuration in the Zookeeper cluster\n+     *\n+     * @param newServers    New configuration which will be used for the update\n+     * @return              Future with the updated configuration\n+     */\n+    private Future<Map<String, String>> updateConfig(Map<String, String> newServers)    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                log.debug(\"Updating Zookeeper configuration to {}\", newServers);\n+                byte[] newConfig = zkAdmin.reconfigure(null, null, serversMapToList(newServers), -1, null);\n+                Map<String, String> servers = parseConfig(newConfig);\n+\n+                log.debug(\"New Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to update Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to update Zookeeper server configuration\", e));\n+            }\n+        }, false, configPromise);\n+\n+        return configPromise.future();\n+    }\n+\n+    /**\n+     * Closes the Zookeeper connection asynchronously\n+     *\n+     * @return\n+     */\n+    private Future<Void> closeConnectionAsync() {\n+        Promise<Void> closePromise = Promise.promise();\n+\n+        log.debug(\"Closing Zookeeper connection to {}\", zookeeperConnectionString);\n+\n+        vertx.executeBlocking(promise -> {\n+            closeConnectionSync();\n+            promise.complete();\n+        }, true, closePromise);\n+\n+        return closePromise.future();\n+    }\n+\n+    /**\n+     * Closes the Zookeeper connection synchronously\n+     */\n+    private void closeConnectionSync() {\n+        if (zkAdmin != null)    {\n+            try {\n+                zkAdmin.close();\n+            } catch (InterruptedException e) {\n+                log.warn(\"Failed to close the ZooKeeperAdmin\", e);\n+            } finally {\n+                zkAdmin = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates the TLS configuration for Zookeeper.\n+     *\n+     * @return\n+     */\n+    private ZKClientConfig getClientConfig()  {\n+        ZKClientConfig clientConfig = new ZKClientConfig();\n+\n+        clientConfig.setProperty(\"zookeeper.clientCnxnSocket\", \"org.apache.zookeeper.ClientCnxnSocketNetty\");\n+        clientConfig.setProperty(\"zookeeper.client.secure\", \"true\");\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.location\", trustStoreFile.getAbsolutePath());\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.password\", trustStorePassword);\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.type\", \"PKCS12\");\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.location\", keyStoreFile.getAbsolutePath());\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.password\", keyStorePassword);\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.type\", \"PKCS12\");\n+\n+        return clientConfig;\n+    }\n+\n+    /**\n+     * Converts the map with configuration to List of Strings which is the format in which the ZookeeperAdmin client\n+     * expects the new configuration.\n+     *\n+     * @param servers   Map with Zookeeper configuration\n+     * @return          List with Zookeeper configuration\n+     */\n+    /*test*/ static List<String> serversMapToList(Map<String, String> servers)  {\n+        List<String> serversList = new ArrayList<String>(servers.size());\n+\n+        for (Map.Entry entry : servers.entrySet())  {\n+            serversList.add(String.format(\"%s=%s\", entry.getKey(), entry.getValue()));\n+        }\n+\n+        return serversList;\n+    }\n+\n+    /**\n+     * Parse the byte array we get from Zookeeper into a map we use internally. During the parsing, only server\n+     * configurations are used. The version field is ignored.\n+     *\n+     * @param byteConfig    byte[] from Zookeeper client\n+     * @return              Map with Zookeeper configuration\n+     */\n+    /*test*/ static Map<String, String> parseConfig(byte[] byteConfig) {\n+        String config = new String(byteConfig, StandardCharsets.US_ASCII);\n+\n+        Map<String, String> configMap = Util.parseMap(config);\n+\n+        Map<String, String> serverMap = new HashMap<>(configMap.size() - 1);\n+\n+        for (Map.Entry<String, String> entry : configMap.entrySet())    {\n+            if (entry.getKey().startsWith(\"server.\"))   {\n+                serverMap.put(entry.getKey(), entry.getValue());\n+            }\n+        }\n+\n+        return serverMap;\n+    }\n+\n+    /**\n+     * Checks whether two Zookeeper configurations are different or not. We will change the configuration only if it\n+     * differs to minimize the load.\n+     *\n+     * @param current   Map with current configuration\n+     * @param desired   Map with desired configuration\n+     * @return          True if the configurations differ and should be updated. False otherwise.\n+     */\n+    /*test*/ static boolean isDifferent(Map<String, String> current, Map<String, String> desired)    {\n+        return !current.equals(desired);\n+    }\n+\n+    /**\n+     * Generates a map with Zookeeper configuration\n+     *\n+     * @param scale     Nubber of nodes which the Zookeeper cluster should have", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3NTA0MQ==", "bodyText": "Remove", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395475041", "createdAt": "2020-03-20T07:42:24Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/ResourceUtils.java", "diffHunk": "@@ -629,6 +632,20 @@ public Admin createAdminClient(String hostname, Secret clusterCaCertSecret, Secr\n         };\n     }\n \n+    public static ZookeeperScalerProvider zookeeperScalerProvider() {\n+        return new ZookeeperScalerProvider() {\n+            @Override\n+            public ZookeeperScaler createZookeeperScaler(Vertx vertx, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+                ZookeeperScaler mockZooScaler = mock(ZookeeperScaler.class);\n+\n+                when(mockZooScaler.scale(anyInt())).thenReturn(Future.succeededFuture());\n+                //when(mockZooScaler.close()).thenReturn(Future.succeededFuture());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3NTcwMg==", "bodyText": "Timeouting isn't a word in English (though I quite like it)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testTimeoutingConnection(VertxTestContext context)  {\n          \n          \n            \n                public void testConnectionTimeout(VertxTestContext context)  {", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395475702", "createdAt": "2020-03-20T07:44:27Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScalerTest.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.fabric8.kubernetes.api.model.SecretBuilder;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.Checkpoint;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.collection.IsIterableContainingInAnyOrder.containsInAnyOrder;\n+import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.isNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(VertxExtension.class)\n+public class ZookeeperScalerTest {\n+    private static Vertx vertx;\n+\n+    @BeforeAll\n+    public static void initVertx() {\n+        vertx = Vertx.vertx();\n+    }\n+\n+    @AfterAll\n+    public static void closeVertx() {\n+        vertx.close();\n+    }\n+\n+    @Test\n+    public void testIsNotDifferent()   {\n+        Map<String, String> current = new HashMap<>(3);\n+        current.put(\"server.1\", \"127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+        current.put(\"server.2\", \"127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+        current.put(\"server.3\", \"127.0.0.1:28882:38882:participant;127.0.0.1:21812\");\n+\n+        Map<String, String> desired = new HashMap<>(3);\n+        desired.put(\"server.1\", \"127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+        desired.put(\"server.2\", \"127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+        desired.put(\"server.3\", \"127.0.0.1:28882:38882:participant;127.0.0.1:21812\");\n+\n+        assertThat(ZookeeperScaler.isDifferent(current, desired), is(false));\n+\n+        Map<String, String> desired2 = new HashMap<>(3);\n+        desired2.put(\"server.1\", \"127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+        desired2.put(\"server.3\", \"127.0.0.1:28882:38882:participant;127.0.0.1:21812\");\n+        desired2.put(\"server.2\", \"127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+\n+        assertThat(ZookeeperScaler.isDifferent(current, desired2), is(false));\n+    }\n+\n+    @Test\n+    public void testIsDifferent()   {\n+        Map<String, String> current = new HashMap<>(3);\n+        current.put(\"server.1\", \"127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+        current.put(\"server.2\", \"127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+        current.put(\"server.3\", \"127.0.0.1:28882:38882:participant;127.0.0.1:21812\");\n+\n+        Map<String, String> desired = new HashMap<>(3);\n+        desired.put(\"server.1\", \"127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+        desired.put(\"server.2\", \"127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+        desired.put(\"server.3\", \"127.0.0.1:28882:38882:participant;127.0.0.1:21812\");\n+        desired.put(\"server.4\", \"127.0.0.1:28883:38883:participant;127.0.0.1:21813\");\n+\n+        assertThat(ZookeeperScaler.isDifferent(current, desired), is(true));\n+\n+        Map<String, String> desired2 = new HashMap<>(3);\n+        desired2.put(\"server.1\", \"127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+        desired2.put(\"server.2\", \"127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+\n+        assertThat(ZookeeperScaler.isDifferent(current, desired2), is(true));\n+\n+        Map<String, String> desired3 = new HashMap<>(3);\n+        desired3.put(\"server.2\", \"127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+        desired3.put(\"server.3\", \"127.0.0.1:28882:38882:participant;127.0.0.1:21812\");\n+\n+        assertThat(ZookeeperScaler.isDifferent(current, desired3), is(true));\n+    }\n+\n+    @Test\n+    public void testGenerateConfigOneNode() {\n+        Map<String, String> expected = new HashMap<>(3);\n+        expected.put(\"server.1\", \"127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+\n+        assertThat(ZookeeperScaler.generateConfig(1), is(expected));\n+    }\n+\n+    @Test\n+    public void testGenerateConfigThreeNodes() {\n+        Map<String, String> expected = new HashMap<>(3);\n+        expected.put(\"server.1\", \"127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+        expected.put(\"server.2\", \"127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+        expected.put(\"server.3\", \"127.0.0.1:28882:38882:participant;127.0.0.1:21812\");\n+\n+        assertThat(ZookeeperScaler.generateConfig(3), is(expected));\n+    }\n+\n+    @Test\n+    public void testParseConfig() {\n+        String config = \"server.1=127.0.0.1:28880:38880:participant;127.0.0.1:21810\\n\" +\n+                        \"server.2=127.0.0.1:28881:38881:participant;127.0.0.1:21811\\n\" +\n+                        \"server.3=127.0.0.1:28882:38882:participant;127.0.0.1:21812\\n\" +\n+                        \"version=100000000b\";\n+\n+        Map<String, String> expected = new HashMap<>(3);\n+        expected.put(\"server.1\", \"127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+        expected.put(\"server.2\", \"127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+        expected.put(\"server.3\", \"127.0.0.1:28882:38882:participant;127.0.0.1:21812\");\n+\n+        assertThat(ZookeeperScaler.parseConfig(config.getBytes(StandardCharsets.US_ASCII)), is(expected));\n+    }\n+\n+    @Test\n+    public void testMapToList() {\n+        Map<String, String> servers = new HashMap<>(3);\n+        servers.put(\"server.1\", \"127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+        servers.put(\"server.2\", \"127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+        servers.put(\"server.3\", \"127.0.0.1:28882:38882:participant;127.0.0.1:21812\");\n+\n+        List<String> expected = new ArrayList<>(3);\n+        expected.add(\"server.1=127.0.0.1:28880:38880:participant;127.0.0.1:21810\");\n+        expected.add(\"server.2=127.0.0.1:28881:38881:participant;127.0.0.1:21811\");\n+        expected.add(\"server.3=127.0.0.1:28882:38882:participant;127.0.0.1:21812\");\n+\n+        assertThat(ZookeeperScaler.serversMapToList(servers), containsInAnyOrder(expected.toArray()));\n+    }\n+\n+    @Test\n+    public void testTimeoutingConnection(VertxTestContext context)  {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3NzgxOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Created file with Keystore or Truststore from the byte arrays passed as param.\n          \n          \n            \n                 * Create a file with Keystore or Truststore from the given {@code bytes}.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395477818", "createdAt": "2020-03-20T07:51:08Z", "author": {"login": "tombentley"}, "path": "operator-common/src/main/java/io/strimzi/operator/common/Util.java", "diffHunk": "@@ -123,4 +130,52 @@ public void handle(Long timerId) {\n             return Collections.emptyMap();\n         }\n     }\n+\n+    /**\n+     * Returns exception when secret is missing. This is used from several different methods to provide identical exception.\n+     *\n+     * @param namespace     Namespace of the Secret\n+     * @param secretName    Name of the Secret\n+     * @return              RuntimeException\n+     */\n+    public static RuntimeException missingSecretException(String namespace, String secretName) {\n+        return new RuntimeException(\"Secret \" + namespace + \"/\" + secretName + \" does not exist\");\n+    }\n+\n+    /**\n+     * Created file with Keystore or Truststore from the byte arrays passed as param.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4MzMwNzA3", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#pullrequestreview-378330707", "createdAt": "2020-03-20T09:26:30Z", "commit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4MzM3OTcy", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#pullrequestreview-378337972", "createdAt": "2020-03-20T09:38:23Z", "commit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwOTozODoyM1rOF5M6cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwOTo1Nzo1NlrOF5NgbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUyNDcyMA==", "bodyText": "The connection won't get closed in if there is a failed Future.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395524720", "createdAt": "2020-03-20T09:38:23Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(ignore -> getConfig())\n+                .compose(servers -> scaleTo(servers, scaleTo))\n+                .compose(ignore -> closeConnectionAsync());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUyODAyMQ==", "bodyText": "Util.parseMap() was originally written for our own 'image map' syntax. Are you sure it's the right thing to use for ZK admin responses?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395528021", "createdAt": "2020-03-20T09:45:07Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(ignore -> getConfig())\n+                .compose(servers -> scaleTo(servers, scaleTo))\n+                .compose(ignore -> closeConnectionAsync());\n+    }\n+\n+    /**\n+     * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes\n+     * the certificate files.\n+     */\n+    @Override\n+    public void close() {\n+        closeConnectionSync();\n+\n+        if (trustStoreFile != null) {\n+            if (!trustStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", trustStoreFile);\n+            }\n+        }\n+\n+        if (keyStoreFile != null)   {\n+            if (!keyStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", keyStoreFile);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method used to create the Zookeeper Admin client and connect it to Zookeeper\n+     *\n+     * @return      Future indicating success or failure\n+     */\n+    private Future<Void> connect()    {\n+        Promise<Void> connected = Promise.promise();\n+\n+        try {\n+            long timer = vertx.setTimer(operationTimeoutMs, ignored -> {\n+                if (!connected.future().isComplete()) {\n+                    log.debug(\"Failed to connected to {} to scale Zookeeper for {} ms. The connection will be closed.\", this.zookeeperConnectionString, operationTimeoutMs);\n+                    closeConnectionSync();\n+                    connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + this.zookeeperConnectionString + \" for \" + operationTimeoutMs + \" ms\"));\n+                }\n+            });\n+\n+            zkAdmin = zooAdminProvider.createZookeeperAdmin(this.zookeeperConnectionString, 10_000, watchedEvent -> {\n+                switch (watchedEvent.getState()) {\n+                    case SyncConnected:\n+                        if (!connected.future().isComplete()) {\n+                            log.debug(\"Successfully connected to {} to scale Zookeeper\", zookeeperConnectionString);\n+                            connected.tryComplete();\n+                        }\n+                        break;\n+                    default:\n+                        if (!connected.future().isComplete()) {\n+                            log.warn(\"Failed to connect to {} to scale Zookeeper because of state {}\", zookeeperConnectionString, watchedEvent.getState());\n+                            closeConnectionSync();\n+                            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \" - got state \" + watchedEvent.getState()));\n+                        }\n+                }\n+\n+                vertx.cancelTimer(timer);\n+            }, getClientConfig());\n+        } catch (IOException e)   {\n+            log.warn(\"Failed to connect to {} to scale Zookeeper\", zookeeperConnectionString, e);\n+            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString, e));\n+        }\n+\n+        return connected.future();\n+    }\n+\n+    /**\n+     * Internal method to scale Zookeeper up or down or check configuration. It will:\n+     *     1) Compare the current configuration with the desired configuration\n+     *     2) Update the configuration if needed\n+     *\n+     * @param currentServers    Current configuration\n+     * @param scaleTo           Desired scale\n+     * @return                  Future indicating success or failure\n+     */\n+    private Future<Void> scaleTo(Map<String, String> currentServers, int scaleTo) {\n+        Map<String, String> desiredServers = generateConfig(scaleTo);\n+\n+        if (isDifferent(currentServers, desiredServers))    {\n+            log.debug(\"The Zookeeper server configuration needs to be updated\");\n+            return updateConfig(desiredServers).map((Void) null);\n+        } else {\n+            log.debug(\"The Zookeeper server configuration is already up to date\");\n+            return Future.succeededFuture();\n+        }\n+    }\n+\n+    /**\n+     * Gets the current configuration from Zookeeper.\n+     *\n+     * @return  Future containing Map with the current Zookeeper configuration\n+     */\n+    private Future<Map<String, String>> getConfig()    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                byte[] config = zkAdmin.getConfig(false, null);\n+                Map<String, String> servers = parseConfig(config);\n+                log.debug(\"Current Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to get current Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to get current Zookeeper server configuration\", e));\n+            }\n+        }, false, configPromise);\n+\n+        return configPromise.future();\n+    }\n+\n+    /**\n+     * Updates the configuration in the Zookeeper cluster\n+     *\n+     * @param newServers    New configuration which will be used for the update\n+     * @return              Future with the updated configuration\n+     */\n+    private Future<Map<String, String>> updateConfig(Map<String, String> newServers)    {\n+        Promise<Map<String, String>> configPromise = Promise.promise();\n+\n+        vertx.executeBlocking(promise -> {\n+            try {\n+                log.debug(\"Updating Zookeeper configuration to {}\", newServers);\n+                byte[] newConfig = zkAdmin.reconfigure(null, null, serversMapToList(newServers), -1, null);\n+                Map<String, String> servers = parseConfig(newConfig);\n+\n+                log.debug(\"New Zookeeper configuration is {}\", servers);\n+                promise.complete(servers);\n+            } catch (KeeperException | InterruptedException e)    {\n+                log.warn(\"Failed to update Zookeeper server configuration\", e);\n+                promise.fail(new RuntimeException(\"Failed to update Zookeeper server configuration\", e));\n+            }\n+        }, false, configPromise);\n+\n+        return configPromise.future();\n+    }\n+\n+    /**\n+     * Closes the Zookeeper connection asynchronously\n+     *\n+     * @return\n+     */\n+    private Future<Void> closeConnectionAsync() {\n+        Promise<Void> closePromise = Promise.promise();\n+\n+        log.debug(\"Closing Zookeeper connection to {}\", zookeeperConnectionString);\n+\n+        vertx.executeBlocking(promise -> {\n+            closeConnectionSync();\n+            promise.complete();\n+        }, true, closePromise);\n+\n+        return closePromise.future();\n+    }\n+\n+    /**\n+     * Closes the Zookeeper connection synchronously\n+     */\n+    private void closeConnectionSync() {\n+        if (zkAdmin != null)    {\n+            try {\n+                zkAdmin.close();\n+            } catch (InterruptedException e) {\n+                log.warn(\"Failed to close the ZooKeeperAdmin\", e);\n+            } finally {\n+                zkAdmin = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates the TLS configuration for Zookeeper.\n+     *\n+     * @return\n+     */\n+    private ZKClientConfig getClientConfig()  {\n+        ZKClientConfig clientConfig = new ZKClientConfig();\n+\n+        clientConfig.setProperty(\"zookeeper.clientCnxnSocket\", \"org.apache.zookeeper.ClientCnxnSocketNetty\");\n+        clientConfig.setProperty(\"zookeeper.client.secure\", \"true\");\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.location\", trustStoreFile.getAbsolutePath());\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.password\", trustStorePassword);\n+        clientConfig.setProperty(\"zookeeper.ssl.trustStore.type\", \"PKCS12\");\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.location\", keyStoreFile.getAbsolutePath());\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.password\", keyStorePassword);\n+        clientConfig.setProperty(\"zookeeper.ssl.keyStore.type\", \"PKCS12\");\n+\n+        return clientConfig;\n+    }\n+\n+    /**\n+     * Converts the map with configuration to List of Strings which is the format in which the ZookeeperAdmin client\n+     * expects the new configuration.\n+     *\n+     * @param servers   Map with Zookeeper configuration\n+     * @return          List with Zookeeper configuration\n+     */\n+    /*test*/ static List<String> serversMapToList(Map<String, String> servers)  {\n+        List<String> serversList = new ArrayList<String>(servers.size());\n+\n+        for (Map.Entry entry : servers.entrySet())  {\n+            serversList.add(String.format(\"%s=%s\", entry.getKey(), entry.getValue()));\n+        }\n+\n+        return serversList;\n+    }\n+\n+    /**\n+     * Parse the byte array we get from Zookeeper into a map we use internally. During the parsing, only server\n+     * configurations are used. The version field is ignored.\n+     *\n+     * @param byteConfig    byte[] from Zookeeper client\n+     * @return              Map with Zookeeper configuration\n+     */\n+    /*test*/ static Map<String, String> parseConfig(byte[] byteConfig) {\n+        String config = new String(byteConfig, StandardCharsets.US_ASCII);\n+\n+        Map<String, String> configMap = Util.parseMap(config);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUyOTU0MQ==", "bodyText": "Can we call this getCurrentConfig() or currentConfig()?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395529541", "createdAt": "2020-03-20T09:48:10Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(ignore -> getConfig())\n+                .compose(servers -> scaleTo(servers, scaleTo))\n+                .compose(ignore -> closeConnectionAsync());\n+    }\n+\n+    /**\n+     * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes\n+     * the certificate files.\n+     */\n+    @Override\n+    public void close() {\n+        closeConnectionSync();\n+\n+        if (trustStoreFile != null) {\n+            if (!trustStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", trustStoreFile);\n+            }\n+        }\n+\n+        if (keyStoreFile != null)   {\n+            if (!keyStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", keyStoreFile);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method used to create the Zookeeper Admin client and connect it to Zookeeper\n+     *\n+     * @return      Future indicating success or failure\n+     */\n+    private Future<Void> connect()    {\n+        Promise<Void> connected = Promise.promise();\n+\n+        try {\n+            long timer = vertx.setTimer(operationTimeoutMs, ignored -> {\n+                if (!connected.future().isComplete()) {\n+                    log.debug(\"Failed to connected to {} to scale Zookeeper for {} ms. The connection will be closed.\", this.zookeeperConnectionString, operationTimeoutMs);\n+                    closeConnectionSync();\n+                    connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + this.zookeeperConnectionString + \" for \" + operationTimeoutMs + \" ms\"));\n+                }\n+            });\n+\n+            zkAdmin = zooAdminProvider.createZookeeperAdmin(this.zookeeperConnectionString, 10_000, watchedEvent -> {\n+                switch (watchedEvent.getState()) {\n+                    case SyncConnected:\n+                        if (!connected.future().isComplete()) {\n+                            log.debug(\"Successfully connected to {} to scale Zookeeper\", zookeeperConnectionString);\n+                            connected.tryComplete();\n+                        }\n+                        break;\n+                    default:\n+                        if (!connected.future().isComplete()) {\n+                            log.warn(\"Failed to connect to {} to scale Zookeeper because of state {}\", zookeeperConnectionString, watchedEvent.getState());\n+                            closeConnectionSync();\n+                            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \" - got state \" + watchedEvent.getState()));\n+                        }\n+                }\n+\n+                vertx.cancelTimer(timer);\n+            }, getClientConfig());\n+        } catch (IOException e)   {\n+            log.warn(\"Failed to connect to {} to scale Zookeeper\", zookeeperConnectionString, e);\n+            connected.tryFail(new RuntimeException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString, e));\n+        }\n+\n+        return connected.future();\n+    }\n+\n+    /**\n+     * Internal method to scale Zookeeper up or down or check configuration. It will:\n+     *     1) Compare the current configuration with the desired configuration\n+     *     2) Update the configuration if needed\n+     *\n+     * @param currentServers    Current configuration\n+     * @param scaleTo           Desired scale\n+     * @return                  Future indicating success or failure\n+     */\n+    private Future<Void> scaleTo(Map<String, String> currentServers, int scaleTo) {\n+        Map<String, String> desiredServers = generateConfig(scaleTo);\n+\n+        if (isDifferent(currentServers, desiredServers))    {\n+            log.debug(\"The Zookeeper server configuration needs to be updated\");\n+            return updateConfig(desiredServers).map((Void) null);\n+        } else {\n+            log.debug(\"The Zookeeper server configuration is already up to date\");\n+            return Future.succeededFuture();\n+        }\n+    }\n+\n+    /**\n+     * Gets the current configuration from Zookeeper.\n+     *\n+     * @return  Future containing Map with the current Zookeeper configuration\n+     */\n+    private Future<Map<String, String>> getConfig()    {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUzNDQ0NA==", "bodyText": "This is accessed in various places by callbacks to vertx.executeBlocking(), i.e. potentially by different threads. Probably the correct thing to do is for connect() to return Future<ZooKeeperAdmin> and propagate the client through the compose chain in scale(), though that's a bit messy because getConfig() would need to return both the config and the client instance.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395534444", "createdAt": "2020-03-20T09:57:56Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    private ZooKeeperAdmin zkAdmin;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85c321d7a2a2e18d8103073defb1a8f9111492c2"}, "originalPosition": 47}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "302f7b86a99a14df7b059c5f306138e2c8170790", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/302f7b86a99a14df7b059c5f306138e2c8170790", "committedDate": "2020-03-20T10:02:29Z", "message": "Review comments I\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "975d9552b4258f844f6323bbd567331708858974", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/975d9552b4258f844f6323bbd567331708858974", "committedDate": "2020-03-20T10:26:21Z", "message": "Review comments II\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4Mzk3Mjky", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#pullrequestreview-378397292", "createdAt": "2020-03-20T11:14:19Z", "commit": {"oid": "975d9552b4258f844f6323bbd567331708858974"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMToxNDoxOVrOF5Ptjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMToxNDoxOVrOF5Ptjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU3MDU3NA==", "bodyText": "We change Kafka version by env variable ST_KAFKA_VERSION. If a specific version of kafka is needed, we should have a different test for it, because this one should be general for ZK scaleup/Scaledown", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395570574", "createdAt": "2020-03-20T11:14:19Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/RollingUpdateST.java", "diffHunk": "@@ -342,14 +341,18 @@ void testKafkaWontRollUpBecauseTopic() {\n     }\n \n     @Test\n-    @Disabled(\"Zookeeper scaleUp/scaleDown is currently covered by manual procedure for Kafka 2.4.x. \" +\n-            \"This should be removed after implementation of Zookeeper Dynamic configuration\")\n     void testZookeeperScaleUpScaleDown() {\n         int messageCount = 50;\n         String topicName = \"test-topic-\" + new Random().nextInt(Integer.MAX_VALUE);\n \n         timeMeasuringSystem.setOperationID(timeMeasuringSystem.startTimeMeasuring(Operation.CLUSTER_RECOVERY));\n-        KafkaResource.kafkaPersistent(CLUSTER_NAME, 3).done();\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withVersion(\"2.3.1\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "975d9552b4258f844f6323bbd567331708858974"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aee909f9164840f58944f02f3cb59b76d4c4d49b", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/aee909f9164840f58944f02f3cb59b76d4c4d49b", "committedDate": "2020-03-20T11:15:52Z", "message": "Fix ST commited by mistake\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b77944076870b8157f21da73b62d64848c6e2347", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b77944076870b8157f21da73b62d64848c6e2347", "committedDate": "2020-03-20T14:39:04Z", "message": "Review Comments III\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NTU0Mjk3", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#pullrequestreview-378554297", "createdAt": "2020-03-20T14:55:10Z", "commit": {"oid": "b77944076870b8157f21da73b62d64848c6e2347"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNDo1NToxMFrOF5XFag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNDo1NjozOFrOF5XJZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY5MTM3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes\n          \n          \n            \n                 * Close the ZookeeperScaler instance. This deletes", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395691370", "createdAt": "2020-03-20T14:55:10Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,424 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    //private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(zkAdmin -> {\n+                    Promise<Void> scalePromise = Promise.promise();\n+\n+                    getCurrentConfig(zkAdmin)\n+                            .compose(servers -> scaleTo(zkAdmin, servers, scaleTo))\n+                            .setHandler(res -> {\n+                                closeConnection(zkAdmin);\n+\n+                                if (res.succeeded())    {\n+                                    scalePromise.complete();\n+                                } else {\n+                                    scalePromise.fail(res.cause());\n+                                }\n+                            });\n+\n+                    return scalePromise.future();\n+                });\n+    }\n+\n+    /**\n+     * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b77944076870b8157f21da73b62d64848c6e2347"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY5MjM5MA==", "bodyText": "Can you delete this?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2721#discussion_r395692390", "createdAt": "2020-03-20T14:56:38Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/ZookeeperScaler.java", "diffHunk": "@@ -0,0 +1,424 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Secret;\n+import io.strimzi.operator.cluster.model.Ca;\n+import io.strimzi.operator.cluster.model.ZookeeperCluster;\n+import io.strimzi.operator.common.Util;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.admin.ZooKeeperAdmin;\n+import org.apache.zookeeper.client.ZKClientConfig;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for scaling Zookeeper 3.5 using the ZookeeperAdmin client\n+ */\n+public class ZookeeperScaler implements AutoCloseable {\n+    private static final Logger log = LogManager.getLogger(ZookeeperScaler.class);\n+\n+    private final Vertx vertx;\n+    private final ZooKeeperAdminProvider zooAdminProvider;\n+\n+    private final String zookeeperConnectionString;\n+\n+    private final long operationTimeoutMs;\n+\n+    private final String trustStorePassword;\n+    private final File trustStoreFile;\n+\n+    private final String keyStorePassword;\n+    private final File keyStoreFile;\n+\n+    //private ZooKeeperAdmin zkAdmin;\n+\n+    /**\n+     * ZookeeperScaler constructor\n+     *\n+     * @param vertx                         Vertx instance\n+     * @param zookeeperConnectionString     Connection string to connect to the right Zookeeper\n+     * @param clusterCaCertSecret           Secret with Kafka cluster CA public key\n+     * @param coKeySecret                   Secret with Cluster Operator public and private key\n+     * @param operationTimeoutMs            Operation timeout\n+     *\n+     * @return  ZookeeperScaler instance\n+     */\n+    protected ZookeeperScaler(Vertx vertx, ZooKeeperAdminProvider zooAdminProvider, String zookeeperConnectionString, Secret clusterCaCertSecret, Secret coKeySecret, long operationTimeoutMs) {\n+        log.debug(\"Creating Zookeeper Scaler for cluster {}\", zookeeperConnectionString);\n+\n+        this.vertx = vertx;\n+        this.zooAdminProvider = zooAdminProvider;\n+        this.zookeeperConnectionString = zookeeperConnectionString;\n+        this.operationTimeoutMs = operationTimeoutMs;\n+        trustStorePassword = new String(Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE_PASSWORD), StandardCharsets.US_ASCII);\n+        trustStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(clusterCaCertSecret, Ca.CA_STORE));\n+        keyStorePassword = new String(Util.decodeFromSecret(coKeySecret, \"cluster-operator.password\"), StandardCharsets.US_ASCII);\n+        keyStoreFile = Util.createFileStore(getClass().getName(), \"p12\", Util.decodeFromSecret(coKeySecret, \"cluster-operator.p12\"));\n+    }\n+\n+    /**\n+     * Scales Zookeeper to defined number of instances.\n+     * It generates new configuration according to the desired number of nodes and updates Zookeeper configuration.\n+     *\n+     * @param scaleTo   Number of Zookeeper nodes which should be used by the cluster\n+     *\n+     * @return          Future which succeeds / fails when the scaling is finished\n+     */\n+    public Future<Void> scale(int scaleTo) {\n+        return connect()\n+                .compose(zkAdmin -> {\n+                    Promise<Void> scalePromise = Promise.promise();\n+\n+                    getCurrentConfig(zkAdmin)\n+                            .compose(servers -> scaleTo(zkAdmin, servers, scaleTo))\n+                            .setHandler(res -> {\n+                                closeConnection(zkAdmin);\n+\n+                                if (res.succeeded())    {\n+                                    scalePromise.complete();\n+                                } else {\n+                                    scalePromise.fail(res.cause());\n+                                }\n+                            });\n+\n+                    return scalePromise.future();\n+                });\n+    }\n+\n+    /**\n+     * Close the ZookeeperScaler instance. This closes the Zookeeper connection in case it was left open and deletes\n+     * the certificate files.\n+     */\n+    @Override\n+    public void close() {\n+        if (trustStoreFile != null) {\n+            if (!trustStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", trustStoreFile);\n+            }\n+        }\n+\n+        if (keyStoreFile != null)   {\n+            if (!keyStoreFile.delete())   {\n+                log.debug(\"Failed to delete file {}\", keyStoreFile);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method used to create the Zookeeper Admin client and connect it to Zookeeper\n+     *\n+     * @return      Future indicating success or failure\n+     */\n+    private Future<ZooKeeperAdmin> connect()    {\n+        Promise<ZooKeeperAdmin> connected = Promise.promise();\n+\n+        try {\n+            ZooKeeperAdmin zkAdmin = zooAdminProvider.createZookeeperAdmin(\n+                this.zookeeperConnectionString,\n+                10_000,\n+                watchedEvent -> log.debug(\"Received event {} from ZooKeeperAdmin client connected to {}\", watchedEvent, zookeeperConnectionString),\n+                getClientConfig());\n+\n+            Util.waitFor(vertx,\n+                String.format(\"ZooKeeperAdmin connection to %s\", zookeeperConnectionString),\n+                1_000,\n+                operationTimeoutMs,\n+                () -> zkAdmin.getState().isAlive() && zkAdmin.getState().isConnected())\n+                .setHandler(res -> {\n+                    if (res.succeeded())  {\n+                        connected.complete(zkAdmin);\n+                    } else {\n+                        closeConnection(zkAdmin);\n+                        log.warn(\"Failed to connect to Zookeeper {}. Connection was not ready in {} ms.\", zookeeperConnectionString, operationTimeoutMs);\n+                        connected.fail(new ZookeeperScalingException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \". Connection was not ready in \" + operationTimeoutMs + \" ms.\", res.cause()));\n+                    }\n+                });\n+\n+        } catch (IOException e)   {\n+            log.warn(\"Failed to connect to {} to scale Zookeeper\", zookeeperConnectionString, e);\n+            connected.fail(new ZookeeperScalingException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString, e));\n+        }\n+\n+        return connected.future();\n+    }\n+\n+    /**\n+     * Internal method used to create the Zookeeper Admin client and connect it to Zookeeper\n+     *\n+     * @return      Future indicating success or failure\n+     */\n+    /*private Future<ZooKeeperAdmin> connect()    {\n+        Promise<ZooKeeperAdmin> connected = Promise.promise();\n+\n+        ZooKeeperAdmin zkAdmin = null;\n+\n+        try {\n+            long timer = vertx.setTimer(operationTimeoutMs, ignored -> {\n+                if (!connected.future().isComplete()) {\n+                    log.debug(\"Failed to connected to {} to scale Zookeeper for {} ms. The connection will be closed.\", this.zookeeperConnectionString, operationTimeoutMs);\n+                    closeConnection(zkAdmin);\n+                    connected.tryFail(new ZookeeperScalingException(\"Failed to connect to Zookeeper \" + this.zookeeperConnectionString + \" for \" + operationTimeoutMs + \" ms\"));\n+                }\n+            });\n+\n+            zkAdmin = zooAdminProvider.createZookeeperAdmin(this.zookeeperConnectionString, 10_000, watchedEvent -> {\n+                switch (watchedEvent.getState()) {\n+                    case SyncConnected:\n+                        if (!connected.future().isComplete()) {\n+                            log.debug(\"Successfully connected to {} to scale Zookeeper\", zookeeperConnectionString);\n+                            connected.tryComplete(zkAdmin);\n+                        }\n+                        break;\n+                    default:\n+                        if (!connected.future().isComplete()) {\n+                            log.warn(\"Failed to connect to {} to scale Zookeeper because of state {}\", zookeeperConnectionString, watchedEvent.getState());\n+                            closeConnection(zkAdmin);\n+                            connected.tryFail(new ZookeeperScalingException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \" - got state \" + watchedEvent.getState()));\n+                        }\n+                }\n+\n+                vertx.cancelTimer(timer);\n+            }, getClientConfig());\n+        } catch (IOException e)   {\n+            log.warn(\"Failed to connect to {} to scale Zookeeper\", zookeeperConnectionString, e);\n+            connected.tryFail(new ZookeeperScalingException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString, e));\n+        }\n+\n+        return connected.future();\n+    }*/\n+\n+    /*private Watcher connectionWatch(ZooKeeperAdmin zkAdmin, Promise connected)   {\n+        return new Watcher() {\n+            @Override\n+            public void process(WatchedEvent event) {\n+                switch (event.getState()) {\n+                    case SyncConnected:\n+                        event.getWrapper().\n+                        if (!connected.future().isComplete()) {\n+                            log.debug(\"Successfully connected to {} to scale Zookeeper\", zookeeperConnectionString);\n+                            connected.tryComplete(zkAdmin);\n+                        }\n+                        break;\n+                    default:\n+                        if (!connected.future().isComplete()) {\n+                            log.warn(\"Failed to connect to {} to scale Zookeeper because of state {}\", zookeeperConnectionString, watchedEvent.getState());\n+                            closeConnection(zkAdmin);\n+                            connected.tryFail(new ZookeeperScalingException(\"Failed to connect to Zookeeper \" + zookeeperConnectionString + \" - got state \" + watchedEvent.getState()));\n+                        }\n+                }\n+            }\n+        };\n+    }*/\n+\n+    /*private void connectionTimoutTimer(ZooKeeperAdmin zkAdmin, Promise connected) {\n+        if (!connected.future().isComplete()) {\n+            log.debug(\"Failed to connected to {} to scale Zookeeper for {} ms. The connection will be closed.\", this.zookeeperConnectionString, operationTimeoutMs);\n+            closeConnection(zkAdmin);\n+            connected.tryFail(new ZookeeperScalingException(\"Failed to connect to Zookeeper \" + this.zookeeperConnectionString + \" for \" + operationTimeoutMs + \" ms\"));\n+        }\n+    }*/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b77944076870b8157f21da73b62d64848c6e2347"}, "originalPosition": 233}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "212192c199f40225364bf6e038e4885ee6a8e718", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/212192c199f40225364bf6e038e4885ee6a8e718", "committedDate": "2020-03-20T15:10:27Z", "message": "Remove old code\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31fad9788e52bdbdcef31f4e957065b5bb7f2f29", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/31fad9788e52bdbdcef31f4e957065b5bb7f2f29", "committedDate": "2020-03-20T16:49:27Z", "message": "Deal with final classes differently -> using Mockito-Inline breaks other tests by being too slow?\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2087, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}