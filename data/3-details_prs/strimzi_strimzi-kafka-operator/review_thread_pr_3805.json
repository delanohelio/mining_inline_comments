{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNDI4Njgy", "number": 3805, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwNzo1MzoyNlrOEvMDrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMDo1OToyMlrOEvQkrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3OTE2MDc3OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LogSettingST.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwNzo1MzoyNlrOHkB7zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwODowODoxN1rOHkCePQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0MjQ3OA==", "bodyText": "We had there some issue that from time to time some containers weren't ready. Did we solve it somehow? If not, we can maybe add some checks for container readiness.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3805#discussion_r507542478", "createdAt": "2020-10-19T07:53:26Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LogSettingST.java", "diffHunk": "@@ -182,181 +187,222 @@\n     };\n \n     @Test\n-    @Order(1)\n-    void testLoggersKafka() {\n-        assertThat(\"Kafka's log level is set properly\", checkLoggersLevel(KAFKA_LOGGERS, KAFKA_MAP), is(true));\n-    }\n+    void testKafkaLogSetting() {\n+        String eoDepName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        String kafkaSsName = KafkaResources.kafkaStatefulSetName(CLUSTER_NAME);\n+        String zkSsName = KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME);\n \n-    @Test\n-    @Order(2)\n-    void testLoggersZookeeper() {\n-        assertThat(\"Zookeeper's log level is set properly\", checkLoggersLevel(ZOOKEEPER_LOGGERS, ZOOKEEPER_MAP), is(true));\n-    }\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDepName);\n+        Map<String, String> kafkaPods = StatefulSetUtils.ssSnapshot(kafkaSsName);\n+        Map<String, String> zkPods = StatefulSetUtils.ssSnapshot(zkSsName);\n \n-    @Test\n-    @Order(3)\n-    void testLoggersTO() {\n-        assertThat(\"Topic operator's log level is set properly\", checkLoggersLevel(OPERATORS_LOGGERS, TO_MAP), is(true));\n-    }\n+        String userName = \"test-user\";\n+        String topicName = \"test-topic\";\n \n-    @Test\n-    @Order(4)\n-    void testLoggersUO() {\n+        KafkaTopicResource.topic(CLUSTER_NAME, topicName).done();\n+        KafkaUserResource.tlsUser(CLUSTER_NAME, userName).done();\n+\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has log level set properly\", CLUSTER_NAME);\n+        assertThat(\"Kafka's log level is set properly\", checkLoggersLevel(KAFKA_LOGGERS, KAFKA_MAP), is(true));\n+        assertThat(\"Zookeeper's log level is set properly\", checkLoggersLevel(ZOOKEEPER_LOGGERS, ZOOKEEPER_MAP), is(true));\n+        assertThat(\"Topic operator's log level is set properly\", checkLoggersLevel(OPERATORS_LOGGERS, TO_MAP), is(true));\n         assertThat(\"User operator's log level is set properly\", checkLoggersLevel(OPERATORS_LOGGERS, UO_MAP), is(true));\n-    }\n \n-    @Test\n-    @Order(5)\n-    void testLoggersKafkaConnect() {\n-        assertThat(\"Kafka connect's log level is set properly\", checkLoggersLevel(CONNECT_LOGGERS, CONNECT_MAP), is(true));\n-    }\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has GC logging enabled in stateful sets/deployments\", CLUSTER_NAME);\n+        assertThat(\"Kafka GC logging is not enabled\", checkGcLoggingStatefulSets(kafkaSsName), is(true));\n+        assertThat(\"Zookeeper GC logging is enabled\", checkGcLoggingStatefulSets(zkSsName), is(true));\n+        assertThat(\"TO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"topic-operator\"), is(true));\n+        assertThat(\"UO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"user-operator\"), is(true));\n+\n+        LOGGER.info(\"Changing JVM options - setting GC logging to false\");\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setJvmOptions(JVM_OPTIONS);\n+            kafka.getSpec().getZookeeper().setJvmOptions(JVM_OPTIONS);\n+            kafka.getSpec().getEntityOperator().getTopicOperator().setJvmOptions(JVM_OPTIONS);\n+            kafka.getSpec().getEntityOperator().getUserOperator().setJvmOptions(JVM_OPTIONS);\n+        });\n \n-    @Test\n-    @Order(6)\n-    void testLoggersMirrorMaker() {\n-        assertThat(\"KafkaMirrorMaker's log level is set properly\", checkLoggersLevel(MIRROR_MAKER_LOGGERS, MM_MAP), is(true));\n-    }\n+        StatefulSetUtils.waitTillSsHasRolled(zkSsName, 1, zkPods);\n+        StatefulSetUtils.waitTillSsHasRolled(kafkaSsName, 3, kafkaPods);\n+        DeploymentUtils.waitTillDepHasRolled(eoDepName, 1, eoPods);\n \n-    @Test\n-    @Order(7)\n-    void testLoggersMirrorMaker2() {\n-        assertThat(\"KafkaMirrorMaker2's log level is set properly\", checkLoggersLevel(MIRROR_MAKER_LOGGERS, MM2_MAP), is(true));\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has GC logging disabled in stateful sets/deployments\", CLUSTER_NAME);\n+        assertThat(\"Kafka GC logging is disabled\", checkGcLoggingStatefulSets(kafkaSsName), is(false));\n+        assertThat(\"Zookeeper GC logging is disabled\", checkGcLoggingStatefulSets(zkSsName), is(false));\n+        assertThat(\"TO GC logging is disabled\", checkGcLoggingDeployments(eoDepName, \"topic-operator\"), is(false));\n+        assertThat(\"UO GC logging is disabled\", checkGcLoggingDeployments(eoDepName, \"user-operator\"), is(false));\n+\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has GC logging disabled in stateful sets/deployments\", GC_LOGGING_SET_NAME);\n+        assertThat(\"Kafka GC logging is enabled\", checkGcLoggingStatefulSets(kafkaSsName), is(false));\n+        assertThat(\"Zookeeper GC logging is enabled\", checkGcLoggingStatefulSets(zkSsName), is(false));\n+        assertThat(\"TO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"topic-operator\"), is(false));\n+        assertThat(\"UO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"user-operator\"), is(false));\n+\n+        kubectlGetStrimzi(CLUSTER_NAME);\n+        kubectlGetStrimzi(GC_LOGGING_SET_NAME);\n+\n+        checkContainersHaveProcessOneAsTini(CLUSTER_NAME);\n+        checkContainersHaveProcessOneAsTini(GC_LOGGING_SET_NAME);\n     }\n \n     @Test\n-    @Order(8)\n-    void testLoggersBridge() {\n-        assertThat(\"Bridge's log level is set properly\", checkLoggersLevel(BRIDGE_LOGGERS, BRIDGE_MAP), is(true));\n+    void testConnectLogSetting() {\n+        KafkaConnectResource.kafkaConnect(CONNECT_NAME, CLUSTER_NAME, 1)\n+            .editSpec()\n+                .withNewInlineLogging()\n+                    .withLoggers(CONNECT_LOGGERS)\n+                .endInlineLogging()\n+                .withNewJvmOptions()\n+                    .withGcLoggingEnabled(true)\n+                .endJvmOptions()\n+            .endSpec()\n+            .done();\n+\n+        String connectDepName = KafkaConnectResources.deploymentName(CONNECT_NAME);\n+        Map<String, String> connectPods = DeploymentUtils.depSnapshot(connectDepName);\n+\n+        LOGGER.info(\"Checking if Connect has log level set properly\");\n+        assertThat(\"KafkaConnect's log level is set properly\", checkLoggersLevel(CONNECT_LOGGERS, CONNECT_MAP), is(true));\n+        assertThat(\"Connect GC logging is enabled\", checkGcLoggingDeployments(connectDepName), is(true));\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CONNECT_NAME, kc -> kc.getSpec().setJvmOptions(JVM_OPTIONS));\n+        DeploymentUtils.waitTillDepHasRolled(connectDepName, 1, connectPods);\n+        assertThat(\"Connect GC logging is disabled\", checkGcLoggingDeployments(connectDepName), is(false));\n+\n+        kubectlGetStrimzi(CONNECT_NAME);\n+        checkContainersHaveProcessOneAsTini(CONNECT_NAME);\n     }\n \n     @Test\n     @OpenShiftOnly\n-    @Order(9)\n-    void testLoggersConnectS2I() {\n+    void testConnectS2ILogSetting() {\n+        KafkaConnectS2IResource.kafkaConnectS2I(CONNECTS2I_NAME, CLUSTER_NAME, 1)\n+            .editSpec()\n+                .withNewInlineLogging()\n+                    .withLoggers(CONNECT_LOGGERS)\n+                .endInlineLogging()\n+                .withNewJvmOptions()\n+                    .withGcLoggingEnabled(true)\n+                .endJvmOptions()\n+            .endSpec()\n+            .done();\n+\n+        String connectS2IDepName = KafkaConnectS2IResources.deploymentName(CONNECTS2I_NAME);\n+        Map<String, String> connectS2IPods = DeploymentConfigUtils.depConfigSnapshot(connectS2IDepName);\n+\n+        LOGGER.info(\"Checking if ConnectS2I has log level set properly\");\n         assertThat(\"KafkaConnectS2I's log level is set properly\", checkLoggersLevel(CONNECT_LOGGERS, CONNECTS2I_MAP), is(true));\n-    }\n+        assertThat(\"ConnectS2I GC logging is enabled\", checkGcLoggingDeploymentConfig(connectS2IDepName), is(true));\n \n-    @Test\n-    @Order(10)\n-    void testGcLoggingNonSetDisabled() {\n-        assertThat(\"Kafka GC logging is enabled\", checkGcLoggingStatefulSets(KafkaResources.kafkaStatefulSetName(GC_LOGGING_SET_NAME)), is(false));\n-        assertThat(\"Zookeeper GC logging is enabled\", checkGcLoggingStatefulSets(KafkaResources.zookeeperStatefulSetName(GC_LOGGING_SET_NAME)), is(false));\n+        KafkaConnectS2IResource.replaceConnectS2IResource(CONNECTS2I_NAME, cs2i -> cs2i.getSpec().setJvmOptions(JVM_OPTIONS));\n+        DeploymentConfigUtils.waitTillDepConfigHasRolled(connectS2IDepName, connectS2IPods);\n+        assertThat(\"ConnectS2I GC logging is disabled\", checkGcLoggingDeploymentConfig(connectS2IDepName), is(false));\n \n-        assertThat(\"TO GC logging is enabled\", checkGcLoggingDeployments(KafkaResources.entityOperatorDeploymentName(GC_LOGGING_SET_NAME), \"topic-operator\"), is(false));\n-        assertThat(\"UO GC logging is enabled\", checkGcLoggingDeployments(KafkaResources.entityOperatorDeploymentName(GC_LOGGING_SET_NAME), \"user-operator\"), is(false));\n+        kubectlGetStrimzi(CONNECTS2I_NAME);\n+        checkContainersHaveProcessOneAsTini(CONNECTS2I_NAME);\n     }\n \n     @Test\n-    @Order(11)\n-    void testGcLoggingSetEnabled() {\n-        assertThat(\"Kafka GC logging is enabled\", checkGcLoggingStatefulSets(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME)), is(true));\n-        assertThat(\"Zookeeper GC logging is enabled\", checkGcLoggingStatefulSets(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME)), is(true));\n+    void testMirrorMakerLogSetting() {\n+        KafkaMirrorMakerResource.kafkaMirrorMaker(MM_NAME, CLUSTER_NAME, GC_LOGGING_SET_NAME, \"my-group\", 1, false)\n+            .editSpec()\n+                .withNewInlineLogging()\n+                    .withLoggers(MIRROR_MAKER_LOGGERS)\n+                .endInlineLogging()\n+                .withNewJvmOptions()\n+                    .withGcLoggingEnabled(true)\n+                .endJvmOptions()\n+            .endSpec()\n+            .done();\n \n-        assertThat(\"TO GC logging is enabled\", checkGcLoggingDeployments(KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME), \"topic-operator\"), is(true));\n-        assertThat(\"UO GC logging is enabled\", checkGcLoggingDeployments(KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME), \"user-operator\"), is(true));\n+        String mmDepName = KafkaMirrorMakerResources.deploymentName(MM_NAME);\n+        Map<String, String> mmPods = DeploymentUtils.depSnapshot(mmDepName);\n \n-        assertThat(\"Connect GC logging is enabled\", checkGcLoggingDeployments(KafkaConnectResources.deploymentName(CONNECT_NAME)), is(true));\n-        assertThat(\"Mirror-maker GC logging is enabled\", checkGcLoggingDeployments(KafkaMirrorMakerResources.deploymentName(MM_NAME)), is(true));\n-        assertThat(\"Mirror-maker-2 GC logging is enabled\", checkGcLoggingDeployments(KafkaMirrorMaker2Resources.deploymentName(MM2_NAME)), is(true));\n+        LOGGER.info(\"Checking if MirrorMaker has log level set properly\");\n+        assertThat(\"KafkaMirrorMaker's log level is set properly\", checkLoggersLevel(MIRROR_MAKER_LOGGERS, MM_MAP), is(true));\n+        assertThat(\"Mirror-maker GC logging is enabled\", checkGcLoggingDeployments(mmDepName), is(true));\n \n-        if (cluster.isNotKubernetes()) {\n-            assertThat(\"ConnectS2I GC logging is enabled\", checkGcLoggingDeploymentConfig(KafkaConnectS2IResources.deploymentName(CONNECTS2I_NAME)), is(true));\n-        }\n+        KafkaMirrorMakerResource.replaceMirrorMakerResource(MM_NAME, mm -> mm.getSpec().setJvmOptions(JVM_OPTIONS));\n+        DeploymentUtils.waitTillDepHasRolled(mmDepName, 1, mmPods);\n+        assertThat(\"Mirror-maker GC logging is disabled\", checkGcLoggingDeployments(mmDepName), is(false));\n+\n+        kubectlGetStrimzi(MM_NAME);\n+        checkContainersHaveProcessOneAsTini(MM_NAME);\n     }\n \n     @Test\n-    @Order(12)\n-    void testGcLoggingSetDisabled() {\n-        String connectName = KafkaConnectResources.deploymentName(CONNECT_NAME);\n-        String connectS2IName = KafkaConnectS2IResources.deploymentName(CONNECTS2I_NAME);\n-        String mmName = KafkaMirrorMakerResources.deploymentName(MM_NAME);\n-        String mm2Name = KafkaMirrorMaker2Resources.deploymentName(MM2_NAME);\n-        String eoName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n-        String kafkaName = KafkaResources.kafkaStatefulSetName(CLUSTER_NAME);\n-        String zkName = KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME);\n-        Map<String, String> connectPods = DeploymentUtils.depSnapshot(connectName);\n-        Map<String, String> mmPods = DeploymentUtils.depSnapshot(mmName);\n-        Map<String, String> mm2Pods = DeploymentUtils.depSnapshot(mm2Name);\n-        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoName);\n-        Map<String, String> kafkaPods = StatefulSetUtils.ssSnapshot(kafkaName);\n-        Map<String, String> zkPods = StatefulSetUtils.ssSnapshot(zkName);\n-\n-        JvmOptions jvmOptions = new JvmOptions();\n-        jvmOptions.setGcLoggingEnabled(false);\n-\n-        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n-            k.getSpec().getKafka().setJvmOptions(jvmOptions);\n-            k.getSpec().getZookeeper().setJvmOptions(jvmOptions);\n-            k.getSpec().getEntityOperator().getTopicOperator().setJvmOptions(jvmOptions);\n-            k.getSpec().getEntityOperator().getUserOperator().setJvmOptions(jvmOptions);\n-        });\n+    void testMirrorMaker2LogSetting() {\n+        KafkaMirrorMaker2Resource.kafkaMirrorMaker2(MM2_NAME, CLUSTER_NAME, GC_LOGGING_SET_NAME, 1, false)\n+            .editSpec()\n+                .withNewInlineLogging()\n+                    .withLoggers(MIRROR_MAKER_LOGGERS)\n+                .endInlineLogging()\n+                .withNewJvmOptions()\n+                    .withGcLoggingEnabled(true)\n+                .endJvmOptions()\n+            .endSpec()\n+            .done();\n \n-        StatefulSetUtils.waitTillSsHasRolled(zkName, 1, zkPods);\n-        StatefulSetUtils.waitTillSsHasRolled(kafkaName, 3, kafkaPods);\n-        DeploymentUtils.waitTillDepHasRolled(eoName, 1, eoPods);\n+        String mm2DepName = KafkaMirrorMaker2Resources.deploymentName(MM2_NAME);\n+        Map<String, String> mm2Pods = DeploymentUtils.depSnapshot(mm2DepName);\n \n-        KafkaConnectResource.replaceKafkaConnectResource(CONNECT_NAME, kc -> kc.getSpec().setJvmOptions(jvmOptions));\n-        DeploymentUtils.waitTillDepHasRolled(connectName, 1, connectPods);\n+        LOGGER.info(\"Checking if MirrorMaker2 has log level set properly\");\n+        assertThat(\"KafkaMirrorMaker2's log level is set properly\", checkLoggersLevel(MIRROR_MAKER_LOGGERS, MM2_MAP), is(true));\n+        assertThat(\"Mirror-maker-2 GC logging is enabled\", checkGcLoggingDeployments(mm2DepName), is(true));\n \n-        if (cluster.isNotKubernetes()) {\n-            KafkaConnectS2IResource.replaceConnectS2IResource(CONNECTS2I_NAME, cs2i -> cs2i.getSpec().setJvmOptions(jvmOptions));\n-            DeploymentConfigUtils.waitTillDepConfigHasRolled(connectS2IName, connectPods);\n-        }\n+        KafkaMirrorMaker2Resource.replaceKafkaMirrorMaker2Resource(MM2_NAME, mm2 -> mm2.getSpec().setJvmOptions(JVM_OPTIONS));\n+        DeploymentUtils.waitTillDepHasRolled(mm2DepName, 1, mm2Pods);\n+        assertThat(\"Mirror-maker2 GC logging is disabled\", checkGcLoggingDeployments(mm2DepName), is(false));\n \n-        KafkaMirrorMakerResource.replaceMirrorMakerResource(MM_NAME, mm -> mm.getSpec().setJvmOptions(jvmOptions));\n-        DeploymentUtils.waitTillDepHasRolled(mmName, 1, mmPods);\n+        kubectlGetStrimzi(MM2_NAME);\n+        checkContainersHaveProcessOneAsTini(MM2_NAME);\n+    }\n \n-        KafkaMirrorMaker2Resource.replaceKafkaMirrorMaker2Resource(MM2_NAME, mm2 -> mm2.getSpec().setJvmOptions(jvmOptions));\n-        DeploymentUtils.waitTillDepHasRolled(mm2Name, 1, mm2Pods);\n+    @Test\n+    void testBridgeLogSetting() {\n+        KafkaBridgeResource.kafkaBridge(BRIDGE_NAME, CLUSTER_NAME, KafkaResources.plainBootstrapAddress(CLUSTER_NAME), 1)\n+            .editSpec()\n+                .withNewInlineLogging()\n+                    .withLoggers(BRIDGE_LOGGERS)\n+                .endInlineLogging()\n+                .withNewJvmOptions()\n+                    .withGcLoggingEnabled(true)\n+                .endJvmOptions()\n+            .endSpec()\n+            .done();\n \n-        assertThat(\"Kafka GC logging is disabled\", checkGcLoggingStatefulSets(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME)), is(false));\n-        assertThat(\"Zookeeper GC logging is disabled\", checkGcLoggingStatefulSets(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME)), is(false));\n+        String bridgeDepName = KafkaBridgeResources.deploymentName(BRIDGE_NAME);\n+        Map<String, String> bridgePods = DeploymentUtils.depSnapshot(bridgeDepName);\n \n-        assertThat(\"TO GC logging is disabled\", checkGcLoggingDeployments(KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME), \"topic-operator\"), is(false));\n-        assertThat(\"UO GC logging is disabled\", checkGcLoggingDeployments(KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME), \"user-operator\"), is(false));\n+        LOGGER.info(\"Checking if Bridge has log level set properly\");\n+        assertThat(\"Bridge's log level is set properly\", checkLoggersLevel(BRIDGE_LOGGERS, BRIDGE_MAP), is(true));\n+        assertThat(\"Bridge's GC logging is enabled\", checkGcLoggingDeployments(bridgeDepName), is(true));\n \n-        assertThat(\"Connect GC logging is disabled\", checkGcLoggingDeployments(KafkaConnectResources.deploymentName(CONNECT_NAME)), is(false));\n-        assertThat(\"Mirror-maker GC logging is disabled\", checkGcLoggingDeployments(KafkaMirrorMakerResources.deploymentName(MM_NAME)), is(false));\n-        assertThat(\"Mirror-maker2 GC logging is disabled\", checkGcLoggingDeployments(KafkaMirrorMaker2Resources.deploymentName(MM2_NAME)), is(false));\n+        KafkaBridgeResource.replaceBridgeResource(BRIDGE_NAME, bridge -> bridge.getSpec().setJvmOptions(JVM_OPTIONS));\n+        DeploymentUtils.waitTillDepHasRolled(bridgeDepName, 1, bridgePods);\n+        assertThat(\"Bridge GC logging is disabled\", checkGcLoggingDeployments(bridgeDepName), is(false));\n \n-        if (cluster.isNotKubernetes()) {\n-            assertThat(\"ConnectS2I GC logging is disabled\", checkGcLoggingDeploymentConfig(KafkaConnectS2IResources.deploymentName(CONNECTS2I_NAME)), is(false));\n-        }\n+        kubectlGetStrimzi(BRIDGE_NAME);\n+        checkContainersHaveProcessOneAsTini(BRIDGE_NAME);\n     }\n \n-    @Test\n-    @Order(13)\n-    void testKubectlGetStrimzi() {\n-        String userName = \"test-user\";\n-        String topicName = \"test-topic\";\n-\n-        KafkaTopicResource.topic(CLUSTER_NAME, topicName).done();\n-        KafkaUserResource.tlsUser(CLUSTER_NAME, userName).done();\n-\n+    void kubectlGetStrimzi(String resourceName) {\n+        LOGGER.info(\"Checking if kubectl get strimzi contains {}\", resourceName);\n         String strimziCRs = cmdKubeClient().execInCurrentNamespace(\"get\", \"strimzi\").out();\n-\n-        assertThat(strimziCRs, containsString(CLUSTER_NAME));\n-        assertThat(strimziCRs, containsString(GC_LOGGING_SET_NAME));\n-        assertThat(strimziCRs, containsString(MM_NAME));\n-        assertThat(strimziCRs, containsString(MM2_NAME));\n-        assertThat(strimziCRs, containsString(BRIDGE_NAME));\n-        assertThat(strimziCRs, containsString(CONNECT_NAME));\n-        assertThat(strimziCRs, containsString(userName));\n-        assertThat(strimziCRs, containsString(topicName));\n+        assertThat(strimziCRs, containsString(resourceName));\n     }\n \n-    @Test\n-    @Order(14)\n-    void testCheckContainersHaveProcessOneAsTini() {\n+    void checkContainersHaveProcessOneAsTini(String resourceClusterName) {\n         //Used [/] in the grep command so that grep process does not return itself\n         String command = \"ps -ef | grep '[/]usr/bin/tini' | awk '{ print $2}'\";\n \n-        for (Pod pod : kubeClient().listPods()) {\n+        for (Pod pod : kubeClient().listPods(Labels.STRIMZI_CLUSTER_LABEL, resourceClusterName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8827905694df58f631aa59a40e48951cf58c6664"}, "originalPosition": 374}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU1MTI5Mw==", "bodyText": "Well the problem was (hopefully) solved. But I will add the readiness check to be sure. Thanks", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3805#discussion_r507551293", "createdAt": "2020-10-19T08:08:17Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LogSettingST.java", "diffHunk": "@@ -182,181 +187,222 @@\n     };\n \n     @Test\n-    @Order(1)\n-    void testLoggersKafka() {\n-        assertThat(\"Kafka's log level is set properly\", checkLoggersLevel(KAFKA_LOGGERS, KAFKA_MAP), is(true));\n-    }\n+    void testKafkaLogSetting() {\n+        String eoDepName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        String kafkaSsName = KafkaResources.kafkaStatefulSetName(CLUSTER_NAME);\n+        String zkSsName = KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME);\n \n-    @Test\n-    @Order(2)\n-    void testLoggersZookeeper() {\n-        assertThat(\"Zookeeper's log level is set properly\", checkLoggersLevel(ZOOKEEPER_LOGGERS, ZOOKEEPER_MAP), is(true));\n-    }\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDepName);\n+        Map<String, String> kafkaPods = StatefulSetUtils.ssSnapshot(kafkaSsName);\n+        Map<String, String> zkPods = StatefulSetUtils.ssSnapshot(zkSsName);\n \n-    @Test\n-    @Order(3)\n-    void testLoggersTO() {\n-        assertThat(\"Topic operator's log level is set properly\", checkLoggersLevel(OPERATORS_LOGGERS, TO_MAP), is(true));\n-    }\n+        String userName = \"test-user\";\n+        String topicName = \"test-topic\";\n \n-    @Test\n-    @Order(4)\n-    void testLoggersUO() {\n+        KafkaTopicResource.topic(CLUSTER_NAME, topicName).done();\n+        KafkaUserResource.tlsUser(CLUSTER_NAME, userName).done();\n+\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has log level set properly\", CLUSTER_NAME);\n+        assertThat(\"Kafka's log level is set properly\", checkLoggersLevel(KAFKA_LOGGERS, KAFKA_MAP), is(true));\n+        assertThat(\"Zookeeper's log level is set properly\", checkLoggersLevel(ZOOKEEPER_LOGGERS, ZOOKEEPER_MAP), is(true));\n+        assertThat(\"Topic operator's log level is set properly\", checkLoggersLevel(OPERATORS_LOGGERS, TO_MAP), is(true));\n         assertThat(\"User operator's log level is set properly\", checkLoggersLevel(OPERATORS_LOGGERS, UO_MAP), is(true));\n-    }\n \n-    @Test\n-    @Order(5)\n-    void testLoggersKafkaConnect() {\n-        assertThat(\"Kafka connect's log level is set properly\", checkLoggersLevel(CONNECT_LOGGERS, CONNECT_MAP), is(true));\n-    }\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has GC logging enabled in stateful sets/deployments\", CLUSTER_NAME);\n+        assertThat(\"Kafka GC logging is not enabled\", checkGcLoggingStatefulSets(kafkaSsName), is(true));\n+        assertThat(\"Zookeeper GC logging is enabled\", checkGcLoggingStatefulSets(zkSsName), is(true));\n+        assertThat(\"TO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"topic-operator\"), is(true));\n+        assertThat(\"UO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"user-operator\"), is(true));\n+\n+        LOGGER.info(\"Changing JVM options - setting GC logging to false\");\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setJvmOptions(JVM_OPTIONS);\n+            kafka.getSpec().getZookeeper().setJvmOptions(JVM_OPTIONS);\n+            kafka.getSpec().getEntityOperator().getTopicOperator().setJvmOptions(JVM_OPTIONS);\n+            kafka.getSpec().getEntityOperator().getUserOperator().setJvmOptions(JVM_OPTIONS);\n+        });\n \n-    @Test\n-    @Order(6)\n-    void testLoggersMirrorMaker() {\n-        assertThat(\"KafkaMirrorMaker's log level is set properly\", checkLoggersLevel(MIRROR_MAKER_LOGGERS, MM_MAP), is(true));\n-    }\n+        StatefulSetUtils.waitTillSsHasRolled(zkSsName, 1, zkPods);\n+        StatefulSetUtils.waitTillSsHasRolled(kafkaSsName, 3, kafkaPods);\n+        DeploymentUtils.waitTillDepHasRolled(eoDepName, 1, eoPods);\n \n-    @Test\n-    @Order(7)\n-    void testLoggersMirrorMaker2() {\n-        assertThat(\"KafkaMirrorMaker2's log level is set properly\", checkLoggersLevel(MIRROR_MAKER_LOGGERS, MM2_MAP), is(true));\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has GC logging disabled in stateful sets/deployments\", CLUSTER_NAME);\n+        assertThat(\"Kafka GC logging is disabled\", checkGcLoggingStatefulSets(kafkaSsName), is(false));\n+        assertThat(\"Zookeeper GC logging is disabled\", checkGcLoggingStatefulSets(zkSsName), is(false));\n+        assertThat(\"TO GC logging is disabled\", checkGcLoggingDeployments(eoDepName, \"topic-operator\"), is(false));\n+        assertThat(\"UO GC logging is disabled\", checkGcLoggingDeployments(eoDepName, \"user-operator\"), is(false));\n+\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has GC logging disabled in stateful sets/deployments\", GC_LOGGING_SET_NAME);\n+        assertThat(\"Kafka GC logging is enabled\", checkGcLoggingStatefulSets(kafkaSsName), is(false));\n+        assertThat(\"Zookeeper GC logging is enabled\", checkGcLoggingStatefulSets(zkSsName), is(false));\n+        assertThat(\"TO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"topic-operator\"), is(false));\n+        assertThat(\"UO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"user-operator\"), is(false));\n+\n+        kubectlGetStrimzi(CLUSTER_NAME);\n+        kubectlGetStrimzi(GC_LOGGING_SET_NAME);\n+\n+        checkContainersHaveProcessOneAsTini(CLUSTER_NAME);\n+        checkContainersHaveProcessOneAsTini(GC_LOGGING_SET_NAME);\n     }\n \n     @Test\n-    @Order(8)\n-    void testLoggersBridge() {\n-        assertThat(\"Bridge's log level is set properly\", checkLoggersLevel(BRIDGE_LOGGERS, BRIDGE_MAP), is(true));\n+    void testConnectLogSetting() {\n+        KafkaConnectResource.kafkaConnect(CONNECT_NAME, CLUSTER_NAME, 1)\n+            .editSpec()\n+                .withNewInlineLogging()\n+                    .withLoggers(CONNECT_LOGGERS)\n+                .endInlineLogging()\n+                .withNewJvmOptions()\n+                    .withGcLoggingEnabled(true)\n+                .endJvmOptions()\n+            .endSpec()\n+            .done();\n+\n+        String connectDepName = KafkaConnectResources.deploymentName(CONNECT_NAME);\n+        Map<String, String> connectPods = DeploymentUtils.depSnapshot(connectDepName);\n+\n+        LOGGER.info(\"Checking if Connect has log level set properly\");\n+        assertThat(\"KafkaConnect's log level is set properly\", checkLoggersLevel(CONNECT_LOGGERS, CONNECT_MAP), is(true));\n+        assertThat(\"Connect GC logging is enabled\", checkGcLoggingDeployments(connectDepName), is(true));\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CONNECT_NAME, kc -> kc.getSpec().setJvmOptions(JVM_OPTIONS));\n+        DeploymentUtils.waitTillDepHasRolled(connectDepName, 1, connectPods);\n+        assertThat(\"Connect GC logging is disabled\", checkGcLoggingDeployments(connectDepName), is(false));\n+\n+        kubectlGetStrimzi(CONNECT_NAME);\n+        checkContainersHaveProcessOneAsTini(CONNECT_NAME);\n     }\n \n     @Test\n     @OpenShiftOnly\n-    @Order(9)\n-    void testLoggersConnectS2I() {\n+    void testConnectS2ILogSetting() {\n+        KafkaConnectS2IResource.kafkaConnectS2I(CONNECTS2I_NAME, CLUSTER_NAME, 1)\n+            .editSpec()\n+                .withNewInlineLogging()\n+                    .withLoggers(CONNECT_LOGGERS)\n+                .endInlineLogging()\n+                .withNewJvmOptions()\n+                    .withGcLoggingEnabled(true)\n+                .endJvmOptions()\n+            .endSpec()\n+            .done();\n+\n+        String connectS2IDepName = KafkaConnectS2IResources.deploymentName(CONNECTS2I_NAME);\n+        Map<String, String> connectS2IPods = DeploymentConfigUtils.depConfigSnapshot(connectS2IDepName);\n+\n+        LOGGER.info(\"Checking if ConnectS2I has log level set properly\");\n         assertThat(\"KafkaConnectS2I's log level is set properly\", checkLoggersLevel(CONNECT_LOGGERS, CONNECTS2I_MAP), is(true));\n-    }\n+        assertThat(\"ConnectS2I GC logging is enabled\", checkGcLoggingDeploymentConfig(connectS2IDepName), is(true));\n \n-    @Test\n-    @Order(10)\n-    void testGcLoggingNonSetDisabled() {\n-        assertThat(\"Kafka GC logging is enabled\", checkGcLoggingStatefulSets(KafkaResources.kafkaStatefulSetName(GC_LOGGING_SET_NAME)), is(false));\n-        assertThat(\"Zookeeper GC logging is enabled\", checkGcLoggingStatefulSets(KafkaResources.zookeeperStatefulSetName(GC_LOGGING_SET_NAME)), is(false));\n+        KafkaConnectS2IResource.replaceConnectS2IResource(CONNECTS2I_NAME, cs2i -> cs2i.getSpec().setJvmOptions(JVM_OPTIONS));\n+        DeploymentConfigUtils.waitTillDepConfigHasRolled(connectS2IDepName, connectS2IPods);\n+        assertThat(\"ConnectS2I GC logging is disabled\", checkGcLoggingDeploymentConfig(connectS2IDepName), is(false));\n \n-        assertThat(\"TO GC logging is enabled\", checkGcLoggingDeployments(KafkaResources.entityOperatorDeploymentName(GC_LOGGING_SET_NAME), \"topic-operator\"), is(false));\n-        assertThat(\"UO GC logging is enabled\", checkGcLoggingDeployments(KafkaResources.entityOperatorDeploymentName(GC_LOGGING_SET_NAME), \"user-operator\"), is(false));\n+        kubectlGetStrimzi(CONNECTS2I_NAME);\n+        checkContainersHaveProcessOneAsTini(CONNECTS2I_NAME);\n     }\n \n     @Test\n-    @Order(11)\n-    void testGcLoggingSetEnabled() {\n-        assertThat(\"Kafka GC logging is enabled\", checkGcLoggingStatefulSets(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME)), is(true));\n-        assertThat(\"Zookeeper GC logging is enabled\", checkGcLoggingStatefulSets(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME)), is(true));\n+    void testMirrorMakerLogSetting() {\n+        KafkaMirrorMakerResource.kafkaMirrorMaker(MM_NAME, CLUSTER_NAME, GC_LOGGING_SET_NAME, \"my-group\", 1, false)\n+            .editSpec()\n+                .withNewInlineLogging()\n+                    .withLoggers(MIRROR_MAKER_LOGGERS)\n+                .endInlineLogging()\n+                .withNewJvmOptions()\n+                    .withGcLoggingEnabled(true)\n+                .endJvmOptions()\n+            .endSpec()\n+            .done();\n \n-        assertThat(\"TO GC logging is enabled\", checkGcLoggingDeployments(KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME), \"topic-operator\"), is(true));\n-        assertThat(\"UO GC logging is enabled\", checkGcLoggingDeployments(KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME), \"user-operator\"), is(true));\n+        String mmDepName = KafkaMirrorMakerResources.deploymentName(MM_NAME);\n+        Map<String, String> mmPods = DeploymentUtils.depSnapshot(mmDepName);\n \n-        assertThat(\"Connect GC logging is enabled\", checkGcLoggingDeployments(KafkaConnectResources.deploymentName(CONNECT_NAME)), is(true));\n-        assertThat(\"Mirror-maker GC logging is enabled\", checkGcLoggingDeployments(KafkaMirrorMakerResources.deploymentName(MM_NAME)), is(true));\n-        assertThat(\"Mirror-maker-2 GC logging is enabled\", checkGcLoggingDeployments(KafkaMirrorMaker2Resources.deploymentName(MM2_NAME)), is(true));\n+        LOGGER.info(\"Checking if MirrorMaker has log level set properly\");\n+        assertThat(\"KafkaMirrorMaker's log level is set properly\", checkLoggersLevel(MIRROR_MAKER_LOGGERS, MM_MAP), is(true));\n+        assertThat(\"Mirror-maker GC logging is enabled\", checkGcLoggingDeployments(mmDepName), is(true));\n \n-        if (cluster.isNotKubernetes()) {\n-            assertThat(\"ConnectS2I GC logging is enabled\", checkGcLoggingDeploymentConfig(KafkaConnectS2IResources.deploymentName(CONNECTS2I_NAME)), is(true));\n-        }\n+        KafkaMirrorMakerResource.replaceMirrorMakerResource(MM_NAME, mm -> mm.getSpec().setJvmOptions(JVM_OPTIONS));\n+        DeploymentUtils.waitTillDepHasRolled(mmDepName, 1, mmPods);\n+        assertThat(\"Mirror-maker GC logging is disabled\", checkGcLoggingDeployments(mmDepName), is(false));\n+\n+        kubectlGetStrimzi(MM_NAME);\n+        checkContainersHaveProcessOneAsTini(MM_NAME);\n     }\n \n     @Test\n-    @Order(12)\n-    void testGcLoggingSetDisabled() {\n-        String connectName = KafkaConnectResources.deploymentName(CONNECT_NAME);\n-        String connectS2IName = KafkaConnectS2IResources.deploymentName(CONNECTS2I_NAME);\n-        String mmName = KafkaMirrorMakerResources.deploymentName(MM_NAME);\n-        String mm2Name = KafkaMirrorMaker2Resources.deploymentName(MM2_NAME);\n-        String eoName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n-        String kafkaName = KafkaResources.kafkaStatefulSetName(CLUSTER_NAME);\n-        String zkName = KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME);\n-        Map<String, String> connectPods = DeploymentUtils.depSnapshot(connectName);\n-        Map<String, String> mmPods = DeploymentUtils.depSnapshot(mmName);\n-        Map<String, String> mm2Pods = DeploymentUtils.depSnapshot(mm2Name);\n-        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoName);\n-        Map<String, String> kafkaPods = StatefulSetUtils.ssSnapshot(kafkaName);\n-        Map<String, String> zkPods = StatefulSetUtils.ssSnapshot(zkName);\n-\n-        JvmOptions jvmOptions = new JvmOptions();\n-        jvmOptions.setGcLoggingEnabled(false);\n-\n-        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n-            k.getSpec().getKafka().setJvmOptions(jvmOptions);\n-            k.getSpec().getZookeeper().setJvmOptions(jvmOptions);\n-            k.getSpec().getEntityOperator().getTopicOperator().setJvmOptions(jvmOptions);\n-            k.getSpec().getEntityOperator().getUserOperator().setJvmOptions(jvmOptions);\n-        });\n+    void testMirrorMaker2LogSetting() {\n+        KafkaMirrorMaker2Resource.kafkaMirrorMaker2(MM2_NAME, CLUSTER_NAME, GC_LOGGING_SET_NAME, 1, false)\n+            .editSpec()\n+                .withNewInlineLogging()\n+                    .withLoggers(MIRROR_MAKER_LOGGERS)\n+                .endInlineLogging()\n+                .withNewJvmOptions()\n+                    .withGcLoggingEnabled(true)\n+                .endJvmOptions()\n+            .endSpec()\n+            .done();\n \n-        StatefulSetUtils.waitTillSsHasRolled(zkName, 1, zkPods);\n-        StatefulSetUtils.waitTillSsHasRolled(kafkaName, 3, kafkaPods);\n-        DeploymentUtils.waitTillDepHasRolled(eoName, 1, eoPods);\n+        String mm2DepName = KafkaMirrorMaker2Resources.deploymentName(MM2_NAME);\n+        Map<String, String> mm2Pods = DeploymentUtils.depSnapshot(mm2DepName);\n \n-        KafkaConnectResource.replaceKafkaConnectResource(CONNECT_NAME, kc -> kc.getSpec().setJvmOptions(jvmOptions));\n-        DeploymentUtils.waitTillDepHasRolled(connectName, 1, connectPods);\n+        LOGGER.info(\"Checking if MirrorMaker2 has log level set properly\");\n+        assertThat(\"KafkaMirrorMaker2's log level is set properly\", checkLoggersLevel(MIRROR_MAKER_LOGGERS, MM2_MAP), is(true));\n+        assertThat(\"Mirror-maker-2 GC logging is enabled\", checkGcLoggingDeployments(mm2DepName), is(true));\n \n-        if (cluster.isNotKubernetes()) {\n-            KafkaConnectS2IResource.replaceConnectS2IResource(CONNECTS2I_NAME, cs2i -> cs2i.getSpec().setJvmOptions(jvmOptions));\n-            DeploymentConfigUtils.waitTillDepConfigHasRolled(connectS2IName, connectPods);\n-        }\n+        KafkaMirrorMaker2Resource.replaceKafkaMirrorMaker2Resource(MM2_NAME, mm2 -> mm2.getSpec().setJvmOptions(JVM_OPTIONS));\n+        DeploymentUtils.waitTillDepHasRolled(mm2DepName, 1, mm2Pods);\n+        assertThat(\"Mirror-maker2 GC logging is disabled\", checkGcLoggingDeployments(mm2DepName), is(false));\n \n-        KafkaMirrorMakerResource.replaceMirrorMakerResource(MM_NAME, mm -> mm.getSpec().setJvmOptions(jvmOptions));\n-        DeploymentUtils.waitTillDepHasRolled(mmName, 1, mmPods);\n+        kubectlGetStrimzi(MM2_NAME);\n+        checkContainersHaveProcessOneAsTini(MM2_NAME);\n+    }\n \n-        KafkaMirrorMaker2Resource.replaceKafkaMirrorMaker2Resource(MM2_NAME, mm2 -> mm2.getSpec().setJvmOptions(jvmOptions));\n-        DeploymentUtils.waitTillDepHasRolled(mm2Name, 1, mm2Pods);\n+    @Test\n+    void testBridgeLogSetting() {\n+        KafkaBridgeResource.kafkaBridge(BRIDGE_NAME, CLUSTER_NAME, KafkaResources.plainBootstrapAddress(CLUSTER_NAME), 1)\n+            .editSpec()\n+                .withNewInlineLogging()\n+                    .withLoggers(BRIDGE_LOGGERS)\n+                .endInlineLogging()\n+                .withNewJvmOptions()\n+                    .withGcLoggingEnabled(true)\n+                .endJvmOptions()\n+            .endSpec()\n+            .done();\n \n-        assertThat(\"Kafka GC logging is disabled\", checkGcLoggingStatefulSets(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME)), is(false));\n-        assertThat(\"Zookeeper GC logging is disabled\", checkGcLoggingStatefulSets(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME)), is(false));\n+        String bridgeDepName = KafkaBridgeResources.deploymentName(BRIDGE_NAME);\n+        Map<String, String> bridgePods = DeploymentUtils.depSnapshot(bridgeDepName);\n \n-        assertThat(\"TO GC logging is disabled\", checkGcLoggingDeployments(KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME), \"topic-operator\"), is(false));\n-        assertThat(\"UO GC logging is disabled\", checkGcLoggingDeployments(KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME), \"user-operator\"), is(false));\n+        LOGGER.info(\"Checking if Bridge has log level set properly\");\n+        assertThat(\"Bridge's log level is set properly\", checkLoggersLevel(BRIDGE_LOGGERS, BRIDGE_MAP), is(true));\n+        assertThat(\"Bridge's GC logging is enabled\", checkGcLoggingDeployments(bridgeDepName), is(true));\n \n-        assertThat(\"Connect GC logging is disabled\", checkGcLoggingDeployments(KafkaConnectResources.deploymentName(CONNECT_NAME)), is(false));\n-        assertThat(\"Mirror-maker GC logging is disabled\", checkGcLoggingDeployments(KafkaMirrorMakerResources.deploymentName(MM_NAME)), is(false));\n-        assertThat(\"Mirror-maker2 GC logging is disabled\", checkGcLoggingDeployments(KafkaMirrorMaker2Resources.deploymentName(MM2_NAME)), is(false));\n+        KafkaBridgeResource.replaceBridgeResource(BRIDGE_NAME, bridge -> bridge.getSpec().setJvmOptions(JVM_OPTIONS));\n+        DeploymentUtils.waitTillDepHasRolled(bridgeDepName, 1, bridgePods);\n+        assertThat(\"Bridge GC logging is disabled\", checkGcLoggingDeployments(bridgeDepName), is(false));\n \n-        if (cluster.isNotKubernetes()) {\n-            assertThat(\"ConnectS2I GC logging is disabled\", checkGcLoggingDeploymentConfig(KafkaConnectS2IResources.deploymentName(CONNECTS2I_NAME)), is(false));\n-        }\n+        kubectlGetStrimzi(BRIDGE_NAME);\n+        checkContainersHaveProcessOneAsTini(BRIDGE_NAME);\n     }\n \n-    @Test\n-    @Order(13)\n-    void testKubectlGetStrimzi() {\n-        String userName = \"test-user\";\n-        String topicName = \"test-topic\";\n-\n-        KafkaTopicResource.topic(CLUSTER_NAME, topicName).done();\n-        KafkaUserResource.tlsUser(CLUSTER_NAME, userName).done();\n-\n+    void kubectlGetStrimzi(String resourceName) {\n+        LOGGER.info(\"Checking if kubectl get strimzi contains {}\", resourceName);\n         String strimziCRs = cmdKubeClient().execInCurrentNamespace(\"get\", \"strimzi\").out();\n-\n-        assertThat(strimziCRs, containsString(CLUSTER_NAME));\n-        assertThat(strimziCRs, containsString(GC_LOGGING_SET_NAME));\n-        assertThat(strimziCRs, containsString(MM_NAME));\n-        assertThat(strimziCRs, containsString(MM2_NAME));\n-        assertThat(strimziCRs, containsString(BRIDGE_NAME));\n-        assertThat(strimziCRs, containsString(CONNECT_NAME));\n-        assertThat(strimziCRs, containsString(userName));\n-        assertThat(strimziCRs, containsString(topicName));\n+        assertThat(strimziCRs, containsString(resourceName));\n     }\n \n-    @Test\n-    @Order(14)\n-    void testCheckContainersHaveProcessOneAsTini() {\n+    void checkContainersHaveProcessOneAsTini(String resourceClusterName) {\n         //Used [/] in the grep command so that grep process does not return itself\n         String command = \"ps -ef | grep '[/]usr/bin/tini' | awk '{ print $2}'\";\n \n-        for (Pod pod : kubeClient().listPods()) {\n+        for (Pod pod : kubeClient().listPods(Labels.STRIMZI_CLUSTER_LABEL, resourceClusterName)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0MjQ3OA=="}, "originalCommit": {"oid": "8827905694df58f631aa59a40e48951cf58c6664"}, "originalPosition": 374}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3OTkwMDYyOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LogSettingST.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMDo1OToyMlrOHkI6SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMDo1OTo1N1rOHkI7mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY1Njc3Nw==", "bodyText": "leftover?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3805#discussion_r507656777", "createdAt": "2020-10-19T10:59:22Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LogSettingST.java", "diffHunk": "@@ -182,181 +188,224 @@\n     };\n \n     @Test\n-    @Order(1)\n-    void testLoggersKafka() {\n-        assertThat(\"Kafka's log level is set properly\", checkLoggersLevel(KAFKA_LOGGERS, KAFKA_MAP), is(true));\n-    }\n+    void testKafkaLogSetting() {\n+        String eoDepName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        String kafkaSsName = KafkaResources.kafkaStatefulSetName(CLUSTER_NAME);\n+        String zkSsName = KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME);\n \n-    @Test\n-    @Order(2)\n-    void testLoggersZookeeper() {\n-        assertThat(\"Zookeeper's log level is set properly\", checkLoggersLevel(ZOOKEEPER_LOGGERS, ZOOKEEPER_MAP), is(true));\n-    }\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDepName);\n+        Map<String, String> kafkaPods = StatefulSetUtils.ssSnapshot(kafkaSsName);\n+        Map<String, String> zkPods = StatefulSetUtils.ssSnapshot(zkSsName);\n \n-    @Test\n-    @Order(3)\n-    void testLoggersTO() {\n-        assertThat(\"Topic operator's log level is set properly\", checkLoggersLevel(OPERATORS_LOGGERS, TO_MAP), is(true));\n-    }\n+        String userName = \"test-user\";\n+        String topicName = \"test-topic\";\n \n-    @Test\n-    @Order(4)\n-    void testLoggersUO() {\n+        KafkaTopicResource.topic(CLUSTER_NAME, topicName).done();\n+        KafkaUserResource.tlsUser(CLUSTER_NAME, userName).done();\n+\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has log level set properly\", CLUSTER_NAME);\n+        assertThat(\"Kafka's log level is set properly\", checkLoggersLevel(KAFKA_LOGGERS, KAFKA_MAP), is(true));\n+        assertThat(\"Zookeeper's log level is set properly\", checkLoggersLevel(ZOOKEEPER_LOGGERS, ZOOKEEPER_MAP), is(true));\n+        assertThat(\"Topic operator's log level is set properly\", checkLoggersLevel(OPERATORS_LOGGERS, TO_MAP), is(true));\n         assertThat(\"User operator's log level is set properly\", checkLoggersLevel(OPERATORS_LOGGERS, UO_MAP), is(true));\n-    }\n \n-    @Test\n-    @Order(5)\n-    void testLoggersKafkaConnect() {\n-        assertThat(\"Kafka connect's log level is set properly\", checkLoggersLevel(CONNECT_LOGGERS, CONNECT_MAP), is(true));\n-    }\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has GC logging enabled in stateful sets/deployments\", CLUSTER_NAME);\n+        assertThat(\"Kafka GC logging is not enabled\", checkGcLoggingStatefulSets(kafkaSsName), is(true));\n+        assertThat(\"Zookeeper GC logging is enabled\", checkGcLoggingStatefulSets(zkSsName), is(true));\n+        assertThat(\"TO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"topic-operator\"), is(true));\n+        assertThat(\"UO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"user-operator\"), is(true));\n+\n+        LOGGER.info(\"Changing JVM options - setting GC logging to false\");\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setJvmOptions(JVM_OPTIONS);\n+            kafka.getSpec().getZookeeper().setJvmOptions(JVM_OPTIONS);\n+            kafka.getSpec().getEntityOperator().getTopicOperator().setJvmOptions(JVM_OPTIONS);\n+            kafka.getSpec().getEntityOperator().getUserOperator().setJvmOptions(JVM_OPTIONS);\n+        });\n \n-    @Test\n-    @Order(6)\n-    void testLoggersMirrorMaker() {\n-        assertThat(\"KafkaMirrorMaker's log level is set properly\", checkLoggersLevel(MIRROR_MAKER_LOGGERS, MM_MAP), is(true));\n-    }\n+        StatefulSetUtils.waitTillSsHasRolled(zkSsName, 1, zkPods);\n+        StatefulSetUtils.waitTillSsHasRolled(kafkaSsName, 3, kafkaPods);\n+        DeploymentUtils.waitTillDepHasRolled(eoDepName, 1, eoPods);\n \n-    @Test\n-    @Order(7)\n-    void testLoggersMirrorMaker2() {\n-        assertThat(\"KafkaMirrorMaker2's log level is set properly\", checkLoggersLevel(MIRROR_MAKER_LOGGERS, MM2_MAP), is(true));\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has GC logging disabled in stateful sets/deployments\", CLUSTER_NAME);\n+        assertThat(\"Kafka GC logging is disabled\", checkGcLoggingStatefulSets(kafkaSsName), is(false));\n+        assertThat(\"Zookeeper GC logging is disabled\", checkGcLoggingStatefulSets(zkSsName), is(false));\n+        assertThat(\"TO GC logging is disabled\", checkGcLoggingDeployments(eoDepName, \"topic-operator\"), is(false));\n+        assertThat(\"UO GC logging is disabled\", checkGcLoggingDeployments(eoDepName, \"user-operator\"), is(false));\n+\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has GC logging disabled in stateful sets/deployments\", GC_LOGGING_SET_NAME);\n+        assertThat(\"Kafka GC logging is enabled\", checkGcLoggingStatefulSets(kafkaSsName), is(false));\n+        assertThat(\"Zookeeper GC logging is enabled\", checkGcLoggingStatefulSets(zkSsName), is(false));\n+        assertThat(\"TO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"topic-operator\"), is(false));\n+        assertThat(\"UO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"user-operator\"), is(false));\n+\n+//        kubectlGetStrimzi(CLUSTER_NAME);\n+//        kubectlGetStrimzi(GC_LOGGING_SET_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39ae6caf0ee29937059ad619fd763e2d87f346df"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY1NzExMw==", "bodyText": "yep, sorry", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3805#discussion_r507657113", "createdAt": "2020-10-19T10:59:57Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LogSettingST.java", "diffHunk": "@@ -182,181 +188,224 @@\n     };\n \n     @Test\n-    @Order(1)\n-    void testLoggersKafka() {\n-        assertThat(\"Kafka's log level is set properly\", checkLoggersLevel(KAFKA_LOGGERS, KAFKA_MAP), is(true));\n-    }\n+    void testKafkaLogSetting() {\n+        String eoDepName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        String kafkaSsName = KafkaResources.kafkaStatefulSetName(CLUSTER_NAME);\n+        String zkSsName = KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME);\n \n-    @Test\n-    @Order(2)\n-    void testLoggersZookeeper() {\n-        assertThat(\"Zookeeper's log level is set properly\", checkLoggersLevel(ZOOKEEPER_LOGGERS, ZOOKEEPER_MAP), is(true));\n-    }\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDepName);\n+        Map<String, String> kafkaPods = StatefulSetUtils.ssSnapshot(kafkaSsName);\n+        Map<String, String> zkPods = StatefulSetUtils.ssSnapshot(zkSsName);\n \n-    @Test\n-    @Order(3)\n-    void testLoggersTO() {\n-        assertThat(\"Topic operator's log level is set properly\", checkLoggersLevel(OPERATORS_LOGGERS, TO_MAP), is(true));\n-    }\n+        String userName = \"test-user\";\n+        String topicName = \"test-topic\";\n \n-    @Test\n-    @Order(4)\n-    void testLoggersUO() {\n+        KafkaTopicResource.topic(CLUSTER_NAME, topicName).done();\n+        KafkaUserResource.tlsUser(CLUSTER_NAME, userName).done();\n+\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has log level set properly\", CLUSTER_NAME);\n+        assertThat(\"Kafka's log level is set properly\", checkLoggersLevel(KAFKA_LOGGERS, KAFKA_MAP), is(true));\n+        assertThat(\"Zookeeper's log level is set properly\", checkLoggersLevel(ZOOKEEPER_LOGGERS, ZOOKEEPER_MAP), is(true));\n+        assertThat(\"Topic operator's log level is set properly\", checkLoggersLevel(OPERATORS_LOGGERS, TO_MAP), is(true));\n         assertThat(\"User operator's log level is set properly\", checkLoggersLevel(OPERATORS_LOGGERS, UO_MAP), is(true));\n-    }\n \n-    @Test\n-    @Order(5)\n-    void testLoggersKafkaConnect() {\n-        assertThat(\"Kafka connect's log level is set properly\", checkLoggersLevel(CONNECT_LOGGERS, CONNECT_MAP), is(true));\n-    }\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has GC logging enabled in stateful sets/deployments\", CLUSTER_NAME);\n+        assertThat(\"Kafka GC logging is not enabled\", checkGcLoggingStatefulSets(kafkaSsName), is(true));\n+        assertThat(\"Zookeeper GC logging is enabled\", checkGcLoggingStatefulSets(zkSsName), is(true));\n+        assertThat(\"TO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"topic-operator\"), is(true));\n+        assertThat(\"UO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"user-operator\"), is(true));\n+\n+        LOGGER.info(\"Changing JVM options - setting GC logging to false\");\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setJvmOptions(JVM_OPTIONS);\n+            kafka.getSpec().getZookeeper().setJvmOptions(JVM_OPTIONS);\n+            kafka.getSpec().getEntityOperator().getTopicOperator().setJvmOptions(JVM_OPTIONS);\n+            kafka.getSpec().getEntityOperator().getUserOperator().setJvmOptions(JVM_OPTIONS);\n+        });\n \n-    @Test\n-    @Order(6)\n-    void testLoggersMirrorMaker() {\n-        assertThat(\"KafkaMirrorMaker's log level is set properly\", checkLoggersLevel(MIRROR_MAKER_LOGGERS, MM_MAP), is(true));\n-    }\n+        StatefulSetUtils.waitTillSsHasRolled(zkSsName, 1, zkPods);\n+        StatefulSetUtils.waitTillSsHasRolled(kafkaSsName, 3, kafkaPods);\n+        DeploymentUtils.waitTillDepHasRolled(eoDepName, 1, eoPods);\n \n-    @Test\n-    @Order(7)\n-    void testLoggersMirrorMaker2() {\n-        assertThat(\"KafkaMirrorMaker2's log level is set properly\", checkLoggersLevel(MIRROR_MAKER_LOGGERS, MM2_MAP), is(true));\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has GC logging disabled in stateful sets/deployments\", CLUSTER_NAME);\n+        assertThat(\"Kafka GC logging is disabled\", checkGcLoggingStatefulSets(kafkaSsName), is(false));\n+        assertThat(\"Zookeeper GC logging is disabled\", checkGcLoggingStatefulSets(zkSsName), is(false));\n+        assertThat(\"TO GC logging is disabled\", checkGcLoggingDeployments(eoDepName, \"topic-operator\"), is(false));\n+        assertThat(\"UO GC logging is disabled\", checkGcLoggingDeployments(eoDepName, \"user-operator\"), is(false));\n+\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has GC logging disabled in stateful sets/deployments\", GC_LOGGING_SET_NAME);\n+        assertThat(\"Kafka GC logging is enabled\", checkGcLoggingStatefulSets(kafkaSsName), is(false));\n+        assertThat(\"Zookeeper GC logging is enabled\", checkGcLoggingStatefulSets(zkSsName), is(false));\n+        assertThat(\"TO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"topic-operator\"), is(false));\n+        assertThat(\"UO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"user-operator\"), is(false));\n+\n+//        kubectlGetStrimzi(CLUSTER_NAME);\n+//        kubectlGetStrimzi(GC_LOGGING_SET_NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY1Njc3Nw=="}, "originalCommit": {"oid": "39ae6caf0ee29937059ad619fd763e2d87f346df"}, "originalPosition": 128}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 924, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}