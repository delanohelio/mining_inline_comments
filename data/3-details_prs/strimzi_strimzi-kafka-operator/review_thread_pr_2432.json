{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1MDA4NTcx", "number": 2432, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwODo1NzoyN1rODZalPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNDo1MzoyNFrODb8XXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3OTc2NTA5OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaBrokerConfigurationBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwODo1NzoyN1rOFfyZAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwOTowNToxNFrOFfymog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NTc3Nw==", "bodyText": "Should we maybe split this into two methods? configureSimpleAuthorization and configureKeycloakAuthorization?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r368875777", "createdAt": "2020-01-21T08:57:27Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaBrokerConfigurationBuilder.java", "diffHunk": "@@ -369,32 +370,64 @@ private String getSecurityProtocol(boolean tls, boolean sasl)   {\n     public KafkaBrokerConfigurationBuilder withAuthorization(String clusterName, KafkaAuthorization authorization)  {\n         if (authorization != null) {\n             List<String> superUsers = new ArrayList<>();\n-            String authorizerClass = \"\";\n \n             // Broker super users\n             superUsers.add(String.format(\"User:CN=%s,O=io.strimzi\", KafkaResources.kafkaStatefulSetName(clusterName)));\n             superUsers.add(String.format(\"User:CN=%s-%s,O=io.strimzi\", clusterName, \"entity-operator\"));\n             superUsers.add(String.format(\"User:CN=%s-%s,O=io.strimzi\", clusterName, \"kafka-exporter\"));\n \n-            // User configured super users\n-            if (KafkaAuthorizationSimple.TYPE_SIMPLE.equals(authorization.getType())) {\n-                KafkaAuthorizationSimple simpleAuthz = (KafkaAuthorizationSimple) authorization;\n-                authorizerClass = KafkaAuthorizationSimple.AUTHORIZER_CLASS_NAME;\n-\n-                if (simpleAuthz.getSuperUsers() != null && simpleAuthz.getSuperUsers().size() > 0) {\n-                    superUsers.addAll(simpleAuthz.getSuperUsers().stream().map(e -> String.format(\"User:%s\", e)).collect(Collectors.toList()));\n-                }\n-            }\n-\n             printSectionHeader(\"Authorization\");\n-            writer.println(\"authorizer.class.name=\" + authorizerClass);\n+            configureAuthorization(clusterName, superUsers, authorization);\n             writer.println(\"super.users=\" + String.join(\";\", superUsers));\n             writer.println();\n         }\n \n         return this;\n     }\n \n+    /**\n+     * Configures authorization for the Kafka brokers. This method is used only internally.\n+     *\n+     * @param clusterName Name of the cluster\n+     * @param superUsers Super users list who have all the rights on the cluster\n+     * @param authorization The authorization configuration from the Kafka CR\n+     */\n+    private void configureAuthorization(String clusterName, List<String> superUsers, KafkaAuthorization authorization) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fecbfe54fb8c01a5243dba44e431ce25ef048b30"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3OTI2Ng==", "bodyText": "We already have a similar pattern for configuring authentication on which I agree. The configuraAuthentication method is just one and we have the logic for different authentication mechanisms inside. I am not sure about the advantage of having different methods here.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r368879266", "createdAt": "2020-01-21T09:05:14Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaBrokerConfigurationBuilder.java", "diffHunk": "@@ -369,32 +370,64 @@ private String getSecurityProtocol(boolean tls, boolean sasl)   {\n     public KafkaBrokerConfigurationBuilder withAuthorization(String clusterName, KafkaAuthorization authorization)  {\n         if (authorization != null) {\n             List<String> superUsers = new ArrayList<>();\n-            String authorizerClass = \"\";\n \n             // Broker super users\n             superUsers.add(String.format(\"User:CN=%s,O=io.strimzi\", KafkaResources.kafkaStatefulSetName(clusterName)));\n             superUsers.add(String.format(\"User:CN=%s-%s,O=io.strimzi\", clusterName, \"entity-operator\"));\n             superUsers.add(String.format(\"User:CN=%s-%s,O=io.strimzi\", clusterName, \"kafka-exporter\"));\n \n-            // User configured super users\n-            if (KafkaAuthorizationSimple.TYPE_SIMPLE.equals(authorization.getType())) {\n-                KafkaAuthorizationSimple simpleAuthz = (KafkaAuthorizationSimple) authorization;\n-                authorizerClass = KafkaAuthorizationSimple.AUTHORIZER_CLASS_NAME;\n-\n-                if (simpleAuthz.getSuperUsers() != null && simpleAuthz.getSuperUsers().size() > 0) {\n-                    superUsers.addAll(simpleAuthz.getSuperUsers().stream().map(e -> String.format(\"User:%s\", e)).collect(Collectors.toList()));\n-                }\n-            }\n-\n             printSectionHeader(\"Authorization\");\n-            writer.println(\"authorizer.class.name=\" + authorizerClass);\n+            configureAuthorization(clusterName, superUsers, authorization);\n             writer.println(\"super.users=\" + String.join(\";\", superUsers));\n             writer.println();\n         }\n \n         return this;\n     }\n \n+    /**\n+     * Configures authorization for the Kafka brokers. This method is used only internally.\n+     *\n+     * @param clusterName Name of the cluster\n+     * @param superUsers Super users list who have all the rights on the cluster\n+     * @param authorization The authorization configuration from the Kafka CR\n+     */\n+    private void configureAuthorization(String clusterName, List<String> superUsers, KafkaAuthorization authorization) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NTc3Nw=="}, "originalCommit": {"oid": "fecbfe54fb8c01a5243dba44e431ce25ef048b30"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3OTc2OTkxOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwODo1ODo1OVrOFfyb0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwOTowNjoxMFrOFfyoTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NjQ5Ng==", "bodyText": "Maybe I forgot something, but don't you need to also add it to the volumes somewhere?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r368876496", "createdAt": "2020-01-21T08:58:59Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -1475,6 +1484,11 @@ private void setDataVolumesClaimsAndMountPaths(Storage storage) {\n             }\n         }\n \n+        if (authorization instanceof KafkaAuthorizationKeycloak) {\n+            KafkaAuthorizationKeycloak keycloakAuthz = (KafkaAuthorizationKeycloak) authorization;\n+            volumeMountList.addAll(AuthenticationUtils.configureOauthCertificateVolumeMounts(\"authz-keycloak\", keycloakAuthz.getTlsTrustedCertificates(), OAUTH_TRUSTED_CERTS_BASE_VOLUME_MOUNT + \"/authz-keycloak-certs\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fecbfe54fb8c01a5243dba44e431ce25ef048b30"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3OTY5NA==", "bodyText": "yep, I forgot it :-)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r368879694", "createdAt": "2020-01-21T09:06:10Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -1475,6 +1484,11 @@ private void setDataVolumesClaimsAndMountPaths(Storage storage) {\n             }\n         }\n \n+        if (authorization instanceof KafkaAuthorizationKeycloak) {\n+            KafkaAuthorizationKeycloak keycloakAuthz = (KafkaAuthorizationKeycloak) authorization;\n+            volumeMountList.addAll(AuthenticationUtils.configureOauthCertificateVolumeMounts(\"authz-keycloak\", keycloakAuthz.getTlsTrustedCertificates(), OAUTH_TRUSTED_CERTS_BASE_VOLUME_MOUNT + \"/authz-keycloak-certs\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NjQ5Ng=="}, "originalCommit": {"oid": "fecbfe54fb8c01a5243dba44e431ce25ef048b30"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3OTc3MzU4OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaBrokerConfigurationBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwOTowMDoxM1rOFfyd9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwOTozODo0NVrOFfzlug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NzA0Nw==", "bodyText": "Can you double check what impact does this have on the internal super users? Do they still keey their own names?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r368877047", "createdAt": "2020-01-21T09:00:13Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaBrokerConfigurationBuilder.java", "diffHunk": "@@ -369,32 +370,64 @@ private String getSecurityProtocol(boolean tls, boolean sasl)   {\n     public KafkaBrokerConfigurationBuilder withAuthorization(String clusterName, KafkaAuthorization authorization)  {\n         if (authorization != null) {\n             List<String> superUsers = new ArrayList<>();\n-            String authorizerClass = \"\";\n \n             // Broker super users\n             superUsers.add(String.format(\"User:CN=%s,O=io.strimzi\", KafkaResources.kafkaStatefulSetName(clusterName)));\n             superUsers.add(String.format(\"User:CN=%s-%s,O=io.strimzi\", clusterName, \"entity-operator\"));\n             superUsers.add(String.format(\"User:CN=%s-%s,O=io.strimzi\", clusterName, \"kafka-exporter\"));\n \n-            // User configured super users\n-            if (KafkaAuthorizationSimple.TYPE_SIMPLE.equals(authorization.getType())) {\n-                KafkaAuthorizationSimple simpleAuthz = (KafkaAuthorizationSimple) authorization;\n-                authorizerClass = KafkaAuthorizationSimple.AUTHORIZER_CLASS_NAME;\n-\n-                if (simpleAuthz.getSuperUsers() != null && simpleAuthz.getSuperUsers().size() > 0) {\n-                    superUsers.addAll(simpleAuthz.getSuperUsers().stream().map(e -> String.format(\"User:%s\", e)).collect(Collectors.toList()));\n-                }\n-            }\n-\n             printSectionHeader(\"Authorization\");\n-            writer.println(\"authorizer.class.name=\" + authorizerClass);\n+            configureAuthorization(clusterName, superUsers, authorization);\n             writer.println(\"super.users=\" + String.join(\";\", superUsers));\n             writer.println();\n         }\n \n         return this;\n     }\n \n+    /**\n+     * Configures authorization for the Kafka brokers. This method is used only internally.\n+     *\n+     * @param clusterName Name of the cluster\n+     * @param superUsers Super users list who have all the rights on the cluster\n+     * @param authorization The authorization configuration from the Kafka CR\n+     */\n+    private void configureAuthorization(String clusterName, List<String> superUsers, KafkaAuthorization authorization) {\n+        if (KafkaAuthorizationSimple.TYPE_SIMPLE.equals(authorization.getType())) {\n+            KafkaAuthorizationSimple simpleAuthz = (KafkaAuthorizationSimple) authorization;\n+            writer.println(\"authorizer.class.name=\" + KafkaAuthorizationSimple.AUTHORIZER_CLASS_NAME);\n+\n+            // User configured super users\n+            if (simpleAuthz.getSuperUsers() != null && simpleAuthz.getSuperUsers().size() > 0) {\n+                superUsers.addAll(simpleAuthz.getSuperUsers().stream().map(e -> String.format(\"User:%s\", e)).collect(Collectors.toList()));\n+            }\n+        } else if (KafkaAuthorizationKeycloak.TYPE_KEYCLOAK.equals(authorization.getType())) {\n+            KafkaAuthorizationKeycloak keycloakAuthz = (KafkaAuthorizationKeycloak) authorization;\n+            writer.println(\"authorizer.class.name=\" + KafkaAuthorizationKeycloak.AUTHORIZER_CLASS_NAME);\n+            writer.println(\"principal.builder.class=\" + KafkaAuthorizationKeycloak.PRINCIPAL_BUILDER_CLASS_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fecbfe54fb8c01a5243dba44e431ce25ef048b30"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg5NTQxOA==", "bodyText": "They should keep their names, yes.\nThe JwtKafkaPrincipalBuilder only does something different when user was authenticated over SASL_OAUTHBEARER as seen here. An internal user would be handled by the same logic as before.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r368895418", "createdAt": "2020-01-21T09:38:45Z", "author": {"login": "mstruk"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaBrokerConfigurationBuilder.java", "diffHunk": "@@ -369,32 +370,64 @@ private String getSecurityProtocol(boolean tls, boolean sasl)   {\n     public KafkaBrokerConfigurationBuilder withAuthorization(String clusterName, KafkaAuthorization authorization)  {\n         if (authorization != null) {\n             List<String> superUsers = new ArrayList<>();\n-            String authorizerClass = \"\";\n \n             // Broker super users\n             superUsers.add(String.format(\"User:CN=%s,O=io.strimzi\", KafkaResources.kafkaStatefulSetName(clusterName)));\n             superUsers.add(String.format(\"User:CN=%s-%s,O=io.strimzi\", clusterName, \"entity-operator\"));\n             superUsers.add(String.format(\"User:CN=%s-%s,O=io.strimzi\", clusterName, \"kafka-exporter\"));\n \n-            // User configured super users\n-            if (KafkaAuthorizationSimple.TYPE_SIMPLE.equals(authorization.getType())) {\n-                KafkaAuthorizationSimple simpleAuthz = (KafkaAuthorizationSimple) authorization;\n-                authorizerClass = KafkaAuthorizationSimple.AUTHORIZER_CLASS_NAME;\n-\n-                if (simpleAuthz.getSuperUsers() != null && simpleAuthz.getSuperUsers().size() > 0) {\n-                    superUsers.addAll(simpleAuthz.getSuperUsers().stream().map(e -> String.format(\"User:%s\", e)).collect(Collectors.toList()));\n-                }\n-            }\n-\n             printSectionHeader(\"Authorization\");\n-            writer.println(\"authorizer.class.name=\" + authorizerClass);\n+            configureAuthorization(clusterName, superUsers, authorization);\n             writer.println(\"super.users=\" + String.join(\";\", superUsers));\n             writer.println();\n         }\n \n         return this;\n     }\n \n+    /**\n+     * Configures authorization for the Kafka brokers. This method is used only internally.\n+     *\n+     * @param clusterName Name of the cluster\n+     * @param superUsers Super users list who have all the rights on the cluster\n+     * @param authorization The authorization configuration from the Kafka CR\n+     */\n+    private void configureAuthorization(String clusterName, List<String> superUsers, KafkaAuthorization authorization) {\n+        if (KafkaAuthorizationSimple.TYPE_SIMPLE.equals(authorization.getType())) {\n+            KafkaAuthorizationSimple simpleAuthz = (KafkaAuthorizationSimple) authorization;\n+            writer.println(\"authorizer.class.name=\" + KafkaAuthorizationSimple.AUTHORIZER_CLASS_NAME);\n+\n+            // User configured super users\n+            if (simpleAuthz.getSuperUsers() != null && simpleAuthz.getSuperUsers().size() > 0) {\n+                superUsers.addAll(simpleAuthz.getSuperUsers().stream().map(e -> String.format(\"User:%s\", e)).collect(Collectors.toList()));\n+            }\n+        } else if (KafkaAuthorizationKeycloak.TYPE_KEYCLOAK.equals(authorization.getType())) {\n+            KafkaAuthorizationKeycloak keycloakAuthz = (KafkaAuthorizationKeycloak) authorization;\n+            writer.println(\"authorizer.class.name=\" + KafkaAuthorizationKeycloak.AUTHORIZER_CLASS_NAME);\n+            writer.println(\"principal.builder.class=\" + KafkaAuthorizationKeycloak.PRINCIPAL_BUILDER_CLASS_NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NzA0Nw=="}, "originalCommit": {"oid": "fecbfe54fb8c01a5243dba44e431ce25ef048b30"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NTE3MDQ2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaAuthorizationKeycloak.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzo1NTozOVrOFiDaog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDo0MDowOFrOFiE-BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MTg3NA==", "bodyText": "hostname verification of what? Presumably the authz serverm but you should say that.\nAnd should it be \"enable...\", defaulting to true?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r371251874", "createdAt": "2020-01-27T13:55:39Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaAuthorizationKeycloak.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Example;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.util.List;\n+\n+/**\n+ * Configures Keycloak authorization on the brokers\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"type\", \"clientId\", \"tokenEndpointUri\",\n+                    \"tlsTrustedCertificates\", \"disableTlsHostnameVerification\",\n+                    \"delegateToKafkaAcls\", \"superUsers\"})\n+@EqualsAndHashCode\n+public class KafkaAuthorizationKeycloak extends KafkaAuthorization {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String TYPE_KEYCLOAK = \"keycloak\";\n+\n+    public static final String AUTHORIZER_CLASS_NAME = \"io.strimzi.kafka.oauth.server.authorizer.KeycloakRBACAuthorizer\";\n+    public static final String PRINCIPAL_BUILDER_CLASS_NAME = \"io.strimzi.kafka.oauth.server.authorizer.JwtKafkaPrincipalBuilder\";\n+\n+    private String clientId;\n+    private String tokenEndpointUri;\n+    private List<CertSecretSource> tlsTrustedCertificates;\n+    private boolean disableTlsHostnameVerification = false;\n+    private boolean delegateToKafkaAcls = false;\n+    private List<String> superUsers;\n+\n+    @Description(\"Must be `\" + TYPE_KEYCLOAK + \"`\")\n+    @Override\n+    public String getType() {\n+        return TYPE_KEYCLOAK;\n+    }\n+\n+    @Description(\"OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.\")\n+    @JsonProperty(required = true)\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    public void setClientId(String clientId) {\n+        this.clientId = clientId;\n+    }\n+\n+    @Description(\"Authorization server token endpoint URI.\")\n+    @JsonProperty(required = true)\n+    public String getTokenEndpointUri() {\n+        return tokenEndpointUri;\n+    }\n+\n+    public void setTokenEndpointUri(String tokenEndpointUri) {\n+        this.tokenEndpointUri = tokenEndpointUri;\n+    }\n+\n+    @Description(\"Trusted certificates for TLS connection to the OAuth server.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public List<CertSecretSource> getTlsTrustedCertificates() {\n+        return tlsTrustedCertificates;\n+    }\n+\n+    public void setTlsTrustedCertificates(List<CertSecretSource> tlsTrustedCertificates) {\n+        this.tlsTrustedCertificates = tlsTrustedCertificates;\n+    }\n+\n+    @Description(\"Enable or disable TLS hostname verification. \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af2861e52c6a40d3e9d11574ee26ac0cbecbe99e"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3NDI2OA==", "bodyText": "I used the same convention of the other OAuth authentication classes (i.e. see KafkaListenerAuthenticationOAuth)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r371274268", "createdAt": "2020-01-27T14:35:07Z", "author": {"login": "ppatierno"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaAuthorizationKeycloak.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Example;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.util.List;\n+\n+/**\n+ * Configures Keycloak authorization on the brokers\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"type\", \"clientId\", \"tokenEndpointUri\",\n+                    \"tlsTrustedCertificates\", \"disableTlsHostnameVerification\",\n+                    \"delegateToKafkaAcls\", \"superUsers\"})\n+@EqualsAndHashCode\n+public class KafkaAuthorizationKeycloak extends KafkaAuthorization {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String TYPE_KEYCLOAK = \"keycloak\";\n+\n+    public static final String AUTHORIZER_CLASS_NAME = \"io.strimzi.kafka.oauth.server.authorizer.KeycloakRBACAuthorizer\";\n+    public static final String PRINCIPAL_BUILDER_CLASS_NAME = \"io.strimzi.kafka.oauth.server.authorizer.JwtKafkaPrincipalBuilder\";\n+\n+    private String clientId;\n+    private String tokenEndpointUri;\n+    private List<CertSecretSource> tlsTrustedCertificates;\n+    private boolean disableTlsHostnameVerification = false;\n+    private boolean delegateToKafkaAcls = false;\n+    private List<String> superUsers;\n+\n+    @Description(\"Must be `\" + TYPE_KEYCLOAK + \"`\")\n+    @Override\n+    public String getType() {\n+        return TYPE_KEYCLOAK;\n+    }\n+\n+    @Description(\"OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.\")\n+    @JsonProperty(required = true)\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    public void setClientId(String clientId) {\n+        this.clientId = clientId;\n+    }\n+\n+    @Description(\"Authorization server token endpoint URI.\")\n+    @JsonProperty(required = true)\n+    public String getTokenEndpointUri() {\n+        return tokenEndpointUri;\n+    }\n+\n+    public void setTokenEndpointUri(String tokenEndpointUri) {\n+        this.tokenEndpointUri = tokenEndpointUri;\n+    }\n+\n+    @Description(\"Trusted certificates for TLS connection to the OAuth server.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public List<CertSecretSource> getTlsTrustedCertificates() {\n+        return tlsTrustedCertificates;\n+    }\n+\n+    public void setTlsTrustedCertificates(List<CertSecretSource> tlsTrustedCertificates) {\n+        this.tlsTrustedCertificates = tlsTrustedCertificates;\n+    }\n+\n+    @Description(\"Enable or disable TLS hostname verification. \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MTg3NA=="}, "originalCommit": {"oid": "af2861e52c6a40d3e9d11574ee26ac0cbecbe99e"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3NzMxNg==", "bodyText": "OK", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r371277316", "createdAt": "2020-01-27T14:40:08Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/KafkaAuthorizationKeycloak.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.Example;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.util.List;\n+\n+/**\n+ * Configures Keycloak authorization on the brokers\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        generateBuilderPackage = false,\n+        builderPackage = \"io.fabric8.kubernetes.api.builder\"\n+)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder({\"type\", \"clientId\", \"tokenEndpointUri\",\n+                    \"tlsTrustedCertificates\", \"disableTlsHostnameVerification\",\n+                    \"delegateToKafkaAcls\", \"superUsers\"})\n+@EqualsAndHashCode\n+public class KafkaAuthorizationKeycloak extends KafkaAuthorization {\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String TYPE_KEYCLOAK = \"keycloak\";\n+\n+    public static final String AUTHORIZER_CLASS_NAME = \"io.strimzi.kafka.oauth.server.authorizer.KeycloakRBACAuthorizer\";\n+    public static final String PRINCIPAL_BUILDER_CLASS_NAME = \"io.strimzi.kafka.oauth.server.authorizer.JwtKafkaPrincipalBuilder\";\n+\n+    private String clientId;\n+    private String tokenEndpointUri;\n+    private List<CertSecretSource> tlsTrustedCertificates;\n+    private boolean disableTlsHostnameVerification = false;\n+    private boolean delegateToKafkaAcls = false;\n+    private List<String> superUsers;\n+\n+    @Description(\"Must be `\" + TYPE_KEYCLOAK + \"`\")\n+    @Override\n+    public String getType() {\n+        return TYPE_KEYCLOAK;\n+    }\n+\n+    @Description(\"OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.\")\n+    @JsonProperty(required = true)\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    public void setClientId(String clientId) {\n+        this.clientId = clientId;\n+    }\n+\n+    @Description(\"Authorization server token endpoint URI.\")\n+    @JsonProperty(required = true)\n+    public String getTokenEndpointUri() {\n+        return tokenEndpointUri;\n+    }\n+\n+    public void setTokenEndpointUri(String tokenEndpointUri) {\n+        this.tokenEndpointUri = tokenEndpointUri;\n+    }\n+\n+    @Description(\"Trusted certificates for TLS connection to the OAuth server.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public List<CertSecretSource> getTlsTrustedCertificates() {\n+        return tlsTrustedCertificates;\n+    }\n+\n+    public void setTlsTrustedCertificates(List<CertSecretSource> tlsTrustedCertificates) {\n+        this.tlsTrustedCertificates = tlsTrustedCertificates;\n+    }\n+\n+    @Description(\"Enable or disable TLS hostname verification. \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MTg3NA=="}, "originalCommit": {"oid": "af2861e52c6a40d3e9d11574ee26ac0cbecbe99e"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NTE4MjQzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/KafkaClusterTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzo1ODo1OVrOFiDhuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzo1ODo1OVrOFiDhuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MzY4OQ==", "bodyText": "There are a couple of variables you can usefully factor out here.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r371253689", "createdAt": "2020-01-27T13:58:59Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/KafkaClusterTest.java", "diffHunk": "@@ -3222,4 +3223,83 @@ public void testCustomCertificateTls() {\n         assertThat(k.getSecretSourceTls().getKey(), is(key));\n         assertThat(k.getSecretSourceTls().getCertificate(), is(cert));\n     }\n+\n+    @Test\n+    public void testGenerateDeploymentWithKeycloakAuthorizationMissingOAuthListeners() {\n+        assertThrows(InvalidResourceException.class, () -> {\n+            Kafka kafkaAssembly = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas,\n+                    image, healthDelay, healthTimeout, metricsCm, configuration, emptyMap()))\n+                    .editSpec()\n+                    .editKafka()\n+                    .withAuthorization(\n+                            new KafkaAuthorizationKeycloakBuilder()\n+                                    .build())\n+                    .endKafka()\n+                    .endSpec()\n+                    .build();\n+\n+            KafkaCluster.fromCrd(kafkaAssembly, VERSIONS);\n+        });\n+    }\n+\n+    @Test\n+    public void testGenerateDeploymentWithKeycloakAuthorization() {\n+        CertSecretSource cert1 = new CertSecretSourceBuilder()\n+                .withSecretName(\"first-certificate\")\n+                .withCertificate(\"ca.crt\")\n+                .build();\n+\n+        CertSecretSource cert2 = new CertSecretSourceBuilder()\n+                .withSecretName(\"second-certificate\")\n+                .withCertificate(\"tls.crt\")\n+                .build();\n+\n+        Kafka kafkaAssembly = new KafkaBuilder(ResourceUtils.createKafkaCluster(namespace, cluster, replicas,\n+                image, healthDelay, healthTimeout, metricsCm, configuration, emptyMap()))\n+                .editSpec()\n+                .editKafka()\n+                .withNewListeners()\n+                    .withNewPlain()\n+                        .withAuth(\n+                                new KafkaListenerAuthenticationOAuthBuilder()\n+                                        .withClientId(\"my-client-id\")\n+                                        .withValidIssuerUri(\"http://valid-issuer\")\n+                                        .withIntrospectionEndpointUri(\"http://introspection\")\n+                                        .withNewClientSecret()\n+                                            .withSecretName(\"my-secret-secret\")\n+                                            .withKey(\"my-secret-key\")\n+                                        .endClientSecret()\n+                                        .withDisableTlsHostnameVerification(true)\n+                                        .withTlsTrustedCertificates(cert1, cert2)\n+                                        .build())\n+                    .endPlain()\n+                .endListeners()\n+                .withAuthorization(\n+                        new KafkaAuthorizationKeycloakBuilder()\n+                                .withClientId(\"my-client-id\")\n+                                .withTokenEndpointUri(\"http://token-endpoint-uri\")\n+                                .withDisableTlsHostnameVerification(true)\n+                                .withDelegateToKafkaAcls(false)\n+                                .withTlsTrustedCertificates(cert1, cert2)\n+                                .build())\n+                .endKafka()\n+                .endSpec()\n+                .build();\n+\n+        KafkaCluster kc = KafkaCluster.fromCrd(kafkaAssembly, VERSIONS);\n+        StatefulSet sts = kc.generateStatefulSet(true, null, null);\n+        Container cont = sts.getSpec().getTemplate().getSpec().getContainers().get(0);\n+\n+        // Volume mounts\n+        assertThat(cont.getVolumeMounts().stream().filter(mount -> \"authz-keycloak-0\".equals(mount.getName())).findFirst().orElse(null).getMountPath(), is(KafkaCluster.OAUTH_TRUSTED_CERTS_BASE_VOLUME_MOUNT + \"/authz-keycloak-certs/first-certificate-0\"));\n+        assertThat(cont.getVolumeMounts().stream().filter(mount -> \"authz-keycloak-1\".equals(mount.getName())).findFirst().orElse(null).getMountPath(), is(KafkaCluster.OAUTH_TRUSTED_CERTS_BASE_VOLUME_MOUNT + \"/authz-keycloak-certs/second-certificate-1\"));\n+\n+        // Volumes\n+        assertThat(sts.getSpec().getTemplate().getSpec().getVolumes().stream().filter(vol -> \"authz-keycloak-0\".equals(vol.getName())).findFirst().orElse(null).getSecret().getItems().size(), is(1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af2861e52c6a40d3e9d11574ee26ac0cbecbe99e"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNjI2OTE4OnYy", "diffSide": "RIGHT", "path": "docker-images/kafka/kafka-thirdparty-libs/2.3.x/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNDo1Mjo1M1rOFjtyMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNDo1Mjo1M1rOFjtyMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk5NDYwOQ==", "bodyText": "Should we change the name of the property? It is not just cllback anymore, so maybe strimzi-oauth.version would be better", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r372994609", "createdAt": "2020-01-30T14:52:53Z", "author": {"login": "scholzj"}, "path": "docker-images/kafka/kafka-thirdparty-libs/2.3.x/pom.xml", "diffHunk": "@@ -107,5 +107,35 @@\n                 </exclusion>\n             </exclusions>\n         </dependency>\n+        <dependency>\n+            <groupId>io.strimzi</groupId>\n+            <artifactId>kafka-oauth-keycloak-authorizer</artifactId>\n+            <version>${strimzi-oauth-callback.version}</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4beced0eb9660cf420bfbc8b83b1311b1881f7"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNjI3MTY0OnYy", "diffSide": "RIGHT", "path": "docker-images/kafka/kafka-thirdparty-libs/2.3.x/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNDo1MzoyNFrOFjtzsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNDo1MzoyNFrOFjtzsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk5NDk5NQ==", "bodyText": "We are now released, so we can remov this again.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2432#discussion_r372994995", "createdAt": "2020-01-30T14:53:24Z", "author": {"login": "scholzj"}, "path": "docker-images/kafka/kafka-thirdparty-libs/2.3.x/pom.xml", "diffHunk": "@@ -107,5 +107,35 @@\n                 </exclusion>\n             </exclusions>\n         </dependency>\n+        <dependency>\n+            <groupId>io.strimzi</groupId>\n+            <artifactId>kafka-oauth-keycloak-authorizer</artifactId>\n+            <version>${strimzi-oauth-callback.version}</version>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>org.apache.kafka</groupId>\n+                    <artifactId>kafka-clients</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>com.fasterxml.jackson.core</groupId>\n+                    <artifactId>jackson-databind</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>com.github.spotbugs</groupId>\n+                    <artifactId>spotbugs-annotations</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>com.fasterxml.jackson.core</groupId>\n+                    <artifactId>jackson-core</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n     </dependencies>\n+\n+    <repositories>\n+        <repository>\n+            <id>staging</id>\n+            <url>https://oss.sonatype.org/content/repositories/iostrimzi-1054/</url>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4beced0eb9660cf420bfbc8b83b1311b1881f7"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 640, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}