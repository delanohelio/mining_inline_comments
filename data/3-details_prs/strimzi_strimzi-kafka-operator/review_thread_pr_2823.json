{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyMjUwMzQ0", "number": 2823, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQwOTo1NDoyNFrODxCQlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxMDowMDo0MVrODxCSqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNzQzODMwOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/StorageDiff.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQwOTo1NDoyNFrOGET-rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxMDoxNjowOVrOGEUHzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE3NDgyOQ==", "bodyText": "any reason for not calling using nodeId directly in the for loop?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2823#discussion_r407174829", "createdAt": "2020-04-12T09:54:24Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/StorageDiff.java", "diffHunk": "@@ -136,4 +171,55 @@ public boolean changesType() {\n     public boolean shrinkSize() {\n         return shrinkSize;\n     }\n+\n+    /**\n+     * Validates the changes to the storage overrides and decides whether they are allowed or not. Allowed changes are\n+     * those to nodes which will be added, removed or which do nto exist yet.\n+     *\n+     * @param current           Current Storage configuration\n+     * @param desired           New storage configuration\n+     * @param currentReplicas   Current number of replicas\n+     * @param desiredReplicas   Desired number of replicas\n+     * @return                  True if only allowed override changes were done, false othewise\n+     */\n+    private boolean isOverrideChangeAllowed(Storage current, Storage desired,  int currentReplicas, int desiredReplicas)   {\n+        List<PersistentClaimStorageOverride> currentOverrides = ((PersistentClaimStorage) current).getOverrides();\n+        if (currentOverrides == null)   {\n+            currentOverrides = Collections.emptyList();\n+        }\n+\n+        List<PersistentClaimStorageOverride> desiredOverrides = ((PersistentClaimStorage) desired).getOverrides();\n+        if (desiredOverrides == null)   {\n+            desiredOverrides = Collections.emptyList();\n+        }\n+\n+        // We care only about the nodes which existed before this reconciliation and will still exist after it\n+        int existedAndWillExist = Math.min(currentReplicas, desiredReplicas);\n+\n+        for (int i = 0; i < existedAndWillExist; i++)    {\n+            int nodeId = i;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f34177bebe5647902808897c4acd1ff1ee308b5"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE3NjE4Ng==", "bodyText": "It is used in the lambdas when filtering the lists. So it needs to be effectively final. That is why I do not use i directly.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2823#discussion_r407176186", "createdAt": "2020-04-12T10:07:05Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/StorageDiff.java", "diffHunk": "@@ -136,4 +171,55 @@ public boolean changesType() {\n     public boolean shrinkSize() {\n         return shrinkSize;\n     }\n+\n+    /**\n+     * Validates the changes to the storage overrides and decides whether they are allowed or not. Allowed changes are\n+     * those to nodes which will be added, removed or which do nto exist yet.\n+     *\n+     * @param current           Current Storage configuration\n+     * @param desired           New storage configuration\n+     * @param currentReplicas   Current number of replicas\n+     * @param desiredReplicas   Desired number of replicas\n+     * @return                  True if only allowed override changes were done, false othewise\n+     */\n+    private boolean isOverrideChangeAllowed(Storage current, Storage desired,  int currentReplicas, int desiredReplicas)   {\n+        List<PersistentClaimStorageOverride> currentOverrides = ((PersistentClaimStorage) current).getOverrides();\n+        if (currentOverrides == null)   {\n+            currentOverrides = Collections.emptyList();\n+        }\n+\n+        List<PersistentClaimStorageOverride> desiredOverrides = ((PersistentClaimStorage) desired).getOverrides();\n+        if (desiredOverrides == null)   {\n+            desiredOverrides = Collections.emptyList();\n+        }\n+\n+        // We care only about the nodes which existed before this reconciliation and will still exist after it\n+        int existedAndWillExist = Math.min(currentReplicas, desiredReplicas);\n+\n+        for (int i = 0; i < existedAndWillExist; i++)    {\n+            int nodeId = i;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE3NDgyOQ=="}, "originalCommit": {"oid": "9f34177bebe5647902808897c4acd1ff1ee308b5"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE3NzE2Nw==", "bodyText": "Right.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2823#discussion_r407177167", "createdAt": "2020-04-12T10:16:09Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/StorageDiff.java", "diffHunk": "@@ -136,4 +171,55 @@ public boolean changesType() {\n     public boolean shrinkSize() {\n         return shrinkSize;\n     }\n+\n+    /**\n+     * Validates the changes to the storage overrides and decides whether they are allowed or not. Allowed changes are\n+     * those to nodes which will be added, removed or which do nto exist yet.\n+     *\n+     * @param current           Current Storage configuration\n+     * @param desired           New storage configuration\n+     * @param currentReplicas   Current number of replicas\n+     * @param desiredReplicas   Desired number of replicas\n+     * @return                  True if only allowed override changes were done, false othewise\n+     */\n+    private boolean isOverrideChangeAllowed(Storage current, Storage desired,  int currentReplicas, int desiredReplicas)   {\n+        List<PersistentClaimStorageOverride> currentOverrides = ((PersistentClaimStorage) current).getOverrides();\n+        if (currentOverrides == null)   {\n+            currentOverrides = Collections.emptyList();\n+        }\n+\n+        List<PersistentClaimStorageOverride> desiredOverrides = ((PersistentClaimStorage) desired).getOverrides();\n+        if (desiredOverrides == null)   {\n+            desiredOverrides = Collections.emptyList();\n+        }\n+\n+        // We care only about the nodes which existed before this reconciliation and will still exist after it\n+        int existedAndWillExist = Math.min(currentReplicas, desiredReplicas);\n+\n+        for (int i = 0; i < existedAndWillExist; i++)    {\n+            int nodeId = i;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE3NDgyOQ=="}, "originalCommit": {"oid": "9f34177bebe5647902808897c4acd1ff1ee308b5"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNzQ0MzYzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxMDowMDo0MVrOGEUBWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxMDoxODoxOVrOGEUIow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE3NTUxNA==", "bodyText": "Maybe not related to this PR but why the zkCurrentReplicas is declared as Integer and not just a simple int which makes a little bit different the way we pass the old replicas between ZooKeeper and Kafka in the next code? Can the getReplicas() return null on a StatefulSet? The same is used in the KafkaClusterDescription but setting an int so I would say no.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2823#discussion_r407175514", "createdAt": "2020-04-12T10:00:41Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1278,14 +1278,14 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n                     .compose(sts -> {\n                         Storage oldStorage = getOldStorage(sts);\n \n-                        this.zkCluster = ZookeeperCluster.fromCrd(kafkaAssembly, versions, oldStorage);\n-                        this.zkService = zkCluster.generateService();\n-                        this.zkHeadlessService = zkCluster.generateHeadlessService();\n-\n                         if (sts != null && sts.getSpec() != null)   {\n                             this.zkCurrentReplicas = sts.getSpec().getReplicas();\n                         }\n \n+                        this.zkCluster = ZookeeperCluster.fromCrd(kafkaAssembly, versions, oldStorage, zkCurrentReplicas != null ? zkCurrentReplicas : 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f34177bebe5647902808897c4acd1ff1ee308b5"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE3NjQ4Ng==", "bodyText": "zkCurrentReplicas is used by the Zookeeper scaling where null indicates bascially new cluster. Therefore it exists as Integer and is a class variable. Thsi is there for a long time, I really just reuse the variable instead of creating another local one just for the Storage diff.\nFor Kafka we do not use it anywhere for anything else. So I created a new local variable and since the storage diff has a different requirements it is sufficient this time to use int.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2823#discussion_r407176486", "createdAt": "2020-04-12T10:09:48Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1278,14 +1278,14 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n                     .compose(sts -> {\n                         Storage oldStorage = getOldStorage(sts);\n \n-                        this.zkCluster = ZookeeperCluster.fromCrd(kafkaAssembly, versions, oldStorage);\n-                        this.zkService = zkCluster.generateService();\n-                        this.zkHeadlessService = zkCluster.generateHeadlessService();\n-\n                         if (sts != null && sts.getSpec() != null)   {\n                             this.zkCurrentReplicas = sts.getSpec().getReplicas();\n                         }\n \n+                        this.zkCluster = ZookeeperCluster.fromCrd(kafkaAssembly, versions, oldStorage, zkCurrentReplicas != null ? zkCurrentReplicas : 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE3NTUxNA=="}, "originalCommit": {"oid": "9f34177bebe5647902808897c4acd1ff1ee308b5"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE3NzM3OQ==", "bodyText": "Ah ok, now I see zkCurrentReplicas stays null when there is no STS yet, so new cluster. Thanks.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2823#discussion_r407177379", "createdAt": "2020-04-12T10:18:19Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1278,14 +1278,14 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n                     .compose(sts -> {\n                         Storage oldStorage = getOldStorage(sts);\n \n-                        this.zkCluster = ZookeeperCluster.fromCrd(kafkaAssembly, versions, oldStorage);\n-                        this.zkService = zkCluster.generateService();\n-                        this.zkHeadlessService = zkCluster.generateHeadlessService();\n-\n                         if (sts != null && sts.getSpec() != null)   {\n                             this.zkCurrentReplicas = sts.getSpec().getReplicas();\n                         }\n \n+                        this.zkCluster = ZookeeperCluster.fromCrd(kafkaAssembly, versions, oldStorage, zkCurrentReplicas != null ? zkCurrentReplicas : 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE3NTUxNA=="}, "originalCommit": {"oid": "9f34177bebe5647902808897c4acd1ff1ee308b5"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 147, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}