{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3MzkxMTU3", "number": 2695, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxMDo0NlrODnkp4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxNDoyN1rODnkujA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODIxNjAyOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxMDo0NlrOF1pyEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxMDo0NlrOF1pyEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwMzQxMQ==", "bodyText": "Should this be really info level?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2695#discussion_r391803411", "createdAt": "2020-03-12T18:10:46Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -333,40 +338,95 @@ protected KafkaConnectApi getKafkaConnectApi() {\n         }\n     }\n \n-    protected Future<Map<String, Object>> createOrUpdateConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient, \n-            String connectorName, KafkaConnectorSpec connectorSpec) {\n-        return apiClient.createOrUpdatePutRequest(host, KafkaConnectCluster.REST_API_PORT, connectorName, asJson(connectorSpec))\n-            .compose(ignored -> apiClient.statusWithBackOff(new BackOff(200L, 2, 6), host, KafkaConnectCluster.REST_API_PORT,\n-                    connectorName))\n-            .compose(status -> {\n-                Object path = ((Map) status.getOrDefault(\"connector\", emptyMap())).get(\"state\");\n-                if (!(path instanceof String)) {\n-                    return Future.failedFuture(\"JSON response lacked $.connector.state\");\n+    /**\n+     * Try to get the current connector config. If the connector does not exist, or its config differs from the \n+     * {@code connectorSpec}'s, then call\n+     * {@link #createOrUpdateConnector(Reconciliation, String, KafkaConnectApi, String, KafkaConnectorSpec)}\n+     * otherwise, just return the connectors current state.\n+     * @param reconciliation The reconciliation.\n+     * @param host The REST API host.\n+     * @param apiClient The client instance.\n+     * @param connectorName The connector name.\n+     * @param connectorSpec The desired connector spec.\n+     * @return A Future whose result, when successfully completed, is a map of the current connector state.\n+     */\n+    protected Future<Map<String, Object>> maybeCreateOrUpdateConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient,\n+                                                                       String connectorName, KafkaConnectorSpec connectorSpec) {\n+        return apiClient.getConnectorConfig(new BackOff(200L, 2, 6), host, port, connectorName).compose(\n+            config -> {\n+                if (!needsReconfiguring(reconciliation, connectorName, connectorSpec, config)) {\n+                    log.info(\"{}: Connector {} exists and has desired config, {}=={}\", reconciliation, connectorName, connectorSpec.getConfig(), config);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38d85c3e4aed5646c0d6e0d53b445f47f28032fe"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODIxODg1OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxMTozNFrOF1pz1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxMTozNFrOF1pz1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwMzg2Mg==", "bodyText": "Same as above.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2695#discussion_r391803862", "createdAt": "2020-03-12T18:11:34Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -333,40 +338,95 @@ protected KafkaConnectApi getKafkaConnectApi() {\n         }\n     }\n \n-    protected Future<Map<String, Object>> createOrUpdateConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient, \n-            String connectorName, KafkaConnectorSpec connectorSpec) {\n-        return apiClient.createOrUpdatePutRequest(host, KafkaConnectCluster.REST_API_PORT, connectorName, asJson(connectorSpec))\n-            .compose(ignored -> apiClient.statusWithBackOff(new BackOff(200L, 2, 6), host, KafkaConnectCluster.REST_API_PORT,\n-                    connectorName))\n-            .compose(status -> {\n-                Object path = ((Map) status.getOrDefault(\"connector\", emptyMap())).get(\"state\");\n-                if (!(path instanceof String)) {\n-                    return Future.failedFuture(\"JSON response lacked $.connector.state\");\n+    /**\n+     * Try to get the current connector config. If the connector does not exist, or its config differs from the \n+     * {@code connectorSpec}'s, then call\n+     * {@link #createOrUpdateConnector(Reconciliation, String, KafkaConnectApi, String, KafkaConnectorSpec)}\n+     * otherwise, just return the connectors current state.\n+     * @param reconciliation The reconciliation.\n+     * @param host The REST API host.\n+     * @param apiClient The client instance.\n+     * @param connectorName The connector name.\n+     * @param connectorSpec The desired connector spec.\n+     * @return A Future whose result, when successfully completed, is a map of the current connector state.\n+     */\n+    protected Future<Map<String, Object>> maybeCreateOrUpdateConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient,\n+                                                                       String connectorName, KafkaConnectorSpec connectorSpec) {\n+        return apiClient.getConnectorConfig(new BackOff(200L, 2, 6), host, port, connectorName).compose(\n+            config -> {\n+                if (!needsReconfiguring(reconciliation, connectorName, connectorSpec, config)) {\n+                    log.info(\"{}: Connector {} exists and has desired config, {}=={}\", reconciliation, connectorName, connectorSpec.getConfig(), config);\n+                    return apiClient.status(host, port, connectorName)\n+                        .compose(status -> {\n+                            return pauseResume(reconciliation, host, apiClient, connectorName, connectorSpec, status);\n+                        });\n                 } else {\n-                    String state = (String) path;\n-                    boolean shouldPause = Boolean.TRUE.equals(connectorSpec.getPause());\n-                    if (\"RUNNING\".equals(state) && shouldPause) {\n-                        log.debug(\"{}: Pausing connector {}\", reconciliation, connectorName);\n-                        return apiClient.pause(host, KafkaConnectCluster.REST_API_PORT,\n-                                connectorName)\n-                                .compose(ignored ->\n-                                        apiClient.status(host, KafkaConnectCluster.REST_API_PORT,\n-                                                connectorName));\n-                    } else if (\"PAUSED\".equals(state) && !shouldPause) {\n-                        log.debug(\"{}: Resuming connector {}\", reconciliation, connectorName);\n-                        return apiClient.resume(host, KafkaConnectCluster.REST_API_PORT,\n-                                connectorName)\n-                                .compose(ignored ->\n-                                        apiClient.status(host, KafkaConnectCluster.REST_API_PORT,\n-                                                connectorName));\n-\n-                    } else {\n-                        return Future.succeededFuture(status);\n-                    }\n+                    log.info(\"{}: Connector {} exists but does not have desired config, {}!={}\", reconciliation, connectorName, connectorSpec.getConfig(), config);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38d85c3e4aed5646c0d6e0d53b445f47f28032fe"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODIyMzA4OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxMzowMFrOF1p2rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxMzowMFrOF1p2rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNDU4OA==", "bodyText": "Given the isDebugEnabled I guess this should definitely be debug?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2695#discussion_r391804588", "createdAt": "2020-03-12T18:13:00Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -333,40 +338,95 @@ protected KafkaConnectApi getKafkaConnectApi() {\n         }\n     }\n \n-    protected Future<Map<String, Object>> createOrUpdateConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient, \n-            String connectorName, KafkaConnectorSpec connectorSpec) {\n-        return apiClient.createOrUpdatePutRequest(host, KafkaConnectCluster.REST_API_PORT, connectorName, asJson(connectorSpec))\n-            .compose(ignored -> apiClient.statusWithBackOff(new BackOff(200L, 2, 6), host, KafkaConnectCluster.REST_API_PORT,\n-                    connectorName))\n-            .compose(status -> {\n-                Object path = ((Map) status.getOrDefault(\"connector\", emptyMap())).get(\"state\");\n-                if (!(path instanceof String)) {\n-                    return Future.failedFuture(\"JSON response lacked $.connector.state\");\n+    /**\n+     * Try to get the current connector config. If the connector does not exist, or its config differs from the \n+     * {@code connectorSpec}'s, then call\n+     * {@link #createOrUpdateConnector(Reconciliation, String, KafkaConnectApi, String, KafkaConnectorSpec)}\n+     * otherwise, just return the connectors current state.\n+     * @param reconciliation The reconciliation.\n+     * @param host The REST API host.\n+     * @param apiClient The client instance.\n+     * @param connectorName The connector name.\n+     * @param connectorSpec The desired connector spec.\n+     * @return A Future whose result, when successfully completed, is a map of the current connector state.\n+     */\n+    protected Future<Map<String, Object>> maybeCreateOrUpdateConnector(Reconciliation reconciliation, String host, KafkaConnectApi apiClient,\n+                                                                       String connectorName, KafkaConnectorSpec connectorSpec) {\n+        return apiClient.getConnectorConfig(new BackOff(200L, 2, 6), host, port, connectorName).compose(\n+            config -> {\n+                if (!needsReconfiguring(reconciliation, connectorName, connectorSpec, config)) {\n+                    log.info(\"{}: Connector {} exists and has desired config, {}=={}\", reconciliation, connectorName, connectorSpec.getConfig(), config);\n+                    return apiClient.status(host, port, connectorName)\n+                        .compose(status -> {\n+                            return pauseResume(reconciliation, host, apiClient, connectorName, connectorSpec, status);\n+                        });\n                 } else {\n-                    String state = (String) path;\n-                    boolean shouldPause = Boolean.TRUE.equals(connectorSpec.getPause());\n-                    if (\"RUNNING\".equals(state) && shouldPause) {\n-                        log.debug(\"{}: Pausing connector {}\", reconciliation, connectorName);\n-                        return apiClient.pause(host, KafkaConnectCluster.REST_API_PORT,\n-                                connectorName)\n-                                .compose(ignored ->\n-                                        apiClient.status(host, KafkaConnectCluster.REST_API_PORT,\n-                                                connectorName));\n-                    } else if (\"PAUSED\".equals(state) && !shouldPause) {\n-                        log.debug(\"{}: Resuming connector {}\", reconciliation, connectorName);\n-                        return apiClient.resume(host, KafkaConnectCluster.REST_API_PORT,\n-                                connectorName)\n-                                .compose(ignored ->\n-                                        apiClient.status(host, KafkaConnectCluster.REST_API_PORT,\n-                                                connectorName));\n-\n-                    } else {\n-                        return Future.succeededFuture(status);\n-                    }\n+                    log.info(\"{}: Connector {} exists but does not have desired config, {}!={}\", reconciliation, connectorName, connectorSpec.getConfig(), config);\n+                    return createOrUpdateConnector(reconciliation, host, apiClient, connectorName, connectorSpec);\n+                }\n+            },\n+            error -> {\n+                if (error instanceof ConnectRestException\n+                        && ((ConnectRestException) error).getStatusCode() == 404) {\n+                    log.info(\"{}: Connector {} does not exist\", reconciliation, connectorName);\n+                    return createOrUpdateConnector(reconciliation, host, apiClient, connectorName, connectorSpec);\n+                } else {\n+                    return Future.failedFuture(error);\n                 }\n             });\n     }\n \n+    private boolean needsReconfiguring(Reconciliation reconciliation, String connectorName, KafkaConnectorSpec connectorSpec, Map<String, Object> actual) {\n+        // The actual which comes from Connect API includes tasks.max, connector.class and name,\n+        // which connectorSpec.getConfig() does not\n+        Map<String, Object> desired = log.isDebugEnabled() ? new TreeMap<>(connectorSpec.getConfig()) : new HashMap<>(connectorSpec.getConfig());\n+        desired.put(\"tasks.max\", connectorSpec.getTasksMax().toString());\n+        desired.put(\"name\", connectorName);\n+        desired.put(\"connector.class\", connectorSpec.getClassName());\n+        if (log.isDebugEnabled()) {\n+            log.info(\"{}: Desired: {}\", reconciliation, desired);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38d85c3e4aed5646c0d6e0d53b445f47f28032fe"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODIyNzA2OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectApi.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxNDowOVrOF1p5KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxNDowOVrOF1p5KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNTIyNA==", "bodyText": "debug ot trace level I guess?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2695#discussion_r391805224", "createdAt": "2020-03-12T18:14:09Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectApi.java", "diffHunk": "@@ -89,13 +188,16 @@ public KafkaConnectApiImpl(Vertx vertx) {\n                         response.bodyHandler(buffer -> {\n                             ObjectMapper mapper = new ObjectMapper();\n                             try {\n-                                result.complete(mapper.readValue(buffer.getBytes(), Map.class));\n+                                Map t = mapper.readValue(buffer.getBytes(), Map.class);\n+                                log.info(\"Got {} response to PUT request to {}: {}\", response.statusCode(), path, t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38d85c3e4aed5646c0d6e0d53b445f47f28032fe"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODIyNzk2OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectApi.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxNDoyN1rOF1p5tQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxNDoyN1rOF1p5tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNTM2NQ==", "bodyText": "Again ...", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2695#discussion_r391805365", "createdAt": "2020-03-12T18:14:27Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectApi.java", "diffHunk": "@@ -89,13 +188,16 @@ public KafkaConnectApiImpl(Vertx vertx) {\n                         response.bodyHandler(buffer -> {\n                             ObjectMapper mapper = new ObjectMapper();\n                             try {\n-                                result.complete(mapper.readValue(buffer.getBytes(), Map.class));\n+                                Map t = mapper.readValue(buffer.getBytes(), Map.class);\n+                                log.info(\"Got {} response to PUT request to {}: {}\", response.statusCode(), path, t);\n+                                result.complete(t);\n                             } catch (IOException e) {\n                                 result.fail(new ConnectRestException(response, \"Could not deserialize response: \" + e));\n                             }\n                         });\n                     } else {\n                         // TODO Handle 409 (Conflict) indicating a rebalance in progress\n+                        log.info(\"Got {} response to PUT request to {}\", response.statusCode(), path);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38d85c3e4aed5646c0d6e0d53b445f47f28032fe"}, "originalPosition": 149}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 303, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}