{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2MTEyMjg4", "number": 2992, "title": "Improve exponential backoff", "bodyText": "Signed-off-by: Stanislav Knot sknot@redhat.com\n\nEnhancement\n\nDescription\nIf connection admin client to broker fails, we try simple TCP connection to the broker. If it fails, we force roll the pod because it is in a fail state. Credit for design and code to @tombentley\nChecklist\n\n Update/write design documentation in ./design\n Write tests\n Make sure all tests pass\n Update documentation\n Check RBAC rights for Kubernetes / OpenShift roles\n Try your changes from Pod inside your Kubernetes and OpenShift cluster, not just locally\n Reference relevant issue(s) and close them after merging\n Update CHANGELOG.md", "createdAt": "2020-05-11T13:39:53Z", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2992", "merged": true, "mergeCommit": {"oid": "2da7ab86eadb1366375d0d147305efce7650c018"}, "closed": true, "closedAt": "2020-05-14T22:22:43Z", "author": {"login": "sknot-rh"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcgP0KygH2gAyNDE2MTEyMjg4OjFkZTdkZWQ3NzIwYWQ2ZTk3NDJlYzY3MWY1NDNmZDU5N2JiMDJhOWM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcg4d0pgFqTQxMDg5NjY0MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1de7ded7720ad6e9742ec671f543fd597bb02a9c", "author": {"user": {"login": "sknot-rh", "name": "Stanislav Knot"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/1de7ded7720ad6e9742ec671f543fd597bb02a9c", "committedDate": "2020-05-11T13:37:13Z", "message": "Improve exponential backoff\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NTY4MjA2", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2992#pullrequestreview-409568206", "createdAt": "2020-05-11T22:13:02Z", "commit": {"oid": "1de7ded7720ad6e9742ec671f543fd597bb02a9c"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMjoxMzowM1rOGTvPEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMjoxODoxN1rOGTvXLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1MDAzMg==", "bodyText": "The lala probably shouldn't be here ;-)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2992#discussion_r423350032", "createdAt": "2020-05-11T22:13:03Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaRoller.java", "diffHunk": "@@ -416,22 +448,64 @@ String podName(Integer podId) {\n      * @return A future which completes the the node id of the controller of the cluster,\n      * or -1 if there is not currently a controller.\n      */\n-    int controller(int podId, Admin ac, long timeout, TimeUnit unit) throws ForceableProblem, InterruptedException {\n+    int controller(int podId, Admin ac, long timeout, TimeUnit unit, RestartContext restartContext) throws ForceableProblem, InterruptedException {\n         Node controllerNode = null;\n         try {\n             DescribeClusterResult describeClusterResult = ac.describeCluster();\n             KafkaFuture<Node> controller = describeClusterResult.controller();\n             controllerNode = controller.get(timeout, unit);\n+            restartContext.clearConnectionError();\n         } catch (ExecutionException e) {\n-            throw new ForceableProblem(\"Error while trying to determine the cluster controller from pod \" + podName(podId), e.getCause());\n+            maybeTcpProbe(podId, e, restartContext);\n         } catch (TimeoutException e) {\n-            throw new ForceableProblem(\"Error while trying to determine the cluster controller from pod \" + podName(podId), e);\n+            throw new ForceableProblem(\"lala Error while trying to determine the cluster controller from pod \" + podName(podId), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1de7ded7720ad6e9742ec671f543fd597bb02a9c"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1MDQyOA==", "bodyText": "These debuug messages are probably also not supposed to be here ;-)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2992#discussion_r423350428", "createdAt": "2020-05-11T22:14:05Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaRoller.java", "diffHunk": "@@ -416,22 +448,64 @@ String podName(Integer podId) {\n      * @return A future which completes the the node id of the controller of the cluster,\n      * or -1 if there is not currently a controller.\n      */\n-    int controller(int podId, Admin ac, long timeout, TimeUnit unit) throws ForceableProblem, InterruptedException {\n+    int controller(int podId, Admin ac, long timeout, TimeUnit unit, RestartContext restartContext) throws ForceableProblem, InterruptedException {\n         Node controllerNode = null;\n         try {\n             DescribeClusterResult describeClusterResult = ac.describeCluster();\n             KafkaFuture<Node> controller = describeClusterResult.controller();\n             controllerNode = controller.get(timeout, unit);\n+            restartContext.clearConnectionError();\n         } catch (ExecutionException e) {\n-            throw new ForceableProblem(\"Error while trying to determine the cluster controller from pod \" + podName(podId), e.getCause());\n+            maybeTcpProbe(podId, e, restartContext);\n         } catch (TimeoutException e) {\n-            throw new ForceableProblem(\"Error while trying to determine the cluster controller from pod \" + podName(podId), e);\n+            throw new ForceableProblem(\"lala Error while trying to determine the cluster controller from pod \" + podName(podId), e);\n         }\n         int id = controllerNode == null || Node.noNode().equals(controllerNode) ? -1 : controllerNode.id();\n         log.debug(\"controller is {}\", id);\n         return id;\n     }\n \n+    /**\n+     * If we've already had trouble connecting to this broker try to probe whether the connection is\n+     * open on the broker; if it's not then maybe throw a ForceableProblem to immediately force a restart.\n+     * This is an optimization for brokers which don't seem to be running.\n+     */\n+    private void maybeTcpProbe(int podId, ExecutionException executionException, RestartContext restartContext) throws ForceableProblem {\n+        log.info(\"debuug1 {} {}\", restartContext.connectionError(), System.currentTimeMillis());\n+        if (restartContext.connectionError() + 120_000 >= System.currentTimeMillis()) {\n+            log.info(\"debuug2\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1de7ded7720ad6e9742ec671f543fd597bb02a9c"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1MTEwMQ==", "bodyText": "Do we need to pass both ctx.backOff.done() and ctx? Cant we pass just ctx and get ctx.backOff.done() from it later? Or does this have some meaning - e.g. in testing?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2992#discussion_r423351101", "createdAt": "2020-05-11T22:15:40Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaRoller.java", "diffHunk": "@@ -193,7 +212,7 @@ public String toString() {\n         singleExecutor.schedule(() -> {\n             log.debug(\"Considering restart of pod {} after delay of {} {}\", podId, delay, unit);\n             try {\n-                restartIfNecessary(podId, ctx.backOff.done());\n+                restartIfNecessary(podId, ctx.backOff.done(), ctx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1de7ded7720ad6e9742ec671f543fd597bb02a9c"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1MTg5MQ==", "bodyText": "Why do we use this here and not for Timeout exception?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2992#discussion_r423351891", "createdAt": "2020-05-11T22:17:45Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaRoller.java", "diffHunk": "@@ -416,22 +448,64 @@ String podName(Integer podId) {\n      * @return A future which completes the the node id of the controller of the cluster,\n      * or -1 if there is not currently a controller.\n      */\n-    int controller(int podId, Admin ac, long timeout, TimeUnit unit) throws ForceableProblem, InterruptedException {\n+    int controller(int podId, Admin ac, long timeout, TimeUnit unit, RestartContext restartContext) throws ForceableProblem, InterruptedException {\n         Node controllerNode = null;\n         try {\n             DescribeClusterResult describeClusterResult = ac.describeCluster();\n             KafkaFuture<Node> controller = describeClusterResult.controller();\n             controllerNode = controller.get(timeout, unit);\n+            restartContext.clearConnectionError();\n         } catch (ExecutionException e) {\n-            throw new ForceableProblem(\"Error while trying to determine the cluster controller from pod \" + podName(podId), e.getCause());\n+            maybeTcpProbe(podId, e, restartContext);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1de7ded7720ad6e9742ec671f543fd597bb02a9c"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1MjEwOQ==", "bodyText": "Why 120_000 an not operationTimeoutMs?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2992#discussion_r423352109", "createdAt": "2020-05-11T22:18:17Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaRoller.java", "diffHunk": "@@ -416,22 +448,64 @@ String podName(Integer podId) {\n      * @return A future which completes the the node id of the controller of the cluster,\n      * or -1 if there is not currently a controller.\n      */\n-    int controller(int podId, Admin ac, long timeout, TimeUnit unit) throws ForceableProblem, InterruptedException {\n+    int controller(int podId, Admin ac, long timeout, TimeUnit unit, RestartContext restartContext) throws ForceableProblem, InterruptedException {\n         Node controllerNode = null;\n         try {\n             DescribeClusterResult describeClusterResult = ac.describeCluster();\n             KafkaFuture<Node> controller = describeClusterResult.controller();\n             controllerNode = controller.get(timeout, unit);\n+            restartContext.clearConnectionError();\n         } catch (ExecutionException e) {\n-            throw new ForceableProblem(\"Error while trying to determine the cluster controller from pod \" + podName(podId), e.getCause());\n+            maybeTcpProbe(podId, e, restartContext);\n         } catch (TimeoutException e) {\n-            throw new ForceableProblem(\"Error while trying to determine the cluster controller from pod \" + podName(podId), e);\n+            throw new ForceableProblem(\"lala Error while trying to determine the cluster controller from pod \" + podName(podId), e);\n         }\n         int id = controllerNode == null || Node.noNode().equals(controllerNode) ? -1 : controllerNode.id();\n         log.debug(\"controller is {}\", id);\n         return id;\n     }\n \n+    /**\n+     * If we've already had trouble connecting to this broker try to probe whether the connection is\n+     * open on the broker; if it's not then maybe throw a ForceableProblem to immediately force a restart.\n+     * This is an optimization for brokers which don't seem to be running.\n+     */\n+    private void maybeTcpProbe(int podId, ExecutionException executionException, RestartContext restartContext) throws ForceableProblem {\n+        log.info(\"debuug1 {} {}\", restartContext.connectionError(), System.currentTimeMillis());\n+        if (restartContext.connectionError() + 120_000 >= System.currentTimeMillis()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1de7ded7720ad6e9742ec671f543fd597bb02a9c"}, "originalPosition": 142}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba8c17d3d7bd13beb24c72d731597239262cd4a9", "author": {"user": {"login": "sknot-rh", "name": "Stanislav Knot"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/ba8c17d3d7bd13beb24c72d731597239262cd4a9", "committedDate": "2020-05-12T07:16:32Z", "message": "comments\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNzQ0MDEz", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2992#pullrequestreview-410744013", "createdAt": "2020-05-13T09:22:40Z", "commit": {"oid": "ba8c17d3d7bd13beb24c72d731597239262cd4a9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b105873667aad8a3e40afea6d3416a623e1f912", "author": {"user": {"login": "sknot-rh", "name": "Stanislav Knot"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/1b105873667aad8a3e40afea6d3416a623e1f912", "committedDate": "2020-05-13T10:41:30Z", "message": "fix build\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwODAzMjg5", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2992#pullrequestreview-410803289", "createdAt": "2020-05-13T10:44:17Z", "commit": {"oid": "1b105873667aad8a3e40afea6d3416a623e1f912"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMDo0NDoxN1rOGUr3Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMDo1MDo1MVrOGUsDhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM0MzMxMQ==", "bodyText": "Can we rename immediateForce to forceNow to match the field?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2992#discussion_r424343311", "createdAt": "2020-05-13T10:44:17Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaRoller.java", "diffHunk": "@@ -295,13 +315,24 @@ private void closeLoggingAnyError(Admin adminClient) {\n         }\n     }\n \n-    /** Exceptions which we're prepared to ignore in the final attempt */\n+    /** Exceptions which we're prepared to ignore (thus forcing a restart) in some circumstances. */\n     static final class ForceableProblem extends Exception {\n+        final boolean forceNow;\n         ForceableProblem(String msg) {\n             this(msg, null);\n         }\n+\n         ForceableProblem(String msg, Throwable cause) {\n+            this(msg, cause, false);\n+        }\n+\n+        ForceableProblem(String msg, boolean forceNow) {\n+            this(msg, null, forceNow);\n+        }\n+\n+        ForceableProblem(String msg, Throwable cause, boolean immediateForce) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b105873667aad8a3e40afea6d3416a623e1f912"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM0NjUwMg==", "bodyText": "If this tcpProbe() call does not throw an IOException then this method returns normally and we lose the fact that executionException was thrown and the caller will say the controller is -1. Is that correct, or should we rethrow executionException if no IOException was thrown?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2992#discussion_r424346502", "createdAt": "2020-05-13T10:50:51Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaRoller.java", "diffHunk": "@@ -416,22 +447,55 @@ String podName(Integer podId) {\n      * @return A future which completes the the node id of the controller of the cluster,\n      * or -1 if there is not currently a controller.\n      */\n-    int controller(int podId, Admin ac, long timeout, TimeUnit unit) throws ForceableProblem, InterruptedException {\n+    int controller(int podId, Admin ac, long timeout, TimeUnit unit, RestartContext restartContext) throws ForceableProblem, InterruptedException {\n         Node controllerNode = null;\n         try {\n             DescribeClusterResult describeClusterResult = ac.describeCluster();\n             KafkaFuture<Node> controller = describeClusterResult.controller();\n             controllerNode = controller.get(timeout, unit);\n-        } catch (ExecutionException e) {\n-            throw new ForceableProblem(\"Error while trying to determine the cluster controller from pod \" + podName(podId), e.getCause());\n-        } catch (TimeoutException e) {\n-            throw new ForceableProblem(\"Error while trying to determine the cluster controller from pod \" + podName(podId), e);\n+            restartContext.clearConnectionError();\n+        } catch (ExecutionException | TimeoutException e) {\n+            maybeTcpProbe(podId, e, restartContext);\n         }\n         int id = controllerNode == null || Node.noNode().equals(controllerNode) ? -1 : controllerNode.id();\n         log.debug(\"controller is {}\", id);\n         return id;\n     }\n \n+    /**\n+     * If we've already had trouble connecting to this broker try to probe whether the connection is\n+     * open on the broker; if it's not then maybe throw a ForceableProblem to immediately force a restart.\n+     * This is an optimization for brokers which don't seem to be running.\n+     */\n+    private void maybeTcpProbe(int podId, Exception executionException, RestartContext restartContext) throws ForceableProblem {\n+        if (restartContext.connectionError() + numPods * 120_000L >= System.currentTimeMillis()) {\n+            try {\n+                log.debug(\"Probing TCP port due to previous problems connecting to pod {}\", podId);\n+                // do a tcp connect and close (with a short connect timeout)\n+                tcpProbe(podName(podId), KafkaCluster.REPLICATION_PORT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b105873667aad8a3e40afea6d3416a623e1f912"}, "originalPosition": 146}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "142745ab4aac6ebaa5505846291b3f461fd85158", "author": {"user": {"login": "sknot-rh", "name": "Stanislav Knot"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/142745ab4aac6ebaa5505846291b3f461fd85158", "committedDate": "2020-05-13T11:14:09Z", "message": "comments\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwODk2NjQx", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2992#pullrequestreview-410896641", "createdAt": "2020-05-13T12:58:55Z", "commit": {"oid": "142745ab4aac6ebaa5505846291b3f461fd85158"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1681, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}