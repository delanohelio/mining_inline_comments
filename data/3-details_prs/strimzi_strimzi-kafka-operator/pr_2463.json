{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3NjkyMDMy", "number": 2463, "title": "Deal with conflict between Connect and Connect S2I", "bodyText": "Type of change\n\nBugfix\n\nDescription\nWhen both Kafka Connect and Kafka Connect S2I exist in the same namespace with the same name they conflict with each other. They share (and overwrite) each others services, config maps etc. This PR adds checks and only the older one from the two will be reconciled. The older or newer one is decided based on the Creation timestamp in metadata.\nThis PR doesn't really deal with situation where such two Connect and Connect S2I instances already exist - it will error the status and stop reconciling one of them, but not delete the pods etc. But given how disfunctional they would be I guess nobody is using this. When the user deletes one of the CRs thi should be resolved through the garbage collection.\nChecklist\n\n Write tests\n Make sure all tests pass\n Try your changes from Pod inside your Kubernetes and OpenShift cluster, not just locally", "createdAt": "2020-01-27T20:37:58Z", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2463", "merged": true, "mergeCommit": {"oid": "f9f9fe3a706b45d5aeaac8d42643bcdef6898869"}, "closed": true, "closedAt": "2020-01-28T15:28:57Z", "author": {"login": "scholzj"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb-jXZaAH2gAyMzY3NjkyMDMyOjY3NGI4NmRlZjcwYzlmODQ4MGU4M2ZjNjY3YTNmZjJjZjk2MjZjNmY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb-xPoFgFqTM0OTM2NjEzNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "674b86def70c9f8480e83fc667a3ff2cf9626c6f", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/674b86def70c9f8480e83fc667a3ff2cf9626c6f", "committedDate": "2020-01-27T21:10:28Z", "message": "Deal with conflict between Connect and Connect S2I\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba8ad7388a9467a882e24bc63bd680156503dc71", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/ba8ad7388a9467a882e24bc63bd680156503dc71", "committedDate": "2020-01-27T21:10:28Z", "message": "Fix unused import\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eece63785e65bd29eec403c3d76080130e5e0687", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/eece63785e65bd29eec403c3d76080130e5e0687", "committedDate": "2020-01-27T21:43:13Z", "message": "Fix errors caused by PRs merged in the meantime\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9911eea627465ed6260fe7048e4b58b6e5cee1b2", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/9911eea627465ed6260fe7048e4b58b6e5cee1b2", "committedDate": "2020-01-27T20:31:49Z", "message": "Fix unused import\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}, "afterCommit": {"oid": "eece63785e65bd29eec403c3d76080130e5e0687", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/eece63785e65bd29eec403c3d76080130e5e0687", "committedDate": "2020-01-27T21:43:13Z", "message": "Fix errors caused by PRs merged in the meantime\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MjI1MDc1", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2463#pullrequestreview-349225075", "createdAt": "2020-01-28T09:21:57Z", "commit": {"oid": "eece63785e65bd29eec403c3d76080130e5e0687"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwOToyMTo1N1rOFid5SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwOToyMjo1MlrOFid7FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY4NTcwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            \"KafkaConnectS2I seems to exists longer and will be used while this custom resource will be ignored.\");\n          \n          \n            \n                                            \"KafkaConnectS2I is older and will be used while this custom resource will be ignored.\");", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2463#discussion_r371685704", "createdAt": "2020-01-28T09:21:57Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -100,7 +107,26 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n         annotations.put(ANNO_STRIMZI_IO_LOGGING, logAndMetricsConfigMap.getData().get(connect.ANCILLARY_CM_KEY_LOG_CONFIG));\n \n         log.debug(\"{}: Updating Kafka Connect cluster\", reconciliation, name, namespace);\n-        connectServiceAccount(namespace, connect)\n+\n+        Future<KafkaConnectS2I> connectS2ICheck;\n+        if (connectS2IOperations != null)   {\n+            connectS2ICheck = connectS2IOperations.getAsync(kafkaConnect.getMetadata().getNamespace(), kafkaConnect.getMetadata().getName());\n+        } else {\n+            connectS2ICheck = Future.succeededFuture(null);\n+        }\n+\n+        connectS2ICheck\n+                .compose(otherConnect -> {\n+                    if (otherConnect != null\n+                            // There is a KafkaConnectS2I with the same name which is older than this KafkaConnect\n+                            && kafkaConnect.getMetadata().getCreationTimestamp().compareTo(otherConnect.getMetadata().getCreationTimestamp()) > 0)    {\n+                        return Future.failedFuture(\"Both KafkaConnect and KafkaConnectS2I exist with the same name. \" +\n+                                \"KafkaConnectS2I seems to exists longer and will be used while this custom resource will be ignored.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eece63785e65bd29eec403c3d76080130e5e0687"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY4NjE2NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            \"KafkaConnect seems to exists longer and will be used while this custom resource will be ignored.\");\n          \n          \n            \n                                            \"KafkaConnect is older and will be used while this custom resource will be ignored.\");", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2463#discussion_r371686164", "createdAt": "2020-01-28T09:22:52Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectS2IAssemblyOperator.java", "diffHunk": "@@ -91,75 +92,84 @@ public KafkaConnectS2IAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability\n \n     @Override\n     public Future<Void> createOrUpdate(Reconciliation reconciliation, KafkaConnectS2I kafkaConnectS2I) {\n+        Promise<Void> createOrUpdatePromise = Promise.promise();\n+        String name = reconciliation.name();\n         String namespace = reconciliation.namespace();\n-        if (kafkaConnectS2I.getSpec() == null) {\n-            log.error(\"{} spec cannot be null\", kafkaConnectS2I.getMetadata().getName());\n-            return Future.failedFuture(\"Spec cannot be null\");\n-        }\n-        if (pfa.hasImages() && pfa.hasApps() && pfa.hasBuilds()) {\n-            Promise<Void> createOrUpdatePromise = Promise.promise();\n-            KafkaConnectS2ICluster connect;\n-            KafkaConnectS2Istatus kafkaConnectS2Istatus = new KafkaConnectS2Istatus();\n-            try {\n-                connect = KafkaConnectS2ICluster.fromCrd(kafkaConnectS2I, versions);\n-            } catch (Exception e) {\n-                StatusUtils.setStatusConditionAndObservedGeneration(kafkaConnectS2I, kafkaConnectS2Istatus, Future.failedFuture(e));\n-                return updateStatus(kafkaConnectS2I, reconciliation, kafkaConnectS2Istatus);\n+        KafkaConnectS2ICluster connect;\n+        KafkaConnectS2IStatus kafkaConnectS2Istatus = new KafkaConnectS2IStatus();\n+\n+        try {\n+            if (kafkaConnectS2I.getSpec() == null) {\n+                log.error(\"{}: Resource lacks spec property\", reconciliation, kafkaConnectS2I.getMetadata().getName());\n+                throw new InvalidResourceException(\"spec property is required\");\n             }\n-            connect.generateBuildConfig();\n-            ConfigMap logAndMetricsConfigMap = connect.generateMetricsAndLogConfigMap(connect.getLogging() instanceof ExternalLogging ?\n-                    configMapOperations.get(namespace, ((ExternalLogging) connect.getLogging()).getName()) :\n-                    null);\n-\n-            HashMap<String, String> annotations = new HashMap<>();\n-            annotations.put(ANNO_STRIMZI_IO_LOGGING, logAndMetricsConfigMap.getData().get(connect.ANCILLARY_CM_KEY_LOG_CONFIG));\n-            connectServiceAccount(namespace, connect)\n-                    .compose(i -> deploymentConfigOperations.scaleDown(namespace, connect.getName(), connect.getReplicas()))\n-                    .compose(scale -> serviceOperations.reconcile(namespace, connect.getServiceName(), connect.generateService()))\n-                    .compose(i -> configMapOperations.reconcile(namespace, connect.getAncillaryConfigName(), logAndMetricsConfigMap))\n-                    .compose(i -> deploymentConfigOperations.reconcile(namespace, connect.getName(), connect.generateDeploymentConfig(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n-                    .compose(i -> imagesStreamOperations.reconcile(namespace, KafkaConnectS2IResources.sourceImageStreamName(connect.getCluster()), connect.generateSourceImageStream()))\n-                    .compose(i -> imagesStreamOperations.reconcile(namespace, KafkaConnectS2IResources.targetImageStreamName(connect.getCluster()), connect.generateTargetImageStream()))\n-                    .compose(i -> podDisruptionBudgetOperator.reconcile(namespace, connect.getName(), connect.generatePodDisruptionBudget()))\n-                    .compose(i -> buildConfigOperations.reconcile(namespace, KafkaConnectS2IResources.buildConfigName(connect.getCluster()), connect.generateBuildConfig()))\n-                    .compose(i -> deploymentConfigOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n-                    .compose(i -> deploymentConfigOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                    .compose(i -> deploymentConfigOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                    .compose(i -> reconcileConnectors(reconciliation, kafkaConnectS2I, kafkaConnectS2Istatus))\n-                    .setHandler(reconciliationResult -> {\n-                        StatusUtils.setStatusConditionAndObservedGeneration(kafkaConnectS2I, kafkaConnectS2Istatus, reconciliationResult);\n-                        kafkaConnectS2Istatus.setUrl(KafkaConnectS2IResources.url(connect.getCluster(), namespace, KafkaConnectS2ICluster.REST_API_PORT));\n-                        kafkaConnectS2Istatus.setBuildConfigName(KafkaConnectS2IResources.buildConfigName(connect.getCluster()));\n-\n-                        updateStatus(kafkaConnectS2I, reconciliation, kafkaConnectS2Istatus).setHandler(statusResult -> {\n-                            // If both features succeeded, createOrUpdate succeeded as well\n-                            // If one or both of them failed, we prefer the reconciliation failure as the main error\n-                            if (reconciliationResult.succeeded() && statusResult.succeeded()) {\n-                                createOrUpdatePromise.complete();\n-                            } else if (reconciliationResult.failed()) {\n-                                createOrUpdatePromise.fail(reconciliationResult.cause());\n-                            } else {\n-                                createOrUpdatePromise.fail(statusResult.cause());\n-                            }\n-                        });\n-                    });\n-            return createOrUpdatePromise.future();\n \n-        } else {\n-            return Future.failedFuture(\"The OpenShift build, image or apps APIs are not available in this Kubernetes cluster. Kafka Connect S2I deployment cannot be enabled.\");\n+            connect = KafkaConnectS2ICluster.fromCrd(kafkaConnectS2I, versions);\n+        } catch (Exception e) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(kafkaConnectS2I, kafkaConnectS2Istatus, Future.failedFuture(e));\n+            return updateStatus(kafkaConnectS2I, reconciliation, kafkaConnectS2Istatus);\n         }\n-    }\n \n-    @Override\n-    protected Future<Void> reconcileConnectors(Reconciliation reconciliation, KafkaConnectS2I connects2i, KafkaConnectS2Istatus connects2istatus) {\n-        return connectOperations.getAsync(connects2i.getMetadata().getNamespace(), connects2i.getMetadata().getName()).compose(connect -> {\n-            // If there's a non-s2i of the same name then do nothing, since that takes precedence\n-            if (connect != null) {\n-                return Future.succeededFuture();\n-            } else {\n-                return super.reconcileConnectors(reconciliation, connects2i, connects2istatus);\n-            }\n-        });\n+        connect.generateBuildConfig();\n+        ConfigMap logAndMetricsConfigMap = connect.generateMetricsAndLogConfigMap(connect.getLogging() instanceof ExternalLogging ?\n+                configMapOperations.get(namespace, ((ExternalLogging) connect.getLogging()).getName()) :\n+                null);\n+\n+        HashMap<String, String> annotations = new HashMap<>();\n+        annotations.put(ANNO_STRIMZI_IO_LOGGING, logAndMetricsConfigMap.getData().get(connect.ANCILLARY_CM_KEY_LOG_CONFIG));\n+\n+        log.debug(\"{}: Updating Kafka Connect S2I cluster\", reconciliation, name, namespace);\n+\n+        connectOperations.getAsync(kafkaConnectS2I.getMetadata().getNamespace(), kafkaConnectS2I.getMetadata().getName())\n+                .compose(otherConnect -> {\n+                    if (otherConnect != null\n+                            // There is a KafkaConnect with the same name which is older than  or equally old as this KafkaConnectS2I\n+                            && kafkaConnectS2I.getMetadata().getCreationTimestamp().compareTo(otherConnect.getMetadata().getCreationTimestamp()) >= 0)    {\n+                        return Future.failedFuture(\"Both KafkaConnect and KafkaConnectS2I exist with the same name. \" +\n+                                \"KafkaConnect seems to exists longer and will be used while this custom resource will be ignored.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eece63785e65bd29eec403c3d76080130e5e0687"}, "originalPosition": 123}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff285f513968f36b8b9c104643d0a36f372e1fb4", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/ff285f513968f36b8b9c104643d0a36f372e1fb4", "committedDate": "2020-01-28T13:03:06Z", "message": "Make handling cleaner in the connector watch\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MzY2MTM0", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2463#pullrequestreview-349366134", "createdAt": "2020-01-28T13:20:39Z", "commit": {"oid": "ff285f513968f36b8b9c104643d0a36f372e1fb4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1873, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}