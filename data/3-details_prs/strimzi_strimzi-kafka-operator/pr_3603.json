{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc5MTI3NTU4", "number": 3603, "title": "Change listeners configuration to list to allow for more listeners", "bodyText": "Type of change\n\nRefactoring\n\nDescription\nThis PR implements the Strimzi Proposal no 5 and brings the possibility to configure listeners as a list and allow to configure more listeners at the same time.\nCompared to the proposal, the internal listener type is now internal since service seemed a bit too confusing (all listeners use some services). Since all listeners now use the same API objects, there is now a new class for validation to check all kinds of different parameters and ensure only the compatible fields are used. But this also allows to use a lot of new configuration combinations which were not possible in the past because they were not implemented. That includes for example advertised host and port configuration for all listeners etc. I also merged the override and configuration sections which were confusing and had a big overlap in the past API. Additionally, I added option to use fully qualified service names in internal listeners as requested by some users (has to be enabled - #2656).\nThere is also a convertor which converts the old API to the new API for backwards compatibility. There are also several methods which take care of using the right names for the old listeners to not change listener names in Kafka or service names in Kube since that would change all addresses etc.\nPS: Sorry for the big PR ... I really was trying to find ways how to split it into smaller PRs. But I do not think it was really possible here.\nChecklist\n\n Write tests\n Make sure all tests pass\n Try your changes from Pod inside your Kubernetes and OpenShift cluster, not just locally\n Update CHANGELOG.md", "createdAt": "2020-09-04T00:20:35Z", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603", "merged": true, "mergeCommit": {"oid": "e786ce9a12117b506ef56c23fe6a314f6d9eb27b"}, "closed": true, "closedAt": "2020-09-08T06:57:24Z", "author": {"login": "scholzj"}, "timelineItems": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdFg0bWgFqTQ4MjQ1NTU5Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdGpa3bAFqTQ4MzcwNzgxNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNDU1NTky", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#pullrequestreview-482455592", "createdAt": "2020-09-04T08:21:04Z", "commit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoyMTowNFrOHNEXUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoyMTowNFrOHNEXUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2NTA0Mg==", "bodyText": "Aren't arrays Objects too?  I know this is petty, but the fact that the new KafkaListeners handles objects or arrays is surely an implementations details (and therefore should be doc commented or made clear through the flow of the code?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483465042", "createdAt": "2020-09-04T08:21:04Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNDU2MzE0", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#pullrequestreview-482456314", "createdAt": "2020-09-04T08:22:09Z", "commit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoyMjoxMFrOHNEZug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozNjoyOVrOHNE3sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2NTY1OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public List<GenericKafkaListener> getListValue() {\n          \n          \n            \n                public List<GenericKafkaListener> getGenericKafkaListeners() {", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483465658", "createdAt": "2020-09-04T08:22:10Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final List<GenericKafkaListener> listValue;\n+    private final KafkaListeners objectValue;\n+\n+    public ArrayOrObjectKafkaListeners(List<GenericKafkaListener> listValue)   {\n+        this.listValue = listValue;\n+        this.objectValue = null;\n+    }\n+\n+    public ArrayOrObjectKafkaListeners(KafkaListeners objectValue)   {\n+        this.listValue = null;\n+        this.objectValue = objectValue;\n+    }\n+\n+    @Alternative()\n+    public List<GenericKafkaListener> getListValue() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2NTc5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public KafkaListeners getObjectValue() {\n          \n          \n            \n                public KafkaListeners getKafkaListeners() {", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483465797", "createdAt": "2020-09-04T08:22:25Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final List<GenericKafkaListener> listValue;\n+    private final KafkaListeners objectValue;\n+\n+    public ArrayOrObjectKafkaListeners(List<GenericKafkaListener> listValue)   {\n+        this.listValue = listValue;\n+        this.objectValue = null;\n+    }\n+\n+    public ArrayOrObjectKafkaListeners(KafkaListeners objectValue)   {\n+        this.listValue = null;\n+        this.objectValue = objectValue;\n+    }\n+\n+    @Alternative()\n+    public List<GenericKafkaListener> getListValue() {\n+        return listValue;\n+    }\n+\n+    @Alternative()\n+    public KafkaListeners getObjectValue() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2NjM5Mw==", "bodyText": "this else can be removed, since we return in the if", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483466393", "createdAt": "2020-09-04T08:23:31Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final List<GenericKafkaListener> listValue;\n+    private final KafkaListeners objectValue;\n+\n+    public ArrayOrObjectKafkaListeners(List<GenericKafkaListener> listValue)   {\n+        this.listValue = listValue;\n+        this.objectValue = null;\n+    }\n+\n+    public ArrayOrObjectKafkaListeners(KafkaListeners objectValue)   {\n+        this.listValue = null;\n+        this.objectValue = objectValue;\n+    }\n+\n+    @Alternative()\n+    public List<GenericKafkaListener> getListValue() {\n+        return listValue;\n+    }\n+\n+    @Alternative()\n+    public KafkaListeners getObjectValue() {\n+        return objectValue;\n+    }\n+\n+    /**\n+     * Convenience method which returns either the new listener format if set, or converted old format.\n+     *\n+     * @return  List of new listeners\n+     */\n+    public List<GenericKafkaListener> newOrConverted()  {\n+        if (listValue != null)  {\n+            return listValue;\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2OTE1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public void serialize(ArrayOrObjectKafkaListeners value, JsonGenerator generator, SerializerProvider provider) throws IOException {\n          \n          \n            \n                    public void serialize(ArrayOrObjectKafkaListeners value, JsonGenerator generator, SerializerProvider provider) throws IOException {\n          \n          \n            \n                    if (value == null) {\n          \n          \n            \n                        generator.writeNull();\n          \n          \n            \n                        return;\n          \n          \n            \n                    }\n          \n          \n            \n                            if (value.listValue != null)    {\n          \n          \n            \n                                generator.writeObject(value.listValue);\n          \n          \n            \n                                return;\n          \n          \n            \n                            } \n          \n          \n            \n                            if (value.objectValue != null)  {\n          \n          \n            \n                                generator.writeObject(value.objectValue);\n          \n          \n            \n                                return;\n          \n          \n            \n                            }\n          \n          \n            \n                            generator.writeNull();\n          \n          \n            \n                            return;\n          \n          \n            \n                           \n          \n          \n            \n                    }", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483469150", "createdAt": "2020-09-04T08:28:44Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final List<GenericKafkaListener> listValue;\n+    private final KafkaListeners objectValue;\n+\n+    public ArrayOrObjectKafkaListeners(List<GenericKafkaListener> listValue)   {\n+        this.listValue = listValue;\n+        this.objectValue = null;\n+    }\n+\n+    public ArrayOrObjectKafkaListeners(KafkaListeners objectValue)   {\n+        this.listValue = null;\n+        this.objectValue = objectValue;\n+    }\n+\n+    @Alternative()\n+    public List<GenericKafkaListener> getListValue() {\n+        return listValue;\n+    }\n+\n+    @Alternative()\n+    public KafkaListeners getObjectValue() {\n+        return objectValue;\n+    }\n+\n+    /**\n+     * Convenience method which returns either the new listener format if set, or converted old format.\n+     *\n+     * @return  List of new listeners\n+     */\n+    public List<GenericKafkaListener> newOrConverted()  {\n+        if (listValue != null)  {\n+            return listValue;\n+        } else {\n+            return ListenersConvertor.convertToNewFormat(objectValue);\n+        }\n+    }\n+\n+    public static class Serializer extends JsonSerializer<ArrayOrObjectKafkaListeners> {\n+        @Override\n+        public void serialize(ArrayOrObjectKafkaListeners value, JsonGenerator generator, SerializerProvider provider) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MDIyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ArrayOrObjectKafkaListeners kafkaListeners;\n          \n          \n            \n                        ObjectCodec oc = jsonParser.getCodec();\n          \n          \n            \n                        if (jsonParser.currentToken() == JsonToken.START_ARRAY) {\n          \n          \n            \n                            return new ArrayOrObjectKafkaListeners(oc.readValue(jsonParser, new TypeReference<List<GenericKafkaListener>>() { }));\n          \n          \n            \n                        }\n          \n          \n            \n                        if (jsonParser.currentToken() == JsonToken.START_OBJECT) {\n          \n          \n            \n                            return new ArrayOrObjectKafkaListeners(oc.readValue(jsonParser, new TypeReference<KafkaListeners>() { }));\n          \n          \n            \n                        }\n          \n          \n            \n                        \n          \n          \n            \n                        throw new RuntimeException(\"Failed to deserialize ArrayOrObjectKafkaListeners. Please check .spec.kafka.listeners configuration.\");\n          \n          \n            \n                        }", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483470228", "createdAt": "2020-09-04T08:30:35Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final List<GenericKafkaListener> listValue;\n+    private final KafkaListeners objectValue;\n+\n+    public ArrayOrObjectKafkaListeners(List<GenericKafkaListener> listValue)   {\n+        this.listValue = listValue;\n+        this.objectValue = null;\n+    }\n+\n+    public ArrayOrObjectKafkaListeners(KafkaListeners objectValue)   {\n+        this.listValue = null;\n+        this.objectValue = objectValue;\n+    }\n+\n+    @Alternative()\n+    public List<GenericKafkaListener> getListValue() {\n+        return listValue;\n+    }\n+\n+    @Alternative()\n+    public KafkaListeners getObjectValue() {\n+        return objectValue;\n+    }\n+\n+    /**\n+     * Convenience method which returns either the new listener format if set, or converted old format.\n+     *\n+     * @return  List of new listeners\n+     */\n+    public List<GenericKafkaListener> newOrConverted()  {\n+        if (listValue != null)  {\n+            return listValue;\n+        } else {\n+            return ListenersConvertor.convertToNewFormat(objectValue);\n+        }\n+    }\n+\n+    public static class Serializer extends JsonSerializer<ArrayOrObjectKafkaListeners> {\n+        @Override\n+        public void serialize(ArrayOrObjectKafkaListeners value, JsonGenerator generator, SerializerProvider provider) throws IOException {\n+            if (value != null) {\n+                if (value.listValue != null)    {\n+                    generator.writeObject(value.listValue);\n+                } else if (value.objectValue != null)  {\n+                    generator.writeObject(value.objectValue);\n+                } else {\n+                    generator.writeNull();\n+                }\n+            } else {\n+                generator.writeNull();\n+            }\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC_ANON\")\n+    public static class Deserializer extends JsonDeserializer<ArrayOrObjectKafkaListeners> {\n+        @Override\n+        public ArrayOrObjectKafkaListeners deserialize(JsonParser jsonParser, DeserializationContext context) throws IOException {\n+            ArrayOrObjectKafkaListeners kafkaListeners;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MzMyOQ==", "bodyText": "https://www.baeldung.com/java-enum-values\nWe can set values to the enums to remove all of the boilerplate toValue, forValue i believe", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483473329", "createdAt": "2020-09-04T08:36:29Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/KafkaListenerType.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonValue;\n+\n+public enum KafkaListenerType {\n+    INTERNAL,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNDcwMjY5", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#pullrequestreview-482470269", "createdAt": "2020-09-04T08:41:57Z", "commit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0MTo1OFrOHNFDgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0MTo1OFrOHNFDgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NjM1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (oldListener.getConfiguration() != null || oldListener.getOverrides() != null) {\n          \n          \n            \n                    if (oldListener.getConfiguration() == null && oldListener.getOverrides() == null) {\n          \n          \n            \n                        return;\n          \n          \n            \n                    }", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483476354", "createdAt": "2020-09-04T08:41:58Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ListenersConvertor.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import io.strimzi.api.kafka.model.listener.IngressListenerBrokerConfiguration;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerExternal;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerExternalIngress;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerExternalLoadBalancer;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerExternalNodePort;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerExternalRoute;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerPlain;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerTls;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.api.kafka.model.listener.LoadBalancerListenerBrokerOverride;\n+import io.strimzi.api.kafka.model.listener.NodePortListenerBrokerOverride;\n+import io.strimzi.api.kafka.model.listener.RouteListenerBrokerOverride;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Util methods used for working with Kafka listeners\n+ */\n+public class ListenersConvertor {\n+    /**\n+     * Converts the Kafka listener configuration from old format to the new format\n+     *\n+     * @param oldListeners  Old Kafka listeners configuration\n+     * @return  New Kafka listeners configuration\n+     */\n+    @SuppressWarnings(\"deprecation\")\n+    public static List<GenericKafkaListener> convertToNewFormat(KafkaListeners oldListeners)    {\n+        List<GenericKafkaListener> newListeners = new ArrayList<>(3);\n+\n+        if (oldListeners != null)   {\n+            if (oldListeners.getPlain() != null)    {\n+                newListeners.add(convertPlainListener(oldListeners.getPlain()));\n+            }\n+\n+            if (oldListeners.getTls() != null)    {\n+                newListeners.add(convertTlsListener(oldListeners.getTls()));\n+            }\n+\n+            if (oldListeners.getExternal() != null)    {\n+                newListeners.add(convertExternalListener(oldListeners.getExternal()));\n+            }\n+        }\n+\n+        return newListeners;\n+    }\n+\n+    /**\n+     * Converts plain listener into the new format\n+     *\n+     * @param plain Plain listener in old format\n+     * @return  Listener in the new format\n+     */\n+    /*test*/ static GenericKafkaListener convertPlainListener(KafkaListenerPlain plain)  {\n+        return new GenericKafkaListenerBuilder()\n+                .withName(\"plain\")\n+                .withPort(9092)\n+                .withType(KafkaListenerType.INTERNAL)\n+                .withTls(false)\n+                .withAuth(plain.getAuth())\n+                .withNetworkPolicyPeers(plain.getNetworkPolicyPeers())\n+                .build();\n+    }\n+\n+    /**\n+     * Converts TLS listener into the new format\n+     *\n+     * @param tls TLS listener in old format\n+     * @return  Listener in the new format\n+     */\n+    /*test*/ static GenericKafkaListener convertTlsListener(KafkaListenerTls tls)  {\n+        GenericKafkaListenerConfiguration configuration = null;\n+\n+        if (tls.getConfiguration() != null) {\n+            configuration = new GenericKafkaListenerConfigurationBuilder()\n+                    .withBrokerCertChainAndKey(tls.getConfiguration().getBrokerCertChainAndKey())\n+                    .build();\n+        }\n+\n+        return new GenericKafkaListenerBuilder()\n+                .withName(\"tls\")\n+                .withPort(9093)\n+                .withType(KafkaListenerType.INTERNAL)\n+                .withTls(true)\n+                .withAuth(tls.getAuth())\n+                .withNetworkPolicyPeers(tls.getNetworkPolicyPeers())\n+                .withConfiguration(configuration)\n+                .build();\n+    }\n+\n+    /**\n+     * Converts External listener into the new format\n+     *\n+     * @param external External listener in old format\n+     * @return  Listener in the new format\n+     */\n+    /*test*/ static GenericKafkaListener convertExternalListener(KafkaListenerExternal external)  {\n+        GenericKafkaListener listener = new GenericKafkaListenerBuilder()\n+                .withName(\"external\")\n+                .withPort(9094)\n+                .withAuth(external.getAuth())\n+                .withNetworkPolicyPeers(external.getNetworkPolicyPeers())\n+                .build();\n+\n+        if (KafkaListenerExternalLoadBalancer.TYPE_LOADBALANCER.equals(external.getType())) {\n+            convertLoadBalancerListener(listener, (KafkaListenerExternalLoadBalancer) external);\n+        } else if (KafkaListenerExternalNodePort.TYPE_NODEPORT.equals(external.getType())) {\n+            convertNodePortListener(listener, (KafkaListenerExternalNodePort) external);\n+        } else if (KafkaListenerExternalRoute.TYPE_ROUTE.equals(external.getType())) {\n+            convertRouteListener(listener, (KafkaListenerExternalRoute) external);\n+        } else if (KafkaListenerExternalIngress.TYPE_INGRESS.equals(external.getType())) {\n+            convertIngressListener(listener, (KafkaListenerExternalIngress) external);\n+        }\n+\n+        return listener;\n+    }\n+\n+    /**\n+     * Converts Load Balancer listener from old to new configuration\n+     *\n+     * @param newListener   New listener which will be configured\n+     * @param oldListener   Old listener\n+     */\n+    private static void convertLoadBalancerListener(GenericKafkaListener newListener, KafkaListenerExternalLoadBalancer oldListener)    {\n+        newListener.setType(KafkaListenerType.LOADBALANCER);\n+        newListener.setTls(oldListener.isTls());\n+\n+        if (oldListener.getConfiguration() != null || oldListener.getOverrides() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 135}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNDcxMDY4", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#pullrequestreview-482471068", "createdAt": "2020-09-04T08:43:05Z", "commit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0MzowNVrOHNFF5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo1MDo1NVrOHNFXEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3Njk2Ng==", "bodyText": "Ditto flip this check", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483476966", "createdAt": "2020-09-04T08:43:05Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ListenersConvertor.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import io.strimzi.api.kafka.model.listener.IngressListenerBrokerConfiguration;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerExternal;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerExternalIngress;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerExternalLoadBalancer;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerExternalNodePort;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerExternalRoute;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerPlain;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerTls;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.api.kafka.model.listener.LoadBalancerListenerBrokerOverride;\n+import io.strimzi.api.kafka.model.listener.NodePortListenerBrokerOverride;\n+import io.strimzi.api.kafka.model.listener.RouteListenerBrokerOverride;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Util methods used for working with Kafka listeners\n+ */\n+public class ListenersConvertor {\n+    /**\n+     * Converts the Kafka listener configuration from old format to the new format\n+     *\n+     * @param oldListeners  Old Kafka listeners configuration\n+     * @return  New Kafka listeners configuration\n+     */\n+    @SuppressWarnings(\"deprecation\")\n+    public static List<GenericKafkaListener> convertToNewFormat(KafkaListeners oldListeners)    {\n+        List<GenericKafkaListener> newListeners = new ArrayList<>(3);\n+\n+        if (oldListeners != null)   {\n+            if (oldListeners.getPlain() != null)    {\n+                newListeners.add(convertPlainListener(oldListeners.getPlain()));\n+            }\n+\n+            if (oldListeners.getTls() != null)    {\n+                newListeners.add(convertTlsListener(oldListeners.getTls()));\n+            }\n+\n+            if (oldListeners.getExternal() != null)    {\n+                newListeners.add(convertExternalListener(oldListeners.getExternal()));\n+            }\n+        }\n+\n+        return newListeners;\n+    }\n+\n+    /**\n+     * Converts plain listener into the new format\n+     *\n+     * @param plain Plain listener in old format\n+     * @return  Listener in the new format\n+     */\n+    /*test*/ static GenericKafkaListener convertPlainListener(KafkaListenerPlain plain)  {\n+        return new GenericKafkaListenerBuilder()\n+                .withName(\"plain\")\n+                .withPort(9092)\n+                .withType(KafkaListenerType.INTERNAL)\n+                .withTls(false)\n+                .withAuth(plain.getAuth())\n+                .withNetworkPolicyPeers(plain.getNetworkPolicyPeers())\n+                .build();\n+    }\n+\n+    /**\n+     * Converts TLS listener into the new format\n+     *\n+     * @param tls TLS listener in old format\n+     * @return  Listener in the new format\n+     */\n+    /*test*/ static GenericKafkaListener convertTlsListener(KafkaListenerTls tls)  {\n+        GenericKafkaListenerConfiguration configuration = null;\n+\n+        if (tls.getConfiguration() != null) {\n+            configuration = new GenericKafkaListenerConfigurationBuilder()\n+                    .withBrokerCertChainAndKey(tls.getConfiguration().getBrokerCertChainAndKey())\n+                    .build();\n+        }\n+\n+        return new GenericKafkaListenerBuilder()\n+                .withName(\"tls\")\n+                .withPort(9093)\n+                .withType(KafkaListenerType.INTERNAL)\n+                .withTls(true)\n+                .withAuth(tls.getAuth())\n+                .withNetworkPolicyPeers(tls.getNetworkPolicyPeers())\n+                .withConfiguration(configuration)\n+                .build();\n+    }\n+\n+    /**\n+     * Converts External listener into the new format\n+     *\n+     * @param external External listener in old format\n+     * @return  Listener in the new format\n+     */\n+    /*test*/ static GenericKafkaListener convertExternalListener(KafkaListenerExternal external)  {\n+        GenericKafkaListener listener = new GenericKafkaListenerBuilder()\n+                .withName(\"external\")\n+                .withPort(9094)\n+                .withAuth(external.getAuth())\n+                .withNetworkPolicyPeers(external.getNetworkPolicyPeers())\n+                .build();\n+\n+        if (KafkaListenerExternalLoadBalancer.TYPE_LOADBALANCER.equals(external.getType())) {\n+            convertLoadBalancerListener(listener, (KafkaListenerExternalLoadBalancer) external);\n+        } else if (KafkaListenerExternalNodePort.TYPE_NODEPORT.equals(external.getType())) {\n+            convertNodePortListener(listener, (KafkaListenerExternalNodePort) external);\n+        } else if (KafkaListenerExternalRoute.TYPE_ROUTE.equals(external.getType())) {\n+            convertRouteListener(listener, (KafkaListenerExternalRoute) external);\n+        } else if (KafkaListenerExternalIngress.TYPE_INGRESS.equals(external.getType())) {\n+            convertIngressListener(listener, (KafkaListenerExternalIngress) external);\n+        }\n+\n+        return listener;\n+    }\n+\n+    /**\n+     * Converts Load Balancer listener from old to new configuration\n+     *\n+     * @param newListener   New listener which will be configured\n+     * @param oldListener   Old listener\n+     */\n+    private static void convertLoadBalancerListener(GenericKafkaListener newListener, KafkaListenerExternalLoadBalancer oldListener)    {\n+        newListener.setType(KafkaListenerType.LOADBALANCER);\n+        newListener.setTls(oldListener.isTls());\n+\n+        if (oldListener.getConfiguration() != null || oldListener.getOverrides() != null) {\n+            GenericKafkaListenerConfiguration configuration = new GenericKafkaListenerConfiguration();\n+\n+            if (oldListener.getConfiguration() != null) {\n+                configuration.setBrokerCertChainAndKey(oldListener.getConfiguration().getBrokerCertChainAndKey());\n+            }\n+\n+            if (oldListener.getOverrides() != null) {\n+                if (oldListener.getOverrides().getBootstrap() != null) {\n+                    GenericKafkaListenerConfigurationBootstrap bootstrapConfiguration = new GenericKafkaListenerConfigurationBootstrap();\n+                    bootstrapConfiguration.setLoadBalancerIP(oldListener.getOverrides().getBootstrap().getLoadBalancerIP());\n+                    bootstrapConfiguration.setDnsAnnotations(oldListener.getOverrides().getBootstrap().getDnsAnnotations());\n+\n+                    if (oldListener.getOverrides().getBootstrap().getAddress() != null) {\n+                        bootstrapConfiguration.setAlternativeNames(Collections.singletonList(oldListener.getOverrides().getBootstrap().getAddress()));\n+                    }\n+\n+                    configuration.setBootstrap(bootstrapConfiguration);\n+                }\n+\n+                if (oldListener.getOverrides().getBrokers() != null) {\n+                    List<GenericKafkaListenerConfigurationBroker> brokers = new ArrayList<>(oldListener.getOverrides().getBrokers().size());\n+\n+                    for (LoadBalancerListenerBrokerOverride oldBroker : oldListener.getOverrides().getBrokers()) {\n+                        GenericKafkaListenerConfigurationBroker brokerConfiguration = new GenericKafkaListenerConfigurationBroker();\n+                        brokerConfiguration.setBroker(oldBroker.getBroker());\n+                        brokerConfiguration.setLoadBalancerIP(oldBroker.getLoadBalancerIP());\n+                        brokerConfiguration.setDnsAnnotations(oldBroker.getDnsAnnotations());\n+                        brokerConfiguration.setAdvertisedHost(oldBroker.getAdvertisedHost());\n+                        brokerConfiguration.setAdvertisedPort(oldBroker.getAdvertisedPort());\n+\n+                        brokers.add(brokerConfiguration);\n+                    }\n+\n+                    configuration.setBrokers(brokers);\n+                }\n+            }\n+\n+            newListener.setConfiguration(configuration);\n+        }\n+    }\n+\n+    /**\n+     * Converts Node Port listener from old to new configuration\n+     *\n+     * @param newListener   New listener which will be configured\n+     * @param oldListener   Old listener\n+     */\n+    private static void convertNodePortListener(GenericKafkaListener newListener, KafkaListenerExternalNodePort oldListener)    {\n+        newListener.setType(KafkaListenerType.NODEPORT);\n+        newListener.setTls(oldListener.isTls());\n+\n+        if (oldListener.getConfiguration() != null || oldListener.getOverrides() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3OTQyOA==", "bodyText": "I assume this can be removed?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483479428", "createdAt": "2020-09-04T08:47:27Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaBrokerConfigurationBuilder.java", "diffHunk": "@@ -301,15 +226,15 @@ private void configureReplicationListener() {\n      *\n      * @return  String with advertised listener configuration\n      */\n-    private String getAdvertisedListener(String clusterName, String namespace, String listenerName, int port)    {\n+    /*private String getAdvertisedListener(String clusterName, String namespace, String listenerName, int port)    {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ4MTM2Mw==", "bodyText": "Does this not break us for non openshift?\nSince it is always deploying with routes?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483481363", "createdAt": "2020-09-04T08:50:55Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -835,327 +766,261 @@ public Service generateService() {\n     /*test*/ Map<String, String> getInternalDiscoveryAnnotation() {\n         JsonArray anno = new JsonArray();\n \n-        if (listeners != null) {\n-            if (listeners.getPlain() != null) {\n-                JsonObject discovery = new JsonObject();\n-                discovery.put(\"port\", 9092);\n-                discovery.put(\"tls\", false);\n-                discovery.put(\"protocol\", \"kafka\");\n-\n-                if (listeners.getPlain().getAuth() != null) {\n-                    discovery.put(\"auth\", listeners.getPlain().getAuth().getType());\n-                } else {\n-                    discovery.put(\"auth\", \"none\");\n-                }\n+        for (GenericKafkaListener listener : listeners) {\n+            JsonObject discovery = new JsonObject();\n+            discovery.put(\"port\", listener.getPort());\n+            discovery.put(\"tls\", listener.isTls());\n+            discovery.put(\"protocol\", \"kafka\");\n \n-                anno.add(discovery);\n+            if (listener.getAuth() != null) {\n+                discovery.put(\"auth\", listener.getAuth().getType());\n+            } else {\n+                discovery.put(\"auth\", \"none\");\n             }\n \n-            if (listeners.getTls() != null) {\n-                JsonObject discovery = new JsonObject();\n-                discovery.put(\"port\", 9093);\n-                discovery.put(\"tls\", true);\n-                discovery.put(\"protocol\", \"kafka\");\n-\n-                if (listeners.getTls().getAuth() != null) {\n-                    discovery.put(\"auth\", listeners.getTls().getAuth().getType());\n-                } else {\n-                    discovery.put(\"auth\", \"none\");\n-                }\n-\n-                anno.add(discovery);\n-            }\n+            anno.add(discovery);\n         }\n \n         return singletonMap(Labels.STRIMZI_DISCOVERY_LABEL, anno.encodePrettily());\n     }\n \n     /**\n-     * Utility function to help to determine the type of service based on external listener configuration\n+     * Generates list of external bootstrap services. These services are used for exposing it externally.\n+     * Separate services are used to make sure that we do expose the right port in the right way.\n      *\n-     * @return Service type\n+     * @return The list with generated Services\n      */\n-    private String getExternalServiceType() {\n-        if (isExposedWithNodePort()) {\n-            return \"NodePort\";\n-        } else if (isExposedWithLoadBalancer()) {\n-            return \"LoadBalancer\";\n-        } else {\n-            return \"ClusterIP\";\n-        }\n-    }\n-\n-    /**\n-     * Generates external bootstrap service. This service is used for exposing it externally.\n-     * It exposes only the external port 9094.\n-     * Separate service is used to make sure that we do not expose the internal ports to the outside of the cluster\n-     *\n-     * @return The generated Service\n-     */\n-    public Service generateExternalBootstrapService() {\n-        if (isExposed()) {\n-            String externalBootstrapServiceName = externalBootstrapServiceName(cluster);\n-\n-            List<ServicePort> ports;\n-            Integer nodePort = null;\n-            if (isExposedWithNodePort()) {\n-                KafkaListenerExternalNodePort externalNodePort = (KafkaListenerExternalNodePort) listeners.getExternal();\n-                if (externalNodePort.getOverrides() != null && externalNodePort.getOverrides().getBootstrap() != null) {\n-                    nodePort = externalNodePort.getOverrides().getBootstrap().getNodePort();\n-                }\n-            }\n-            ports = Collections.singletonList(createServicePort(EXTERNAL_PORT_NAME, EXTERNAL_PORT, EXTERNAL_PORT,\n-                    nodePort, \"TCP\"));\n-\n-            Map<String, String> dnsAnnotations = Collections.emptyMap();\n-            String loadBalancerIP = null;\n-\n-            if (isExposedWithLoadBalancer())    {\n-                KafkaListenerExternalLoadBalancer externalLb = (KafkaListenerExternalLoadBalancer) listeners.getExternal();\n-\n-                if (externalLb.getOverrides() != null && externalLb.getOverrides().getBootstrap() != null) {\n-                    dnsAnnotations = externalLb.getOverrides().getBootstrap().getDnsAnnotations();\n-                    loadBalancerIP = externalLb.getOverrides().getBootstrap().getLoadBalancerIP();\n-                }\n-            } else if (isExposedWithNodePort()) {\n-                KafkaListenerExternalNodePort externalNp = (KafkaListenerExternalNodePort) listeners.getExternal();\n-\n-                if (externalNp.getOverrides() != null && externalNp.getOverrides().getBootstrap() != null) {\n-                    dnsAnnotations = externalNp.getOverrides().getBootstrap().getDnsAnnotations();\n+    public List<Service> generateExternalBootstrapServices() {\n+        List<GenericKafkaListener> externalListeners = ListenersUtils.externalListeners(listeners);\n+        List<Service> services = new ArrayList<>(externalListeners.size());\n+\n+        for (GenericKafkaListener listener : externalListeners)   {\n+            String serviceName = ListenersUtils.backwardsCompatibleBootstrapServiceName(cluster, listener);\n+\n+            List<ServicePort> ports = Collections.singletonList(\n+                    createServicePort(ListenersUtils.backwardsCompatiblePortName(listener),\n+                            listener.getPort(),\n+                            listener.getPort(),\n+                            ListenersUtils.bootstrapNodePort(listener),\n+                            \"TCP\")\n+            );\n+\n+            Service service = createService(\n+                    serviceName,\n+                    ListenersUtils.getServiceType(listener),\n+                    ports,\n+                    getLabelsWithStrimziName(name, templateExternalBootstrapServiceLabels),\n+                    getSelectorLabels(),\n+                    Util.mergeLabelsOrAnnotations(ListenersUtils.bootstrapDnsAnnotations(listener), templateExternalBootstrapServiceAnnotations)\n+            );\n+\n+            if (KafkaListenerType.LOADBALANCER == listener.getType()) {\n+                String loadBalancerIP = ListenersUtils.bootstrapLoadBalancerIP(listener);\n+                if (loadBalancerIP != null) {\n+                    service.getSpec().setLoadBalancerIP(loadBalancerIP);\n                 }\n             }\n \n-            Service service = createService(externalBootstrapServiceName, getExternalServiceType(), ports,\n-                    getLabelsWithStrimziName(externalBootstrapServiceName, templateExternalBootstrapServiceLabels), getSelectorLabels(),\n-                    Util.mergeLabelsOrAnnotations(dnsAnnotations, templateExternalBootstrapServiceAnnotations), loadBalancerIP);\n-\n-            if (isExposedWithLoadBalancer()) {\n-                if (templateExternalBootstrapServiceLoadBalancerSourceRanges != null) {\n+            if (KafkaListenerType.LOADBALANCER == listener.getType()) {\n+                List<String> loadBalancerSourceRanges = ListenersUtils.loadBalancerSourceRanges(listener);\n+                if (loadBalancerSourceRanges != null) {\n+                    service.getSpec().setLoadBalancerSourceRanges(loadBalancerSourceRanges);\n+                } else if (templateExternalBootstrapServiceLoadBalancerSourceRanges != null) {\n                     service.getSpec().setLoadBalancerSourceRanges(templateExternalBootstrapServiceLoadBalancerSourceRanges);\n                 }\n             }\n \n-            if (isExposedWithLoadBalancer() || isExposedWithNodePort()) {\n-                if (templateExternalBootstrapServiceTrafficPolicy != null)  {\n+            if (KafkaListenerType.LOADBALANCER == listener.getType() || KafkaListenerType.NODEPORT == listener.getType()) {\n+                ExternalTrafficPolicy etp = ListenersUtils.externalTrafficPolicy(listener);\n+                if (etp != null) {\n+                    service.getSpec().setExternalTrafficPolicy(etp.toValue());\n+                } else if (templateExternalBootstrapServiceTrafficPolicy != null) {\n                     service.getSpec().setExternalTrafficPolicy(templateExternalBootstrapServiceTrafficPolicy.toValue());\n                 }\n             }\n \n-            return service;\n+            services.add(service);\n         }\n \n-        return null;\n+        return services;\n     }\n \n     /**\n-     * Generates service for pod. This service is used for exposing it externally.\n+     * Generates list of service for pod. These services are used for exposing it externally.\n      *\n      * @param pod Number of the pod for which this service should be generated\n-     * @return The generated Service\n+     * @return The list with generated Services\n      */\n-    public Service generateExternalService(int pod) {\n-        if (isExposed()) {\n-            String perPodServiceName = externalServiceName(cluster, pod);\n-\n-            List<ServicePort> ports = new ArrayList<>(1);\n-            Integer nodePort = null;\n-            if (isExposedWithNodePort()) {\n-                KafkaListenerExternalNodePort externalNodePort = (KafkaListenerExternalNodePort) listeners.getExternal();\n-                if (externalNodePort.getOverrides() != null && externalNodePort.getOverrides().getBrokers() != null) {\n-                    nodePort = externalNodePort.getOverrides().getBrokers().stream()\n-                            .filter(broker -> broker != null && broker.getBroker() != null && broker.getBroker() == pod && broker.getNodePort() != null)\n-                            .map(NodePortListenerBrokerOverride::getNodePort)\n-                            .findAny().orElse(null);\n-                }\n-            }\n-            ports.add(createServicePort(EXTERNAL_PORT_NAME, EXTERNAL_PORT, EXTERNAL_PORT, nodePort, \"TCP\"));\n-\n-            Map<String, String> dnsAnnotations = Collections.emptyMap();\n-            String loadBalancerIP = null;\n-\n-            if (isExposedWithLoadBalancer())    {\n-                KafkaListenerExternalLoadBalancer externalLb = (KafkaListenerExternalLoadBalancer) listeners.getExternal();\n-\n-                if (externalLb.getOverrides() != null && externalLb.getOverrides().getBrokers() != null) {\n-                    dnsAnnotations = externalLb.getOverrides().getBrokers().stream()\n-                            .filter(broker -> broker != null && broker.getBroker() == pod)\n-                            .map(LoadBalancerListenerBrokerOverride::getDnsAnnotations)\n-                            .findAny()\n-                            .orElse(Collections.emptyMap());\n-\n-                    loadBalancerIP = externalLb.getOverrides().getBrokers().stream()\n-                            .filter(brokerService -> brokerService != null && brokerService.getBroker() == pod\n-                                    && brokerService.getLoadBalancerIP() != null)\n-                            .map(LoadBalancerListenerBrokerOverride::getLoadBalancerIP)\n-                            .findAny()\n-                            .orElse(null);\n-\n-                    if (loadBalancerIP != null && loadBalancerIP.isEmpty()) {\n-                        loadBalancerIP = null;\n-                    }\n-                }\n-            } else if (isExposedWithNodePort()) {\n-                KafkaListenerExternalNodePort externalNp = (KafkaListenerExternalNodePort) listeners.getExternal();\n-\n-                if (externalNp.getOverrides() != null && externalNp.getOverrides().getBrokers() != null) {\n-                    dnsAnnotations = externalNp.getOverrides().getBrokers().stream()\n-                            .filter(broker -> broker != null && broker.getBroker() == pod)\n-                            .map(NodePortListenerBrokerOverride::getDnsAnnotations)\n-                            .findAny()\n-                            .orElse(Collections.emptyMap());\n-                }\n-            }\n+    public List<Service> generateExternalServices(int pod) {\n+        List<GenericKafkaListener> externalListeners = ListenersUtils.externalListeners(listeners);\n+        List<Service> services = new ArrayList<>(externalListeners.size());\n+\n+        for (GenericKafkaListener listener : externalListeners)   {\n+            String serviceName = ListenersUtils.backwardsCompatibleBrokerServiceName(cluster, pod, listener);\n+\n+            List<ServicePort> ports = Collections.singletonList(\n+                    createServicePort(ListenersUtils.backwardsCompatiblePortName(listener),\n+                            listener.getPort(),\n+                            listener.getPort(),\n+                            ListenersUtils.brokerNodePort(listener, pod),\n+                            \"TCP\")\n+            );\n \n             Labels selector = getSelectorLabels().withStatefulSetPod(kafkaPodName(cluster, pod));\n \n-            Service service = createService(perPodServiceName, getExternalServiceType(), ports,\n-                    getLabelsWithStrimziName(perPodServiceName, templatePerPodServiceLabels), selector,\n-                    Util.mergeLabelsOrAnnotations(dnsAnnotations, templatePerPodServiceAnnotations), loadBalancerIP);\n+            Service service = createService(\n+                    serviceName,\n+                    ListenersUtils.getServiceType(listener),\n+                    ports,\n+                    getLabelsWithStrimziName(name, templatePerPodServiceLabels),\n+                    selector,\n+                    Util.mergeLabelsOrAnnotations(ListenersUtils.brokerDnsAnnotations(listener, pod), templatePerPodServiceAnnotations)\n+            );\n+\n+            if (KafkaListenerType.LOADBALANCER == listener.getType()) {\n+                String loadBalancerIP = ListenersUtils.brokerLoadBalancerIP(listener, pod);\n+                if (loadBalancerIP != null) {\n+                    service.getSpec().setLoadBalancerIP(loadBalancerIP);\n+                }\n+            }\n \n-            if (isExposedWithLoadBalancer()) {\n-                if (templatePerPodServiceLoadBalancerSourceRanges != null) {\n+            if (KafkaListenerType.LOADBALANCER == listener.getType()) {\n+                List<String> loadBalancerSourceRanges = ListenersUtils.loadBalancerSourceRanges(listener);\n+                if (loadBalancerSourceRanges != null) {\n+                    service.getSpec().setLoadBalancerSourceRanges(loadBalancerSourceRanges);\n+                } else if (templatePerPodServiceLoadBalancerSourceRanges != null) {\n                     service.getSpec().setLoadBalancerSourceRanges(templatePerPodServiceLoadBalancerSourceRanges);\n                 }\n             }\n \n-            if (isExposedWithLoadBalancer() || isExposedWithNodePort()) {\n-                if (templatePerPodServiceTrafficPolicy != null)  {\n+            if (KafkaListenerType.LOADBALANCER == listener.getType() || KafkaListenerType.NODEPORT == listener.getType()) {\n+                ExternalTrafficPolicy etp = ListenersUtils.externalTrafficPolicy(listener);\n+                if (etp != null) {\n+                    service.getSpec().setExternalTrafficPolicy(etp.toValue());\n+                } else if (templatePerPodServiceTrafficPolicy != null) {\n                     service.getSpec().setExternalTrafficPolicy(templatePerPodServiceTrafficPolicy.toValue());\n                 }\n             }\n \n-            return service;\n+            services.add(service);\n         }\n \n-        return null;\n+        return services;\n     }\n \n-    /**\n-     * Generates route for pod. This route is used for exposing it externally using OpenShift Routes.\n+        /**\n+     * Generates a list of bootstrap route which can be used to bootstrap clients outside of OpenShift.\n      *\n-     * @param pod Number of the pod for which this route should be generated\n-     * @return The generated Route\n+     * @return The list of generated Routes\n      */\n-    public Route generateExternalRoute(int pod) {\n-        if (isExposedWithRoute()) {\n-            String perPodServiceName = externalServiceName(cluster, pod);\n+    public List<Route> generateExternalBootstrapRoutes() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 568}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNDYyNDE2", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#pullrequestreview-482462416", "createdAt": "2020-09-04T08:30:50Z", "commit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "state": "COMMENTED", "comments": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozMDo1MFrOHNEsEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOToxOTozMFrOHNGU8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MDM1NQ==", "bodyText": "We write an object for the list value?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483470355", "createdAt": "2020-09-04T08:30:50Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final List<GenericKafkaListener> listValue;\n+    private final KafkaListeners objectValue;\n+\n+    public ArrayOrObjectKafkaListeners(List<GenericKafkaListener> listValue)   {\n+        this.listValue = listValue;\n+        this.objectValue = null;\n+    }\n+\n+    public ArrayOrObjectKafkaListeners(KafkaListeners objectValue)   {\n+        this.listValue = null;\n+        this.objectValue = objectValue;\n+    }\n+\n+    @Alternative()\n+    public List<GenericKafkaListener> getListValue() {\n+        return listValue;\n+    }\n+\n+    @Alternative()\n+    public KafkaListeners getObjectValue() {\n+        return objectValue;\n+    }\n+\n+    /**\n+     * Convenience method which returns either the new listener format if set, or converted old format.\n+     *\n+     * @return  List of new listeners\n+     */\n+    public List<GenericKafkaListener> newOrConverted()  {\n+        if (listValue != null)  {\n+            return listValue;\n+        } else {\n+            return ListenersConvertor.convertToNewFormat(objectValue);\n+        }\n+    }\n+\n+    public static class Serializer extends JsonSerializer<ArrayOrObjectKafkaListeners> {\n+        @Override\n+        public void serialize(ArrayOrObjectKafkaListeners value, JsonGenerator generator, SerializerProvider provider) throws IOException {\n+            if (value != null) {\n+                if (value.listValue != null)    {\n+                    generator.writeObject(value.listValue);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MTIxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"The name has to be unique within given Kafka cluster. \" +\n          \n          \n            \n                        \"The name has to be unique within a given Kafka cluster. \" +", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483471219", "createdAt": "2020-09-04T08:32:29Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MjMzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"The port number has to be unique within given Kafka cluster. \" +\n          \n          \n            \n                        \"The port number has to be unique within a given Kafka cluster. \" +", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483472331", "createdAt": "2020-09-04T08:34:36Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MzE2NQ==", "bodyText": "A sentence shouldn't start with a \"But\"\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n          \n          \n            \n                        \"Depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n          \n      \n    \n    \n  \n\nAlternatively it might be better to merge this with the preceding sentence.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483473165", "createdAt": "2020-09-04T08:36:08Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +\n+            \"The port number will be used for the listener inside Kafka. \" +\n+            \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MzQ3Ng==", "bodyText": "Is it an external listener if one of the types is internal?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483473476", "createdAt": "2020-09-04T08:36:46Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +\n+            \"The port number will be used for the listener inside Kafka. \" +\n+            \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n+    @JsonProperty(required = true)\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    @Description(\"Type of the external listener. \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MzcwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"* `internal` type exposes Kafka internally only within Kubernetes cluster.\" +\n          \n          \n            \n                        \"* `internal` type exposes Kafka internally only within the Kubernetes cluster.\\n\" +", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483473708", "createdAt": "2020-09-04T08:37:16Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +\n+            \"The port number will be used for the listener inside Kafka. \" +\n+            \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n+    @JsonProperty(required = true)\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    @Description(\"Type of the external listener. \" +\n+            \"Currently the supported types are `internal, `route`, `loadbalancer`, `nodeport` and `ingress`. \\n\\n\" +\n+            \"* `internal` type exposes Kafka internally only within Kubernetes cluster.\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MzgzNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"* `route` type uses OpenShift Routes to expose Kafka.\" +\n          \n          \n            \n                        \"* `route` type uses OpenShift Routes to expose Kafka.\\n\" +", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483473835", "createdAt": "2020-09-04T08:37:29Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +\n+            \"The port number will be used for the listener inside Kafka. \" +\n+            \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n+    @JsonProperty(required = true)\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    @Description(\"Type of the external listener. \" +\n+            \"Currently the supported types are `internal, `route`, `loadbalancer`, `nodeport` and `ingress`. \\n\\n\" +\n+            \"* `internal` type exposes Kafka internally only within Kubernetes cluster.\" +\n+            \"* `route` type uses OpenShift Routes to expose Kafka.\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3Mzk4Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"* `loadbalancer` type uses LoadBalancer type services to expose Kafka.\" +\n          \n          \n            \n                        \"* `loadbalancer` type uses LoadBalancer type services to expose Kafka.\\n\" +", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483473982", "createdAt": "2020-09-04T08:37:47Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +\n+            \"The port number will be used for the listener inside Kafka. \" +\n+            \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n+    @JsonProperty(required = true)\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    @Description(\"Type of the external listener. \" +\n+            \"Currently the supported types are `internal, `route`, `loadbalancer`, `nodeport` and `ingress`. \\n\\n\" +\n+            \"* `internal` type exposes Kafka internally only within Kubernetes cluster.\" +\n+            \"* `route` type uses OpenShift Routes to expose Kafka.\" +\n+            \"* `loadbalancer` type uses LoadBalancer type services to expose Kafka.\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NDExMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"* `nodeport` type uses NodePort type services to expose Kafka.\" +\n          \n          \n            \n                        \"* `nodeport` type uses NodePort type services to expose Kafka.\\n\" +", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483474110", "createdAt": "2020-09-04T08:37:59Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +\n+            \"The port number will be used for the listener inside Kafka. \" +\n+            \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n+    @JsonProperty(required = true)\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    @Description(\"Type of the external listener. \" +\n+            \"Currently the supported types are `internal, `route`, `loadbalancer`, `nodeport` and `ingress`. \\n\\n\" +\n+            \"* `internal` type exposes Kafka internally only within Kubernetes cluster.\" +\n+            \"* `route` type uses OpenShift Routes to expose Kafka.\" +\n+            \"* `loadbalancer` type uses LoadBalancer type services to expose Kafka.\" +\n+            \"* `nodeport` type uses NodePort type services to expose Kafka.\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NDQzOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"* `ingress` type uses Kubernetes Nginx Ingress to expose Kafka.\")\n          \n          \n            \n                        \"* `ingress` type uses Kubernetes Nginx Ingress to expose Kafka.\\n\")\n          \n      \n    \n    \n  \n\nI thought we could (theorretically) configure ingress to use something other than Nginx?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483474438", "createdAt": "2020-09-04T08:38:35Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +\n+            \"The port number will be used for the listener inside Kafka. \" +\n+            \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n+    @JsonProperty(required = true)\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    @Description(\"Type of the external listener. \" +\n+            \"Currently the supported types are `internal, `route`, `loadbalancer`, `nodeport` and `ingress`. \\n\\n\" +\n+            \"* `internal` type exposes Kafka internally only within Kubernetes cluster.\" +\n+            \"* `route` type uses OpenShift Routes to expose Kafka.\" +\n+            \"* `loadbalancer` type uses LoadBalancer type services to expose Kafka.\" +\n+            \"* `nodeport` type uses NodePort type services to expose Kafka.\" +\n+            \"* `ingress` type uses Kubernetes Nginx Ingress to expose Kafka.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NDk0MA==", "bodyText": "It's listener specific, so it's a bit misleading to bring brokers into it.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Description(\"Authentication configuration for Kafka brokers\")\n          \n          \n            \n                @Description(\"Authentication configuration for this listener\")", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483474940", "createdAt": "2020-09-04T08:39:30Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +\n+            \"The port number will be used for the listener inside Kafka. \" +\n+            \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n+    @JsonProperty(required = true)\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    @Description(\"Type of the external listener. \" +\n+            \"Currently the supported types are `internal, `route`, `loadbalancer`, `nodeport` and `ingress`. \\n\\n\" +\n+            \"* `internal` type exposes Kafka internally only within Kubernetes cluster.\" +\n+            \"* `route` type uses OpenShift Routes to expose Kafka.\" +\n+            \"* `loadbalancer` type uses LoadBalancer type services to expose Kafka.\" +\n+            \"* `nodeport` type uses NodePort type services to expose Kafka.\" +\n+            \"* `ingress` type uses Kubernetes Nginx Ingress to expose Kafka.\")\n+    @JsonProperty(required = true)\n+    public KafkaListenerType getType() {\n+        return type;\n+    }\n+\n+    public void setType(KafkaListenerType type) {\n+        this.type = type;\n+    }\n+\n+    @Description(\"Authentication configuration for Kafka brokers\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NTk5Nw==", "bodyText": "I do wonder whether false is the best default for all listeners. If we used a Boolean we could have different defaults for different listener types, right? Or should be make it a mandatory property.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483475997", "createdAt": "2020-09-04T08:41:19Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +\n+            \"The port number will be used for the listener inside Kafka. \" +\n+            \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n+    @JsonProperty(required = true)\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    @Description(\"Type of the external listener. \" +\n+            \"Currently the supported types are `internal, `route`, `loadbalancer`, `nodeport` and `ingress`. \\n\\n\" +\n+            \"* `internal` type exposes Kafka internally only within Kubernetes cluster.\" +\n+            \"* `route` type uses OpenShift Routes to expose Kafka.\" +\n+            \"* `loadbalancer` type uses LoadBalancer type services to expose Kafka.\" +\n+            \"* `nodeport` type uses NodePort type services to expose Kafka.\" +\n+            \"* `ingress` type uses Kubernetes Nginx Ingress to expose Kafka.\")\n+    @JsonProperty(required = true)\n+    public KafkaListenerType getType() {\n+        return type;\n+    }\n+\n+    public void setType(KafkaListenerType type) {\n+        this.type = type;\n+    }\n+\n+    @Description(\"Authentication configuration for Kafka brokers\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @JsonProperty(\"authentication\")\n+    public KafkaListenerAuthentication getAuth() {\n+        return auth;\n+    }\n+\n+    public void setAuth(KafkaListenerAuthentication auth) {\n+        this.auth = auth;\n+    }\n+\n+    @Description(\"Enables TLS encryption on the listener. \" +\n+            \"By default set to `false` for disabled TLS encryption.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3OTE2Ng==", "bodyText": "In the ingress-specific property is called ingressClass shouldn't this be be preferredNodeportAddressType?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483479166", "createdAt": "2020-09-04T08:46:56Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListenerConfiguration.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.CertAndKeySecretSource;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Collections.emptyMap;\n+\n+/**\n+ * Configures Kafka listeners\n+ */\n+@JsonPropertyOrder({\"brokerCertChainAndKey\", \"ingressClass\", \"preferredAddressType\", \"externalTrafficPolicy\", \"loadBalancerSourceRanges\", \"bootstrap\", \"brokers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Buildable(\n+    editableEnabled = false,\n+    builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@EqualsAndHashCode\n+public class GenericKafkaListenerConfiguration implements Serializable, UnknownPropertyPreserving {\n+    private static final long serialVersionUID = 1L;\n+\n+    private CertAndKeySecretSource brokerCertChainAndKey;\n+    private String ingressClass;\n+    private NodeAddressType preferredAddressType;\n+    private ExternalTrafficPolicy externalTrafficPolicy;\n+    private List<String> loadBalancerSourceRanges = new ArrayList<>(0);\n+    private Boolean useServiceDnsDomain;\n+    private GenericKafkaListenerConfigurationBootstrap bootstrap;\n+    private List<GenericKafkaListenerConfigurationBroker> brokers;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. \" +\n+            \"The certificate can optionally contain the whole chain. \" +\n+            \"This field can be used only with listeners with enabled TLS encryption.\")\n+    public CertAndKeySecretSource getBrokerCertChainAndKey() {\n+        return brokerCertChainAndKey;\n+    }\n+\n+    public void setBrokerCertChainAndKey(CertAndKeySecretSource brokerCertChainAndKey) {\n+        this.brokerCertChainAndKey = brokerCertChainAndKey;\n+    }\n+\n+    @Description(\"Configures the `Ingress` class that defines which `Ingress` controller will be used. \" +\n+            \"If not set, the `Ingress` class is set to `nginx`. \" +\n+            \"This field can be used only with `ingress` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @JsonProperty(\"class\")\n+    public String getIngressClass() {\n+        return ingressClass;\n+    }\n+\n+    public void setIngressClass(String ingressClass) {\n+        this.ingressClass = ingressClass;\n+    }\n+\n+    @Description(\"Defines which address type should be used as the node address. \" +\n+            \"Available types are: `ExternalDNS`, `ExternalIP`, `InternalDNS`, `InternalIP` and `Hostname`. \" +\n+            \"By default, the addresses will be used in the following order (the first one found will be used):\\n\" +\n+            \"* `ExternalDNS`\\n\" +\n+            \"* `ExternalIP`\\n\" +\n+            \"* `InternalDNS`\\n\" +\n+            \"* `InternalIP`\\n\" +\n+            \"* `Hostname`\\n\" +\n+            \"\\n\" +\n+            \"This field can be used to select the address type which will be used as the preferred type and checked first. \" +\n+            \"In case no address will be found for this address type, the other types will be used in the default order.\" +\n+            \"This field can be used only with `nodeport` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public NodeAddressType getPreferredAddressType() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3OTM5MQ==", "bodyText": "Similarly externalLoadbalancerTrafficPolicy?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483479391", "createdAt": "2020-09-04T08:47:23Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListenerConfiguration.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.CertAndKeySecretSource;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Collections.emptyMap;\n+\n+/**\n+ * Configures Kafka listeners\n+ */\n+@JsonPropertyOrder({\"brokerCertChainAndKey\", \"ingressClass\", \"preferredAddressType\", \"externalTrafficPolicy\", \"loadBalancerSourceRanges\", \"bootstrap\", \"brokers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Buildable(\n+    editableEnabled = false,\n+    builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@EqualsAndHashCode\n+public class GenericKafkaListenerConfiguration implements Serializable, UnknownPropertyPreserving {\n+    private static final long serialVersionUID = 1L;\n+\n+    private CertAndKeySecretSource brokerCertChainAndKey;\n+    private String ingressClass;\n+    private NodeAddressType preferredAddressType;\n+    private ExternalTrafficPolicy externalTrafficPolicy;\n+    private List<String> loadBalancerSourceRanges = new ArrayList<>(0);\n+    private Boolean useServiceDnsDomain;\n+    private GenericKafkaListenerConfigurationBootstrap bootstrap;\n+    private List<GenericKafkaListenerConfigurationBroker> brokers;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. \" +\n+            \"The certificate can optionally contain the whole chain. \" +\n+            \"This field can be used only with listeners with enabled TLS encryption.\")\n+    public CertAndKeySecretSource getBrokerCertChainAndKey() {\n+        return brokerCertChainAndKey;\n+    }\n+\n+    public void setBrokerCertChainAndKey(CertAndKeySecretSource brokerCertChainAndKey) {\n+        this.brokerCertChainAndKey = brokerCertChainAndKey;\n+    }\n+\n+    @Description(\"Configures the `Ingress` class that defines which `Ingress` controller will be used. \" +\n+            \"If not set, the `Ingress` class is set to `nginx`. \" +\n+            \"This field can be used only with `ingress` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @JsonProperty(\"class\")\n+    public String getIngressClass() {\n+        return ingressClass;\n+    }\n+\n+    public void setIngressClass(String ingressClass) {\n+        this.ingressClass = ingressClass;\n+    }\n+\n+    @Description(\"Defines which address type should be used as the node address. \" +\n+            \"Available types are: `ExternalDNS`, `ExternalIP`, `InternalDNS`, `InternalIP` and `Hostname`. \" +\n+            \"By default, the addresses will be used in the following order (the first one found will be used):\\n\" +\n+            \"* `ExternalDNS`\\n\" +\n+            \"* `ExternalIP`\\n\" +\n+            \"* `InternalDNS`\\n\" +\n+            \"* `InternalIP`\\n\" +\n+            \"* `Hostname`\\n\" +\n+            \"\\n\" +\n+            \"This field can be used to select the address type which will be used as the preferred type and checked first. \" +\n+            \"In case no address will be found for this address type, the other types will be used in the default order.\" +\n+            \"This field can be used only with `nodeport` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public NodeAddressType getPreferredAddressType() {\n+        return preferredAddressType;\n+    }\n+\n+    public void setPreferredAddressType(NodeAddressType preferredAddressType) {\n+        this.preferredAddressType = preferredAddressType;\n+    }\n+\n+    @Description(\"Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. \" +\n+            \"`Cluster` may cause a second hop to another node and obscures the client source IP. \" +\n+            \"`Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). \" +\n+            \"If unspecified, Kubernetes will use `Cluster` as the default.\" +\n+            \"This field can be used only with `loadbalancer` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public ExternalTrafficPolicy getExternalTrafficPolicy() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ4NDYwNg==", "bodyText": "Can we constrain it using @Pattern to be an IP address?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483484606", "createdAt": "2020-09-04T08:56:36Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListenerConfigurationBootstrap.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures listener bootstrap configuration\n+ */\n+@JsonPropertyOrder({\"alternativeNames\", \"host\", \"dnsAnnotations\", \"nodePort\", \"loadBalancerIP\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Buildable(\n+    editableEnabled = false,\n+    builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@EqualsAndHashCode\n+public class GenericKafkaListenerConfigurationBootstrap implements Serializable, UnknownPropertyPreserving {\n+    private static final long serialVersionUID = 1L;\n+\n+    private List<String> alternativeNames;\n+    private String host;\n+    private Map<String, String> dnsAnnotations = new HashMap<>(0);\n+    private Integer nodePort;\n+    private String loadBalancerIP;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"Additional alternative names for the bootstrap service. \" +\n+            \"The alternative names will be added to the list of subject alternative names of the TLS certificates.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public List<String> getAlternativeNames() {\n+        return alternativeNames;\n+    }\n+\n+    public void setAlternativeNames(List<String> alternativeNames) {\n+        this.alternativeNames = alternativeNames;\n+    }\n+\n+    @Description(\"The bootstrap host. \" +\n+            \"This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. \" +\n+            \"This field can be used only with `route` (optional) or `ingress` (required) type listeners.\")\n+    @JsonProperty(required = true)\n+    public String getHost() {\n+        return host;\n+    }\n+\n+    public void setHost(String host) {\n+        this.host = host;\n+    }\n+\n+    @Description(\"Annotations that will be added to the `Ingress` or `Service` resource. \" +\n+            \"You can use this field to configure DNS providers such as External DNS. \" +\n+            \"This field can be used only with `loadbalancer`, `nodeport`, or `ingress` type listeners.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, String> getDnsAnnotations() {\n+        return dnsAnnotations;\n+    }\n+\n+    public void setDnsAnnotations(Map<String, String> dnsAnnotations) {\n+        this.dnsAnnotations = dnsAnnotations;\n+    }\n+\n+    @Description(\"Node port for the bootstrap service. \" +\n+            \"This field can be used only with `nodeport` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public Integer getNodePort() {\n+        return nodePort;\n+    }\n+\n+    public void setNodePort(Integer nodePort) {\n+        this.nodePort = nodePort;\n+    }\n+\n+    @Description(\"The loadbalancer is requested with the IP address specified in this field. \" +\n+            \"This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. \" +\n+            \"This field is ignored if the cloud provider does not support the feature.\" +\n+            \"This field can be used only with `loadbalancer` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public String getLoadBalancerIP() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ4NDg4NQ==", "bodyText": "Again, can be use @Pattern?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483484885", "createdAt": "2020-09-04T08:57:01Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListenerConfigurationBroker.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.util.Collections.emptyMap;\n+\n+/**\n+ * Configures listener per-broker configuration\n+ */\n+@JsonPropertyOrder({\"broker\", \"advertisedHost\", \"advertisedPort\", \"host\", \"dnsAnnotations\", \"nodePort\", \"loadBalancerIP\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Buildable(\n+    editableEnabled = false,\n+    builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@EqualsAndHashCode\n+public class GenericKafkaListenerConfigurationBroker implements Serializable, UnknownPropertyPreserving {\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer broker;\n+    private String advertisedHost;\n+    private Integer advertisedPort;\n+    private String host;\n+    private Map<String, String> dnsAnnotations = new HashMap<>(0);\n+    private Integer nodePort;\n+    private String loadBalancerIP;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"ID of the kafka broker (broker identifier). \" +\n+            \"Broker IDs start from 0 and correspond to the number of broker replicas.\")\n+    @JsonProperty(required = true)\n+    public Integer getBroker() {\n+        return broker;\n+    }\n+\n+    public void setBroker(Integer broker) {\n+        this.broker = broker;\n+    }\n+\n+    @Description(\"The host name which will be used in the brokers' `advertised.brokers`\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public String getAdvertisedHost() {\n+        return advertisedHost;\n+    }\n+\n+    public void setAdvertisedHost(String advertisedHost) {\n+        this.advertisedHost = advertisedHost;\n+    }\n+\n+    @Description(\"The port number which will be used in the brokers' `advertised.brokers`\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public Integer getAdvertisedPort() {\n+        return advertisedPort;\n+    }\n+\n+    public void setAdvertisedPort(Integer advertisedPort) {\n+        this.advertisedPort = advertisedPort;\n+    }\n+\n+\n+    @Description(\"The broker host. \" +\n+            \"This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. \" +\n+            \"This field can be used only with `route` (optional) or `ingress` (required) type listeners.\")\n+    @JsonProperty(required = true)\n+    public String getHost() {\n+        return host;\n+    }\n+\n+    public void setHost(String host) {\n+        this.host = host;\n+    }\n+\n+    @Description(\"Annotations that will be added to the `Ingress` or `Service` resource. \" +\n+            \"You can use this field to configure DNS providers such as External DNS. \" +\n+            \"This field can be used only with `loadbalancer`, `nodeport`, or `ingress` type listeners.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, String> getDnsAnnotations() {\n+        return dnsAnnotations;\n+    }\n+\n+    public void setDnsAnnotations(Map<String, String> dnsAnnotations) {\n+        this.dnsAnnotations = dnsAnnotations;\n+    }\n+\n+    @Description(\"Node port for the per-broker service. \" +\n+            \"This field can be used only with `nodeport` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public Integer getNodePort() {\n+        return nodePort;\n+    }\n+\n+    public void setNodePort(Integer nodePort) {\n+        this.nodePort = nodePort;\n+    }\n+\n+    @Description(\"The loadbalancer is requested with the IP address specified in this field. \" +\n+            \"This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. \" +\n+            \"This field is ignored if the cloud provider does not support the feature.\" +\n+            \"This field can be used only with `loadbalancer` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public String getLoadBalancerIP() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ4NjQwNw==", "bodyText": "Remove this, if it's not needed?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483486407", "createdAt": "2020-09-04T08:59:44Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaBrokerConfigurationBuilder.java", "diffHunk": "@@ -301,15 +226,15 @@ private void configureReplicationListener() {\n      *\n      * @return  String with advertised listener configuration\n      */\n-    private String getAdvertisedListener(String clusterName, String namespace, String listenerName, int port)    {\n+    /*private String getAdvertisedListener(String clusterName, String namespace, String listenerName, int port)    {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ4Njg2Nw==", "bodyText": "Import this type?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483486867", "createdAt": "2020-09-04T09:00:36Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -244,7 +225,7 @@\n \n     // Configuration defaults\n     private static final int DEFAULT_REPLICAS = 3;\n-    public static final Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder().withTimeoutSeconds(5)\n+    public static final io.strimzi.api.kafka.model.Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder().withTimeoutSeconds(5)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ4OTk0Ng==", "bodyText": "Better have helper methods on ListenerUtils which return whether there are any listeners of a given sort without having to allocate a List (that way you don't have to allocate a List only to test its emptiness).", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483489946", "createdAt": "2020-09-04T09:06:18Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -2099,7 +1770,7 @@ public boolean isExposedWithRoute() {\n      * @return true when the Kafka cluster is exposed using load balancer.\n      */\n     public boolean isExposedWithLoadBalancer() {\n-        return isExposed() && listeners.getExternal() instanceof KafkaListenerExternalLoadBalancer;\n+        return !ListenersUtils.loadBalancerListeners(listeners).isEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 1308}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5MTA2Mw==", "bodyText": "filter(...).findFirst().isPresent()", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483491063", "createdAt": "2020-09-04T09:08:27Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersUtils.java", "diffHunk": "@@ -0,0 +1,489 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationOAuth;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListener;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfigurationBroker;\n+import io.strimzi.api.kafka.model.listener.v2.KafkaListenerType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Util methods for working with Kafka listeners\n+ */\n+public class ListenersUtils {\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_PLAIN_PORT_NAME = \"tcp-clients\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_TLS_PORT_NAME = \"tcp-clientstls\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_EXTERNAL_PORT_NAME = \"tcp-external\";\n+\n+    /**\n+     * Finds out if any of the listeners has OAuth authentication enabled\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of used names\n+     */\n+    public static boolean hasListenerWithOAuth(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> listener.getAuth() != null && KafkaListenerAuthenticationOAuth.TYPE_OAUTH.equals(listener.getAuth().getType()))\n+                .map(listener -> true)\n+                .findFirst()\n+                .orElse(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5MTk1MQ==", "bodyText": "Factor out a private method which takes the desired KafkaListenerType as a param then each of these methods becomes a trivial return privateMethod(KafkaListenerType.XXX);", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483491951", "createdAt": "2020-09-04T09:10:00Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersUtils.java", "diffHunk": "@@ -0,0 +1,489 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationOAuth;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListener;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfigurationBroker;\n+import io.strimzi.api.kafka.model.listener.v2.KafkaListenerType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Util methods for working with Kafka listeners\n+ */\n+public class ListenersUtils {\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_PLAIN_PORT_NAME = \"tcp-clients\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_TLS_PORT_NAME = \"tcp-clientstls\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_EXTERNAL_PORT_NAME = \"tcp-external\";\n+\n+    /**\n+     * Finds out if any of the listeners has OAuth authentication enabled\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of used names\n+     */\n+    public static boolean hasListenerWithOAuth(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> listener.getAuth() != null && KafkaListenerAuthenticationOAuth.TYPE_OAUTH.equals(listener.getAuth().getType()))\n+                .map(listener -> true)\n+                .findFirst()\n+                .orElse(false);\n+    }\n+\n+    /**\n+     * Returns list of all internal listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of internal listeners\n+     */\n+    public static List<GenericKafkaListener> internalListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INTERNAL == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all external listeners (i.e. not internal)\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of external listeners\n+     */\n+    public static List<GenericKafkaListener> externalListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INTERNAL != listener.getType())\n+                .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5MjYwOA==", "bodyText": "This is just a single flatMap(listener -> listener.getConfiguration().getBootstrap().getAlternativeNames().stream() I think.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483492608", "createdAt": "2020-09-04T09:11:10Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersUtils.java", "diffHunk": "@@ -0,0 +1,489 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationOAuth;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListener;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfigurationBroker;\n+import io.strimzi.api.kafka.model.listener.v2.KafkaListenerType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Util methods for working with Kafka listeners\n+ */\n+public class ListenersUtils {\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_PLAIN_PORT_NAME = \"tcp-clients\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_TLS_PORT_NAME = \"tcp-clientstls\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_EXTERNAL_PORT_NAME = \"tcp-external\";\n+\n+    /**\n+     * Finds out if any of the listeners has OAuth authentication enabled\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of used names\n+     */\n+    public static boolean hasListenerWithOAuth(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> listener.getAuth() != null && KafkaListenerAuthenticationOAuth.TYPE_OAUTH.equals(listener.getAuth().getType()))\n+                .map(listener -> true)\n+                .findFirst()\n+                .orElse(false);\n+    }\n+\n+    /**\n+     * Returns list of all internal listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of internal listeners\n+     */\n+    public static List<GenericKafkaListener> internalListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INTERNAL == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all external listeners (i.e. not internal)\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of external listeners\n+     */\n+    public static List<GenericKafkaListener> externalListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INTERNAL != listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all Route type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of route listeners\n+     */\n+    public static List<GenericKafkaListener> routeListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.ROUTE == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all LoadBalancer type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of load balancer listeners\n+     */\n+    public static List<GenericKafkaListener> loadBalancerListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.LOADBALANCER == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all NodePort type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of node port listeners\n+     */\n+    public static List<GenericKafkaListener> nodePortListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.NODEPORT == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all Ingress type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of ingress listeners\n+     */\n+    public static List<GenericKafkaListener> ingressListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INGRESS == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all additional DNS addresses for certificates\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of external listeners\n+     */\n+    public static List<String> alternativeNames(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> listener.getConfiguration() != null\n+                        && listener.getConfiguration().getBootstrap() != null\n+                        && listener.getConfiguration().getBootstrap().getAlternativeNames() != null)\n+                .map(listener -> listener.getConfiguration().getBootstrap().getAlternativeNames())\n+                .flatMap(List::stream)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5MzIwMA==", "bodyText": "I wonder if this is the best name. Is it used as a suffix or prefix?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483493200", "createdAt": "2020-09-04T09:12:09Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersUtils.java", "diffHunk": "@@ -0,0 +1,489 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationOAuth;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListener;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfigurationBroker;\n+import io.strimzi.api.kafka.model.listener.v2.KafkaListenerType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Util methods for working with Kafka listeners\n+ */\n+public class ListenersUtils {\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_PLAIN_PORT_NAME = \"tcp-clients\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_TLS_PORT_NAME = \"tcp-clientstls\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_EXTERNAL_PORT_NAME = \"tcp-external\";\n+\n+    /**\n+     * Finds out if any of the listeners has OAuth authentication enabled\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of used names\n+     */\n+    public static boolean hasListenerWithOAuth(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> listener.getAuth() != null && KafkaListenerAuthenticationOAuth.TYPE_OAUTH.equals(listener.getAuth().getType()))\n+                .map(listener -> true)\n+                .findFirst()\n+                .orElse(false);\n+    }\n+\n+    /**\n+     * Returns list of all internal listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of internal listeners\n+     */\n+    public static List<GenericKafkaListener> internalListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INTERNAL == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all external listeners (i.e. not internal)\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of external listeners\n+     */\n+    public static List<GenericKafkaListener> externalListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INTERNAL != listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all Route type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of route listeners\n+     */\n+    public static List<GenericKafkaListener> routeListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.ROUTE == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all LoadBalancer type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of load balancer listeners\n+     */\n+    public static List<GenericKafkaListener> loadBalancerListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.LOADBALANCER == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all NodePort type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of node port listeners\n+     */\n+    public static List<GenericKafkaListener> nodePortListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.NODEPORT == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all Ingress type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of ingress listeners\n+     */\n+    public static List<GenericKafkaListener> ingressListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INGRESS == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all additional DNS addresses for certificates\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of external listeners\n+     */\n+    public static List<String> alternativeNames(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> listener.getConfiguration() != null\n+                        && listener.getConfiguration().getBootstrap() != null\n+                        && listener.getConfiguration().getBootstrap().getAlternativeNames() != null)\n+                .map(listener -> listener.getConfiguration().getBootstrap().getAlternativeNames())\n+                .flatMap(List::stream)\n+                .distinct()\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Generates a listener identifier which is used to name the related volumes, volume mounts, etc.\n+     *\n+     * @param listener  Listener for which the name should be generated\n+     * @return          Identifier string\n+     */\n+    public static String identifier(GenericKafkaListener listener) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5NDI1NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        errors.add(\"every listener needs to have unique name\");\n          \n          \n            \n                        errors.add(\"every listener needs to have a unique name\");", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483494255", "createdAt": "2020-09-04T09:14:03Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersValidator.java", "diffHunk": "@@ -0,0 +1,445 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationOAuth;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListener;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfiguration;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfigurationBroker;\n+import io.strimzi.api.kafka.model.listener.v2.KafkaListenerType;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * Util methods for validating Kafka listeners\n+ */\n+public class ListenersValidator {\n+    protected static final Logger LOG = LogManager.getLogger(ListenersValidator.class.getName());\n+    private final static Pattern LISTENER_NAME_PATTERN = Pattern.compile(GenericKafkaListener.LISTENER_NAME_REGEX);\n+    public final static List<Integer> FORBIDDEN_PORTS = unmodifiableList(Arrays.asList(9090, 9091, 9404, 9999));\n+\n+    /**\n+     * Validated the listener configuration. If the configuration is not valid, InvalidResourceException will be thrown.\n+     *\n+     * @param replicas   Number of replicas (required for Ingress validation)\n+     * @param listeners  Listeners which should be validated\n+     */\n+    public static void validate(int replicas, List<GenericKafkaListener> listeners) throws InvalidResourceException {\n+        Set<String> errors = validateAndGetErrorMessages(replicas, listeners);\n+\n+        if (!errors.isEmpty())  {\n+            LOG.error(\"Listener configuration is not valid: {}\", errors);\n+            throw new InvalidResourceException(\"Listener configuration is not valid: \" + errors);\n+        }\n+    }\n+\n+    /*test*/ static Set<String> validateAndGetErrorMessages(int replicas, List<GenericKafkaListener> listeners)    {\n+        Set<String> errors = new HashSet<>(0);\n+        List<Integer> ports = getPorts(listeners);\n+        List<String> names = getNames(listeners);\n+\n+        if (names.size() != listeners.size())   {\n+            errors.add(\"every listener needs to have unique name\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5NDM4OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        errors.add(\"every listener needs to have unique port number\");\n          \n          \n            \n                        errors.add(\"every listener needs to have a unique port number\");", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483494389", "createdAt": "2020-09-04T09:14:17Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersValidator.java", "diffHunk": "@@ -0,0 +1,445 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationOAuth;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListener;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfiguration;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfigurationBroker;\n+import io.strimzi.api.kafka.model.listener.v2.KafkaListenerType;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * Util methods for validating Kafka listeners\n+ */\n+public class ListenersValidator {\n+    protected static final Logger LOG = LogManager.getLogger(ListenersValidator.class.getName());\n+    private final static Pattern LISTENER_NAME_PATTERN = Pattern.compile(GenericKafkaListener.LISTENER_NAME_REGEX);\n+    public final static List<Integer> FORBIDDEN_PORTS = unmodifiableList(Arrays.asList(9090, 9091, 9404, 9999));\n+\n+    /**\n+     * Validated the listener configuration. If the configuration is not valid, InvalidResourceException will be thrown.\n+     *\n+     * @param replicas   Number of replicas (required for Ingress validation)\n+     * @param listeners  Listeners which should be validated\n+     */\n+    public static void validate(int replicas, List<GenericKafkaListener> listeners) throws InvalidResourceException {\n+        Set<String> errors = validateAndGetErrorMessages(replicas, listeners);\n+\n+        if (!errors.isEmpty())  {\n+            LOG.error(\"Listener configuration is not valid: {}\", errors);\n+            throw new InvalidResourceException(\"Listener configuration is not valid: \" + errors);\n+        }\n+    }\n+\n+    /*test*/ static Set<String> validateAndGetErrorMessages(int replicas, List<GenericKafkaListener> listeners)    {\n+        Set<String> errors = new HashSet<>(0);\n+        List<Integer> ports = getPorts(listeners);\n+        List<String> names = getNames(listeners);\n+\n+        if (names.size() != listeners.size())   {\n+            errors.add(\"every listener needs to have unique name\");\n+        }\n+\n+        List<String> invalidNames = names.stream().filter(name -> !LISTENER_NAME_PATTERN.matcher(name).matches()).collect(Collectors.toList());\n+        if (!invalidNames.isEmpty())    {\n+            errors.add(\"listener names \" + invalidNames + \" are invalid and do not match the pattern \" + GenericKafkaListener.LISTENER_NAME_REGEX);\n+        }\n+\n+        if (ports.size() != listeners.size())   {\n+            errors.add(\"every listener needs to have unique port number\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5NDgyNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            errors.add(\"listener \" + listener.getName() + \" is missing bootstrap host name which is required for Ingress based listeners\");\n          \n          \n            \n                            errors.add(\"listener \" + listener.getName() + \" is missing a bootstrap host name which is required for Ingress based listeners\");", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483494827", "createdAt": "2020-09-04T09:15:01Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersValidator.java", "diffHunk": "@@ -0,0 +1,445 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationOAuth;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListener;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfiguration;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfigurationBroker;\n+import io.strimzi.api.kafka.model.listener.v2.KafkaListenerType;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * Util methods for validating Kafka listeners\n+ */\n+public class ListenersValidator {\n+    protected static final Logger LOG = LogManager.getLogger(ListenersValidator.class.getName());\n+    private final static Pattern LISTENER_NAME_PATTERN = Pattern.compile(GenericKafkaListener.LISTENER_NAME_REGEX);\n+    public final static List<Integer> FORBIDDEN_PORTS = unmodifiableList(Arrays.asList(9090, 9091, 9404, 9999));\n+\n+    /**\n+     * Validated the listener configuration. If the configuration is not valid, InvalidResourceException will be thrown.\n+     *\n+     * @param replicas   Number of replicas (required for Ingress validation)\n+     * @param listeners  Listeners which should be validated\n+     */\n+    public static void validate(int replicas, List<GenericKafkaListener> listeners) throws InvalidResourceException {\n+        Set<String> errors = validateAndGetErrorMessages(replicas, listeners);\n+\n+        if (!errors.isEmpty())  {\n+            LOG.error(\"Listener configuration is not valid: {}\", errors);\n+            throw new InvalidResourceException(\"Listener configuration is not valid: \" + errors);\n+        }\n+    }\n+\n+    /*test*/ static Set<String> validateAndGetErrorMessages(int replicas, List<GenericKafkaListener> listeners)    {\n+        Set<String> errors = new HashSet<>(0);\n+        List<Integer> ports = getPorts(listeners);\n+        List<String> names = getNames(listeners);\n+\n+        if (names.size() != listeners.size())   {\n+            errors.add(\"every listener needs to have unique name\");\n+        }\n+\n+        List<String> invalidNames = names.stream().filter(name -> !LISTENER_NAME_PATTERN.matcher(name).matches()).collect(Collectors.toList());\n+        if (!invalidNames.isEmpty())    {\n+            errors.add(\"listener names \" + invalidNames + \" are invalid and do not match the pattern \" + GenericKafkaListener.LISTENER_NAME_REGEX);\n+        }\n+\n+        if (ports.size() != listeners.size())   {\n+            errors.add(\"every listener needs to have unique port number\");\n+        }\n+\n+        if (!Collections.disjoint(ports, FORBIDDEN_PORTS))    {\n+            errors.add(\"ports \" + FORBIDDEN_PORTS + \" are forbidden and cannot be used\");\n+        }\n+\n+        for (GenericKafkaListener listener : listeners) {\n+            validateRouteAndIngressTlsOnly(errors, listener);\n+            validateTlsFeaturesOnNonTlsListener(errors, listener);\n+            validateOauth(errors, listener);\n+\n+            if (listener.getConfiguration() != null)    {\n+                validateServiceDnsDomain(errors, listener);\n+                validateIngressClass(errors, listener);\n+                validateExternalTrafficPolicy(errors, listener);\n+                validateLoadBalancerSourceRanges(errors, listener);\n+                validatePreferredAddressType(errors, listener);\n+\n+                if (listener.getConfiguration().getBootstrap() != null) {\n+                    validateBootstrapHost(errors, listener);\n+                    validateBootstrapLoadBalancerIp(errors, listener);\n+                    validateBootstrapNodePort(errors, listener);\n+                    validateBootstrapDnsAnnotations(errors, listener);\n+                }\n+\n+                if (listener.getConfiguration().getBrokers() != null) {\n+                    for (GenericKafkaListenerConfigurationBroker broker : listener.getConfiguration().getBrokers()) {\n+                        validateBrokerHost(errors, listener, broker);\n+                        validateBrokerLoadBalancerIp(errors, listener, broker);\n+                        validateBrokerNodePort(errors, listener, broker);\n+                        validateBrokerDnsAnnotations(errors, listener, broker);\n+                    }\n+                }\n+            }\n+\n+            if (KafkaListenerType.INGRESS.equals(listener.getType()))    {\n+                validateIngress(errors, replicas, listener);\n+            }\n+        }\n+\n+        return errors;\n+    }\n+\n+    /**\n+     * Validates that Ingress type listener has the right host configurations\n+     *\n+     * @param errors    List where any found errors will be added\n+     * @param replicas  Number of Kafka replicas\n+     * @param listener  Listener which needs to be validated\n+     */\n+    private static void validateIngress(Set<String> errors, int replicas, GenericKafkaListener listener) {\n+        if (listener.getConfiguration() != null)    {\n+            GenericKafkaListenerConfiguration conf = listener.getConfiguration();\n+\n+            if (conf.getBootstrap() == null\n+                    || conf.getBootstrap().getHost() == null)   {\n+                errors.add(\"listener \" + listener.getName() + \" is missing bootstrap host name which is required for Ingress based listeners\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5NDkyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    errors.add(\"listener \" + listener.getName() + \" is missing broker host name for broker with ID \" + i + \" which is required for Ingress based listeners\");\n          \n          \n            \n                                    errors.add(\"listener \" + listener.getName() + \" is missing a broker host name for broker with ID \" + i + \" which is required for Ingress based listeners\");", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483494923", "createdAt": "2020-09-04T09:15:13Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersValidator.java", "diffHunk": "@@ -0,0 +1,445 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationOAuth;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListener;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfiguration;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfigurationBroker;\n+import io.strimzi.api.kafka.model.listener.v2.KafkaListenerType;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * Util methods for validating Kafka listeners\n+ */\n+public class ListenersValidator {\n+    protected static final Logger LOG = LogManager.getLogger(ListenersValidator.class.getName());\n+    private final static Pattern LISTENER_NAME_PATTERN = Pattern.compile(GenericKafkaListener.LISTENER_NAME_REGEX);\n+    public final static List<Integer> FORBIDDEN_PORTS = unmodifiableList(Arrays.asList(9090, 9091, 9404, 9999));\n+\n+    /**\n+     * Validated the listener configuration. If the configuration is not valid, InvalidResourceException will be thrown.\n+     *\n+     * @param replicas   Number of replicas (required for Ingress validation)\n+     * @param listeners  Listeners which should be validated\n+     */\n+    public static void validate(int replicas, List<GenericKafkaListener> listeners) throws InvalidResourceException {\n+        Set<String> errors = validateAndGetErrorMessages(replicas, listeners);\n+\n+        if (!errors.isEmpty())  {\n+            LOG.error(\"Listener configuration is not valid: {}\", errors);\n+            throw new InvalidResourceException(\"Listener configuration is not valid: \" + errors);\n+        }\n+    }\n+\n+    /*test*/ static Set<String> validateAndGetErrorMessages(int replicas, List<GenericKafkaListener> listeners)    {\n+        Set<String> errors = new HashSet<>(0);\n+        List<Integer> ports = getPorts(listeners);\n+        List<String> names = getNames(listeners);\n+\n+        if (names.size() != listeners.size())   {\n+            errors.add(\"every listener needs to have unique name\");\n+        }\n+\n+        List<String> invalidNames = names.stream().filter(name -> !LISTENER_NAME_PATTERN.matcher(name).matches()).collect(Collectors.toList());\n+        if (!invalidNames.isEmpty())    {\n+            errors.add(\"listener names \" + invalidNames + \" are invalid and do not match the pattern \" + GenericKafkaListener.LISTENER_NAME_REGEX);\n+        }\n+\n+        if (ports.size() != listeners.size())   {\n+            errors.add(\"every listener needs to have unique port number\");\n+        }\n+\n+        if (!Collections.disjoint(ports, FORBIDDEN_PORTS))    {\n+            errors.add(\"ports \" + FORBIDDEN_PORTS + \" are forbidden and cannot be used\");\n+        }\n+\n+        for (GenericKafkaListener listener : listeners) {\n+            validateRouteAndIngressTlsOnly(errors, listener);\n+            validateTlsFeaturesOnNonTlsListener(errors, listener);\n+            validateOauth(errors, listener);\n+\n+            if (listener.getConfiguration() != null)    {\n+                validateServiceDnsDomain(errors, listener);\n+                validateIngressClass(errors, listener);\n+                validateExternalTrafficPolicy(errors, listener);\n+                validateLoadBalancerSourceRanges(errors, listener);\n+                validatePreferredAddressType(errors, listener);\n+\n+                if (listener.getConfiguration().getBootstrap() != null) {\n+                    validateBootstrapHost(errors, listener);\n+                    validateBootstrapLoadBalancerIp(errors, listener);\n+                    validateBootstrapNodePort(errors, listener);\n+                    validateBootstrapDnsAnnotations(errors, listener);\n+                }\n+\n+                if (listener.getConfiguration().getBrokers() != null) {\n+                    for (GenericKafkaListenerConfigurationBroker broker : listener.getConfiguration().getBrokers()) {\n+                        validateBrokerHost(errors, listener, broker);\n+                        validateBrokerLoadBalancerIp(errors, listener, broker);\n+                        validateBrokerNodePort(errors, listener, broker);\n+                        validateBrokerDnsAnnotations(errors, listener, broker);\n+                    }\n+                }\n+            }\n+\n+            if (KafkaListenerType.INGRESS.equals(listener.getType()))    {\n+                validateIngress(errors, replicas, listener);\n+            }\n+        }\n+\n+        return errors;\n+    }\n+\n+    /**\n+     * Validates that Ingress type listener has the right host configurations\n+     *\n+     * @param errors    List where any found errors will be added\n+     * @param replicas  Number of Kafka replicas\n+     * @param listener  Listener which needs to be validated\n+     */\n+    private static void validateIngress(Set<String> errors, int replicas, GenericKafkaListener listener) {\n+        if (listener.getConfiguration() != null)    {\n+            GenericKafkaListenerConfiguration conf = listener.getConfiguration();\n+\n+            if (conf.getBootstrap() == null\n+                    || conf.getBootstrap().getHost() == null)   {\n+                errors.add(\"listener \" + listener.getName() + \" is missing bootstrap host name which is required for Ingress based listeners\");\n+            }\n+\n+            if (conf.getBrokers() != null) {\n+                for (int i = 0; i < replicas; i++)  {\n+                    final int id = i;\n+                    GenericKafkaListenerConfigurationBroker broker = conf.getBrokers().stream().filter(b -> b.getBroker() == id).findFirst().orElse(null);\n+\n+                    if (broker == null || broker.getHost() == null) {\n+                        errors.add(\"listener \" + listener.getName() + \" is missing broker host name for broker with ID \" + i + \" which is required for Ingress based listeners\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5NzIwMw==", "bodyText": "What changed here?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483497203", "createdAt": "2020-09-04T09:19:30Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorCustomCertTest.java", "diffHunk": "@@ -196,7 +204,7 @@ public Secret getTlsSecret() {\n     }\n \n     public String getTlsThumbprint()    {\n-        return \"vjPd/D/f0/X3yqitf65yoUZbyeWnQU4cPDJGbr7GA7I=\";\n+        return \"{external=COWn2zWLZMhoewfrmSTfUeKlQPifBKekyXzjm2iGTuc=, tls=vjPd/D/f0/X3yqitf65yoUZbyeWnQU4cPDJGbr7GA7I=}\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 69}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ffc8c7fce5dde1e90a98534967921ee54ff2c5f7", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/ffc8c7fce5dde1e90a98534967921ee54ff2c5f7", "committedDate": "2020-09-04T14:49:47Z", "message": "Fix some STs\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}, "afterCommit": {"oid": "02b4b0cd190068bdfd29d31e00765bf525e9bbba", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/02b4b0cd190068bdfd29d31e00765bf525e9bbba", "committedDate": "2020-09-04T17:49:47Z", "message": "Fix some STs\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzMDUyNzc2", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#pullrequestreview-483052776", "createdAt": "2020-09-05T12:37:23Z", "commit": {"oid": "b3d87555da1388d32cc4b41581b73a8a58fd7b4c"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQxMjozNzoyNFrOHNhy-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQxMjo1NzozNlrOHNh5Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk0NzI1Nw==", "bodyText": "Agree with @samuel-hawker I find the if/else harder too read when they are too nested. Of course, it is fine when there is no other solution but in this case Sam is proposing a good one.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483947257", "createdAt": "2020-09-05T12:37:24Z", "author": {"login": "ppatierno"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final List<GenericKafkaListener> listValue;\n+    private final KafkaListeners objectValue;\n+\n+    public ArrayOrObjectKafkaListeners(List<GenericKafkaListener> listValue)   {\n+        this.listValue = listValue;\n+        this.objectValue = null;\n+    }\n+\n+    public ArrayOrObjectKafkaListeners(KafkaListeners objectValue)   {\n+        this.listValue = null;\n+        this.objectValue = objectValue;\n+    }\n+\n+    @Alternative()\n+    public List<GenericKafkaListener> getListValue() {\n+        return listValue;\n+    }\n+\n+    @Alternative()\n+    public KafkaListeners getObjectValue() {\n+        return objectValue;\n+    }\n+\n+    /**\n+     * Convenience method which returns either the new listener format if set, or converted old format.\n+     *\n+     * @return  List of new listeners\n+     */\n+    public List<GenericKafkaListener> newOrConverted()  {\n+        if (listValue != null)  {\n+            return listValue;\n+        } else {\n+            return ListenersConvertor.convertToNewFormat(objectValue);\n+        }\n+    }\n+\n+    public static class Serializer extends JsonSerializer<ArrayOrObjectKafkaListeners> {\n+        @Override\n+        public void serialize(ArrayOrObjectKafkaListeners value, JsonGenerator generator, SerializerProvider provider) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2OTE1MA=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk0ODg1OQ==", "bodyText": "There is already listenersByType but it is not applicable here because we need any other listener which is NOT internal. Maybe the method could be factored out having a predicate on type as parameter and not a specific type itself.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483948859", "createdAt": "2020-09-05T12:57:36Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersUtils.java", "diffHunk": "@@ -0,0 +1,489 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationOAuth;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListener;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfigurationBroker;\n+import io.strimzi.api.kafka.model.listener.v2.KafkaListenerType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Util methods for working with Kafka listeners\n+ */\n+public class ListenersUtils {\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_PLAIN_PORT_NAME = \"tcp-clients\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_TLS_PORT_NAME = \"tcp-clientstls\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_EXTERNAL_PORT_NAME = \"tcp-external\";\n+\n+    /**\n+     * Finds out if any of the listeners has OAuth authentication enabled\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of used names\n+     */\n+    public static boolean hasListenerWithOAuth(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> listener.getAuth() != null && KafkaListenerAuthenticationOAuth.TYPE_OAUTH.equals(listener.getAuth().getType()))\n+                .map(listener -> true)\n+                .findFirst()\n+                .orElse(false);\n+    }\n+\n+    /**\n+     * Returns list of all internal listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of internal listeners\n+     */\n+    public static List<GenericKafkaListener> internalListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INTERNAL == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all external listeners (i.e. not internal)\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of external listeners\n+     */\n+    public static List<GenericKafkaListener> externalListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INTERNAL != listener.getType())\n+                .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5MTk1MQ=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNTMxODg4", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#pullrequestreview-483531888", "createdAt": "2020-09-07T12:51:16Z", "commit": {"oid": "b65396d690a4a1feb55b13c42bafce9328043b23"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMjo1MToxNlrOHN-RLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMjo1MToxNlrOHN-RLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQxMzc0MQ==", "bodyText": "I think the v2 in the package name might become confusing in the future if we ended up with a v1 and v2 API version in the CR and that got reflected in the package naming. Is there any benefit to putting this in a new package?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r484413741", "createdAt": "2020-09-07T12:51:16Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b65396d690a4a1feb55b13c42bafce9328043b23"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57f0166dc3eac76415949ee4a0cce68ea8fe0ace", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/57f0166dc3eac76415949ee4a0cce68ea8fe0ace", "committedDate": "2020-09-07T17:00:30Z", "message": "Refactor listeners to allow full array of listeners\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da2892a3715a504f5e02ac78e4bf47d9ff54698d", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/da2892a3715a504f5e02ac78e4bf47d9ff54698d", "committedDate": "2020-09-07T17:00:30Z", "message": "Review comments\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07c26c22c777c0fd0f98e41caca1495984704b86", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/07c26c22c777c0fd0f98e41caca1495984704b86", "committedDate": "2020-09-07T17:00:30Z", "message": "Fix some STs\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb9dd45702fc1421c8a358049e7d475e3dc67b7a", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/eb9dd45702fc1421c8a358049e7d475e3dc67b7a", "committedDate": "2020-09-07T17:00:30Z", "message": "Fix another system test\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "981c2ba3cbb6e77cf92dc5c596b9f23479a17b49", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/981c2ba3cbb6e77cf92dc5c596b9f23479a17b49", "committedDate": "2020-09-07T17:00:30Z", "message": "Review comments and ST fixes\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6dc12329ea533318a58fdf7246621b3596b22be6", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/6dc12329ea533318a58fdf7246621b3596b22be6", "committedDate": "2020-09-07T17:00:30Z", "message": "Another bunch of fixes\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8b596e419df0eb155fe7b828c820f3995e17666", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/a8b596e419df0eb155fe7b828c820f3995e17666", "committedDate": "2020-09-07T17:00:30Z", "message": "Fix the stupid renaming\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9044ef073de8ec976cad623e46cfbd9c71d77db6", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/9044ef073de8ec976cad623e46cfbd9c71d77db6", "committedDate": "2020-09-07T17:01:29Z", "message": "More unit tests and CHANGELOG\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b3f5a0807c2aee5b4a0182793f56bfb2d055cc9", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/8b3f5a0807c2aee5b4a0182793f56bfb2d055cc9", "committedDate": "2020-09-07T17:01:29Z", "message": "Fix load balancer source range test\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "013091515b3eb6090e06b9cdd10994862c72ce90", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/013091515b3eb6090e06b9cdd10994862c72ce90", "committedDate": "2020-09-07T17:01:29Z", "message": "MAke sure serialization works and write backwards compatibility STs\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8ba7aca5e4848a39b87852dff3d95e0af1ca738", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/d8ba7aca5e4848a39b87852dff3d95e0af1ca738", "committedDate": "2020-09-07T17:01:29Z", "message": "Increase regression test pipeline timout and fix OCP system test\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "931b8a794d59c214d0dc8f843ec9e4ff19706e45", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/931b8a794d59c214d0dc8f843ec9e4ff19706e45", "committedDate": "2020-09-07T17:01:29Z", "message": "Fix typo\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6065556ddc50ab435ac7d581afc7b57292ec37e", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c6065556ddc50ab435ac7d581afc7b57292ec37e", "committedDate": "2020-09-07T17:01:29Z", "message": "Review comments\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "72501092a9055f4fd8934b6f458549c321d98052", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/72501092a9055f4fd8934b6f458549c321d98052", "committedDate": "2020-09-07T13:58:23Z", "message": "Fix typo\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}, "afterCommit": {"oid": "c6065556ddc50ab435ac7d581afc7b57292ec37e", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c6065556ddc50ab435ac7d581afc7b57292ec37e", "committedDate": "2020-09-07T17:01:29Z", "message": "Review comments\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNjgwODQz", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#pullrequestreview-483680843", "createdAt": "2020-09-07T18:04:05Z", "commit": {"oid": "c6065556ddc50ab435ac7d581afc7b57292ec37e"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxODowNDowNVrOHOFySw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxODowNDowNVrOHOFySw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUzNjkwNw==", "bodyText": "Are you sure this is working? I thought the hard timeout for each job is set to 6 hours by Azure itself.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r484536907", "createdAt": "2020-09-07T18:04:05Z", "author": {"login": "Frawless"}, "path": ".azure/regression-pipeline.yaml", "diffHunk": "@@ -16,7 +16,7 @@ jobs:\n       test_case: 'kafka.*ST,mirrormaker.*ST'\n       groups: 'regression'\n       cluster_operator_install_type: 'bundle'\n-      timeout: 360", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6065556ddc50ab435ac7d581afc7b57292ec37e"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNjk0NTUw", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#pullrequestreview-483694550", "createdAt": "2020-09-07T19:25:00Z", "commit": {"oid": "c6065556ddc50ab435ac7d581afc7b57292ec37e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNzA3NDQy", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#pullrequestreview-483707442", "createdAt": "2020-09-07T20:52:38Z", "commit": {"oid": "c6065556ddc50ab435ac7d581afc7b57292ec37e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QyMDo1MjozOFrOHOHfPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QyMDo1MjozOFrOHOHfPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU2NDc5Ng==", "bodyText": "just a typo :)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                type: loadlablancer\n          \n          \n            \n                type: loadbalancer", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r484564796", "createdAt": "2020-09-07T20:52:38Z", "author": {"login": "see-quick"}, "path": "CHANGELOG.md", "diffHunk": "@@ -19,9 +18,77 @@\n   * Fixed bug on maximum reconcile time graph\n   * Removed the avarage reconsile time graph\n   * Rearranged graphs\n+* Make `listeners` configurable as an array and add support for more different listeners in single cluster \n \n ### Deprecations and removals\n \n+#### Redesign of the `.spec.kafka.listeners` section\n+\n+The `.spec.kafka.listeners` section of the Kafka CRD has been redesigned to allow configuring more different listeners.\n+The old `listeners` object which allowed only configuration of one`plain`, one `tls`, and one `external` listener is now deprecated and will be removed in the future.\n+It is replaced with an array allowing configuration of multiple different listeners:\n+\n+```yaml\n+listeners:\n+  - name: local\n+    port: 9092\n+    type: internal\n+    tls: true\n+  - name: external1\n+    port: 9093\n+    type: loadbalancer\n+    tls: true\n+  - name: external2\n+    port: 9094\n+    type: nodeport\n+    tls: true\n+```\n+\n+This change includes some other changes:\n+* The `tls` field is now required.\n+* The former `overrides` section is now merged with the `configuration` section.\n+* The `dnsAnnotations` field has been renamed to `annotations` since we found out it has wider use.\n+* Configuration of `loadBalancerSourceRanges` and `externalTrafficPolicy` has been moved into listener configuration. Its use in the `template` section is now deprecated.\n+* For `type: internal` listeners, you can now use the flag `useServiceDnsDomain` to define whether they should use the fully qualified DNS names including the cluster service suffix (usually `.cluster.local`). This option defaults to false.\n+* All listeners now support configuring the advertised hostname and port.\n+* `preferredAddressType` has been removed to `preferredNodePortAddressType`.\n+\n+To convert the old format into the new format with backwards compatibility, you should use following names and types:\n+* For the old `plain` listener, use the name `plain`, port `9092` and type `internal`.\n+* For the old `tls` listener, use the name `tls`, port `9093` and type `internal`.\n+* For the old `external` listener, use the name `external`, port `9094`.\n+\n+For example the following old configuration:\n+\n+```yaml\n+listeners:\n+  plain:\n+    # ...\n+  tls: \n+    # ...\n+  external:\n+    type: loadbalancer \n+    # ...\n+```\n+\n+Will look like this in the new format:\n+\n+```yaml\n+listeners:\n+  - name: plain\n+    port: 9092\n+    type: internal\n+    tls: false\n+  - name: tls\n+    port: 9093\n+    type: internal\n+    tls: true\n+  - name: external\n+    port: 9094\n+    type: loadlablancer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6065556ddc50ab435ac7d581afc7b57292ec37e"}, "originalPosition": 76}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6aa3b45804283f21ee2f63f5d644de5eea55d31", "author": {"user": {"login": "scholzj", "name": "Jakub Scholz"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e6aa3b45804283f21ee2f63f5d644de5eea55d31", "committedDate": "2020-09-07T20:55:11Z", "message": "Fix CHANGELOG typo and split Azure regression builds into 5 jobs\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNzA3ODE1", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#pullrequestreview-483707815", "createdAt": "2020-09-07T20:55:22Z", "commit": {"oid": "c6065556ddc50ab435ac7d581afc7b57292ec37e"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QyMDo1NToyMlrOHOHg3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QyMDo1NToyMlrOHOHg3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU2NTIxNA==", "bodyText": "Why do you using new ArrayList<>(0); here? I assume it is for memory costs but would it be better to use at least 2 or something like that? Just a question.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r484565214", "createdAt": "2020-09-07T20:55:22Z", "author": {"login": "see-quick"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/arraylistener/GenericKafkaListenerConfiguration.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.arraylistener;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.CertAndKeySecretSource;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Collections.emptyMap;\n+\n+/**\n+ * Configures Kafka listeners\n+ */\n+@JsonPropertyOrder({\"brokerCertChainAndKey\", \"ingressClass\", \"preferredAddressType\", \"externalTrafficPolicy\", \"loadBalancerSourceRanges\", \"bootstrap\", \"brokers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Buildable(\n+    editableEnabled = false,\n+    builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@EqualsAndHashCode\n+public class GenericKafkaListenerConfiguration implements Serializable, UnknownPropertyPreserving {\n+    private static final long serialVersionUID = 1L;\n+\n+    private CertAndKeySecretSource brokerCertChainAndKey;\n+    private String ingressClass;\n+    private NodeAddressType preferredNodePortAddressType;\n+    private ExternalTrafficPolicy externalTrafficPolicy;\n+    private List<String> loadBalancerSourceRanges = new ArrayList<>(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6065556ddc50ab435ac7d581afc7b57292ec37e"}, "originalPosition": 44}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 942, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}