{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0ODU2MjE2", "number": 3200, "reviewThreads": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDowNzowOFrOEKHUdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMToxMzowOFrOEZbQmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDQxMTQzOnYy", "diffSide": "RIGHT", "path": "systemtest/src/main/java/io/strimzi/systemtest/resources/KubernetesResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDowNzowOFrOGq-Gqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDowNzowOFrOGq-Gqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcxMDg5MA==", "bodyText": "indentation", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r447710890", "createdAt": "2020-06-30T14:07:08Z", "author": {"login": "ppatierno"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/resources/KubernetesResource.java", "diffHunk": "@@ -255,6 +263,42 @@ public static DoneableClusterRoleBinding clusterRoleBinding(ClusterRoleBinding c\n         return kCRBList;\n     }\n \n+    private static Ingress getSystemTestIngressResource(String serviceName, int port) {\n+        IngressBackend backend = new IngressBackend();\n+        backend.setServiceName(serviceName);\n+        backend.setServicePort(new IntOrString(port));\n+\n+        HTTPIngressPath path = new HTTPIngressPath();\n+        path.setPath(\"/\");\n+        path.setBackend(backend);\n+\n+        return new IngressBuilder()\n+            .withNewMetadata()\n+            .withName(serviceName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da430c28cd7f303033b94f4ffc7976627482af5f"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDQzNDUyOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeCors.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDoxMTo1OVrOGq-VQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDozMjowNFrOGq_TGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcxNDYyNw==", "bodyText": "why the choice of makingthe host an explicit parameter while hiding the port (80) inside the method?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r447714627", "createdAt": "2020-06-30T14:11:59Z", "author": {"login": "ppatierno"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeCors.java", "diffHunk": "@@ -59,7 +53,7 @@ void testCorsOriginAllowed(VertxTestContext context) {\n         JsonObject topics = new JsonObject();\n         topics.put(\"topics\", topic);\n \n-        client.request(HttpMethod.OPTIONS, bridgePort, bridgeHost, \"/consumers/\" + groupId + \"/instances/\" + kafkaBridgeUser + \"/subscription\")\n+        client.request(HttpMethod.OPTIONS, bridgeHost, \"/consumers/\" + groupId + \"/instances/\" + kafkaBridgeUser + \"/subscription\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da430c28cd7f303033b94f4ffc7976627482af5f"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczMDQ1Ng==", "bodyText": "Yeah sorry, I leave that after some try, removed :)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r447730456", "createdAt": "2020-06-30T14:32:04Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeCors.java", "diffHunk": "@@ -59,7 +53,7 @@ void testCorsOriginAllowed(VertxTestContext context) {\n         JsonObject topics = new JsonObject();\n         topics.put(\"topics\", topic);\n \n-        client.request(HttpMethod.OPTIONS, bridgePort, bridgeHost, \"/consumers/\" + groupId + \"/instances/\" + kafkaBridgeUser + \"/subscription\")\n+        client.request(HttpMethod.OPTIONS, bridgeHost, \"/consumers/\" + groupId + \"/instances/\" + kafkaBridgeUser + \"/subscription\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcxNDYyNw=="}, "originalCommit": {"oid": "da430c28cd7f303033b94f4ffc7976627482af5f"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDYzODMxOnYy", "diffSide": "RIGHT", "path": "systemtest/src/main/java/io/strimzi/systemtest/resources/KubernetesResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDo1Mjo0MFrOGrAShQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDo1Mjo0MFrOGrAShQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc0NjY5Mw==", "bodyText": "ingress as. a method name would probably suffice, since it is in the system tests, writing system test is redundant.\nSimilarly we are creating a resource and the return type suggests that.\nMight be worth adding a doc comment explaining a few of the config options if they're not clear why they are the way they are.\nI would suggest it be called createIngress but that clashes with the function with the name below.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r447746693", "createdAt": "2020-06-30T14:52:40Z", "author": {"login": "samuel-hawker"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/resources/KubernetesResource.java", "diffHunk": "@@ -255,6 +263,42 @@ public static DoneableClusterRoleBinding clusterRoleBinding(ClusterRoleBinding c\n         return kCRBList;\n     }\n \n+    private static Ingress getSystemTestIngressResource(String serviceName, int port) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "583a9dca77079f36310b69fa9998bdf5b33334f0"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDY0MTgwOnYy", "diffSide": "RIGHT", "path": "systemtest/src/main/java/io/strimzi/systemtest/resources/KubernetesResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDo1MzoxOVrOGrAUtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDo1MzoxOVrOGrAUtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc0NzI1NQ==", "bodyText": "Needs indenting", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r447747255", "createdAt": "2020-06-30T14:53:19Z", "author": {"login": "samuel-hawker"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/resources/KubernetesResource.java", "diffHunk": "@@ -255,6 +263,42 @@ public static DoneableClusterRoleBinding clusterRoleBinding(ClusterRoleBinding c\n         return kCRBList;\n     }\n \n+    private static Ingress getSystemTestIngressResource(String serviceName, int port) {\n+        IngressBackend backend = new IngressBackend();\n+        backend.setServiceName(serviceName);\n+        backend.setServicePort(new IntOrString(port));\n+\n+        HTTPIngressPath path = new HTTPIngressPath();\n+        path.setPath(\"/\");\n+        path.setBackend(backend);\n+\n+        return new IngressBuilder()\n+            .withNewMetadata()\n+                .withName(serviceName)\n+            .endMetadata()\n+            .withNewSpec()\n+            .withRules(new IngressRuleBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "583a9dca77079f36310b69fa9998bdf5b33334f0"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDY3MTgzOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeExternalListenersST.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDo1OToxNVrOGrAnZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo0MjoyNlrOGrCl0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc1MjAzOQ==", "bodyText": "testScramShaAuthWithWeirdUsername\nMight be worth testing this with several other names, or perhaps having the name containing more potentially problematic characters?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r447752039", "createdAt": "2020-06-30T14:59:15Z", "author": {"login": "samuel-hawker"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeExternalListenersST.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.bridge;\n+\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.strimzi.api.kafka.model.CertSecretSource;\n+import io.strimzi.api.kafka.model.KafkaBridgeSpec;\n+import io.strimzi.api.kafka.model.KafkaBridgeSpecBuilder;\n+import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.api.kafka.model.PasswordSecretSource;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationScramSha512;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n+import io.strimzi.systemtest.Constants;\n+import io.strimzi.systemtest.kafkaclients.externalClients.BasicExternalKafkaClient;\n+import io.strimzi.systemtest.resources.KubernetesResource;\n+import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n+import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n+import io.strimzi.systemtest.utils.kafkaUtils.KafkaBridgeUtils;\n+import io.strimzi.systemtest.utils.specific.BridgeUtils;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.common.security.auth.SecurityProtocol;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import static io.strimzi.systemtest.Constants.EXTERNAL_CLIENTS_USED;\n+import static io.strimzi.systemtest.Constants.NODEPORT_SUPPORTED;\n+import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+@Tag(NODEPORT_SUPPORTED)\n+@Tag(EXTERNAL_CLIENTS_USED)\n+class HttpBridgeExternalListenersST extends HttpBridgeBaseST {\n+    private static final String BRIDGE_EXTERNAL_SERVICE = CLUSTER_NAME + \"-bridge-external-service\";\n+\n+    @Test\n+    void testScramShaAuthWithWeirdNamedUser() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "583a9dca77079f36310b69fa9998bdf5b33334f0"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc1NjEyOQ==", "bodyText": "Which problematic characters do you mean? Like *+/ etc? I don't know if we didn't discussed that with @scholzj, but I can try it :)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r447756129", "createdAt": "2020-06-30T15:04:29Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeExternalListenersST.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.bridge;\n+\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.strimzi.api.kafka.model.CertSecretSource;\n+import io.strimzi.api.kafka.model.KafkaBridgeSpec;\n+import io.strimzi.api.kafka.model.KafkaBridgeSpecBuilder;\n+import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.api.kafka.model.PasswordSecretSource;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationScramSha512;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n+import io.strimzi.systemtest.Constants;\n+import io.strimzi.systemtest.kafkaclients.externalClients.BasicExternalKafkaClient;\n+import io.strimzi.systemtest.resources.KubernetesResource;\n+import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n+import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n+import io.strimzi.systemtest.utils.kafkaUtils.KafkaBridgeUtils;\n+import io.strimzi.systemtest.utils.specific.BridgeUtils;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.common.security.auth.SecurityProtocol;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import static io.strimzi.systemtest.Constants.EXTERNAL_CLIENTS_USED;\n+import static io.strimzi.systemtest.Constants.NODEPORT_SUPPORTED;\n+import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+@Tag(NODEPORT_SUPPORTED)\n+@Tag(EXTERNAL_CLIENTS_USED)\n+class HttpBridgeExternalListenersST extends HttpBridgeBaseST {\n+    private static final String BRIDGE_EXTERNAL_SERVICE = CLUSTER_NAME + \"-bridge-external-service\";\n+\n+    @Test\n+    void testScramShaAuthWithWeirdNamedUser() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc1MjAzOQ=="}, "originalCommit": {"oid": "583a9dca77079f36310b69fa9998bdf5b33334f0"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4NDQwMQ==", "bodyText": "I tried some options and it's not working with these special characters, how I said, I think that we had conversation about the naming with @scholzj when we made the tests, so I think we could leave it like this.\nDo you agree @Frawless, @samuel-hawker, @scholzj?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r447784401", "createdAt": "2020-06-30T15:42:26Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeExternalListenersST.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.bridge;\n+\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.strimzi.api.kafka.model.CertSecretSource;\n+import io.strimzi.api.kafka.model.KafkaBridgeSpec;\n+import io.strimzi.api.kafka.model.KafkaBridgeSpecBuilder;\n+import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.api.kafka.model.PasswordSecretSource;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationScramSha512;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n+import io.strimzi.systemtest.Constants;\n+import io.strimzi.systemtest.kafkaclients.externalClients.BasicExternalKafkaClient;\n+import io.strimzi.systemtest.resources.KubernetesResource;\n+import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n+import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n+import io.strimzi.systemtest.utils.kafkaUtils.KafkaBridgeUtils;\n+import io.strimzi.systemtest.utils.specific.BridgeUtils;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.common.security.auth.SecurityProtocol;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import static io.strimzi.systemtest.Constants.EXTERNAL_CLIENTS_USED;\n+import static io.strimzi.systemtest.Constants.NODEPORT_SUPPORTED;\n+import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+@Tag(NODEPORT_SUPPORTED)\n+@Tag(EXTERNAL_CLIENTS_USED)\n+class HttpBridgeExternalListenersST extends HttpBridgeBaseST {\n+    private static final String BRIDGE_EXTERNAL_SERVICE = CLUSTER_NAME + \"-bridge-external-service\";\n+\n+    @Test\n+    void testScramShaAuthWithWeirdNamedUser() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc1MjAzOQ=="}, "originalCommit": {"oid": "583a9dca77079f36310b69fa9998bdf5b33334f0"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDY3MjcyOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeExternalListenersST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDo1OToyNFrOGrAn6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDo1OToyNFrOGrAn6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc1MjE3MQ==", "bodyText": "ditto naming", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r447752171", "createdAt": "2020-06-30T14:59:24Z", "author": {"login": "samuel-hawker"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeExternalListenersST.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.bridge;\n+\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.strimzi.api.kafka.model.CertSecretSource;\n+import io.strimzi.api.kafka.model.KafkaBridgeSpec;\n+import io.strimzi.api.kafka.model.KafkaBridgeSpecBuilder;\n+import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.api.kafka.model.PasswordSecretSource;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationScramSha512;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n+import io.strimzi.systemtest.Constants;\n+import io.strimzi.systemtest.kafkaclients.externalClients.BasicExternalKafkaClient;\n+import io.strimzi.systemtest.resources.KubernetesResource;\n+import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n+import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n+import io.strimzi.systemtest.utils.kafkaUtils.KafkaBridgeUtils;\n+import io.strimzi.systemtest.utils.specific.BridgeUtils;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.common.security.auth.SecurityProtocol;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import static io.strimzi.systemtest.Constants.EXTERNAL_CLIENTS_USED;\n+import static io.strimzi.systemtest.Constants.NODEPORT_SUPPORTED;\n+import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+@Tag(NODEPORT_SUPPORTED)\n+@Tag(EXTERNAL_CLIENTS_USED)\n+class HttpBridgeExternalListenersST extends HttpBridgeBaseST {\n+    private static final String BRIDGE_EXTERNAL_SERVICE = CLUSTER_NAME + \"-bridge-external-service\";\n+\n+    @Test\n+    void testScramShaAuthWithWeirdNamedUser() throws Exception {\n+        // Create weird named user with . and more than 64 chars -> SCRAM-SHA\n+        String weirdUserName = \"jjglmahyijoambryleyxjjglmahy.ijoambryleyxjjglmahyijoambryleyxasd.asdasidioiqweioqiweooioqieioqieoqieooi\";\n+\n+        // Initialize PasswordSecret to set this as PasswordSecret in Mirror Maker spec\n+        PasswordSecretSource passwordSecret = new PasswordSecretSource();\n+        passwordSecret.setSecretName(weirdUserName);\n+        passwordSecret.setPassword(\"password\");\n+\n+        // Initialize CertSecretSource with certificate and secret names for consumer\n+        CertSecretSource certSecret = new CertSecretSource();\n+        certSecret.setCertificate(\"ca.crt\");\n+        certSecret.setSecretName(KafkaResources.clusterCaCertificateSecretName(CLUSTER_NAME));\n+\n+        KafkaBridgeSpec bridgeSpec = new KafkaBridgeSpecBuilder()\n+            .withNewKafkaClientAuthenticationScramSha512()\n+                .withNewUsername(weirdUserName)\n+                .withPasswordSecret(passwordSecret)\n+            .endKafkaClientAuthenticationScramSha512()\n+            .withNewTls()\n+                .withTrustedCertificates(certSecret)\n+            .endTls()\n+            .build();\n+\n+        testWeirdUsername(weirdUserName, new KafkaListenerAuthenticationScramSha512(), bridgeSpec, SecurityProtocol.SASL_SSL);\n+    }\n+\n+    @Test\n+    void testTlsAuthWithWeirdNamedUser() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "583a9dca77079f36310b69fa9998bdf5b33334f0"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NDQxMDUxOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeAbstractST.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQxMjo0NDoyM1rOHBSMkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQyMDo0OToxOVrOHBVIqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTEwODc1Mw==", "bodyText": "Why do we have these tags if we are removing external access?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r471108753", "createdAt": "2020-08-16T12:44:23Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeAbstractST.java", "diffHunk": "@@ -37,40 +27,18 @@\n @Tag(NODEPORT_SUPPORTED)\n @Tag(EXTERNAL_CLIENTS_USED)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2556563e992cf9760019c6bb383c7989089cfd5"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE1NjkwNA==", "bodyText": "I forgot to remove it, thanks", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r471156904", "createdAt": "2020-08-16T20:49:19Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeAbstractST.java", "diffHunk": "@@ -37,40 +27,18 @@\n @Tag(NODEPORT_SUPPORTED)\n @Tag(EXTERNAL_CLIENTS_USED)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTEwODc1Mw=="}, "originalCommit": {"oid": "b2556563e992cf9760019c6bb383c7989089cfd5"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NDQxNzAzOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeCorsST.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQxMjo1MjoxOVrOHBSPwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQyMDo0OTo0NFrOHBVIyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTEwOTU3MA==", "bodyText": "I think you should be running this in a separate pod. Not from the bridge pod it self.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r471109570", "createdAt": "2020-08-16T12:52:19Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeCorsST.java", "diffHunk": "@@ -4,129 +4,109 @@\n  */\n package io.strimzi.systemtest.bridge;\n \n-import io.fabric8.kubernetes.api.model.Service;\n import io.strimzi.api.kafka.model.KafkaBridgeHttpCors;\n import io.strimzi.api.kafka.model.KafkaResources;\n import io.strimzi.systemtest.Constants;\n-import io.strimzi.systemtest.resources.KubernetesResource;\n import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n import io.strimzi.systemtest.resources.crd.KafkaResource;\n import io.strimzi.systemtest.utils.ClientUtils;\n-import io.strimzi.systemtest.utils.kafkaUtils.KafkaBridgeUtils;\n-import io.strimzi.systemtest.utils.kubeUtils.objects.ServiceUtils;\n+import io.strimzi.systemtest.utils.specific.BridgeUtils;\n import io.vertx.core.http.HttpMethod;\n-import io.vertx.core.json.JsonArray;\n import io.vertx.core.json.JsonObject;\n-import io.vertx.junit5.VertxTestContext;\n import org.apache.kafka.clients.consumer.ConsumerConfig;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n \n-import java.util.Arrays;\n-import java.util.List;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n \n import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.CoreMatchers.hasItem;\n+import static org.hamcrest.Matchers.containsString;\n \n public class HttpBridgeCorsST extends HttpBridgeAbstractST {\n \n     private static final Logger LOGGER = LogManager.getLogger(HttpBridgeCorsST.class);\n-    public static final String NAMESPACE = \"bridge-cluster-test\";\n-    private static final String CORS_ORIGIN = \"https://strimzi.io\";\n+    private static final String NAMESPACE = \"bridge-cors-cluster-test\";\n \n-    protected static String bridgeExternalService = CLUSTER_NAME + \"-bridge-external-service\";\n-    private static String bridgeHost;\n-    private static int bridgePort;\n+    private static final String ALLOWED_ORIGIN = \"https://strimzi.io\";\n+    private static final String NOT_ALLOWED_ORIGIN = \"https://evil.io\";\n+\n+    private static String podName = \"\";\n \n     @Test\n-    void testCorsOriginAllowed(VertxTestContext context) {\n+    void testCorsOriginAllowed() {\n         final String kafkaBridgeUser = \"bridge-user-example\";\n-        final String topicName = \"topic-simple-receive\";\n         final String groupId = ClientUtils.generateRandomConsumerGroup();\n \n         JsonObject config = new JsonObject();\n         config.put(\"name\", kafkaBridgeUser);\n         config.put(\"format\", \"json\");\n         config.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \n-        // Create topics json\n-        JsonArray topic = new JsonArray();\n-        topic.add(topicName);\n-        JsonObject topics = new JsonObject();\n-        topics.put(\"topics\", topic);\n-\n-        client.request(HttpMethod.OPTIONS, bridgePort, bridgeHost, \"/consumers/\" + groupId + \"/instances/\" + kafkaBridgeUser + \"/subscription\")\n-            .putHeader(\"Origin\", CORS_ORIGIN)\n-            .putHeader(\"Access-Control-Request-Method\", \"POST\")\n-            .putHeader(\"Content-length\", String.valueOf(topics.toBuffer().length()))\n-            .putHeader(\"Content-type\", Constants.KAFKA_BRIDGE_JSON)\n-            .sendJsonObject(config, ar -> context.verify(() -> {\n-                assertThat(ar.result().statusCode(), is(200));\n-                assertThat(ar.result().getHeader(\"access-control-allow-origin\"), is(CORS_ORIGIN));\n-                assertThat(ar.result().getHeader(\"access-control-allow-headers\"), is(\"access-control-allow-origin,origin,x-requested-with,content-type,access-control-allow-methods,accept\"));\n-                List<String> list = Arrays.asList(ar.result().getHeader(\"access-control-allow-methods\").split(\",\"));\n-                assertThat(list, hasItem(\"POST\"));\n-                client.request(HttpMethod.POST, bridgePort, bridgeHost, \"/consumers/\" + groupId + \"/instances/\" + kafkaBridgeUser + \"/subscription\")\n-                    .putHeader(\"Origin\", CORS_ORIGIN)\n-                    .send(ar2 -> context.verify(() -> {\n-                        assertThat(ar2.result().statusCode(), is(404));\n-                        context.completeNow();\n-                    }));\n-            }));\n+        Map<String, String> additionalHeaders = new HashMap<>();\n+        additionalHeaders.put(\"Origin\", ALLOWED_ORIGIN);\n+        additionalHeaders.put(\"Access-Control-Request-Method\", HttpMethod.POST.toString());\n+\n+        String url = BridgeUtils.DEFAULT_BRIDGE_HOST + \"/consumers/\" + groupId + \"/instances/\" + kafkaBridgeUser + \"/subscription\";\n+        String headers = BridgeUtils.addHeadersToString(additionalHeaders, Constants.KAFKA_BRIDGE_JSON_JSON, config.toString());\n+        String response = BridgeUtils.executeCurlCommand(HttpMethod.OPTIONS, podName, config.toString(), url, headers);\n+        String allowedHeaders = \"access-control-allow-origin,origin,x-requested-with,content-type,access-control-allow-methods,accept\";\n+\n+        LOGGER.info(\"Checking if response from Bridge is correct\");\n+        assertThat(response, containsString(\"200 OK\"));\n+        assertThat(BridgeUtils.getHeaderValue(\"access-control-allow-origin\", response), is(ALLOWED_ORIGIN));\n+        assertThat(BridgeUtils.getHeaderValue(\"access-control-allow-headers\", response), is(allowedHeaders));\n+        assertThat(BridgeUtils.getHeaderValue(\"access-control-allow-methods\", response), containsString(HttpMethod.POST.toString()));\n+\n+        url = BridgeUtils.DEFAULT_BRIDGE_HOST + \"/consumers/\" + groupId + \"/instances/\" + kafkaBridgeUser + \"/subscription\";\n+        headers = BridgeUtils.addHeadersToString(Collections.singletonMap(\"Origin\", ALLOWED_ORIGIN));\n+        response = BridgeUtils.executeCurlCommand(HttpMethod.POST, podName, config.toString(), url, headers);\n+\n+        assertThat(response.contains(\"404\"), is(true));\n     }\n \n     @Test\n-    void testCorsForbidden(VertxTestContext context) {\n+    void testCorsForbidden() {\n         final String kafkaBridgeUser = \"bridge-user-example\";\n         final String groupId = ClientUtils.generateRandomConsumerGroup();\n \n-        final String notAllowedOrigin = \"https://evil.io\";\n-\n-        client.request(HttpMethod.OPTIONS, bridgePort, bridgeHost, \"/consumers/\" + groupId + \"/instances/\" + kafkaBridgeUser + \"/subscription\")\n-            .putHeader(\"Origin\", notAllowedOrigin)\n-            .putHeader(\"Access-Control-Request-Method\", \"POST\")\n-            .send(ar -> context.verify(() -> {\n-                assertThat(ar.result().statusCode(), is(403));\n-                assertThat(ar.result().statusMessage(), is(\"CORS Rejected - Invalid origin\"));\n-                client.request(HttpMethod.POST, bridgePort, bridgeHost, \"/consumers/\" + groupId + \"/instances/\" + kafkaBridgeUser + \"/subscription\")\n-                    .putHeader(\"Origin\", notAllowedOrigin)\n-                    .send(ar2 -> context.verify(() -> {\n-                        assertThat(ar2.result().statusCode(), is(403));\n-                        assertThat(ar2.result().statusMessage(), is(\"CORS Rejected - Invalid origin\"));\n-                        context.completeNow();\n-                    }));\n-            }));\n+        Map<String, String> additionalHeaders = new HashMap<>();\n+        additionalHeaders.put(\"Origin\", NOT_ALLOWED_ORIGIN);\n+        additionalHeaders.put(\"Access-Control-Request-Method\", HttpMethod.POST.toString());\n+\n+        String url = BridgeUtils.DEFAULT_BRIDGE_HOST + \"/consumers/\" + groupId + \"/instances/\" + kafkaBridgeUser + \"/subscription\";\n+        String headers = BridgeUtils.addHeadersToString(additionalHeaders);\n+        String response = BridgeUtils.executeCurlCommand(HttpMethod.OPTIONS, podName, url, headers);\n+\n+        LOGGER.info(\"Checking if response from Bridge is correct\");\n+        assertThat(response, containsString(\"403\"));\n+        assertThat(response, containsString(\"CORS Rejected - Invalid origin\"));\n+\n+        additionalHeaders.remove(\"Access-Control-Request-Method\", HttpMethod.POST.toString());\n+        headers = BridgeUtils.addHeadersToString(additionalHeaders);\n+        response = BridgeUtils.executeCurlCommand(HttpMethod.POST, podName, url, headers);\n+\n+        LOGGER.info(\"Checking if response from Bridge is correct\");\n+        assertThat(response, containsString(\"403\"));\n+        assertThat(response, containsString(\"CORS Rejected - Invalid origin\"));\n     }\n \n     @BeforeAll\n-    static void beforeAll() throws InterruptedException {\n-        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 1, 1)\n-            .editSpec()\n-                .editKafka()\n-                    .editListeners()\n-                        .withNewKafkaListenerExternalNodePort()\n-                            .withTls(false)\n-                        .endKafkaListenerExternalNodePort()\n-                    .endListeners()\n-                .endKafka()\n-            .endSpec()\n-            .done();\n+    void beforeAll() throws Exception {\n+        deployClusterOperator(NAMESPACE);\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 1, 1).done();\n \n         KafkaBridgeResource.kafkaBridgeWithCors(CLUSTER_NAME, KafkaResources.plainBootstrapAddress(CLUSTER_NAME),\n-            1, CORS_ORIGIN, null).done();\n+            1, ALLOWED_ORIGIN, null).done();\n \n         KafkaBridgeHttpCors kafkaBridgeHttpCors = KafkaBridgeResource.kafkaBridgeClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getSpec().getHttp().getCors();\n         LOGGER.info(\"Bridge with the following CORS settings {}\", kafkaBridgeHttpCors.toString());\n \n-        Service service = KafkaBridgeUtils.createBridgeNodePortService(CLUSTER_NAME, NAMESPACE, bridgeExternalService);\n-        KubernetesResource.createServiceResource(service, NAMESPACE).done();\n-        ServiceUtils.waitForNodePortService(bridgeExternalService);\n-\n-        bridgePort = KafkaBridgeUtils.getBridgeNodePort(NAMESPACE, bridgeExternalService);\n-        bridgeHost = kubeClient(NAMESPACE).getNodeAddress();\n+        podName = kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-bridge\").get(0).getMetadata().getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2556563e992cf9760019c6bb383c7989089cfd5"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE1NjkzNg==", "bodyText": "I'm gonna take a look at it :)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r471156936", "createdAt": "2020-08-16T20:49:44Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeCorsST.java", "diffHunk": "@@ -4,129 +4,109 @@\n  */\n package io.strimzi.systemtest.bridge;\n \n-import io.fabric8.kubernetes.api.model.Service;\n import io.strimzi.api.kafka.model.KafkaBridgeHttpCors;\n import io.strimzi.api.kafka.model.KafkaResources;\n import io.strimzi.systemtest.Constants;\n-import io.strimzi.systemtest.resources.KubernetesResource;\n import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n import io.strimzi.systemtest.resources.crd.KafkaResource;\n import io.strimzi.systemtest.utils.ClientUtils;\n-import io.strimzi.systemtest.utils.kafkaUtils.KafkaBridgeUtils;\n-import io.strimzi.systemtest.utils.kubeUtils.objects.ServiceUtils;\n+import io.strimzi.systemtest.utils.specific.BridgeUtils;\n import io.vertx.core.http.HttpMethod;\n-import io.vertx.core.json.JsonArray;\n import io.vertx.core.json.JsonObject;\n-import io.vertx.junit5.VertxTestContext;\n import org.apache.kafka.clients.consumer.ConsumerConfig;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n \n-import java.util.Arrays;\n-import java.util.List;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n \n import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.CoreMatchers.hasItem;\n+import static org.hamcrest.Matchers.containsString;\n \n public class HttpBridgeCorsST extends HttpBridgeAbstractST {\n \n     private static final Logger LOGGER = LogManager.getLogger(HttpBridgeCorsST.class);\n-    public static final String NAMESPACE = \"bridge-cluster-test\";\n-    private static final String CORS_ORIGIN = \"https://strimzi.io\";\n+    private static final String NAMESPACE = \"bridge-cors-cluster-test\";\n \n-    protected static String bridgeExternalService = CLUSTER_NAME + \"-bridge-external-service\";\n-    private static String bridgeHost;\n-    private static int bridgePort;\n+    private static final String ALLOWED_ORIGIN = \"https://strimzi.io\";\n+    private static final String NOT_ALLOWED_ORIGIN = \"https://evil.io\";\n+\n+    private static String podName = \"\";\n \n     @Test\n-    void testCorsOriginAllowed(VertxTestContext context) {\n+    void testCorsOriginAllowed() {\n         final String kafkaBridgeUser = \"bridge-user-example\";\n-        final String topicName = \"topic-simple-receive\";\n         final String groupId = ClientUtils.generateRandomConsumerGroup();\n \n         JsonObject config = new JsonObject();\n         config.put(\"name\", kafkaBridgeUser);\n         config.put(\"format\", \"json\");\n         config.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \n-        // Create topics json\n-        JsonArray topic = new JsonArray();\n-        topic.add(topicName);\n-        JsonObject topics = new JsonObject();\n-        topics.put(\"topics\", topic);\n-\n-        client.request(HttpMethod.OPTIONS, bridgePort, bridgeHost, \"/consumers/\" + groupId + \"/instances/\" + kafkaBridgeUser + \"/subscription\")\n-            .putHeader(\"Origin\", CORS_ORIGIN)\n-            .putHeader(\"Access-Control-Request-Method\", \"POST\")\n-            .putHeader(\"Content-length\", String.valueOf(topics.toBuffer().length()))\n-            .putHeader(\"Content-type\", Constants.KAFKA_BRIDGE_JSON)\n-            .sendJsonObject(config, ar -> context.verify(() -> {\n-                assertThat(ar.result().statusCode(), is(200));\n-                assertThat(ar.result().getHeader(\"access-control-allow-origin\"), is(CORS_ORIGIN));\n-                assertThat(ar.result().getHeader(\"access-control-allow-headers\"), is(\"access-control-allow-origin,origin,x-requested-with,content-type,access-control-allow-methods,accept\"));\n-                List<String> list = Arrays.asList(ar.result().getHeader(\"access-control-allow-methods\").split(\",\"));\n-                assertThat(list, hasItem(\"POST\"));\n-                client.request(HttpMethod.POST, bridgePort, bridgeHost, \"/consumers/\" + groupId + \"/instances/\" + kafkaBridgeUser + \"/subscription\")\n-                    .putHeader(\"Origin\", CORS_ORIGIN)\n-                    .send(ar2 -> context.verify(() -> {\n-                        assertThat(ar2.result().statusCode(), is(404));\n-                        context.completeNow();\n-                    }));\n-            }));\n+        Map<String, String> additionalHeaders = new HashMap<>();\n+        additionalHeaders.put(\"Origin\", ALLOWED_ORIGIN);\n+        additionalHeaders.put(\"Access-Control-Request-Method\", HttpMethod.POST.toString());\n+\n+        String url = BridgeUtils.DEFAULT_BRIDGE_HOST + \"/consumers/\" + groupId + \"/instances/\" + kafkaBridgeUser + \"/subscription\";\n+        String headers = BridgeUtils.addHeadersToString(additionalHeaders, Constants.KAFKA_BRIDGE_JSON_JSON, config.toString());\n+        String response = BridgeUtils.executeCurlCommand(HttpMethod.OPTIONS, podName, config.toString(), url, headers);\n+        String allowedHeaders = \"access-control-allow-origin,origin,x-requested-with,content-type,access-control-allow-methods,accept\";\n+\n+        LOGGER.info(\"Checking if response from Bridge is correct\");\n+        assertThat(response, containsString(\"200 OK\"));\n+        assertThat(BridgeUtils.getHeaderValue(\"access-control-allow-origin\", response), is(ALLOWED_ORIGIN));\n+        assertThat(BridgeUtils.getHeaderValue(\"access-control-allow-headers\", response), is(allowedHeaders));\n+        assertThat(BridgeUtils.getHeaderValue(\"access-control-allow-methods\", response), containsString(HttpMethod.POST.toString()));\n+\n+        url = BridgeUtils.DEFAULT_BRIDGE_HOST + \"/consumers/\" + groupId + \"/instances/\" + kafkaBridgeUser + \"/subscription\";\n+        headers = BridgeUtils.addHeadersToString(Collections.singletonMap(\"Origin\", ALLOWED_ORIGIN));\n+        response = BridgeUtils.executeCurlCommand(HttpMethod.POST, podName, config.toString(), url, headers);\n+\n+        assertThat(response.contains(\"404\"), is(true));\n     }\n \n     @Test\n-    void testCorsForbidden(VertxTestContext context) {\n+    void testCorsForbidden() {\n         final String kafkaBridgeUser = \"bridge-user-example\";\n         final String groupId = ClientUtils.generateRandomConsumerGroup();\n \n-        final String notAllowedOrigin = \"https://evil.io\";\n-\n-        client.request(HttpMethod.OPTIONS, bridgePort, bridgeHost, \"/consumers/\" + groupId + \"/instances/\" + kafkaBridgeUser + \"/subscription\")\n-            .putHeader(\"Origin\", notAllowedOrigin)\n-            .putHeader(\"Access-Control-Request-Method\", \"POST\")\n-            .send(ar -> context.verify(() -> {\n-                assertThat(ar.result().statusCode(), is(403));\n-                assertThat(ar.result().statusMessage(), is(\"CORS Rejected - Invalid origin\"));\n-                client.request(HttpMethod.POST, bridgePort, bridgeHost, \"/consumers/\" + groupId + \"/instances/\" + kafkaBridgeUser + \"/subscription\")\n-                    .putHeader(\"Origin\", notAllowedOrigin)\n-                    .send(ar2 -> context.verify(() -> {\n-                        assertThat(ar2.result().statusCode(), is(403));\n-                        assertThat(ar2.result().statusMessage(), is(\"CORS Rejected - Invalid origin\"));\n-                        context.completeNow();\n-                    }));\n-            }));\n+        Map<String, String> additionalHeaders = new HashMap<>();\n+        additionalHeaders.put(\"Origin\", NOT_ALLOWED_ORIGIN);\n+        additionalHeaders.put(\"Access-Control-Request-Method\", HttpMethod.POST.toString());\n+\n+        String url = BridgeUtils.DEFAULT_BRIDGE_HOST + \"/consumers/\" + groupId + \"/instances/\" + kafkaBridgeUser + \"/subscription\";\n+        String headers = BridgeUtils.addHeadersToString(additionalHeaders);\n+        String response = BridgeUtils.executeCurlCommand(HttpMethod.OPTIONS, podName, url, headers);\n+\n+        LOGGER.info(\"Checking if response from Bridge is correct\");\n+        assertThat(response, containsString(\"403\"));\n+        assertThat(response, containsString(\"CORS Rejected - Invalid origin\"));\n+\n+        additionalHeaders.remove(\"Access-Control-Request-Method\", HttpMethod.POST.toString());\n+        headers = BridgeUtils.addHeadersToString(additionalHeaders);\n+        response = BridgeUtils.executeCurlCommand(HttpMethod.POST, podName, url, headers);\n+\n+        LOGGER.info(\"Checking if response from Bridge is correct\");\n+        assertThat(response, containsString(\"403\"));\n+        assertThat(response, containsString(\"CORS Rejected - Invalid origin\"));\n     }\n \n     @BeforeAll\n-    static void beforeAll() throws InterruptedException {\n-        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 1, 1)\n-            .editSpec()\n-                .editKafka()\n-                    .editListeners()\n-                        .withNewKafkaListenerExternalNodePort()\n-                            .withTls(false)\n-                        .endKafkaListenerExternalNodePort()\n-                    .endListeners()\n-                .endKafka()\n-            .endSpec()\n-            .done();\n+    void beforeAll() throws Exception {\n+        deployClusterOperator(NAMESPACE);\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 1, 1).done();\n \n         KafkaBridgeResource.kafkaBridgeWithCors(CLUSTER_NAME, KafkaResources.plainBootstrapAddress(CLUSTER_NAME),\n-            1, CORS_ORIGIN, null).done();\n+            1, ALLOWED_ORIGIN, null).done();\n \n         KafkaBridgeHttpCors kafkaBridgeHttpCors = KafkaBridgeResource.kafkaBridgeClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getSpec().getHttp().getCors();\n         LOGGER.info(\"Bridge with the following CORS settings {}\", kafkaBridgeHttpCors.toString());\n \n-        Service service = KafkaBridgeUtils.createBridgeNodePortService(CLUSTER_NAME, NAMESPACE, bridgeExternalService);\n-        KubernetesResource.createServiceResource(service, NAMESPACE).done();\n-        ServiceUtils.waitForNodePortService(bridgeExternalService);\n-\n-        bridgePort = KafkaBridgeUtils.getBridgeNodePort(NAMESPACE, bridgeExternalService);\n-        bridgeHost = kubeClient(NAMESPACE).getNodeAddress();\n+        podName = kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-bridge\").get(0).getMetadata().getName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTEwOTU3MA=="}, "originalCommit": {"oid": "b2556563e992cf9760019c6bb383c7989089cfd5"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NzU3NDQ0OnYy", "diffSide": "RIGHT", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNTo0NzoyNFrOHBua1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjoxMTowOFrOHBvWTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU3MTE1Ng==", "bodyText": "Kinda strange log, what should it say?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r471571156", "createdAt": "2020-08-17T15:47:24Z", "author": {"login": "Frawless"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "diffHunk": "@@ -44,152 +48,181 @@ public static JsonObject generateHttpMessages(int messageCount) {\n         return root;\n     }\n \n-    public static JsonObject sendMessagesHttpRequest(JsonObject records, String bridgeHost, int bridgePort, String topicName, WebClient client) throws InterruptedException, ExecutionException, TimeoutException {\n+    public static JsonObject sendMessagesHttpRequest(JsonObject records, String topicName, String podName) {\n         LOGGER.info(\"Sending records to KafkaBridge\");\n-        CompletableFuture<JsonObject> future = new CompletableFuture<>();\n-        client.post(bridgePort, bridgeHost, \"/topics/\" + topicName)\n-            .putHeader(\"Content-length\", String.valueOf(records.toBuffer().length()))\n-            .putHeader(\"Content-Type\", Constants.KAFKA_BRIDGE_JSON_JSON)\n-            .as(BodyCodec.jsonObject())\n-            .sendJsonObject(records, ar -> {\n-                if (ar.succeeded()) {\n-                    HttpResponse<JsonObject> response = ar.result();\n-                    if (response.statusCode() == HttpResponseStatus.OK.code()) {\n-                        LOGGER.debug(\"Server accepted post\");\n-                        future.complete(response.body());\n-                    } else {\n-                        LOGGER.error(\"Server didn't accept post\", ar.cause());\n-                    }\n-                } else {\n-                    LOGGER.error(\"Server didn't accept post\", ar.cause());\n-                    future.completeExceptionally(ar.cause());\n-                }\n-            });\n-        return future.get(1, TimeUnit.MINUTES);\n-    }\n-\n-    public static JsonArray receiveMessagesHttpRequest(String bridgeHost, int bridgePort, String groupID, String name, WebClient client) throws Exception {\n-        CompletableFuture<JsonArray> future = new CompletableFuture<>();\n-        client.get(bridgePort, bridgeHost, \"/consumers/\" + groupID + \"/instances/\" + name + \"/records?timeout=\" + 1000)\n-            .putHeader(\"Accept\", Constants.KAFKA_BRIDGE_JSON_JSON)\n-            .as(BodyCodec.jsonArray())\n-            .send(ar -> {\n-                if (ar.succeeded() && ar.result().statusCode() == 200) {\n-                    HttpResponse<JsonArray> response = ar.result();\n-                    if (response.body().size() > 0) {\n-                        for (int i = 0; i < response.body().size(); i++) {\n-                            JsonObject jsonResponse = response.body().getJsonObject(i);\n-                            LOGGER.info(\"JsonResponse: {}\", jsonResponse.toString());\n-                            String kafkaTopic = jsonResponse.getString(\"topic\");\n-                            int kafkaPartition = jsonResponse.getInteger(\"partition\");\n-                            String key = jsonResponse.getString(\"key\");\n-                            Object value = jsonResponse.getValue(\"value\");\n-                            long offset = jsonResponse.getLong(\"offset\");\n-                            LOGGER.debug(\"Received msg: topic:{} partition:{} key:{} value:{} offset{}\", kafkaTopic, kafkaPartition, key, value, offset);\n-                        }\n-                        LOGGER.info(\"Received {} messages from KafkaBridge\", response.body().size());\n-                    } else {\n-                        LOGGER.warn(\"Received body 0 messages: {}\", response.body());\n-                    }\n-                    future.complete(response.body());\n-                } else {\n-                    LOGGER.info(\"Cannot consume any messages!\", ar.cause());\n-                    future.completeExceptionally(ar.cause());\n+\n+        url = DEFAULT_BRIDGE_HOST + \"/topics/\" + topicName;\n+        headers = addHeadersToString(Constants.KAFKA_BRIDGE_JSON_JSON, records.toString());\n+        response = executeCurlCommand(HttpMethod.POST, podName, records.toString(), url, headers);\n+\n+        Matcher matcher = ALL_BEFORE_JSON_PATTERN.matcher(response);\n+        JsonObject jsonResponse = new JsonObject(matcher.replaceFirst(\"{\"));\n+\n+        if (response.contains(\"200 OK\")) {\n+            LOGGER.debug(\"Server accepted post\");\n+        } else {\n+            throw new RuntimeException(\"Server didn't accept post: \" + response);\n+        }\n+\n+        return jsonResponse;\n+    }\n+\n+    public static JsonArray receiveMessagesHttpRequest(String podName, String groupID, String name) {\n+        LOGGER.info(\"Trying to receive messages\");\n+        JsonArray jsonResponse = receiveMessages(podName, groupID, name);\n+        if (jsonResponse.size() == 0) {\n+            LOGGER.info(\"Received 0 messages, trying again after subscribing to offset\");\n+            jsonResponse = receiveMessages(podName, groupID, name);\n+        }\n+\n+        return jsonResponse;\n+    }\n+\n+    public static JsonArray receiveMessages(String podName, String groupID, String name) {\n+        LOGGER.info(\"Receiving records from KafkaBridge\");\n+\n+        url = DEFAULT_BRIDGE_HOST + \"/consumers/\" + groupID + \"/instances/\" + name + \"/records?timeout=\" + 1000;\n+        headers = addHeadersToString(Collections.singletonMap(\"Accept\", Constants.KAFKA_BRIDGE_JSON_JSON));\n+        response = executeCurlCommand(HttpMethod.GET, podName, \"\", url, headers);\n+\n+        Matcher matcher = ALL_BEFORE_JSON_ARRAY_PATTERN.matcher(response);\n+        JsonArray jsonResponse = new JsonArray(matcher.replaceFirst(\"[\"));\n+\n+        if (response.contains(\"200 OK\")) {\n+            if (jsonResponse.size() > 0) {\n+                for (int i = 0; i < jsonResponse.size(); i++) {\n+                    JsonObject jsonObject = jsonResponse.getJsonObject(i);\n+                    LOGGER.info(\"JsonResponse: {}\", jsonObject.toString());\n+                    String kafkaTopic = jsonObject.getString(\"topic\");\n+                    int kafkaPartition = jsonObject.getInteger(\"partition\");\n+                    String key = jsonObject.getString(\"key\");\n+                    Object value = jsonObject.getValue(\"value\");\n+                    long offset = jsonObject.getLong(\"offset\");\n+                    LOGGER.debug(\"Received msg: topic:{} partition:{} key:{} value:{} offset{}\", kafkaTopic, kafkaPartition, key, value, offset);\n                 }\n-            });\n-        return future.get(1, TimeUnit.MINUTES);\n+                LOGGER.info(\"Received {} messages from KafkaBridge\", jsonResponse.size());\n+            } else {\n+                LOGGER.warn(\"Received body 0 messages: {}\", jsonResponse);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94b5a538c0953bf8115691eca3bbf08dfccc4d6c"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU4NjM4Mw==", "bodyText": "already changed -> these methods are useless right now as we are using everywhere example clients...", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r471586383", "createdAt": "2020-08-17T16:11:08Z", "author": {"login": "im-konge"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "diffHunk": "@@ -44,152 +48,181 @@ public static JsonObject generateHttpMessages(int messageCount) {\n         return root;\n     }\n \n-    public static JsonObject sendMessagesHttpRequest(JsonObject records, String bridgeHost, int bridgePort, String topicName, WebClient client) throws InterruptedException, ExecutionException, TimeoutException {\n+    public static JsonObject sendMessagesHttpRequest(JsonObject records, String topicName, String podName) {\n         LOGGER.info(\"Sending records to KafkaBridge\");\n-        CompletableFuture<JsonObject> future = new CompletableFuture<>();\n-        client.post(bridgePort, bridgeHost, \"/topics/\" + topicName)\n-            .putHeader(\"Content-length\", String.valueOf(records.toBuffer().length()))\n-            .putHeader(\"Content-Type\", Constants.KAFKA_BRIDGE_JSON_JSON)\n-            .as(BodyCodec.jsonObject())\n-            .sendJsonObject(records, ar -> {\n-                if (ar.succeeded()) {\n-                    HttpResponse<JsonObject> response = ar.result();\n-                    if (response.statusCode() == HttpResponseStatus.OK.code()) {\n-                        LOGGER.debug(\"Server accepted post\");\n-                        future.complete(response.body());\n-                    } else {\n-                        LOGGER.error(\"Server didn't accept post\", ar.cause());\n-                    }\n-                } else {\n-                    LOGGER.error(\"Server didn't accept post\", ar.cause());\n-                    future.completeExceptionally(ar.cause());\n-                }\n-            });\n-        return future.get(1, TimeUnit.MINUTES);\n-    }\n-\n-    public static JsonArray receiveMessagesHttpRequest(String bridgeHost, int bridgePort, String groupID, String name, WebClient client) throws Exception {\n-        CompletableFuture<JsonArray> future = new CompletableFuture<>();\n-        client.get(bridgePort, bridgeHost, \"/consumers/\" + groupID + \"/instances/\" + name + \"/records?timeout=\" + 1000)\n-            .putHeader(\"Accept\", Constants.KAFKA_BRIDGE_JSON_JSON)\n-            .as(BodyCodec.jsonArray())\n-            .send(ar -> {\n-                if (ar.succeeded() && ar.result().statusCode() == 200) {\n-                    HttpResponse<JsonArray> response = ar.result();\n-                    if (response.body().size() > 0) {\n-                        for (int i = 0; i < response.body().size(); i++) {\n-                            JsonObject jsonResponse = response.body().getJsonObject(i);\n-                            LOGGER.info(\"JsonResponse: {}\", jsonResponse.toString());\n-                            String kafkaTopic = jsonResponse.getString(\"topic\");\n-                            int kafkaPartition = jsonResponse.getInteger(\"partition\");\n-                            String key = jsonResponse.getString(\"key\");\n-                            Object value = jsonResponse.getValue(\"value\");\n-                            long offset = jsonResponse.getLong(\"offset\");\n-                            LOGGER.debug(\"Received msg: topic:{} partition:{} key:{} value:{} offset{}\", kafkaTopic, kafkaPartition, key, value, offset);\n-                        }\n-                        LOGGER.info(\"Received {} messages from KafkaBridge\", response.body().size());\n-                    } else {\n-                        LOGGER.warn(\"Received body 0 messages: {}\", response.body());\n-                    }\n-                    future.complete(response.body());\n-                } else {\n-                    LOGGER.info(\"Cannot consume any messages!\", ar.cause());\n-                    future.completeExceptionally(ar.cause());\n+\n+        url = DEFAULT_BRIDGE_HOST + \"/topics/\" + topicName;\n+        headers = addHeadersToString(Constants.KAFKA_BRIDGE_JSON_JSON, records.toString());\n+        response = executeCurlCommand(HttpMethod.POST, podName, records.toString(), url, headers);\n+\n+        Matcher matcher = ALL_BEFORE_JSON_PATTERN.matcher(response);\n+        JsonObject jsonResponse = new JsonObject(matcher.replaceFirst(\"{\"));\n+\n+        if (response.contains(\"200 OK\")) {\n+            LOGGER.debug(\"Server accepted post\");\n+        } else {\n+            throw new RuntimeException(\"Server didn't accept post: \" + response);\n+        }\n+\n+        return jsonResponse;\n+    }\n+\n+    public static JsonArray receiveMessagesHttpRequest(String podName, String groupID, String name) {\n+        LOGGER.info(\"Trying to receive messages\");\n+        JsonArray jsonResponse = receiveMessages(podName, groupID, name);\n+        if (jsonResponse.size() == 0) {\n+            LOGGER.info(\"Received 0 messages, trying again after subscribing to offset\");\n+            jsonResponse = receiveMessages(podName, groupID, name);\n+        }\n+\n+        return jsonResponse;\n+    }\n+\n+    public static JsonArray receiveMessages(String podName, String groupID, String name) {\n+        LOGGER.info(\"Receiving records from KafkaBridge\");\n+\n+        url = DEFAULT_BRIDGE_HOST + \"/consumers/\" + groupID + \"/instances/\" + name + \"/records?timeout=\" + 1000;\n+        headers = addHeadersToString(Collections.singletonMap(\"Accept\", Constants.KAFKA_BRIDGE_JSON_JSON));\n+        response = executeCurlCommand(HttpMethod.GET, podName, \"\", url, headers);\n+\n+        Matcher matcher = ALL_BEFORE_JSON_ARRAY_PATTERN.matcher(response);\n+        JsonArray jsonResponse = new JsonArray(matcher.replaceFirst(\"[\"));\n+\n+        if (response.contains(\"200 OK\")) {\n+            if (jsonResponse.size() > 0) {\n+                for (int i = 0; i < jsonResponse.size(); i++) {\n+                    JsonObject jsonObject = jsonResponse.getJsonObject(i);\n+                    LOGGER.info(\"JsonResponse: {}\", jsonObject.toString());\n+                    String kafkaTopic = jsonObject.getString(\"topic\");\n+                    int kafkaPartition = jsonObject.getInteger(\"partition\");\n+                    String key = jsonObject.getString(\"key\");\n+                    Object value = jsonObject.getValue(\"value\");\n+                    long offset = jsonObject.getLong(\"offset\");\n+                    LOGGER.debug(\"Received msg: topic:{} partition:{} key:{} value:{} offset{}\", kafkaTopic, kafkaPartition, key, value, offset);\n                 }\n-            });\n-        return future.get(1, TimeUnit.MINUTES);\n+                LOGGER.info(\"Received {} messages from KafkaBridge\", jsonResponse.size());\n+            } else {\n+                LOGGER.warn(\"Received body 0 messages: {}\", jsonResponse);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU3MTE1Ng=="}, "originalCommit": {"oid": "94b5a538c0953bf8115691eca3bbf08dfccc4d6c"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NzU3NzE5OnYy", "diffSide": "RIGHT", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNTo0Nzo1N1rOHBucXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjoxMToxN1rOHBvWnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU3MTU1MA==", "bodyText": "Maybe add the expected message count to the log?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r471571550", "createdAt": "2020-08-17T15:47:57Z", "author": {"login": "Frawless"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "diffHunk": "@@ -44,152 +48,181 @@ public static JsonObject generateHttpMessages(int messageCount) {\n         return root;\n     }\n \n-    public static JsonObject sendMessagesHttpRequest(JsonObject records, String bridgeHost, int bridgePort, String topicName, WebClient client) throws InterruptedException, ExecutionException, TimeoutException {\n+    public static JsonObject sendMessagesHttpRequest(JsonObject records, String topicName, String podName) {\n         LOGGER.info(\"Sending records to KafkaBridge\");\n-        CompletableFuture<JsonObject> future = new CompletableFuture<>();\n-        client.post(bridgePort, bridgeHost, \"/topics/\" + topicName)\n-            .putHeader(\"Content-length\", String.valueOf(records.toBuffer().length()))\n-            .putHeader(\"Content-Type\", Constants.KAFKA_BRIDGE_JSON_JSON)\n-            .as(BodyCodec.jsonObject())\n-            .sendJsonObject(records, ar -> {\n-                if (ar.succeeded()) {\n-                    HttpResponse<JsonObject> response = ar.result();\n-                    if (response.statusCode() == HttpResponseStatus.OK.code()) {\n-                        LOGGER.debug(\"Server accepted post\");\n-                        future.complete(response.body());\n-                    } else {\n-                        LOGGER.error(\"Server didn't accept post\", ar.cause());\n-                    }\n-                } else {\n-                    LOGGER.error(\"Server didn't accept post\", ar.cause());\n-                    future.completeExceptionally(ar.cause());\n-                }\n-            });\n-        return future.get(1, TimeUnit.MINUTES);\n-    }\n-\n-    public static JsonArray receiveMessagesHttpRequest(String bridgeHost, int bridgePort, String groupID, String name, WebClient client) throws Exception {\n-        CompletableFuture<JsonArray> future = new CompletableFuture<>();\n-        client.get(bridgePort, bridgeHost, \"/consumers/\" + groupID + \"/instances/\" + name + \"/records?timeout=\" + 1000)\n-            .putHeader(\"Accept\", Constants.KAFKA_BRIDGE_JSON_JSON)\n-            .as(BodyCodec.jsonArray())\n-            .send(ar -> {\n-                if (ar.succeeded() && ar.result().statusCode() == 200) {\n-                    HttpResponse<JsonArray> response = ar.result();\n-                    if (response.body().size() > 0) {\n-                        for (int i = 0; i < response.body().size(); i++) {\n-                            JsonObject jsonResponse = response.body().getJsonObject(i);\n-                            LOGGER.info(\"JsonResponse: {}\", jsonResponse.toString());\n-                            String kafkaTopic = jsonResponse.getString(\"topic\");\n-                            int kafkaPartition = jsonResponse.getInteger(\"partition\");\n-                            String key = jsonResponse.getString(\"key\");\n-                            Object value = jsonResponse.getValue(\"value\");\n-                            long offset = jsonResponse.getLong(\"offset\");\n-                            LOGGER.debug(\"Received msg: topic:{} partition:{} key:{} value:{} offset{}\", kafkaTopic, kafkaPartition, key, value, offset);\n-                        }\n-                        LOGGER.info(\"Received {} messages from KafkaBridge\", response.body().size());\n-                    } else {\n-                        LOGGER.warn(\"Received body 0 messages: {}\", response.body());\n-                    }\n-                    future.complete(response.body());\n-                } else {\n-                    LOGGER.info(\"Cannot consume any messages!\", ar.cause());\n-                    future.completeExceptionally(ar.cause());\n+\n+        url = DEFAULT_BRIDGE_HOST + \"/topics/\" + topicName;\n+        headers = addHeadersToString(Constants.KAFKA_BRIDGE_JSON_JSON, records.toString());\n+        response = executeCurlCommand(HttpMethod.POST, podName, records.toString(), url, headers);\n+\n+        Matcher matcher = ALL_BEFORE_JSON_PATTERN.matcher(response);\n+        JsonObject jsonResponse = new JsonObject(matcher.replaceFirst(\"{\"));\n+\n+        if (response.contains(\"200 OK\")) {\n+            LOGGER.debug(\"Server accepted post\");\n+        } else {\n+            throw new RuntimeException(\"Server didn't accept post: \" + response);\n+        }\n+\n+        return jsonResponse;\n+    }\n+\n+    public static JsonArray receiveMessagesHttpRequest(String podName, String groupID, String name) {\n+        LOGGER.info(\"Trying to receive messages\");\n+        JsonArray jsonResponse = receiveMessages(podName, groupID, name);\n+        if (jsonResponse.size() == 0) {\n+            LOGGER.info(\"Received 0 messages, trying again after subscribing to offset\");\n+            jsonResponse = receiveMessages(podName, groupID, name);\n+        }\n+\n+        return jsonResponse;\n+    }\n+\n+    public static JsonArray receiveMessages(String podName, String groupID, String name) {\n+        LOGGER.info(\"Receiving records from KafkaBridge\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94b5a538c0953bf8115691eca3bbf08dfccc4d6c"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU4NjQ2Mw==", "bodyText": "same as above", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r471586463", "createdAt": "2020-08-17T16:11:17Z", "author": {"login": "im-konge"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "diffHunk": "@@ -44,152 +48,181 @@ public static JsonObject generateHttpMessages(int messageCount) {\n         return root;\n     }\n \n-    public static JsonObject sendMessagesHttpRequest(JsonObject records, String bridgeHost, int bridgePort, String topicName, WebClient client) throws InterruptedException, ExecutionException, TimeoutException {\n+    public static JsonObject sendMessagesHttpRequest(JsonObject records, String topicName, String podName) {\n         LOGGER.info(\"Sending records to KafkaBridge\");\n-        CompletableFuture<JsonObject> future = new CompletableFuture<>();\n-        client.post(bridgePort, bridgeHost, \"/topics/\" + topicName)\n-            .putHeader(\"Content-length\", String.valueOf(records.toBuffer().length()))\n-            .putHeader(\"Content-Type\", Constants.KAFKA_BRIDGE_JSON_JSON)\n-            .as(BodyCodec.jsonObject())\n-            .sendJsonObject(records, ar -> {\n-                if (ar.succeeded()) {\n-                    HttpResponse<JsonObject> response = ar.result();\n-                    if (response.statusCode() == HttpResponseStatus.OK.code()) {\n-                        LOGGER.debug(\"Server accepted post\");\n-                        future.complete(response.body());\n-                    } else {\n-                        LOGGER.error(\"Server didn't accept post\", ar.cause());\n-                    }\n-                } else {\n-                    LOGGER.error(\"Server didn't accept post\", ar.cause());\n-                    future.completeExceptionally(ar.cause());\n-                }\n-            });\n-        return future.get(1, TimeUnit.MINUTES);\n-    }\n-\n-    public static JsonArray receiveMessagesHttpRequest(String bridgeHost, int bridgePort, String groupID, String name, WebClient client) throws Exception {\n-        CompletableFuture<JsonArray> future = new CompletableFuture<>();\n-        client.get(bridgePort, bridgeHost, \"/consumers/\" + groupID + \"/instances/\" + name + \"/records?timeout=\" + 1000)\n-            .putHeader(\"Accept\", Constants.KAFKA_BRIDGE_JSON_JSON)\n-            .as(BodyCodec.jsonArray())\n-            .send(ar -> {\n-                if (ar.succeeded() && ar.result().statusCode() == 200) {\n-                    HttpResponse<JsonArray> response = ar.result();\n-                    if (response.body().size() > 0) {\n-                        for (int i = 0; i < response.body().size(); i++) {\n-                            JsonObject jsonResponse = response.body().getJsonObject(i);\n-                            LOGGER.info(\"JsonResponse: {}\", jsonResponse.toString());\n-                            String kafkaTopic = jsonResponse.getString(\"topic\");\n-                            int kafkaPartition = jsonResponse.getInteger(\"partition\");\n-                            String key = jsonResponse.getString(\"key\");\n-                            Object value = jsonResponse.getValue(\"value\");\n-                            long offset = jsonResponse.getLong(\"offset\");\n-                            LOGGER.debug(\"Received msg: topic:{} partition:{} key:{} value:{} offset{}\", kafkaTopic, kafkaPartition, key, value, offset);\n-                        }\n-                        LOGGER.info(\"Received {} messages from KafkaBridge\", response.body().size());\n-                    } else {\n-                        LOGGER.warn(\"Received body 0 messages: {}\", response.body());\n-                    }\n-                    future.complete(response.body());\n-                } else {\n-                    LOGGER.info(\"Cannot consume any messages!\", ar.cause());\n-                    future.completeExceptionally(ar.cause());\n+\n+        url = DEFAULT_BRIDGE_HOST + \"/topics/\" + topicName;\n+        headers = addHeadersToString(Constants.KAFKA_BRIDGE_JSON_JSON, records.toString());\n+        response = executeCurlCommand(HttpMethod.POST, podName, records.toString(), url, headers);\n+\n+        Matcher matcher = ALL_BEFORE_JSON_PATTERN.matcher(response);\n+        JsonObject jsonResponse = new JsonObject(matcher.replaceFirst(\"{\"));\n+\n+        if (response.contains(\"200 OK\")) {\n+            LOGGER.debug(\"Server accepted post\");\n+        } else {\n+            throw new RuntimeException(\"Server didn't accept post: \" + response);\n+        }\n+\n+        return jsonResponse;\n+    }\n+\n+    public static JsonArray receiveMessagesHttpRequest(String podName, String groupID, String name) {\n+        LOGGER.info(\"Trying to receive messages\");\n+        JsonArray jsonResponse = receiveMessages(podName, groupID, name);\n+        if (jsonResponse.size() == 0) {\n+            LOGGER.info(\"Received 0 messages, trying again after subscribing to offset\");\n+            jsonResponse = receiveMessages(podName, groupID, name);\n+        }\n+\n+        return jsonResponse;\n+    }\n+\n+    public static JsonArray receiveMessages(String podName, String groupID, String name) {\n+        LOGGER.info(\"Receiving records from KafkaBridge\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU3MTU1MA=="}, "originalCommit": {"oid": "94b5a538c0953bf8115691eca3bbf08dfccc4d6c"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NzU3ODA4OnYy", "diffSide": "RIGHT", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNTo0ODowOFrOHBuc2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjoxMTozMlrOHBvXLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU3MTY3NA==", "bodyText": "Maybe add expected records count?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r471571674", "createdAt": "2020-08-17T15:48:08Z", "author": {"login": "Frawless"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "diffHunk": "@@ -44,152 +48,181 @@ public static JsonObject generateHttpMessages(int messageCount) {\n         return root;\n     }\n \n-    public static JsonObject sendMessagesHttpRequest(JsonObject records, String bridgeHost, int bridgePort, String topicName, WebClient client) throws InterruptedException, ExecutionException, TimeoutException {\n+    public static JsonObject sendMessagesHttpRequest(JsonObject records, String topicName, String podName) {\n         LOGGER.info(\"Sending records to KafkaBridge\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94b5a538c0953bf8115691eca3bbf08dfccc4d6c"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU4NjYwNQ==", "bodyText": "same as above", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r471586605", "createdAt": "2020-08-17T16:11:32Z", "author": {"login": "im-konge"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "diffHunk": "@@ -44,152 +48,181 @@ public static JsonObject generateHttpMessages(int messageCount) {\n         return root;\n     }\n \n-    public static JsonObject sendMessagesHttpRequest(JsonObject records, String bridgeHost, int bridgePort, String topicName, WebClient client) throws InterruptedException, ExecutionException, TimeoutException {\n+    public static JsonObject sendMessagesHttpRequest(JsonObject records, String topicName, String podName) {\n         LOGGER.info(\"Sending records to KafkaBridge\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU3MTY3NA=="}, "originalCommit": {"oid": "94b5a538c0953bf8115691eca3bbf08dfccc4d6c"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NzU4MTgwOnYy", "diffSide": "RIGHT", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNTo0ODo1N1rOHBufFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjoxMTo1MlrOHBvX3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU3MjI0NA==", "bodyText": "you should use bridge service address", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r471572244", "createdAt": "2020-08-17T15:48:57Z", "author": {"login": "Frawless"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "diffHunk": "@@ -4,31 +4,35 @@\n  */\n package io.strimzi.systemtest.utils.specific;\n \n-import io.netty.handler.codec.http.HttpResponseStatus;\n import io.strimzi.systemtest.Constants;\n import io.strimzi.systemtest.utils.HttpUtils;\n import io.strimzi.test.TestUtils;\n-import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n import io.vertx.core.json.JsonArray;\n import io.vertx.core.json.JsonObject;\n-import io.vertx.ext.web.client.HttpResponse;\n-import io.vertx.ext.web.client.WebClient;\n-import io.vertx.ext.web.codec.BodyCodec;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n import java.io.InputStream;\n import java.util.Collections;\n import java.util.Map;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.strimzi.systemtest.resources.ResourceManager.cmdKubeClient;\n \n public class BridgeUtils {\n \n     private static final Logger LOGGER = LogManager.getLogger(HttpUtils.class);\n \n+    public static final Pattern ALL_BEFORE_JSON_PATTERN = Pattern.compile(\"(.*\\\\s)\\\\{\", Pattern.DOTALL);\n+    private static final Pattern ALL_BEFORE_JSON_ARRAY_PATTERN = Pattern.compile(\"(.*\\\\s)\\\\[\", Pattern.DOTALL);\n+\n+    public static final String DEFAULT_BRIDGE_HOST = \"localhost:\" + Constants.HTTP_BRIDGE_DEFAULT_PORT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94b5a538c0953bf8115691eca3bbf08dfccc4d6c"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU4Njc4MA==", "bodyText": "already changed", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r471586780", "createdAt": "2020-08-17T16:11:52Z", "author": {"login": "im-konge"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "diffHunk": "@@ -4,31 +4,35 @@\n  */\n package io.strimzi.systemtest.utils.specific;\n \n-import io.netty.handler.codec.http.HttpResponseStatus;\n import io.strimzi.systemtest.Constants;\n import io.strimzi.systemtest.utils.HttpUtils;\n import io.strimzi.test.TestUtils;\n-import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n import io.vertx.core.json.JsonArray;\n import io.vertx.core.json.JsonObject;\n-import io.vertx.ext.web.client.HttpResponse;\n-import io.vertx.ext.web.client.WebClient;\n-import io.vertx.ext.web.codec.BodyCodec;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n import java.io.InputStream;\n import java.util.Collections;\n import java.util.Map;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.strimzi.systemtest.resources.ResourceManager.cmdKubeClient;\n \n public class BridgeUtils {\n \n     private static final Logger LOGGER = LogManager.getLogger(HttpUtils.class);\n \n+    public static final Pattern ALL_BEFORE_JSON_PATTERN = Pattern.compile(\"(.*\\\\s)\\\\{\", Pattern.DOTALL);\n+    private static final Pattern ALL_BEFORE_JSON_ARRAY_PATTERN = Pattern.compile(\"(.*\\\\s)\\\\[\", Pattern.DOTALL);\n+\n+    public static final String DEFAULT_BRIDGE_HOST = \"localhost:\" + Constants.HTTP_BRIDGE_DEFAULT_PORT;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU3MjI0NA=="}, "originalCommit": {"oid": "94b5a538c0953bf8115691eca3bbf08dfccc4d6c"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDgxODUyOnYy", "diffSide": "RIGHT", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/ClientUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDoyNjozNVrOHCNQqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDo0ODo1M1rOHCN8jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NjQ1Ng==", "bodyText": "Change commend ? :)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472076456", "createdAt": "2020-08-18T10:26:35Z", "author": {"login": "see-quick"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/ClientUtils.java", "diffHunk": "@@ -62,7 +62,7 @@ public static void waitForClientSuccess(String jobName, String namespace, int me\n \n     private static long timeoutForClientFinishJob(int messagesCount) {\n         // need to add at least 1-2minutes for finishing the job", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4NzY5Mw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472087693", "createdAt": "2020-08-18T10:48:53Z", "author": {"login": "im-konge"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/ClientUtils.java", "diffHunk": "@@ -62,7 +62,7 @@ public static void waitForClientSuccess(String jobName, String namespace, int me\n \n     private static long timeoutForClientFinishJob(int messagesCount) {\n         // need to add at least 1-2minutes for finishing the job", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NjQ1Ng=="}, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDgyNjI0OnYy", "diffSide": "RIGHT", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDoyOToxMVrOHCNViw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMTo1Mjo0NlrOHCP58A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NzcwNw==", "bodyText": "I would prefer called it buildCurlCommand but it's just  suggestion.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472077707", "createdAt": "2020-08-18T10:29:11Z", "author": {"login": "see-quick"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "diffHunk": "@@ -4,192 +4,76 @@\n  */\n package io.strimzi.systemtest.utils.specific;\n \n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.strimzi.systemtest.Constants;\n import io.strimzi.systemtest.utils.HttpUtils;\n import io.strimzi.test.TestUtils;\n-import io.vertx.core.MultiMap;\n-import io.vertx.core.json.JsonArray;\n-import io.vertx.core.json.JsonObject;\n-import io.vertx.ext.web.client.HttpResponse;\n-import io.vertx.ext.web.client.WebClient;\n-import io.vertx.ext.web.codec.BodyCodec;\n+import io.vertx.core.http.HttpMethod;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n import java.io.InputStream;\n-import java.util.Collections;\n import java.util.Map;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.strimzi.systemtest.resources.ResourceManager.cmdKubeClient;\n \n public class BridgeUtils {\n \n     private static final Logger LOGGER = LogManager.getLogger(HttpUtils.class);\n \n     private BridgeUtils() { }\n \n-    public static JsonObject generateHttpMessages(int messageCount) {\n-        LOGGER.info(\"Creating {} records for KafkaBridge\", messageCount);\n-        JsonArray records = new JsonArray();\n-        JsonObject json = new JsonObject();\n-        for (int i = 0; i < messageCount; i++) {\n-            json.put(\"value\", \"msg_\" + i);\n-            records.add(json);\n+    public static String getCurlCommand(HttpMethod httpMethod, String url, String headers, String data) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjExOTc5Mg==", "bodyText": "I have another suggestion, but it's just that. You could also check that data has to be empty when the method is not  PUT or POST.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472119792", "createdAt": "2020-08-18T11:52:46Z", "author": {"login": "ppatierno"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "diffHunk": "@@ -4,192 +4,76 @@\n  */\n package io.strimzi.systemtest.utils.specific;\n \n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.strimzi.systemtest.Constants;\n import io.strimzi.systemtest.utils.HttpUtils;\n import io.strimzi.test.TestUtils;\n-import io.vertx.core.MultiMap;\n-import io.vertx.core.json.JsonArray;\n-import io.vertx.core.json.JsonObject;\n-import io.vertx.ext.web.client.HttpResponse;\n-import io.vertx.ext.web.client.WebClient;\n-import io.vertx.ext.web.codec.BodyCodec;\n+import io.vertx.core.http.HttpMethod;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n import java.io.InputStream;\n-import java.util.Collections;\n import java.util.Map;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.strimzi.systemtest.resources.ResourceManager.cmdKubeClient;\n \n public class BridgeUtils {\n \n     private static final Logger LOGGER = LogManager.getLogger(HttpUtils.class);\n \n     private BridgeUtils() { }\n \n-    public static JsonObject generateHttpMessages(int messageCount) {\n-        LOGGER.info(\"Creating {} records for KafkaBridge\", messageCount);\n-        JsonArray records = new JsonArray();\n-        JsonObject json = new JsonObject();\n-        for (int i = 0; i < messageCount; i++) {\n-            json.put(\"value\", \"msg_\" + i);\n-            records.add(json);\n+    public static String getCurlCommand(HttpMethod httpMethod, String url, String headers, String data) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NzcwNw=="}, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDg0NjU3OnYy", "diffSide": "RIGHT", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDozNTowOFrOHCNhtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDozNTowOFrOHCNhtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4MDgyMg==", "bodyText": "I know that the base idea was good. In a practise if you create method, which has one line to encapsulate some logic. You can end-up having these one-liners with different names but most likely same behaviour. Wouldn't you think that having:\ncmdKubeClient().execInPod(podName, \"/bin/bash\", \"-c\", BridgeUtils.getCurlCommand(httpMethod, url, headers, data)).out().trim();\n\nwill be better?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472080822", "createdAt": "2020-08-18T10:35:08Z", "author": {"login": "see-quick"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "diffHunk": "@@ -4,192 +4,76 @@\n  */\n package io.strimzi.systemtest.utils.specific;\n \n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.strimzi.systemtest.Constants;\n import io.strimzi.systemtest.utils.HttpUtils;\n import io.strimzi.test.TestUtils;\n-import io.vertx.core.MultiMap;\n-import io.vertx.core.json.JsonArray;\n-import io.vertx.core.json.JsonObject;\n-import io.vertx.ext.web.client.HttpResponse;\n-import io.vertx.ext.web.client.WebClient;\n-import io.vertx.ext.web.codec.BodyCodec;\n+import io.vertx.core.http.HttpMethod;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n import java.io.InputStream;\n-import java.util.Collections;\n import java.util.Map;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.strimzi.systemtest.resources.ResourceManager.cmdKubeClient;\n \n public class BridgeUtils {\n \n     private static final Logger LOGGER = LogManager.getLogger(HttpUtils.class);\n \n     private BridgeUtils() { }\n \n-    public static JsonObject generateHttpMessages(int messageCount) {\n-        LOGGER.info(\"Creating {} records for KafkaBridge\", messageCount);\n-        JsonArray records = new JsonArray();\n-        JsonObject json = new JsonObject();\n-        for (int i = 0; i < messageCount; i++) {\n-            json.put(\"value\", \"msg_\" + i);\n-            records.add(json);\n+    public static String getCurlCommand(HttpMethod httpMethod, String url, String headers, String data) {\n+        String command = \"curl -X \" + httpMethod.toString() + \" -D - \" + url + \" \" + headers;\n+\n+        if (!data.equals(\"\")) {\n+            command += \" -d \" + \"'\" + data + \"'\";\n         }\n-        JsonObject root = new JsonObject();\n-        root.put(\"records\", records);\n-        return root;\n-    }\n \n-    public static JsonObject sendMessagesHttpRequest(JsonObject records, String bridgeHost, int bridgePort, String topicName, WebClient client) throws InterruptedException, ExecutionException, TimeoutException {\n-        LOGGER.info(\"Sending records to KafkaBridge\");\n-        CompletableFuture<JsonObject> future = new CompletableFuture<>();\n-        client.post(bridgePort, bridgeHost, \"/topics/\" + topicName)\n-            .putHeader(\"Content-length\", String.valueOf(records.toBuffer().length()))\n-            .putHeader(\"Content-Type\", Constants.KAFKA_BRIDGE_JSON_JSON)\n-            .as(BodyCodec.jsonObject())\n-            .sendJsonObject(records, ar -> {\n-                if (ar.succeeded()) {\n-                    HttpResponse<JsonObject> response = ar.result();\n-                    if (response.statusCode() == HttpResponseStatus.OK.code()) {\n-                        LOGGER.debug(\"Server accepted post\");\n-                        future.complete(response.body());\n-                    } else {\n-                        LOGGER.error(\"Server didn't accept post\", ar.cause());\n-                    }\n-                } else {\n-                    LOGGER.error(\"Server didn't accept post\", ar.cause());\n-                    future.completeExceptionally(ar.cause());\n-                }\n-            });\n-        return future.get(1, TimeUnit.MINUTES);\n+        return command;\n     }\n \n-    public static JsonArray receiveMessagesHttpRequest(String bridgeHost, int bridgePort, String groupID, String name, WebClient client) throws Exception {\n-        CompletableFuture<JsonArray> future = new CompletableFuture<>();\n-        client.get(bridgePort, bridgeHost, \"/consumers/\" + groupID + \"/instances/\" + name + \"/records?timeout=\" + 1000)\n-            .putHeader(\"Accept\", Constants.KAFKA_BRIDGE_JSON_JSON)\n-            .as(BodyCodec.jsonArray())\n-            .send(ar -> {\n-                if (ar.succeeded() && ar.result().statusCode() == 200) {\n-                    HttpResponse<JsonArray> response = ar.result();\n-                    if (response.body().size() > 0) {\n-                        for (int i = 0; i < response.body().size(); i++) {\n-                            JsonObject jsonResponse = response.body().getJsonObject(i);\n-                            LOGGER.info(\"JsonResponse: {}\", jsonResponse.toString());\n-                            String kafkaTopic = jsonResponse.getString(\"topic\");\n-                            int kafkaPartition = jsonResponse.getInteger(\"partition\");\n-                            String key = jsonResponse.getString(\"key\");\n-                            Object value = jsonResponse.getValue(\"value\");\n-                            long offset = jsonResponse.getLong(\"offset\");\n-                            LOGGER.debug(\"Received msg: topic:{} partition:{} key:{} value:{} offset{}\", kafkaTopic, kafkaPartition, key, value, offset);\n-                        }\n-                        LOGGER.info(\"Received {} messages from KafkaBridge\", response.body().size());\n-                    } else {\n-                        LOGGER.warn(\"Received body 0 messages: {}\", response.body());\n-                    }\n-                    future.complete(response.body());\n-                } else {\n-                    LOGGER.info(\"Cannot consume any messages!\", ar.cause());\n-                    future.completeExceptionally(ar.cause());\n-                }\n-            });\n-        return future.get(1, TimeUnit.MINUTES);\n+    public static String executeCurlCommand(HttpMethod httpMethod, String podName, String url, String headers) {\n+        return executeCurlCommand(httpMethod, podName, \"\", url, headers);\n     }\n \n-    public static boolean subscribeHttpConsumer(JsonObject topics, String bridgeHost, int bridgePort, String groupId,\n-                                                String name, WebClient client, Map<String, String> additionalHeaders) throws InterruptedException, ExecutionException, TimeoutException {\n-\n-        MultiMap headers = MultiMap.caseInsensitiveMultiMap()\n-            .add(\"Content-length\", String.valueOf(topics.toBuffer().length()))\n-            .add(\"Content-type\", Constants.KAFKA_BRIDGE_JSON);\n-\n-        for (Map.Entry<String, String> header : additionalHeaders.entrySet()) {\n-            LOGGER.info(\"Adding header {} -> {}\", header.getKey(), header.getValue());\n-            headers.add(header.getKey(), header.getValue());\n-        }\n-\n-        CompletableFuture<Boolean> future = new CompletableFuture<>();\n-\n-        client.post(bridgePort, bridgeHost,  \"/consumers/\" + groupId + \"/instances/\" + name + \"/subscription\")\n-            .putHeaders(headers)\n-            .as(BodyCodec.jsonObject())\n-            .sendJsonObject(topics, ar -> {\n-                LOGGER.info(ar.result());\n-\n-                if (ar.succeeded() && ar.result().statusCode() == 204) {\n-                    LOGGER.info(\"Consumer subscribed\");\n-                    future.complete(ar.succeeded());\n-                } else {\n-                    LOGGER.error(\"Cannot subscribe consumer\", ar.cause());\n-                    future.completeExceptionally(ar.cause());\n-                }\n-            });\n-        return future.get(1, TimeUnit.MINUTES);\n+    public static String executeCurlCommand(HttpMethod httpMethod, String podName, String data, String url, String headers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDg3MzczOnYy", "diffSide": "LEFT", "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeScramShaST.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDo0MzozN1rOHCNyew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDo1MjoxNlrOHCODBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4NTExNQ==", "bodyText": "The point of this test was to send the encrypted (tls) and moreover with support of simple authentication (scram-sha). You have changed to plain communication. Why? I am assuming that you wanted to just test thee scram-sha with plain communication. If this is the case please change the name of the test :)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472085115", "createdAt": "2020-08-18T10:43:37Z", "author": {"login": "see-quick"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeScramShaST.java", "diffHunk": "@@ -4,225 +4,115 @@\n  */\n package io.strimzi.systemtest.bridge;\n \n-import io.fabric8.kubernetes.api.model.Service;\n-import io.strimzi.api.kafka.model.CertSecretSource;\n import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.api.kafka.model.KafkaUser;\n import io.strimzi.api.kafka.model.PasswordSecretSource;\n import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationScramSha512;\n-import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n-import io.strimzi.api.kafka.model.listener.KafkaListenerTls;\n-import io.strimzi.systemtest.Constants;\n-import io.strimzi.systemtest.kafkaclients.externalClients.BasicExternalKafkaClient;\n-import io.strimzi.systemtest.utils.kafkaUtils.KafkaBridgeUtils;\n-import io.strimzi.systemtest.utils.kubeUtils.objects.ServiceUtils;\n-import io.strimzi.systemtest.utils.specific.BridgeUtils;\n-import io.vertx.core.json.JsonArray;\n-import io.vertx.core.json.JsonObject;\n-import io.vertx.junit5.VertxExtension;\n+import io.strimzi.systemtest.kafkaclients.internalClients.InternalKafkaClient;\n+import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n+import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n+import io.strimzi.systemtest.utils.ClientUtils;\n import org.apache.kafka.clients.consumer.ConsumerConfig;\n-import org.apache.kafka.common.security.auth.SecurityProtocol;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-import io.strimzi.systemtest.resources.KubernetesResource;\n-import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n-import io.strimzi.systemtest.resources.crd.KafkaResource;\n-import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n-import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n \n-import static io.strimzi.systemtest.Constants.BRIDGE;\n-import static io.strimzi.systemtest.Constants.EXTERNAL_CLIENTS_USED;\n-import static io.strimzi.systemtest.Constants.NODEPORT_SUPPORTED;\n-import static io.strimzi.systemtest.Constants.REGRESSION;\n-import static io.strimzi.systemtest.bridge.HttpBridgeST.NAMESPACE;\n+import static io.strimzi.systemtest.Constants.INTERNAL_CLIENTS_USED;\n import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n \n-@Tag(BRIDGE)\n-@Tag(REGRESSION)\n-@Tag(NODEPORT_SUPPORTED)\n-@Tag(EXTERNAL_CLIENTS_USED)\n-@ExtendWith(VertxExtension.class)\n+@Tag(INTERNAL_CLIENTS_USED)\n class HttpBridgeScramShaST extends HttpBridgeAbstractST {\n     private static final Logger LOGGER = LogManager.getLogger(HttpBridgeScramShaST.class);\n+    private static final String NAMESPACE = \"bridge-scram-sha-cluster-test\";\n \n-    private String bridgeHost = \"\";\n-    private int bridgePort = Constants.HTTP_BRIDGE_DEFAULT_PORT;\n+    private String kafkaClientsPodName;\n \n     @Test\n-    void testSendSimpleMessageTlsScramSha() throws Exception {\n-        int messageCount = 50;\n+    void testSendSimpleMessageTlsScramSha() {\n         // Create topic\n         KafkaTopicResource.topic(CLUSTER_NAME, TOPIC_NAME).done();\n \n-        JsonObject records = BridgeUtils.generateHttpMessages(messageCount);\n-        JsonObject response = BridgeUtils.sendMessagesHttpRequest(records, bridgeHost, bridgePort, TOPIC_NAME, client);\n-        KafkaBridgeUtils.checkSendResponse(response, messageCount);\n+        KafkaClientsResource.producerStrimziBridge(producerName, bridgeServiceName, bridgePort, TOPIC_NAME, MESSAGE_COUNT).done();\n+        ClientUtils.waitForClientSuccess(producerName, NAMESPACE, MESSAGE_COUNT);\n \n-        BasicExternalKafkaClient kafkaClient = new BasicExternalKafkaClient.Builder()\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n             .withTopicName(TOPIC_NAME)\n             .withNamespaceName(NAMESPACE)\n             .withClusterName(CLUSTER_NAME)\n+            .withMessageCount(MESSAGE_COUNT)\n             .withKafkaUsername(USER_NAME)\n-            .withMessageCount(messageCount)\n-            .withSecurityProtocol(SecurityProtocol.SASL_SSL)\n+            .withUsingPodName(kafkaClientsPodName)\n             .build();\n \n-        assertThat(kafkaClient.receiveMessagesTls(), is(messageCount));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4OTM0OQ==", "bodyText": "My bad! I will change it :) thanks", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472089349", "createdAt": "2020-08-18T10:52:16Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeScramShaST.java", "diffHunk": "@@ -4,225 +4,115 @@\n  */\n package io.strimzi.systemtest.bridge;\n \n-import io.fabric8.kubernetes.api.model.Service;\n-import io.strimzi.api.kafka.model.CertSecretSource;\n import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.api.kafka.model.KafkaUser;\n import io.strimzi.api.kafka.model.PasswordSecretSource;\n import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationScramSha512;\n-import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n-import io.strimzi.api.kafka.model.listener.KafkaListenerTls;\n-import io.strimzi.systemtest.Constants;\n-import io.strimzi.systemtest.kafkaclients.externalClients.BasicExternalKafkaClient;\n-import io.strimzi.systemtest.utils.kafkaUtils.KafkaBridgeUtils;\n-import io.strimzi.systemtest.utils.kubeUtils.objects.ServiceUtils;\n-import io.strimzi.systemtest.utils.specific.BridgeUtils;\n-import io.vertx.core.json.JsonArray;\n-import io.vertx.core.json.JsonObject;\n-import io.vertx.junit5.VertxExtension;\n+import io.strimzi.systemtest.kafkaclients.internalClients.InternalKafkaClient;\n+import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n+import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n+import io.strimzi.systemtest.utils.ClientUtils;\n import org.apache.kafka.clients.consumer.ConsumerConfig;\n-import org.apache.kafka.common.security.auth.SecurityProtocol;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-import io.strimzi.systemtest.resources.KubernetesResource;\n-import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n-import io.strimzi.systemtest.resources.crd.KafkaResource;\n-import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n-import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n \n-import static io.strimzi.systemtest.Constants.BRIDGE;\n-import static io.strimzi.systemtest.Constants.EXTERNAL_CLIENTS_USED;\n-import static io.strimzi.systemtest.Constants.NODEPORT_SUPPORTED;\n-import static io.strimzi.systemtest.Constants.REGRESSION;\n-import static io.strimzi.systemtest.bridge.HttpBridgeST.NAMESPACE;\n+import static io.strimzi.systemtest.Constants.INTERNAL_CLIENTS_USED;\n import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n \n-@Tag(BRIDGE)\n-@Tag(REGRESSION)\n-@Tag(NODEPORT_SUPPORTED)\n-@Tag(EXTERNAL_CLIENTS_USED)\n-@ExtendWith(VertxExtension.class)\n+@Tag(INTERNAL_CLIENTS_USED)\n class HttpBridgeScramShaST extends HttpBridgeAbstractST {\n     private static final Logger LOGGER = LogManager.getLogger(HttpBridgeScramShaST.class);\n+    private static final String NAMESPACE = \"bridge-scram-sha-cluster-test\";\n \n-    private String bridgeHost = \"\";\n-    private int bridgePort = Constants.HTTP_BRIDGE_DEFAULT_PORT;\n+    private String kafkaClientsPodName;\n \n     @Test\n-    void testSendSimpleMessageTlsScramSha() throws Exception {\n-        int messageCount = 50;\n+    void testSendSimpleMessageTlsScramSha() {\n         // Create topic\n         KafkaTopicResource.topic(CLUSTER_NAME, TOPIC_NAME).done();\n \n-        JsonObject records = BridgeUtils.generateHttpMessages(messageCount);\n-        JsonObject response = BridgeUtils.sendMessagesHttpRequest(records, bridgeHost, bridgePort, TOPIC_NAME, client);\n-        KafkaBridgeUtils.checkSendResponse(response, messageCount);\n+        KafkaClientsResource.producerStrimziBridge(producerName, bridgeServiceName, bridgePort, TOPIC_NAME, MESSAGE_COUNT).done();\n+        ClientUtils.waitForClientSuccess(producerName, NAMESPACE, MESSAGE_COUNT);\n \n-        BasicExternalKafkaClient kafkaClient = new BasicExternalKafkaClient.Builder()\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n             .withTopicName(TOPIC_NAME)\n             .withNamespaceName(NAMESPACE)\n             .withClusterName(CLUSTER_NAME)\n+            .withMessageCount(MESSAGE_COUNT)\n             .withKafkaUsername(USER_NAME)\n-            .withMessageCount(messageCount)\n-            .withSecurityProtocol(SecurityProtocol.SASL_SSL)\n+            .withUsingPodName(kafkaClientsPodName)\n             .build();\n \n-        assertThat(kafkaClient.receiveMessagesTls(), is(messageCount));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4NTExNQ=="}, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDg4MzQyOnYy", "diffSide": "LEFT", "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeTlsST.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDo0Njo0N1rOHCN4Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMjo0NTo1N1rOHCR_8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4NjYyMw==", "bodyText": "Why do you remove BRIDGE + REGRESSION tag?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472086623", "createdAt": "2020-08-18T10:46:47Z", "author": {"login": "see-quick"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeTlsST.java", "diffHunk": "@@ -4,191 +4,102 @@\n  */\n package io.strimzi.systemtest.bridge;\n \n-import io.fabric8.kubernetes.api.model.Service;\n import io.strimzi.api.kafka.model.CertSecretSource;\n import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.api.kafka.model.KafkaUser;\n import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n-import io.strimzi.systemtest.Constants;\n-import io.strimzi.systemtest.kafkaclients.externalClients.BasicExternalKafkaClient;\n-import io.strimzi.systemtest.utils.kafkaUtils.KafkaBridgeUtils;\n-import io.strimzi.systemtest.utils.kafkaUtils.KafkaTopicUtils;\n-import io.strimzi.systemtest.utils.kubeUtils.objects.ServiceUtils;\n-import io.strimzi.systemtest.utils.specific.BridgeUtils;\n-import io.vertx.core.json.JsonArray;\n-import io.vertx.core.json.JsonObject;\n-import io.vertx.junit5.VertxExtension;\n+import io.strimzi.systemtest.kafkaclients.internalClients.InternalKafkaClient;\n+import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n+import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n+import io.strimzi.systemtest.utils.ClientUtils;\n import org.apache.kafka.clients.consumer.ConsumerConfig;\n import org.apache.kafka.common.security.auth.SecurityProtocol;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-import io.strimzi.systemtest.resources.KubernetesResource;\n-import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n-import io.strimzi.systemtest.resources.crd.KafkaResource;\n-import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n-import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n \n import static io.strimzi.systemtest.Constants.ACCEPTANCE;\n-import static io.strimzi.systemtest.Constants.BRIDGE;\n-import static io.strimzi.systemtest.Constants.EXTERNAL_CLIENTS_USED;\n-import static io.strimzi.systemtest.Constants.NODEPORT_SUPPORTED;\n-import static io.strimzi.systemtest.Constants.REGRESSION;\n-import static io.strimzi.systemtest.bridge.HttpBridgeST.NAMESPACE;\n+import static io.strimzi.systemtest.Constants.INTERNAL_CLIENTS_USED;\n import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n \n-@Tag(BRIDGE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4OTE1OQ==", "bodyText": "It takes all tags from HttpAbstractST, so adding it here is not necessary.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472089159", "createdAt": "2020-08-18T10:51:53Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeTlsST.java", "diffHunk": "@@ -4,191 +4,102 @@\n  */\n package io.strimzi.systemtest.bridge;\n \n-import io.fabric8.kubernetes.api.model.Service;\n import io.strimzi.api.kafka.model.CertSecretSource;\n import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.api.kafka.model.KafkaUser;\n import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n-import io.strimzi.systemtest.Constants;\n-import io.strimzi.systemtest.kafkaclients.externalClients.BasicExternalKafkaClient;\n-import io.strimzi.systemtest.utils.kafkaUtils.KafkaBridgeUtils;\n-import io.strimzi.systemtest.utils.kafkaUtils.KafkaTopicUtils;\n-import io.strimzi.systemtest.utils.kubeUtils.objects.ServiceUtils;\n-import io.strimzi.systemtest.utils.specific.BridgeUtils;\n-import io.vertx.core.json.JsonArray;\n-import io.vertx.core.json.JsonObject;\n-import io.vertx.junit5.VertxExtension;\n+import io.strimzi.systemtest.kafkaclients.internalClients.InternalKafkaClient;\n+import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n+import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n+import io.strimzi.systemtest.utils.ClientUtils;\n import org.apache.kafka.clients.consumer.ConsumerConfig;\n import org.apache.kafka.common.security.auth.SecurityProtocol;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-import io.strimzi.systemtest.resources.KubernetesResource;\n-import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n-import io.strimzi.systemtest.resources.crd.KafkaResource;\n-import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n-import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n \n import static io.strimzi.systemtest.Constants.ACCEPTANCE;\n-import static io.strimzi.systemtest.Constants.BRIDGE;\n-import static io.strimzi.systemtest.Constants.EXTERNAL_CLIENTS_USED;\n-import static io.strimzi.systemtest.Constants.NODEPORT_SUPPORTED;\n-import static io.strimzi.systemtest.Constants.REGRESSION;\n-import static io.strimzi.systemtest.bridge.HttpBridgeST.NAMESPACE;\n+import static io.strimzi.systemtest.Constants.INTERNAL_CLIENTS_USED;\n import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n \n-@Tag(BRIDGE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4NjYyMw=="}, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5NzYwOA==", "bodyText": "I wonder if we should keep it in all classes instead of inheriting it. It's a little bit confusing.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472097608", "createdAt": "2020-08-18T11:08:58Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeTlsST.java", "diffHunk": "@@ -4,191 +4,102 @@\n  */\n package io.strimzi.systemtest.bridge;\n \n-import io.fabric8.kubernetes.api.model.Service;\n import io.strimzi.api.kafka.model.CertSecretSource;\n import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.api.kafka.model.KafkaUser;\n import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n-import io.strimzi.systemtest.Constants;\n-import io.strimzi.systemtest.kafkaclients.externalClients.BasicExternalKafkaClient;\n-import io.strimzi.systemtest.utils.kafkaUtils.KafkaBridgeUtils;\n-import io.strimzi.systemtest.utils.kafkaUtils.KafkaTopicUtils;\n-import io.strimzi.systemtest.utils.kubeUtils.objects.ServiceUtils;\n-import io.strimzi.systemtest.utils.specific.BridgeUtils;\n-import io.vertx.core.json.JsonArray;\n-import io.vertx.core.json.JsonObject;\n-import io.vertx.junit5.VertxExtension;\n+import io.strimzi.systemtest.kafkaclients.internalClients.InternalKafkaClient;\n+import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n+import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n+import io.strimzi.systemtest.utils.ClientUtils;\n import org.apache.kafka.clients.consumer.ConsumerConfig;\n import org.apache.kafka.common.security.auth.SecurityProtocol;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-import io.strimzi.systemtest.resources.KubernetesResource;\n-import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n-import io.strimzi.systemtest.resources.crd.KafkaResource;\n-import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n-import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n \n import static io.strimzi.systemtest.Constants.ACCEPTANCE;\n-import static io.strimzi.systemtest.Constants.BRIDGE;\n-import static io.strimzi.systemtest.Constants.EXTERNAL_CLIENTS_USED;\n-import static io.strimzi.systemtest.Constants.NODEPORT_SUPPORTED;\n-import static io.strimzi.systemtest.Constants.REGRESSION;\n-import static io.strimzi.systemtest.bridge.HttpBridgeST.NAMESPACE;\n+import static io.strimzi.systemtest.Constants.INTERNAL_CLIENTS_USED;\n import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n \n-@Tag(BRIDGE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4NjYyMw=="}, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE1NDA5OA==", "bodyText": "I'm gonna add it back and remove the inheritance.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472154098", "createdAt": "2020-08-18T12:45:57Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeTlsST.java", "diffHunk": "@@ -4,191 +4,102 @@\n  */\n package io.strimzi.systemtest.bridge;\n \n-import io.fabric8.kubernetes.api.model.Service;\n import io.strimzi.api.kafka.model.CertSecretSource;\n import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.api.kafka.model.KafkaUser;\n import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n-import io.strimzi.systemtest.Constants;\n-import io.strimzi.systemtest.kafkaclients.externalClients.BasicExternalKafkaClient;\n-import io.strimzi.systemtest.utils.kafkaUtils.KafkaBridgeUtils;\n-import io.strimzi.systemtest.utils.kafkaUtils.KafkaTopicUtils;\n-import io.strimzi.systemtest.utils.kubeUtils.objects.ServiceUtils;\n-import io.strimzi.systemtest.utils.specific.BridgeUtils;\n-import io.vertx.core.json.JsonArray;\n-import io.vertx.core.json.JsonObject;\n-import io.vertx.junit5.VertxExtension;\n+import io.strimzi.systemtest.kafkaclients.internalClients.InternalKafkaClient;\n+import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n+import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n+import io.strimzi.systemtest.utils.ClientUtils;\n import org.apache.kafka.clients.consumer.ConsumerConfig;\n import org.apache.kafka.common.security.auth.SecurityProtocol;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-import io.strimzi.systemtest.resources.KubernetesResource;\n-import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n-import io.strimzi.systemtest.resources.crd.KafkaResource;\n-import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n-import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n \n import static io.strimzi.systemtest.Constants.ACCEPTANCE;\n-import static io.strimzi.systemtest.Constants.BRIDGE;\n-import static io.strimzi.systemtest.Constants.EXTERNAL_CLIENTS_USED;\n-import static io.strimzi.systemtest.Constants.NODEPORT_SUPPORTED;\n-import static io.strimzi.systemtest.Constants.REGRESSION;\n-import static io.strimzi.systemtest.bridge.HttpBridgeST.NAMESPACE;\n+import static io.strimzi.systemtest.Constants.INTERNAL_CLIENTS_USED;\n import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n \n-@Tag(BRIDGE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4NjYyMw=="}, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDkyMDQ2OnYy", "diffSide": "RIGHT", "path": "systemtest/src/main/java/io/strimzi/systemtest/kafkaclients/internalClients/ClientArgument.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDo1ODozNVrOHCOPpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNDoyMzo1OVrOHCXCOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5MjU4MA==", "bodyText": "Does it work with Kafka 2.5.x ?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472092580", "createdAt": "2020-08-18T10:58:35Z", "author": {"login": "Frawless"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/kafkaclients/internalClients/ClientArgument.java", "diffHunk": "@@ -23,7 +23,7 @@\n     ASSIGMENT_STRATEGY(\"--assignment-strategy\"),\n \n     // Producer\n-    BROKER_LIST(\"--broker-list\"),\n+    BOOTSTRAP_SERVER(\"--bootstrap-server\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEwMDQwOA==", "bodyText": "Yes it should, gonna test it on ocp4.x too", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472100408", "createdAt": "2020-08-18T11:14:56Z", "author": {"login": "im-konge"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/kafkaclients/internalClients/ClientArgument.java", "diffHunk": "@@ -23,7 +23,7 @@\n     ASSIGMENT_STRATEGY(\"--assignment-strategy\"),\n \n     // Producer\n-    BROKER_LIST(\"--broker-list\"),\n+    BOOTSTRAP_SERVER(\"--bootstrap-server\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5MjU4MA=="}, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIzNjYwMQ==", "bodyText": "It works", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472236601", "createdAt": "2020-08-18T14:23:59Z", "author": {"login": "im-konge"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/kafkaclients/internalClients/ClientArgument.java", "diffHunk": "@@ -23,7 +23,7 @@\n     ASSIGMENT_STRATEGY(\"--assignment-strategy\"),\n \n     // Producer\n-    BROKER_LIST(\"--broker-list\"),\n+    BOOTSTRAP_SERVER(\"--bootstrap-server\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5MjU4MA=="}, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDkyMzExOnYy", "diffSide": "RIGHT", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDo1OToyOFrOHCORQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMToxNTowM1rOHCOueg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5Mjk5NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!data.equals(\"\")) {\n          \n          \n            \n                    if (data.isEmpty()) {\n          \n          \n            \n            ``` is maybe better?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472092995", "createdAt": "2020-08-18T10:59:28Z", "author": {"login": "Frawless"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "diffHunk": "@@ -4,192 +4,76 @@\n  */\n package io.strimzi.systemtest.utils.specific;\n \n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.strimzi.systemtest.Constants;\n import io.strimzi.systemtest.utils.HttpUtils;\n import io.strimzi.test.TestUtils;\n-import io.vertx.core.MultiMap;\n-import io.vertx.core.json.JsonArray;\n-import io.vertx.core.json.JsonObject;\n-import io.vertx.ext.web.client.HttpResponse;\n-import io.vertx.ext.web.client.WebClient;\n-import io.vertx.ext.web.codec.BodyCodec;\n+import io.vertx.core.http.HttpMethod;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n import java.io.InputStream;\n-import java.util.Collections;\n import java.util.Map;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.strimzi.systemtest.resources.ResourceManager.cmdKubeClient;\n \n public class BridgeUtils {\n \n     private static final Logger LOGGER = LogManager.getLogger(HttpUtils.class);\n \n     private BridgeUtils() { }\n \n-    public static JsonObject generateHttpMessages(int messageCount) {\n-        LOGGER.info(\"Creating {} records for KafkaBridge\", messageCount);\n-        JsonArray records = new JsonArray();\n-        JsonObject json = new JsonObject();\n-        for (int i = 0; i < messageCount; i++) {\n-            json.put(\"value\", \"msg_\" + i);\n-            records.add(json);\n+    public static String getCurlCommand(HttpMethod httpMethod, String url, String headers, String data) {\n+        String command = \"curl -X \" + httpMethod.toString() + \" -D - \" + url + \" \" + headers;\n+\n+        if (!data.equals(\"\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEwMDQ3NA==", "bodyText": "but with the ! ofc :D", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472100474", "createdAt": "2020-08-18T11:15:03Z", "author": {"login": "see-quick"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "diffHunk": "@@ -4,192 +4,76 @@\n  */\n package io.strimzi.systemtest.utils.specific;\n \n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.strimzi.systemtest.Constants;\n import io.strimzi.systemtest.utils.HttpUtils;\n import io.strimzi.test.TestUtils;\n-import io.vertx.core.MultiMap;\n-import io.vertx.core.json.JsonArray;\n-import io.vertx.core.json.JsonObject;\n-import io.vertx.ext.web.client.HttpResponse;\n-import io.vertx.ext.web.client.WebClient;\n-import io.vertx.ext.web.codec.BodyCodec;\n+import io.vertx.core.http.HttpMethod;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n import java.io.InputStream;\n-import java.util.Collections;\n import java.util.Map;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.strimzi.systemtest.resources.ResourceManager.cmdKubeClient;\n \n public class BridgeUtils {\n \n     private static final Logger LOGGER = LogManager.getLogger(HttpUtils.class);\n \n     private BridgeUtils() { }\n \n-    public static JsonObject generateHttpMessages(int messageCount) {\n-        LOGGER.info(\"Creating {} records for KafkaBridge\", messageCount);\n-        JsonArray records = new JsonArray();\n-        JsonObject json = new JsonObject();\n-        for (int i = 0; i < messageCount; i++) {\n-            json.put(\"value\", \"msg_\" + i);\n-            records.add(json);\n+    public static String getCurlCommand(HttpMethod httpMethod, String url, String headers, String data) {\n+        String command = \"curl -X \" + httpMethod.toString() + \" -D - \" + url + \" \" + headers;\n+\n+        if (!data.equals(\"\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5Mjk5NQ=="}, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDkyNTI1OnYy", "diffSide": "RIGHT", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMTowMDowM1rOHCOSgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMTowMDowM1rOHCOSgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5MzMxMw==", "bodyText": "Same as above", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472093313", "createdAt": "2020-08-18T11:00:03Z", "author": {"login": "Frawless"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "diffHunk": "@@ -4,192 +4,76 @@\n  */\n package io.strimzi.systemtest.utils.specific;\n \n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.strimzi.systemtest.Constants;\n import io.strimzi.systemtest.utils.HttpUtils;\n import io.strimzi.test.TestUtils;\n-import io.vertx.core.MultiMap;\n-import io.vertx.core.json.JsonArray;\n-import io.vertx.core.json.JsonObject;\n-import io.vertx.ext.web.client.HttpResponse;\n-import io.vertx.ext.web.client.WebClient;\n-import io.vertx.ext.web.codec.BodyCodec;\n+import io.vertx.core.http.HttpMethod;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n import java.io.InputStream;\n-import java.util.Collections;\n import java.util.Map;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.strimzi.systemtest.resources.ResourceManager.cmdKubeClient;\n \n public class BridgeUtils {\n \n     private static final Logger LOGGER = LogManager.getLogger(HttpUtils.class);\n \n     private BridgeUtils() { }\n \n-    public static JsonObject generateHttpMessages(int messageCount) {\n-        LOGGER.info(\"Creating {} records for KafkaBridge\", messageCount);\n-        JsonArray records = new JsonArray();\n-        JsonObject json = new JsonObject();\n-        for (int i = 0; i < messageCount; i++) {\n-            json.put(\"value\", \"msg_\" + i);\n-            records.add(json);\n+    public static String getCurlCommand(HttpMethod httpMethod, String url, String headers, String data) {\n+        String command = \"curl -X \" + httpMethod.toString() + \" -D - \" + url + \" \" + headers;\n+\n+        if (!data.equals(\"\")) {\n+            command += \" -d \" + \"'\" + data + \"'\";\n         }\n-        JsonObject root = new JsonObject();\n-        root.put(\"records\", records);\n-        return root;\n-    }\n \n-    public static JsonObject sendMessagesHttpRequest(JsonObject records, String bridgeHost, int bridgePort, String topicName, WebClient client) throws InterruptedException, ExecutionException, TimeoutException {\n-        LOGGER.info(\"Sending records to KafkaBridge\");\n-        CompletableFuture<JsonObject> future = new CompletableFuture<>();\n-        client.post(bridgePort, bridgeHost, \"/topics/\" + topicName)\n-            .putHeader(\"Content-length\", String.valueOf(records.toBuffer().length()))\n-            .putHeader(\"Content-Type\", Constants.KAFKA_BRIDGE_JSON_JSON)\n-            .as(BodyCodec.jsonObject())\n-            .sendJsonObject(records, ar -> {\n-                if (ar.succeeded()) {\n-                    HttpResponse<JsonObject> response = ar.result();\n-                    if (response.statusCode() == HttpResponseStatus.OK.code()) {\n-                        LOGGER.debug(\"Server accepted post\");\n-                        future.complete(response.body());\n-                    } else {\n-                        LOGGER.error(\"Server didn't accept post\", ar.cause());\n-                    }\n-                } else {\n-                    LOGGER.error(\"Server didn't accept post\", ar.cause());\n-                    future.completeExceptionally(ar.cause());\n-                }\n-            });\n-        return future.get(1, TimeUnit.MINUTES);\n+        return command;\n     }\n \n-    public static JsonArray receiveMessagesHttpRequest(String bridgeHost, int bridgePort, String groupID, String name, WebClient client) throws Exception {\n-        CompletableFuture<JsonArray> future = new CompletableFuture<>();\n-        client.get(bridgePort, bridgeHost, \"/consumers/\" + groupID + \"/instances/\" + name + \"/records?timeout=\" + 1000)\n-            .putHeader(\"Accept\", Constants.KAFKA_BRIDGE_JSON_JSON)\n-            .as(BodyCodec.jsonArray())\n-            .send(ar -> {\n-                if (ar.succeeded() && ar.result().statusCode() == 200) {\n-                    HttpResponse<JsonArray> response = ar.result();\n-                    if (response.body().size() > 0) {\n-                        for (int i = 0; i < response.body().size(); i++) {\n-                            JsonObject jsonResponse = response.body().getJsonObject(i);\n-                            LOGGER.info(\"JsonResponse: {}\", jsonResponse.toString());\n-                            String kafkaTopic = jsonResponse.getString(\"topic\");\n-                            int kafkaPartition = jsonResponse.getInteger(\"partition\");\n-                            String key = jsonResponse.getString(\"key\");\n-                            Object value = jsonResponse.getValue(\"value\");\n-                            long offset = jsonResponse.getLong(\"offset\");\n-                            LOGGER.debug(\"Received msg: topic:{} partition:{} key:{} value:{} offset{}\", kafkaTopic, kafkaPartition, key, value, offset);\n-                        }\n-                        LOGGER.info(\"Received {} messages from KafkaBridge\", response.body().size());\n-                    } else {\n-                        LOGGER.warn(\"Received body 0 messages: {}\", response.body());\n-                    }\n-                    future.complete(response.body());\n-                } else {\n-                    LOGGER.info(\"Cannot consume any messages!\", ar.cause());\n-                    future.completeExceptionally(ar.cause());\n-                }\n-            });\n-        return future.get(1, TimeUnit.MINUTES);\n+    public static String executeCurlCommand(HttpMethod httpMethod, String podName, String url, String headers) {\n+        return executeCurlCommand(httpMethod, podName, \"\", url, headers);\n     }\n \n-    public static boolean subscribeHttpConsumer(JsonObject topics, String bridgeHost, int bridgePort, String groupId,\n-                                                String name, WebClient client, Map<String, String> additionalHeaders) throws InterruptedException, ExecutionException, TimeoutException {\n-\n-        MultiMap headers = MultiMap.caseInsensitiveMultiMap()\n-            .add(\"Content-length\", String.valueOf(topics.toBuffer().length()))\n-            .add(\"Content-type\", Constants.KAFKA_BRIDGE_JSON);\n-\n-        for (Map.Entry<String, String> header : additionalHeaders.entrySet()) {\n-            LOGGER.info(\"Adding header {} -> {}\", header.getKey(), header.getValue());\n-            headers.add(header.getKey(), header.getValue());\n-        }\n-\n-        CompletableFuture<Boolean> future = new CompletableFuture<>();\n-\n-        client.post(bridgePort, bridgeHost,  \"/consumers/\" + groupId + \"/instances/\" + name + \"/subscription\")\n-            .putHeaders(headers)\n-            .as(BodyCodec.jsonObject())\n-            .sendJsonObject(topics, ar -> {\n-                LOGGER.info(ar.result());\n-\n-                if (ar.succeeded() && ar.result().statusCode() == 204) {\n-                    LOGGER.info(\"Consumer subscribed\");\n-                    future.complete(ar.succeeded());\n-                } else {\n-                    LOGGER.error(\"Cannot subscribe consumer\", ar.cause());\n-                    future.completeExceptionally(ar.cause());\n-                }\n-            });\n-        return future.get(1, TimeUnit.MINUTES);\n+    public static String executeCurlCommand(HttpMethod httpMethod, String podName, String data, String url, String headers) {\n+        return cmdKubeClient().execInPod(podName, \"/bin/bash\", \"-c\", getCurlCommand(httpMethod, url, headers, data)).out().trim();\n     }\n \n-    public static boolean subscribeHttpConsumer(JsonObject topics, String bridgeHost, int bridgePort, String groupId,\n-                                                String name, WebClient client) throws InterruptedException, ExecutionException, TimeoutException {\n-        return subscribeHttpConsumer(topics, bridgeHost, bridgePort, groupId, name, client, Collections.emptyMap());\n+    public static String addHeadersToString(Map<String, String> additionalHeaders) {\n+        return addHeadersToString(additionalHeaders, \"\",  \"\");\n     }\n \n-    public static JsonObject createBridgeConsumer(JsonObject config, String bridgeHost, int bridgePort, String groupId,\n-                                                  WebClient client, Map<String, String> additionalHeaders) throws InterruptedException, ExecutionException, TimeoutException {\n+    public static String addHeadersToString(Map<String, String> additionalHeaders,  String contentType, String content) {\n+        StringBuilder headerString = new StringBuilder();\n \n-        MultiMap headers = MultiMap.caseInsensitiveMultiMap()\n-            .add(\"Content-length\", String.valueOf(config.toBuffer().length()))\n-            .add(\"Content-type\", Constants.KAFKA_BRIDGE_JSON);\n+        if (!content.equals(\"\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDkyNTU4OnYy", "diffSide": "RIGHT", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMTowMDoxMFrOHCOSvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMTowMDoxMFrOHCOSvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5MzM3Mw==", "bodyText": "same as above", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472093373", "createdAt": "2020-08-18T11:00:10Z", "author": {"login": "Frawless"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/specific/BridgeUtils.java", "diffHunk": "@@ -4,192 +4,76 @@\n  */\n package io.strimzi.systemtest.utils.specific;\n \n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.strimzi.systemtest.Constants;\n import io.strimzi.systemtest.utils.HttpUtils;\n import io.strimzi.test.TestUtils;\n-import io.vertx.core.MultiMap;\n-import io.vertx.core.json.JsonArray;\n-import io.vertx.core.json.JsonObject;\n-import io.vertx.ext.web.client.HttpResponse;\n-import io.vertx.ext.web.client.WebClient;\n-import io.vertx.ext.web.codec.BodyCodec;\n+import io.vertx.core.http.HttpMethod;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n import java.io.InputStream;\n-import java.util.Collections;\n import java.util.Map;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.strimzi.systemtest.resources.ResourceManager.cmdKubeClient;\n \n public class BridgeUtils {\n \n     private static final Logger LOGGER = LogManager.getLogger(HttpUtils.class);\n \n     private BridgeUtils() { }\n \n-    public static JsonObject generateHttpMessages(int messageCount) {\n-        LOGGER.info(\"Creating {} records for KafkaBridge\", messageCount);\n-        JsonArray records = new JsonArray();\n-        JsonObject json = new JsonObject();\n-        for (int i = 0; i < messageCount; i++) {\n-            json.put(\"value\", \"msg_\" + i);\n-            records.add(json);\n+    public static String getCurlCommand(HttpMethod httpMethod, String url, String headers, String data) {\n+        String command = \"curl -X \" + httpMethod.toString() + \" -D - \" + url + \" \" + headers;\n+\n+        if (!data.equals(\"\")) {\n+            command += \" -d \" + \"'\" + data + \"'\";\n         }\n-        JsonObject root = new JsonObject();\n-        root.put(\"records\", records);\n-        return root;\n-    }\n \n-    public static JsonObject sendMessagesHttpRequest(JsonObject records, String bridgeHost, int bridgePort, String topicName, WebClient client) throws InterruptedException, ExecutionException, TimeoutException {\n-        LOGGER.info(\"Sending records to KafkaBridge\");\n-        CompletableFuture<JsonObject> future = new CompletableFuture<>();\n-        client.post(bridgePort, bridgeHost, \"/topics/\" + topicName)\n-            .putHeader(\"Content-length\", String.valueOf(records.toBuffer().length()))\n-            .putHeader(\"Content-Type\", Constants.KAFKA_BRIDGE_JSON_JSON)\n-            .as(BodyCodec.jsonObject())\n-            .sendJsonObject(records, ar -> {\n-                if (ar.succeeded()) {\n-                    HttpResponse<JsonObject> response = ar.result();\n-                    if (response.statusCode() == HttpResponseStatus.OK.code()) {\n-                        LOGGER.debug(\"Server accepted post\");\n-                        future.complete(response.body());\n-                    } else {\n-                        LOGGER.error(\"Server didn't accept post\", ar.cause());\n-                    }\n-                } else {\n-                    LOGGER.error(\"Server didn't accept post\", ar.cause());\n-                    future.completeExceptionally(ar.cause());\n-                }\n-            });\n-        return future.get(1, TimeUnit.MINUTES);\n+        return command;\n     }\n \n-    public static JsonArray receiveMessagesHttpRequest(String bridgeHost, int bridgePort, String groupID, String name, WebClient client) throws Exception {\n-        CompletableFuture<JsonArray> future = new CompletableFuture<>();\n-        client.get(bridgePort, bridgeHost, \"/consumers/\" + groupID + \"/instances/\" + name + \"/records?timeout=\" + 1000)\n-            .putHeader(\"Accept\", Constants.KAFKA_BRIDGE_JSON_JSON)\n-            .as(BodyCodec.jsonArray())\n-            .send(ar -> {\n-                if (ar.succeeded() && ar.result().statusCode() == 200) {\n-                    HttpResponse<JsonArray> response = ar.result();\n-                    if (response.body().size() > 0) {\n-                        for (int i = 0; i < response.body().size(); i++) {\n-                            JsonObject jsonResponse = response.body().getJsonObject(i);\n-                            LOGGER.info(\"JsonResponse: {}\", jsonResponse.toString());\n-                            String kafkaTopic = jsonResponse.getString(\"topic\");\n-                            int kafkaPartition = jsonResponse.getInteger(\"partition\");\n-                            String key = jsonResponse.getString(\"key\");\n-                            Object value = jsonResponse.getValue(\"value\");\n-                            long offset = jsonResponse.getLong(\"offset\");\n-                            LOGGER.debug(\"Received msg: topic:{} partition:{} key:{} value:{} offset{}\", kafkaTopic, kafkaPartition, key, value, offset);\n-                        }\n-                        LOGGER.info(\"Received {} messages from KafkaBridge\", response.body().size());\n-                    } else {\n-                        LOGGER.warn(\"Received body 0 messages: {}\", response.body());\n-                    }\n-                    future.complete(response.body());\n-                } else {\n-                    LOGGER.info(\"Cannot consume any messages!\", ar.cause());\n-                    future.completeExceptionally(ar.cause());\n-                }\n-            });\n-        return future.get(1, TimeUnit.MINUTES);\n+    public static String executeCurlCommand(HttpMethod httpMethod, String podName, String url, String headers) {\n+        return executeCurlCommand(httpMethod, podName, \"\", url, headers);\n     }\n \n-    public static boolean subscribeHttpConsumer(JsonObject topics, String bridgeHost, int bridgePort, String groupId,\n-                                                String name, WebClient client, Map<String, String> additionalHeaders) throws InterruptedException, ExecutionException, TimeoutException {\n-\n-        MultiMap headers = MultiMap.caseInsensitiveMultiMap()\n-            .add(\"Content-length\", String.valueOf(topics.toBuffer().length()))\n-            .add(\"Content-type\", Constants.KAFKA_BRIDGE_JSON);\n-\n-        for (Map.Entry<String, String> header : additionalHeaders.entrySet()) {\n-            LOGGER.info(\"Adding header {} -> {}\", header.getKey(), header.getValue());\n-            headers.add(header.getKey(), header.getValue());\n-        }\n-\n-        CompletableFuture<Boolean> future = new CompletableFuture<>();\n-\n-        client.post(bridgePort, bridgeHost,  \"/consumers/\" + groupId + \"/instances/\" + name + \"/subscription\")\n-            .putHeaders(headers)\n-            .as(BodyCodec.jsonObject())\n-            .sendJsonObject(topics, ar -> {\n-                LOGGER.info(ar.result());\n-\n-                if (ar.succeeded() && ar.result().statusCode() == 204) {\n-                    LOGGER.info(\"Consumer subscribed\");\n-                    future.complete(ar.succeeded());\n-                } else {\n-                    LOGGER.error(\"Cannot subscribe consumer\", ar.cause());\n-                    future.completeExceptionally(ar.cause());\n-                }\n-            });\n-        return future.get(1, TimeUnit.MINUTES);\n+    public static String executeCurlCommand(HttpMethod httpMethod, String podName, String data, String url, String headers) {\n+        return cmdKubeClient().execInPod(podName, \"/bin/bash\", \"-c\", getCurlCommand(httpMethod, url, headers, data)).out().trim();\n     }\n \n-    public static boolean subscribeHttpConsumer(JsonObject topics, String bridgeHost, int bridgePort, String groupId,\n-                                                String name, WebClient client) throws InterruptedException, ExecutionException, TimeoutException {\n-        return subscribeHttpConsumer(topics, bridgeHost, bridgePort, groupId, name, client, Collections.emptyMap());\n+    public static String addHeadersToString(Map<String, String> additionalHeaders) {\n+        return addHeadersToString(additionalHeaders, \"\",  \"\");\n     }\n \n-    public static JsonObject createBridgeConsumer(JsonObject config, String bridgeHost, int bridgePort, String groupId,\n-                                                  WebClient client, Map<String, String> additionalHeaders) throws InterruptedException, ExecutionException, TimeoutException {\n+    public static String addHeadersToString(Map<String, String> additionalHeaders,  String contentType, String content) {\n+        StringBuilder headerString = new StringBuilder();\n \n-        MultiMap headers = MultiMap.caseInsensitiveMultiMap()\n-            .add(\"Content-length\", String.valueOf(config.toBuffer().length()))\n-            .add(\"Content-type\", Constants.KAFKA_BRIDGE_JSON);\n+        if (!content.equals(\"\")) {\n+            headerString.append(\" -H 'Content-length: \").append(content.length()).append(\"'\");\n+        }\n+\n+        if (!contentType.equals(\"\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDkzMTAwOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeAbstractST.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMTowMTo1N1rOHCOV_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMzowOTowNVrOHCTXqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5NDIwNQ==", "bodyText": "Wouldn't be better to use KafkaBridgeResources.url() instead just service name?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472094205", "createdAt": "2020-08-18T11:01:57Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeAbstractST.java", "diffHunk": "@@ -34,43 +22,19 @@\n @ExtendWith(VertxExtension.class)\n @Tag(BRIDGE)\n @Tag(REGRESSION)\n-@Tag(NODEPORT_SUPPORTED)\n-@Tag(EXTERNAL_CLIENTS_USED)\n public class HttpBridgeAbstractST extends AbstractST {\n-    private static final Logger LOGGER = LogManager.getLogger(HttpBridgeAbstractST.class);\n-\n-    protected WebClient client;\n-    protected String bridgeExternalService = CLUSTER_NAME + \"-bridge-external-service\";\n+    public static int bridgePort = Constants.HTTP_BRIDGE_DEFAULT_PORT;\n+    public static String bridgeHost = \"\";\n+    public static String kafkaClientsPodName = \"\";\n+    public static String bridgeServiceName = KafkaBridgeResources.serviceName(CLUSTER_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE3NjU1Mw==", "bodyText": "For this case I'm gonna add bridgeUrl var to use KafkaBridgeResources.url() method and I will keep bridgeServiceName var for example clients usage.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472176553", "createdAt": "2020-08-18T13:09:05Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeAbstractST.java", "diffHunk": "@@ -34,43 +22,19 @@\n @ExtendWith(VertxExtension.class)\n @Tag(BRIDGE)\n @Tag(REGRESSION)\n-@Tag(NODEPORT_SUPPORTED)\n-@Tag(EXTERNAL_CLIENTS_USED)\n public class HttpBridgeAbstractST extends AbstractST {\n-    private static final Logger LOGGER = LogManager.getLogger(HttpBridgeAbstractST.class);\n-\n-    protected WebClient client;\n-    protected String bridgeExternalService = CLUSTER_NAME + \"-bridge-external-service\";\n+    public static int bridgePort = Constants.HTTP_BRIDGE_DEFAULT_PORT;\n+    public static String bridgeHost = \"\";\n+    public static String kafkaClientsPodName = \"\";\n+    public static String bridgeServiceName = KafkaBridgeResources.serviceName(CLUSTER_NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5NDIwNQ=="}, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDkzMjEwOnYy", "diffSide": "RIGHT", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/ClientUtils.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMTowMjoxN1rOHCOWqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNjowOToxN1rOHCbskA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5NDM3OA==", "bodyText": "Why?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472094378", "createdAt": "2020-08-18T11:02:17Z", "author": {"login": "Frawless"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/ClientUtils.java", "diffHunk": "@@ -62,7 +62,7 @@ public static void waitForClientSuccess(String jobName, String namespace, int me\n \n     private static long timeoutForClientFinishJob(int messagesCount) {\n         // need to add at least 1-2minutes for finishing the job\n-        return (long) messagesCount * 1000 + Duration.ofMinutes(2).toMillis();\n+        return (long) messagesCount * 1000 + Duration.ofMinutes(3).toMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEwMDg3NA==", "bodyText": "In some cases the job needed one more minute on Jenkins -> on local env two minutes are sufficient ...", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472100874", "createdAt": "2020-08-18T11:15:53Z", "author": {"login": "im-konge"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/ClientUtils.java", "diffHunk": "@@ -62,7 +62,7 @@ public static void waitForClientSuccess(String jobName, String namespace, int me\n \n     private static long timeoutForClientFinishJob(int messagesCount) {\n         // need to add at least 1-2minutes for finishing the job\n-        return (long) messagesCount * 1000 + Duration.ofMinutes(2).toMillis();\n+        return (long) messagesCount * 1000 + Duration.ofMinutes(3).toMillis();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5NDM3OA=="}, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMwMzgwNQ==", "bodyText": "I wonder why it needs additional time, maybe message count and timeout between messages is not set correctly?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472303805", "createdAt": "2020-08-18T15:55:04Z", "author": {"login": "Frawless"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/ClientUtils.java", "diffHunk": "@@ -62,7 +62,7 @@ public static void waitForClientSuccess(String jobName, String namespace, int me\n \n     private static long timeoutForClientFinishJob(int messagesCount) {\n         // need to add at least 1-2minutes for finishing the job\n-        return (long) messagesCount * 1000 + Duration.ofMinutes(2).toMillis();\n+        return (long) messagesCount * 1000 + Duration.ofMinutes(3).toMillis();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5NDM3OA=="}, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMxMjk3Ng==", "bodyText": "I think that 2 minutes will be enough -> I forgot that I added the auto.reset.offset.config: earliest so I'm gonna change it back", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472312976", "createdAt": "2020-08-18T16:09:17Z", "author": {"login": "im-konge"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/ClientUtils.java", "diffHunk": "@@ -62,7 +62,7 @@ public static void waitForClientSuccess(String jobName, String namespace, int me\n \n     private static long timeoutForClientFinishJob(int messagesCount) {\n         // need to add at least 1-2minutes for finishing the job\n-        return (long) messagesCount * 1000 + Duration.ofMinutes(2).toMillis();\n+        return (long) messagesCount * 1000 + Duration.ofMinutes(3).toMillis();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5NDM3OA=="}, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDk0MDA0OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeExternalListenersST.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMTowNDo1OVrOHCObnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMTo1NTo0OFrOHCQBgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5NTY0NA==", "bodyText": "The name is kinda misleading from my POV. IT looks like bridge have external listener here, which is not true.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472095644", "createdAt": "2020-08-18T11:04:59Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeExternalListenersST.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.bridge;\n+\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.strimzi.api.kafka.model.CertSecretSource;\n+import io.strimzi.api.kafka.model.KafkaBridgeSpec;\n+import io.strimzi.api.kafka.model.KafkaBridgeSpecBuilder;\n+import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.api.kafka.model.PasswordSecretSource;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationScramSha512;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n+import io.strimzi.systemtest.Constants;\n+import io.strimzi.systemtest.kafkaclients.externalClients.BasicExternalKafkaClient;\n+import io.strimzi.systemtest.resources.KubernetesResource;\n+import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n+import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n+import io.strimzi.systemtest.utils.ClientUtils;\n+import io.strimzi.systemtest.utils.kafkaUtils.KafkaBridgeUtils;\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.common.security.auth.SecurityProtocol;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import static io.strimzi.systemtest.Constants.EXTERNAL_CLIENTS_USED;\n+import static io.strimzi.systemtest.Constants.NODEPORT_SUPPORTED;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+@Tag(NODEPORT_SUPPORTED)\n+@Tag(EXTERNAL_CLIENTS_USED)\n+class HttpBridgeExternalListenersST extends HttpBridgeAbstractST {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEyMTcyOQ==", "bodyText": "Agree", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472121729", "createdAt": "2020-08-18T11:55:48Z", "author": {"login": "ppatierno"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeExternalListenersST.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.bridge;\n+\n+import io.fabric8.kubernetes.api.model.Service;\n+import io.strimzi.api.kafka.model.CertSecretSource;\n+import io.strimzi.api.kafka.model.KafkaBridgeSpec;\n+import io.strimzi.api.kafka.model.KafkaBridgeSpecBuilder;\n+import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.api.kafka.model.PasswordSecretSource;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationScramSha512;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n+import io.strimzi.systemtest.Constants;\n+import io.strimzi.systemtest.kafkaclients.externalClients.BasicExternalKafkaClient;\n+import io.strimzi.systemtest.resources.KubernetesResource;\n+import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n+import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n+import io.strimzi.systemtest.utils.ClientUtils;\n+import io.strimzi.systemtest.utils.kafkaUtils.KafkaBridgeUtils;\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.common.security.auth.SecurityProtocol;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import static io.strimzi.systemtest.Constants.EXTERNAL_CLIENTS_USED;\n+import static io.strimzi.systemtest.Constants.NODEPORT_SUPPORTED;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+@Tag(NODEPORT_SUPPORTED)\n+@Tag(EXTERNAL_CLIENTS_USED)\n+class HttpBridgeExternalListenersST extends HttpBridgeAbstractST {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5NTY0NA=="}, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDk0NTIzOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeScramShaST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMTowNjozOVrOHCOe5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMTowNjozOVrOHCOe5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5NjQ4Ng==", "bodyText": "Same as Maros mentioned above I guess", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472096486", "createdAt": "2020-08-18T11:06:39Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeScramShaST.java", "diffHunk": "@@ -4,225 +4,115 @@\n  */\n package io.strimzi.systemtest.bridge;\n \n-import io.fabric8.kubernetes.api.model.Service;\n-import io.strimzi.api.kafka.model.CertSecretSource;\n import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.api.kafka.model.KafkaUser;\n import io.strimzi.api.kafka.model.PasswordSecretSource;\n import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationScramSha512;\n-import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n-import io.strimzi.api.kafka.model.listener.KafkaListenerTls;\n-import io.strimzi.systemtest.Constants;\n-import io.strimzi.systemtest.kafkaclients.externalClients.BasicExternalKafkaClient;\n-import io.strimzi.systemtest.utils.kafkaUtils.KafkaBridgeUtils;\n-import io.strimzi.systemtest.utils.kubeUtils.objects.ServiceUtils;\n-import io.strimzi.systemtest.utils.specific.BridgeUtils;\n-import io.vertx.core.json.JsonArray;\n-import io.vertx.core.json.JsonObject;\n-import io.vertx.junit5.VertxExtension;\n+import io.strimzi.systemtest.kafkaclients.internalClients.InternalKafkaClient;\n+import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n+import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n+import io.strimzi.systemtest.utils.ClientUtils;\n import org.apache.kafka.clients.consumer.ConsumerConfig;\n-import org.apache.kafka.common.security.auth.SecurityProtocol;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-import io.strimzi.systemtest.resources.KubernetesResource;\n-import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n-import io.strimzi.systemtest.resources.crd.KafkaResource;\n-import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n-import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n \n-import static io.strimzi.systemtest.Constants.BRIDGE;\n-import static io.strimzi.systemtest.Constants.EXTERNAL_CLIENTS_USED;\n-import static io.strimzi.systemtest.Constants.NODEPORT_SUPPORTED;\n-import static io.strimzi.systemtest.Constants.REGRESSION;\n-import static io.strimzi.systemtest.bridge.HttpBridgeST.NAMESPACE;\n+import static io.strimzi.systemtest.Constants.INTERNAL_CLIENTS_USED;\n import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n \n-@Tag(BRIDGE)\n-@Tag(REGRESSION)\n-@Tag(NODEPORT_SUPPORTED)\n-@Tag(EXTERNAL_CLIENTS_USED)\n-@ExtendWith(VertxExtension.class)\n+@Tag(INTERNAL_CLIENTS_USED)\n class HttpBridgeScramShaST extends HttpBridgeAbstractST {\n     private static final Logger LOGGER = LogManager.getLogger(HttpBridgeScramShaST.class);\n+    private static final String NAMESPACE = \"bridge-scram-sha-cluster-test\";\n \n-    private String bridgeHost = \"\";\n-    private int bridgePort = Constants.HTTP_BRIDGE_DEFAULT_PORT;\n+    private String kafkaClientsPodName;\n \n     @Test\n-    void testSendSimpleMessageTlsScramSha() throws Exception {\n-        int messageCount = 50;\n+    void testSendSimpleMessageTlsScramSha() {\n         // Create topic\n         KafkaTopicResource.topic(CLUSTER_NAME, TOPIC_NAME).done();\n \n-        JsonObject records = BridgeUtils.generateHttpMessages(messageCount);\n-        JsonObject response = BridgeUtils.sendMessagesHttpRequest(records, bridgeHost, bridgePort, TOPIC_NAME, client);\n-        KafkaBridgeUtils.checkSendResponse(response, messageCount);\n+        KafkaClientsResource.producerStrimziBridge(producerName, bridgeServiceName, bridgePort, TOPIC_NAME, MESSAGE_COUNT).done();\n+        ClientUtils.waitForClientSuccess(producerName, NAMESPACE, MESSAGE_COUNT);\n \n-        BasicExternalKafkaClient kafkaClient = new BasicExternalKafkaClient.Builder()\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n             .withTopicName(TOPIC_NAME)\n             .withNamespaceName(NAMESPACE)\n             .withClusterName(CLUSTER_NAME)\n+            .withMessageCount(MESSAGE_COUNT)\n             .withKafkaUsername(USER_NAME)\n-            .withMessageCount(messageCount)\n-            .withSecurityProtocol(SecurityProtocol.SASL_SSL)\n+            .withUsingPodName(kafkaClientsPodName)\n             .build();\n \n-        assertThat(kafkaClient.receiveMessagesTls(), is(messageCount));\n+        assertThat(internalKafkaClient.receiveMessagesPlain(), is(MESSAGE_COUNT));\n     }\n \n     @Test\n-    void testReceiveSimpleMessageTlsScramSha() throws Exception {\n-        // Create topic\n+    void testReceiveSimpleMessageTlsScramSha() {\n         KafkaTopicResource.topic(CLUSTER_NAME, TOPIC_NAME).done();\n \n-        BasicExternalKafkaClient kafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withKafkaUsername(USER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withSecurityProtocol(SecurityProtocol.SASL_SSL)\n-            .build();\n+        KafkaClientsResource.consumerStrimziBridge(consumerName, bridgeServiceName, bridgePort, TOPIC_NAME, MESSAGE_COUNT).done();\n \n         // Send messages to Kafka\n-        assertThat(kafkaClient.sendMessagesTls(), is(MESSAGE_COUNT));\n-\n-        String name = \"kafka-consumer-simple-receive\";\n-\n-        JsonObject config = new JsonObject();\n-        config.put(\"name\", name);\n-        config.put(\"format\", \"json\");\n-        config.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n-        // Create consumer\n-        JsonObject response = BridgeUtils.createBridgeConsumer(config, bridgeHost, bridgePort, CONSUMER_GROUP_NAME, client);\n-        assertThat(\"Consumer wasn't created correctly\", response.getString(\"instance_id\"), is(name));\n-        // Create topics json\n-        JsonArray topic = new JsonArray();\n-        topic.add(TOPIC_NAME);\n-        JsonObject topics = new JsonObject();\n-        topics.put(\"topics\", topic);\n-        // Subscribe\n-        assertThat(BridgeUtils.subscribeHttpConsumer(topics, bridgeHost, bridgePort, CONSUMER_GROUP_NAME, name, client), is(true));\n-        // Try to consume messages\n-        JsonArray bridgeResponse = BridgeUtils.receiveMessagesHttpRequest(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, name, client);\n-        if (bridgeResponse.size() == 0) {\n-            // Real consuming\n-            bridgeResponse = BridgeUtils.receiveMessagesHttpRequest(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, name, client);\n-        }\n-\n-        assertThat(\"Sent message count is not equal with received message count\", bridgeResponse.size(), is(MESSAGE_COUNT));\n-        // Delete consumer\n-        assertThat(BridgeUtils.deleteConsumer(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, name, client), is(true));\n-    }\n-\n-    @Test\n-    void testScramShaAuthWithWeirdNamedUser() throws Exception {\n-        // Create weird named user with . and more than 64 chars -> SCRAM-SHA\n-        String weirdUserName = \"jjglmahyijoambryleyxjjglmahy.ijoambryleyxjjglmahyijoambryleyxasd.asdasidioiqweioqiweooioqieioqieoqieooi\";\n-        // Create user with normal name -> we don't need to set weird name for consumer\n-        String aliceUser = \"alice\";\n-\n-        // Create topic\n-        KafkaTopicResource.topic(CLUSTER_NAME, TOPIC_NAME).done();\n-        // Create user\n-        KafkaUserResource.scramShaUser(CLUSTER_NAME, weirdUserName).done();\n-        KafkaUserResource.scramShaUser(CLUSTER_NAME, aliceUser).done();\n-\n-        JsonObject config = new JsonObject();\n-        config.put(\"name\", aliceUser);\n-        config.put(\"format\", \"json\");\n-        config.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n-\n-        // Create consumer\n-        JsonObject response = BridgeUtils.createBridgeConsumer(config, bridgeHost, bridgePort, CONSUMER_GROUP_NAME, client);\n-        assertThat(\"Consumer wasn't created correctly\", response.getString(\"instance_id\"), is(aliceUser));\n-\n-        // Create topics json\n-        JsonArray topic = new JsonArray();\n-        topic.add(TOPIC_NAME);\n-        JsonObject topics = new JsonObject();\n-        topics.put(\"topics\", topic);\n-\n-        // Subscribe\n-        assertThat(BridgeUtils.subscribeHttpConsumer(topics, bridgeHost, bridgePort, CONSUMER_GROUP_NAME, aliceUser, client), is(true));\n-\n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n             .withTopicName(TOPIC_NAME)\n             .withNamespaceName(NAMESPACE)\n             .withClusterName(CLUSTER_NAME)\n             .withMessageCount(MESSAGE_COUNT)\n-            .withSecurityProtocol(SecurityProtocol.SASL_SSL)\n-            .withKafkaUsername(weirdUserName)\n+            .withKafkaUsername(USER_NAME)\n+            .withUsingPodName(kafkaClientsPodName)\n             .build();\n \n-        assertThat(basicExternalKafkaClient.sendMessagesTls(), is(MESSAGE_COUNT));\n-        // Try to consume messages\n-        JsonArray bridgeResponse = BridgeUtils.receiveMessagesHttpRequest(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, aliceUser, client);\n-        if (bridgeResponse.size() == 0) {\n-            // Real consuming\n-            bridgeResponse = BridgeUtils.receiveMessagesHttpRequest(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, aliceUser, client);\n-        }\n-        assertThat(\"Sent message count is not equal with received message count\", bridgeResponse.size(), is(MESSAGE_COUNT));\n-        // Delete consumer\n-        assertThat(BridgeUtils.deleteConsumer(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, aliceUser, client), is(true));\n+        assertThat(internalKafkaClient.sendMessagesPlain(), is(MESSAGE_COUNT));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDk0Nzk2OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeScramShaST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMTowNzozNlrOHCOgng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMTowNzozNlrOHCOgng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5NjkyNg==", "bodyText": "Some new lines/indents?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472096926", "createdAt": "2020-08-18T11:07:36Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeScramShaST.java", "diffHunk": "@@ -4,225 +4,115 @@\n  */\n package io.strimzi.systemtest.bridge;\n \n-import io.fabric8.kubernetes.api.model.Service;\n-import io.strimzi.api.kafka.model.CertSecretSource;\n import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.api.kafka.model.KafkaUser;\n import io.strimzi.api.kafka.model.PasswordSecretSource;\n import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationScramSha512;\n-import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n-import io.strimzi.api.kafka.model.listener.KafkaListenerTls;\n-import io.strimzi.systemtest.Constants;\n-import io.strimzi.systemtest.kafkaclients.externalClients.BasicExternalKafkaClient;\n-import io.strimzi.systemtest.utils.kafkaUtils.KafkaBridgeUtils;\n-import io.strimzi.systemtest.utils.kubeUtils.objects.ServiceUtils;\n-import io.strimzi.systemtest.utils.specific.BridgeUtils;\n-import io.vertx.core.json.JsonArray;\n-import io.vertx.core.json.JsonObject;\n-import io.vertx.junit5.VertxExtension;\n+import io.strimzi.systemtest.kafkaclients.internalClients.InternalKafkaClient;\n+import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n+import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n+import io.strimzi.systemtest.utils.ClientUtils;\n import org.apache.kafka.clients.consumer.ConsumerConfig;\n-import org.apache.kafka.common.security.auth.SecurityProtocol;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-import io.strimzi.systemtest.resources.KubernetesResource;\n-import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n-import io.strimzi.systemtest.resources.crd.KafkaResource;\n-import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n-import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n \n-import static io.strimzi.systemtest.Constants.BRIDGE;\n-import static io.strimzi.systemtest.Constants.EXTERNAL_CLIENTS_USED;\n-import static io.strimzi.systemtest.Constants.NODEPORT_SUPPORTED;\n-import static io.strimzi.systemtest.Constants.REGRESSION;\n-import static io.strimzi.systemtest.bridge.HttpBridgeST.NAMESPACE;\n+import static io.strimzi.systemtest.Constants.INTERNAL_CLIENTS_USED;\n import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n \n-@Tag(BRIDGE)\n-@Tag(REGRESSION)\n-@Tag(NODEPORT_SUPPORTED)\n-@Tag(EXTERNAL_CLIENTS_USED)\n-@ExtendWith(VertxExtension.class)\n+@Tag(INTERNAL_CLIENTS_USED)\n class HttpBridgeScramShaST extends HttpBridgeAbstractST {\n     private static final Logger LOGGER = LogManager.getLogger(HttpBridgeScramShaST.class);\n+    private static final String NAMESPACE = \"bridge-scram-sha-cluster-test\";\n \n-    private String bridgeHost = \"\";\n-    private int bridgePort = Constants.HTTP_BRIDGE_DEFAULT_PORT;\n+    private String kafkaClientsPodName;\n \n     @Test\n-    void testSendSimpleMessageTlsScramSha() throws Exception {\n-        int messageCount = 50;\n+    void testSendSimpleMessageTlsScramSha() {\n         // Create topic\n         KafkaTopicResource.topic(CLUSTER_NAME, TOPIC_NAME).done();\n \n-        JsonObject records = BridgeUtils.generateHttpMessages(messageCount);\n-        JsonObject response = BridgeUtils.sendMessagesHttpRequest(records, bridgeHost, bridgePort, TOPIC_NAME, client);\n-        KafkaBridgeUtils.checkSendResponse(response, messageCount);\n+        KafkaClientsResource.producerStrimziBridge(producerName, bridgeServiceName, bridgePort, TOPIC_NAME, MESSAGE_COUNT).done();\n+        ClientUtils.waitForClientSuccess(producerName, NAMESPACE, MESSAGE_COUNT);\n \n-        BasicExternalKafkaClient kafkaClient = new BasicExternalKafkaClient.Builder()\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n             .withTopicName(TOPIC_NAME)\n             .withNamespaceName(NAMESPACE)\n             .withClusterName(CLUSTER_NAME)\n+            .withMessageCount(MESSAGE_COUNT)\n             .withKafkaUsername(USER_NAME)\n-            .withMessageCount(messageCount)\n-            .withSecurityProtocol(SecurityProtocol.SASL_SSL)\n+            .withUsingPodName(kafkaClientsPodName)\n             .build();\n \n-        assertThat(kafkaClient.receiveMessagesTls(), is(messageCount));\n+        assertThat(internalKafkaClient.receiveMessagesPlain(), is(MESSAGE_COUNT));\n     }\n \n     @Test\n-    void testReceiveSimpleMessageTlsScramSha() throws Exception {\n-        // Create topic\n+    void testReceiveSimpleMessageTlsScramSha() {\n         KafkaTopicResource.topic(CLUSTER_NAME, TOPIC_NAME).done();\n \n-        BasicExternalKafkaClient kafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withKafkaUsername(USER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withSecurityProtocol(SecurityProtocol.SASL_SSL)\n-            .build();\n+        KafkaClientsResource.consumerStrimziBridge(consumerName, bridgeServiceName, bridgePort, TOPIC_NAME, MESSAGE_COUNT).done();\n \n         // Send messages to Kafka\n-        assertThat(kafkaClient.sendMessagesTls(), is(MESSAGE_COUNT));\n-\n-        String name = \"kafka-consumer-simple-receive\";\n-\n-        JsonObject config = new JsonObject();\n-        config.put(\"name\", name);\n-        config.put(\"format\", \"json\");\n-        config.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n-        // Create consumer\n-        JsonObject response = BridgeUtils.createBridgeConsumer(config, bridgeHost, bridgePort, CONSUMER_GROUP_NAME, client);\n-        assertThat(\"Consumer wasn't created correctly\", response.getString(\"instance_id\"), is(name));\n-        // Create topics json\n-        JsonArray topic = new JsonArray();\n-        topic.add(TOPIC_NAME);\n-        JsonObject topics = new JsonObject();\n-        topics.put(\"topics\", topic);\n-        // Subscribe\n-        assertThat(BridgeUtils.subscribeHttpConsumer(topics, bridgeHost, bridgePort, CONSUMER_GROUP_NAME, name, client), is(true));\n-        // Try to consume messages\n-        JsonArray bridgeResponse = BridgeUtils.receiveMessagesHttpRequest(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, name, client);\n-        if (bridgeResponse.size() == 0) {\n-            // Real consuming\n-            bridgeResponse = BridgeUtils.receiveMessagesHttpRequest(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, name, client);\n-        }\n-\n-        assertThat(\"Sent message count is not equal with received message count\", bridgeResponse.size(), is(MESSAGE_COUNT));\n-        // Delete consumer\n-        assertThat(BridgeUtils.deleteConsumer(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, name, client), is(true));\n-    }\n-\n-    @Test\n-    void testScramShaAuthWithWeirdNamedUser() throws Exception {\n-        // Create weird named user with . and more than 64 chars -> SCRAM-SHA\n-        String weirdUserName = \"jjglmahyijoambryleyxjjglmahy.ijoambryleyxjjglmahyijoambryleyxasd.asdasidioiqweioqiweooioqieioqieoqieooi\";\n-        // Create user with normal name -> we don't need to set weird name for consumer\n-        String aliceUser = \"alice\";\n-\n-        // Create topic\n-        KafkaTopicResource.topic(CLUSTER_NAME, TOPIC_NAME).done();\n-        // Create user\n-        KafkaUserResource.scramShaUser(CLUSTER_NAME, weirdUserName).done();\n-        KafkaUserResource.scramShaUser(CLUSTER_NAME, aliceUser).done();\n-\n-        JsonObject config = new JsonObject();\n-        config.put(\"name\", aliceUser);\n-        config.put(\"format\", \"json\");\n-        config.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n-\n-        // Create consumer\n-        JsonObject response = BridgeUtils.createBridgeConsumer(config, bridgeHost, bridgePort, CONSUMER_GROUP_NAME, client);\n-        assertThat(\"Consumer wasn't created correctly\", response.getString(\"instance_id\"), is(aliceUser));\n-\n-        // Create topics json\n-        JsonArray topic = new JsonArray();\n-        topic.add(TOPIC_NAME);\n-        JsonObject topics = new JsonObject();\n-        topics.put(\"topics\", topic);\n-\n-        // Subscribe\n-        assertThat(BridgeUtils.subscribeHttpConsumer(topics, bridgeHost, bridgePort, CONSUMER_GROUP_NAME, aliceUser, client), is(true));\n-\n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n             .withTopicName(TOPIC_NAME)\n             .withNamespaceName(NAMESPACE)\n             .withClusterName(CLUSTER_NAME)\n             .withMessageCount(MESSAGE_COUNT)\n-            .withSecurityProtocol(SecurityProtocol.SASL_SSL)\n-            .withKafkaUsername(weirdUserName)\n+            .withKafkaUsername(USER_NAME)\n+            .withUsingPodName(kafkaClientsPodName)\n             .build();\n \n-        assertThat(basicExternalKafkaClient.sendMessagesTls(), is(MESSAGE_COUNT));\n-        // Try to consume messages\n-        JsonArray bridgeResponse = BridgeUtils.receiveMessagesHttpRequest(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, aliceUser, client);\n-        if (bridgeResponse.size() == 0) {\n-            // Real consuming\n-            bridgeResponse = BridgeUtils.receiveMessagesHttpRequest(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, aliceUser, client);\n-        }\n-        assertThat(\"Sent message count is not equal with received message count\", bridgeResponse.size(), is(MESSAGE_COUNT));\n-        // Delete consumer\n-        assertThat(BridgeUtils.deleteConsumer(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, aliceUser, client), is(true));\n+        assertThat(internalKafkaClient.sendMessagesPlain(), is(MESSAGE_COUNT));\n+\n+        ClientUtils.waitForClientSuccess(consumerName, NAMESPACE, MESSAGE_COUNT);\n     }\n \n     @BeforeAll\n-    void setup() throws InterruptedException {\n+    void setup() throws Exception {\n+        deployClusterOperator(NAMESPACE);\n         LOGGER.info(\"Deploy Kafka and KafkaBridge before tests\");\n \n-        KafkaListenerAuthenticationTls auth = new KafkaListenerAuthenticationTls();\n-        KafkaListenerTls listenerTls = new KafkaListenerTls();\n-        listenerTls.setAuth(auth);\n-\n         // Deploy kafka\n         KafkaResource.kafkaEphemeral(CLUSTER_NAME, 1, 1)\n             .editSpec()\n                 .editKafka()\n                     .withNewListeners()\n-                        .withNewKafkaListenerExternalNodePort()\n-                            .withAuth(new KafkaListenerAuthenticationScramSha512())\n-                        .endKafkaListenerExternalNodePort()\n-                        .withNewTls().withAuth(new KafkaListenerAuthenticationScramSha512()).endTls()\n+                        .withNewPlain().withAuth(new KafkaListenerAuthenticationScramSha512()).endPlain()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDk1MDEyOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeScramShaST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMTowODoxNVrOHCOh4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMTowODoxNVrOHCOh4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5NzI1MQ==", "bodyText": "Probably same as above? tls -> plain", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472097251", "createdAt": "2020-08-18T11:08:15Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeScramShaST.java", "diffHunk": "@@ -4,225 +4,115 @@\n  */\n package io.strimzi.systemtest.bridge;\n \n-import io.fabric8.kubernetes.api.model.Service;\n-import io.strimzi.api.kafka.model.CertSecretSource;\n import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.api.kafka.model.KafkaUser;\n import io.strimzi.api.kafka.model.PasswordSecretSource;\n import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationScramSha512;\n-import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n-import io.strimzi.api.kafka.model.listener.KafkaListenerTls;\n-import io.strimzi.systemtest.Constants;\n-import io.strimzi.systemtest.kafkaclients.externalClients.BasicExternalKafkaClient;\n-import io.strimzi.systemtest.utils.kafkaUtils.KafkaBridgeUtils;\n-import io.strimzi.systemtest.utils.kubeUtils.objects.ServiceUtils;\n-import io.strimzi.systemtest.utils.specific.BridgeUtils;\n-import io.vertx.core.json.JsonArray;\n-import io.vertx.core.json.JsonObject;\n-import io.vertx.junit5.VertxExtension;\n+import io.strimzi.systemtest.kafkaclients.internalClients.InternalKafkaClient;\n+import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n+import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n+import io.strimzi.systemtest.utils.ClientUtils;\n import org.apache.kafka.clients.consumer.ConsumerConfig;\n-import org.apache.kafka.common.security.auth.SecurityProtocol;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-import io.strimzi.systemtest.resources.KubernetesResource;\n-import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n-import io.strimzi.systemtest.resources.crd.KafkaResource;\n-import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n-import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n \n-import static io.strimzi.systemtest.Constants.BRIDGE;\n-import static io.strimzi.systemtest.Constants.EXTERNAL_CLIENTS_USED;\n-import static io.strimzi.systemtest.Constants.NODEPORT_SUPPORTED;\n-import static io.strimzi.systemtest.Constants.REGRESSION;\n-import static io.strimzi.systemtest.bridge.HttpBridgeST.NAMESPACE;\n+import static io.strimzi.systemtest.Constants.INTERNAL_CLIENTS_USED;\n import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n \n-@Tag(BRIDGE)\n-@Tag(REGRESSION)\n-@Tag(NODEPORT_SUPPORTED)\n-@Tag(EXTERNAL_CLIENTS_USED)\n-@ExtendWith(VertxExtension.class)\n+@Tag(INTERNAL_CLIENTS_USED)\n class HttpBridgeScramShaST extends HttpBridgeAbstractST {\n     private static final Logger LOGGER = LogManager.getLogger(HttpBridgeScramShaST.class);\n+    private static final String NAMESPACE = \"bridge-scram-sha-cluster-test\";\n \n-    private String bridgeHost = \"\";\n-    private int bridgePort = Constants.HTTP_BRIDGE_DEFAULT_PORT;\n+    private String kafkaClientsPodName;\n \n     @Test\n-    void testSendSimpleMessageTlsScramSha() throws Exception {\n-        int messageCount = 50;\n+    void testSendSimpleMessageTlsScramSha() {\n         // Create topic\n         KafkaTopicResource.topic(CLUSTER_NAME, TOPIC_NAME).done();\n \n-        JsonObject records = BridgeUtils.generateHttpMessages(messageCount);\n-        JsonObject response = BridgeUtils.sendMessagesHttpRequest(records, bridgeHost, bridgePort, TOPIC_NAME, client);\n-        KafkaBridgeUtils.checkSendResponse(response, messageCount);\n+        KafkaClientsResource.producerStrimziBridge(producerName, bridgeServiceName, bridgePort, TOPIC_NAME, MESSAGE_COUNT).done();\n+        ClientUtils.waitForClientSuccess(producerName, NAMESPACE, MESSAGE_COUNT);\n \n-        BasicExternalKafkaClient kafkaClient = new BasicExternalKafkaClient.Builder()\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n             .withTopicName(TOPIC_NAME)\n             .withNamespaceName(NAMESPACE)\n             .withClusterName(CLUSTER_NAME)\n+            .withMessageCount(MESSAGE_COUNT)\n             .withKafkaUsername(USER_NAME)\n-            .withMessageCount(messageCount)\n-            .withSecurityProtocol(SecurityProtocol.SASL_SSL)\n+            .withUsingPodName(kafkaClientsPodName)\n             .build();\n \n-        assertThat(kafkaClient.receiveMessagesTls(), is(messageCount));\n+        assertThat(internalKafkaClient.receiveMessagesPlain(), is(MESSAGE_COUNT));\n     }\n \n     @Test\n-    void testReceiveSimpleMessageTlsScramSha() throws Exception {\n-        // Create topic\n+    void testReceiveSimpleMessageTlsScramSha() {\n         KafkaTopicResource.topic(CLUSTER_NAME, TOPIC_NAME).done();\n \n-        BasicExternalKafkaClient kafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withKafkaUsername(USER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withSecurityProtocol(SecurityProtocol.SASL_SSL)\n-            .build();\n+        KafkaClientsResource.consumerStrimziBridge(consumerName, bridgeServiceName, bridgePort, TOPIC_NAME, MESSAGE_COUNT).done();\n \n         // Send messages to Kafka\n-        assertThat(kafkaClient.sendMessagesTls(), is(MESSAGE_COUNT));\n-\n-        String name = \"kafka-consumer-simple-receive\";\n-\n-        JsonObject config = new JsonObject();\n-        config.put(\"name\", name);\n-        config.put(\"format\", \"json\");\n-        config.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n-        // Create consumer\n-        JsonObject response = BridgeUtils.createBridgeConsumer(config, bridgeHost, bridgePort, CONSUMER_GROUP_NAME, client);\n-        assertThat(\"Consumer wasn't created correctly\", response.getString(\"instance_id\"), is(name));\n-        // Create topics json\n-        JsonArray topic = new JsonArray();\n-        topic.add(TOPIC_NAME);\n-        JsonObject topics = new JsonObject();\n-        topics.put(\"topics\", topic);\n-        // Subscribe\n-        assertThat(BridgeUtils.subscribeHttpConsumer(topics, bridgeHost, bridgePort, CONSUMER_GROUP_NAME, name, client), is(true));\n-        // Try to consume messages\n-        JsonArray bridgeResponse = BridgeUtils.receiveMessagesHttpRequest(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, name, client);\n-        if (bridgeResponse.size() == 0) {\n-            // Real consuming\n-            bridgeResponse = BridgeUtils.receiveMessagesHttpRequest(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, name, client);\n-        }\n-\n-        assertThat(\"Sent message count is not equal with received message count\", bridgeResponse.size(), is(MESSAGE_COUNT));\n-        // Delete consumer\n-        assertThat(BridgeUtils.deleteConsumer(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, name, client), is(true));\n-    }\n-\n-    @Test\n-    void testScramShaAuthWithWeirdNamedUser() throws Exception {\n-        // Create weird named user with . and more than 64 chars -> SCRAM-SHA\n-        String weirdUserName = \"jjglmahyijoambryleyxjjglmahy.ijoambryleyxjjglmahyijoambryleyxasd.asdasidioiqweioqiweooioqieioqieoqieooi\";\n-        // Create user with normal name -> we don't need to set weird name for consumer\n-        String aliceUser = \"alice\";\n-\n-        // Create topic\n-        KafkaTopicResource.topic(CLUSTER_NAME, TOPIC_NAME).done();\n-        // Create user\n-        KafkaUserResource.scramShaUser(CLUSTER_NAME, weirdUserName).done();\n-        KafkaUserResource.scramShaUser(CLUSTER_NAME, aliceUser).done();\n-\n-        JsonObject config = new JsonObject();\n-        config.put(\"name\", aliceUser);\n-        config.put(\"format\", \"json\");\n-        config.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n-\n-        // Create consumer\n-        JsonObject response = BridgeUtils.createBridgeConsumer(config, bridgeHost, bridgePort, CONSUMER_GROUP_NAME, client);\n-        assertThat(\"Consumer wasn't created correctly\", response.getString(\"instance_id\"), is(aliceUser));\n-\n-        // Create topics json\n-        JsonArray topic = new JsonArray();\n-        topic.add(TOPIC_NAME);\n-        JsonObject topics = new JsonObject();\n-        topics.put(\"topics\", topic);\n-\n-        // Subscribe\n-        assertThat(BridgeUtils.subscribeHttpConsumer(topics, bridgeHost, bridgePort, CONSUMER_GROUP_NAME, aliceUser, client), is(true));\n-\n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n             .withTopicName(TOPIC_NAME)\n             .withNamespaceName(NAMESPACE)\n             .withClusterName(CLUSTER_NAME)\n             .withMessageCount(MESSAGE_COUNT)\n-            .withSecurityProtocol(SecurityProtocol.SASL_SSL)\n-            .withKafkaUsername(weirdUserName)\n+            .withKafkaUsername(USER_NAME)\n+            .withUsingPodName(kafkaClientsPodName)\n             .build();\n \n-        assertThat(basicExternalKafkaClient.sendMessagesTls(), is(MESSAGE_COUNT));\n-        // Try to consume messages\n-        JsonArray bridgeResponse = BridgeUtils.receiveMessagesHttpRequest(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, aliceUser, client);\n-        if (bridgeResponse.size() == 0) {\n-            // Real consuming\n-            bridgeResponse = BridgeUtils.receiveMessagesHttpRequest(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, aliceUser, client);\n-        }\n-        assertThat(\"Sent message count is not equal with received message count\", bridgeResponse.size(), is(MESSAGE_COUNT));\n-        // Delete consumer\n-        assertThat(BridgeUtils.deleteConsumer(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, aliceUser, client), is(true));\n+        assertThat(internalKafkaClient.sendMessagesPlain(), is(MESSAGE_COUNT));\n+\n+        ClientUtils.waitForClientSuccess(consumerName, NAMESPACE, MESSAGE_COUNT);\n     }\n \n     @BeforeAll\n-    void setup() throws InterruptedException {\n+    void setup() throws Exception {\n+        deployClusterOperator(NAMESPACE);\n         LOGGER.info(\"Deploy Kafka and KafkaBridge before tests\");\n \n-        KafkaListenerAuthenticationTls auth = new KafkaListenerAuthenticationTls();\n-        KafkaListenerTls listenerTls = new KafkaListenerTls();\n-        listenerTls.setAuth(auth);\n-\n         // Deploy kafka\n         KafkaResource.kafkaEphemeral(CLUSTER_NAME, 1, 1)\n             .editSpec()\n                 .editKafka()\n                     .withNewListeners()\n-                        .withNewKafkaListenerExternalNodePort()\n-                            .withAuth(new KafkaListenerAuthenticationScramSha512())\n-                        .endKafkaListenerExternalNodePort()\n-                        .withNewTls().withAuth(new KafkaListenerAuthenticationScramSha512()).endTls()\n+                        .withNewPlain().withAuth(new KafkaListenerAuthenticationScramSha512()).endPlain()\n                     .endListeners()\n                 .endKafka()\n             .endSpec().done();\n \n         // Create Kafka user\n-        KafkaUserResource.scramShaUser(CLUSTER_NAME, USER_NAME).done();\n+        KafkaUser scramShaUser = KafkaUserResource.scramShaUser(CLUSTER_NAME, USER_NAME).done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME, scramShaUser).done();\n+\n+        kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n \n         // Initialize PasswordSecret to set this as PasswordSecret in Mirror Maker spec\n         PasswordSecretSource passwordSecret = new PasswordSecretSource();\n         passwordSecret.setSecretName(USER_NAME);\n         passwordSecret.setPassword(\"password\");\n \n-        // Initialize CertSecretSource with certificate and secret names for consumer\n-        CertSecretSource certSecret = new CertSecretSource();\n-        certSecret.setCertificate(\"ca.crt\");\n-        certSecret.setSecretName(KafkaResources.clusterCaCertificateSecretName(CLUSTER_NAME));\n-\n         // Deploy http bridge\n-        KafkaBridgeResource.kafkaBridge(CLUSTER_NAME, KafkaResources.tlsBootstrapAddress(CLUSTER_NAME), 1)\n+        KafkaBridgeResource.kafkaBridge(CLUSTER_NAME, KafkaResources.plainBootstrapAddress(CLUSTER_NAME), 1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 243}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDk1NjE3OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeTlsST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMToxMDowOFrOHCOlkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMToxMDowOFrOHCOlkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5ODE5Mw==", "bodyText": "I think format before this changes looks better.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472098193", "createdAt": "2020-08-18T11:10:08Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeTlsST.java", "diffHunk": "@@ -4,191 +4,102 @@\n  */\n package io.strimzi.systemtest.bridge;\n \n-import io.fabric8.kubernetes.api.model.Service;\n import io.strimzi.api.kafka.model.CertSecretSource;\n import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.api.kafka.model.KafkaUser;\n import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n-import io.strimzi.systemtest.Constants;\n-import io.strimzi.systemtest.kafkaclients.externalClients.BasicExternalKafkaClient;\n-import io.strimzi.systemtest.utils.kafkaUtils.KafkaBridgeUtils;\n-import io.strimzi.systemtest.utils.kafkaUtils.KafkaTopicUtils;\n-import io.strimzi.systemtest.utils.kubeUtils.objects.ServiceUtils;\n-import io.strimzi.systemtest.utils.specific.BridgeUtils;\n-import io.vertx.core.json.JsonArray;\n-import io.vertx.core.json.JsonObject;\n-import io.vertx.junit5.VertxExtension;\n+import io.strimzi.systemtest.kafkaclients.internalClients.InternalKafkaClient;\n+import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n+import io.strimzi.systemtest.resources.crd.KafkaClientsResource;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n+import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n+import io.strimzi.systemtest.utils.ClientUtils;\n import org.apache.kafka.clients.consumer.ConsumerConfig;\n import org.apache.kafka.common.security.auth.SecurityProtocol;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-import io.strimzi.systemtest.resources.KubernetesResource;\n-import io.strimzi.systemtest.resources.crd.KafkaBridgeResource;\n-import io.strimzi.systemtest.resources.crd.KafkaResource;\n-import io.strimzi.systemtest.resources.crd.KafkaTopicResource;\n-import io.strimzi.systemtest.resources.crd.KafkaUserResource;\n \n import static io.strimzi.systemtest.Constants.ACCEPTANCE;\n-import static io.strimzi.systemtest.Constants.BRIDGE;\n-import static io.strimzi.systemtest.Constants.EXTERNAL_CLIENTS_USED;\n-import static io.strimzi.systemtest.Constants.NODEPORT_SUPPORTED;\n-import static io.strimzi.systemtest.Constants.REGRESSION;\n-import static io.strimzi.systemtest.bridge.HttpBridgeST.NAMESPACE;\n+import static io.strimzi.systemtest.Constants.INTERNAL_CLIENTS_USED;\n import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.MatcherAssert.assertThat;\n \n-@Tag(BRIDGE)\n @Tag(ACCEPTANCE)\n-@Tag(REGRESSION)\n-@Tag(NODEPORT_SUPPORTED)\n-@Tag(EXTERNAL_CLIENTS_USED)\n-@ExtendWith(VertxExtension.class)\n+@Tag(INTERNAL_CLIENTS_USED)\n class HttpBridgeTlsST extends HttpBridgeAbstractST {\n     private static final Logger LOGGER = LogManager.getLogger(HttpBridgeTlsST.class);\n-\n-    private String bridgeHost = \"\";\n-    private int bridgePort = Constants.HTTP_BRIDGE_DEFAULT_PORT;\n+    private static final String NAMESPACE = \"bridge-tls-cluster-test\";\n \n     @Test\n-    void testSendSimpleMessageTls() throws Exception {\n-        String topicName = KafkaTopicUtils.generateRandomNameOfTopic();\n+    void testSendSimpleMessageTls() {\n         // Create topic\n-        KafkaTopicResource.topic(CLUSTER_NAME, topicName).done();\n-\n-        JsonObject records = BridgeUtils.generateHttpMessages(MESSAGE_COUNT);\n-        JsonObject response = BridgeUtils.sendMessagesHttpRequest(records, bridgeHost, bridgePort, topicName, client);\n-        KafkaBridgeUtils.checkSendResponse(response, MESSAGE_COUNT);\n-\n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(topicName)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withSecurityProtocol(SecurityProtocol.SSL)\n-            .withKafkaUsername(USER_NAME)\n-            .build();\n+        KafkaTopicResource.topic(CLUSTER_NAME, TOPIC_NAME).done();\n \n-        assertThat(basicExternalKafkaClient.receiveMessagesTls(), is(MESSAGE_COUNT));\n-    }\n+        KafkaClientsResource.producerStrimziBridge(producerName, bridgeServiceName, bridgePort, TOPIC_NAME, MESSAGE_COUNT).done();\n+        ClientUtils.waitForClientSuccess(producerName, NAMESPACE, MESSAGE_COUNT);\n \n-    @Test\n-    void testReceiveSimpleMessageTls() throws Exception {\n-        String topicName = KafkaTopicUtils.generateRandomNameOfTopic();\n-        // Create topic\n-        KafkaTopicResource.topic(CLUSTER_NAME, topicName).done();\n-        KafkaTopicUtils.waitForKafkaTopicCreation(topicName);\n-\n-        JsonObject config = new JsonObject();\n-        config.put(\"name\", USER_NAME);\n-        config.put(\"format\", \"json\");\n-        config.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n-        // Create consumer\n-        JsonObject response = BridgeUtils.createBridgeConsumer(config, bridgeHost, bridgePort, CONSUMER_GROUP_NAME, client);\n-        assertThat(\"Consumer wasn't created correctly\", response.getString(\"instance_id\"), is(USER_NAME));\n-        // Create topics json\n-        JsonArray topic = new JsonArray();\n-        topic.add(topicName);\n-        JsonObject topics = new JsonObject();\n-        topics.put(\"topics\", topic);\n-        // Subscribe\n-        assertThat(BridgeUtils.subscribeHttpConsumer(topics, bridgeHost, bridgePort, CONSUMER_GROUP_NAME, USER_NAME, client), is(true));\n-        // Send messages to Kafka\n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(topicName)\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+            .withTopicName(TOPIC_NAME)\n             .withNamespaceName(NAMESPACE)\n             .withClusterName(CLUSTER_NAME)\n             .withMessageCount(MESSAGE_COUNT)\n             .withSecurityProtocol(SecurityProtocol.SSL)\n             .withKafkaUsername(USER_NAME)\n+            .withUsingPodName(kafkaClientsPodName)\n             .build();\n \n-\n-        assertThat(basicExternalKafkaClient.sendMessagesTls(), is(MESSAGE_COUNT));\n-        // Try to consume messages\n-        JsonArray bridgeResponse = BridgeUtils.receiveMessagesHttpRequest(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, USER_NAME, client);\n-        if (bridgeResponse.size() == 0) {\n-            // Real consuming\n-            bridgeResponse = BridgeUtils.receiveMessagesHttpRequest(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, USER_NAME, client);\n-        }\n-        assertThat(\"Sent message count is not equal with received message count\", bridgeResponse.size(), is(MESSAGE_COUNT));\n-        // Delete consumer\n-        assertThat(BridgeUtils.deleteConsumer(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, USER_NAME, client), is(true));\n+        assertThat(internalKafkaClient.receiveMessagesTls(), is(MESSAGE_COUNT));\n     }\n \n     @Test\n-    void testTlsAuthWithWeirdNamedUser() throws Exception {\n-        // Create weird named user with . and maximum of 64 chars -> TLS\n-        String weirdUserName = \"jjglmahyijoambryleyxjjglmahy.ijoambryleyxjjglmahyijoambryleyxasd\";\n-        // Create user with normal name -> we don't need to set weird name for consumer\n-        String aliceUser = \"alice\";\n-\n-        // Create topic\n+    void testReceiveSimpleMessageTls() {\n         KafkaTopicResource.topic(CLUSTER_NAME, TOPIC_NAME).done();\n-        // Create user\n-        KafkaUserResource.tlsUser(CLUSTER_NAME, weirdUserName).done();\n-        KafkaUserResource.tlsUser(CLUSTER_NAME, aliceUser).done();\n-\n-        JsonObject config = new JsonObject();\n-        config.put(\"name\", aliceUser);\n-        config.put(\"format\", \"json\");\n-        config.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n-\n-        // Create consumer\n-        JsonObject response = BridgeUtils.createBridgeConsumer(config, bridgeHost, bridgePort, CONSUMER_GROUP_NAME, client);\n-        assertThat(\"Consumer wasn't created correctly\", response.getString(\"instance_id\"), is(aliceUser));\n-\n-        // Create topics json\n-        JsonArray topic = new JsonArray();\n-        topic.add(TOPIC_NAME);\n-        JsonObject topics = new JsonObject();\n-        topics.put(\"topics\", topic);\n \n-        // Subscribe\n-        assertThat(BridgeUtils.subscribeHttpConsumer(topics, bridgeHost, bridgePort, CONSUMER_GROUP_NAME, aliceUser, client), is(true));\n+        KafkaClientsResource.consumerStrimziBridge(consumerName, bridgeServiceName, bridgePort, TOPIC_NAME, MESSAGE_COUNT).done();\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n+        // Send messages to Kafka\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n             .withTopicName(TOPIC_NAME)\n             .withNamespaceName(NAMESPACE)\n             .withClusterName(CLUSTER_NAME)\n             .withMessageCount(MESSAGE_COUNT)\n             .withSecurityProtocol(SecurityProtocol.SSL)\n-            .withKafkaUsername(weirdUserName)\n+            .withKafkaUsername(USER_NAME)\n+            .withUsingPodName(kafkaClientsPodName)\n             .build();\n \n-        assertThat(basicExternalKafkaClient.sendMessagesTls(), is(MESSAGE_COUNT));\n-        // Try to consume messages\n-        JsonArray bridgeResponse = BridgeUtils.receiveMessagesHttpRequest(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, aliceUser, client);\n-        if (bridgeResponse.size() == 0) {\n-            // Real consuming\n-            bridgeResponse = BridgeUtils.receiveMessagesHttpRequest(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, aliceUser, client);\n-        }\n-        assertThat(\"Sent message count is not equal with received message count\", bridgeResponse.size(), is(MESSAGE_COUNT));\n-        // Delete consumer\n-        assertThat(BridgeUtils.deleteConsumer(bridgeHost, bridgePort, CONSUMER_GROUP_NAME, aliceUser, client), is(true));\n+        assertThat(internalKafkaClient.sendMessagesTls(), is(MESSAGE_COUNT));\n+\n+        ClientUtils.waitForClientSuccess(consumerName, NAMESPACE, MESSAGE_COUNT);\n     }\n \n     @BeforeAll\n-    void createClassResources() throws InterruptedException {\n+    void createClassResources() throws Exception {\n+        deployClusterOperator(NAMESPACE);\n         LOGGER.info(\"Deploy Kafka and KafkaBridge before tests\");\n \n         // Deploy kafka\n         KafkaResource.kafkaEphemeral(CLUSTER_NAME, 1, 1)\n             .editSpec()\n                 .editKafka()\n-                    .editListeners()\n-                        .withNewKafkaListenerExternalNodePort()\n-                            .withAuth(new KafkaListenerAuthenticationTls())\n-                        .endKafkaListenerExternalNodePort()\n+                    .withNewListeners()\n+                        .withNewTls().withAuth(new KafkaListenerAuthenticationTls()).endTls()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDk2NDUxOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/tracing/TracingST.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMToxMzowMlrOHCOq_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMToxNjo1NVrOHCOx2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5OTU4Mg==", "bodyText": "Why this change is needed?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472099582", "createdAt": "2020-08-18T11:13:02Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/tracing/TracingST.java", "diffHunk": "@@ -556,7 +551,7 @@ void testProducerConsumerMirrorMakerService() {\n         KafkaClientsResource.consumerWithTracing(KafkaResources.plainBootstrapAddress(kafkaClusterTargetName)).done();\n \n         KafkaMirrorMakerResource.kafkaMirrorMaker(CLUSTER_NAME, kafkaClusterSourceName, kafkaClusterTargetName,\n-            ClientUtils.generateRandomConsumerGroup(), 1, false)\n+                \"my-group\" + new Random().nextInt(Integer.MAX_VALUE), 1, false)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEwMTMzNw==", "bodyText": "Good catch! I think I little bit messed up the rebase", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472101337", "createdAt": "2020-08-18T11:16:55Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/tracing/TracingST.java", "diffHunk": "@@ -556,7 +551,7 @@ void testProducerConsumerMirrorMakerService() {\n         KafkaClientsResource.consumerWithTracing(KafkaResources.plainBootstrapAddress(kafkaClusterTargetName)).done();\n \n         KafkaMirrorMakerResource.kafkaMirrorMaker(CLUSTER_NAME, kafkaClusterSourceName, kafkaClusterTargetName,\n-            ClientUtils.generateRandomConsumerGroup(), 1, false)\n+                \"my-group\" + new Random().nextInt(Integer.MAX_VALUE), 1, false)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5OTU4Mg=="}, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDk2NDcyOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/tracing/TracingST.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMToxMzowOFrOHCOrHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMToxNzoxMFrOHCOyag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5OTYxNA==", "bodyText": "Same as above", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472099614", "createdAt": "2020-08-18T11:13:08Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/tracing/TracingST.java", "diffHunk": "@@ -688,7 +683,7 @@ void testProducerConsumerMirrorMakerConnectStreamsService() {\n                 + \"'\" + connectorConfig + \"'\" + \" http://localhost:8083/connectors\");\n \n         KafkaMirrorMakerResource.kafkaMirrorMaker(CLUSTER_NAME, kafkaClusterSourceName, kafkaClusterTargetName,\n-            ClientUtils.generateRandomConsumerGroup(), 1, false)\n+                \"my-group\" + new Random().nextInt(Integer.MAX_VALUE), 1, false)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEwMTQ4Mg==", "bodyText": "Same as above ^^", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3200#discussion_r472101482", "createdAt": "2020-08-18T11:17:10Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/tracing/TracingST.java", "diffHunk": "@@ -688,7 +683,7 @@ void testProducerConsumerMirrorMakerConnectStreamsService() {\n                 + \"'\" + connectorConfig + \"'\" + \" http://localhost:8083/connectors\");\n \n         KafkaMirrorMakerResource.kafkaMirrorMaker(CLUSTER_NAME, kafkaClusterSourceName, kafkaClusterTargetName,\n-            ClientUtils.generateRandomConsumerGroup(), 1, false)\n+                \"my-group\" + new Random().nextInt(Integer.MAX_VALUE), 1, false)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5OTYxNA=="}, "originalCommit": {"oid": "f270223e235e5217f139d39574856fad239816e9"}, "originalPosition": 66}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1693, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}