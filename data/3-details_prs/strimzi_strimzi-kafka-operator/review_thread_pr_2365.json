{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5NjM4MTA3", "number": 2365, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwOToyNDowNVrODWMTEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwOTozMToyN1rODWMbDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NTk2NzUzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ModelUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwOToyNDowNVrOFaz3tQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxNjoxMjowOFrOFa-IOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY1NzE0MQ==", "bodyText": "I wonder if the name (do)commonCertificatesDiffer is better?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2365#discussion_r363657141", "createdAt": "2020-01-07T09:24:05Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ModelUtils.java", "diffHunk": "@@ -366,4 +366,31 @@ public static String encodeStorageToJson(Storage storage) {\n     private static byte[] decodeFromSecret(Secret secret, String key) {\n         return Base64.getDecoder().decode(secret.getData().get(key));\n     }\n+\n+    /**\n+     * Compares two Secrets with certificates and checks whether any value for a key which exists in both Secrets\n+     * changed. This method is used to evaluate whether rolling update of existing brokers is needed when secrets with\n+     * certificates change. It separates changes for existing certificates with other changes to the secret such as\n+     * added or removed certificates (scale-up or scale-down).\n+     *\n+     * @param current   Existing secret\n+     * @param desired   Desired secret\n+     *\n+     * @return  True if there is a key which exists in the data sections of both secrets and which changed.\n+     */\n+    public static boolean didAnyCertificateChangedInSecret(Secret current, Secret desired) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59500b446f6c2a54a53678d6879eabe9257695b9"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgyNTIwOA==", "bodyText": "I think common is a bit confusing. I went with doExistingCertificatesDiffer - hope that works for you.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2365#discussion_r363825208", "createdAt": "2020-01-07T16:12:08Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ModelUtils.java", "diffHunk": "@@ -366,4 +366,31 @@ public static String encodeStorageToJson(Storage storage) {\n     private static byte[] decodeFromSecret(Secret secret, String key) {\n         return Base64.getDecoder().decode(secret.getData().get(key));\n     }\n+\n+    /**\n+     * Compares two Secrets with certificates and checks whether any value for a key which exists in both Secrets\n+     * changed. This method is used to evaluate whether rolling update of existing brokers is needed when secrets with\n+     * certificates change. It separates changes for existing certificates with other changes to the secret such as\n+     * added or removed certificates (scale-up or scale-down).\n+     *\n+     * @param current   Existing secret\n+     * @param desired   Desired secret\n+     *\n+     * @return  True if there is a key which exists in the data sections of both secrets and which changed.\n+     */\n+    public static boolean didAnyCertificateChangedInSecret(Secret current, Secret desired) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY1NzE0MQ=="}, "originalCommit": {"oid": "59500b446f6c2a54a53678d6879eabe9257695b9"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NTk4MTE5OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwOToyOToyMlrOFa0Agw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxNjoxMjozOVrOFa-JUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY1OTM5NQ==", "bodyText": "We've got this same pattern of method calls repeated three or four times in this PR. Surely we can factor out a common method which takes the secret name and BiFunction whose argument is a method reference to kafkaExporter::generateSecret or whatever?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2365#discussion_r363659395", "createdAt": "2020-01-07T09:29:22Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2866,12 +2884,18 @@ String getInternalServiceHostname(String serviceName)    {\n         }\n \n         Future<ReconciliationState> kafkaExporterSecret(Supplier<Date> dateSupplier) {\n-            return secretOperations.reconcile(namespace, KafkaExporter.secretName(name),\n-                    kafkaExporter == null ? null : kafkaExporter.generateSecret(clusterCa, isMaintenanceTimeWindowsSatisfied(dateSupplier)))\n-                    .map(res -> {\n-                        isKafkaExporterCertsChanged = res instanceof ReconcileResult.Patched;\n-                        return this;\n-                    });\n+            return secretOperations.getAsync(namespace, KafkaExporter.secretName(name))\n+                    .compose(oldSecret -> secretOperations.reconcile(namespace, KafkaExporter.secretName(name),\n+                            kafkaExporter == null ? null : kafkaExporter.generateSecret(clusterCa, isMaintenanceTimeWindowsSatisfied(dateSupplier)))\n+                            .map(res -> {\n+                                if (res instanceof ReconcileResult.Patched) {\n+                                    // The secret is patched and some changes to the existing certificates actually occured\n+                                    isExistingKafkaExporterCertsChanged = ModelUtils.didAnyCertificateChangedInSecret(oldSecret, res.resource());\n+                                }\n+\n+                                return this;\n+                            })\n+                    );\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59500b446f6c2a54a53678d6879eabe9257695b9"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgyNTQ4OA==", "bodyText": "I migth have done this a bit differently, but I factored it out. and re-used it in all 4 methods.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2365#discussion_r363825488", "createdAt": "2020-01-07T16:12:39Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2866,12 +2884,18 @@ String getInternalServiceHostname(String serviceName)    {\n         }\n \n         Future<ReconciliationState> kafkaExporterSecret(Supplier<Date> dateSupplier) {\n-            return secretOperations.reconcile(namespace, KafkaExporter.secretName(name),\n-                    kafkaExporter == null ? null : kafkaExporter.generateSecret(clusterCa, isMaintenanceTimeWindowsSatisfied(dateSupplier)))\n-                    .map(res -> {\n-                        isKafkaExporterCertsChanged = res instanceof ReconcileResult.Patched;\n-                        return this;\n-                    });\n+            return secretOperations.getAsync(namespace, KafkaExporter.secretName(name))\n+                    .compose(oldSecret -> secretOperations.reconcile(namespace, KafkaExporter.secretName(name),\n+                            kafkaExporter == null ? null : kafkaExporter.generateSecret(clusterCa, isMaintenanceTimeWindowsSatisfied(dateSupplier)))\n+                            .map(res -> {\n+                                if (res instanceof ReconcileResult.Patched) {\n+                                    // The secret is patched and some changes to the existing certificates actually occured\n+                                    isExistingKafkaExporterCertsChanged = ModelUtils.didAnyCertificateChangedInSecret(oldSecret, res.resource());\n+                                }\n+\n+                                return this;\n+                            })\n+                    );\n         }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY1OTM5NQ=="}, "originalCommit": {"oid": "59500b446f6c2a54a53678d6879eabe9257695b9"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NTk4Nzk2OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QwOTozMToyN1rOFa0Ebw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxNjoxMzowN1rOFa-KRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY2MDM5OQ==", "bodyText": "If we're changing the name of these anyway, I wonder if we should drop the is part. The tense disagrees with the changed suffix, so it reads a bit awkwardly.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2365#discussion_r363660399", "createdAt": "2020-01-07T09:31:27Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -383,10 +383,10 @@ ReconciliationState createReconciliationState(Reconciliation reconciliation, Kaf\n         /* test */ Set<String> fsResizingRestartRequest = new HashSet<>();\n \n         // Certificate change indicators\n-        private boolean isZookeeperCertsChanged = false;\n-        private boolean isKafkaCertsChanged = false;\n-        private boolean isKafkaExporterCertsChanged = false;\n-        private boolean isEntityOperatorCertsChanged = false;\n+        private boolean isExistingZookeeperCertsChanged = false;\n+        private boolean isExistingKafkaCertsChanged = false;\n+        private boolean isExistingKafkaExporterCertsChanged = false;\n+        private boolean isExistingEntityOperatorCertsChanged = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59500b446f6c2a54a53678d6879eabe9257695b9"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgyNTczMw==", "bodyText": "Yeah, now when you say it it sounds weird :-D", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2365#discussion_r363825733", "createdAt": "2020-01-07T16:13:07Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -383,10 +383,10 @@ ReconciliationState createReconciliationState(Reconciliation reconciliation, Kaf\n         /* test */ Set<String> fsResizingRestartRequest = new HashSet<>();\n \n         // Certificate change indicators\n-        private boolean isZookeeperCertsChanged = false;\n-        private boolean isKafkaCertsChanged = false;\n-        private boolean isKafkaExporterCertsChanged = false;\n-        private boolean isEntityOperatorCertsChanged = false;\n+        private boolean isExistingZookeeperCertsChanged = false;\n+        private boolean isExistingKafkaCertsChanged = false;\n+        private boolean isExistingKafkaExporterCertsChanged = false;\n+        private boolean isExistingEntityOperatorCertsChanged = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY2MDM5OQ=="}, "originalCommit": {"oid": "59500b446f6c2a54a53678d6879eabe9257695b9"}, "originalPosition": 11}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 555, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}