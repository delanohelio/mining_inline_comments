{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNDI4Njgy", "number": 3805, "title": "[systemtest] Remove ordering of test cases and do not deploy everything in BeforeAll in LogSettingST", "bodyText": "Signed-off-by: Lukas Kral lukywill16@gmail.com\nType of change\n\nRefactoring\n\nDescription\nThe main idea of this PR is to deploy resources by test -> this means that we will not deploy all of the resources in @BeforeAll block. The main problem of deploying all of the resources in the @BeforeAll block is, that when we want to execute single test for example about KafkaConnect, we have to wait all the time until all the resources are deployed (which can take approx 5-8mins) and then just assert something. I'm changing it to have all the asserts and checks in one test for each resource.\nAnother problem was that when we had all the resources deployed, there were some problems -> for example KafkaExporter wasn't able to handle topics mirrored by MM or MM2 from second Kafka cluster to the my-cluster Kafka cluster, so some tests were failling because of error in KE pod.\nChecklist\n\n Make sure all tests pass", "createdAt": "2020-10-14T14:44:55Z", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3805", "merged": true, "mergeCommit": {"oid": "30e6f1fdb6e23b9d999cd963b351e484d7dc5551"}, "closed": true, "closedAt": "2020-10-19T16:53:19Z", "author": {"login": "im-konge"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSxTqlABqjM4ODEzOTM3ODc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdUCF9BAH2gAyNTAzNDI4NjgyOjAxNGQyMjk5ODhlNjQ0OGIxNWRlZWZjNjhkNjQ2M2Q0NTVlZmMyMjk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "400c0f74b11f5332fd3c4a9ba715722afbdf1ac6", "author": {"user": {"login": "im-konge", "name": "Luk\u00e1\u0161 Kr\u00e1l"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/400c0f74b11f5332fd3c4a9ba715722afbdf1ac6", "committedDate": "2020-10-15T08:25:46Z", "message": "fixup! refactor of LogSettingST\n\nSigned-off-by: Lukas Kral <lukywill16@gmail.com>"}, "afterCommit": {"oid": "8827905694df58f631aa59a40e48951cf58c6664", "author": {"user": {"login": "im-konge", "name": "Luk\u00e1\u0161 Kr\u00e1l"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/8827905694df58f631aa59a40e48951cf58c6664", "committedDate": "2020-10-15T12:54:25Z", "message": "fixup! fixup! refactor of LogSettingST\n\nSigned-off-by: Lukas Kral <lukywill16@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NTA4OTY4", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3805#pullrequestreview-509508968", "createdAt": "2020-10-15T15:31:44Z", "commit": {"oid": "8827905694df58f631aa59a40e48951cf58c6664"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExNDk2MDU2", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3805#pullrequestreview-511496056", "createdAt": "2020-10-19T07:53:26Z", "commit": {"oid": "8827905694df58f631aa59a40e48951cf58c6664"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwNzo1MzoyNlrOHkB7zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwNzo1MzoyNlrOHkB7zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0MjQ3OA==", "bodyText": "We had there some issue that from time to time some containers weren't ready. Did we solve it somehow? If not, we can maybe add some checks for container readiness.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3805#discussion_r507542478", "createdAt": "2020-10-19T07:53:26Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LogSettingST.java", "diffHunk": "@@ -182,181 +187,222 @@\n     };\n \n     @Test\n-    @Order(1)\n-    void testLoggersKafka() {\n-        assertThat(\"Kafka's log level is set properly\", checkLoggersLevel(KAFKA_LOGGERS, KAFKA_MAP), is(true));\n-    }\n+    void testKafkaLogSetting() {\n+        String eoDepName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        String kafkaSsName = KafkaResources.kafkaStatefulSetName(CLUSTER_NAME);\n+        String zkSsName = KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME);\n \n-    @Test\n-    @Order(2)\n-    void testLoggersZookeeper() {\n-        assertThat(\"Zookeeper's log level is set properly\", checkLoggersLevel(ZOOKEEPER_LOGGERS, ZOOKEEPER_MAP), is(true));\n-    }\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDepName);\n+        Map<String, String> kafkaPods = StatefulSetUtils.ssSnapshot(kafkaSsName);\n+        Map<String, String> zkPods = StatefulSetUtils.ssSnapshot(zkSsName);\n \n-    @Test\n-    @Order(3)\n-    void testLoggersTO() {\n-        assertThat(\"Topic operator's log level is set properly\", checkLoggersLevel(OPERATORS_LOGGERS, TO_MAP), is(true));\n-    }\n+        String userName = \"test-user\";\n+        String topicName = \"test-topic\";\n \n-    @Test\n-    @Order(4)\n-    void testLoggersUO() {\n+        KafkaTopicResource.topic(CLUSTER_NAME, topicName).done();\n+        KafkaUserResource.tlsUser(CLUSTER_NAME, userName).done();\n+\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has log level set properly\", CLUSTER_NAME);\n+        assertThat(\"Kafka's log level is set properly\", checkLoggersLevel(KAFKA_LOGGERS, KAFKA_MAP), is(true));\n+        assertThat(\"Zookeeper's log level is set properly\", checkLoggersLevel(ZOOKEEPER_LOGGERS, ZOOKEEPER_MAP), is(true));\n+        assertThat(\"Topic operator's log level is set properly\", checkLoggersLevel(OPERATORS_LOGGERS, TO_MAP), is(true));\n         assertThat(\"User operator's log level is set properly\", checkLoggersLevel(OPERATORS_LOGGERS, UO_MAP), is(true));\n-    }\n \n-    @Test\n-    @Order(5)\n-    void testLoggersKafkaConnect() {\n-        assertThat(\"Kafka connect's log level is set properly\", checkLoggersLevel(CONNECT_LOGGERS, CONNECT_MAP), is(true));\n-    }\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has GC logging enabled in stateful sets/deployments\", CLUSTER_NAME);\n+        assertThat(\"Kafka GC logging is not enabled\", checkGcLoggingStatefulSets(kafkaSsName), is(true));\n+        assertThat(\"Zookeeper GC logging is enabled\", checkGcLoggingStatefulSets(zkSsName), is(true));\n+        assertThat(\"TO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"topic-operator\"), is(true));\n+        assertThat(\"UO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"user-operator\"), is(true));\n+\n+        LOGGER.info(\"Changing JVM options - setting GC logging to false\");\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setJvmOptions(JVM_OPTIONS);\n+            kafka.getSpec().getZookeeper().setJvmOptions(JVM_OPTIONS);\n+            kafka.getSpec().getEntityOperator().getTopicOperator().setJvmOptions(JVM_OPTIONS);\n+            kafka.getSpec().getEntityOperator().getUserOperator().setJvmOptions(JVM_OPTIONS);\n+        });\n \n-    @Test\n-    @Order(6)\n-    void testLoggersMirrorMaker() {\n-        assertThat(\"KafkaMirrorMaker's log level is set properly\", checkLoggersLevel(MIRROR_MAKER_LOGGERS, MM_MAP), is(true));\n-    }\n+        StatefulSetUtils.waitTillSsHasRolled(zkSsName, 1, zkPods);\n+        StatefulSetUtils.waitTillSsHasRolled(kafkaSsName, 3, kafkaPods);\n+        DeploymentUtils.waitTillDepHasRolled(eoDepName, 1, eoPods);\n \n-    @Test\n-    @Order(7)\n-    void testLoggersMirrorMaker2() {\n-        assertThat(\"KafkaMirrorMaker2's log level is set properly\", checkLoggersLevel(MIRROR_MAKER_LOGGERS, MM2_MAP), is(true));\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has GC logging disabled in stateful sets/deployments\", CLUSTER_NAME);\n+        assertThat(\"Kafka GC logging is disabled\", checkGcLoggingStatefulSets(kafkaSsName), is(false));\n+        assertThat(\"Zookeeper GC logging is disabled\", checkGcLoggingStatefulSets(zkSsName), is(false));\n+        assertThat(\"TO GC logging is disabled\", checkGcLoggingDeployments(eoDepName, \"topic-operator\"), is(false));\n+        assertThat(\"UO GC logging is disabled\", checkGcLoggingDeployments(eoDepName, \"user-operator\"), is(false));\n+\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has GC logging disabled in stateful sets/deployments\", GC_LOGGING_SET_NAME);\n+        assertThat(\"Kafka GC logging is enabled\", checkGcLoggingStatefulSets(kafkaSsName), is(false));\n+        assertThat(\"Zookeeper GC logging is enabled\", checkGcLoggingStatefulSets(zkSsName), is(false));\n+        assertThat(\"TO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"topic-operator\"), is(false));\n+        assertThat(\"UO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"user-operator\"), is(false));\n+\n+        kubectlGetStrimzi(CLUSTER_NAME);\n+        kubectlGetStrimzi(GC_LOGGING_SET_NAME);\n+\n+        checkContainersHaveProcessOneAsTini(CLUSTER_NAME);\n+        checkContainersHaveProcessOneAsTini(GC_LOGGING_SET_NAME);\n     }\n \n     @Test\n-    @Order(8)\n-    void testLoggersBridge() {\n-        assertThat(\"Bridge's log level is set properly\", checkLoggersLevel(BRIDGE_LOGGERS, BRIDGE_MAP), is(true));\n+    void testConnectLogSetting() {\n+        KafkaConnectResource.kafkaConnect(CONNECT_NAME, CLUSTER_NAME, 1)\n+            .editSpec()\n+                .withNewInlineLogging()\n+                    .withLoggers(CONNECT_LOGGERS)\n+                .endInlineLogging()\n+                .withNewJvmOptions()\n+                    .withGcLoggingEnabled(true)\n+                .endJvmOptions()\n+            .endSpec()\n+            .done();\n+\n+        String connectDepName = KafkaConnectResources.deploymentName(CONNECT_NAME);\n+        Map<String, String> connectPods = DeploymentUtils.depSnapshot(connectDepName);\n+\n+        LOGGER.info(\"Checking if Connect has log level set properly\");\n+        assertThat(\"KafkaConnect's log level is set properly\", checkLoggersLevel(CONNECT_LOGGERS, CONNECT_MAP), is(true));\n+        assertThat(\"Connect GC logging is enabled\", checkGcLoggingDeployments(connectDepName), is(true));\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CONNECT_NAME, kc -> kc.getSpec().setJvmOptions(JVM_OPTIONS));\n+        DeploymentUtils.waitTillDepHasRolled(connectDepName, 1, connectPods);\n+        assertThat(\"Connect GC logging is disabled\", checkGcLoggingDeployments(connectDepName), is(false));\n+\n+        kubectlGetStrimzi(CONNECT_NAME);\n+        checkContainersHaveProcessOneAsTini(CONNECT_NAME);\n     }\n \n     @Test\n     @OpenShiftOnly\n-    @Order(9)\n-    void testLoggersConnectS2I() {\n+    void testConnectS2ILogSetting() {\n+        KafkaConnectS2IResource.kafkaConnectS2I(CONNECTS2I_NAME, CLUSTER_NAME, 1)\n+            .editSpec()\n+                .withNewInlineLogging()\n+                    .withLoggers(CONNECT_LOGGERS)\n+                .endInlineLogging()\n+                .withNewJvmOptions()\n+                    .withGcLoggingEnabled(true)\n+                .endJvmOptions()\n+            .endSpec()\n+            .done();\n+\n+        String connectS2IDepName = KafkaConnectS2IResources.deploymentName(CONNECTS2I_NAME);\n+        Map<String, String> connectS2IPods = DeploymentConfigUtils.depConfigSnapshot(connectS2IDepName);\n+\n+        LOGGER.info(\"Checking if ConnectS2I has log level set properly\");\n         assertThat(\"KafkaConnectS2I's log level is set properly\", checkLoggersLevel(CONNECT_LOGGERS, CONNECTS2I_MAP), is(true));\n-    }\n+        assertThat(\"ConnectS2I GC logging is enabled\", checkGcLoggingDeploymentConfig(connectS2IDepName), is(true));\n \n-    @Test\n-    @Order(10)\n-    void testGcLoggingNonSetDisabled() {\n-        assertThat(\"Kafka GC logging is enabled\", checkGcLoggingStatefulSets(KafkaResources.kafkaStatefulSetName(GC_LOGGING_SET_NAME)), is(false));\n-        assertThat(\"Zookeeper GC logging is enabled\", checkGcLoggingStatefulSets(KafkaResources.zookeeperStatefulSetName(GC_LOGGING_SET_NAME)), is(false));\n+        KafkaConnectS2IResource.replaceConnectS2IResource(CONNECTS2I_NAME, cs2i -> cs2i.getSpec().setJvmOptions(JVM_OPTIONS));\n+        DeploymentConfigUtils.waitTillDepConfigHasRolled(connectS2IDepName, connectS2IPods);\n+        assertThat(\"ConnectS2I GC logging is disabled\", checkGcLoggingDeploymentConfig(connectS2IDepName), is(false));\n \n-        assertThat(\"TO GC logging is enabled\", checkGcLoggingDeployments(KafkaResources.entityOperatorDeploymentName(GC_LOGGING_SET_NAME), \"topic-operator\"), is(false));\n-        assertThat(\"UO GC logging is enabled\", checkGcLoggingDeployments(KafkaResources.entityOperatorDeploymentName(GC_LOGGING_SET_NAME), \"user-operator\"), is(false));\n+        kubectlGetStrimzi(CONNECTS2I_NAME);\n+        checkContainersHaveProcessOneAsTini(CONNECTS2I_NAME);\n     }\n \n     @Test\n-    @Order(11)\n-    void testGcLoggingSetEnabled() {\n-        assertThat(\"Kafka GC logging is enabled\", checkGcLoggingStatefulSets(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME)), is(true));\n-        assertThat(\"Zookeeper GC logging is enabled\", checkGcLoggingStatefulSets(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME)), is(true));\n+    void testMirrorMakerLogSetting() {\n+        KafkaMirrorMakerResource.kafkaMirrorMaker(MM_NAME, CLUSTER_NAME, GC_LOGGING_SET_NAME, \"my-group\", 1, false)\n+            .editSpec()\n+                .withNewInlineLogging()\n+                    .withLoggers(MIRROR_MAKER_LOGGERS)\n+                .endInlineLogging()\n+                .withNewJvmOptions()\n+                    .withGcLoggingEnabled(true)\n+                .endJvmOptions()\n+            .endSpec()\n+            .done();\n \n-        assertThat(\"TO GC logging is enabled\", checkGcLoggingDeployments(KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME), \"topic-operator\"), is(true));\n-        assertThat(\"UO GC logging is enabled\", checkGcLoggingDeployments(KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME), \"user-operator\"), is(true));\n+        String mmDepName = KafkaMirrorMakerResources.deploymentName(MM_NAME);\n+        Map<String, String> mmPods = DeploymentUtils.depSnapshot(mmDepName);\n \n-        assertThat(\"Connect GC logging is enabled\", checkGcLoggingDeployments(KafkaConnectResources.deploymentName(CONNECT_NAME)), is(true));\n-        assertThat(\"Mirror-maker GC logging is enabled\", checkGcLoggingDeployments(KafkaMirrorMakerResources.deploymentName(MM_NAME)), is(true));\n-        assertThat(\"Mirror-maker-2 GC logging is enabled\", checkGcLoggingDeployments(KafkaMirrorMaker2Resources.deploymentName(MM2_NAME)), is(true));\n+        LOGGER.info(\"Checking if MirrorMaker has log level set properly\");\n+        assertThat(\"KafkaMirrorMaker's log level is set properly\", checkLoggersLevel(MIRROR_MAKER_LOGGERS, MM_MAP), is(true));\n+        assertThat(\"Mirror-maker GC logging is enabled\", checkGcLoggingDeployments(mmDepName), is(true));\n \n-        if (cluster.isNotKubernetes()) {\n-            assertThat(\"ConnectS2I GC logging is enabled\", checkGcLoggingDeploymentConfig(KafkaConnectS2IResources.deploymentName(CONNECTS2I_NAME)), is(true));\n-        }\n+        KafkaMirrorMakerResource.replaceMirrorMakerResource(MM_NAME, mm -> mm.getSpec().setJvmOptions(JVM_OPTIONS));\n+        DeploymentUtils.waitTillDepHasRolled(mmDepName, 1, mmPods);\n+        assertThat(\"Mirror-maker GC logging is disabled\", checkGcLoggingDeployments(mmDepName), is(false));\n+\n+        kubectlGetStrimzi(MM_NAME);\n+        checkContainersHaveProcessOneAsTini(MM_NAME);\n     }\n \n     @Test\n-    @Order(12)\n-    void testGcLoggingSetDisabled() {\n-        String connectName = KafkaConnectResources.deploymentName(CONNECT_NAME);\n-        String connectS2IName = KafkaConnectS2IResources.deploymentName(CONNECTS2I_NAME);\n-        String mmName = KafkaMirrorMakerResources.deploymentName(MM_NAME);\n-        String mm2Name = KafkaMirrorMaker2Resources.deploymentName(MM2_NAME);\n-        String eoName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n-        String kafkaName = KafkaResources.kafkaStatefulSetName(CLUSTER_NAME);\n-        String zkName = KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME);\n-        Map<String, String> connectPods = DeploymentUtils.depSnapshot(connectName);\n-        Map<String, String> mmPods = DeploymentUtils.depSnapshot(mmName);\n-        Map<String, String> mm2Pods = DeploymentUtils.depSnapshot(mm2Name);\n-        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoName);\n-        Map<String, String> kafkaPods = StatefulSetUtils.ssSnapshot(kafkaName);\n-        Map<String, String> zkPods = StatefulSetUtils.ssSnapshot(zkName);\n-\n-        JvmOptions jvmOptions = new JvmOptions();\n-        jvmOptions.setGcLoggingEnabled(false);\n-\n-        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n-            k.getSpec().getKafka().setJvmOptions(jvmOptions);\n-            k.getSpec().getZookeeper().setJvmOptions(jvmOptions);\n-            k.getSpec().getEntityOperator().getTopicOperator().setJvmOptions(jvmOptions);\n-            k.getSpec().getEntityOperator().getUserOperator().setJvmOptions(jvmOptions);\n-        });\n+    void testMirrorMaker2LogSetting() {\n+        KafkaMirrorMaker2Resource.kafkaMirrorMaker2(MM2_NAME, CLUSTER_NAME, GC_LOGGING_SET_NAME, 1, false)\n+            .editSpec()\n+                .withNewInlineLogging()\n+                    .withLoggers(MIRROR_MAKER_LOGGERS)\n+                .endInlineLogging()\n+                .withNewJvmOptions()\n+                    .withGcLoggingEnabled(true)\n+                .endJvmOptions()\n+            .endSpec()\n+            .done();\n \n-        StatefulSetUtils.waitTillSsHasRolled(zkName, 1, zkPods);\n-        StatefulSetUtils.waitTillSsHasRolled(kafkaName, 3, kafkaPods);\n-        DeploymentUtils.waitTillDepHasRolled(eoName, 1, eoPods);\n+        String mm2DepName = KafkaMirrorMaker2Resources.deploymentName(MM2_NAME);\n+        Map<String, String> mm2Pods = DeploymentUtils.depSnapshot(mm2DepName);\n \n-        KafkaConnectResource.replaceKafkaConnectResource(CONNECT_NAME, kc -> kc.getSpec().setJvmOptions(jvmOptions));\n-        DeploymentUtils.waitTillDepHasRolled(connectName, 1, connectPods);\n+        LOGGER.info(\"Checking if MirrorMaker2 has log level set properly\");\n+        assertThat(\"KafkaMirrorMaker2's log level is set properly\", checkLoggersLevel(MIRROR_MAKER_LOGGERS, MM2_MAP), is(true));\n+        assertThat(\"Mirror-maker-2 GC logging is enabled\", checkGcLoggingDeployments(mm2DepName), is(true));\n \n-        if (cluster.isNotKubernetes()) {\n-            KafkaConnectS2IResource.replaceConnectS2IResource(CONNECTS2I_NAME, cs2i -> cs2i.getSpec().setJvmOptions(jvmOptions));\n-            DeploymentConfigUtils.waitTillDepConfigHasRolled(connectS2IName, connectPods);\n-        }\n+        KafkaMirrorMaker2Resource.replaceKafkaMirrorMaker2Resource(MM2_NAME, mm2 -> mm2.getSpec().setJvmOptions(JVM_OPTIONS));\n+        DeploymentUtils.waitTillDepHasRolled(mm2DepName, 1, mm2Pods);\n+        assertThat(\"Mirror-maker2 GC logging is disabled\", checkGcLoggingDeployments(mm2DepName), is(false));\n \n-        KafkaMirrorMakerResource.replaceMirrorMakerResource(MM_NAME, mm -> mm.getSpec().setJvmOptions(jvmOptions));\n-        DeploymentUtils.waitTillDepHasRolled(mmName, 1, mmPods);\n+        kubectlGetStrimzi(MM2_NAME);\n+        checkContainersHaveProcessOneAsTini(MM2_NAME);\n+    }\n \n-        KafkaMirrorMaker2Resource.replaceKafkaMirrorMaker2Resource(MM2_NAME, mm2 -> mm2.getSpec().setJvmOptions(jvmOptions));\n-        DeploymentUtils.waitTillDepHasRolled(mm2Name, 1, mm2Pods);\n+    @Test\n+    void testBridgeLogSetting() {\n+        KafkaBridgeResource.kafkaBridge(BRIDGE_NAME, CLUSTER_NAME, KafkaResources.plainBootstrapAddress(CLUSTER_NAME), 1)\n+            .editSpec()\n+                .withNewInlineLogging()\n+                    .withLoggers(BRIDGE_LOGGERS)\n+                .endInlineLogging()\n+                .withNewJvmOptions()\n+                    .withGcLoggingEnabled(true)\n+                .endJvmOptions()\n+            .endSpec()\n+            .done();\n \n-        assertThat(\"Kafka GC logging is disabled\", checkGcLoggingStatefulSets(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME)), is(false));\n-        assertThat(\"Zookeeper GC logging is disabled\", checkGcLoggingStatefulSets(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME)), is(false));\n+        String bridgeDepName = KafkaBridgeResources.deploymentName(BRIDGE_NAME);\n+        Map<String, String> bridgePods = DeploymentUtils.depSnapshot(bridgeDepName);\n \n-        assertThat(\"TO GC logging is disabled\", checkGcLoggingDeployments(KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME), \"topic-operator\"), is(false));\n-        assertThat(\"UO GC logging is disabled\", checkGcLoggingDeployments(KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME), \"user-operator\"), is(false));\n+        LOGGER.info(\"Checking if Bridge has log level set properly\");\n+        assertThat(\"Bridge's log level is set properly\", checkLoggersLevel(BRIDGE_LOGGERS, BRIDGE_MAP), is(true));\n+        assertThat(\"Bridge's GC logging is enabled\", checkGcLoggingDeployments(bridgeDepName), is(true));\n \n-        assertThat(\"Connect GC logging is disabled\", checkGcLoggingDeployments(KafkaConnectResources.deploymentName(CONNECT_NAME)), is(false));\n-        assertThat(\"Mirror-maker GC logging is disabled\", checkGcLoggingDeployments(KafkaMirrorMakerResources.deploymentName(MM_NAME)), is(false));\n-        assertThat(\"Mirror-maker2 GC logging is disabled\", checkGcLoggingDeployments(KafkaMirrorMaker2Resources.deploymentName(MM2_NAME)), is(false));\n+        KafkaBridgeResource.replaceBridgeResource(BRIDGE_NAME, bridge -> bridge.getSpec().setJvmOptions(JVM_OPTIONS));\n+        DeploymentUtils.waitTillDepHasRolled(bridgeDepName, 1, bridgePods);\n+        assertThat(\"Bridge GC logging is disabled\", checkGcLoggingDeployments(bridgeDepName), is(false));\n \n-        if (cluster.isNotKubernetes()) {\n-            assertThat(\"ConnectS2I GC logging is disabled\", checkGcLoggingDeploymentConfig(KafkaConnectS2IResources.deploymentName(CONNECTS2I_NAME)), is(false));\n-        }\n+        kubectlGetStrimzi(BRIDGE_NAME);\n+        checkContainersHaveProcessOneAsTini(BRIDGE_NAME);\n     }\n \n-    @Test\n-    @Order(13)\n-    void testKubectlGetStrimzi() {\n-        String userName = \"test-user\";\n-        String topicName = \"test-topic\";\n-\n-        KafkaTopicResource.topic(CLUSTER_NAME, topicName).done();\n-        KafkaUserResource.tlsUser(CLUSTER_NAME, userName).done();\n-\n+    void kubectlGetStrimzi(String resourceName) {\n+        LOGGER.info(\"Checking if kubectl get strimzi contains {}\", resourceName);\n         String strimziCRs = cmdKubeClient().execInCurrentNamespace(\"get\", \"strimzi\").out();\n-\n-        assertThat(strimziCRs, containsString(CLUSTER_NAME));\n-        assertThat(strimziCRs, containsString(GC_LOGGING_SET_NAME));\n-        assertThat(strimziCRs, containsString(MM_NAME));\n-        assertThat(strimziCRs, containsString(MM2_NAME));\n-        assertThat(strimziCRs, containsString(BRIDGE_NAME));\n-        assertThat(strimziCRs, containsString(CONNECT_NAME));\n-        assertThat(strimziCRs, containsString(userName));\n-        assertThat(strimziCRs, containsString(topicName));\n+        assertThat(strimziCRs, containsString(resourceName));\n     }\n \n-    @Test\n-    @Order(14)\n-    void testCheckContainersHaveProcessOneAsTini() {\n+    void checkContainersHaveProcessOneAsTini(String resourceClusterName) {\n         //Used [/] in the grep command so that grep process does not return itself\n         String command = \"ps -ef | grep '[/]usr/bin/tini' | awk '{ print $2}'\";\n \n-        for (Pod pod : kubeClient().listPods()) {\n+        for (Pod pod : kubeClient().listPods(Labels.STRIMZI_CLUSTER_LABEL, resourceClusterName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8827905694df58f631aa59a40e48951cf58c6664"}, "originalPosition": 374}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a203439441dbeda97e7b9953fb81e01c3c42bb5", "author": {"user": {"login": "im-konge", "name": "Luk\u00e1\u0161 Kr\u00e1l"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/1a203439441dbeda97e7b9953fb81e01c3c42bb5", "committedDate": "2020-10-19T08:29:33Z", "message": "refactor of LogSettingST\n\nSigned-off-by: Lukas Kral <lukywill16@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "265f99ae3d516a982deb165c08d5708531298b86", "author": {"user": {"login": "im-konge", "name": "Luk\u00e1\u0161 Kr\u00e1l"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/265f99ae3d516a982deb165c08d5708531298b86", "committedDate": "2020-10-19T08:29:33Z", "message": "fixup! refactor of LogSettingST\n\nSigned-off-by: Lukas Kral <lukywill16@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23bba76fddaed613c106613e0273e13875ec8d09", "author": {"user": {"login": "im-konge", "name": "Luk\u00e1\u0161 Kr\u00e1l"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/23bba76fddaed613c106613e0273e13875ec8d09", "committedDate": "2020-10-19T08:29:33Z", "message": "fixup! fixup! refactor of LogSettingST\n\nSigned-off-by: Lukas Kral <lukywill16@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExNTQwMDc5", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3805#pullrequestreview-511540079", "createdAt": "2020-10-19T08:47:25Z", "commit": {"oid": "8827905694df58f631aa59a40e48951cf58c6664"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39ae6caf0ee29937059ad619fd763e2d87f346df", "author": {"user": {"login": "im-konge", "name": "Luk\u00e1\u0161 Kr\u00e1l"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/39ae6caf0ee29937059ad619fd763e2d87f346df", "committedDate": "2020-10-19T09:57:26Z", "message": "add wait for pod's container ready\n\nSigned-off-by: Lukas Kral <lukywill16@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8827905694df58f631aa59a40e48951cf58c6664", "author": {"user": {"login": "im-konge", "name": "Luk\u00e1\u0161 Kr\u00e1l"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/8827905694df58f631aa59a40e48951cf58c6664", "committedDate": "2020-10-15T12:54:25Z", "message": "fixup! fixup! refactor of LogSettingST\n\nSigned-off-by: Lukas Kral <lukywill16@gmail.com>"}, "afterCommit": {"oid": "39ae6caf0ee29937059ad619fd763e2d87f346df", "author": {"user": {"login": "im-konge", "name": "Luk\u00e1\u0161 Kr\u00e1l"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/39ae6caf0ee29937059ad619fd763e2d87f346df", "committedDate": "2020-10-19T09:57:26Z", "message": "add wait for pod's container ready\n\nSigned-off-by: Lukas Kral <lukywill16@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExNjQzNDE3", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3805#pullrequestreview-511643417", "createdAt": "2020-10-19T10:59:22Z", "commit": {"oid": "39ae6caf0ee29937059ad619fd763e2d87f346df"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMDo1OToyMlrOHkI6SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMDo1OToyMlrOHkI6SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY1Njc3Nw==", "bodyText": "leftover?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3805#discussion_r507656777", "createdAt": "2020-10-19T10:59:22Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LogSettingST.java", "diffHunk": "@@ -182,181 +188,224 @@\n     };\n \n     @Test\n-    @Order(1)\n-    void testLoggersKafka() {\n-        assertThat(\"Kafka's log level is set properly\", checkLoggersLevel(KAFKA_LOGGERS, KAFKA_MAP), is(true));\n-    }\n+    void testKafkaLogSetting() {\n+        String eoDepName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        String kafkaSsName = KafkaResources.kafkaStatefulSetName(CLUSTER_NAME);\n+        String zkSsName = KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME);\n \n-    @Test\n-    @Order(2)\n-    void testLoggersZookeeper() {\n-        assertThat(\"Zookeeper's log level is set properly\", checkLoggersLevel(ZOOKEEPER_LOGGERS, ZOOKEEPER_MAP), is(true));\n-    }\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDepName);\n+        Map<String, String> kafkaPods = StatefulSetUtils.ssSnapshot(kafkaSsName);\n+        Map<String, String> zkPods = StatefulSetUtils.ssSnapshot(zkSsName);\n \n-    @Test\n-    @Order(3)\n-    void testLoggersTO() {\n-        assertThat(\"Topic operator's log level is set properly\", checkLoggersLevel(OPERATORS_LOGGERS, TO_MAP), is(true));\n-    }\n+        String userName = \"test-user\";\n+        String topicName = \"test-topic\";\n \n-    @Test\n-    @Order(4)\n-    void testLoggersUO() {\n+        KafkaTopicResource.topic(CLUSTER_NAME, topicName).done();\n+        KafkaUserResource.tlsUser(CLUSTER_NAME, userName).done();\n+\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has log level set properly\", CLUSTER_NAME);\n+        assertThat(\"Kafka's log level is set properly\", checkLoggersLevel(KAFKA_LOGGERS, KAFKA_MAP), is(true));\n+        assertThat(\"Zookeeper's log level is set properly\", checkLoggersLevel(ZOOKEEPER_LOGGERS, ZOOKEEPER_MAP), is(true));\n+        assertThat(\"Topic operator's log level is set properly\", checkLoggersLevel(OPERATORS_LOGGERS, TO_MAP), is(true));\n         assertThat(\"User operator's log level is set properly\", checkLoggersLevel(OPERATORS_LOGGERS, UO_MAP), is(true));\n-    }\n \n-    @Test\n-    @Order(5)\n-    void testLoggersKafkaConnect() {\n-        assertThat(\"Kafka connect's log level is set properly\", checkLoggersLevel(CONNECT_LOGGERS, CONNECT_MAP), is(true));\n-    }\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has GC logging enabled in stateful sets/deployments\", CLUSTER_NAME);\n+        assertThat(\"Kafka GC logging is not enabled\", checkGcLoggingStatefulSets(kafkaSsName), is(true));\n+        assertThat(\"Zookeeper GC logging is enabled\", checkGcLoggingStatefulSets(zkSsName), is(true));\n+        assertThat(\"TO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"topic-operator\"), is(true));\n+        assertThat(\"UO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"user-operator\"), is(true));\n+\n+        LOGGER.info(\"Changing JVM options - setting GC logging to false\");\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setJvmOptions(JVM_OPTIONS);\n+            kafka.getSpec().getZookeeper().setJvmOptions(JVM_OPTIONS);\n+            kafka.getSpec().getEntityOperator().getTopicOperator().setJvmOptions(JVM_OPTIONS);\n+            kafka.getSpec().getEntityOperator().getUserOperator().setJvmOptions(JVM_OPTIONS);\n+        });\n \n-    @Test\n-    @Order(6)\n-    void testLoggersMirrorMaker() {\n-        assertThat(\"KafkaMirrorMaker's log level is set properly\", checkLoggersLevel(MIRROR_MAKER_LOGGERS, MM_MAP), is(true));\n-    }\n+        StatefulSetUtils.waitTillSsHasRolled(zkSsName, 1, zkPods);\n+        StatefulSetUtils.waitTillSsHasRolled(kafkaSsName, 3, kafkaPods);\n+        DeploymentUtils.waitTillDepHasRolled(eoDepName, 1, eoPods);\n \n-    @Test\n-    @Order(7)\n-    void testLoggersMirrorMaker2() {\n-        assertThat(\"KafkaMirrorMaker2's log level is set properly\", checkLoggersLevel(MIRROR_MAKER_LOGGERS, MM2_MAP), is(true));\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has GC logging disabled in stateful sets/deployments\", CLUSTER_NAME);\n+        assertThat(\"Kafka GC logging is disabled\", checkGcLoggingStatefulSets(kafkaSsName), is(false));\n+        assertThat(\"Zookeeper GC logging is disabled\", checkGcLoggingStatefulSets(zkSsName), is(false));\n+        assertThat(\"TO GC logging is disabled\", checkGcLoggingDeployments(eoDepName, \"topic-operator\"), is(false));\n+        assertThat(\"UO GC logging is disabled\", checkGcLoggingDeployments(eoDepName, \"user-operator\"), is(false));\n+\n+        LOGGER.info(\"Checking if Kafka, Zookeeper, TO and UO of cluster:{} has GC logging disabled in stateful sets/deployments\", GC_LOGGING_SET_NAME);\n+        assertThat(\"Kafka GC logging is enabled\", checkGcLoggingStatefulSets(kafkaSsName), is(false));\n+        assertThat(\"Zookeeper GC logging is enabled\", checkGcLoggingStatefulSets(zkSsName), is(false));\n+        assertThat(\"TO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"topic-operator\"), is(false));\n+        assertThat(\"UO GC logging is enabled\", checkGcLoggingDeployments(eoDepName, \"user-operator\"), is(false));\n+\n+//        kubectlGetStrimzi(CLUSTER_NAME);\n+//        kubectlGetStrimzi(GC_LOGGING_SET_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39ae6caf0ee29937059ad619fd763e2d87f346df"}, "originalPosition": 128}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "014d229988e6448b15deefc68d6463d455efc229", "author": {"user": {"login": "im-konge", "name": "Luk\u00e1\u0161 Kr\u00e1l"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/014d229988e6448b15deefc68d6463d455efc229", "committedDate": "2020-10-19T11:02:02Z", "message": "leftover\n\nSigned-off-by: Lukas Kral <lukywill16@gmail.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 802, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}