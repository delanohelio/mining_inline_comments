{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3NzkzMjQ0", "number": 2780, "title": "Context succeeding - Part 7", "bodyText": "For this Pull request I have continued the context\nsucceeding work, and taken the opportunity to remove\nunneeded concurrency based dependencies.\nminor test renames, hamcrest additions and variable\nrenames to improve clarity.\nPart 7 : cluster-operator\nTest refactoring removing test exceptions\nMove repeated code to BeforeEach methods\nKafkaAssemblyOperatorMockTest refactor and clean up\nType of change\nSelect the type of your PR\n\nBugfix\nEnhancement / new feature\nRefactoring\nDocumentation\n\nDescription\nPlease describe your pull request\nChecklist\nPlease go through this checklist and make sure all applicable tasks have been done\n\n Update/write design documentation in ./design\n Write tests\n Make sure all tests pass\n Update documentation\n Check RBAC rights for Kubernetes / OpenShift roles\n Try your changes from Pod inside your Kubernetes and OpenShift cluster, not just locally\n Reference relevant issue(s) and close them after merging\n Update CHANGELOG.md", "createdAt": "2020-04-02T20:14:44Z", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2780", "merged": true, "mergeCommit": {"oid": "09ba1c22779d1c3eb4695a7b93a2f3cc7d46404c"}, "closed": true, "closedAt": "2020-04-03T19:24:06Z", "author": {"login": "samuel-hawker"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcT0xuOgFqTM4Njg0MjExOA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcUED3ygFqTM4NzQzNDA1Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2ODQyMTE4", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2780#pullrequestreview-386842118", "createdAt": "2020-04-02T23:17:34Z", "commit": {"oid": "6f3992dedb2e5800e5d0777b3380e106d7813068"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMzoxNzozNFrOF__zyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMzoxOTo0MVrOF__2jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1MDA1OQ==", "bodyText": "I think some of these will cause lot of conflicts with my changes in #2737. Some things such as the metrics do not work well when you are opening and closing vertx too often. So I actually mmoved most of these to @BeforeAll / @afterall and tied to keep the method names as before and after. Was there any particular reason why moving Vet.x to @beforeeach / @AfterEach?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2780#discussion_r402650059", "createdAt": "2020-04-02T23:17:34Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorCustomCertTest.java", "diffHunk": "@@ -62,17 +66,91 @@\n     private final String clusterName = \"testkafka\";\n     protected static Vertx vertx;\n \n-    @BeforeAll\n-    public static void before() {\n+    private Kafka kafka;\n+    private KafkaCluster kafkaCluster;\n+    private ResourceOperatorSupplier supplier;\n+    private KafkaAssemblyOperator operator;\n+    private ArgumentCaptor<StatefulSet> reconcileStsCaptor;\n+    private ArgumentCaptor<Function<Pod, String>> isPodToRestartFunctionCaptor;\n+\n+    /**\n+     * Mock the KafkaAssemblyOperator and override reconcile to only run through the steps we want to test\n+     */\n+    class MockKafkaAssemblyOperator extends KafkaAssemblyOperator  {\n+        public MockKafkaAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa, CertManager certManager, PasswordGenerator passwordGenerator, ResourceOperatorSupplier supplier, ClusterOperatorConfig config) {\n+            super(vertx, pfa, certManager, passwordGenerator, supplier, config);\n+        }\n+\n+        @Override\n+        Future<Void> reconcile(ReconciliationState reconcileState)  {\n+            return reconcileState.reconcileCas(this::dateSupplier)\n+                    .compose(state -> state.getKafkaClusterDescription())\n+                    .compose(state -> state.customTlsListenerCertificate())\n+                    .compose(state -> state.customExternalListenerCertificate())\n+                    .compose(state -> state.kafkaStatefulSet())\n+                    .compose(state -> state.kafkaRollingUpdate())\n+                    .map((Void) null);\n+        }\n+    }\n+\n+    @BeforeEach\n+    public void before() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f3992dedb2e5800e5d0777b3380e106d7813068"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1MDIyMQ==", "bodyText": "I guess this is some rebasing issue? Should it be deleted or uncommented?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2780#discussion_r402650221", "createdAt": "2020-04-02T23:18:04Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorCustomCertTest.java", "diffHunk": "@@ -153,197 +231,207 @@ public Pod getPod(StatefulSet sts) {\n     }\n \n     @Test\n-    public void testWithUnchangedCertificates(VertxTestContext context) throws InterruptedException {\n-        Kafka kafka = getKafkaCrd();\n-        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(false);\n-        KafkaCluster kafkaCluster = KafkaCluster.fromCrd(kafka, VERSIONS, null);\n-\n-        // Mock the Kafka Operator\n-        CrdOperator mockKafkaOps = supplier.kafkaOperator;\n-        when(mockKafkaOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(getKafkaCrd()));\n-        when(mockKafkaOps.updateStatusAsync(any())).thenReturn(Future.succeededFuture());\n-\n-        // Mock the KafkaSetOperator\n-        KafkaSetOperator mockKafkaSetOps = supplier.kafkaSetOperations;\n-        when(mockKafkaSetOps.getAsync(eq(namespace), eq(KafkaCluster.kafkaClusterName(clusterName)))).thenReturn(Future.succeededFuture(kafkaCluster.generateStatefulSet(false, null, null)));\n-\n-        ArgumentCaptor<StatefulSet> reconcileStsCaptor = ArgumentCaptor.forClass(StatefulSet.class);\n-        when(mockKafkaSetOps.reconcile(eq(namespace), eq(KafkaCluster.kafkaClusterName(clusterName)), reconcileStsCaptor.capture())).then(invocation -> {\n-            return Future.succeededFuture(ReconcileResult.patched(invocation.getArgument(2)));\n-        });\n-\n-        ArgumentCaptor<StatefulSet> maybeRollingUpdateStsCaptor = ArgumentCaptor.forClass(StatefulSet.class);\n-        ArgumentCaptor<Function<Pod, String>> isPodToRestartFunctionCaptor = ArgumentCaptor.forClass(Function.class);\n-        when(mockKafkaSetOps.maybeRollingUpdate(maybeRollingUpdateStsCaptor.capture(), isPodToRestartFunctionCaptor.capture())).thenReturn(Future.succeededFuture());\n-\n-        // Mock the ConfigMapOperator\n-        ConfigMapOperator mockCmOps = supplier.configMapOperations;\n-        when(mockCmOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(kafkaCluster.generateMetricsAndLogConfigMap(null)));\n-\n-        // Mock the SecretOperator\n-        SecretOperator mockSecretOps = supplier.secretOperations;\n-        when(mockSecretOps.getAsync(eq(namespace), eq(\"my-tls-secret\"))).thenReturn(Future.succeededFuture(getTlsSecret()));\n-        when(mockSecretOps.getAsync(eq(namespace), eq(\"my-external-secret\"))).thenReturn(Future.succeededFuture(getExternalSecret()));\n-        when(mockSecretOps.reconcile(any(), any(), any())).then(invocation -> {\n-            return Future.succeededFuture(ReconcileResult.created(invocation.getArgument(2)));\n-        });\n-\n-        MockKafkaAssemblyOperator kao = new MockKafkaAssemblyOperator(vertx, new PlatformFeaturesAvailability(false, kubernetesVersion),\n-                certManager,\n-                passwordGenerator,\n-                supplier,\n-                config);\n-\n+    public void testPodToRestartFalseWhenCustomCertAnnotationsHaveMatchingThumbprints(VertxTestContext context) {\n         Checkpoint async = context.checkpoint();\n-        kao.createOrUpdate(new Reconciliation(\"test-trigger\", Kafka.RESOURCE_KIND, namespace, clusterName), kafka).setHandler(res -> {\n-            assertThat(res.succeeded(), is(true));\n-\n-            assertThat(reconcileStsCaptor.getAllValues().size(), is(1));\n-\n-            StatefulSet reconcileSts = reconcileStsCaptor.getValue();\n-            assertThat(reconcileSts.getSpec().getTemplate().getMetadata().getAnnotations().getOrDefault(KafkaCluster.ANNO_STRIMZI_CUSTOM_CERT_THUMBPRINT_TLS_LISTENER, \"\"), is(getTlsThumbprint()));\n-            assertThat(reconcileSts.getSpec().getTemplate().getMetadata().getAnnotations().getOrDefault(KafkaCluster.ANNO_STRIMZI_CUSTOM_CERT_THUMBPRINT_EXTERNAL_LISTENER, \"\"), is(getExternalThumbprint()));\n-\n-            assertThat(isPodToRestartFunctionCaptor.getAllValues().size(), is(1));\n-\n-            Function<Pod, String> isPodToRestart = isPodToRestartFunctionCaptor.getValue();\n-            assertThat(isPodToRestart.apply(getPod(reconcileSts)), is(nullValue()));\n-\n-            async.flag();\n-        });\n+        operator.createOrUpdate(new Reconciliation(\"test-trigger\", Kafka.RESOURCE_KIND, namespace, clusterName), kafka)\n+            .setHandler(context.succeeding(v -> context.verify(() -> {\n+                assertThat(reconcileStsCaptor.getAllValues(), hasSize(1));\n+\n+                StatefulSet reconcileSts = reconcileStsCaptor.getValue();\n+                assertThat(reconcileSts.getSpec().getTemplate().getMetadata().getAnnotations(),\n+                        hasEntry(KafkaCluster.ANNO_STRIMZI_CUSTOM_CERT_THUMBPRINT_TLS_LISTENER, getTlsThumbprint()));\n+                assertThat(reconcileSts.getSpec().getTemplate().getMetadata().getAnnotations(),\n+                        hasEntry(KafkaCluster.ANNO_STRIMZI_CUSTOM_CERT_THUMBPRINT_EXTERNAL_LISTENER, getExternalThumbprint()));\n+\n+                assertThat(isPodToRestartFunctionCaptor.getAllValues(), hasSize(1));\n+                Function<Pod, String> isPodToRestart = isPodToRestartFunctionCaptor.getValue();\n+                assertThat(isPodToRestart.apply(getPod(reconcileSts)), is(nullValue()));\n+\n+                async.flag();\n+            })));\n     }\n \n-    @Test\n-    public void testWithChangedTlsCertificate(VertxTestContext context) throws InterruptedException {\n-        Kafka kafka = getKafkaCrd();\n-        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(false);\n-        KafkaCluster kafkaCluster = KafkaCluster.fromCrd(kafka, VERSIONS, null);\n-\n-        // Mock the Kafka Operator\n-        CrdOperator mockKafkaOps = supplier.kafkaOperator;\n-        when(mockKafkaOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(getKafkaCrd()));\n-        when(mockKafkaOps.updateStatusAsync(any())).thenReturn(Future.succeededFuture());\n-\n-        // Mock the KafkaSetOperator\n-        KafkaSetOperator mockKafkaSetOps = supplier.kafkaSetOperations;\n-        when(mockKafkaSetOps.getAsync(eq(namespace), eq(KafkaCluster.kafkaClusterName(clusterName)))).thenReturn(Future.succeededFuture(kafkaCluster.generateStatefulSet(false, null, null)));\n-\n-        ArgumentCaptor<StatefulSet> reconcileStsCaptor = ArgumentCaptor.forClass(StatefulSet.class);\n-        when(mockKafkaSetOps.reconcile(eq(namespace), eq(KafkaCluster.kafkaClusterName(clusterName)), reconcileStsCaptor.capture())).then(invocation -> {\n-            return Future.succeededFuture(ReconcileResult.patched(invocation.getArgument(2)));\n-        });\n-\n-        ArgumentCaptor<StatefulSet> maybeRollingUpdateStsCaptor = ArgumentCaptor.forClass(StatefulSet.class);\n-        ArgumentCaptor<Function<Pod, String>> isPodToRestartFunctionCaptor = ArgumentCaptor.forClass(Function.class);\n-        when(mockKafkaSetOps.maybeRollingUpdate(maybeRollingUpdateStsCaptor.capture(), isPodToRestartFunctionCaptor.capture())).thenReturn(Future.succeededFuture());\n-\n-        // Mock the ConfigMapOperator\n-        ConfigMapOperator mockCmOps = supplier.configMapOperations;\n-        when(mockCmOps.get(eq(namespace), eq(clusterName))).thenReturn(kafkaCluster.generateMetricsAndLogConfigMap(null));\n-\n-        // Mock the SecretOperator\n-        SecretOperator mockSecretOps = supplier.secretOperations;\n-        when(mockSecretOps.getAsync(eq(namespace), eq(\"my-tls-secret\"))).thenReturn(Future.succeededFuture(getTlsSecret()));\n-        when(mockSecretOps.getAsync(eq(namespace), eq(\"my-external-secret\"))).thenReturn(Future.succeededFuture(getExternalSecret()));\n-        when(mockSecretOps.reconcile(any(), any(), any())).then(invocation -> {\n-            return Future.succeededFuture(ReconcileResult.created(invocation.getArgument(2)));\n-        });\n-\n-        MockKafkaAssemblyOperator kao = new MockKafkaAssemblyOperator(vertx, new PlatformFeaturesAvailability(false, kubernetesVersion),\n-                certManager,\n-                passwordGenerator,\n-                supplier,\n-                config);\n+//<<<<<<<HEAD", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f3992dedb2e5800e5d0777b3380e106d7813068"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1MDc2Nw==", "bodyText": "In #2737 I tended to use before and after which seemed to be used most often as method names. I do not have strong preference, but we should try to use the same everywhere.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2780#discussion_r402650767", "createdAt": "2020-04-02T23:19:41Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorMockTest.java", "diffHunk": "@@ -195,19 +204,35 @@ public void setFields(KafkaAssemblyOperatorMockTest.Params params) {\n         this.kafkaStorage = params.kafkaStorage;\n \n         this.resources = params.resources;\n-        this.before();\n     }\n \n-    private Vertx vertx;\n     private Kafka cluster;\n \n-    public void before() {\n-        this.cluster = new KafkaBuilder()\n-                .withMetadata(new ObjectMetaBuilder()\n-                        .withName(CLUSTER_NAME)\n-                        .withNamespace(NAMESPACE)\n-                        .withLabels(TestUtils.map(\"foo\", \"bar\"))\n-                        .build())\n+    @BeforeAll\n+    static void setup() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f3992dedb2e5800e5d0777b3380e106d7813068"}, "originalPosition": 141}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3MDY0NjUy", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2780#pullrequestreview-387064652", "createdAt": "2020-04-03T08:41:22Z", "commit": {"oid": "6f3992dedb2e5800e5d0777b3380e106d7813068"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "203b16fe0a0e6f513eac901e10ffc02e0b832a0b", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/203b16fe0a0e6f513eac901e10ffc02e0b832a0b", "committedDate": "2020-04-03T12:10:36Z", "message": "feat: Context succeeding - Part 7\n\nFor this Pull request I have continued the context\nsucceeding work, and taken the opportunity to remove\nunneeded concurrency based dependencies.\nminor test renames, hamcrest additions and variable\nrenames to improve clarity.\n\nPart 7 : cluster-operator\nTest refactoring removing test exceptions\nMove repeated code to BeforeEach methods\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a31ba339ad69198d1896896fa5c824844d28753c", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/a31ba339ad69198d1896896fa5c824844d28753c", "committedDate": "2020-04-03T12:12:38Z", "message": "feat: Assembly operator refactor\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a711b1ffff35bbdf5ccada87bfd330c50610975", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/6a711b1ffff35bbdf5ccada87bfd330c50610975", "committedDate": "2020-04-03T12:12:38Z", "message": "chore: address review comments\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8547520469076007b869e39c653fe22eec4edc60", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/8547520469076007b869e39c653fe22eec4edc60", "committedDate": "2020-04-03T12:58:06Z", "message": "feat: Merge conflict\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7821c0aa8517fc2520e3920bdcefbba54aec974f", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/7821c0aa8517fc2520e3920bdcefbba54aec974f", "committedDate": "2020-04-03T08:50:50Z", "message": "chore: address review comments\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}, "afterCommit": {"oid": "8547520469076007b869e39c653fe22eec4edc60", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/8547520469076007b869e39c653fe22eec4edc60", "committedDate": "2020-04-03T12:58:06Z", "message": "feat: Merge conflict\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NDM0MDU3", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2780#pullrequestreview-387434057", "createdAt": "2020-04-03T17:08:25Z", "commit": {"oid": "8547520469076007b869e39c653fe22eec4edc60"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2177, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}