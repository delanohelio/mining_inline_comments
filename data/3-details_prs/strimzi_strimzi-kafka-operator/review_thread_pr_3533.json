{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxNjE1MDI4", "number": 3533, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNToxNTo1MlrOEeWaTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwOTo1MzoyMlrOEfYTWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjU5OTE5OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAbstractST.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNToxNTo1MlrOHJ9B0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNjo1Mzo1MlrOHK_ysQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE5OTEyMw==", "bodyText": "Why not to use the JobUtils.deleteJob()?\nAnd question -> don't we want to add something like JobsClient() to not always do the kubeClient().getClient().batch().jobs()? This is just a question/suggestion.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3533#discussion_r480199123", "createdAt": "2020-08-31T15:15:52Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAbstractST.java", "diffHunk": "@@ -72,73 +67,31 @@ void setup() throws Exception {\n \n         KeycloakUtils.deployKeycloak(NAMESPACE);\n \n-        // https\n-        Service keycloakService = KubernetesResource.createKeycloakNodePortService(NAMESPACE);\n-        KubernetesResource.createServiceResource(keycloakService, NAMESPACE);\n-        ServiceUtils.waitForNodePortService(keycloakService.getMetadata().getName());\n-\n-        // http\n-        Service keycloakHttpService = KubernetesResource.createKeycloakNodePortHttpService(NAMESPACE);\n-        KubernetesResource.createServiceResource(keycloakHttpService, NAMESPACE);\n-        ServiceUtils.waitForNodePortService(keycloakHttpService.getMetadata().getName());\n-\n         String passwordEncoded = kubeClient().getSecret(\"credential-example-keycloak\").getData().get(\"ADMIN_PASSWORD\");\n         String password = new String(Base64.getDecoder().decode(passwordEncoded.getBytes()));\n         keycloakInstance = new KeycloakInstance(\"admin\", password, NAMESPACE);\n \n-        clusterHost = kubeClient().getNodeAddress();\n-\n-        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3, 1)\n-            .editSpec()\n-                .editKafka()\n-                    .editListeners()\n-                        .withNewTls()\n-                            .withNewKafkaListenerAuthenticationOAuth()\n-                                .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n-                                .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n-                                .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n-                                .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n-                                .withUserNameClaim(keycloakInstance.getUserNameClaim())\n-                                .withTlsTrustedCertificates(\n-                                    new CertSecretSourceBuilder()\n-                                        .withSecretName(SECRET_OF_KEYCLOAK)\n-                                        .withCertificate(CERTIFICATE_OF_KEYCLOAK)\n-                                        .build())\n-                                .withDisableTlsHostnameVerification(true)\n-                            .endKafkaListenerAuthenticationOAuth()\n-                        .endTls()\n-                        .withNewKafkaListenerExternalNodePort()\n-                            .withNewKafkaListenerAuthenticationOAuth()\n-                                .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n-                                .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n-                                .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n-                                .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n-                                .withUserNameClaim(keycloakInstance.getUserNameClaim())\n-                                .withTlsTrustedCertificates(\n-                                    new CertSecretSourceBuilder()\n-                                        .withSecretName(SECRET_OF_KEYCLOAK)\n-                                        .withCertificate(CERTIFICATE_OF_KEYCLOAK)\n-                                        .build())\n-                                .withDisableTlsHostnameVerification(true)\n-                            .endKafkaListenerAuthenticationOAuth()\n-                        .endKafkaListenerExternalNodePort()\n-                    .endListeners()\n-                .endKafka()\n-            .endSpec()\n-            .done();\n-\n-        KafkaTopicResource.topic(CLUSTER_NAME, TOPIC_NAME).done();\n-\n         createSecretsForDeployments();\n+    }\n+\n+    @AfterEach\n+    void tearDown() {\n \n-        KafkaUserResource.tlsUser(CLUSTER_NAME, OAUTH_CLIENT_NAME).done();\n+        for (Job job : kubeClient().getClient().batch().jobs().inNamespace(NAMESPACE).list().getItems()) {\n+            LOGGER.info(\"Deleting {} job\", job.getMetadata().getName());\n+            kubeClient().getClient().batch().jobs().inNamespace(NAMESPACE).delete(job);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93bee8ca22346ac0b49ecebcd0cc87767c3afa76"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDIwMzgzMA==", "bodyText": "Leftover, feel free to open issue to add this job implementation to kubeclient.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3533#discussion_r480203830", "createdAt": "2020-08-31T15:23:33Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAbstractST.java", "diffHunk": "@@ -72,73 +67,31 @@ void setup() throws Exception {\n \n         KeycloakUtils.deployKeycloak(NAMESPACE);\n \n-        // https\n-        Service keycloakService = KubernetesResource.createKeycloakNodePortService(NAMESPACE);\n-        KubernetesResource.createServiceResource(keycloakService, NAMESPACE);\n-        ServiceUtils.waitForNodePortService(keycloakService.getMetadata().getName());\n-\n-        // http\n-        Service keycloakHttpService = KubernetesResource.createKeycloakNodePortHttpService(NAMESPACE);\n-        KubernetesResource.createServiceResource(keycloakHttpService, NAMESPACE);\n-        ServiceUtils.waitForNodePortService(keycloakHttpService.getMetadata().getName());\n-\n         String passwordEncoded = kubeClient().getSecret(\"credential-example-keycloak\").getData().get(\"ADMIN_PASSWORD\");\n         String password = new String(Base64.getDecoder().decode(passwordEncoded.getBytes()));\n         keycloakInstance = new KeycloakInstance(\"admin\", password, NAMESPACE);\n \n-        clusterHost = kubeClient().getNodeAddress();\n-\n-        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3, 1)\n-            .editSpec()\n-                .editKafka()\n-                    .editListeners()\n-                        .withNewTls()\n-                            .withNewKafkaListenerAuthenticationOAuth()\n-                                .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n-                                .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n-                                .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n-                                .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n-                                .withUserNameClaim(keycloakInstance.getUserNameClaim())\n-                                .withTlsTrustedCertificates(\n-                                    new CertSecretSourceBuilder()\n-                                        .withSecretName(SECRET_OF_KEYCLOAK)\n-                                        .withCertificate(CERTIFICATE_OF_KEYCLOAK)\n-                                        .build())\n-                                .withDisableTlsHostnameVerification(true)\n-                            .endKafkaListenerAuthenticationOAuth()\n-                        .endTls()\n-                        .withNewKafkaListenerExternalNodePort()\n-                            .withNewKafkaListenerAuthenticationOAuth()\n-                                .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n-                                .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n-                                .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n-                                .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n-                                .withUserNameClaim(keycloakInstance.getUserNameClaim())\n-                                .withTlsTrustedCertificates(\n-                                    new CertSecretSourceBuilder()\n-                                        .withSecretName(SECRET_OF_KEYCLOAK)\n-                                        .withCertificate(CERTIFICATE_OF_KEYCLOAK)\n-                                        .build())\n-                                .withDisableTlsHostnameVerification(true)\n-                            .endKafkaListenerAuthenticationOAuth()\n-                        .endKafkaListenerExternalNodePort()\n-                    .endListeners()\n-                .endKafka()\n-            .endSpec()\n-            .done();\n-\n-        KafkaTopicResource.topic(CLUSTER_NAME, TOPIC_NAME).done();\n-\n         createSecretsForDeployments();\n+    }\n+\n+    @AfterEach\n+    void tearDown() {\n \n-        KafkaUserResource.tlsUser(CLUSTER_NAME, OAUTH_CLIENT_NAME).done();\n+        for (Job job : kubeClient().getClient().batch().jobs().inNamespace(NAMESPACE).list().getItems()) {\n+            LOGGER.info(\"Deleting {} job\", job.getMetadata().getName());\n+            kubeClient().getClient().batch().jobs().inNamespace(NAMESPACE).delete(job);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE5OTEyMw=="}, "originalCommit": {"oid": "93bee8ca22346ac0b49ecebcd0cc87767c3afa76"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI5Mjk3Nw==", "bodyText": "Perfect, thanks", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3533#discussion_r481292977", "createdAt": "2020-09-01T16:53:52Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAbstractST.java", "diffHunk": "@@ -72,73 +67,31 @@ void setup() throws Exception {\n \n         KeycloakUtils.deployKeycloak(NAMESPACE);\n \n-        // https\n-        Service keycloakService = KubernetesResource.createKeycloakNodePortService(NAMESPACE);\n-        KubernetesResource.createServiceResource(keycloakService, NAMESPACE);\n-        ServiceUtils.waitForNodePortService(keycloakService.getMetadata().getName());\n-\n-        // http\n-        Service keycloakHttpService = KubernetesResource.createKeycloakNodePortHttpService(NAMESPACE);\n-        KubernetesResource.createServiceResource(keycloakHttpService, NAMESPACE);\n-        ServiceUtils.waitForNodePortService(keycloakHttpService.getMetadata().getName());\n-\n         String passwordEncoded = kubeClient().getSecret(\"credential-example-keycloak\").getData().get(\"ADMIN_PASSWORD\");\n         String password = new String(Base64.getDecoder().decode(passwordEncoded.getBytes()));\n         keycloakInstance = new KeycloakInstance(\"admin\", password, NAMESPACE);\n \n-        clusterHost = kubeClient().getNodeAddress();\n-\n-        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3, 1)\n-            .editSpec()\n-                .editKafka()\n-                    .editListeners()\n-                        .withNewTls()\n-                            .withNewKafkaListenerAuthenticationOAuth()\n-                                .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n-                                .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n-                                .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n-                                .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n-                                .withUserNameClaim(keycloakInstance.getUserNameClaim())\n-                                .withTlsTrustedCertificates(\n-                                    new CertSecretSourceBuilder()\n-                                        .withSecretName(SECRET_OF_KEYCLOAK)\n-                                        .withCertificate(CERTIFICATE_OF_KEYCLOAK)\n-                                        .build())\n-                                .withDisableTlsHostnameVerification(true)\n-                            .endKafkaListenerAuthenticationOAuth()\n-                        .endTls()\n-                        .withNewKafkaListenerExternalNodePort()\n-                            .withNewKafkaListenerAuthenticationOAuth()\n-                                .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n-                                .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n-                                .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n-                                .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n-                                .withUserNameClaim(keycloakInstance.getUserNameClaim())\n-                                .withTlsTrustedCertificates(\n-                                    new CertSecretSourceBuilder()\n-                                        .withSecretName(SECRET_OF_KEYCLOAK)\n-                                        .withCertificate(CERTIFICATE_OF_KEYCLOAK)\n-                                        .build())\n-                                .withDisableTlsHostnameVerification(true)\n-                            .endKafkaListenerAuthenticationOAuth()\n-                        .endKafkaListenerExternalNodePort()\n-                    .endListeners()\n-                .endKafka()\n-            .endSpec()\n-            .done();\n-\n-        KafkaTopicResource.topic(CLUSTER_NAME, TOPIC_NAME).done();\n-\n         createSecretsForDeployments();\n+    }\n+\n+    @AfterEach\n+    void tearDown() {\n \n-        KafkaUserResource.tlsUser(CLUSTER_NAME, OAUTH_CLIENT_NAME).done();\n+        for (Job job : kubeClient().getClient().batch().jobs().inNamespace(NAMESPACE).list().getItems()) {\n+            LOGGER.info(\"Deleting {} job\", job.getMetadata().getName());\n+            kubeClient().getClient().batch().jobs().inNamespace(NAMESPACE).delete(job);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE5OTEyMw=="}, "originalCommit": {"oid": "93bee8ca22346ac0b49ecebcd0cc87767c3afa76"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjYwMDYzOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNToxNjoxMlrOHJ9CsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNjo1Mzo0M1rOHK_yYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE5OTM0NQ==", "bodyText": "Another suggestion -> shouldn't be better to have builder for this? Just asking ... for the future PR?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3533#discussion_r480199345", "createdAt": "2020-08-31T15:16:12Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -222,76 +231,70 @@ void testClusterVerification() {\n     void setUp()  {\n         keycloakInstance.setRealm(\"kafka-authz\", true);\n \n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3, 1)\n+            .editSpec()\n+                .editKafka()\n+                    .editListeners()\n+                        .withNewTls()\n+                            .withNewKafkaListenerAuthenticationOAuth()\n+                                .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n+                                .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n+                                .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n+                                .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n+                                .withUserNameClaim(keycloakInstance.getUserNameClaim())\n+                                .withTlsTrustedCertificates(\n+                                    new CertSecretSourceBuilder()\n+                                        .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME)\n+                                        .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT)\n+                                        .build())\n+                                .withDisableTlsHostnameVerification(true)\n+                            .endKafkaListenerAuthenticationOAuth()\n+                        .endTls()\n+                    .endListeners()\n+                    .withNewKafkaAuthorizationKeycloak()\n+                        .withClientId(KAFKA_CLIENT_ID)\n+                        .withDisableTlsHostnameVerification(true)\n+                        .withDelegateToKafkaAcls(false)\n+                        // ca.crt a tls.crt\n+                        .withTlsTrustedCertificates(\n+                            new CertSecretSourceBuilder()\n+                                .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME)\n+                                .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT)\n+                                .build()\n+                        )\n+                        .withTokenEndpointUri(keycloakInstance.getOauthTokenEndpointUri())\n+                    .endKafkaAuthorizationKeycloak()\n+                .endKafka()\n+            .endSpec()\n+            .done();\n+\n         LOGGER.info(\"Setting producer and consumer properties\");\n \n         KafkaUserResource.tlsUser(CLUSTER_NAME, TEAM_A_CLIENT).done();\n         KafkaUserResource.tlsUser(CLUSTER_NAME, TEAM_B_CLIENT).done();\n \n-        KafkaUserUtils.waitForKafkaUserCreation(TEAM_A_CLIENT);\n-        KafkaUserUtils.waitForKafkaUserCreation(TEAM_B_CLIENT);\n-\n-        teamAOauthKafkaClient = new OauthExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_A)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withKafkaUsername(TEAM_A_CLIENT)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withSecurityProtocol(SecurityProtocol.SASL_SSL)\n-            .withConsumerGroupName(\"a-consumer_group\")\n-            .withOauthClientId(TEAM_A_CLIENT)\n-            .withClientSecretName(TEAM_A_CLIENT_SECRET)\n-            .withOauthTokenEndpointUri(keycloakInstance.getOauthTokenEndpointUri())\n-            .build();\n-\n-        teamBOauthKafkaClient = new OauthExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withKafkaUsername(TEAM_A_CLIENT)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withSecurityProtocol(SecurityProtocol.SASL_SSL)\n-            .withConsumerGroupName(\"x-\" + ClientUtils.generateRandomConsumerGroup())\n-            .withOauthClientId(TEAM_B_CLIENT)\n-            .withClientSecretName(TEAM_B_CLIENT_SECRET)\n-            .withOauthTokenEndpointUri(keycloakInstance.getOauthTokenEndpointUri())\n-            .build();\n-\n-        Map<String, String> kafkaPods = StatefulSetUtils.ssSnapshot(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME));\n-\n-        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n-            kafka.getSpec().getKafka().getListeners().setExternal(\n-                new KafkaListenerExternalNodePortBuilder()\n-                    .withNewKafkaListenerAuthenticationOAuth()\n-                        .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n-                        .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n-                        .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n-                        .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n-                        .withUserNameClaim(keycloakInstance.getUserNameClaim())\n-                        .withTlsTrustedCertificates(\n-                            new CertSecretSourceBuilder()\n-                                .withSecretName(SECRET_OF_KEYCLOAK)\n-                                .withCertificate(CERTIFICATE_OF_KEYCLOAK)\n-                                .build())\n-                        .withDisableTlsHostnameVerification(true)\n-                    .endKafkaListenerAuthenticationOAuth()\n-                    .build());\n-\n-            kafka.getSpec().getKafka().setAuthorization(\n-                new KafkaAuthorizationKeycloakBuilder()\n-                    .withClientId(KAFKA_CLIENT_ID)\n-                    .withDisableTlsHostnameVerification(true)\n-                    .withDelegateToKafkaAcls(false)\n-                    // ca.crt a tls.crt\n-                    .withTlsTrustedCertificates(\n-                        new CertSecretSourceBuilder()\n-                            .withSecretName(SECRET_OF_KEYCLOAK)\n-                            .withCertificate(CERTIFICATE_OF_KEYCLOAK)\n-                            .build()\n-                    )\n-                    .withTokenEndpointUri(keycloakInstance.getOauthTokenEndpointUri())\n-                    .build());\n-        });\n-\n-        StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), 3, kafkaPods);\n+        teamAOauthClientJob = new KafkaOauthClientsResource(\n+                TEAM_A_PRODUCER_NAME,\n+                TEAM_A_CONSUMER_NAME,\n+                KafkaResources.tlsBootstrapAddress(CLUSTER_NAME),\n+                TOPIC_A,\n+                MESSAGE_COUNT,\n+                \"\",\n+                \"a-consumer_group\",\n+                TEAM_A_CLIENT,\n+                TEAM_A_CLIENT_SECRET,\n+                keycloakInstance.getOauthTokenEndpointUri());\n+\n+        teamBOauthClientJob = new KafkaOauthClientsResource(\n+                TEAM_B_PRODUCER_NAME,\n+                TEAM_B_CONSUMER_NAME,\n+                KafkaResources.tlsBootstrapAddress(CLUSTER_NAME),\n+                TOPIC_A,\n+                MESSAGE_COUNT,\n+                \"\",\n+                \"x-\" + ClientUtils.generateRandomConsumerGroup(),\n+                TEAM_B_CLIENT,\n+                TEAM_B_CLIENT_SECRET,\n+                keycloakInstance.getOauthTokenEndpointUri());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93bee8ca22346ac0b49ecebcd0cc87767c3afa76"}, "originalPosition": 381}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDIwNDA4MQ==", "bodyText": "Open issue for that. We discuss it and we decide it needs separete PR.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3533#discussion_r480204081", "createdAt": "2020-08-31T15:23:59Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -222,76 +231,70 @@ void testClusterVerification() {\n     void setUp()  {\n         keycloakInstance.setRealm(\"kafka-authz\", true);\n \n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3, 1)\n+            .editSpec()\n+                .editKafka()\n+                    .editListeners()\n+                        .withNewTls()\n+                            .withNewKafkaListenerAuthenticationOAuth()\n+                                .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n+                                .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n+                                .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n+                                .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n+                                .withUserNameClaim(keycloakInstance.getUserNameClaim())\n+                                .withTlsTrustedCertificates(\n+                                    new CertSecretSourceBuilder()\n+                                        .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME)\n+                                        .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT)\n+                                        .build())\n+                                .withDisableTlsHostnameVerification(true)\n+                            .endKafkaListenerAuthenticationOAuth()\n+                        .endTls()\n+                    .endListeners()\n+                    .withNewKafkaAuthorizationKeycloak()\n+                        .withClientId(KAFKA_CLIENT_ID)\n+                        .withDisableTlsHostnameVerification(true)\n+                        .withDelegateToKafkaAcls(false)\n+                        // ca.crt a tls.crt\n+                        .withTlsTrustedCertificates(\n+                            new CertSecretSourceBuilder()\n+                                .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME)\n+                                .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT)\n+                                .build()\n+                        )\n+                        .withTokenEndpointUri(keycloakInstance.getOauthTokenEndpointUri())\n+                    .endKafkaAuthorizationKeycloak()\n+                .endKafka()\n+            .endSpec()\n+            .done();\n+\n         LOGGER.info(\"Setting producer and consumer properties\");\n \n         KafkaUserResource.tlsUser(CLUSTER_NAME, TEAM_A_CLIENT).done();\n         KafkaUserResource.tlsUser(CLUSTER_NAME, TEAM_B_CLIENT).done();\n \n-        KafkaUserUtils.waitForKafkaUserCreation(TEAM_A_CLIENT);\n-        KafkaUserUtils.waitForKafkaUserCreation(TEAM_B_CLIENT);\n-\n-        teamAOauthKafkaClient = new OauthExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_A)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withKafkaUsername(TEAM_A_CLIENT)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withSecurityProtocol(SecurityProtocol.SASL_SSL)\n-            .withConsumerGroupName(\"a-consumer_group\")\n-            .withOauthClientId(TEAM_A_CLIENT)\n-            .withClientSecretName(TEAM_A_CLIENT_SECRET)\n-            .withOauthTokenEndpointUri(keycloakInstance.getOauthTokenEndpointUri())\n-            .build();\n-\n-        teamBOauthKafkaClient = new OauthExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withKafkaUsername(TEAM_A_CLIENT)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withSecurityProtocol(SecurityProtocol.SASL_SSL)\n-            .withConsumerGroupName(\"x-\" + ClientUtils.generateRandomConsumerGroup())\n-            .withOauthClientId(TEAM_B_CLIENT)\n-            .withClientSecretName(TEAM_B_CLIENT_SECRET)\n-            .withOauthTokenEndpointUri(keycloakInstance.getOauthTokenEndpointUri())\n-            .build();\n-\n-        Map<String, String> kafkaPods = StatefulSetUtils.ssSnapshot(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME));\n-\n-        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n-            kafka.getSpec().getKafka().getListeners().setExternal(\n-                new KafkaListenerExternalNodePortBuilder()\n-                    .withNewKafkaListenerAuthenticationOAuth()\n-                        .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n-                        .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n-                        .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n-                        .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n-                        .withUserNameClaim(keycloakInstance.getUserNameClaim())\n-                        .withTlsTrustedCertificates(\n-                            new CertSecretSourceBuilder()\n-                                .withSecretName(SECRET_OF_KEYCLOAK)\n-                                .withCertificate(CERTIFICATE_OF_KEYCLOAK)\n-                                .build())\n-                        .withDisableTlsHostnameVerification(true)\n-                    .endKafkaListenerAuthenticationOAuth()\n-                    .build());\n-\n-            kafka.getSpec().getKafka().setAuthorization(\n-                new KafkaAuthorizationKeycloakBuilder()\n-                    .withClientId(KAFKA_CLIENT_ID)\n-                    .withDisableTlsHostnameVerification(true)\n-                    .withDelegateToKafkaAcls(false)\n-                    // ca.crt a tls.crt\n-                    .withTlsTrustedCertificates(\n-                        new CertSecretSourceBuilder()\n-                            .withSecretName(SECRET_OF_KEYCLOAK)\n-                            .withCertificate(CERTIFICATE_OF_KEYCLOAK)\n-                            .build()\n-                    )\n-                    .withTokenEndpointUri(keycloakInstance.getOauthTokenEndpointUri())\n-                    .build());\n-        });\n-\n-        StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), 3, kafkaPods);\n+        teamAOauthClientJob = new KafkaOauthClientsResource(\n+                TEAM_A_PRODUCER_NAME,\n+                TEAM_A_CONSUMER_NAME,\n+                KafkaResources.tlsBootstrapAddress(CLUSTER_NAME),\n+                TOPIC_A,\n+                MESSAGE_COUNT,\n+                \"\",\n+                \"a-consumer_group\",\n+                TEAM_A_CLIENT,\n+                TEAM_A_CLIENT_SECRET,\n+                keycloakInstance.getOauthTokenEndpointUri());\n+\n+        teamBOauthClientJob = new KafkaOauthClientsResource(\n+                TEAM_B_PRODUCER_NAME,\n+                TEAM_B_CONSUMER_NAME,\n+                KafkaResources.tlsBootstrapAddress(CLUSTER_NAME),\n+                TOPIC_A,\n+                MESSAGE_COUNT,\n+                \"\",\n+                \"x-\" + ClientUtils.generateRandomConsumerGroup(),\n+                TEAM_B_CLIENT,\n+                TEAM_B_CLIENT_SECRET,\n+                keycloakInstance.getOauthTokenEndpointUri());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE5OTM0NQ=="}, "originalCommit": {"oid": "93bee8ca22346ac0b49ecebcd0cc87767c3afa76"}, "originalPosition": 381}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI5Mjg5OQ==", "bodyText": "Thanks :) gonna open it.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3533#discussion_r481292899", "createdAt": "2020-09-01T16:53:43Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthAuthorizationST.java", "diffHunk": "@@ -222,76 +231,70 @@ void testClusterVerification() {\n     void setUp()  {\n         keycloakInstance.setRealm(\"kafka-authz\", true);\n \n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3, 1)\n+            .editSpec()\n+                .editKafka()\n+                    .editListeners()\n+                        .withNewTls()\n+                            .withNewKafkaListenerAuthenticationOAuth()\n+                                .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n+                                .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n+                                .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n+                                .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n+                                .withUserNameClaim(keycloakInstance.getUserNameClaim())\n+                                .withTlsTrustedCertificates(\n+                                    new CertSecretSourceBuilder()\n+                                        .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME)\n+                                        .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT)\n+                                        .build())\n+                                .withDisableTlsHostnameVerification(true)\n+                            .endKafkaListenerAuthenticationOAuth()\n+                        .endTls()\n+                    .endListeners()\n+                    .withNewKafkaAuthorizationKeycloak()\n+                        .withClientId(KAFKA_CLIENT_ID)\n+                        .withDisableTlsHostnameVerification(true)\n+                        .withDelegateToKafkaAcls(false)\n+                        // ca.crt a tls.crt\n+                        .withTlsTrustedCertificates(\n+                            new CertSecretSourceBuilder()\n+                                .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME)\n+                                .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT)\n+                                .build()\n+                        )\n+                        .withTokenEndpointUri(keycloakInstance.getOauthTokenEndpointUri())\n+                    .endKafkaAuthorizationKeycloak()\n+                .endKafka()\n+            .endSpec()\n+            .done();\n+\n         LOGGER.info(\"Setting producer and consumer properties\");\n \n         KafkaUserResource.tlsUser(CLUSTER_NAME, TEAM_A_CLIENT).done();\n         KafkaUserResource.tlsUser(CLUSTER_NAME, TEAM_B_CLIENT).done();\n \n-        KafkaUserUtils.waitForKafkaUserCreation(TEAM_A_CLIENT);\n-        KafkaUserUtils.waitForKafkaUserCreation(TEAM_B_CLIENT);\n-\n-        teamAOauthKafkaClient = new OauthExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_A)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withKafkaUsername(TEAM_A_CLIENT)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withSecurityProtocol(SecurityProtocol.SASL_SSL)\n-            .withConsumerGroupName(\"a-consumer_group\")\n-            .withOauthClientId(TEAM_A_CLIENT)\n-            .withClientSecretName(TEAM_A_CLIENT_SECRET)\n-            .withOauthTokenEndpointUri(keycloakInstance.getOauthTokenEndpointUri())\n-            .build();\n-\n-        teamBOauthKafkaClient = new OauthExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withKafkaUsername(TEAM_A_CLIENT)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withSecurityProtocol(SecurityProtocol.SASL_SSL)\n-            .withConsumerGroupName(\"x-\" + ClientUtils.generateRandomConsumerGroup())\n-            .withOauthClientId(TEAM_B_CLIENT)\n-            .withClientSecretName(TEAM_B_CLIENT_SECRET)\n-            .withOauthTokenEndpointUri(keycloakInstance.getOauthTokenEndpointUri())\n-            .build();\n-\n-        Map<String, String> kafkaPods = StatefulSetUtils.ssSnapshot(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME));\n-\n-        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n-            kafka.getSpec().getKafka().getListeners().setExternal(\n-                new KafkaListenerExternalNodePortBuilder()\n-                    .withNewKafkaListenerAuthenticationOAuth()\n-                        .withValidIssuerUri(keycloakInstance.getValidIssuerUri())\n-                        .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri())\n-                        .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds())\n-                        .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds())\n-                        .withUserNameClaim(keycloakInstance.getUserNameClaim())\n-                        .withTlsTrustedCertificates(\n-                            new CertSecretSourceBuilder()\n-                                .withSecretName(SECRET_OF_KEYCLOAK)\n-                                .withCertificate(CERTIFICATE_OF_KEYCLOAK)\n-                                .build())\n-                        .withDisableTlsHostnameVerification(true)\n-                    .endKafkaListenerAuthenticationOAuth()\n-                    .build());\n-\n-            kafka.getSpec().getKafka().setAuthorization(\n-                new KafkaAuthorizationKeycloakBuilder()\n-                    .withClientId(KAFKA_CLIENT_ID)\n-                    .withDisableTlsHostnameVerification(true)\n-                    .withDelegateToKafkaAcls(false)\n-                    // ca.crt a tls.crt\n-                    .withTlsTrustedCertificates(\n-                        new CertSecretSourceBuilder()\n-                            .withSecretName(SECRET_OF_KEYCLOAK)\n-                            .withCertificate(CERTIFICATE_OF_KEYCLOAK)\n-                            .build()\n-                    )\n-                    .withTokenEndpointUri(keycloakInstance.getOauthTokenEndpointUri())\n-                    .build());\n-        });\n-\n-        StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), 3, kafkaPods);\n+        teamAOauthClientJob = new KafkaOauthClientsResource(\n+                TEAM_A_PRODUCER_NAME,\n+                TEAM_A_CONSUMER_NAME,\n+                KafkaResources.tlsBootstrapAddress(CLUSTER_NAME),\n+                TOPIC_A,\n+                MESSAGE_COUNT,\n+                \"\",\n+                \"a-consumer_group\",\n+                TEAM_A_CLIENT,\n+                TEAM_A_CLIENT_SECRET,\n+                keycloakInstance.getOauthTokenEndpointUri());\n+\n+        teamBOauthClientJob = new KafkaOauthClientsResource(\n+                TEAM_B_PRODUCER_NAME,\n+                TEAM_B_CONSUMER_NAME,\n+                KafkaResources.tlsBootstrapAddress(CLUSTER_NAME),\n+                TOPIC_A,\n+                MESSAGE_COUNT,\n+                \"\",\n+                \"x-\" + ClientUtils.generateRandomConsumerGroup(),\n+                TEAM_B_CLIENT,\n+                TEAM_B_CLIENT_SECRET,\n+                keycloakInstance.getOauthTokenEndpointUri());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE5OTM0NQ=="}, "originalCommit": {"oid": "93bee8ca22346ac0b49ecebcd0cc87767c3afa76"}, "originalPosition": 381}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjYwMTUwOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthPlainST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNToxNjoyNVrOHJ9DPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNToxNjoyNVrOHJ9DPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE5OTQ4Nw==", "bodyText": "Same as above: Why not to use the JobUtils.deleteJob()?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3533#discussion_r480199487", "createdAt": "2020-08-31T15:16:25Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthPlainST.java", "diffHunk": "@@ -187,19 +184,35 @@ void testProducerConsumerMirrorMaker() {\n         TestUtils.waitFor(\"Waiting for Mirror Maker will copy messages from \" + CLUSTER_NAME + \" to \" + targetKafkaCluster,\n             Constants.GLOBAL_CLIENTS_POLL, Constants.TIMEOUT_FOR_MIRROR_MAKER_COPY_MESSAGES_BETWEEN_BROKERS,\n             () -> {\n-                oauthExternalKafkaClient.setConsumerGroup(ClientUtils.generateRandomConsumerGroup());\n-                return oauthExternalKafkaClient.receiveMessagesPlain() == MESSAGE_COUNT;\n+                LOGGER.info(\"Deleting the Job\");\n+                kubeClient().getClient().batch().jobs().inNamespace(NAMESPACE).withName(OAUTH_CONSUMER_NAME).delete();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93bee8ca22346ac0b49ecebcd0cc87767c3afa76"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjYwMjE3OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthPlainST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNToxNjozNVrOHJ9DpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNToxNjozNVrOHJ9DpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE5OTU4OA==", "bodyText": "Same as above", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3533#discussion_r480199588", "createdAt": "2020-08-31T15:16:35Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthPlainST.java", "diffHunk": "@@ -273,19 +286,35 @@ void testProducerConsumerMirrorMaker2() {\n         TestUtils.waitFor(\"Waiting for Mirror Maker 2 will copy messages from \" + kafkaSourceClusterName + \" to \" + kafkaTargetClusterName,\n             Duration.ofSeconds(30).toMillis(), Constants.TIMEOUT_FOR_MIRROR_MAKER_COPY_MESSAGES_BETWEEN_BROKERS,\n             () -> {\n-                oauthExternalKafkaClient.setConsumerGroup(ClientUtils.generateRandomConsumerGroup());\n-                return oauthExternalKafkaClient.receiveMessagesPlain() == MESSAGE_COUNT;\n+                LOGGER.info(\"Deleting the Job {}\", OAUTH_CONSUMER_NAME);\n+                kubeClient().getClient().batch().jobs().inNamespace(NAMESPACE).withName(OAUTH_CONSUMER_NAME).delete();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93bee8ca22346ac0b49ecebcd0cc87767c3afa76"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMzM2OTk3OnYy", "diffSide": "RIGHT", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/ClientUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwOTo0NjozMVrOHLneQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwOTo0NjozMVrOHLneQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk0MzEwNw==", "bodyText": "Should this be a waitForJobFailure and sit in JobUtils? apart from the log message, there is nothing client specific.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3533#discussion_r481943107", "createdAt": "2020-09-02T09:46:31Z", "author": {"login": "scholzj"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/ClientUtils.java", "diffHunk": "@@ -60,6 +60,12 @@ public static void waitForClientSuccess(String jobName, String namespace, int me\n             () -> kubeClient().getClient().batch().jobs().inNamespace(namespace).withName(jobName).get().getStatus().getSucceeded().equals(1));\n     }\n \n+    public static void waitForClientFailure(String jobName, String namespace, long timeout) {\n+        LOGGER.info(\"Waiting for producer/consumer:{} will be in error state\", jobName);\n+        TestUtils.waitFor(\"job finished\", Constants.GLOBAL_POLL_INTERVAL, timeout,\n+            () -> kubeClient().getClient().batch().jobs().inNamespace(namespace).withName(jobName).get().getStatus().getSucceeded().equals(1));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28e4b4fdd92fa08f3eeaa91ce46ec8af06fee5af"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMzM3ODA3OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeKafkaExternalListenersST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwOTo0ODo0NlrOHLnjIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwOTo0ODo0NlrOHLnjIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk0NDM1Mw==", "bodyText": "This seems to be the same for all the Bridge tests. Can this be moved in some way to the abstract class?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3533#discussion_r481944353", "createdAt": "2020-09-02T09:48:46Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/bridge/HttpBridgeKafkaExternalListenersST.java", "diffHunk": "@@ -164,5 +166,8 @@ private void testWeirdUsername(String weirdUserName, KafkaListenerAuthentication\n     @BeforeAll\n     void createClassResources() throws Exception {\n         deployClusterOperator(NAMESPACE);\n+\n+        kafkaBridgeClientJob = new KafkaBridgeClientsResource(producerName, consumerName, KafkaBridgeResources.serviceName(CLUSTER_NAME),\n+            TOPIC_NAME, MESSAGE_COUNT, \"\", ClientUtils.generateRandomConsumerGroup(), bridgePort, 1000, 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28e4b4fdd92fa08f3eeaa91ce46ec8af06fee5af"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMzM5NDgwOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/ClusterOperationST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwOTo1MzoyMlrOHLntYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwOTo1MzoyMlrOHLntYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk0Njk3Nw==", "bodyText": "What is the value of having this at the class level? Looks like you use it only within a single loop.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3533#discussion_r481946977", "createdAt": "2020-09-02T09:53:22Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/ClusterOperationST.java", "diffHunk": "@@ -32,16 +32,19 @@\n public class ClusterOperationST extends AbstractST {\n \n     private static final Logger LOGGER = LogManager.getLogger(ClusterOperationST.class);\n+    private KafkaBasicClientResource kafkaBasicClientResource;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28e4b4fdd92fa08f3eeaa91ce46ec8af06fee5af"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1340, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}