{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA5ODIyNjgz", "number": 3873, "title": "FIX(Tests) testRackAware (no external clients) & new testRackAwareConnect", "bodyText": "\u2026oad balancer\nSigned-off-by: Michal T\u00f3th mtoth@redhat.com\nType of change\nSelect the type of your PR\n\nBugfix\nEnhancement / new feature\nRefactoring\nDocumentation\n\nDescription\nCreate new tests for rack awareness of kafka clients.\nChecklist\n\n Write tests\n Make sure all tests pass\n Try your changes from Pod inside your Kubernetes and OpenShift cluster, not just locally\n Reference relevant issue(s) and close them after merging", "createdAt": "2020-10-26T07:16:14Z", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873", "merged": true, "mergeCommit": {"oid": "24ab15bac9258b148d42145791094ad1d67804a8"}, "closed": true, "closedAt": "2020-11-26T12:21:21Z", "author": {"login": "michalxo"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdWQnlMgFqTUxNjU3ODMyOA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdgQ6ihABqjQwNDIwMDk3OTY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2NTc4MzI4", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#pullrequestreview-516578328", "createdAt": "2020-10-26T09:05:17Z", "commit": {"oid": "ef35a4e7393c0d91afbdeb2f94c3c95d3435e6c3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwOTowNToxN1rOHoGPpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwOTowNToxN1rOHoGPpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwNzM5Ng==", "bodyText": "Why is this in any way relevant only to this ST? Also, sleeping for the whole reconciliation interval could be waste of time. You should check periodically with some small backoff for example to make sure you don't waste time on it.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r511807396", "createdAt": "2020-10-26T09:05:17Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,6 +100,15 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n+        LOGGER.info(\"Waiting for reconciliation to happen. \" +\n+                \"Giving some time to DNS/load balancer to propagate kafka address.\" +\n+                \"Sleeping for {}ms\", Constants.RECONCILIATION_INTERVAL);\n+        try {\n+            Thread.sleep(Constants.RECONCILIATION_INTERVAL);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef35a4e7393c0d91afbdeb2f94c3c95d3435e6c3"}, "originalPosition": 11}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c165e0578691fbf1cf6c48566c39c7c42a970ada", "author": {"user": {"login": "michalxo", "name": "Michal T"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c165e0578691fbf1cf6c48566c39c7c42a970ada", "committedDate": "2020-10-26T13:59:45Z", "message": "FIX(Tests) TestRackAware do not use load balance w/ ext clients\n\nSigned-off-by: Michal T\u00f3th <mtoth@redhat.com>"}, "afterCommit": {"oid": "e6907c23439339e2b9636c0eb7d73da2f3bafc79", "author": {"user": {"login": "michalxo", "name": "Michal T"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e6907c23439339e2b9636c0eb7d73da2f3bafc79", "committedDate": "2020-10-26T15:05:44Z", "message": "FIX(Tests) TestRackAware do not use load balance w/ ext clients\n\nSigned-off-by: Michal T\u00f3th <mtoth@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTIyNzcy", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#pullrequestreview-516922772", "createdAt": "2020-10-26T15:52:55Z", "commit": {"oid": "e6907c23439339e2b9636c0eb7d73da2f3bafc79"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e6907c23439339e2b9636c0eb7d73da2f3bafc79", "author": {"user": {"login": "michalxo", "name": "Michal T"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e6907c23439339e2b9636c0eb7d73da2f3bafc79", "committedDate": "2020-10-26T15:05:44Z", "message": "FIX(Tests) TestRackAware do not use load balance w/ ext clients\n\nSigned-off-by: Michal T\u00f3th <mtoth@redhat.com>"}, "afterCommit": {"oid": "14a3b390216fae011b06b50920aa3a692238c448", "author": {"user": {"login": "michalxo", "name": "Michal T"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/14a3b390216fae011b06b50920aa3a692238c448", "committedDate": "2020-11-04T10:45:59Z", "message": "NEW(Tests) testRackAwareConnect\n\nSigned-off-by: Michal T\u00f3th <mtoth@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzMwMDE1", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#pullrequestreview-523330015", "createdAt": "2020-11-04T12:51:13Z", "commit": {"oid": "14a3b390216fae011b06b50920aa3a692238c448"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMjo1MToxM1rOHtWulA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMjo1MToxM1rOHtWulA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMyMDM0MA==", "bodyText": "I guess ideally you should also deploy some connector and send some messages to verify it is all working and is connected.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r517320340", "createdAt": "2020-11-04T12:51:13Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +103,84 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    void testRackAwareConnect() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a3b390216fae011b06b50920aa3a692238c448"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNDQ1NDE2", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#pullrequestreview-523445416", "createdAt": "2020-11-04T15:01:27Z", "commit": {"oid": "14a3b390216fae011b06b50920aa3a692238c448"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTowMToyN1rOHtcEJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTowOTowN1rOHtcZ2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQwNzc4Mg==", "bodyText": "You should add REGRESSION tag here", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r517407782", "createdAt": "2020-11-04T15:01:27Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -56,8 +69,6 @@\n     public static final String NAMESPACE = \"specific-cluster-test\";\n \n     @Test\n-    @Tag(LOADBALANCER_SUPPORTED)\n-    @Tag(EXTERNAL_CLIENTS_USED)\n     void testRackAware() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a3b390216fae011b06b50920aa3a692238c448"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQwNzg5NA==", "bodyText": "Same as above", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r517407894", "createdAt": "2020-11-04T15:01:36Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +103,84 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    void testRackAwareConnect() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a3b390216fae011b06b50920aa3a692238c448"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQwODE4OQ==", "bodyText": "Indent", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r517408189", "createdAt": "2020-11-04T15:02:00Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +103,84 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    void testRackAwareConnect() {\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                .editKafka()\n+                .withNewRack()\n+                .withTopologyKey(rackKey)\n+                .endRack()\n+                .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                .endKafka()\n+                .endSpec().done();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a3b390216fae011b06b50920aa3a692238c448"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQwODI3NQ==", "bodyText": "Indent", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r517408275", "createdAt": "2020-11-04T15:02:09Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +103,84 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    void testRackAwareConnect() {\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                .editKafka()\n+                .withNewRack()\n+                .withTopologyKey(rackKey)\n+                .endRack()\n+                .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                .withNewRack()\n+                .withTopologyKey(wrongRackKey)\n+                .endRack()\n+                .endSpec()\n+                .build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a3b390216fae011b06b50920aa3a692238c448"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQwODU0Mg==", "bodyText": "indent", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r517408542", "createdAt": "2020-11-04T15:02:24Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +103,84 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    void testRackAwareConnect() {\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                .editKafka()\n+                .withNewRack()\n+                .withTopologyKey(rackKey)\n+                .endRack()\n+                .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                .withNewRack()\n+                .withTopologyKey(wrongRackKey)\n+                .endRack()\n+                .endSpec()\n+                .build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+        assertThat(kcWrongStatus.getConditions().get(0).getMessage(), containsString(\"didn't match node selector\"));\n+        KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).withPropagationPolicy(DeletionPropagation.FOREGROUND).delete();\n+        PodUtils.deletePodWithWait(connectWrongPodName);\n+\n+        LOGGER.info(\"Deploy KafkaConnect with correct rack-aware topology key: {}\", rackKey);\n+        KafkaConnectResource.kafkaConnect(CLUSTER_NAME, 2)\n+                .editSpec()\n+                .withNewRack()\n+                .withTopologyKey(rackKey)\n+                .endRack()\n+                .endSpec()\n+                .done();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a3b390216fae011b06b50920aa3a692238c448"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxMzMzNw==", "bodyText": "Wouldn't be better to check KC status instead of pod status which is set by kubernetes? If there is something useful of course.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r517413337", "createdAt": "2020-11-04T15:09:07Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +103,84 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    void testRackAwareConnect() {\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                .editKafka()\n+                .withNewRack()\n+                .withTopologyKey(rackKey)\n+                .endRack()\n+                .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                .withNewRack()\n+                .withTopologyKey(wrongRackKey)\n+                .endRack()\n+                .endSpec()\n+                .build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a3b390216fae011b06b50920aa3a692238c448"}, "originalPosition": 136}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5a08ef15bb7ba0f05e0ff5691c90287b78d593a0", "author": {"user": {"login": "michalxo", "name": "Michal T"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5a08ef15bb7ba0f05e0ff5691c90287b78d593a0", "committedDate": "2020-11-04T15:16:09Z", "message": "fixup! FIX(Tests) TestRackAware do not use load balance w/ ext clients"}, "afterCommit": {"oid": "9f647c40ef0258e15da6770dcf79def95bfd7ea0", "author": {"user": {"login": "michalxo", "name": "Michal T"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/9f647c40ef0258e15da6770dcf79def95bfd7ea0", "committedDate": "2020-11-05T08:08:16Z", "message": "fixup! FIX(Tests) TestRackAware do not use load balance w/ ext clients\n\nSigned-off-by: Michal T\u00f3th <mtoth@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0MzM4MTM0", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#pullrequestreview-524338134", "createdAt": "2020-11-05T14:50:39Z", "commit": {"oid": "872a420efbc02018f9b12b676dab17786d08ca09"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDo1MDozOVrOHuG4Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDo1MzowNFrOHuG_lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODEwOTIxMQ==", "bodyText": "Didn't you had some waitFor methods which can do this in a more efficient way?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r518109211", "createdAt": "2020-11-05T14:50:39Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +109,120 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnect() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        Thread.sleep(CO_OPERATION_TIMEOUT_SHORT + 10000);\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "872a420efbc02018f9b12b676dab17786d08ca09"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODExMDEzMg==", "bodyText": "I wonder if we do really want to have the error text hardcoded. It is often different with Kubernetes versions and makes the test lass portable and future-proof.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r518110132", "createdAt": "2020-11-05T14:51:47Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +109,120 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnect() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        Thread.sleep(CO_OPERATION_TIMEOUT_SHORT + 10000);\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+        assertThat(kcWrongStatus.getConditions().get(0).getMessage(), containsString(\"didn't match node selector\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "872a420efbc02018f9b12b676dab17786d08ca09"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODExMTEyNg==", "bodyText": "Maybe if you already start with a wrong rack, you could also just change the Connect CR and see that it recovers instead of deleting it?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r518111126", "createdAt": "2020-11-05T14:53:04Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +109,120 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnect() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        Thread.sleep(CO_OPERATION_TIMEOUT_SHORT + 10000);\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+        assertThat(kcWrongStatus.getConditions().get(0).getMessage(), containsString(\"didn't match node selector\"));\n+        KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).withPropagationPolicy(DeletionPropagation.FOREGROUND).delete();\n+        PodUtils.deletePodWithWait(connectWrongPodName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "872a420efbc02018f9b12b676dab17786d08ca09"}, "originalPosition": 157}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a34467fbdc216c9256041ddf74b46f844d33915f", "author": {"user": {"login": "michalxo", "name": "Michal T"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/a34467fbdc216c9256041ddf74b46f844d33915f", "committedDate": "2020-11-19T14:34:41Z", "message": "FIX(Tests) testRackAware added wait for DNS propagation of kafka to load balancer\n\nSigned-off-by: Michal T\u00f3th <mtoth@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0338dc6395c2383c906130b1ffba861c852633af", "author": {"user": {"login": "michalxo", "name": "Michal T"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/0338dc6395c2383c906130b1ffba861c852633af", "committedDate": "2020-11-19T14:34:42Z", "message": "FIX(Tests) TestRackAware do not use load balance w/ ext clients\n\nSigned-off-by: Michal T\u00f3th <mtoth@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "872a420efbc02018f9b12b676dab17786d08ca09", "author": {"user": {"login": "michalxo", "name": "Michal T"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/872a420efbc02018f9b12b676dab17786d08ca09", "committedDate": "2020-11-05T13:26:30Z", "message": "fixup! FIX(Tests) TestRackAware do not use load balance w/ ext clients\n\nSigned-off-by: Michal T\u00f3th <mtoth@redhat.com>"}, "afterCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f", "author": {"user": {"login": "michalxo", "name": "Michal T"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/aac1bfe88b502c06821a1c3a93cf1b7ff448395f", "committedDate": "2020-11-19T14:34:42Z", "message": "fixup! NEW(Tests) testRackAwareConnect\n\nSigned-off-by: Michal T\u00f3th <mtoth@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0NjI4NTgy", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#pullrequestreview-534628582", "createdAt": "2020-11-19T16:31:25Z", "commit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozMToyNlrOH2nGhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozOTo0NFrOH2ne8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyNTc5OQ==", "bodyText": "It's not a test", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527025799", "createdAt": "2020-11-19T16:31:26Z", "author": {"login": "Frawless"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/kafkaUtils/KafkaConnectUtils.java", "diffHunk": "@@ -78,4 +80,33 @@ public static void waitForKafkaConnectConfigChange(String propertyKey, String pr\n             });\n         LOGGER.info(\"Kafka Connect property {} -> {} change\", propertyKey, propertyValue);\n     }\n+\n+    /**\n+     * Test sending and receiving messages through file sink connector (using Kafka Connect).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyNTk1OA==", "bodyText": "Same as above", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527025958", "createdAt": "2020-11-19T16:31:38Z", "author": {"login": "Frawless"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/kafkaUtils/KafkaConnectUtils.java", "diffHunk": "@@ -78,4 +80,33 @@ public static void waitForKafkaConnectConfigChange(String propertyKey, String pr\n             });\n         LOGGER.info(\"Kafka Connect property {} -> {} change\", propertyKey, propertyValue);\n     }\n+\n+    /**\n+     * Test sending and receiving messages through file sink connector (using Kafka Connect).\n+     * @param connectPodName kafkaConnect pod name\n+     * @param topicName topic to be used\n+     * @param kafkaClientsPodName kafkaClients pod name\n+     * @param namespace namespace name\n+     * @param clusterName cluster name\n+     */\n+    public static void sendReceiveMessagesThroughConnect(String connectPodName, String topicName, String kafkaClientsPodName, String namespace, String clusterName) {\n+        LOGGER.info(\"Test sending and receiving messages through KafkaConnect\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyNzQ4Ng==", "bodyText": "Move it to some utils class? You basically wait until KC is not ready, I don't see any specific message in status. Also, the test will wait 5 minutes until deployment will timeout. WOuldn't be enough just to wait for the pending, wait for the next reconciliation, check if the pod is still pending, and then proceed?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527027486", "createdAt": "2020-11-19T16:33:43Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,151 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnectWrongDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .addToConfig(\"key.converter.schemas.enable\", false)\n+                .addToConfig(\"value.converter.schemas.enable\", false)\n+                .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        TestUtils.waitFor(\"Wait for KafkaConnect 'Unschedulable' condition due to wrong rackKey used.\",\n+                Constants.GLOBAL_POLL_INTERVAL, CO_OPERATION_TIMEOUT_SHORT * 2, () -> {\n+                List<Condition> conditions = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getStatus().getConditions();\n+                for (Condition condition : conditions) {\n+                    if (condition.getReason().matches(\"TimeoutException\") && condition.getType().matches(\"NotReady\")) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyNzgwNQ==", "bodyText": "Why do you assert something, which is verified a few lines above?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527027805", "createdAt": "2020-11-19T16:34:12Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,151 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnectWrongDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .addToConfig(\"key.converter.schemas.enable\", false)\n+                .addToConfig(\"value.converter.schemas.enable\", false)\n+                .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        TestUtils.waitFor(\"Wait for KafkaConnect 'Unschedulable' condition due to wrong rackKey used.\",\n+                Constants.GLOBAL_POLL_INTERVAL, CO_OPERATION_TIMEOUT_SHORT * 2, () -> {\n+                List<Condition> conditions = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getStatus().getConditions();\n+                for (Condition condition : conditions) {\n+                    if (condition.getReason().matches(\"TimeoutException\") && condition.getType().matches(\"NotReady\")) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            });\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyODU2MQ==", "bodyText": "maybe put rack key into the log as well?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527028561", "createdAt": "2020-11-19T16:35:06Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,151 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnectWrongDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .addToConfig(\"key.converter.schemas.enable\", false)\n+                .addToConfig(\"value.converter.schemas.enable\", false)\n+                .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        TestUtils.waitFor(\"Wait for KafkaConnect 'Unschedulable' condition due to wrong rackKey used.\",\n+                Constants.GLOBAL_POLL_INTERVAL, CO_OPERATION_TIMEOUT_SHORT * 2, () -> {\n+                List<Condition> conditions = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getStatus().getConditions();\n+                for (Condition condition : conditions) {\n+                    if (condition.getReason().matches(\"TimeoutException\") && condition.getType().matches(\"NotReady\")) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            });\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CLUSTER_NAME, kafkaConnect -> {\n+            kafkaConnect.getSpec().setRack(new Rack(rackKey));\n+        });\n+        KafkaConnectUtils.waitForConnectReady(CLUSTER_NAME);\n+        LOGGER.info(\"KafkaConnect is ready with changed rack key.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyOTgzOQ==", "bodyText": "isn't it by default applied for each KC which we create during tests?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527029839", "createdAt": "2020-11-19T16:36:51Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,151 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnectWrongDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .addToConfig(\"key.converter.schemas.enable\", false)\n+                .addToConfig(\"value.converter.schemas.enable\", false)\n+                .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        TestUtils.waitFor(\"Wait for KafkaConnect 'Unschedulable' condition due to wrong rackKey used.\",\n+                Constants.GLOBAL_POLL_INTERVAL, CO_OPERATION_TIMEOUT_SHORT * 2, () -> {\n+                List<Condition> conditions = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getStatus().getConditions();\n+                for (Condition condition : conditions) {\n+                    if (condition.getReason().matches(\"TimeoutException\") && condition.getType().matches(\"NotReady\")) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            });\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CLUSTER_NAME, kafkaConnect -> {\n+            kafkaConnect.getSpec().setRack(new Rack(rackKey));\n+        });\n+        KafkaConnectUtils.waitForConnectReady(CLUSTER_NAME);\n+        LOGGER.info(\"KafkaConnect is ready with changed rack key.\");\n+        LOGGER.info(\"Verify KafkaConnect rack key update\");\n+        kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        assertThat(kc.getSpec().getRack().getTopologyKey(), is(rackKey));\n+\n+        if (Environment.DEFAULT_TO_DENY_NETWORK_POLICIES.equals(Boolean.TRUE.toString())) {\n+            KubernetesResource.allowNetworkPolicySettingsForResource(kc, KafkaConnectResources.deploymentName(kc.getMetadata().getName()));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAzMDA4NA==", "bodyText": "indent", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527030084", "createdAt": "2020-11-19T16:37:09Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,151 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnectWrongDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .addToConfig(\"key.converter.schemas.enable\", false)\n+                .addToConfig(\"value.converter.schemas.enable\", false)\n+                .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAzMjA1MQ==", "bodyText": "Same as I mentioned above", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527032051", "createdAt": "2020-11-19T16:39:44Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,151 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n+        final String defaultKafkaClientsPodName =\n+                ResourceManager.kubeClient().listPodsByPrefixInName(CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).get(0).getMetadata().getName();\n+        InternalKafkaClient internalKafkaClient = new InternalKafkaClient.Builder()\n+                .withUsingPodName(defaultKafkaClientsPodName)\n+                .withTopicName(TOPIC_NAME)\n+                .withNamespaceName(NAMESPACE)\n+                .withClusterName(CLUSTER_NAME)\n+                .withMessageCount(MESSAGE_COUNT)\n+                .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME)\n+                .build();\n+\n+        internalKafkaClient.verifyProducedAndConsumedMessages(\n+                internalKafkaClient.sendMessagesPlain(),\n+                internalKafkaClient.receiveMessagesPlain()\n         );\n     }\n \n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    void testRackAwareConnectWrongDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String wrongRackKey = \"wrong-key\";\n+        String rackKey = \"rack-key\";\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with wrong rack-aware topology key: {}\", wrongRackKey);\n+        KafkaConnectResource.kafkaConnectWithoutWait(KafkaConnectResource.defaultKafkaConnect(CLUSTER_NAME, CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(wrongRackKey)\n+                    .endRack()\n+                .addToConfig(\"key.converter.schemas.enable\", false)\n+                .addToConfig(\"value.converter.schemas.enable\", false)\n+                .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .endSpec().build());\n+\n+        PodUtils.waitForPendingPod(CLUSTER_NAME + \"-connect\");\n+        List<String> connectWrongPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        String connectWrongPodName = connectWrongPods.get(0);\n+        LOGGER.info(\"Waiting for ClusterOperator to get timeout operation of incorrectly set up KafkaConnect\");\n+        TestUtils.waitFor(\"Wait for KafkaConnect 'Unschedulable' condition due to wrong rackKey used.\",\n+                Constants.GLOBAL_POLL_INTERVAL, CO_OPERATION_TIMEOUT_SHORT * 2, () -> {\n+                List<Condition> conditions = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get().getStatus().getConditions();\n+                for (Condition condition : conditions) {\n+                    if (condition.getReason().matches(\"TimeoutException\") && condition.getType().matches(\"NotReady\")) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            });\n+\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        Condition kcCondition = kc.getStatus().getConditions().get(0);\n+        assertThat(\"NotReady\", is(kcCondition.getType()));\n+        assertThat(\"TimeoutException\", is(kcCondition.getReason()));\n+\n+        PodStatus kcWrongStatus = kubeClient().getPod(connectWrongPodName).getStatus();\n+        assertThat(\"Unschedulable\", is(kcWrongStatus.getConditions().get(0).getReason()));\n+        assertThat(\"PodScheduled\", is(kcWrongStatus.getConditions().get(0).getType()));\n+\n+        KafkaConnectResource.replaceKafkaConnectResource(CLUSTER_NAME, kafkaConnect -> {\n+            kafkaConnect.getSpec().setRack(new Rack(rackKey));\n+        });\n+        KafkaConnectUtils.waitForConnectReady(CLUSTER_NAME);\n+        LOGGER.info(\"KafkaConnect is ready with changed rack key.\");\n+        LOGGER.info(\"Verify KafkaConnect rack key update\");\n+        kc = KafkaConnectResource.kafkaConnectClient().inNamespace(NAMESPACE).withName(CLUSTER_NAME).get();\n+        assertThat(kc.getSpec().getRack().getTopologyKey(), is(rackKey));\n+\n+        if (Environment.DEFAULT_TO_DENY_NETWORK_POLICIES.equals(Boolean.TRUE.toString())) {\n+            KubernetesResource.allowNetworkPolicySettingsForResource(kc, KafkaConnectResources.deploymentName(kc.getMetadata().getName()));\n+        }\n+        List<String> kcPods = kubeClient().listPodNames(Labels.STRIMZI_KIND_LABEL, KafkaConnect.RESOURCE_KIND);\n+        KafkaConnectUtils.sendReceiveMessagesThroughConnect(kcPods.get(0), TOPIC_NAME, kafkaClientsPodName, NAMESPACE, CLUSTER_NAME);\n+    }\n+\n+    @Test\n+    @Tag(CONNECT)\n+    @Tag(REGRESSION)\n+    public void testRackAwareConnectCorrectDeployment() throws Exception {\n+        installClusterOperator(NAMESPACE, CO_OPERATION_TIMEOUT_SHORT);\n+\n+        String rackKey = \"rack-key\";\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3)\n+                .editSpec()\n+                    .editKafka()\n+                        .withNewRack()\n+                            .withTopologyKey(rackKey)\n+                        .endRack()\n+                        .addToConfig(\"replica.selector.class\", \"org.apache.kafka.common.replica.RackAwareReplicaSelector\")\n+                    .endKafka()\n+                .endSpec().done();\n+\n+        KafkaClientsResource.deployKafkaClients(false, KAFKA_CLIENTS_NAME).done();\n+        String kafkaClientsPodName = kubeClient().listPodsByPrefixInName(KAFKA_CLIENTS_NAME).get(0).getMetadata().getName();\n+\n+        LOGGER.info(\"Deploy KafkaConnect with correct rack-aware topology key: {}\", rackKey);\n+        KafkaConnect kc = KafkaConnectResource.kafkaConnect(CLUSTER_NAME, 1)\n+                .editSpec()\n+                    .withNewRack()\n+                        .withTopologyKey(rackKey)\n+                    .endRack()\n+                    .addToConfig(\"key.converter.schemas.enable\", false)\n+                    .addToConfig(\"value.converter.schemas.enable\", false)\n+                    .addToConfig(\"key.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                    .addToConfig(\"value.converter\", \"org.apache.kafka.connect.storage.StringConverter\")\n+                .endSpec().done();\n+        if (Environment.DEFAULT_TO_DENY_NETWORK_POLICIES.equals(Boolean.TRUE.toString())) {\n+            KubernetesResource.allowNetworkPolicySettingsForResource(kc, KafkaConnectResources.deploymentName(kc.getMetadata().getName()));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aac1bfe88b502c06821a1c3a93cf1b7ff448395f"}, "originalPosition": 212}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0ODg0NDkz", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#pullrequestreview-534884493", "createdAt": "2020-11-19T21:50:25Z", "commit": {"oid": "9b9af81b61d1cf33d87366ab643d8b8c09e4fcd2"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMTo1MDoyNVrOH2zSog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMTo1MTozMVrOH2zVCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIyNTUwNg==", "bodyText": "How about to add INTERNAL_CLIENTS_USED as well?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527225506", "createdAt": "2020-11-19T21:50:25Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -56,8 +75,7 @@\n     public static final String NAMESPACE = \"specific-cluster-test\";\n \n     @Test\n-    @Tag(LOADBALANCER_SUPPORTED)\n-    @Tag(EXTERNAL_CLIENTS_USED)\n+    @Tag(REGRESSION)\n     void testRackAware() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b9af81b61d1cf33d87366ab643d8b8c09e4fcd2"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIyNjEyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();\n          \n          \n            \n                    KafkaClientsResource.deployKafkaClients(true, KAFKA_CLIENTS_NAME).done();\n          \n          \n            \n            ``` ?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#discussion_r527226120", "createdAt": "2020-11-19T21:51:31Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/specific/SpecificST.java", "diffHunk": "@@ -100,20 +110,147 @@ void testRackAware() {\n         List<Event> events = kubeClient().listEvents(uid);\n         assertThat(events, hasAllOfReasons(Scheduled, Pulled, Created, Started));\n \n-        BasicExternalKafkaClient basicExternalKafkaClient = new BasicExternalKafkaClient.Builder()\n-            .withTopicName(TOPIC_NAME)\n-            .withNamespaceName(NAMESPACE)\n-            .withClusterName(CLUSTER_NAME)\n-            .withMessageCount(MESSAGE_COUNT)\n-            .withListenerName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-            .build();\n-\n-        basicExternalKafkaClient.verifyProducedAndConsumedMessages(\n-            basicExternalKafkaClient.sendMessagesPlain(),\n-            basicExternalKafkaClient.receiveMessagesPlain()\n+        KafkaClientsResource.deployKafkaClients(true, CLUSTER_NAME + \"-\" + Constants.KAFKA_CLIENTS).done();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b9af81b61d1cf33d87366ab643d8b8c09e4fcd2"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5MTQxODYz", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#pullrequestreview-539141863", "createdAt": "2020-11-26T09:35:57Z", "commit": {"oid": "abcc3be50be090ba68303beb440e493b300d50b1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5MTQ4NjQ2", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3873#pullrequestreview-539148646", "createdAt": "2020-11-26T09:43:54Z", "commit": {"oid": "abcc3be50be090ba68303beb440e493b300d50b1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c3634c20d32ebb1c124f8c3b9666cd5f623de01", "author": {"user": {"login": "michalxo", "name": "Michal T"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/7c3634c20d32ebb1c124f8c3b9666cd5f623de01", "committedDate": "2020-11-26T11:04:53Z", "message": "NEW(Tests) testRackAwareConnect\n\nSigned-off-by: Michal T\u00f3th <mtoth@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "abcc3be50be090ba68303beb440e493b300d50b1", "author": {"user": {"login": "michalxo", "name": "Michal T"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/abcc3be50be090ba68303beb440e493b300d50b1", "committedDate": "2020-11-26T08:26:18Z", "message": "fixup! NEW(Tests) testRackAwareConnect\n\nSigned-off-by: Michal T\u00f3th <mtoth@redhat.com>"}, "afterCommit": {"oid": "7c3634c20d32ebb1c124f8c3b9666cd5f623de01", "author": {"user": {"login": "michalxo", "name": "Michal T"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/7c3634c20d32ebb1c124f8c3b9666cd5f623de01", "committedDate": "2020-11-26T11:04:53Z", "message": "NEW(Tests) testRackAwareConnect\n\nSigned-off-by: Michal T\u00f3th <mtoth@redhat.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 857, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}