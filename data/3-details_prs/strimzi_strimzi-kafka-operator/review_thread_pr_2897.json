{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4OTkxMjUx", "number": 2897, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxNzo1MjowMlrOD2Xmxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODo0NTowM1rOD5uSAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MzM2NDU0OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxNzo1MjowMlrOGMHx3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMToyMzo0OFrOGO62bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ==", "bodyText": "I might be wrong in saying this, but maybe we should tell reconcileConnectors to expect a ConnectTimeoutException if replicas ==  0? Then we don't have to capture the exception here.\n(essentially move this logic into reconcileConnectors and change its behaviour.)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415363551", "createdAt": "2020-04-26T17:52:02Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2NDc0OA==", "bodyText": "I had it that way originally. But it is not completely easy, because the connector reconciliation is triggered form two sources:\n\nKafkaConnectAssemblyOperator and KafkaConnectS2IAssemblyOperator which can provide the replicas.\nThe KafkaConnector watch which doesn't have them. So it creates inconsistent results based on where it is triggered from and it seemed to be better this way.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415364748", "createdAt": "2020-04-26T17:57:55Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU2NzUxMA==", "bodyText": "Won't this error handling result in the Ready status on the KafkaConnect? It's ready in the sense that there wasn't an error in the reconciliation, but not in the sense that the cluster is 'ready' for REST requests, is that what we want?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415567510", "createdAt": "2020-04-27T07:15:25Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU3MTA2OA==", "bodyText": "It does, but that is the point of the whole issue. To stop the reocnciliation failing when scaled to 0. There will be no REST API, but the resource will be ready in the sense that it will run as requested from the user.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415571068", "createdAt": "2020-04-27T07:21:30Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4OTU4Mg==", "bodyText": "Fair point. But that means we're treating NotReady has having the semantics of \"failed\", rather than simply the cluster not being ready. Maybe we need a different condition entirely? I do feel that we need some way to distinguish a scaled-to-zero-like-you-asked kind of Ready from REST-interface-should-work kind of Ready, because people will want to automate on top of this status and so it needs to be unambiguous.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415589582", "createdAt": "2020-04-27T07:51:22Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMzU4Nw==", "bodyText": "So what status would you set in such case?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415633587", "createdAt": "2020-04-27T08:55:34Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4MjI1Mw==", "bodyText": "I'm not sure, are there any precedents in Kube with scale to zero (in Deployment, ReplicaSet or StatefulSet)? If Kube uses Ready in this case, maybe it would be enough to omit the REST connection information when scaled to zero.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415682253", "createdAt": "2020-04-27T10:06:42Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyMDYyNw==", "bodyText": "Only Pod has Ready conditionm but there is no pod when it has 0 replicas. In deployment, the conditions do not show anything different from when they have replicas. They have for example the Available condition set to True.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415720627", "createdAt": "2020-04-27T11:08:32Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIxNjAwMA==", "bodyText": "I think it would make sense to me that we use a similar mechanism to what deployments and statefulsets use and say Available false and give a reason like: NoReplicas / InvalidReplicas, e.g. the condition would look something like:\n - lastTransitionTime: \"2020-04-29T09:26:39Z\"\n    lastUpdateTime: \"2020-04-29T09:26:39Z\"\n    message: Scaling KafkaConnect to 0 is not supported.\n    reason: InvalidReplicas\n    status: \"False\"\n    type: Available", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r417216000", "createdAt": "2020-04-29T10:30:47Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI1MDQwNw==", "bodyText": "They actually don't seem to do that. A deployment scaled to 0 has just this:\n  status:\n    conditions:\n    - lastTransitionTime: \"2020-04-29T08:15:31Z\"\n      lastUpdateTime: \"2020-04-29T08:34:48Z\"\n      message: ReplicaSet \"strimzi-cluster-operator-7bcd647d8d\" has successfully progressed.\n      reason: NewReplicaSetAvailable\n      status: \"True\"\n      type: Progressing\n    - lastTransitionTime: \"2020-04-29T11:18:52Z\"\n      lastUpdateTime: \"2020-04-29T11:18:52Z\"\n      message: Deployment has minimum availability.\n      reason: MinimumReplicasAvailable\n      status: \"True\"\n      type: Available\n    observedGeneration: 3\n\nSo it actually says it is available. If we would go for it (regardless what Deployment does), the wierd thing would be whether it make sense to say Available / False when we do not have available / True when everything is working.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r417250407", "createdAt": "2020-04-29T11:40:02Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMyMDMwNQ==", "bodyText": "Thinking more I don't think we should try to solve this using conditions, because we'll be forced into have two and that makes life harder at the point of use because to test for readiness you would need to check for both Ready and Available (or Ready and not Unavailable, or whatever). replicas=0 is a bit of an edge case which most people shouldn't have to deal with.\nSo on reflection when replicas=0 I guess it would be OK to say Ready=true, but to not set the status.url or status.connectorPlugins. I think that would be enough of a signal for people wanting to use replicas=0.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r417320305", "createdAt": "2020-04-29T13:37:44Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU3MjMxMQ==", "bodyText": "Makes sense to me, my original thinking was that we would effectively override the deployments state of availability (that's why my suggestion differs from the deployment example Jakub linked) - but you are right querying two separate status conditions seems like extra complexity...\nTom's suggestion makes sense to me, though I do wonder if a user would be confused why the url/connectorPlugins fields are missing. Perhaps we follow the pattern that @dalelane introduced in #2663 and print an additional condition as a warning so the user has a little more to go on?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r417572311", "createdAt": "2020-04-29T19:53:51Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYwMTgxNw==", "bodyText": "Tom's suggestion makes sense to me, though I do wonder if a user would be confused why the url/connectorPlugins fields are missing. Perhaps we follow the pattern that @dalelane introduced in #2663 and print an additional condition as a warning so the user has a little more to go on?\n\nI can do that if you want. Although the scaling to 0 is from my point of view always intentional and not done by mistake or not understanding how things work.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r417601817", "createdAt": "2020-04-29T20:48:12Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1ODI4NQ==", "bodyText": "Very true, I agree it seems very unlikely a user would scale down to 0 and also expect a service to still exist. But i do still think an additional entry to conditions clarifying that ita ready but only in the trivial sense of that all containers (that is zero of them) are ready as there is nothing to do.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r417658285", "createdAt": "2020-04-29T22:51:36Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA1NDk4OQ==", "bodyText": "@tombentley Does this sound reasonable to you? Want to make sure this works for everyone before implementing it.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r418054989", "createdAt": "2020-04-30T14:31:41Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA2ODQ3NA==", "bodyText": "What's the proposal exactly:\ntype: \"Available\"\nstatus: \"False\"\nreason: \"ScaledToZero\"", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r418068474", "createdAt": "2020-04-30T14:49:31Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA3MTEwNw==", "bodyText": "Something like that. The actual names can be finetuned easily later. I do not think the Available type makes sense ... I would probably form it more as a warning or something.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r418071107", "createdAt": "2020-04-30T14:53:17Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5NTI4MQ==", "bodyText": "I'm not keen on calling it a warning. They asked for 0, and we gave them 0. There's no particular reason to treat that differently from other numbers of replicas. They asked for 3, but maybe they meant 5?\nI think the warnings we added in #2663 were useful because they highlighted very definite cases where people could break their clusters/lose data. That's not the case here.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r418095281", "createdAt": "2020-04-30T15:26:49Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0MzE0Ng==", "bodyText": "I'm not sure I like the Available: False when we have no Available: True. But if that is fine for @samuel-hawker I can implement it.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r418243146", "createdAt": "2020-04-30T19:36:10Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NzQ1Mw==", "bodyText": "I agree that we should forego the Available condition, I wish I had made that a bit more clear further up the thread.\nI agree that if a user asks for 0 replicas, we give them 0 replicas, I suggested a Warning only because a user in theory could wonder why the status.url or status.connectorPlugins fields are empty or missing.\nSomething like:\ntype: \"Warning\"\nreason: \"Zero replicas so no provided URL\"\n\nBut maybe there is little value in this - what do you think @tombentley ?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r418297453", "createdAt": "2020-04-30T21:23:48Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MzM2NDY5OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectS2IAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxNzo1MjoxNFrOGMHx8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxNzo1MjoxNFrOGMHx8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU3MQ==", "bodyText": "ditto prev comment", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415363571", "createdAt": "2020-04-26T17:52:14Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectS2IAssemblyOperator.java", "diffHunk": "@@ -152,8 +153,15 @@ public KafkaConnectS2IAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability\n                 .compose(i -> buildConfigOperations.reconcile(namespace, KafkaConnectS2IResources.buildConfigName(connect.getCluster()), connect.generateBuildConfig()))\n                 .compose(i -> deploymentConfigOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentConfigOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentConfigOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnectS2I, kafkaConnectS2Istatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentConfigOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnectS2I, kafkaConnectS2Istatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NDk3NzM3OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/ConnectorMockTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwNzoxMDozNVrOGMUD9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwNzoyMjozMVrOGMUe4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU2NDc4OQ==", "bodyText": "Should the status message include what the connection was being made to? \"Connection to Connect REST API timed out\", or \"Connection to foo.bar:8083 timed out\", or something like that?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415564789", "createdAt": "2020-04-27T07:10:35Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/ConnectorMockTest.java", "diffHunk": "@@ -938,4 +939,133 @@ public void testConnectorPauseResume() {\n                 eq(connectorName));\n     }\n \n+    /** Create connect, create connector, Scale to 0 */\n+    @Test\n+    public void testConnectScaleToZero() {\n+        String connectName = \"cluster\";\n+        String connectorName = \"connector\";\n+\n+        // Create KafkaConnect cluster and wait till it's ready\n+        Crds.kafkaConnectOperation(client).inNamespace(NAMESPACE).createNew()\n+                .withNewMetadata()\n+                .withNamespace(NAMESPACE)\n+                .withName(connectName)\n+                .addToAnnotations(Annotations.STRIMZI_IO_USE_CONNECTOR_RESOURCES, \"true\")\n+                .endMetadata()\n+                .withNewSpec()\n+                    .withReplicas(1)\n+                .endSpec()\n+                .done();\n+        waitForConnectReady(connectName);\n+\n+        // triggered twice (creation followed by status update)\n+        verify(api, times(2)).list(\n+                eq(KafkaConnectResources.qualifiedServiceName(connectName, NAMESPACE)), eq(KafkaConnectCluster.REST_API_PORT));\n+\n+        verify(api, never()).createOrUpdatePutRequest(\n+                eq(KafkaConnectResources.qualifiedServiceName(connectName, NAMESPACE)), eq(KafkaConnectCluster.REST_API_PORT),\n+                eq(connectorName), any());\n+\n+        // Create KafkaConnector and wait till it's ready\n+        Crds.kafkaConnectorOperation(client).inNamespace(NAMESPACE).createNew()\n+                .withNewMetadata()\n+                .withName(connectorName)\n+                .withNamespace(NAMESPACE)\n+                .addToLabels(Labels.STRIMZI_CLUSTER_LABEL, connectName)\n+                .endMetadata()\n+                .withNewSpec()\n+                .withTasksMax(1)\n+                .withClassName(\"Dummy\")\n+                .endSpec()\n+                .done();\n+        waitForConnectorReady(connectorName);\n+\n+        verify(api, times(2)).list(\n+                eq(KafkaConnectResources.qualifiedServiceName(connectName, NAMESPACE)), eq(KafkaConnectCluster.REST_API_PORT));\n+        verify(api, times(2)).createOrUpdatePutRequest(\n+                eq(KafkaConnectResources.qualifiedServiceName(connectName, NAMESPACE)), eq(KafkaConnectCluster.REST_API_PORT),\n+                eq(connectorName), any());\n+        assertThat(runningConnectors.keySet(), is(Collections.singleton(key(\"cluster-connect-api.ns.svc\", connectorName))));\n+\n+        when(api.list(any(), anyInt())).thenReturn(Future.failedFuture(new ConnectTimeoutException(\"connection timed out\")));\n+        when(api.listConnectorPlugins(any(), anyInt())).thenReturn(Future.failedFuture(new ConnectTimeoutException(\"connection timed out\")));\n+        when(api.createOrUpdatePutRequest(any(), anyInt(), anyString(), any())).thenReturn(Future.failedFuture(new ConnectTimeoutException(\"connection timed out\")));\n+        when(api.getConnectorConfig(any(), any(), anyInt(), any())).thenReturn(Future.failedFuture(new ConnectTimeoutException(\"connection timed out\")));\n+        when(api.getConnector(any(), anyInt(), any())).thenReturn(Future.failedFuture(new ConnectTimeoutException(\"connection timed out\")));\n+\n+        Crds.kafkaConnectOperation(client).inNamespace(NAMESPACE).withName(connectName).edit()\n+                .editSpec()\n+                    .withReplicas(0)\n+                .endSpec()\n+                .done();\n+\n+        waitForConnectReady(connectName);\n+        waitForConnectorNotReady(connectorName, \"ConnectTimeoutException\", \"connection timed out\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU3MTY4Mg==", "bodyText": "Thsi is really just the test exception based on what the mocked APi throws. The atual exception would be much longer and will include the adress.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415571682", "createdAt": "2020-04-27T07:22:31Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/ConnectorMockTest.java", "diffHunk": "@@ -938,4 +939,133 @@ public void testConnectorPauseResume() {\n                 eq(connectorName));\n     }\n \n+    /** Create connect, create connector, Scale to 0 */\n+    @Test\n+    public void testConnectScaleToZero() {\n+        String connectName = \"cluster\";\n+        String connectorName = \"connector\";\n+\n+        // Create KafkaConnect cluster and wait till it's ready\n+        Crds.kafkaConnectOperation(client).inNamespace(NAMESPACE).createNew()\n+                .withNewMetadata()\n+                .withNamespace(NAMESPACE)\n+                .withName(connectName)\n+                .addToAnnotations(Annotations.STRIMZI_IO_USE_CONNECTOR_RESOURCES, \"true\")\n+                .endMetadata()\n+                .withNewSpec()\n+                    .withReplicas(1)\n+                .endSpec()\n+                .done();\n+        waitForConnectReady(connectName);\n+\n+        // triggered twice (creation followed by status update)\n+        verify(api, times(2)).list(\n+                eq(KafkaConnectResources.qualifiedServiceName(connectName, NAMESPACE)), eq(KafkaConnectCluster.REST_API_PORT));\n+\n+        verify(api, never()).createOrUpdatePutRequest(\n+                eq(KafkaConnectResources.qualifiedServiceName(connectName, NAMESPACE)), eq(KafkaConnectCluster.REST_API_PORT),\n+                eq(connectorName), any());\n+\n+        // Create KafkaConnector and wait till it's ready\n+        Crds.kafkaConnectorOperation(client).inNamespace(NAMESPACE).createNew()\n+                .withNewMetadata()\n+                .withName(connectorName)\n+                .withNamespace(NAMESPACE)\n+                .addToLabels(Labels.STRIMZI_CLUSTER_LABEL, connectName)\n+                .endMetadata()\n+                .withNewSpec()\n+                .withTasksMax(1)\n+                .withClassName(\"Dummy\")\n+                .endSpec()\n+                .done();\n+        waitForConnectorReady(connectorName);\n+\n+        verify(api, times(2)).list(\n+                eq(KafkaConnectResources.qualifiedServiceName(connectName, NAMESPACE)), eq(KafkaConnectCluster.REST_API_PORT));\n+        verify(api, times(2)).createOrUpdatePutRequest(\n+                eq(KafkaConnectResources.qualifiedServiceName(connectName, NAMESPACE)), eq(KafkaConnectCluster.REST_API_PORT),\n+                eq(connectorName), any());\n+        assertThat(runningConnectors.keySet(), is(Collections.singleton(key(\"cluster-connect-api.ns.svc\", connectorName))));\n+\n+        when(api.list(any(), anyInt())).thenReturn(Future.failedFuture(new ConnectTimeoutException(\"connection timed out\")));\n+        when(api.listConnectorPlugins(any(), anyInt())).thenReturn(Future.failedFuture(new ConnectTimeoutException(\"connection timed out\")));\n+        when(api.createOrUpdatePutRequest(any(), anyInt(), anyString(), any())).thenReturn(Future.failedFuture(new ConnectTimeoutException(\"connection timed out\")));\n+        when(api.getConnectorConfig(any(), any(), anyInt(), any())).thenReturn(Future.failedFuture(new ConnectTimeoutException(\"connection timed out\")));\n+        when(api.getConnector(any(), anyInt(), any())).thenReturn(Future.failedFuture(new ConnectTimeoutException(\"connection timed out\")));\n+\n+        Crds.kafkaConnectOperation(client).inNamespace(NAMESPACE).withName(connectName).edit()\n+                .editSpec()\n+                    .withReplicas(0)\n+                .endSpec()\n+                .done();\n+\n+        waitForConnectReady(connectName);\n+        waitForConnectorNotReady(connectorName, \"ConnectTimeoutException\", \"connection timed out\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU2NDc4OQ=="}, "originalCommit": {"oid": "456c871f34e85df78930db28be1559bc532a535c"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxODQ0NTk4OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODoxODozNVrOGRIiRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODoxODozNVrOGRIiRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYxODgyMA==", "bodyText": "Isn't this the same check twice?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r420618820", "createdAt": "2020-05-06T08:18:35Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -208,6 +209,11 @@ public void eventReceived(Action action, KafkaConnector kafkaConnector) {\n                                                 log.info(\"{} {} in namespace {} was {}, but Connect cluster {} does not exist\", connectorKind, connectorName, connectorNamespace, action, connectName);\n                                                 updateStatus(noConnectCluster(connectNamespace, connectName), kafkaConnector, connectOperator.connectorOperator);\n                                                 return Future.succeededFuture();\n+                                            } else if ((connect != null && connect.getSpec() != null && connect.getSpec().getReplicas() == 0)\n+                                                    || (connect != null && connect.getSpec() != null && connect.getSpec().getReplicas() == 0))    {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c38541dcedebff490163a5e5b588e8cba277f48f"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxODQ2MDM2OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODoyMjo1OVrOGRIrUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODoyMjo1OVrOGRIrUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyMTEzNg==", "bodyText": "Since we are now computing\nconnect.getReplicas() > 0\nconnect.getReplicas() == 0\nand > 0 again here is it worth setting a boolean before the compose something like:\nconnectHasZeroReplicas = connect.getReplicas() == 0\n\nAnd then re-using this value for logic gating? I think it makes sense from the reconcile loop to have as little logic gating as possible and pre-declaring it on a one-time computed boolean might make the intent a little more clearer.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r420621136", "createdAt": "2020-05-06T08:22:59Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,11 +143,14 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus, connect.getReplicas() == 0))\n                 .setHandler(reconciliationResult -> {\n                     StatusUtils.setStatusConditionAndObservedGeneration(kafkaConnect, kafkaConnectStatus, reconciliationResult);\n-                    kafkaConnectStatus.setUrl(KafkaConnectResources.url(connect.getCluster(), namespace, KafkaConnectCluster.REST_API_PORT));\n+\n+                    if (connect.getReplicas() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c38541dcedebff490163a5e5b588e8cba277f48f"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxODQ2MTEyOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectS2IAssemblyOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODoyMzowOFrOGRIrvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODoyMzowOFrOGRIrvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyMTI0NA==", "bodyText": "ditto", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r420621244", "createdAt": "2020-05-06T08:23:08Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectS2IAssemblyOperator.java", "diffHunk": "@@ -152,12 +152,15 @@ public KafkaConnectS2IAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability\n                 .compose(i -> buildConfigOperations.reconcile(namespace, KafkaConnectS2IResources.buildConfigName(connect.getCluster()), connect.generateBuildConfig()))\n                 .compose(i -> deploymentConfigOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentConfigOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentConfigOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnectS2I, kafkaConnectS2Istatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentConfigOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnectS2I, kafkaConnectS2Istatus, connect.getReplicas() == 0))\n                 .setHandler(reconciliationResult -> {\n                     StatusUtils.setStatusConditionAndObservedGeneration(kafkaConnectS2I, kafkaConnectS2Istatus, reconciliationResult);\n-                    kafkaConnectS2Istatus.setUrl(KafkaConnectS2IResources.url(connect.getCluster(), namespace, KafkaConnectS2ICluster.REST_API_PORT));\n-                    kafkaConnectS2Istatus.setBuildConfigName(KafkaConnectS2IResources.buildConfigName(connect.getCluster()));\n+\n+                    if (connect.getReplicas() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c38541dcedebff490163a5e5b588e8cba277f48f"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxODUzNjk2OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODo0NTowM1rOGRJceg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwOTowNTowOFrOGRKIdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMzcyMg==", "bodyText": "What about the case where both connect and connectS2i are non null, but connectS2i is scaled to 0? We'd say there were zero replicas via the first branch, but we ought to proceed via the 2nd branch, right?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r420633722", "createdAt": "2020-05-06T08:45:03Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -208,6 +209,11 @@ public void eventReceived(Action action, KafkaConnector kafkaConnector) {\n                                                 log.info(\"{} {} in namespace {} was {}, but Connect cluster {} does not exist\", connectorKind, connectorName, connectorNamespace, action, connectName);\n                                                 updateStatus(noConnectCluster(connectNamespace, connectName), kafkaConnector, connectOperator.connectorOperator);\n                                                 return Future.succeededFuture();\n+                                            } else if ((connect != null && connect.getSpec() != null && connect.getSpec().getReplicas() == 0)\n+                                                    || (connectS2i != null && connectS2i.getSpec() != null && connectS2i.getSpec().getReplicas() == 0))    {\n+                                                log.info(\"{} {} in namespace {} was {}, but Connect cluster {} has 0 replicas\", connectorKind, connectorName, connectorNamespace, action, connectName);\n+                                                updateStatus(zeroReplicas(connectNamespace, connectName), kafkaConnector, connectOperator.connectorOperator);\n+                                                return Future.succeededFuture();\n                                             } else if (connect != null && isOlderOrAlone(connect.getMetadata().getCreationTimestamp(), connectS2i)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92956f5fb00f2a08a3444af52ec4563c773add7d"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY0NDk4MA==", "bodyText": "Good point. I pushed it one block below to make sure it is reflected which Connect takes the priority. Thanks", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r420644980", "createdAt": "2020-05-06T09:05:08Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -208,6 +209,11 @@ public void eventReceived(Action action, KafkaConnector kafkaConnector) {\n                                                 log.info(\"{} {} in namespace {} was {}, but Connect cluster {} does not exist\", connectorKind, connectorName, connectorNamespace, action, connectName);\n                                                 updateStatus(noConnectCluster(connectNamespace, connectName), kafkaConnector, connectOperator.connectorOperator);\n                                                 return Future.succeededFuture();\n+                                            } else if ((connect != null && connect.getSpec() != null && connect.getSpec().getReplicas() == 0)\n+                                                    || (connectS2i != null && connectS2i.getSpec() != null && connectS2i.getSpec().getReplicas() == 0))    {\n+                                                log.info(\"{} {} in namespace {} was {}, but Connect cluster {} has 0 replicas\", connectorKind, connectorName, connectorNamespace, action, connectName);\n+                                                updateStatus(zeroReplicas(connectNamespace, connectName), kafkaConnector, connectOperator.connectorOperator);\n+                                                return Future.succeededFuture();\n                                             } else if (connect != null && isOlderOrAlone(connect.getMetadata().getCreationTimestamp(), connectS2i)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMzcyMg=="}, "originalCommit": {"oid": "92956f5fb00f2a08a3444af52ec4563c773add7d"}, "originalPosition": 35}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 237, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}