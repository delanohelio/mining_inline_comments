{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3NzkzMjQ0", "number": 2780, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMzoxNzozNFrODuJwjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMzoxOTo0MVrODuJyYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NzIwOTc1OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorCustomCertTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMzoxNzozNFrOF__zyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1NToyOVrOGAMQmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1MDA1OQ==", "bodyText": "I think some of these will cause lot of conflicts with my changes in #2737. Some things such as the metrics do not work well when you are opening and closing vertx too often. So I actually mmoved most of these to @BeforeAll / @afterall and tied to keep the method names as before and after. Was there any particular reason why moving Vet.x to @beforeeach / @AfterEach?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2780#discussion_r402650059", "createdAt": "2020-04-02T23:17:34Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorCustomCertTest.java", "diffHunk": "@@ -62,17 +66,91 @@\n     private final String clusterName = \"testkafka\";\n     protected static Vertx vertx;\n \n-    @BeforeAll\n-    public static void before() {\n+    private Kafka kafka;\n+    private KafkaCluster kafkaCluster;\n+    private ResourceOperatorSupplier supplier;\n+    private KafkaAssemblyOperator operator;\n+    private ArgumentCaptor<StatefulSet> reconcileStsCaptor;\n+    private ArgumentCaptor<Function<Pod, String>> isPodToRestartFunctionCaptor;\n+\n+    /**\n+     * Mock the KafkaAssemblyOperator and override reconcile to only run through the steps we want to test\n+     */\n+    class MockKafkaAssemblyOperator extends KafkaAssemblyOperator  {\n+        public MockKafkaAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa, CertManager certManager, PasswordGenerator passwordGenerator, ResourceOperatorSupplier supplier, ClusterOperatorConfig config) {\n+            super(vertx, pfa, certManager, passwordGenerator, supplier, config);\n+        }\n+\n+        @Override\n+        Future<Void> reconcile(ReconciliationState reconcileState)  {\n+            return reconcileState.reconcileCas(this::dateSupplier)\n+                    .compose(state -> state.getKafkaClusterDescription())\n+                    .compose(state -> state.customTlsListenerCertificate())\n+                    .compose(state -> state.customExternalListenerCertificate())\n+                    .compose(state -> state.kafkaStatefulSet())\n+                    .compose(state -> state.kafkaRollingUpdate())\n+                    .map((Void) null);\n+        }\n+    }\n+\n+    @BeforeEach\n+    public void before() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f3992dedb2e5800e5d0777b3380e106d7813068"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NDA0Mw==", "bodyText": "You're absolutely right, I have changed it to follow your example.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2780#discussion_r402854043", "createdAt": "2020-04-03T08:55:29Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorCustomCertTest.java", "diffHunk": "@@ -62,17 +66,91 @@\n     private final String clusterName = \"testkafka\";\n     protected static Vertx vertx;\n \n-    @BeforeAll\n-    public static void before() {\n+    private Kafka kafka;\n+    private KafkaCluster kafkaCluster;\n+    private ResourceOperatorSupplier supplier;\n+    private KafkaAssemblyOperator operator;\n+    private ArgumentCaptor<StatefulSet> reconcileStsCaptor;\n+    private ArgumentCaptor<Function<Pod, String>> isPodToRestartFunctionCaptor;\n+\n+    /**\n+     * Mock the KafkaAssemblyOperator and override reconcile to only run through the steps we want to test\n+     */\n+    class MockKafkaAssemblyOperator extends KafkaAssemblyOperator  {\n+        public MockKafkaAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa, CertManager certManager, PasswordGenerator passwordGenerator, ResourceOperatorSupplier supplier, ClusterOperatorConfig config) {\n+            super(vertx, pfa, certManager, passwordGenerator, supplier, config);\n+        }\n+\n+        @Override\n+        Future<Void> reconcile(ReconciliationState reconcileState)  {\n+            return reconcileState.reconcileCas(this::dateSupplier)\n+                    .compose(state -> state.getKafkaClusterDescription())\n+                    .compose(state -> state.customTlsListenerCertificate())\n+                    .compose(state -> state.customExternalListenerCertificate())\n+                    .compose(state -> state.kafkaStatefulSet())\n+                    .compose(state -> state.kafkaRollingUpdate())\n+                    .map((Void) null);\n+        }\n+    }\n+\n+    @BeforeEach\n+    public void before() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1MDA1OQ=="}, "originalCommit": {"oid": "6f3992dedb2e5800e5d0777b3380e106d7813068"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NzIxMDg0OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorCustomCertTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMzoxODowNFrOF__0bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1NTozOFrOGAMRJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1MDIyMQ==", "bodyText": "I guess this is some rebasing issue? Should it be deleted or uncommented?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2780#discussion_r402650221", "createdAt": "2020-04-02T23:18:04Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorCustomCertTest.java", "diffHunk": "@@ -153,197 +231,207 @@ public Pod getPod(StatefulSet sts) {\n     }\n \n     @Test\n-    public void testWithUnchangedCertificates(VertxTestContext context) throws InterruptedException {\n-        Kafka kafka = getKafkaCrd();\n-        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(false);\n-        KafkaCluster kafkaCluster = KafkaCluster.fromCrd(kafka, VERSIONS, null);\n-\n-        // Mock the Kafka Operator\n-        CrdOperator mockKafkaOps = supplier.kafkaOperator;\n-        when(mockKafkaOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(getKafkaCrd()));\n-        when(mockKafkaOps.updateStatusAsync(any())).thenReturn(Future.succeededFuture());\n-\n-        // Mock the KafkaSetOperator\n-        KafkaSetOperator mockKafkaSetOps = supplier.kafkaSetOperations;\n-        when(mockKafkaSetOps.getAsync(eq(namespace), eq(KafkaCluster.kafkaClusterName(clusterName)))).thenReturn(Future.succeededFuture(kafkaCluster.generateStatefulSet(false, null, null)));\n-\n-        ArgumentCaptor<StatefulSet> reconcileStsCaptor = ArgumentCaptor.forClass(StatefulSet.class);\n-        when(mockKafkaSetOps.reconcile(eq(namespace), eq(KafkaCluster.kafkaClusterName(clusterName)), reconcileStsCaptor.capture())).then(invocation -> {\n-            return Future.succeededFuture(ReconcileResult.patched(invocation.getArgument(2)));\n-        });\n-\n-        ArgumentCaptor<StatefulSet> maybeRollingUpdateStsCaptor = ArgumentCaptor.forClass(StatefulSet.class);\n-        ArgumentCaptor<Function<Pod, String>> isPodToRestartFunctionCaptor = ArgumentCaptor.forClass(Function.class);\n-        when(mockKafkaSetOps.maybeRollingUpdate(maybeRollingUpdateStsCaptor.capture(), isPodToRestartFunctionCaptor.capture())).thenReturn(Future.succeededFuture());\n-\n-        // Mock the ConfigMapOperator\n-        ConfigMapOperator mockCmOps = supplier.configMapOperations;\n-        when(mockCmOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(kafkaCluster.generateMetricsAndLogConfigMap(null)));\n-\n-        // Mock the SecretOperator\n-        SecretOperator mockSecretOps = supplier.secretOperations;\n-        when(mockSecretOps.getAsync(eq(namespace), eq(\"my-tls-secret\"))).thenReturn(Future.succeededFuture(getTlsSecret()));\n-        when(mockSecretOps.getAsync(eq(namespace), eq(\"my-external-secret\"))).thenReturn(Future.succeededFuture(getExternalSecret()));\n-        when(mockSecretOps.reconcile(any(), any(), any())).then(invocation -> {\n-            return Future.succeededFuture(ReconcileResult.created(invocation.getArgument(2)));\n-        });\n-\n-        MockKafkaAssemblyOperator kao = new MockKafkaAssemblyOperator(vertx, new PlatformFeaturesAvailability(false, kubernetesVersion),\n-                certManager,\n-                passwordGenerator,\n-                supplier,\n-                config);\n-\n+    public void testPodToRestartFalseWhenCustomCertAnnotationsHaveMatchingThumbprints(VertxTestContext context) {\n         Checkpoint async = context.checkpoint();\n-        kao.createOrUpdate(new Reconciliation(\"test-trigger\", Kafka.RESOURCE_KIND, namespace, clusterName), kafka).setHandler(res -> {\n-            assertThat(res.succeeded(), is(true));\n-\n-            assertThat(reconcileStsCaptor.getAllValues().size(), is(1));\n-\n-            StatefulSet reconcileSts = reconcileStsCaptor.getValue();\n-            assertThat(reconcileSts.getSpec().getTemplate().getMetadata().getAnnotations().getOrDefault(KafkaCluster.ANNO_STRIMZI_CUSTOM_CERT_THUMBPRINT_TLS_LISTENER, \"\"), is(getTlsThumbprint()));\n-            assertThat(reconcileSts.getSpec().getTemplate().getMetadata().getAnnotations().getOrDefault(KafkaCluster.ANNO_STRIMZI_CUSTOM_CERT_THUMBPRINT_EXTERNAL_LISTENER, \"\"), is(getExternalThumbprint()));\n-\n-            assertThat(isPodToRestartFunctionCaptor.getAllValues().size(), is(1));\n-\n-            Function<Pod, String> isPodToRestart = isPodToRestartFunctionCaptor.getValue();\n-            assertThat(isPodToRestart.apply(getPod(reconcileSts)), is(nullValue()));\n-\n-            async.flag();\n-        });\n+        operator.createOrUpdate(new Reconciliation(\"test-trigger\", Kafka.RESOURCE_KIND, namespace, clusterName), kafka)\n+            .setHandler(context.succeeding(v -> context.verify(() -> {\n+                assertThat(reconcileStsCaptor.getAllValues(), hasSize(1));\n+\n+                StatefulSet reconcileSts = reconcileStsCaptor.getValue();\n+                assertThat(reconcileSts.getSpec().getTemplate().getMetadata().getAnnotations(),\n+                        hasEntry(KafkaCluster.ANNO_STRIMZI_CUSTOM_CERT_THUMBPRINT_TLS_LISTENER, getTlsThumbprint()));\n+                assertThat(reconcileSts.getSpec().getTemplate().getMetadata().getAnnotations(),\n+                        hasEntry(KafkaCluster.ANNO_STRIMZI_CUSTOM_CERT_THUMBPRINT_EXTERNAL_LISTENER, getExternalThumbprint()));\n+\n+                assertThat(isPodToRestartFunctionCaptor.getAllValues(), hasSize(1));\n+                Function<Pod, String> isPodToRestart = isPodToRestartFunctionCaptor.getValue();\n+                assertThat(isPodToRestart.apply(getPod(reconcileSts)), is(nullValue()));\n+\n+                async.flag();\n+            })));\n     }\n \n-    @Test\n-    public void testWithChangedTlsCertificate(VertxTestContext context) throws InterruptedException {\n-        Kafka kafka = getKafkaCrd();\n-        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(false);\n-        KafkaCluster kafkaCluster = KafkaCluster.fromCrd(kafka, VERSIONS, null);\n-\n-        // Mock the Kafka Operator\n-        CrdOperator mockKafkaOps = supplier.kafkaOperator;\n-        when(mockKafkaOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(getKafkaCrd()));\n-        when(mockKafkaOps.updateStatusAsync(any())).thenReturn(Future.succeededFuture());\n-\n-        // Mock the KafkaSetOperator\n-        KafkaSetOperator mockKafkaSetOps = supplier.kafkaSetOperations;\n-        when(mockKafkaSetOps.getAsync(eq(namespace), eq(KafkaCluster.kafkaClusterName(clusterName)))).thenReturn(Future.succeededFuture(kafkaCluster.generateStatefulSet(false, null, null)));\n-\n-        ArgumentCaptor<StatefulSet> reconcileStsCaptor = ArgumentCaptor.forClass(StatefulSet.class);\n-        when(mockKafkaSetOps.reconcile(eq(namespace), eq(KafkaCluster.kafkaClusterName(clusterName)), reconcileStsCaptor.capture())).then(invocation -> {\n-            return Future.succeededFuture(ReconcileResult.patched(invocation.getArgument(2)));\n-        });\n-\n-        ArgumentCaptor<StatefulSet> maybeRollingUpdateStsCaptor = ArgumentCaptor.forClass(StatefulSet.class);\n-        ArgumentCaptor<Function<Pod, String>> isPodToRestartFunctionCaptor = ArgumentCaptor.forClass(Function.class);\n-        when(mockKafkaSetOps.maybeRollingUpdate(maybeRollingUpdateStsCaptor.capture(), isPodToRestartFunctionCaptor.capture())).thenReturn(Future.succeededFuture());\n-\n-        // Mock the ConfigMapOperator\n-        ConfigMapOperator mockCmOps = supplier.configMapOperations;\n-        when(mockCmOps.get(eq(namespace), eq(clusterName))).thenReturn(kafkaCluster.generateMetricsAndLogConfigMap(null));\n-\n-        // Mock the SecretOperator\n-        SecretOperator mockSecretOps = supplier.secretOperations;\n-        when(mockSecretOps.getAsync(eq(namespace), eq(\"my-tls-secret\"))).thenReturn(Future.succeededFuture(getTlsSecret()));\n-        when(mockSecretOps.getAsync(eq(namespace), eq(\"my-external-secret\"))).thenReturn(Future.succeededFuture(getExternalSecret()));\n-        when(mockSecretOps.reconcile(any(), any(), any())).then(invocation -> {\n-            return Future.succeededFuture(ReconcileResult.created(invocation.getArgument(2)));\n-        });\n-\n-        MockKafkaAssemblyOperator kao = new MockKafkaAssemblyOperator(vertx, new PlatformFeaturesAvailability(false, kubernetesVersion),\n-                certManager,\n-                passwordGenerator,\n-                supplier,\n-                config);\n+//<<<<<<<HEAD", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f3992dedb2e5800e5d0777b3380e106d7813068"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NDE4Mg==", "bodyText": "Woops! Deleted", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2780#discussion_r402854182", "createdAt": "2020-04-03T08:55:38Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorCustomCertTest.java", "diffHunk": "@@ -153,197 +231,207 @@ public Pod getPod(StatefulSet sts) {\n     }\n \n     @Test\n-    public void testWithUnchangedCertificates(VertxTestContext context) throws InterruptedException {\n-        Kafka kafka = getKafkaCrd();\n-        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(false);\n-        KafkaCluster kafkaCluster = KafkaCluster.fromCrd(kafka, VERSIONS, null);\n-\n-        // Mock the Kafka Operator\n-        CrdOperator mockKafkaOps = supplier.kafkaOperator;\n-        when(mockKafkaOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(getKafkaCrd()));\n-        when(mockKafkaOps.updateStatusAsync(any())).thenReturn(Future.succeededFuture());\n-\n-        // Mock the KafkaSetOperator\n-        KafkaSetOperator mockKafkaSetOps = supplier.kafkaSetOperations;\n-        when(mockKafkaSetOps.getAsync(eq(namespace), eq(KafkaCluster.kafkaClusterName(clusterName)))).thenReturn(Future.succeededFuture(kafkaCluster.generateStatefulSet(false, null, null)));\n-\n-        ArgumentCaptor<StatefulSet> reconcileStsCaptor = ArgumentCaptor.forClass(StatefulSet.class);\n-        when(mockKafkaSetOps.reconcile(eq(namespace), eq(KafkaCluster.kafkaClusterName(clusterName)), reconcileStsCaptor.capture())).then(invocation -> {\n-            return Future.succeededFuture(ReconcileResult.patched(invocation.getArgument(2)));\n-        });\n-\n-        ArgumentCaptor<StatefulSet> maybeRollingUpdateStsCaptor = ArgumentCaptor.forClass(StatefulSet.class);\n-        ArgumentCaptor<Function<Pod, String>> isPodToRestartFunctionCaptor = ArgumentCaptor.forClass(Function.class);\n-        when(mockKafkaSetOps.maybeRollingUpdate(maybeRollingUpdateStsCaptor.capture(), isPodToRestartFunctionCaptor.capture())).thenReturn(Future.succeededFuture());\n-\n-        // Mock the ConfigMapOperator\n-        ConfigMapOperator mockCmOps = supplier.configMapOperations;\n-        when(mockCmOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(kafkaCluster.generateMetricsAndLogConfigMap(null)));\n-\n-        // Mock the SecretOperator\n-        SecretOperator mockSecretOps = supplier.secretOperations;\n-        when(mockSecretOps.getAsync(eq(namespace), eq(\"my-tls-secret\"))).thenReturn(Future.succeededFuture(getTlsSecret()));\n-        when(mockSecretOps.getAsync(eq(namespace), eq(\"my-external-secret\"))).thenReturn(Future.succeededFuture(getExternalSecret()));\n-        when(mockSecretOps.reconcile(any(), any(), any())).then(invocation -> {\n-            return Future.succeededFuture(ReconcileResult.created(invocation.getArgument(2)));\n-        });\n-\n-        MockKafkaAssemblyOperator kao = new MockKafkaAssemblyOperator(vertx, new PlatformFeaturesAvailability(false, kubernetesVersion),\n-                certManager,\n-                passwordGenerator,\n-                supplier,\n-                config);\n-\n+    public void testPodToRestartFalseWhenCustomCertAnnotationsHaveMatchingThumbprints(VertxTestContext context) {\n         Checkpoint async = context.checkpoint();\n-        kao.createOrUpdate(new Reconciliation(\"test-trigger\", Kafka.RESOURCE_KIND, namespace, clusterName), kafka).setHandler(res -> {\n-            assertThat(res.succeeded(), is(true));\n-\n-            assertThat(reconcileStsCaptor.getAllValues().size(), is(1));\n-\n-            StatefulSet reconcileSts = reconcileStsCaptor.getValue();\n-            assertThat(reconcileSts.getSpec().getTemplate().getMetadata().getAnnotations().getOrDefault(KafkaCluster.ANNO_STRIMZI_CUSTOM_CERT_THUMBPRINT_TLS_LISTENER, \"\"), is(getTlsThumbprint()));\n-            assertThat(reconcileSts.getSpec().getTemplate().getMetadata().getAnnotations().getOrDefault(KafkaCluster.ANNO_STRIMZI_CUSTOM_CERT_THUMBPRINT_EXTERNAL_LISTENER, \"\"), is(getExternalThumbprint()));\n-\n-            assertThat(isPodToRestartFunctionCaptor.getAllValues().size(), is(1));\n-\n-            Function<Pod, String> isPodToRestart = isPodToRestartFunctionCaptor.getValue();\n-            assertThat(isPodToRestart.apply(getPod(reconcileSts)), is(nullValue()));\n-\n-            async.flag();\n-        });\n+        operator.createOrUpdate(new Reconciliation(\"test-trigger\", Kafka.RESOURCE_KIND, namespace, clusterName), kafka)\n+            .setHandler(context.succeeding(v -> context.verify(() -> {\n+                assertThat(reconcileStsCaptor.getAllValues(), hasSize(1));\n+\n+                StatefulSet reconcileSts = reconcileStsCaptor.getValue();\n+                assertThat(reconcileSts.getSpec().getTemplate().getMetadata().getAnnotations(),\n+                        hasEntry(KafkaCluster.ANNO_STRIMZI_CUSTOM_CERT_THUMBPRINT_TLS_LISTENER, getTlsThumbprint()));\n+                assertThat(reconcileSts.getSpec().getTemplate().getMetadata().getAnnotations(),\n+                        hasEntry(KafkaCluster.ANNO_STRIMZI_CUSTOM_CERT_THUMBPRINT_EXTERNAL_LISTENER, getExternalThumbprint()));\n+\n+                assertThat(isPodToRestartFunctionCaptor.getAllValues(), hasSize(1));\n+                Function<Pod, String> isPodToRestart = isPodToRestartFunctionCaptor.getValue();\n+                assertThat(isPodToRestart.apply(getPod(reconcileSts)), is(nullValue()));\n+\n+                async.flag();\n+            })));\n     }\n \n-    @Test\n-    public void testWithChangedTlsCertificate(VertxTestContext context) throws InterruptedException {\n-        Kafka kafka = getKafkaCrd();\n-        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(false);\n-        KafkaCluster kafkaCluster = KafkaCluster.fromCrd(kafka, VERSIONS, null);\n-\n-        // Mock the Kafka Operator\n-        CrdOperator mockKafkaOps = supplier.kafkaOperator;\n-        when(mockKafkaOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(getKafkaCrd()));\n-        when(mockKafkaOps.updateStatusAsync(any())).thenReturn(Future.succeededFuture());\n-\n-        // Mock the KafkaSetOperator\n-        KafkaSetOperator mockKafkaSetOps = supplier.kafkaSetOperations;\n-        when(mockKafkaSetOps.getAsync(eq(namespace), eq(KafkaCluster.kafkaClusterName(clusterName)))).thenReturn(Future.succeededFuture(kafkaCluster.generateStatefulSet(false, null, null)));\n-\n-        ArgumentCaptor<StatefulSet> reconcileStsCaptor = ArgumentCaptor.forClass(StatefulSet.class);\n-        when(mockKafkaSetOps.reconcile(eq(namespace), eq(KafkaCluster.kafkaClusterName(clusterName)), reconcileStsCaptor.capture())).then(invocation -> {\n-            return Future.succeededFuture(ReconcileResult.patched(invocation.getArgument(2)));\n-        });\n-\n-        ArgumentCaptor<StatefulSet> maybeRollingUpdateStsCaptor = ArgumentCaptor.forClass(StatefulSet.class);\n-        ArgumentCaptor<Function<Pod, String>> isPodToRestartFunctionCaptor = ArgumentCaptor.forClass(Function.class);\n-        when(mockKafkaSetOps.maybeRollingUpdate(maybeRollingUpdateStsCaptor.capture(), isPodToRestartFunctionCaptor.capture())).thenReturn(Future.succeededFuture());\n-\n-        // Mock the ConfigMapOperator\n-        ConfigMapOperator mockCmOps = supplier.configMapOperations;\n-        when(mockCmOps.get(eq(namespace), eq(clusterName))).thenReturn(kafkaCluster.generateMetricsAndLogConfigMap(null));\n-\n-        // Mock the SecretOperator\n-        SecretOperator mockSecretOps = supplier.secretOperations;\n-        when(mockSecretOps.getAsync(eq(namespace), eq(\"my-tls-secret\"))).thenReturn(Future.succeededFuture(getTlsSecret()));\n-        when(mockSecretOps.getAsync(eq(namespace), eq(\"my-external-secret\"))).thenReturn(Future.succeededFuture(getExternalSecret()));\n-        when(mockSecretOps.reconcile(any(), any(), any())).then(invocation -> {\n-            return Future.succeededFuture(ReconcileResult.created(invocation.getArgument(2)));\n-        });\n-\n-        MockKafkaAssemblyOperator kao = new MockKafkaAssemblyOperator(vertx, new PlatformFeaturesAvailability(false, kubernetesVersion),\n-                certManager,\n-                passwordGenerator,\n-                supplier,\n-                config);\n+//<<<<<<<HEAD", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1MDIyMQ=="}, "originalCommit": {"oid": "6f3992dedb2e5800e5d0777b3380e106d7813068"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NzIxNDQyOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorMockTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMzoxOTo0MVrOF__2jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMzoxOTo0MVrOF__2jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1MDc2Nw==", "bodyText": "In #2737 I tended to use before and after which seemed to be used most often as method names. I do not have strong preference, but we should try to use the same everywhere.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2780#discussion_r402650767", "createdAt": "2020-04-02T23:19:41Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorMockTest.java", "diffHunk": "@@ -195,19 +204,35 @@ public void setFields(KafkaAssemblyOperatorMockTest.Params params) {\n         this.kafkaStorage = params.kafkaStorage;\n \n         this.resources = params.resources;\n-        this.before();\n     }\n \n-    private Vertx vertx;\n     private Kafka cluster;\n \n-    public void before() {\n-        this.cluster = new KafkaBuilder()\n-                .withMetadata(new ObjectMetaBuilder()\n-                        .withName(CLUSTER_NAME)\n-                        .withNamespace(NAMESPACE)\n-                        .withLabels(TestUtils.map(\"foo\", \"bar\"))\n-                        .build())\n+    @BeforeAll\n+    static void setup() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f3992dedb2e5800e5d0777b3380e106d7813068"}, "originalPosition": 141}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 398, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}