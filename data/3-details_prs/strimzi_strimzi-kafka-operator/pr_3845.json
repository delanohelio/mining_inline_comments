{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2NjExMDcz", "number": 3845, "title": "feat: Namespace RBAC scope deployment option", "bodyText": "Type of change\n\nEnhancement / new feature\n\nDescription\nAdd role permissions to the cluster operator\nthis allows it to manage the role resources\nIntroduce a new envar STRIMZI_RBAC_SCOPE to use roles wherever possible\ninstead of ClusterRoles\nAddresses #3826\nChecklist\nPlease go through this checklist and make sure all applicable tasks have been done\n\n Write tests\n Make sure all tests pass\n Update documentation\n Check RBAC rights for Kubernetes / OpenShift roles\n Try your changes from Pod inside your Kubernetes and OpenShift cluster, not just locally\n Reference relevant issue(s) and close them after merging\n Update CHANGELOG.md\n Supply screenshots for visual changes, such as Grafana dashboards", "createdAt": "2020-10-20T09:01:16Z", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845", "merged": true, "mergeCommit": {"oid": "c4cecd805d3c52429edc70d07837c9db9ee699a5"}, "closed": true, "closedAt": "2021-01-06T14:50:42Z", "author": {"login": "samuel-hawker"}, "timelineItems": {"totalCount": 43, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdUXJvzgBqjM4OTgxNjk2NjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdtb5JYgBqjQxNzQyNjM4OTE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ef849c8ab7a3f5a41c4f7a3a5e8a773b22193df1", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/ef849c8ab7a3f5a41c4f7a3a5e8a773b22193df1", "committedDate": "2020-10-20T08:56:50Z", "message": "feat: Better method names\n\nRename generators to be less confusing\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}, "afterCommit": {"oid": "bca43b2fe62dea6d39e2d2f1670e84a0e6af15a2", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/bca43b2fe62dea6d39e2d2f1670e84a0e6af15a2", "committedDate": "2020-10-20T11:33:57Z", "message": "feat: Better method names\n\nRename generators to be less confusing\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "936e12ede96a7920eb8b53707675c8e26254e78d", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/936e12ede96a7920eb8b53707675c8e26254e78d", "committedDate": "2020-10-21T13:39:47Z", "message": "feat: System test cleanup\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}, "afterCommit": {"oid": "2ab041ca4f060a4870d92ed3a6a25bb54af9b958", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/2ab041ca4f060a4870d92ed3a6a25bb54af9b958", "committedDate": "2020-10-21T15:52:42Z", "message": "feat: System test cleanup\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0NzYxMjc3", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#pullrequestreview-514761277", "createdAt": "2020-10-22T14:02:04Z", "commit": {"oid": "6fca2241893149bfa589cba849fbe6d10a030592"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNDowMjowNVrOHmjWTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNDoxMDo1NFrOHmjxPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4NzA4NA==", "bodyText": "Is it really a boolean or should it be role_mode being cluster or namespace for now, but leaving the door open to some other alternative in future?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r510187084", "createdAt": "2020-10-22T14:02:05Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/ClusterOperatorConfig.java", "diffHunk": "@@ -36,10 +36,17 @@\n     public static final String STRIMZI_NAMESPACE = \"STRIMZI_NAMESPACE\";\n     public static final String STRIMZI_FULL_RECONCILIATION_INTERVAL_MS = \"STRIMZI_FULL_RECONCILIATION_INTERVAL_MS\";\n     public static final String STRIMZI_OPERATION_TIMEOUT_MS = \"STRIMZI_OPERATION_TIMEOUT_MS\";\n-    public static final String STRIMZI_CREATE_CLUSTER_ROLES = \"STRIMZI_CREATE_CLUSTER_ROLES\";\n     public static final String STRIMZI_IMAGE_PULL_POLICY = \"STRIMZI_IMAGE_PULL_POLICY\";\n     public static final String STRIMZI_IMAGE_PULL_SECRETS = \"STRIMZI_IMAGE_PULL_SECRETS\";\n \n+    // Feature Flags\n+    public static final String STRIMZI_ROLES_ONLY = \"STRIMZI_ROLES_ONLY\";\n+    public static final boolean DEFAULT_STRIMZI_ROLES_ONLY = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fca2241893149bfa589cba849fbe6d10a030592"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4ODQ2MA==", "bodyText": "getOrDefault?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r510188460", "createdAt": "2020-10-22T14:03:50Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/ClusterOperatorConfig.java", "diffHunk": "@@ -122,14 +131,15 @@ private static void warningsForRemovedEndVars(Map<String, String> map) {\n      * @return  Cluster Operator configuration instance\n      */\n     public static ClusterOperatorConfig fromMap(Map<String, String> map, KafkaVersion.Lookup lookup) {\n-        Set<String> namespaces = parseNamespaceList(map.get(ClusterOperatorConfig.STRIMZI_NAMESPACE));\n-        long reconciliationInterval = parseReconciliationInerval(map.get(ClusterOperatorConfig.STRIMZI_FULL_RECONCILIATION_INTERVAL_MS));\n-        long operationTimeout = parseOperationTimeout(map.get(ClusterOperatorConfig.STRIMZI_OPERATION_TIMEOUT_MS));\n-        boolean createClusterRoles = parseCreateClusterRoles(map.get(ClusterOperatorConfig.STRIMZI_CREATE_CLUSTER_ROLES));\n-        ImagePullPolicy imagePullPolicy = parseImagePullPolicy(map.get(ClusterOperatorConfig.STRIMZI_IMAGE_PULL_POLICY));\n-        List<LocalObjectReference> imagePullSecrets = parseImagePullSecrets(map.get(ClusterOperatorConfig.STRIMZI_IMAGE_PULL_SECRETS));\n-        return new ClusterOperatorConfig(namespaces, reconciliationInterval, operationTimeout, createClusterRoles, lookup, imagePullPolicy, imagePullSecrets);\n-\n+        Set<String> namespaces = parseNamespaceList(map.get(STRIMZI_NAMESPACE));\n+        long reconciliationInterval = parseReconciliationInerval(map.get(STRIMZI_FULL_RECONCILIATION_INTERVAL_MS));\n+        long operationTimeout = parseOperationTimeout(map.get(STRIMZI_OPERATION_TIMEOUT_MS));\n+        boolean createClusterRoles = parseCreateClusterRoles(map.get(STRIMZI_CREATE_CLUSTER_ROLES));\n+        ImagePullPolicy imagePullPolicy = parseImagePullPolicy(map.get(STRIMZI_IMAGE_PULL_POLICY));\n+        List<LocalObjectReference> imagePullSecrets = parseImagePullSecrets(map.get(STRIMZI_IMAGE_PULL_SECRETS));\n+        boolean rolesOnly = parseRolesOnly(map.get(STRIMZI_ROLES_ONLY));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fca2241893149bfa589cba849fbe6d10a030592"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4ODYwOQ==", "bodyText": "could we fix the typo while we're here?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r510188609", "createdAt": "2020-10-22T14:04:03Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/ClusterOperatorConfig.java", "diffHunk": "@@ -122,14 +131,15 @@ private static void warningsForRemovedEndVars(Map<String, String> map) {\n      * @return  Cluster Operator configuration instance\n      */\n     public static ClusterOperatorConfig fromMap(Map<String, String> map, KafkaVersion.Lookup lookup) {\n-        Set<String> namespaces = parseNamespaceList(map.get(ClusterOperatorConfig.STRIMZI_NAMESPACE));\n-        long reconciliationInterval = parseReconciliationInerval(map.get(ClusterOperatorConfig.STRIMZI_FULL_RECONCILIATION_INTERVAL_MS));\n-        long operationTimeout = parseOperationTimeout(map.get(ClusterOperatorConfig.STRIMZI_OPERATION_TIMEOUT_MS));\n-        boolean createClusterRoles = parseCreateClusterRoles(map.get(ClusterOperatorConfig.STRIMZI_CREATE_CLUSTER_ROLES));\n-        ImagePullPolicy imagePullPolicy = parseImagePullPolicy(map.get(ClusterOperatorConfig.STRIMZI_IMAGE_PULL_POLICY));\n-        List<LocalObjectReference> imagePullSecrets = parseImagePullSecrets(map.get(ClusterOperatorConfig.STRIMZI_IMAGE_PULL_SECRETS));\n-        return new ClusterOperatorConfig(namespaces, reconciliationInterval, operationTimeout, createClusterRoles, lookup, imagePullPolicy, imagePullSecrets);\n-\n+        Set<String> namespaces = parseNamespaceList(map.get(STRIMZI_NAMESPACE));\n+        long reconciliationInterval = parseReconciliationInerval(map.get(STRIMZI_FULL_RECONCILIATION_INTERVAL_MS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fca2241893149bfa589cba849fbe6d10a030592"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4OTI1Nw==", "bodyText": "getServiceAccountRole()?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r510189257", "createdAt": "2020-10-22T14:04:57Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -656,6 +659,13 @@ protected String getServiceAccountName() {\n         return null;\n     }\n \n+    /**\n+     * @return the name of the role used by the service account for the deployed cluster for Kubernetes API operations.\n+     */\n+    protected String getRoleName() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fca2241893149bfa589cba849fbe6d10a030592"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE5MTY4OQ==", "bodyText": "Presumably we only need this in role (not cluster role) mode? If so, we should say so in the comment.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r510191689", "createdAt": "2020-10-22T14:08:04Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/resources/cluster-roles/020-ClusterRole-strimzi-cluster-operator-role.yaml", "diffHunk": "@@ -19,6 +19,8 @@ rules:\n   - apiGroups:\n       - \"rbac.authorization.k8s.io\"\n     resources:\n+      # The cluster operator needs to access and manage roles to grant the entity operator permissions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fca2241893149bfa589cba849fbe6d10a030592"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE5Mzk4Mw==", "bodyText": "Probably we should validate that the value is either true or false and error if it's anything else.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r510193983", "createdAt": "2020-10-22T14:10:54Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/ClusterOperatorConfig.java", "diffHunk": "@@ -181,6 +191,16 @@ private static boolean parseCreateClusterRoles(String createClusterRolesEnvVar)\n         return createClusterRoles;\n     }\n \n+    private static boolean parseRolesOnly(String rolesOnlyEnvVar) {\n+        boolean rolesOnly = DEFAULT_STRIMZI_ROLES_ONLY;\n+\n+        if (rolesOnlyEnvVar != null) {\n+            rolesOnly = Boolean.parseBoolean(rolesOnlyEnvVar);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fca2241893149bfa589cba849fbe6d10a030592"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMTMzNjgy", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#pullrequestreview-521133682", "createdAt": "2020-10-31T11:45:30Z", "commit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQxMTo0NTozMVrOHrm74Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQxMTo0NTozMVrOHrm74Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ4ODczNw==", "bodyText": "shouldn't be there strimzi_permissions_mode: namespace ?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515488737", "createdAt": "2020-10-31T11:45:31Z", "author": {"login": "Frawless"}, "path": ".azure/roles-only-acceptance-pipeline.yaml", "diffHunk": "@@ -0,0 +1,21 @@\n+# Triggers\n+# This pipeline will be triggered manually for a release or by github comment\n+trigger: none\n+pr:\n+  autoCancel: false\n+  branches:\n+    include:\n+      - '*'\n+\n+jobs:\n+  - template: 'templates/system_test_general.yaml'\n+    parameters:\n+      name: 'acceptance_roles_only'\n+      display_name: 'acceptance-roles-only'\n+      test_case: '.*ST'\n+      groups: 'acceptance'\n+      cluster_operator_install_type: 'bundle'\n+      stimzi_roles_only: 'true'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMTMzODc1", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#pullrequestreview-521133875", "createdAt": "2020-10-31T11:48:16Z", "commit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQxMTo0ODoxNlrOHrm8ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQxMTo0ODoxNlrOHrm8ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ4ODkzMQ==", "bodyText": "We should also include here the tests which are specific for this feature which means add acceptance tag to RolesOnlyOperatorST or create a specific tag for this class and change groups in yaml like groups: 'acceptance,rolesOnly'.  Guess a little bit better solution is to extend acceptance tests :)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515488931", "createdAt": "2020-10-31T11:48:16Z", "author": {"login": "Frawless"}, "path": ".azure/roles-only-acceptance-pipeline.yaml", "diffHunk": "@@ -0,0 +1,21 @@\n+# Triggers\n+# This pipeline will be triggered manually for a release or by github comment\n+trigger: none\n+pr:\n+  autoCancel: false\n+  branches:\n+    include:\n+      - '*'\n+\n+jobs:\n+  - template: 'templates/system_test_general.yaml'\n+    parameters:\n+      name: 'acceptance_roles_only'\n+      display_name: 'acceptance-roles-only'\n+      test_case: '.*ST'\n+      groups: 'acceptance'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMTQ3MjA5", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#pullrequestreview-521147209", "createdAt": "2020-10-31T15:23:58Z", "commit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "state": "COMMENTED", "comments": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQxNToyMzo1OFrOHroFsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQxNjowNTo1N1rOHroUsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwNzYzNA==", "bodyText": "So how does this work? Will it be triggered by /azp run acceptance_roles_only? Meaning it will be separate from the regular acceptance and not part of regression?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515507634", "createdAt": "2020-10-31T15:23:58Z", "author": {"login": "scholzj"}, "path": ".azure/roles-only-acceptance-pipeline.yaml", "diffHunk": "@@ -0,0 +1,21 @@\n+# Triggers\n+# This pipeline will be triggered manually for a release or by github comment\n+trigger: none\n+pr:\n+  autoCancel: false\n+  branches:\n+    include:\n+      - '*'\n+\n+jobs:\n+  - template: 'templates/system_test_general.yaml'\n+    parameters:\n+      name: 'acceptance_roles_only'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwNzc0OA==", "bodyText": "Should this print permissionsMode= instead of rolesOnly=? Seems more logical given the parameter name and the values.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515507748", "createdAt": "2020-10-31T15:24:53Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/ClusterOperatorConfig.java", "diffHunk": "@@ -313,6 +369,7 @@ public String toString() {\n                 \",versions=\" + versions +\n                 \",imagePullPolicy=\" + imagePullPolicy +\n                 \",imagePullSecrets=\" + imagePullSecrets +\n+                \",rolesOnly=\" + permissionsMode +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwNzkxNw==", "bodyText": "I wonder if this should have some better name. There might be different and non-mutually exclusive permission modes (I mentioned network policies in the past). So I'm not sure this is clear enough and future proof enough.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515507917", "createdAt": "2020-10-31T15:26:47Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/ClusterOperatorConfig.java", "diffHunk": "@@ -67,26 +71,29 @@\n     private final KafkaVersion.Lookup versions;\n     private final ImagePullPolicy imagePullPolicy;\n     private final List<LocalObjectReference> imagePullSecrets;\n+    private final PermissionsMode permissionsMode;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODE5Mw==", "bodyText": "I do not think this makes sense with the getServiceAccountRoleName returning null because it creates invalid resource. Maybe getServiceAccountRoleName should be abstract instead?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515508193", "createdAt": "2020-10-31T15:29:43Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -1305,6 +1315,18 @@ public ServiceAccount generateServiceAccount() {\n             .build();\n     }\n \n+    public Role generateRole(List<PolicyRule> rules) {\n+        return new RoleBuilder()\n+                .withNewMetadata()\n+                    .withName(getServiceAccountRoleName())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODI4OA==", "bodyText": "I'm not sure I understand the method and its name ... there is no ServiceAccountRole name, so this is confusing because it is not cleare what does it name. Since it is used in the method below, should it be getRoleName?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515508288", "createdAt": "2020-10-31T15:30:46Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -656,6 +659,13 @@ protected String getServiceAccountName() {\n         return null;\n     }\n \n+    /**\n+     * @return the name of the role used by the service account for the deployed cluster for Kubernetes API operations.\n+     */\n+    protected String getServiceAccountRoleName() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODM5Mg==", "bodyText": "This seems to be used only from the method above. So why not return there directly entityOperatorRoleName(cluster)?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515508392", "createdAt": "2020-10-31T15:32:02Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityOperator.java", "diffHunk": "@@ -348,6 +352,48 @@ public ServiceAccount generateServiceAccount() {\n         return super.generateServiceAccount();\n     }\n \n+    /**\n+     * Get the name of the Entity Operator Role given the name of the {@code cluster}.\n+     * @param cluster The cluster name\n+     * @return The name of the EO role.\n+     */\n+    public static String entityOperatorRoleName(String cluster) {\n+        return entityOperatorName(cluster);\n+    }\n+\n+    @Override\n+    protected String getServiceAccountRoleName() {\n+        return getRoleName(cluster);\n+    }\n+\n+    protected static String getRoleName(String cluster) {\n+        return entityOperatorRoleName(cluster);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODQ4Mg==", "bodyText": "I don't like this. This hardcodes the RBAC files into the code. So we now have it both in the YAMLs ad in the code and need to update it. I think you need to generate this from the YAMLs or something to make sure this is done only in one place.\nOr assuming the installation will anyway be non-trivial, you should expect the Role objects to already exist from the installation.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515508482", "createdAt": "2020-10-31T15:33:30Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityOperator.java", "diffHunk": "@@ -348,6 +352,48 @@ public ServiceAccount generateServiceAccount() {\n         return super.generateServiceAccount();\n     }\n \n+    /**\n+     * Get the name of the Entity Operator Role given the name of the {@code cluster}.\n+     * @param cluster The cluster name\n+     * @return The name of the EO role.\n+     */\n+    public static String entityOperatorRoleName(String cluster) {\n+        return entityOperatorName(cluster);\n+    }\n+\n+    @Override\n+    protected String getServiceAccountRoleName() {\n+        return getRoleName(cluster);\n+    }\n+\n+    protected static String getRoleName(String cluster) {\n+        return entityOperatorRoleName(cluster);\n+    }\n+\n+    public Role generateRole() {\n+        List<PolicyRule> rules = new ArrayList<>();\n+\n+        rules.add(new PolicyRuleBuilder()\n+                .addToResources(\"secrets\")\n+                .addToVerbs(\"create\", \"delete\", \"get\", \"list\", \"patch\", \"update\")\n+                .addToApiGroups(\"\")\n+                .build());\n+\n+        rules.add(new PolicyRuleBuilder()\n+                .addToResources(\"events\")\n+                .addToVerbs(\"create\")\n+                .addToApiGroups(\"\")\n+                .build());\n+\n+        rules.add(new PolicyRuleBuilder()\n+                .addToResources(\"kafkatopics\", \"kafkatopics/status\", \"kafkausers\", \"kafkausers/status\")\n+                .addToVerbs(\"create\", \"delete\", \"get\", \"list\", \"patch\", \"update\", \"watch\")\n+                .addToApiGroups(Constants.RESOURCE_GROUP_NAME)\n+                .build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODY5OA==", "bodyText": "Why do we need a different name here from the cluster role?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515508698", "createdAt": "2020-10-31T15:35:36Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityTopicOperator.java", "diffHunk": "@@ -170,13 +170,23 @@ public static String metricAndLogConfigsName(String cluster) {\n \n     /**\n      * Get the name of the TO role binding given the name of the {@code cluster}.\n+     * This binding binds to a ClusterRole, retains old naming convention for backwards compatibility.\n      * @param cluster The cluster name.\n      * @return The name of the role binding.\n      */\n-    public static String roleBindingName(String cluster) {\n+    public static String clusterRoleRoleBindingName(String cluster) {\n         return \"strimzi-\" + cluster + \"-entity-topic-operator\";\n     }\n \n+    /**\n+     * Get the name of the TO role binding given the name of the {@code cluster}.\n+     * @param cluster The cluster name.\n+     * @return The name of the role binding.\n+     */\n+    public static String roleRoleBindingName(String cluster) {\n+        return \"strimzi-\" + cluster + \"-entity-topic-operator-role\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODkyNw==", "bodyText": "You have a single Role for the whole EntityOperator and single service account per EntityOperator. So why do we need to generate the RoleBinding on what is essentially the container level? Shouldn't this be in EntityOperator.java instead?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515508927", "createdAt": "2020-10-31T15:38:35Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityTopicOperator.java", "diffHunk": "@@ -309,6 +319,38 @@ public RoleBinding generateRoleBinding(String namespace, String watchedNamespace\n         return rb;\n     }\n \n+    @Override\n+    protected String getServiceAccountRoleName() {\n+        return EntityOperator.getRoleName(cluster);\n+    }\n+\n+    public RoleBinding generateRoleBindingForRole(String namespace, String watchedNamespace) {\n+        Subject ks = new SubjectBuilder()\n+                .withKind(\"ServiceAccount\")\n+                .withName(EntityOperator.entityOperatorServiceAccountName(cluster))\n+                .withNamespace(namespace)\n+                .build();\n+\n+        RoleRef roleRef = new RoleRefBuilder()\n+                .withName(getServiceAccountRoleName())\n+                .withApiGroup(\"rbac.authorization.k8s.io\")\n+                .withKind(\"Role\")\n+                .build();\n+\n+        RoleBinding rb = new RoleBindingBuilder()\n+                .withNewMetadata()\n+                .withName(roleRoleBindingName(cluster))\n+                .withNamespace(watchedNamespace)\n+                .withOwnerReferences(createOwnerReference())\n+                .withLabels(labels.toMap())\n+                .endMetadata()\n+                .withRoleRef(roleRef)\n+                .withSubjects(singletonList(ks))\n+                .build();\n+\n+        return rb;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwOTA2OA==", "bodyText": "Same as above.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515509068", "createdAt": "2020-10-31T15:39:56Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityUserOperator.java", "diffHunk": "@@ -328,6 +338,39 @@ public RoleBinding generateRoleBinding(String namespace, String watchedNamespace\n         return rb;\n     }\n \n+    @Override\n+    protected String getServiceAccountRoleName() {\n+        return EntityOperator.getRoleName(cluster);\n+    }\n+\n+    public RoleBinding generateRoleBindingForRole(String namespace, String watchedNamespace) {\n+        Subject ks = new SubjectBuilder()\n+                .withKind(\"ServiceAccount\")\n+                .withName(EntityOperator.entityOperatorServiceAccountName(cluster))\n+                .withNamespace(namespace)\n+                .build();\n+\n+        RoleRef roleRef = new RoleRefBuilder()\n+                .withName(getServiceAccountRoleName())\n+                .withApiGroup(\"rbac.authorization.k8s.io\")\n+                .withKind(\"Role\")\n+                .build();\n+\n+\n+        RoleBinding rb = new RoleBindingBuilder()\n+                .withNewMetadata()\n+                .withName(roleRoleBindingName(cluster))\n+                .withNamespace(watchedNamespace)\n+                .withOwnerReferences(createOwnerReference())\n+                .withLabels(labels.toMap())\n+                .endMetadata()\n+                .withRoleRef(roleRef)\n+                .withSubjects(singletonList(ks))\n+                .build();\n+\n+        return rb;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwOTQzMw==", "bodyText": "This seems a bit suspicious to me. The Cluster-wide resources are used in Kafka as well. At least for:\n\nNode port access\nRack awareness\n\nI do not see that handled anywhere.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515509433", "createdAt": "2020-10-31T15:44:18Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -315,9 +322,12 @@ public KafkaAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n                 .compose(state -> state.checkUnsupportedTopicOperator())\n \n                 .compose(state -> state.getEntityOperatorDescription())\n+                .compose(state -> state.entityOperatorRole())\n                 .compose(state -> state.entityOperatorServiceAccount())\n-                .compose(state -> state.entityOperatorTopicOpRoleBinding())\n-                .compose(state -> state.entityOperatorUserOpRoleBinding())\n+                .compose(state -> state.entityOperatorTopicOpRoleRoleBinding())\n+                .compose(state -> state.entityOperatorTopicOpClusterRoleRoleBinding())\n+                .compose(state -> state.entityOperatorUserOpRoleRoleBinding())\n+                .compose(state -> state.entityOperatorUserOpClusterRoleRoleBinding())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwOTc0Nw==", "bodyText": "You defined canUseRoles in this class. Should you then use it here?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515509747", "createdAt": "2020-10-31T15:47:29Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2986,74 +2996,147 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if STRIMZI_PERMISSIONS_MODE is set to use roles and entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (permissionsMode.canUseRoles() && isEntityOperatorDeployed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDEwNw==", "bodyText": "This is confusing. When does the EO need any ClusterRoleBindings? IMHO it is always using only RoleBindings. That also seems to what is done in the previous code.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515510107", "createdAt": "2020-10-31T15:51:24Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2986,74 +2996,147 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if STRIMZI_PERMISSIONS_MODE is set to use roles and entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (permissionsMode.canUseRoles() && isEntityOperatorDeployed()) {\n+                role = entityOperator.generateRole();\n+            } else {\n+                role = null;\n+            }\n+\n+            return withVoid(roleOperations.reconcile(\n+                    namespace,\n+                    EntityOperator.entityOperatorRoleName(name),\n+                    role));\n+        }\n+\n         Future<ReconciliationState> entityOperatorServiceAccount() {\n             return withVoid(serviceAccountOperations.reconcile(namespace,\n                     EntityOperator.entityOperatorServiceAccountName(name),\n-                    eoDeployment != null ? entityOperator.generateServiceAccount() : null));\n+                    isEntityOperatorDeployed() ? entityOperator.generateServiceAccount() : null));\n         }\n \n-        Future<ReconciliationState> entityOperatorTopicOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getTopicOperator() != null) {\n-                String watchedNamespace = namespace;\n+        // Check for is the entity operator will be deployed as part of the reconciliation\n+        // Related resources need to know this to know whether to deploy\n+        private boolean isEntityOperatorDeployed() {\n+            return eoDeployment != null;\n+        }\n \n-                if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n-                        && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n-                    watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n-                }\n+        // Check for if roles can be used for the topic and user operator\n+        // If watched namespace is set to the current namespace Roles can be used\n+        // Note watchedNamespace can't be unset as it defaults to the deployed namespace\n+        public boolean canUseRoles(String watchedNamespace) {\n+            return permissionsMode.canUseRoles() && this.namespace.equals(watchedNamespace);\n+        }\n \n-                return withVoid(roleBindingOperations.reconcile(\n-                        watchedNamespace,\n-                        EntityTopicOperator.roleBindingName(name),\n-                        entityOperator.getTopicOperator().generateRoleBinding(namespace, watchedNamespace)));\n-            } else  {\n-                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.roleBindingName(name), null));\n+        Future<ReconciliationState> entityOperatorTopicOpRoleRoleBinding() {\n+            // Don't deploy Role RoleBinding if not running in roles only mode,\n+            // or if the topic operator is not deployed,\n+            // or if the topic operator needs to watch a different namespace\n+            if (!isEntityOperatorDeployed()\n+                    || entityOperator.getTopicOperator() == null\n+                    || !canUseRoles(entityOperator.getTopicOperator().getWatchedNamespace())) {\n+                log.info(\"entityOperatorTopicOpRoleRoleBinding not required\");\n+                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.roleRoleBindingName(name), null));\n             }\n+\n+            return withVoid(roleBindingOperations.reconcile(\n+                    namespace,\n+                    EntityTopicOperator.roleRoleBindingName(name),\n+                    entityOperator.getTopicOperator().generateRoleBindingForRole(namespace, namespace)));\n         }\n \n-        Future<ReconciliationState> entityOperatorUserOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getUserOperator() != null) {\n-                Future<ReconcileResult<RoleBinding>> ownNamespaceFuture;\n-                Future<ReconcileResult<RoleBinding>> watchedNamespaceFuture;\n+        Future<ReconciliationState> entityOperatorTopicOpClusterRoleRoleBinding() {\n+            // Don't deploy ClusterRole RoleBinding if it can use roles,\n+            // or if the topic operator is not deployed,\n+            // or if the topic operator doesn't need to watch a different namespace\n+            if (!isEntityOperatorDeployed()\n+                    || entityOperator.getTopicOperator() == null\n+                    || canUseRoles(entityOperator.getTopicOperator().getWatchedNamespace())) {\n+                log.info(\"entityOperatorTopicOpClusterRoleBinding not required\");\n+                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.clusterRoleRoleBindingName(name), null));\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDIwNQ==", "bodyText": "Please wrap this into else { ... } to make the code more readable.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515510205", "createdAt": "2020-10-31T15:52:28Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2986,74 +2996,147 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if STRIMZI_PERMISSIONS_MODE is set to use roles and entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (permissionsMode.canUseRoles() && isEntityOperatorDeployed()) {\n+                role = entityOperator.generateRole();\n+            } else {\n+                role = null;\n+            }\n+\n+            return withVoid(roleOperations.reconcile(\n+                    namespace,\n+                    EntityOperator.entityOperatorRoleName(name),\n+                    role));\n+        }\n+\n         Future<ReconciliationState> entityOperatorServiceAccount() {\n             return withVoid(serviceAccountOperations.reconcile(namespace,\n                     EntityOperator.entityOperatorServiceAccountName(name),\n-                    eoDeployment != null ? entityOperator.generateServiceAccount() : null));\n+                    isEntityOperatorDeployed() ? entityOperator.generateServiceAccount() : null));\n         }\n \n-        Future<ReconciliationState> entityOperatorTopicOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getTopicOperator() != null) {\n-                String watchedNamespace = namespace;\n+        // Check for is the entity operator will be deployed as part of the reconciliation\n+        // Related resources need to know this to know whether to deploy\n+        private boolean isEntityOperatorDeployed() {\n+            return eoDeployment != null;\n+        }\n \n-                if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n-                        && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n-                    watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n-                }\n+        // Check for if roles can be used for the topic and user operator\n+        // If watched namespace is set to the current namespace Roles can be used\n+        // Note watchedNamespace can't be unset as it defaults to the deployed namespace\n+        public boolean canUseRoles(String watchedNamespace) {\n+            return permissionsMode.canUseRoles() && this.namespace.equals(watchedNamespace);\n+        }\n \n-                return withVoid(roleBindingOperations.reconcile(\n-                        watchedNamespace,\n-                        EntityTopicOperator.roleBindingName(name),\n-                        entityOperator.getTopicOperator().generateRoleBinding(namespace, watchedNamespace)));\n-            } else  {\n-                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.roleBindingName(name), null));\n+        Future<ReconciliationState> entityOperatorTopicOpRoleRoleBinding() {\n+            // Don't deploy Role RoleBinding if not running in roles only mode,\n+            // or if the topic operator is not deployed,\n+            // or if the topic operator needs to watch a different namespace\n+            if (!isEntityOperatorDeployed()\n+                    || entityOperator.getTopicOperator() == null\n+                    || !canUseRoles(entityOperator.getTopicOperator().getWatchedNamespace())) {\n+                log.info(\"entityOperatorTopicOpRoleRoleBinding not required\");\n+                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.roleRoleBindingName(name), null));\n             }\n+\n+            return withVoid(roleBindingOperations.reconcile(\n+                    namespace,\n+                    EntityTopicOperator.roleRoleBindingName(name),\n+                    entityOperator.getTopicOperator().generateRoleBindingForRole(namespace, namespace)));\n         }\n \n-        Future<ReconciliationState> entityOperatorUserOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getUserOperator() != null) {\n-                Future<ReconcileResult<RoleBinding>> ownNamespaceFuture;\n-                Future<ReconcileResult<RoleBinding>> watchedNamespaceFuture;\n+        Future<ReconciliationState> entityOperatorTopicOpClusterRoleRoleBinding() {\n+            // Don't deploy ClusterRole RoleBinding if it can use roles,\n+            // or if the topic operator is not deployed,\n+            // or if the topic operator doesn't need to watch a different namespace\n+            if (!isEntityOperatorDeployed()\n+                    || entityOperator.getTopicOperator() == null\n+                    || canUseRoles(entityOperator.getTopicOperator().getWatchedNamespace())) {\n+                log.info(\"entityOperatorTopicOpClusterRoleBinding not required\");\n+                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.clusterRoleRoleBindingName(name), null));\n+            }\n \n-                String watchedNamespace = namespace;\n+            String watchedNamespace = namespace;\n \n-                if (entityOperator.getUserOperator().getWatchedNamespace() != null\n-                        && !entityOperator.getUserOperator().getWatchedNamespace().isEmpty()) {\n-                    watchedNamespace = entityOperator.getUserOperator().getWatchedNamespace();\n-                }\n+            if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n+                    && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n+                watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n+            }\n \n-                if (!namespace.equals(watchedNamespace)) {\n-                    watchedNamespaceFuture = roleBindingOperations.reconcile(watchedNamespace, EntityUserOperator.roleBindingName(name), entityOperator.getUserOperator().generateRoleBinding(namespace, watchedNamespace));\n-                } else {\n-                    watchedNamespaceFuture = Future.succeededFuture();\n-                }\n+            return withVoid(roleBindingOperations.reconcile(\n+                    watchedNamespace,\n+                    EntityTopicOperator.clusterRoleRoleBindingName(name),\n+                    entityOperator.getTopicOperator().generateRoleBindingForClusterRole(namespace, watchedNamespace)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDM1Mg==", "bodyText": "Are you sure this method follows the same handling of the watched namespace and own namespace as the previous? From the code it does not seem to be the case.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515510352", "createdAt": "2020-10-31T15:53:59Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -2986,74 +2996,147 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if STRIMZI_PERMISSIONS_MODE is set to use roles and entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (permissionsMode.canUseRoles() && isEntityOperatorDeployed()) {\n+                role = entityOperator.generateRole();\n+            } else {\n+                role = null;\n+            }\n+\n+            return withVoid(roleOperations.reconcile(\n+                    namespace,\n+                    EntityOperator.entityOperatorRoleName(name),\n+                    role));\n+        }\n+\n         Future<ReconciliationState> entityOperatorServiceAccount() {\n             return withVoid(serviceAccountOperations.reconcile(namespace,\n                     EntityOperator.entityOperatorServiceAccountName(name),\n-                    eoDeployment != null ? entityOperator.generateServiceAccount() : null));\n+                    isEntityOperatorDeployed() ? entityOperator.generateServiceAccount() : null));\n         }\n \n-        Future<ReconciliationState> entityOperatorTopicOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getTopicOperator() != null) {\n-                String watchedNamespace = namespace;\n+        // Check for is the entity operator will be deployed as part of the reconciliation\n+        // Related resources need to know this to know whether to deploy\n+        private boolean isEntityOperatorDeployed() {\n+            return eoDeployment != null;\n+        }\n \n-                if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n-                        && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n-                    watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n-                }\n+        // Check for if roles can be used for the topic and user operator\n+        // If watched namespace is set to the current namespace Roles can be used\n+        // Note watchedNamespace can't be unset as it defaults to the deployed namespace\n+        public boolean canUseRoles(String watchedNamespace) {\n+            return permissionsMode.canUseRoles() && this.namespace.equals(watchedNamespace);\n+        }\n \n-                return withVoid(roleBindingOperations.reconcile(\n-                        watchedNamespace,\n-                        EntityTopicOperator.roleBindingName(name),\n-                        entityOperator.getTopicOperator().generateRoleBinding(namespace, watchedNamespace)));\n-            } else  {\n-                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.roleBindingName(name), null));\n+        Future<ReconciliationState> entityOperatorTopicOpRoleRoleBinding() {\n+            // Don't deploy Role RoleBinding if not running in roles only mode,\n+            // or if the topic operator is not deployed,\n+            // or if the topic operator needs to watch a different namespace\n+            if (!isEntityOperatorDeployed()\n+                    || entityOperator.getTopicOperator() == null\n+                    || !canUseRoles(entityOperator.getTopicOperator().getWatchedNamespace())) {\n+                log.info(\"entityOperatorTopicOpRoleRoleBinding not required\");\n+                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.roleRoleBindingName(name), null));\n             }\n+\n+            return withVoid(roleBindingOperations.reconcile(\n+                    namespace,\n+                    EntityTopicOperator.roleRoleBindingName(name),\n+                    entityOperator.getTopicOperator().generateRoleBindingForRole(namespace, namespace)));\n         }\n \n-        Future<ReconciliationState> entityOperatorUserOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getUserOperator() != null) {\n-                Future<ReconcileResult<RoleBinding>> ownNamespaceFuture;\n-                Future<ReconcileResult<RoleBinding>> watchedNamespaceFuture;\n+        Future<ReconciliationState> entityOperatorTopicOpClusterRoleRoleBinding() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDU1NQ==", "bodyText": "Again, there are no ClusterRoleBindings here.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515510555", "createdAt": "2020-10-31T15:56:02Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/EntityTopicOperatorTest.java", "diffHunk": "@@ -223,10 +223,32 @@ public void testGetContainers() {\n     }\n \n     @Test\n-    public void testRoleBinding()   {\n-        RoleBinding binding = entityTopicOperator.generateRoleBinding(namespace, toWatchedNamespace);\n+    public void testClusterRoleRoleBindingDefault() {\n+        RoleBinding binding = entityTopicOperator.generateRoleBindingForClusterRole(namespace, toWatchedNamespace);\n \n         assertThat(binding.getSubjects().get(0).getNamespace(), is(namespace));\n         assertThat(binding.getMetadata().getNamespace(), is(toWatchedNamespace));\n     }\n+\n+    @Test\n+    public void testClusterRoleRoleBinding() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDU3NA==", "bodyText": "Same as above.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515510574", "createdAt": "2020-10-31T15:56:12Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/EntityUserOperatorTest.java", "diffHunk": "@@ -286,10 +286,24 @@ public void testEntityUserOperatorEnvVarValidityAndRenewal() {\n     }\n \n     @Test\n-    public void testRoleBinding()   {\n-        RoleBinding binding = entityUserOperator.generateRoleBinding(namespace, uoWatchedNamespace);\n+    public void testClusterRoleRoleBinding()   {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDcxOQ==", "bodyText": "As mentioned in the previous comments. This completely ignores the features using ClusterRoleBindings like rack awareness and node port listeners.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515510719", "createdAt": "2020-10-31T15:57:48Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorPermissionsModeTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.api.model.rbac.RoleBinding;\n+import io.fabric8.kubernetes.api.model.rbac.RoleRef;\n+import io.fabric8.kubernetes.api.model.rbac.RoleRefBuilder;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.certs.CertManager;\n+import io.strimzi.operator.KubernetesVersion;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.EntityOperator;\n+import io.strimzi.operator.cluster.model.KafkaVersion;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.PasswordGenerator;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.operator.MockCertManager;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.RoleBindingOperator;\n+import io.vertx.core.Future;\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.Checkpoint;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+import org.hamcrest.TypeSafeDiagnosingMatcher;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.util.List;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(VertxExtension.class)\n+public class KafkaAssemblyOperatorPermissionsModeTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDgwMQ==", "bodyText": "I do not see this change for the Helm2 chart.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515510801", "createdAt": "2020-10-31T15:58:52Z", "author": {"login": "scholzj"}, "path": "helm-charts/helm3/strimzi-kafka-operator/templates/020-ClusterRole-strimzi-cluster-operator-role.yaml", "diffHunk": "@@ -24,6 +24,9 @@ rules:\n - apiGroups:\n   - \"rbac.authorization.k8s.io\"\n   resources:\n+    # The cluster operator needs to access and manage roles to grant the entity operator permissions\n+    # This is only needed if the STRIMZI_PERMISSIONS_MODE is set to 'namespace', otherwise ClusterRoles are used\n+  - roles", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDk1Mg==", "bodyText": "How does this work within the OLM deployment where the RBAC files are hard coded? I would expect that it makes no sense here.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515510952", "createdAt": "2020-10-31T16:00:07Z", "author": {"login": "scholzj"}, "path": "systemtest/src/main/resources/olm/subscription.yaml", "diffHunk": "@@ -20,4 +20,5 @@ spec:\n         value: \"${STRIMZI_FULL_RECONCILIATION_INTERVAL_MS}\"\n       - name: STRIMZI_OPERATION_TIMEOUT_MS\n         value: \"${STRIMZI_OPERATION_TIMEOUT_MS}\"\n-\n+      - name: STRIMZI_PERMISSIONS_MODE\n+        value: \"${STRIMZI_PERMISSIONS_MODE}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMTA4OQ==", "bodyText": "I guess you will need to also fix the ClusterRoleBindings somewhere? To not install them randomly against missing clusterRoles?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515511089", "createdAt": "2020-10-31T16:01:45Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/AbstractST.java", "diffHunk": "@@ -144,6 +155,48 @@ protected void installClusterOperator(String namespace) throws Exception {\n         installClusterOperator(namespace, Constants.CO_OPERATION_TIMEOUT_DEFAULT);\n     }\n \n+    /**\n+     * Perform application of ServiceAccount, Roles and CRDs needed for proper cluster operator deployment.\n+     * Configuration files are loaded from install/cluster-operator directory.\n+     */\n+    public void applyClusterOperatorInstallFiles(String namespace) {\n+        clusterOperatorConfigs.clear();\n+        Map<File, String> operatorFiles = Arrays.stream(new File(CO_INSTALL_DIR).listFiles()).sorted()\n+                .filter(file ->\n+                        !file.getName().matches(\".*(Binding|Deployment)-.*\"))\n+                .collect(Collectors.toMap(\n+                    file -> file,\n+                    f -> TestUtils.getContent(f, TestUtils::toYamlString),\n+                    (x, y) -> x, LinkedHashMap::new));\n+        for (Map.Entry<File, String> entry : operatorFiles.entrySet()) {\n+            LOGGER.info(\"Applying configuration file: {}\", entry.getKey());\n+            if (Environment.isRolesOnly()) {\n+                switchClusterRolesToRoles(entry.getValue());\n+            }\n+            clusterOperatorConfigs.push(entry.getKey().getPath());\n+            cmdKubeClient().clientWithAdmin().namespace(namespace).apply(entry.getKey().getPath());\n+        }\n+    }\n+\n+    /**\n+     * Replace all references to ClusterRole to Role.\n+     * This includes ClusterRoles themselves as well as RoleBindings that reference them.\n+     */\n+    private void switchClusterRolesToRoles(String fileContents) {\n+        fileContents.replace(\"ClusterRole\", \"Role\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMTQ3NQ==", "bodyText": "I'm not sure I follow the point of this test. It seems to run only when the tests are triggered with isRolesOnly == true, but it doesn't really test anything else what the other tests would not do. So it seems completely useless to me (of course it is possible i miss the point). I think much bigger value would be if:\n\nThis test runs in regular Acceptance pipeline\nIt deploys the CO with the roles only setup\nTests a simple deployment, topic and user creation and sending of messages\n\nThat would be IMHO added value.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r515511475", "createdAt": "2020-10-31T16:05:57Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/operators/RolesOnlyOperatorST.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.operators;\n+\n+import io.strimzi.systemtest.AbstractST;\n+import io.strimzi.systemtest.Environment;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.resources.operator.BundleResource;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Collections;\n+\n+import static io.strimzi.systemtest.Constants.REGRESSION;\n+import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assumptions.assumeTrue;\n+\n+@Tag(REGRESSION)\n+class RolesOnlyOperatorST extends AbstractST {\n+\n+    static final String NAMESPACE = \"roles-only-cluster-test\";\n+    static final String CLUSTER_NAME = \"roles-only-cluster\";\n+\n+    private static final Logger LOGGER = LogManager.getLogger(RolesOnlyOperatorST.class);\n+\n+    @Test\n+    void testRolesOnlyDeploysRoles() {\n+        assumeTrue(Environment.isRolesOnly());\n+        prepareEnvironment();\n+\n+        KafkaResource.kafkaEphemeral(CLUSTER_NAME, 3, 3).done();\n+\n+        // Obviously not right.\n+        // Get advice on how to resolve what this test should do.\n+        assertThat(kubeClient().listClusterRoles(), is(Collections.emptyList()));\n+    }\n+\n+    private void prepareEnvironment() {\n+        prepareEnvForOperator(NAMESPACE);\n+        applyBindings(NAMESPACE);\n+        // 060-Deployment\n+        BundleResource.clusterOperator(NAMESPACE).done();\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7"}, "originalPosition": 50}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6bd8016da67fc76e37171d9d8907411e829468d7", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/6bd8016da67fc76e37171d9d8907411e829468d7", "committedDate": "2020-10-28T14:47:26Z", "message": "fix: System test fixes\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}, "afterCommit": {"oid": "5584b0549304b3f23d39335455e66ebe8b57fa7d", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5584b0549304b3f23d39335455e66ebe8b57fa7d", "committedDate": "2020-12-03T10:34:09Z", "message": "feat: Handle rackawareness and nodeports\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5584b0549304b3f23d39335455e66ebe8b57fa7d", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5584b0549304b3f23d39335455e66ebe8b57fa7d", "committedDate": "2020-12-03T10:34:09Z", "message": "feat: Handle rackawareness and nodeports\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}, "afterCommit": {"oid": "c756be07053209c4c7be35fcea2facf045bd6f23", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c756be07053209c4c7be35fcea2facf045bd6f23", "committedDate": "2020-12-03T11:08:16Z", "message": "feat: Handle rackawareness and nodeports\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3OTA1Mjk1", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#pullrequestreview-547905295", "createdAt": "2020-12-09T07:33:28Z", "commit": {"oid": "2d39360b0f46b9971bbd24b920b5711d26e8b66d"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNzozMzoyOFrOICGStA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODowMzowN1rOICHPzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3MTE1Ng==", "bodyText": "Should it be something lile canUseClusterRoles? It is the cluster scope you are reall limiting, so that will be or will not be available.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r539071156", "createdAt": "2020-12-09T07:33:28Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/ClusterOperatorConfig.java", "diffHunk": "@@ -196,6 +221,37 @@ private static boolean parseCreateClusterRoles(String createClusterRolesEnvVar)\n         return createClusterRoles;\n     }\n \n+    /**\n+     * enum to represent the various permission modes the cluster operator can be set to\n+     *\n+     * CLUSTER is the default and uses ClusterRoles to set permissions\n+     * NAMESPACE allows for the use of Roles where possible instead of ClusterRoles\n+     */\n+    public enum RbacScope {\n+        CLUSTER(),\n+        NAMESPACE();\n+\n+        public boolean canUseRoles() {\n+            return this.equals(RbacScope.NAMESPACE);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d39360b0f46b9971bbd24b920b5711d26e8b66d"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3NjQwMA==", "bodyText": "Do we need to have the builder multiple times in several classes? Can't we just parametrize it and have it once in AbstractCluster or in ModelUtils?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r539076400", "createdAt": "2020-12-09T07:43:44Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityUserOperator.java", "diffHunk": "@@ -329,7 +339,40 @@ public RoleBinding generateRoleBinding(String namespace, String watchedNamespace\n \n         RoleBinding rb = new RoleBindingBuilder()\n                 .withNewMetadata()\n-                    .withName(roleBindingName(cluster))\n+                    .withName(roleBindingForClusterRoleName(cluster))\n+                    .withNamespace(watchedNamespace)\n+                    .withOwnerReferences(createOwnerReference())\n+                    .withLabels(labels.toMap())\n+                .endMetadata()\n+                .withRoleRef(roleRef)\n+                .withSubjects(singletonList(ks))\n+                .build();\n+\n+        return rb;\n+    }\n+\n+    @Override\n+    protected String getRoleName() {\n+        return EntityOperator.getRoleName(cluster);\n+    }\n+\n+    public RoleBinding generateRoleBindingForRole(String namespace, String watchedNamespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d39360b0f46b9971bbd24b920b5711d26e8b66d"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA4MDA2MQ==", "bodyText": "I do not think this is right. It basically ignores the issue and send the pods looping. If we do not have access and it is needed, we should just error the reconciliation and have the user fix it. Thsi otherwise gives a very bad UX where users do something and it will not work and they will not understand why.\nI also wonder if we should maintain both methods of running this => the one above which silently ignores things and the one where it is intentionally configured. I think we should go for the simplicity and keep just one of them (yours) and if users do not set the Namespaced RBAC_SCOPE and do not give it the right it will just error. It will give us less paths to maintain.\nFinally, the right thing to do is to not make the call when you are in the namespaced RbacScope. This way you trigger the error every 2 minutes while you know it will fail. That also triggers various security monitoring systems etc. So we need to check the scope before making the call.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r539080061", "createdAt": "2020-12-09T07:50:40Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1716,26 +1726,30 @@ String zkConnectionString(int connectToReplicas, Function<Integer, String> zkNod\n \n         Future<ReconciliationState> kafkaInitClusterRoleBinding() {\n             ClusterRoleBinding desired = kafkaCluster.generateClusterRoleBinding(namespace);\n-            Future<ReconcileResult<ClusterRoleBinding>> fut = clusterRoleBindingOperations.reconcile(\n-                    KafkaResources.initContainerClusterRoleBindingName(name, namespace), desired);\n-\n-            Promise replacementPromise = Promise.promise();\n \n-            fut.onComplete(res -> {\n-                if (res.failed()) {\n-                    if (desired == null && res.cause() != null && res.cause().getMessage() != null &&\n-                            res.cause().getMessage().contains(\"Message: Forbidden!\")) {\n-                        log.debug(\"Ignoring forbidden access to ClusterRoleBindings which seems not needed while Kafka rack awareness is disabled.\");\n-                        replacementPromise.complete();\n-                    } else {\n-                        replacementPromise.fail(res.cause());\n-                    }\n-                } else {\n-                    replacementPromise.complete();\n-                }\n-            });\n+            return withVoid(clusterRoleBindingOperations.reconcile(\n+                        KafkaResources.initContainerClusterRoleBindingName(name, namespace),\n+                        desired)\n+                    .compose(\n+                        rr -> Future.succeededFuture(),\n+                        e -> {\n+                            if (desired == null\n+                                    && e.getMessage() != null\n+                                    && e.getMessage().contains(\"Message: Forbidden!\")) {\n+                                log.debug(\"Ignoring forbidden access to ClusterRoleBindings which seems not needed while Kafka rack awareness is disabled.\");\n+                                return Future.succeededFuture();\n+                            }\n+                            if (rbacScope.canUseRoles()\n+                                    && e.getMessage() != null\n+                                    && e.getMessage().contains(\"Message: Forbidden!\")) {\n+                                log.info(\"Using STRIMZI_RBAC_SCOPE set to namespace requires user to apply ClusterRole and ClusterRoleBinding\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d39360b0f46b9971bbd24b920b5711d26e8b66d"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA4MTA2Ng==", "bodyText": "I think this needs to have different naming. You can always use roles. It is the ClusterRoles which you can or cannot use. Renaming it will make it more clear. With the current name it creates things like !canUseRoles(entityOperator.getTopicOperator().getWatchedNamespace()) which I need to think about 5 minutes to actually understand what does it mean.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r539081066", "createdAt": "2020-12-09T07:52:38Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3049,74 +3063,178 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if STRIMZI_RBAC_SCOPE is set to use roles and entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (canUseRoles(namespace) && isEntityOperatorDeployed()) {\n+                role = entityOperator.generateRole();\n+            } else {\n+                role = null;\n+            }\n+\n+            return withVoid(roleOperations.reconcile(\n+                    namespace,\n+                    EntityOperator.entityOperatorRoleName(name),\n+                    role));\n+        }\n+\n         Future<ReconciliationState> entityOperatorServiceAccount() {\n             return withVoid(serviceAccountOperations.reconcile(namespace,\n                     EntityOperator.entityOperatorServiceAccountName(name),\n-                    eoDeployment != null ? entityOperator.generateServiceAccount() : null));\n+                    isEntityOperatorDeployed() ? entityOperator.generateServiceAccount() : null));\n         }\n \n-        Future<ReconciliationState> entityOperatorTopicOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getTopicOperator() != null) {\n-                String watchedNamespace = namespace;\n+        // Check for if the entity operator will be deployed as part of the reconciliation\n+        // Related resources need to know this to know whether to deploy\n+        private boolean isEntityOperatorDeployed() {\n+            return eoDeployment != null;\n+        }\n \n-                if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n-                        && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n-                    watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n-                }\n+        // Check for if roles can be used for the topic and user operator\n+        // If watched namespace is set to the current namespace Roles can be used\n+        // Note watchedNamespace can't be unset as it defaults to the deployed namespace\n+        public boolean canUseRoles(String watchedNamespace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d39360b0f46b9971bbd24b920b5711d26e8b66d"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA4Mzg3MA==", "bodyText": "Not sure I understand the namespace check. I did not saw any validation in the ClusterOperatorConfig which would for example forbid watching multiple namespaces there. So I'm not sure why exactly do we impose this limitation here.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r539083870", "createdAt": "2020-12-09T07:57:54Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3049,74 +3063,178 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if STRIMZI_RBAC_SCOPE is set to use roles and entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (canUseRoles(namespace) && isEntityOperatorDeployed()) {\n+                role = entityOperator.generateRole();\n+            } else {\n+                role = null;\n+            }\n+\n+            return withVoid(roleOperations.reconcile(\n+                    namespace,\n+                    EntityOperator.entityOperatorRoleName(name),\n+                    role));\n+        }\n+\n         Future<ReconciliationState> entityOperatorServiceAccount() {\n             return withVoid(serviceAccountOperations.reconcile(namespace,\n                     EntityOperator.entityOperatorServiceAccountName(name),\n-                    eoDeployment != null ? entityOperator.generateServiceAccount() : null));\n+                    isEntityOperatorDeployed() ? entityOperator.generateServiceAccount() : null));\n         }\n \n-        Future<ReconciliationState> entityOperatorTopicOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getTopicOperator() != null) {\n-                String watchedNamespace = namespace;\n+        // Check for if the entity operator will be deployed as part of the reconciliation\n+        // Related resources need to know this to know whether to deploy\n+        private boolean isEntityOperatorDeployed() {\n+            return eoDeployment != null;\n+        }\n \n-                if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n-                        && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n-                    watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n-                }\n+        // Check for if roles can be used for the topic and user operator\n+        // If watched namespace is set to the current namespace Roles can be used\n+        // Note watchedNamespace can't be unset as it defaults to the deployed namespace\n+        public boolean canUseRoles(String watchedNamespace) {\n+            return rbacScope.canUseRoles() && this.namespace.equals(watchedNamespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d39360b0f46b9971bbd24b920b5711d26e8b66d"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA4NDE4NA==", "bodyText": "Is this still something TODO? Or should it be removed?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r539084184", "createdAt": "2020-12-09T07:58:23Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3049,74 +3063,178 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if STRIMZI_RBAC_SCOPE is set to use roles and entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (canUseRoles(namespace) && isEntityOperatorDeployed()) {\n+                role = entityOperator.generateRole();\n+            } else {\n+                role = null;\n+            }\n+\n+            return withVoid(roleOperations.reconcile(\n+                    namespace,\n+                    EntityOperator.entityOperatorRoleName(name),\n+                    role));\n+        }\n+\n         Future<ReconciliationState> entityOperatorServiceAccount() {\n             return withVoid(serviceAccountOperations.reconcile(namespace,\n                     EntityOperator.entityOperatorServiceAccountName(name),\n-                    eoDeployment != null ? entityOperator.generateServiceAccount() : null));\n+                    isEntityOperatorDeployed() ? entityOperator.generateServiceAccount() : null));\n         }\n \n-        Future<ReconciliationState> entityOperatorTopicOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getTopicOperator() != null) {\n-                String watchedNamespace = namespace;\n+        // Check for if the entity operator will be deployed as part of the reconciliation\n+        // Related resources need to know this to know whether to deploy\n+        private boolean isEntityOperatorDeployed() {\n+            return eoDeployment != null;\n+        }\n \n-                if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n-                        && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n-                    watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n-                }\n+        // Check for if roles can be used for the topic and user operator\n+        // If watched namespace is set to the current namespace Roles can be used\n+        // Note watchedNamespace can't be unset as it defaults to the deployed namespace\n+        public boolean canUseRoles(String watchedNamespace) {\n+            return rbacScope.canUseRoles() && this.namespace.equals(watchedNamespace);\n+        }\n+\n+        Future<ReconciliationState> entityOperatorTopicOpRoleBindingForRole() {\n+            // Don't deploy Role RoleBinding if not running in roles only mode,\n+            // or if the topic operator is not deployed,\n+            // or if the topic operator needs to watch a different namespace\n+            if (!isEntityOperatorDeployed()\n+                    || entityOperator.getTopicOperator() == null\n+                    || !canUseRoles(entityOperator.getTopicOperator().getWatchedNamespace())) {\n+                log.debug(\"entityOperatorTopicOpRoleBindingForRole not required\");\n+                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.roleBindingForRoleName(name), null));\n+            }\n+\n+            return withVoid(roleBindingOperations.reconcile(\n+                    namespace,\n+                    EntityTopicOperator.roleBindingForRoleName(name),\n+                    entityOperator.getTopicOperator().generateRoleBindingForRole(namespace, namespace)));\n+        }\n \n+        Future<ReconciliationState> entityOperatorTopicOpRoleBindingForClusterRole() {\n+            // Don't deploy ClusterRole RoleBinding if it can use roles,\n+            // or if the topic operator is not deployed,\n+            // or if the topic operator doesn't need to watch a different namespace\n+            if (!isEntityOperatorDeployed()\n+                    || entityOperator.getTopicOperator() == null\n+                    || canUseRoles(entityOperator.getTopicOperator().getWatchedNamespace())) {\n+                log.debug(\"entityOperatorTopicOpRoleBindingForClusterRole not required\");\n                 return withVoid(roleBindingOperations.reconcile(\n+                        namespace,\n+                        EntityTopicOperator.roleBindingForClusterRoleName(name),\n+                        null));\n+            }\n+\n+            final String watchedNamespace;\n+\n+            if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n+                    && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n+                watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n+            } else {\n+                watchedNamespace = namespace;\n+            }\n+\n+            final Future<ReconcileResult<RoleBinding>> watchedNamespaceFuture;\n+\n+            if (!namespace.equals(watchedNamespace)) {\n+                watchedNamespaceFuture = roleBindingOperations.reconcile(\n                         watchedNamespace,\n-                        EntityTopicOperator.roleBindingName(name),\n-                        entityOperator.getTopicOperator().generateRoleBinding(namespace, watchedNamespace)));\n-            } else  {\n-                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.roleBindingName(name), null));\n+                        EntityTopicOperator.roleBindingForClusterRoleName(name),\n+                        entityOperator.getTopicOperator().generateRoleBindingForClusterRole(namespace, watchedNamespace));\n+            } else {\n+                watchedNamespaceFuture = Future.succeededFuture();\n             }\n+\n+            // Create role binding for the the UI runs in (it needs to access the CA etc.)\n+            Future<ReconcileResult<RoleBinding>> ownNamespaceFuture = roleBindingOperations.reconcile(\n+                    namespace,\n+                    EntityTopicOperator.roleBindingForClusterRoleName(name),\n+                    entityOperator.getTopicOperator().generateRoleBindingForClusterRole(namespace, namespace));\n+\n+            return withVoid(CompositeFuture.join(ownNamespaceFuture, watchedNamespaceFuture));\n         }\n \n-        Future<ReconciliationState> entityOperatorUserOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getUserOperator() != null) {\n-                Future<ReconcileResult<RoleBinding>> ownNamespaceFuture;\n-                Future<ReconcileResult<RoleBinding>> watchedNamespaceFuture;\n+        Future<ReconciliationState> entityOperatorUserOpRoleBindingForRole() {\n+            // Don't deploy Role RoleBinding if not running in roles only mode,\n+            // or if the user operator is not deployed,\n+            // or if the user operator needs to watch a different namespace\n+            if (!isEntityOperatorDeployed()\n+                    || entityOperator.getUserOperator() == null\n+                    || !canUseRoles(entityOperator.getUserOperator().getWatchedNamespace())) {\n+                log.debug(\"entityOperatorUserOpRoleBindingForRole not required\");\n+                return withVoid(roleBindingOperations.reconcile(\n+                        namespace,\n+                        EntityUserOperator.roleBindingForRoleName(name),\n+                        null));\n+            }\n \n-                String watchedNamespace = namespace;\n+            // TODO Comment true?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d39360b0f46b9971bbd24b920b5711d26e8b66d"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA4NTMxNg==", "bodyText": "I wonder if this should again be updated and bound to the RbacScope instead of silently ignoring things. That will make it work everywhere the same way.\nAlso as I said in the KafkaAssemblyOperator => this should be gated by the RbacScope to not be called in the first place.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r539085316", "createdAt": "2020-12-09T08:00:28Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -194,25 +194,20 @@ protected KafkaConnectStatus createStatus() {\n      */\n     Future<ReconcileResult<ClusterRoleBinding>> connectInitClusterRoleBinding(String namespace, String name, KafkaConnectCluster connectCluster) {\n         ClusterRoleBinding desired = connectCluster.generateClusterRoleBinding();\n-        Future<ReconcileResult<ClusterRoleBinding>> fut = clusterRoleBindingOperations.reconcile(\n-                KafkaConnectResources.initContainerClusterRoleBindingName(name, namespace), desired);\n-\n-        Promise<ReconcileResult<ClusterRoleBinding>> replacementPromise = Promise.promise();\n-\n-        fut.onComplete(res -> {\n-            if (res.failed()) {\n-                if (desired == null && res.cause() != null && res.cause().getMessage() != null &&\n-                        res.cause().getMessage().contains(\"Message: Forbidden!\")) {\n-                    log.debug(\"Ignoring forbidden access to ClusterRoleBindings which seems not needed while Kafka Connect rack awareness is disabled.\");\n-                    replacementPromise.complete();\n-                } else {\n-                    replacementPromise.fail(res.cause());\n-                }\n-            } else {\n-                replacementPromise.complete(res.result());\n-            }\n-        });\n-\n-        return replacementPromise.future();\n+        return clusterRoleBindingOperations.reconcile(\n+                    KafkaConnectResources.initContainerClusterRoleBindingName(name, namespace),\n+                    desired)\n+                .compose(\n+                    rr -> Future.succeededFuture(),\n+                    e -> {\n+                        if (desired == null\n+                                && e.getMessage() != null\n+                                && e.getMessage().contains(\"Message: Forbidden!\")) {\n+                            log.debug(\"Ignoring forbidden access to ClusterRoleBindings which seems not needed while Kafka Connect rack awareness is disabled.\");\n+                            return Future.succeededFuture();\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d39360b0f46b9971bbd24b920b5711d26e8b66d"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA4Njc5OQ==", "bodyText": "Can we also add checks here that the ClusterRoleBinding etc. APIs are never called? That would help to test not just that it does the right steps but that it skips the wrong steps.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r539086799", "createdAt": "2020-12-09T08:03:07Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorRbacScopeTest.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.operator.assembly;\n+\n+import io.fabric8.kubernetes.api.model.rbac.ClusterRoleBinding;\n+import io.fabric8.kubernetes.api.model.rbac.RoleBinding;\n+import io.fabric8.kubernetes.api.model.rbac.RoleRef;\n+import io.fabric8.kubernetes.api.model.rbac.RoleRefBuilder;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaBuilder;\n+import io.strimzi.api.kafka.model.listener.arraylistener.KafkaListenerType;\n+import io.strimzi.certs.CertManager;\n+import io.strimzi.operator.KubernetesVersion;\n+import io.strimzi.operator.PlatformFeaturesAvailability;\n+import io.strimzi.operator.cluster.ClusterOperatorConfig;\n+import io.strimzi.operator.cluster.KafkaVersionTestUtils;\n+import io.strimzi.operator.cluster.ResourceUtils;\n+import io.strimzi.operator.cluster.model.EntityOperator;\n+import io.strimzi.operator.cluster.model.KafkaVersion;\n+import io.strimzi.operator.cluster.operator.resource.KafkaSetOperator;\n+import io.strimzi.operator.cluster.operator.resource.ResourceOperatorSupplier;\n+import io.strimzi.operator.common.PasswordGenerator;\n+import io.strimzi.operator.common.Reconciliation;\n+import io.strimzi.operator.common.operator.MockCertManager;\n+import io.strimzi.operator.common.operator.resource.ClusterRoleBindingOperator;\n+import io.strimzi.operator.common.operator.resource.CrdOperator;\n+import io.strimzi.operator.common.operator.resource.RoleBindingOperator;\n+import io.vertx.core.Future;\n+import io.vertx.core.Vertx;\n+import io.vertx.junit5.Checkpoint;\n+import io.vertx.junit5.VertxExtension;\n+import io.vertx.junit5.VertxTestContext;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+import org.hamcrest.TypeSafeDiagnosingMatcher;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.util.List;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(VertxExtension.class)\n+public class KafkaAssemblyOperatorRbacScopeTest {\n+    private final KubernetesVersion kubernetesVersion = KubernetesVersion.V1_11;\n+    private final MockCertManager certManager = new MockCertManager();\n+    private final PasswordGenerator passwordGenerator = new PasswordGenerator(10, \"a\", \"a\");\n+    private final ClusterOperatorConfig config = ResourceUtils.dummyClusterOperatorConfig(VERSIONS);\n+    private final ClusterOperatorConfig configNamespaceRbacScope = ResourceUtils.dummyClusterOperatorConfigRolesOnly(\n+            VERSIONS,\n+            ClusterOperatorConfig.DEFAULT_OPERATION_TIMEOUT_MS);\n+    private static final KafkaVersion.Lookup VERSIONS = KafkaVersionTestUtils.getKafkaVersionLookup();\n+    private final String namespace = \"test-ns\";\n+    private final String clusterName = \"test-instance\";\n+    protected static Vertx vertx;\n+\n+    @BeforeAll\n+    public static void before() {\n+        vertx = Vertx.vertx();\n+    }\n+\n+    @AfterAll\n+    public static void after() {\n+        vertx.close();\n+    }\n+\n+    /**\n+     * Override KafkaAssemblyOperator to only run reconciliation steps that concern the STRIMZI_RBAC_SCOPE feature\n+     */\n+    class KafkaAssemblyOperatorRolesSubset extends KafkaAssemblyOperator {\n+        public KafkaAssemblyOperatorRolesSubset(\n+                Vertx vertx,\n+                PlatformFeaturesAvailability pfa,\n+                CertManager certManager,\n+                PasswordGenerator passwordGenerator,\n+                ResourceOperatorSupplier supplier,\n+                ClusterOperatorConfig config\n+        ) {\n+            super(vertx, pfa, certManager, passwordGenerator, supplier, config);\n+        }\n+\n+        @Override\n+        Future<Void> reconcile(ReconciliationState reconcileState)  {\n+            return reconcileState.getEntityOperatorDescription()\n+                    .compose(state -> state.entityOperatorRole())\n+                    .compose(state -> state.entityOperatorServiceAccount())\n+                    .compose(state -> state.entityOperatorTopicOpRoleBindingForRole())\n+                    .compose(state -> state.entityOperatorTopicOpRoleBindingForClusterRole())\n+                    .compose(state -> state.entityOperatorUserOpRoleBindingForRole())\n+                    .compose(state -> state.entityOperatorUserOpRoleBindingForClusterRole())\n+                    .map((Void) null);\n+        }\n+\n+    }\n+\n+    /**\n+     * This test checks that when STRIMZI_RBAC_SCOPE feature is set to 'NAMESPACE', the cluster operator only\n+     * deploys and binds to Roles\n+     */\n+    @Test\n+    public void testRolesDeployedWhenNamespaceRbacScope(VertxTestContext context) {\n+        Kafka kafka = new KafkaBuilder()\n+                .withNewMetadata()\n+                    .withName(clusterName)\n+                    .withNamespace(namespace)\n+                .endMetadata()\n+                .withNewSpec()\n+                    .withNewKafka()\n+                        .withReplicas(3)\n+                    .endKafka()\n+                    .withNewZookeeper()\n+                        .withReplicas(3)\n+                    .endZookeeper()\n+                    .withNewEntityOperator()\n+                        .withNewUserOperator()\n+                        .endUserOperator()\n+                        .withNewTopicOperator()\n+                        .endTopicOperator()\n+                    .endEntityOperator()\n+                .endSpec()\n+                .build();\n+\n+        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(false);\n+\n+        // Mock the CRD Operator for Kafka resources\n+        CrdOperator mockKafkaOps = supplier.kafkaOperator;\n+        when(mockKafkaOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(kafka));\n+        when(mockKafkaOps.get(eq(namespace), eq(clusterName))).thenReturn(kafka);\n+        when(mockKafkaOps.updateStatusAsync(any(Kafka.class))).thenReturn(Future.succeededFuture());\n+\n+        // Mock the operations for RoleBindings\n+        RoleBindingOperator mockRoleBindingOps = supplier.roleBindingOperations;\n+        // Capture the names of reconciled rolebindings and their patched state\n+        ArgumentCaptor<String> roleBindingNameCaptor = ArgumentCaptor.forClass(String.class);\n+        ArgumentCaptor<RoleBinding> roleBindingCaptor = ArgumentCaptor.forClass(RoleBinding.class);\n+        when(mockRoleBindingOps.reconcile(eq(namespace), roleBindingNameCaptor.capture(), roleBindingCaptor.capture()))\n+                .thenReturn(Future.succeededFuture());\n+\n+        KafkaAssemblyOperatorRolesSubset kao = new KafkaAssemblyOperatorRolesSubset(\n+                vertx,\n+                new PlatformFeaturesAvailability(false, kubernetesVersion),\n+                certManager,\n+                passwordGenerator,\n+                supplier,\n+                configNamespaceRbacScope);\n+\n+        Checkpoint async = context.checkpoint();\n+        kao.reconcile(new Reconciliation(\"test-trigger\", Kafka.RESOURCE_KIND, namespace, clusterName))\n+                .onComplete(context.succeeding(v -> context.verify(() -> {\n+                    List<String> roleBindingNames = roleBindingNameCaptor.getAllValues();\n+                    List<RoleBinding> roleBindings = roleBindingCaptor.getAllValues();\n+\n+                    assertThat(roleBindingNames, hasSize(4));\n+                    assertThat(roleBindings, hasSize(4));\n+\n+                    // Check all RoleBindings, easier to index by order applied\n+                    assertThat(roleBindingNames.get(0), is(\"test-instance-entity-topic-operator-role\"));\n+                    assertThat(roleBindings.get(0), hasRoleRef(new RoleRefBuilder()\n+                            .withApiGroup(\"rbac.authorization.k8s.io\")\n+                            .withKind(\"Role\")\n+                            .withName(\"test-instance-entity-operator\")\n+                            .build()));\n+\n+                    assertThat(roleBindingNames.get(1), is(\"strimzi-test-instance-entity-topic-operator\"));\n+                    assertThat(roleBindings.get(1), is(nullValue()));\n+\n+                    assertThat(roleBindingNames.get(2), is(\"test-instance-entity-user-operator-role\"));\n+                    assertThat(roleBindings.get(2), hasRoleRef(new RoleRefBuilder()\n+                            .withApiGroup(\"rbac.authorization.k8s.io\")\n+                            .withKind(\"Role\")\n+                            .withName(\"test-instance-entity-operator\")\n+                            .build()));\n+\n+                    assertThat(roleBindingNames.get(3), is(\"strimzi-test-instance-entity-user-operator\"));\n+                    assertThat(roleBindings.get(3), is(nullValue()));\n+\n+                    async.flag();\n+                })));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d39360b0f46b9971bbd24b920b5711d26e8b66d"}, "originalPosition": 190}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2d39360b0f46b9971bbd24b920b5711d26e8b66d", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/2d39360b0f46b9971bbd24b920b5711d26e8b66d", "committedDate": "2020-12-03T13:41:31Z", "message": "feat: Commit generated files\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}, "afterCommit": {"oid": "a52844df4d8e14f073a7cefdf2148809d5b4f7ff", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/a52844df4d8e14f073a7cefdf2148809d5b4f7ff", "committedDate": "2020-12-11T13:30:17Z", "message": "feat: Review comments + STs\n\nFix Acceptance test pipeline\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e48b12933b941f0f0ab5bf05096135f768569f37", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e48b12933b941f0f0ab5bf05096135f768569f37", "committedDate": "2020-12-11T17:54:40Z", "message": "chore: Merge conflicts + azure correction\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}, "afterCommit": {"oid": "65051ffb458e484636f6e8100e8145e94c9e2656", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/65051ffb458e484636f6e8100e8145e94c9e2656", "committedDate": "2020-12-14T10:09:11Z", "message": "chore: Merge conflicts + azure correction\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "65051ffb458e484636f6e8100e8145e94c9e2656", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/65051ffb458e484636f6e8100e8145e94c9e2656", "committedDate": "2020-12-14T10:09:11Z", "message": "chore: Merge conflicts + azure correction\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}, "afterCommit": {"oid": "a896f7d79faaffe1a288f1450abdbecb809afd6f", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/a896f7d79faaffe1a288f1450abdbecb809afd6f", "committedDate": "2020-12-14T10:27:20Z", "message": "chore: Merge conflicts + azure correction\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "272c201517c7c3cbd34f4b8eb32e0bed1bf21b7b", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/272c201517c7c3cbd34f4b8eb32e0bed1bf21b7b", "committedDate": "2020-12-14T15:15:26Z", "message": "feat: System test changes\n\nAdd extra logging\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}, "afterCommit": {"oid": "485e550d9757867d3474b3696e53ec3deb2ad8d4", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/485e550d9757867d3474b3696e53ec3deb2ad8d4", "committedDate": "2020-12-15T09:28:50Z", "message": "feat: System test changes\n\nAdd extra logging\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "485e550d9757867d3474b3696e53ec3deb2ad8d4", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/485e550d9757867d3474b3696e53ec3deb2ad8d4", "committedDate": "2020-12-15T09:28:50Z", "message": "feat: System test changes\n\nAdd extra logging\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}, "afterCommit": {"oid": "c6d0673e1c7937b5d7ffa9d7ab68431b0bed8035", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c6d0673e1c7937b5d7ffa9d7ab68431b0bed8035", "committedDate": "2020-12-15T14:11:47Z", "message": "feat: System test changes\n\nAdd extra logging\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f95bb1179a238d343d2562acdbab84c75d1a9784", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/f95bb1179a238d343d2562acdbab84c75d1a9784", "committedDate": "2020-12-16T11:27:53Z", "message": "feat: Fix role application for watchedNamespace\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}, "afterCommit": {"oid": "25f9cc44d57f572064a97f16e9c1b982df6bbc50", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/25f9cc44d57f572064a97f16e9c1b982df6bbc50", "committedDate": "2020-12-16T12:12:56Z", "message": "feat: Fix role application for watchedNamespace\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "25f9cc44d57f572064a97f16e9c1b982df6bbc50", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/25f9cc44d57f572064a97f16e9c1b982df6bbc50", "committedDate": "2020-12-16T12:12:56Z", "message": "feat: Fix role application for watchedNamespace\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}, "afterCommit": {"oid": "fce39f7b09cbd4a01026290b5c1d0209452c39ac", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/fce39f7b09cbd4a01026290b5c1d0209452c39ac", "committedDate": "2020-12-16T12:39:24Z", "message": "feat: Fix role application for watchedNamespace\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fce39f7b09cbd4a01026290b5c1d0209452c39ac", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/fce39f7b09cbd4a01026290b5c1d0209452c39ac", "committedDate": "2020-12-16T12:39:24Z", "message": "feat: Fix role application for watchedNamespace\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}, "afterCommit": {"oid": "de18000e7b614e6dc80674dade99a9d813f62996", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/de18000e7b614e6dc80674dade99a9d813f62996", "committedDate": "2020-12-16T12:50:49Z", "message": "feat: Fix role application for watchedNamespace\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "23f6d6819ae5218f9c5a684a728f20769bf130d4", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/23f6d6819ae5218f9c5a684a728f20769bf130d4", "committedDate": "2020-12-16T12:56:57Z", "message": "feat: New tests + ST fixes\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}, "afterCommit": {"oid": "d53197ab6812ee1791e4797b7a8b7f70554113bd", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/d53197ab6812ee1791e4797b7a8b7f70554113bd", "committedDate": "2020-12-16T13:13:36Z", "message": "feat: New tests + ST fixes\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d53197ab6812ee1791e4797b7a8b7f70554113bd", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/d53197ab6812ee1791e4797b7a8b7f70554113bd", "committedDate": "2020-12-16T13:13:36Z", "message": "feat: New tests + ST fixes\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}, "afterCommit": {"oid": "b26d77ed35a42765df676965c2a7da8eff0496b0", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b26d77ed35a42765df676965c2a7da8eff0496b0", "committedDate": "2020-12-16T16:40:55Z", "message": "feat: New tests + ST fixes\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0NTAxNjA2", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#pullrequestreview-554501606", "createdAt": "2020-12-17T11:09:23Z", "commit": {"oid": "1b16ad8a283561b83f636e751a8944540c8f1621"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxMTowOToyM1rOIHwf-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxMToyNzo0MlrOIHxMBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAwNTU2Mg==", "bodyText": "rerunFailingTestsCount set it to back to 2", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r545005562", "createdAt": "2020-12-17T11:09:23Z", "author": {"login": "Frawless"}, "path": ".azure/templates/system_test_general.yaml", "diffHunk": "@@ -54,10 +56,11 @@ jobs:\n         publishJUnitResults: true\n         testResultsFiles: '**/failsafe-reports/TEST-*.xml'\n         goals: 'verify'\n-        options: '-Dgroups=${{ parameters.groups }} -Dit.test=\"${{ parameters.test_case }}\" -DexcludedGroups=flaky,loadbalancer,networkpolicies -Dmaven.javadoc.skip=true -B -V -Dfailsafe.rerunFailingTestsCount=2'\n+        options: '-Dgroups=${{ parameters.groups }} -Dit.test=\"${{ parameters.test_case }}\" -DexcludedGroups=flaky,loadbalancer,networkpolicies,${{ parameters.excludedGroups }} -Dmaven.javadoc.skip=true -B -V -Dfailsafe.rerunFailingTestsCount=0'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b16ad8a283561b83f636e751a8944540c8f1621"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAxMjAwMw==", "bodyText": "Maybe create a constant for it?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r545012003", "createdAt": "2020-12-17T11:19:38Z", "author": {"login": "Frawless"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/Environment.java", "diffHunk": "@@ -173,6 +179,10 @@ public static boolean isHelmInstall() {\n         return CLUSTER_OPERATOR_INSTALL_TYPE.equals(ClusterOperatorInstallType.HELM);\n     }\n \n+    public static boolean isNamespaceRbacScope() {\n+        return \"NAMESPACE\".equals(STRIMZI_RBAC_SCOPE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b16ad8a283561b83f636e751a8944540c8f1621"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAxNjgzOQ==", "bodyText": "I wonder why we have nodePort listener here when we don't use it at all...guess we should double-check it and remove/use it in some next PR.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r545016839", "createdAt": "2020-12-17T11:27:42Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/security/oauth/OauthPlainST.java", "diffHunk": "@@ -222,6 +224,7 @@ void testProducerConsumerMirrorMaker() {\n     @Test\n     @Tag(MIRROR_MAKER2)\n     @Tag(CONNECT_COMPONENTS)\n+    @Tag(NODEPORT_SUPPORTED)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b16ad8a283561b83f636e751a8944540c8f1621"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2MDc3ODg3", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#pullrequestreview-556077887", "createdAt": "2020-12-21T00:29:09Z", "commit": {"oid": "1197db8f8d587cb73d38667f1f9409693d2ca591"}, "state": "COMMENTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwMDoyOTowOVrOIJJNvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwMToxMzo0MlrOIJJm7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1OTA3MA==", "bodyText": "Can we add some JavaDoc please?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546459070", "createdAt": "2020-12-21T00:29:09Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -1368,6 +1380,31 @@ public ServiceAccount generateServiceAccount() {\n             .build();\n     }\n \n+    public Role generateRole(String namespace, List<PolicyRule> rules) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1197db8f8d587cb73d38667f1f9409693d2ca591"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1OTA3OQ==", "bodyText": "Can we add some JavaDoc please?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546459079", "createdAt": "2020-12-21T00:29:14Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -1368,6 +1380,31 @@ public ServiceAccount generateServiceAccount() {\n             .build();\n     }\n \n+    public Role generateRole(String namespace, List<PolicyRule> rules) {\n+        return new RoleBuilder()\n+                .withNewMetadata()\n+                    .withName(getRoleName())\n+                    .withNamespace(namespace)\n+                    .withOwnerReferences(createOwnerReference())\n+                    .addToLabels(labels.toMap())\n+                .endMetadata()\n+                .withRules(rules)\n+                .build();\n+    }\n+\n+    public RoleBinding generateRoleBinding(String name, String namespace, RoleRef roleRef, List<Subject> subjects) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1197db8f8d587cb73d38667f1f9409693d2ca591"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1OTQ0MQ==", "bodyText": "I still think this is a bit weird. Should we instead throw some UnsupportedException or something? I think that will help to make sure this is not used by mistake somewhere. But maybe I'm just overthinking it.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546459441", "createdAt": "2020-12-21T00:32:13Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -719,6 +724,13 @@ protected String getServiceAccountName() {\n         return null;\n     }\n \n+    /**\n+     * @return the name of the role used by the service account for the deployed cluster for Kubernetes API operations.\n+     */\n+    protected String getRoleName() {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1197db8f8d587cb73d38667f1f9409693d2ca591"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1OTczNA==", "bodyText": "I'm sorry, but I still don't follow this. Why do we need two static methods? Why not just use this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static String entityOperatorRoleName(String cluster) {\n          \n          \n            \n                    return entityOperatorName(cluster);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                @Override\n          \n          \n            \n                protected String getRoleName() {\n          \n          \n            \n                    return getRoleName(cluster);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                protected static String getRoleName(String cluster) {\n          \n          \n            \n                    return entityOperatorRoleName(cluster);\n          \n          \n            \n                }\n          \n          \n            \n                public static String entityOperatorRoleName(String cluster) {\n          \n          \n            \n                    return entityOperatorName(cluster);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                @Override\n          \n          \n            \n                protected String getRoleName() {\n          \n          \n            \n                    return entityOperatorRoleName(cluster);\n          \n          \n            \n                }\n          \n      \n    \n    \n  \n\nI.e. deleting the protected static String getRoleName(String cluster) which doesn't seem to do anything useful.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546459734", "createdAt": "2020-12-21T00:34:35Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityOperator.java", "diffHunk": "@@ -348,6 +358,53 @@ public ServiceAccount generateServiceAccount() {\n         return super.generateServiceAccount();\n     }\n \n+    /**\n+     * Get the name of the Entity Operator Role given the name of the {@code cluster}.\n+     * @param cluster The cluster name\n+     * @return The name of the EO role.\n+     */\n+    public static String entityOperatorRoleName(String cluster) {\n+        return entityOperatorName(cluster);\n+    }\n+\n+    @Override\n+    protected String getRoleName() {\n+        return getRoleName(cluster);\n+    }\n+\n+    protected static String getRoleName(String cluster) {\n+        return entityOperatorRoleName(cluster);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1197db8f8d587cb73d38667f1f9409693d2ca591"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2MTA2Mg==", "bodyText": "I think I said it before ... but I do not agree with this solution. This cannot pass with just a debug message. If the init role is needed, this IMHO needs to fail to make it obvious to the user that this does not work. I understand the intention that the user might create the cluster role binding manually. But I think the risk of not understanding that and thinking they have a feature enabled which isn't is too big and too dangerous. Also, if the user has the rights to create the cluster role binding manually, he can also give it to the operator in the first place and doesn't have to use namespaced scope. So I think we should change this.\nThis is also important because for example with node ports, this is your chance to give it a nice and understandable error and gate the feature here. If you let it pass, the user will in many cases not create the cluster role binding and get much weirder errors later.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546461062", "createdAt": "2020-12-21T00:44:05Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1813,9 +1821,19 @@ String zkConnectionString(int connectToReplicas, Function<Integer, String> zkNod\n         }\n \n         Future<ReconciliationState> kafkaInitClusterRoleBinding() {\n+            if (!rbacScope.canUseClusterRoles()) {\n+                log.debug(\"Using STRIMZI_RBAC_SCOPE set to namespace requires user to apply ClusterRole and ClusterRoleBinding manually\");\n+                return withVoid(Future.succeededFuture());\n+            }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1197db8f8d587cb73d38667f1f9409693d2ca591"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2MjA0MQ==", "bodyText": "I'm not sure I understand this comment. Is this still a TODO for this PR? It looks to me like the code bellow created the roles in watchedNamespaces ... so maybe this is invalid now?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546462041", "createdAt": "2020-12-21T00:50:48Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3129,74 +3147,182 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (isEntityOperatorDeployed()) {\n+                role = entityOperator.generateRole(namespace);\n+            } else {\n+                role = null;\n+            }\n+\n+            // Currently only deploys role into target namespace\n+            // Role must be applied manually if using 'watchedNamespace' feature", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1197db8f8d587cb73d38667f1f9409693d2ca591"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2MjI0NA==", "bodyText": "What happens when userWatchedNamespace and topicWatchedNamespace are the same? Do we need to handle that to not overwrite the roles?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546462244", "createdAt": "2020-12-21T00:52:01Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3129,74 +3147,182 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (isEntityOperatorDeployed()) {\n+                role = entityOperator.generateRole(namespace);\n+            } else {\n+                role = null;\n+            }\n+\n+            // Currently only deploys role into target namespace\n+            // Role must be applied manually if using 'watchedNamespace' feature\n+            final Future<ReconcileResult<Role>> ownNamespaceFuture = roleOperations.reconcile(\n+                    namespace,\n+                    EntityOperator.entityOperatorRoleName(name),\n+                    role);\n+\n+            final String userWatchedNamespace;\n+            if (isEntityOperatorDeployed()\n+                    && entityOperator.getUserOperator() != null\n+                    && entityOperator.getUserOperator().getWatchedNamespace() != null\n+                    && !entityOperator.getUserOperator().getWatchedNamespace().isEmpty()) {\n+                userWatchedNamespace = entityOperator.getUserOperator().getWatchedNamespace();\n+            } else {\n+                userWatchedNamespace = namespace;\n+            }\n+\n+            final Future<ReconcileResult<Role>> userWatchedNamespaceFuture;\n+            if (!namespace.equals(userWatchedNamespace)) {\n+                userWatchedNamespaceFuture = roleOperations.reconcile(\n+                        userWatchedNamespace,\n+                        EntityOperator.entityOperatorRoleName(name),\n+                        entityOperator.generateRole(userWatchedNamespace));\n+            } else {\n+                userWatchedNamespaceFuture = Future.succeededFuture();\n+            }\n+\n+            final String topicWatchedNamespace;\n+            if (isEntityOperatorDeployed()\n+                    && entityOperator.getTopicOperator() != null\n+                    && entityOperator.getTopicOperator().getWatchedNamespace() != null\n+                    && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n+                topicWatchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n+            } else {\n+                topicWatchedNamespace = namespace;\n+            }\n+\n+            final Future<ReconcileResult<Role>> topicWatchedNamespaceFuture;\n+            if (!namespace.equals(topicWatchedNamespace)) {\n+                topicWatchedNamespaceFuture = roleOperations.reconcile(\n+                        topicWatchedNamespace,\n+                        EntityOperator.entityOperatorRoleName(name),\n+                        entityOperator.generateRole(topicWatchedNamespace));\n+            } else {\n+                topicWatchedNamespaceFuture = Future.succeededFuture();\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1197db8f8d587cb73d38667f1f9409693d2ca591"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2MjM1NA==", "bodyText": "I wonder if we should split this into 3 smaller methods ... the code seems to be fairly independent for the 3 different sections.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546462354", "createdAt": "2020-12-21T00:53:00Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3129,74 +3147,182 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1197db8f8d587cb73d38667f1f9409693d2ca591"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2MjU4Nw==", "bodyText": "Does the first line of the comment still apply?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546462587", "createdAt": "2020-12-21T00:54:37Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3129,74 +3147,182 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (isEntityOperatorDeployed()) {\n+                role = entityOperator.generateRole(namespace);\n+            } else {\n+                role = null;\n+            }\n+\n+            // Currently only deploys role into target namespace\n+            // Role must be applied manually if using 'watchedNamespace' feature\n+            final Future<ReconcileResult<Role>> ownNamespaceFuture = roleOperations.reconcile(\n+                    namespace,\n+                    EntityOperator.entityOperatorRoleName(name),\n+                    role);\n+\n+            final String userWatchedNamespace;\n+            if (isEntityOperatorDeployed()\n+                    && entityOperator.getUserOperator() != null\n+                    && entityOperator.getUserOperator().getWatchedNamespace() != null\n+                    && !entityOperator.getUserOperator().getWatchedNamespace().isEmpty()) {\n+                userWatchedNamespace = entityOperator.getUserOperator().getWatchedNamespace();\n+            } else {\n+                userWatchedNamespace = namespace;\n+            }\n+\n+            final Future<ReconcileResult<Role>> userWatchedNamespaceFuture;\n+            if (!namespace.equals(userWatchedNamespace)) {\n+                userWatchedNamespaceFuture = roleOperations.reconcile(\n+                        userWatchedNamespace,\n+                        EntityOperator.entityOperatorRoleName(name),\n+                        entityOperator.generateRole(userWatchedNamespace));\n+            } else {\n+                userWatchedNamespaceFuture = Future.succeededFuture();\n+            }\n+\n+            final String topicWatchedNamespace;\n+            if (isEntityOperatorDeployed()\n+                    && entityOperator.getTopicOperator() != null\n+                    && entityOperator.getTopicOperator().getWatchedNamespace() != null\n+                    && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n+                topicWatchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n+            } else {\n+                topicWatchedNamespace = namespace;\n+            }\n+\n+            final Future<ReconcileResult<Role>> topicWatchedNamespaceFuture;\n+            if (!namespace.equals(topicWatchedNamespace)) {\n+                topicWatchedNamespaceFuture = roleOperations.reconcile(\n+                        topicWatchedNamespace,\n+                        EntityOperator.entityOperatorRoleName(name),\n+                        entityOperator.generateRole(topicWatchedNamespace));\n+            } else {\n+                topicWatchedNamespaceFuture = Future.succeededFuture();\n+            }\n+\n+            return withVoid(CompositeFuture.join(\n+                    ownNamespaceFuture,\n+                    userWatchedNamespaceFuture,\n+                    topicWatchedNamespaceFuture));\n+        }\n+\n         Future<ReconciliationState> entityOperatorServiceAccount() {\n             return withVoid(serviceAccountOperations.reconcile(namespace,\n                     EntityOperator.entityOperatorServiceAccountName(name),\n-                    eoDeployment != null ? entityOperator.generateServiceAccount() : null));\n+                    isEntityOperatorDeployed() ? entityOperator.generateServiceAccount() : null));\n         }\n \n-        Future<ReconciliationState> entityOperatorTopicOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getTopicOperator() != null) {\n-                String watchedNamespace = namespace;\n-\n-                if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n-                        && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n-                    watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n-                }\n+        // Check for if the entity operator will be deployed as part of the reconciliation\n+        // Related resources need to know this to know whether to deploy\n+        private boolean isEntityOperatorDeployed() {\n+            return eoDeployment != null;\n+        }\n \n+        Future<ReconciliationState> entityOperatorTopicOpRoleBindingForRole() {\n+            // Don't deploy Role RoleBinding if not running in roles only mode,\n+            // or if the topic operator is not deployed,\n+            // or if the topic operator needs to watch a different namespace\n+            if (!isEntityOperatorDeployed()\n+                    || entityOperator.getTopicOperator() == null) {\n+                log.debug(\"entityOperatorTopicOpRoleBindingForRole not required\");\n                 return withVoid(roleBindingOperations.reconcile(\n+                        namespace,\n+                        EntityTopicOperator.roleBindingForRoleName(name),\n+                        null));\n+            }\n+\n+\n+            final String watchedNamespace;\n+\n+            if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n+                    && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n+                watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n+            } else {\n+                watchedNamespace = namespace;\n+            }\n+\n+            final Future<ReconcileResult<RoleBinding>> watchedNamespaceFuture;\n+\n+            if (!namespace.equals(watchedNamespace)) {\n+                watchedNamespaceFuture = roleBindingOperations.reconcile(\n                         watchedNamespace,\n-                        EntityTopicOperator.roleBindingName(name),\n-                        entityOperator.getTopicOperator().generateRoleBinding(namespace, watchedNamespace)));\n-            } else  {\n-                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.roleBindingName(name), null));\n+                        EntityTopicOperator.roleBindingForRoleName(name),\n+                        entityOperator.getTopicOperator().generateRoleBindingForRole(namespace, watchedNamespace));\n+            } else {\n+                watchedNamespaceFuture = Future.succeededFuture();\n             }\n-        }\n \n-        Future<ReconciliationState> entityOperatorUserOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getUserOperator() != null) {\n-                Future<ReconcileResult<RoleBinding>> ownNamespaceFuture;\n-                Future<ReconcileResult<RoleBinding>> watchedNamespaceFuture;\n+            // Create role binding for the the UI runs in (it needs to access the CA etc.)\n+            Future<ReconcileResult<RoleBinding>> ownNamespaceFuture = roleBindingOperations.reconcile(\n+                    namespace,\n+                    EntityTopicOperator.roleBindingForRoleName(name),\n+                    entityOperator.getTopicOperator().generateRoleBindingForRole(namespace, namespace));\n+\n+            return withVoid(CompositeFuture.join(ownNamespaceFuture, watchedNamespaceFuture));\n+        }\n \n-                String watchedNamespace = namespace;\n+        Future<ReconciliationState> entityOperatorUserOpRoleBindingForRole() {\n+            // Don't deploy Role RoleBinding if not running in roles only mode,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1197db8f8d587cb73d38667f1f9409693d2ca591"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2MjcwMg==", "bodyText": "Also here I wonder if we should split this into 3 separate methods. Just a thought.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546462702", "createdAt": "2020-12-21T00:55:18Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3129,74 +3147,182 @@ StatefulSet getKafkaStatefulSet()   {\n             }\n         }\n \n+        // Deploy entity operator Role if entity operator is deployed\n+        Future<ReconciliationState> entityOperatorRole() {\n+            final Role role;\n+            if (isEntityOperatorDeployed()) {\n+                role = entityOperator.generateRole(namespace);\n+            } else {\n+                role = null;\n+            }\n+\n+            // Currently only deploys role into target namespace\n+            // Role must be applied manually if using 'watchedNamespace' feature\n+            final Future<ReconcileResult<Role>> ownNamespaceFuture = roleOperations.reconcile(\n+                    namespace,\n+                    EntityOperator.entityOperatorRoleName(name),\n+                    role);\n+\n+            final String userWatchedNamespace;\n+            if (isEntityOperatorDeployed()\n+                    && entityOperator.getUserOperator() != null\n+                    && entityOperator.getUserOperator().getWatchedNamespace() != null\n+                    && !entityOperator.getUserOperator().getWatchedNamespace().isEmpty()) {\n+                userWatchedNamespace = entityOperator.getUserOperator().getWatchedNamespace();\n+            } else {\n+                userWatchedNamespace = namespace;\n+            }\n+\n+            final Future<ReconcileResult<Role>> userWatchedNamespaceFuture;\n+            if (!namespace.equals(userWatchedNamespace)) {\n+                userWatchedNamespaceFuture = roleOperations.reconcile(\n+                        userWatchedNamespace,\n+                        EntityOperator.entityOperatorRoleName(name),\n+                        entityOperator.generateRole(userWatchedNamespace));\n+            } else {\n+                userWatchedNamespaceFuture = Future.succeededFuture();\n+            }\n+\n+            final String topicWatchedNamespace;\n+            if (isEntityOperatorDeployed()\n+                    && entityOperator.getTopicOperator() != null\n+                    && entityOperator.getTopicOperator().getWatchedNamespace() != null\n+                    && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n+                topicWatchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n+            } else {\n+                topicWatchedNamespace = namespace;\n+            }\n+\n+            final Future<ReconcileResult<Role>> topicWatchedNamespaceFuture;\n+            if (!namespace.equals(topicWatchedNamespace)) {\n+                topicWatchedNamespaceFuture = roleOperations.reconcile(\n+                        topicWatchedNamespace,\n+                        EntityOperator.entityOperatorRoleName(name),\n+                        entityOperator.generateRole(topicWatchedNamespace));\n+            } else {\n+                topicWatchedNamespaceFuture = Future.succeededFuture();\n+            }\n+\n+            return withVoid(CompositeFuture.join(\n+                    ownNamespaceFuture,\n+                    userWatchedNamespaceFuture,\n+                    topicWatchedNamespaceFuture));\n+        }\n+\n         Future<ReconciliationState> entityOperatorServiceAccount() {\n             return withVoid(serviceAccountOperations.reconcile(namespace,\n                     EntityOperator.entityOperatorServiceAccountName(name),\n-                    eoDeployment != null ? entityOperator.generateServiceAccount() : null));\n+                    isEntityOperatorDeployed() ? entityOperator.generateServiceAccount() : null));\n         }\n \n-        Future<ReconciliationState> entityOperatorTopicOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getTopicOperator() != null) {\n-                String watchedNamespace = namespace;\n-\n-                if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n-                        && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n-                    watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n-                }\n+        // Check for if the entity operator will be deployed as part of the reconciliation\n+        // Related resources need to know this to know whether to deploy\n+        private boolean isEntityOperatorDeployed() {\n+            return eoDeployment != null;\n+        }\n \n+        Future<ReconciliationState> entityOperatorTopicOpRoleBindingForRole() {\n+            // Don't deploy Role RoleBinding if not running in roles only mode,\n+            // or if the topic operator is not deployed,\n+            // or if the topic operator needs to watch a different namespace\n+            if (!isEntityOperatorDeployed()\n+                    || entityOperator.getTopicOperator() == null) {\n+                log.debug(\"entityOperatorTopicOpRoleBindingForRole not required\");\n                 return withVoid(roleBindingOperations.reconcile(\n+                        namespace,\n+                        EntityTopicOperator.roleBindingForRoleName(name),\n+                        null));\n+            }\n+\n+\n+            final String watchedNamespace;\n+\n+            if (entityOperator.getTopicOperator().getWatchedNamespace() != null\n+                    && !entityOperator.getTopicOperator().getWatchedNamespace().isEmpty()) {\n+                watchedNamespace = entityOperator.getTopicOperator().getWatchedNamespace();\n+            } else {\n+                watchedNamespace = namespace;\n+            }\n+\n+            final Future<ReconcileResult<RoleBinding>> watchedNamespaceFuture;\n+\n+            if (!namespace.equals(watchedNamespace)) {\n+                watchedNamespaceFuture = roleBindingOperations.reconcile(\n                         watchedNamespace,\n-                        EntityTopicOperator.roleBindingName(name),\n-                        entityOperator.getTopicOperator().generateRoleBinding(namespace, watchedNamespace)));\n-            } else  {\n-                return withVoid(roleBindingOperations.reconcile(namespace, EntityTopicOperator.roleBindingName(name), null));\n+                        EntityTopicOperator.roleBindingForRoleName(name),\n+                        entityOperator.getTopicOperator().generateRoleBindingForRole(namespace, watchedNamespace));\n+            } else {\n+                watchedNamespaceFuture = Future.succeededFuture();\n             }\n-        }\n \n-        Future<ReconciliationState> entityOperatorUserOpRoleBinding() {\n-            if (eoDeployment != null && entityOperator.getUserOperator() != null) {\n-                Future<ReconcileResult<RoleBinding>> ownNamespaceFuture;\n-                Future<ReconcileResult<RoleBinding>> watchedNamespaceFuture;\n+            // Create role binding for the the UI runs in (it needs to access the CA etc.)\n+            Future<ReconcileResult<RoleBinding>> ownNamespaceFuture = roleBindingOperations.reconcile(\n+                    namespace,\n+                    EntityTopicOperator.roleBindingForRoleName(name),\n+                    entityOperator.getTopicOperator().generateRoleBindingForRole(namespace, namespace));\n+\n+            return withVoid(CompositeFuture.join(ownNamespaceFuture, watchedNamespaceFuture));\n+        }\n \n-                String watchedNamespace = namespace;\n+        Future<ReconciliationState> entityOperatorUserOpRoleBindingForRole() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1197db8f8d587cb73d38667f1f9409693d2ca591"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2MjgyMQ==", "bodyText": "Same comment as I had for this method in KafkaAssemblyOperator.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546462821", "createdAt": "2020-12-21T00:55:58Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -193,9 +195,19 @@ protected KafkaConnectStatus createStatus() {\n      * @return                  Future for tracking the asynchronous result of the ClusterRoleBinding reconciliation\n      */\n     Future<ReconcileResult<ClusterRoleBinding>> connectInitClusterRoleBinding(String namespace, String name, KafkaConnectCluster connectCluster) {\n+        if (!rbacScope.canUseClusterRoles()) {\n+            log.debug(\"Using STRIMZI_RBAC_SCOPE set to namespace requires user to apply ClusterRole and ClusterRoleBinding manually\");\n+            return Future.succeededFuture();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1197db8f8d587cb73d38667f1f9409693d2ca591"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2MzM5Nw==", "bodyText": "If I got it right, we are now not using anymore the 031-ClusterRole-strimzi-entity-operator.yaml and 032-ClusterRole-strimzi-topic-operator.yaml ClusterRoles, or? Should they then be just removed ad the ACL rights merged into the 020-ClusterRole-strimzi-cluster-operator-role.yaml?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546463397", "createdAt": "2020-12-21T00:59:09Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/resources/cluster-roles/020-ClusterRole-strimzi-cluster-operator-role.yaml", "diffHunk": "@@ -18,6 +18,17 @@ rules:\n       - delete\n       - patch\n       - update\n+  - apiGroups:\n+      - \"rbac.authorization.k8s.io\"\n+    resources:\n+      # The cluster operator needs to access and manage roles to grant the entity operator permissions\n+      - roles\n+    verbs:\n+      - get\n+      - create\n+      - delete\n+      - patch\n+      - update", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1197db8f8d587cb73d38667f1f9409693d2ca591"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2NDEwMA==", "bodyText": "I think this part is confusing. The OLM deployment does not allow you to change the settings of the ClusterRoles / ClusterRoleBindings. It always deploys the operator in cluster-scope. So I'm not sure any tests with it run with the operator configured for the namespaced-scope make sense. This might confuse someone into thinking they do. So I would probably remove this.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546464100", "createdAt": "2020-12-21T01:04:39Z", "author": {"login": "scholzj"}, "path": "systemtest/src/main/resources/olm/subscription.yaml", "diffHunk": "@@ -20,4 +20,5 @@ spec:\n         value: \"${STRIMZI_FULL_RECONCILIATION_INTERVAL_MS}\"\n       - name: STRIMZI_OPERATION_TIMEOUT_MS\n         value: \"${STRIMZI_OPERATION_TIMEOUT_MS}\"\n-\n+      - name: STRIMZI_RBAC_SCOPE\n+        value: \"${STRIMZI_RBAC_SCOPE}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1197db8f8d587cb73d38667f1f9409693d2ca591"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2NDI0Mw==", "bodyText": "How much temporary is this? Is it still needed?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546464243", "createdAt": "2020-12-21T01:05:30Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/kafka/KafkaST.java", "diffHunk": "@@ -721,6 +723,9 @@ void testRemoveUserOperatorFromEntityOperator() {\n \n     @Test\n     void testRemoveUserAndTopicOperatorsFromEntityOperator() {\n+        // TODO temporary fix", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1197db8f8d587cb73d38667f1f9409693d2ca591"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2NDU4Mw==", "bodyText": "I do not think this makes sense. You are basically turning this into testMultipleInternal when running it without the node-ports. Should this just use Assume and skip the test in the namespaced mode?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546464583", "createdAt": "2020-12-21T01:07:33Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/kafka/listeners/MultipleListenersST.java", "diffHunk": "@@ -71,10 +72,12 @@ void testCombinationOfInternalAndExternalListeners() {\n         List<GenericKafkaListener> multipleDifferentListeners = new ArrayList<>();\n \n         List<GenericKafkaListener> internalListeners = testCases.get(KafkaListenerType.INTERNAL);\n-        List<GenericKafkaListener> nodeportListeners = testCases.get(KafkaListenerType.NODEPORT);\n-\n         multipleDifferentListeners.addAll(internalListeners);\n-        multipleDifferentListeners.addAll(nodeportListeners);\n+\n+        if (!Environment.isNamespaceRbacScope()) {\n+            List<GenericKafkaListener> nodeportListeners = testCases.get(KafkaListenerType.NODEPORT);\n+            multipleDifferentListeners.addAll(nodeportListeners);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1197db8f8d587cb73d38667f1f9409693d2ca591"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2NTE4MA==", "bodyText": "I wonder how well the status of the node port listener is really tested if this is all you need to get it passing. Because I guess it means there are no asserts for the status part related to the NodePort. So do we really need this? Should we just delete this and remove the @Tag(NODEPORT_SUPPORTED) annotation where applicable?\nWDYT @Frawless?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546465180", "createdAt": "2020-12-21T01:11:27Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/operators/CustomResourceStatusST.java", "diffHunk": "@@ -449,16 +451,25 @@ void deployTestSpecificResources() throws Exception {\n                             .withType(KafkaListenerType.INTERNAL)\n                             .withTls(true)\n                         .endGenericKafkaListener()\n-                        .addNewGenericKafkaListener()\n-                            .withName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-                            .withPort(9094)\n-                            .withType(KafkaListenerType.NODEPORT)\n-                            .withTls(false)\n-                        .endGenericKafkaListener()\n                     .endListeners()\n                 .endKafka()\n-            .endSpec()\n-            .done();\n+            .endSpec();\n+\n+        if (!Environment.isNamespaceRbacScope()) {\n+            kafka.editSpec()\n+                    .editKafka()\n+                        .editListeners()\n+                            .addNewGenericKafkaListener()\n+                                .withName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n+                                .withPort(9094)\n+                                .withType(KafkaListenerType.NODEPORT)\n+                                .withTls(false)\n+                            .endGenericKafkaListener()\n+                        .endListeners()\n+                    .endKafka()\n+                .endSpec();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1197db8f8d587cb73d38667f1f9409693d2ca591"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2NTUxOA==", "bodyText": "Again, lot of these temporary fixes ... it is not clear how temporary they are and if they should still be here.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r546465518", "createdAt": "2020-12-21T01:13:42Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/tracing/TracingST.java", "diffHunk": "@@ -111,6 +113,9 @@\n \n     @Test\n     void testProducerService() {\n+        // TODO temporary fix", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1197db8f8d587cb73d38667f1f9409693d2ca591"}, "originalPosition": 20}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df47107973e40fa27b1e58676f4f3fba47ef3aa3", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/df47107973e40fa27b1e58676f4f3fba47ef3aa3", "committedDate": "2020-12-24T09:25:50Z", "message": "feat: Roles RBAC Scope\n\nRole operator tests\nRole permissions\nClusterOperatorConfig changes\nAdd Assembly tests\nSystem tests\nAdd new envar docs\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fea0d48da19a36bd5bc8748e2d220113ec76204", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/8fea0d48da19a36bd5bc8748e2d220113ec76204", "committedDate": "2020-12-24T09:25:50Z", "message": "feat: Handle rackawareness and nodeports\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa90b9924ac185f698b616e538b402fd57d51a0f", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/aa90b9924ac185f698b616e538b402fd57d51a0f", "committedDate": "2020-12-24T09:25:50Z", "message": "feat: Commit generated files\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bea6a1ba796ebf6b6aee6be15cf62942fb7c995e", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/bea6a1ba796ebf6b6aee6be15cf62942fb7c995e", "committedDate": "2020-12-24T09:25:50Z", "message": "feat: Review comments + STs\n\nFix Acceptance test pipeline\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e83d50f6bf401636f933d492fa912d1b63bba2f", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/0e83d50f6bf401636f933d492fa912d1b63bba2f", "committedDate": "2020-12-24T09:25:51Z", "message": "chore: Merge conflicts + azure correction\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f9f160d38955c63b6189ca3e090433a727828a2", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/9f9f160d38955c63b6189ca3e090433a727828a2", "committedDate": "2020-12-24T09:25:51Z", "message": "feat: Use roles not clusterroles for EO\n\nTo reduce maintained code paths always use roles\n+ rolebindings for the EO\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbe856aecbe2562a6b4f2785a9d1bf82a4ea3056", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/dbe856aecbe2562a6b4f2785a9d1bf82a4ea3056", "committedDate": "2020-12-24T09:25:51Z", "message": "feat: System test changes\n\nAdd extra logging\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db4d676df795a547e7979e43aa7b44f53afb8f7b", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/db4d676df795a547e7979e43aa7b44f53afb8f7b", "committedDate": "2020-12-24T09:25:51Z", "message": "feat: Fix role application for watchedNamespace\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3320a44f88e80c99336ed6bd3ec133809bb463e6", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/3320a44f88e80c99336ed6bd3ec133809bb463e6", "committedDate": "2020-12-24T09:25:51Z", "message": "feat: New tests + ST fixes\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5819597562a1b29c37c3dc7cf50ece1a784bdb9", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c5819597562a1b29c37c3dc7cf50ece1a784bdb9", "committedDate": "2020-12-24T09:25:51Z", "message": "feat: Disable tests to fix in followup PR\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21c14c1ae61f167400f713cfec09d071449f009a", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/21c14c1ae61f167400f713cfec09d071449f009a", "committedDate": "2020-12-24T09:25:51Z", "message": "feat: Review comments\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1197db8f8d587cb73d38667f1f9409693d2ca591", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/1197db8f8d587cb73d38667f1f9409693d2ca591", "committedDate": "2020-12-17T11:35:42Z", "message": "feat: Review comments\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}, "afterCommit": {"oid": "3c7830c6783a60408f45f87b9f7fe6c3fd98f63e", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/3c7830c6783a60408f45f87b9f7fe6c3fd98f63e", "committedDate": "2020-12-24T10:06:32Z", "message": "feat: Address review comments\n\nAdd javadoc\nremove method duplication\nAdd clarifying exceptions\nRemove system test logic that doesnt\nmake sense\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33bc4aac331763689446eb5c342442299f9c8ac5", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/33bc4aac331763689446eb5c342442299f9c8ac5", "committedDate": "2020-12-24T11:46:03Z", "message": "feat: Address review comments\n\nAdd javadoc\nremove method duplication\nAdd clarifying exceptions\nRemove system test logic that doesnt\nmake sense\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3c7830c6783a60408f45f87b9f7fe6c3fd98f63e", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/3c7830c6783a60408f45f87b9f7fe6c3fd98f63e", "committedDate": "2020-12-24T10:06:32Z", "message": "feat: Address review comments\n\nAdd javadoc\nremove method duplication\nAdd clarifying exceptions\nRemove system test logic that doesnt\nmake sense\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}, "afterCommit": {"oid": "33bc4aac331763689446eb5c342442299f9c8ac5", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/33bc4aac331763689446eb5c342442299f9c8ac5", "committedDate": "2020-12-24T11:46:03Z", "message": "feat: Address review comments\n\nAdd javadoc\nremove method duplication\nAdd clarifying exceptions\nRemove system test logic that doesnt\nmake sense\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "010fd842ad54136b36b9b67a106f138c5ee679f7", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/010fd842ad54136b36b9b67a106f138c5ee679f7", "committedDate": "2021-01-04T15:12:32Z", "message": "feat: Improve readability\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}, "afterCommit": {"oid": "53989c6be5f2c14cab2b1b3cb24759c774f40742", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/53989c6be5f2c14cab2b1b3cb24759c774f40742", "committedDate": "2021-01-04T15:31:54Z", "message": "feat: Improve readability\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMTI2MTg1", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#pullrequestreview-561126185", "createdAt": "2021-01-04T15:38:39Z", "commit": {"oid": "53989c6be5f2c14cab2b1b3cb24759c774f40742"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54484d35c16a1f15265f5aef0c358377a3922712", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/54484d35c16a1f15265f5aef0c358377a3922712", "committedDate": "2021-01-04T16:10:42Z", "message": "feat: Improve readability\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "53989c6be5f2c14cab2b1b3cb24759c774f40742", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/53989c6be5f2c14cab2b1b3cb24759c774f40742", "committedDate": "2021-01-04T15:31:54Z", "message": "feat: Improve readability\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}, "afterCommit": {"oid": "54484d35c16a1f15265f5aef0c358377a3922712", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/54484d35c16a1f15265f5aef0c358377a3922712", "committedDate": "2021-01-04T16:10:42Z", "message": "feat: Improve readability\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMTUxODAy", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#pullrequestreview-561151802", "createdAt": "2021-01-04T16:12:10Z", "commit": {"oid": "53989c6be5f2c14cab2b1b3cb24759c774f40742"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjoxNjoxMFrOIN3v-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjoxNjoxMFrOIN3v-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQxNTgwMg==", "bodyText": "Or we can enhance the test for some additional checks, but I think to remove nodePort part is better since we take data from Kafka status in different tests.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r551415802", "createdAt": "2021-01-04T16:16:10Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/operators/CustomResourceStatusST.java", "diffHunk": "@@ -449,16 +451,25 @@ void deployTestSpecificResources() throws Exception {\n                             .withType(KafkaListenerType.INTERNAL)\n                             .withTls(true)\n                         .endGenericKafkaListener()\n-                        .addNewGenericKafkaListener()\n-                            .withName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n-                            .withPort(9094)\n-                            .withType(KafkaListenerType.NODEPORT)\n-                            .withTls(false)\n-                        .endGenericKafkaListener()\n                     .endListeners()\n                 .endKafka()\n-            .endSpec()\n-            .done();\n+            .endSpec();\n+\n+        if (!Environment.isNamespaceRbacScope()) {\n+            kafka.editSpec()\n+                    .editKafka()\n+                        .editListeners()\n+                            .addNewGenericKafkaListener()\n+                                .withName(Constants.EXTERNAL_LISTENER_DEFAULT_NAME)\n+                                .withPort(9094)\n+                                .withType(KafkaListenerType.NODEPORT)\n+                                .withTls(false)\n+                            .endGenericKafkaListener()\n+                        .endListeners()\n+                    .endKafka()\n+                .endSpec();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2NTE4MA=="}, "originalCommit": {"oid": "1197db8f8d587cb73d38667f1f9409693d2ca591"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxOTM1MjYx", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#pullrequestreview-561935261", "createdAt": "2021-01-05T16:24:33Z", "commit": {"oid": "c7325eddf3cc8da29a5319c660f9662bd512ecb8"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjoyNDozNFrOIOd6cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjoyNDozNFrOIOd6cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0MTA3Mg==", "bodyText": "Any reason why we're not just using a YAMLMapper here? That would probably avoid the need for yaml, since it can take an InputStream to parse.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3845#discussion_r552041072", "createdAt": "2021-01-05T16:24:34Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityOperator.java", "diffHunk": "@@ -348,6 +358,49 @@ public ServiceAccount generateServiceAccount() {\n         return super.generateServiceAccount();\n     }\n \n+    @Override\n+    protected String getRoleName() {\n+        return getRoleName(cluster);\n+    }\n+\n+    /**\n+     * Get the name of the Entity Operator Role given the name of the {@code cluster}.\n+     * @param cluster The cluster name\n+     * @return The name of the EO role.\n+     */\n+    public static String getRoleName(String cluster) {\n+        return entityOperatorName(cluster);\n+    }\n+\n+    /**\n+     * Read the entity operator ClusterRole, and use the rules to create a new Role.\n+     * This is done to avoid duplication of the rules set defined in source code.\n+     *\n+     * @param namespace the namespace this role will be located\n+     *\n+     * @return role for the entity operator\n+     */\n+    public Role generateRole(String namespace) {\n+        List<PolicyRule> rules;\n+\n+        try (BufferedReader br = new BufferedReader(\n+                new InputStreamReader(\n+                    Main.class.getResourceAsStream(\"/cluster-roles/031-ClusterRole-strimzi-entity-operator.yaml\"),\n+                    StandardCharsets.UTF_8)\n+            )\n+        ) {\n+            String yaml = br.lines().collect(Collectors.joining(System.lineSeparator()));\n+            ObjectMapper yamlReader = new ObjectMapper(new YAMLFactory());\n+            ClusterRole cr = yamlReader.readValue(yaml, ClusterRole.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7325eddf3cc8da29a5319c660f9662bd512ecb8"}, "originalPosition": 82}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "813ba7af9dd88fcc7a1aaf271b90f6b0888c60f5", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/813ba7af9dd88fcc7a1aaf271b90f6b0888c60f5", "committedDate": "2021-01-06T09:13:29Z", "message": "feat: Add role watch permissions for delete\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c7325eddf3cc8da29a5319c660f9662bd512ecb8", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c7325eddf3cc8da29a5319c660f9662bd512ecb8", "committedDate": "2021-01-05T11:39:01Z", "message": "feat: Add role watch permissions for delete\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}, "afterCommit": {"oid": "813ba7af9dd88fcc7a1aaf271b90f6b0888c60f5", "author": {"user": {"login": "samuel-hawker", "name": "Samuel Hawker"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/813ba7af9dd88fcc7a1aaf271b90f6b0888c60f5", "committedDate": "2021-01-06T09:13:29Z", "message": "feat: Add role watch permissions for delete\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 831, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}