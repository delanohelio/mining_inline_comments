{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc4NjE3ODA1", "number": 3599, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMzoyMjowMFrOEgYVLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMzoyMjowMFrOEgYVLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzg4NTI0OnYy", "diffSide": "RIGHT", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/ClientUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMzoyMjowMFrOHNNT2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMzo1MTozOVrOHNOXGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYxMTYxMQ==", "bodyText": "I would prepare to use the same approach as we have for deployment. Use current namespace if not specified and in case it's specified, use different.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3599#discussion_r483611611", "createdAt": "2020-09-04T13:22:00Z", "author": {"login": "Frawless"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/ClientUtils.java", "diffHunk": "@@ -50,14 +50,13 @@ public static void waitUntilClientReceivedMessagesTls(KafkaClientOperations kafk\n     public static void waitTillContinuousClientsFinish(String producerName, String consumerName, String namespace, int messageCount) {\n         LOGGER.info(\"Waiting till producer {} and consumer {} finish\", producerName, consumerName);\n         TestUtils.waitFor(\"continuous clients finished\", Constants.GLOBAL_POLL_INTERVAL, timeoutForClientFinishJob(messageCount),\n-            () -> kubeClient().getClient().batch().jobs().inNamespace(namespace).withName(producerName).get().getStatus().getSucceeded().equals(1) &&\n-                    kubeClient().getClient().batch().jobs().inNamespace(namespace).withName(consumerName).get().getStatus().getSucceeded().equals(1));\n+            () -> kubeClient().getJobStatus(producerName, namespace) && kubeClient().getJobStatus(consumerName, namespace));\n     }\n \n     public static void waitForClientSuccess(String jobName, String namespace, int messageCount) {\n         LOGGER.info(\"Waiting for producer/consumer:{} will be finished\", jobName);\n         TestUtils.waitFor(\"job finished\", Constants.GLOBAL_POLL_INTERVAL, timeoutForClientFinishJob(messageCount),\n-            () -> kubeClient().getClient().batch().jobs().inNamespace(namespace).withName(jobName).get().getStatus().getSucceeded().equals(1));\n+            () -> kubeClient().getJobStatus(jobName, namespace));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4183d57d1825aaad6d3f3bef815a67c2fd684cdf"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYyODgyNQ==", "bodyText": "You mean by specifying it in the kubeClient() right? Like we have -> kubeClient(\"some-namespace\"). I totally forgot this! Thanks :)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3599#discussion_r483628825", "createdAt": "2020-09-04T13:51:39Z", "author": {"login": "im-konge"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/ClientUtils.java", "diffHunk": "@@ -50,14 +50,13 @@ public static void waitUntilClientReceivedMessagesTls(KafkaClientOperations kafk\n     public static void waitTillContinuousClientsFinish(String producerName, String consumerName, String namespace, int messageCount) {\n         LOGGER.info(\"Waiting till producer {} and consumer {} finish\", producerName, consumerName);\n         TestUtils.waitFor(\"continuous clients finished\", Constants.GLOBAL_POLL_INTERVAL, timeoutForClientFinishJob(messageCount),\n-            () -> kubeClient().getClient().batch().jobs().inNamespace(namespace).withName(producerName).get().getStatus().getSucceeded().equals(1) &&\n-                    kubeClient().getClient().batch().jobs().inNamespace(namespace).withName(consumerName).get().getStatus().getSucceeded().equals(1));\n+            () -> kubeClient().getJobStatus(producerName, namespace) && kubeClient().getJobStatus(consumerName, namespace));\n     }\n \n     public static void waitForClientSuccess(String jobName, String namespace, int messageCount) {\n         LOGGER.info(\"Waiting for producer/consumer:{} will be finished\", jobName);\n         TestUtils.waitFor(\"job finished\", Constants.GLOBAL_POLL_INTERVAL, timeoutForClientFinishJob(messageCount),\n-            () -> kubeClient().getClient().batch().jobs().inNamespace(namespace).withName(jobName).get().getStatus().getSucceeded().equals(1));\n+            () -> kubeClient().getJobStatus(jobName, namespace));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYxMTYxMQ=="}, "originalCommit": {"oid": "4183d57d1825aaad6d3f3bef815a67c2fd684cdf"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1073, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}