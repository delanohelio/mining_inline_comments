{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4MjY2OTYx", "number": 3311, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDoyNzowOFrOEN18sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwODowODozMlrOEOJqgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyOTUwODM0OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDoyNzowOFrOGwrBIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNzo1Mjo0M1rOGxIaeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY4OTYzNQ==", "bodyText": "bridz?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3311#discussion_r453689635", "createdAt": "2020-07-13T14:27:08Z", "author": {"login": "ppatierno"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -349,6 +352,111 @@ void testDynamicallySetEOloggingLevels() throws InterruptedException {\n         assertThat(\"EO pod should not roll\", DeploymentUtils.depSnapshot(eoDeploymentName), equalTo(eoPods));\n     }\n \n+    @Test\n+    void testDynamicallySetBridgeLoggingLevels() throws InterruptedException {\n+        InlineLogging ilOff = new InlineLogging();\n+        Map<String, String> loggers = new HashMap<>();\n+        loggers.put(\"rootLogger.level\", \"OFF\");\n+        loggers.put(\"logger.bridge.level\", \"OFF\");\n+        loggers.put(\"logger.healthy.level\", \"OFF\");\n+        loggers.put(\"logger.ready.level\", \"OFF\");\n+        ilOff.setLoggers(loggers);\n+\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        KafkaBridgeResource.kafkaBridge(CLUSTER_NAME, KafkaResources.tlsBootstrapAddress(CLUSTER_NAME), 1)\n+                .editSpec()\n+                    .withInlineLogging(ilOff)\n+                .endSpec()\n+                .done();\n+\n+        Map<String, String> bridgeSnapshot = DeploymentUtils.depSnapshot(KafkaBridgeResources.deploymentName(CLUSTER_NAME));\n+\n+        LOGGER.info(\"Changing rootLogger level to DEBUG with inline logging\");\n+        InlineLogging ilDebug = new InlineLogging();\n+        loggers.put(\"rootLogger.level\", \"DEBUG\");\n+        loggers.put(\"logger.bridge.level\", \"OFF\");\n+        loggers.put(\"logger.healthy.level\", \"OFF\");\n+        loggers.put(\"logger.ready.level\", \"OFF\");\n+        ilDebug.setLoggers(loggers);\n+\n+        KafkaBridgeResource.replaceBridgeResource(CLUSTER_NAME, bridz -> {\n+            bridz.getSpec().setLogging(ilDebug);\n+        });\n+\n+        final String bridgePodName = bridgeSnapshot.keySet().iterator().next();\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(bridgePodName, KafkaBridgeResources.deploymentName(CLUSTER_NAME), \"cat\", \"/opt/strimzi/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=DEBUG\")\n+                && cmdKubeClient().execInPodContainer(bridgePodName, KafkaBridgeResources.deploymentName(CLUSTER_NAME), \"cat\", \"/opt/strimzi/custom-config/log4j2.properties\").out().contains(\"monitorInterval=30\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for DEBUG log will appear\", LOGGING_RELOADING_INTERVAL * 2);\n+        // wait some time and check whether logs after this time contain anything\n+        Thread.sleep(LOGGING_RELOADING_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(bridgePodName, KafkaBridgeResources.deploymentName(CLUSTER_NAME), \"30s\"), is(not(emptyString())));\n+\n+        ConfigMap configMapBridge = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-bridge\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withData(Collections.singletonMap(\"log4j2.properties\",\n+                        \"name = BridgeConfig\\n\" +\n+                                \"\\n\" +\n+                                \"appender.console.type = Console\\n\" +\n+                                \"appender.console.name = STDOUT\\n\" +\n+                                \"appender.console.layout.type = PatternLayout\\n\" +\n+                                \"appender.console.layout.pattern = [%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                                \"\\n\" +\n+                                \"rootLogger.level = OFF\\n\" +\n+                                \"rootLogger.appenderRefs = console\\n\" +\n+                                \"rootLogger.appenderRef.console.ref = STDOUT\\n\" +\n+                                \"rootLogger.additivity = false\\n\" +\n+                                \"\\n\" +\n+                                \"logger.bridge.name = io.strimzi.kafka.bridge\\n\" +\n+                                \"logger.bridge.level = OFF\\n\" +\n+                                \"logger.bridge.appenderRefs = console\\n\" +\n+                                \"logger.bridge.appenderRef.console.ref = STDOUT\\n\" +\n+                                \"logger.bridge.additivity = false\\n\" +\n+                                \"\\n\" +\n+                                \"# HTTP OpenAPI specific logging levels (default is INFO)\\n\" +\n+                                \"# Logging healthy and ready endpoints is very verbose because of Kubernetes health checking.\\n\" +\n+                                \"logger.healthy.name = http.openapi.operation.healthy\\n\" +\n+                                \"logger.healthy.level = OFF\\n\" +\n+                                \"logger.ready.name = http.openapi.operation.ready\\n\" +\n+                                \"logger.ready.level = OFF\"))\n+                .build();\n+\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapBridge);\n+\n+        ExternalLogging bridgeXternalLogging = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-bridge\")\n+                .build();\n+\n+        LOGGER.info(\"Setting log level of Bridge to OFF - records should not appear in the log\");\n+        // change to the external logging\n+        KafkaBridgeResource.replaceBridgeResource(CLUSTER_NAME, bridz -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d78d96771fd18e44892fb603edba62102e1e47ce"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY5Mzg4Ng==", "bodyText": "Yeah, it is a prevention of using test-scope-var and lambda-scope-var with the same name. I can rename it if you wish so.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3311#discussion_r453693886", "createdAt": "2020-07-13T14:32:58Z", "author": {"login": "sknot-rh"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -349,6 +352,111 @@ void testDynamicallySetEOloggingLevels() throws InterruptedException {\n         assertThat(\"EO pod should not roll\", DeploymentUtils.depSnapshot(eoDeploymentName), equalTo(eoPods));\n     }\n \n+    @Test\n+    void testDynamicallySetBridgeLoggingLevels() throws InterruptedException {\n+        InlineLogging ilOff = new InlineLogging();\n+        Map<String, String> loggers = new HashMap<>();\n+        loggers.put(\"rootLogger.level\", \"OFF\");\n+        loggers.put(\"logger.bridge.level\", \"OFF\");\n+        loggers.put(\"logger.healthy.level\", \"OFF\");\n+        loggers.put(\"logger.ready.level\", \"OFF\");\n+        ilOff.setLoggers(loggers);\n+\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        KafkaBridgeResource.kafkaBridge(CLUSTER_NAME, KafkaResources.tlsBootstrapAddress(CLUSTER_NAME), 1)\n+                .editSpec()\n+                    .withInlineLogging(ilOff)\n+                .endSpec()\n+                .done();\n+\n+        Map<String, String> bridgeSnapshot = DeploymentUtils.depSnapshot(KafkaBridgeResources.deploymentName(CLUSTER_NAME));\n+\n+        LOGGER.info(\"Changing rootLogger level to DEBUG with inline logging\");\n+        InlineLogging ilDebug = new InlineLogging();\n+        loggers.put(\"rootLogger.level\", \"DEBUG\");\n+        loggers.put(\"logger.bridge.level\", \"OFF\");\n+        loggers.put(\"logger.healthy.level\", \"OFF\");\n+        loggers.put(\"logger.ready.level\", \"OFF\");\n+        ilDebug.setLoggers(loggers);\n+\n+        KafkaBridgeResource.replaceBridgeResource(CLUSTER_NAME, bridz -> {\n+            bridz.getSpec().setLogging(ilDebug);\n+        });\n+\n+        final String bridgePodName = bridgeSnapshot.keySet().iterator().next();\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(bridgePodName, KafkaBridgeResources.deploymentName(CLUSTER_NAME), \"cat\", \"/opt/strimzi/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=DEBUG\")\n+                && cmdKubeClient().execInPodContainer(bridgePodName, KafkaBridgeResources.deploymentName(CLUSTER_NAME), \"cat\", \"/opt/strimzi/custom-config/log4j2.properties\").out().contains(\"monitorInterval=30\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for DEBUG log will appear\", LOGGING_RELOADING_INTERVAL * 2);\n+        // wait some time and check whether logs after this time contain anything\n+        Thread.sleep(LOGGING_RELOADING_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(bridgePodName, KafkaBridgeResources.deploymentName(CLUSTER_NAME), \"30s\"), is(not(emptyString())));\n+\n+        ConfigMap configMapBridge = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-bridge\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withData(Collections.singletonMap(\"log4j2.properties\",\n+                        \"name = BridgeConfig\\n\" +\n+                                \"\\n\" +\n+                                \"appender.console.type = Console\\n\" +\n+                                \"appender.console.name = STDOUT\\n\" +\n+                                \"appender.console.layout.type = PatternLayout\\n\" +\n+                                \"appender.console.layout.pattern = [%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                                \"\\n\" +\n+                                \"rootLogger.level = OFF\\n\" +\n+                                \"rootLogger.appenderRefs = console\\n\" +\n+                                \"rootLogger.appenderRef.console.ref = STDOUT\\n\" +\n+                                \"rootLogger.additivity = false\\n\" +\n+                                \"\\n\" +\n+                                \"logger.bridge.name = io.strimzi.kafka.bridge\\n\" +\n+                                \"logger.bridge.level = OFF\\n\" +\n+                                \"logger.bridge.appenderRefs = console\\n\" +\n+                                \"logger.bridge.appenderRef.console.ref = STDOUT\\n\" +\n+                                \"logger.bridge.additivity = false\\n\" +\n+                                \"\\n\" +\n+                                \"# HTTP OpenAPI specific logging levels (default is INFO)\\n\" +\n+                                \"# Logging healthy and ready endpoints is very verbose because of Kubernetes health checking.\\n\" +\n+                                \"logger.healthy.name = http.openapi.operation.healthy\\n\" +\n+                                \"logger.healthy.level = OFF\\n\" +\n+                                \"logger.ready.name = http.openapi.operation.ready\\n\" +\n+                                \"logger.ready.level = OFF\"))\n+                .build();\n+\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapBridge);\n+\n+        ExternalLogging bridgeXternalLogging = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-bridge\")\n+                .build();\n+\n+        LOGGER.info(\"Setting log level of Bridge to OFF - records should not appear in the log\");\n+        // change to the external logging\n+        KafkaBridgeResource.replaceBridgeResource(CLUSTER_NAME, bridz -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY4OTYzNQ=="}, "originalCommit": {"oid": "d78d96771fd18e44892fb603edba62102e1e47ce"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcwMjk3Mw==", "bodyText": "is that a czech word? :-)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3311#discussion_r453702973", "createdAt": "2020-07-13T14:45:26Z", "author": {"login": "ppatierno"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -349,6 +352,111 @@ void testDynamicallySetEOloggingLevels() throws InterruptedException {\n         assertThat(\"EO pod should not roll\", DeploymentUtils.depSnapshot(eoDeploymentName), equalTo(eoPods));\n     }\n \n+    @Test\n+    void testDynamicallySetBridgeLoggingLevels() throws InterruptedException {\n+        InlineLogging ilOff = new InlineLogging();\n+        Map<String, String> loggers = new HashMap<>();\n+        loggers.put(\"rootLogger.level\", \"OFF\");\n+        loggers.put(\"logger.bridge.level\", \"OFF\");\n+        loggers.put(\"logger.healthy.level\", \"OFF\");\n+        loggers.put(\"logger.ready.level\", \"OFF\");\n+        ilOff.setLoggers(loggers);\n+\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        KafkaBridgeResource.kafkaBridge(CLUSTER_NAME, KafkaResources.tlsBootstrapAddress(CLUSTER_NAME), 1)\n+                .editSpec()\n+                    .withInlineLogging(ilOff)\n+                .endSpec()\n+                .done();\n+\n+        Map<String, String> bridgeSnapshot = DeploymentUtils.depSnapshot(KafkaBridgeResources.deploymentName(CLUSTER_NAME));\n+\n+        LOGGER.info(\"Changing rootLogger level to DEBUG with inline logging\");\n+        InlineLogging ilDebug = new InlineLogging();\n+        loggers.put(\"rootLogger.level\", \"DEBUG\");\n+        loggers.put(\"logger.bridge.level\", \"OFF\");\n+        loggers.put(\"logger.healthy.level\", \"OFF\");\n+        loggers.put(\"logger.ready.level\", \"OFF\");\n+        ilDebug.setLoggers(loggers);\n+\n+        KafkaBridgeResource.replaceBridgeResource(CLUSTER_NAME, bridz -> {\n+            bridz.getSpec().setLogging(ilDebug);\n+        });\n+\n+        final String bridgePodName = bridgeSnapshot.keySet().iterator().next();\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(bridgePodName, KafkaBridgeResources.deploymentName(CLUSTER_NAME), \"cat\", \"/opt/strimzi/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=DEBUG\")\n+                && cmdKubeClient().execInPodContainer(bridgePodName, KafkaBridgeResources.deploymentName(CLUSTER_NAME), \"cat\", \"/opt/strimzi/custom-config/log4j2.properties\").out().contains(\"monitorInterval=30\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for DEBUG log will appear\", LOGGING_RELOADING_INTERVAL * 2);\n+        // wait some time and check whether logs after this time contain anything\n+        Thread.sleep(LOGGING_RELOADING_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(bridgePodName, KafkaBridgeResources.deploymentName(CLUSTER_NAME), \"30s\"), is(not(emptyString())));\n+\n+        ConfigMap configMapBridge = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-bridge\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withData(Collections.singletonMap(\"log4j2.properties\",\n+                        \"name = BridgeConfig\\n\" +\n+                                \"\\n\" +\n+                                \"appender.console.type = Console\\n\" +\n+                                \"appender.console.name = STDOUT\\n\" +\n+                                \"appender.console.layout.type = PatternLayout\\n\" +\n+                                \"appender.console.layout.pattern = [%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                                \"\\n\" +\n+                                \"rootLogger.level = OFF\\n\" +\n+                                \"rootLogger.appenderRefs = console\\n\" +\n+                                \"rootLogger.appenderRef.console.ref = STDOUT\\n\" +\n+                                \"rootLogger.additivity = false\\n\" +\n+                                \"\\n\" +\n+                                \"logger.bridge.name = io.strimzi.kafka.bridge\\n\" +\n+                                \"logger.bridge.level = OFF\\n\" +\n+                                \"logger.bridge.appenderRefs = console\\n\" +\n+                                \"logger.bridge.appenderRef.console.ref = STDOUT\\n\" +\n+                                \"logger.bridge.additivity = false\\n\" +\n+                                \"\\n\" +\n+                                \"# HTTP OpenAPI specific logging levels (default is INFO)\\n\" +\n+                                \"# Logging healthy and ready endpoints is very verbose because of Kubernetes health checking.\\n\" +\n+                                \"logger.healthy.name = http.openapi.operation.healthy\\n\" +\n+                                \"logger.healthy.level = OFF\\n\" +\n+                                \"logger.ready.name = http.openapi.operation.ready\\n\" +\n+                                \"logger.ready.level = OFF\"))\n+                .build();\n+\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapBridge);\n+\n+        ExternalLogging bridgeXternalLogging = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-bridge\")\n+                .build();\n+\n+        LOGGER.info(\"Setting log level of Bridge to OFF - records should not appear in the log\");\n+        // change to the external logging\n+        KafkaBridgeResource.replaceBridgeResource(CLUSTER_NAME, bridz -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY4OTYzNQ=="}, "originalCommit": {"oid": "d78d96771fd18e44892fb603edba62102e1e47ce"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE3MTI1Ng==", "bodyText": "Kinda :)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3311#discussion_r454171256", "createdAt": "2020-07-14T07:52:43Z", "author": {"login": "sknot-rh"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -349,6 +352,111 @@ void testDynamicallySetEOloggingLevels() throws InterruptedException {\n         assertThat(\"EO pod should not roll\", DeploymentUtils.depSnapshot(eoDeploymentName), equalTo(eoPods));\n     }\n \n+    @Test\n+    void testDynamicallySetBridgeLoggingLevels() throws InterruptedException {\n+        InlineLogging ilOff = new InlineLogging();\n+        Map<String, String> loggers = new HashMap<>();\n+        loggers.put(\"rootLogger.level\", \"OFF\");\n+        loggers.put(\"logger.bridge.level\", \"OFF\");\n+        loggers.put(\"logger.healthy.level\", \"OFF\");\n+        loggers.put(\"logger.ready.level\", \"OFF\");\n+        ilOff.setLoggers(loggers);\n+\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        KafkaBridgeResource.kafkaBridge(CLUSTER_NAME, KafkaResources.tlsBootstrapAddress(CLUSTER_NAME), 1)\n+                .editSpec()\n+                    .withInlineLogging(ilOff)\n+                .endSpec()\n+                .done();\n+\n+        Map<String, String> bridgeSnapshot = DeploymentUtils.depSnapshot(KafkaBridgeResources.deploymentName(CLUSTER_NAME));\n+\n+        LOGGER.info(\"Changing rootLogger level to DEBUG with inline logging\");\n+        InlineLogging ilDebug = new InlineLogging();\n+        loggers.put(\"rootLogger.level\", \"DEBUG\");\n+        loggers.put(\"logger.bridge.level\", \"OFF\");\n+        loggers.put(\"logger.healthy.level\", \"OFF\");\n+        loggers.put(\"logger.ready.level\", \"OFF\");\n+        ilDebug.setLoggers(loggers);\n+\n+        KafkaBridgeResource.replaceBridgeResource(CLUSTER_NAME, bridz -> {\n+            bridz.getSpec().setLogging(ilDebug);\n+        });\n+\n+        final String bridgePodName = bridgeSnapshot.keySet().iterator().next();\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(bridgePodName, KafkaBridgeResources.deploymentName(CLUSTER_NAME), \"cat\", \"/opt/strimzi/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=DEBUG\")\n+                && cmdKubeClient().execInPodContainer(bridgePodName, KafkaBridgeResources.deploymentName(CLUSTER_NAME), \"cat\", \"/opt/strimzi/custom-config/log4j2.properties\").out().contains(\"monitorInterval=30\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for DEBUG log will appear\", LOGGING_RELOADING_INTERVAL * 2);\n+        // wait some time and check whether logs after this time contain anything\n+        Thread.sleep(LOGGING_RELOADING_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(bridgePodName, KafkaBridgeResources.deploymentName(CLUSTER_NAME), \"30s\"), is(not(emptyString())));\n+\n+        ConfigMap configMapBridge = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-bridge\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withData(Collections.singletonMap(\"log4j2.properties\",\n+                        \"name = BridgeConfig\\n\" +\n+                                \"\\n\" +\n+                                \"appender.console.type = Console\\n\" +\n+                                \"appender.console.name = STDOUT\\n\" +\n+                                \"appender.console.layout.type = PatternLayout\\n\" +\n+                                \"appender.console.layout.pattern = [%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                                \"\\n\" +\n+                                \"rootLogger.level = OFF\\n\" +\n+                                \"rootLogger.appenderRefs = console\\n\" +\n+                                \"rootLogger.appenderRef.console.ref = STDOUT\\n\" +\n+                                \"rootLogger.additivity = false\\n\" +\n+                                \"\\n\" +\n+                                \"logger.bridge.name = io.strimzi.kafka.bridge\\n\" +\n+                                \"logger.bridge.level = OFF\\n\" +\n+                                \"logger.bridge.appenderRefs = console\\n\" +\n+                                \"logger.bridge.appenderRef.console.ref = STDOUT\\n\" +\n+                                \"logger.bridge.additivity = false\\n\" +\n+                                \"\\n\" +\n+                                \"# HTTP OpenAPI specific logging levels (default is INFO)\\n\" +\n+                                \"# Logging healthy and ready endpoints is very verbose because of Kubernetes health checking.\\n\" +\n+                                \"logger.healthy.name = http.openapi.operation.healthy\\n\" +\n+                                \"logger.healthy.level = OFF\\n\" +\n+                                \"logger.ready.name = http.openapi.operation.ready\\n\" +\n+                                \"logger.ready.level = OFF\"))\n+                .build();\n+\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapBridge);\n+\n+        ExternalLogging bridgeXternalLogging = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-bridge\")\n+                .build();\n+\n+        LOGGER.info(\"Setting log level of Bridge to OFF - records should not appear in the log\");\n+        // change to the external logging\n+        KafkaBridgeResource.replaceBridgeResource(CLUSTER_NAME, bridz -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY4OTYzNQ=="}, "originalCommit": {"oid": "d78d96771fd18e44892fb603edba62102e1e47ce"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMjczODU3OnYy", "diffSide": "RIGHT", "path": "CHANGELOG.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwODowODozMlrOGxI8NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwODowODozMlrOGxI8NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE3OTg5Mw==", "bodyText": "maybe both on one line?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3311#discussion_r454179893", "createdAt": "2020-07-14T08:08:32Z", "author": {"login": "ppatierno"}, "path": "CHANGELOG.md", "diffHunk": "@@ -22,6 +22,7 @@\n   * enable/disable metrics in the KafkaBridge custom resource\n   * new Grafana dashboard for the bridge metrics\n * Support dynamically changeable logging in the Entity Operator \n+* Support dynamically changeable logging in the Kafka Bridge ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5880efce1e955bb454a32b3d7dd1e15074fffde2"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1446, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}