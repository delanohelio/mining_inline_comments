{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzMDQ3NTM4", "number": 2637, "title": "Prevent ZK cluster roll when scaling 3.5.x clusters ", "bodyText": "Type of change\nBugfix\nDescription\nThis PR prevents the CO rolling the ZK (3.5.x) cluster after scaling and allows the user to manually reconfigure the cluster to add or remove ZK nodes. The scaling of ZK 3.4.x clusters is unchanged.\n\nUpdated settings to allow ZK 3.5.x cluster reconfiguration\nMade the ZK config gen script support 3.4.x and 3.5.x config format\nAdded annotation to signal that the user has finished manual scaling\n\nNote: This commit will require manual user intervention to scale a 3.5.x cluster.\nChecklist\n\n Write tests\n Make sure all tests pass\n Update documentation\n Try your changes from Pod inside your Kubernetes and OpenShift cluster, not just locally\n Reference relevant issue(s) and close them after merging\n Update CHANGELOG.md", "createdAt": "2020-03-03T16:22:57Z", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637", "merged": true, "mergeCommit": {"oid": "c8269f5f61be64d4b6c75c379f2afca872408fcd"}, "closed": true, "closedAt": "2020-03-05T16:53:45Z", "author": {"login": "tomncooper"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcKFI1bAFqTM2ODEzMDUyOA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcKudB8AFqTM2OTc0MDg0Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4MTMwNTI4", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#pullrequestreview-368130528", "createdAt": "2020-03-03T16:28:10Z", "commit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNjoyODoxMFrOFxNKZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNjo0Mjo1MVrOFxNwrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDE5OA==", "bodyText": "Havig this here suggests this can be override and is just default. I think this should be in forbidden options + ardcoded in zookeeper_config_generator.sh. That probably applies also to 4lw.commands.whitelist, but I'm fine to leave that for other day.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387140198", "createdAt": "2020-03-03T16:28:10Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ZookeeperConfiguration.java", "diffHunk": "@@ -34,6 +34,8 @@\n         config.put(\"tickTime\", \"2000\");\n         config.put(\"initLimit\", \"5\");\n         config.put(\"syncLimit\", \"2\");\n+        config.put(\"standaloneEnabled\", \"false\");\n+        config.put(\"reconfigEnabled\", \"true\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MTMwNw==", "bodyText": "Should this be added tot he status in addition to printing a warning? The warning will be missed by most people.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387141307", "createdAt": "2020-03-03T16:29:42Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1356,13 +1358,21 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n             StatefulSet zkSts = zkCluster.generateStatefulSet(pfa.isOpenshift(), imagePullPolicy, imagePullSecrets);\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(Ca.ANNO_STRIMZI_IO_CLUSTER_CA_CERT_GENERATION, String.valueOf(getCaCertGeneration(this.clusterCa)));\n             Annotations.annotations(zkSts.getSpec().getTemplate()).put(AbstractModel.ANNO_STRIMZI_LOGGING_HASH, zkLoggingHash);\n+            Annotations.annotations(zkSts).put(Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, String.valueOf(zkManualScaling));\n             return withZkDiff(zkSetOperations.reconcile(namespace, zkCluster.getName(), zkSts));\n         }\n \n         Future<ReconciliationState> zkRollingUpdate() {\n-            return withVoid(zkSetOperations.maybeRollingUpdate(zkDiffs.resource(), pod ->\n-                isPodToRestart(zkDiffs.resource(), pod, existingZookeeperCertsChanged, this.clusterCa)\n-            ));\n+            if (zkManualScaling && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                log.info(\"Skipping cluster roll due to ongoing manual scaling operations. \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MTgzNA==", "bodyText": "Does this TODO still apply?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387141834", "createdAt": "2020-03-03T16:30:33Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1376,20 +1386,39 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          */\n         Future<ReconciliationState> zkScaleUpInSmallSteps() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MjY4Nw==", "bodyText": "Should this be named scaleInSmallSteps now?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387142687", "createdAt": "2020-03-03T16:31:44Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1376,20 +1386,39 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          */\n         Future<ReconciliationState> zkScaleUpInSmallSteps() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0NTUzOQ==", "bodyText": "What if the anno is missing? Will this trigger or what will it do?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387145539", "createdAt": "2020-03-03T16:36:05Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1376,20 +1386,39 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          */\n         Future<ReconciliationState> zkScaleUpInSmallSteps() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n \n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                                log.info(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                                \"update process defined in the documentation should be followed\"\n+                                );\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0OTk5OQ==", "bodyText": "Does this or the scaleDown method need to be protected by the annotation as well? IIRC you said scaleup should happen node by node ... but unless this is protected, and someone changes the replicas e.g. from 3 to 7 it scale up every reocnciliation regardless whether the user finished the manual tasks, or?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387149999", "createdAt": "2020-03-03T16:42:51Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1376,20 +1386,39 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          */\n         Future<ReconciliationState> zkScaleUpInSmallSteps() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n \n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                                log.info(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                                \"update process defined in the documentation should be followed\"\n+                                );\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // We need to check if we are still in a manual scaling operation. Only the user can set this to false\n+                                // once it has been set to true.\n+                                log.info(\"Detected manual Zookeeper scaling operation in progress\");\n+                                zkManualScaling = true;\n+                            }\n+                        }\n                         return Future.succeededFuture(this);\n                     });\n         }\n \n         Future<ReconciliationState> zkScaleUp() {\n             if (zkScalingUp) {\n                 return zkSetOperations.scaleUp(namespace, zkCluster.getName(), zkCluster.getReplicas())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fffe1e23cc30434e3241aa90213c6446390db53"}, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NjI5NzY4", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#pullrequestreview-368629768", "createdAt": "2020-03-04T09:42:41Z", "commit": {"oid": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwOTo0Mjo0MlrOFxmMjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwOTo0Mjo0MlrOFxmMjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1MDM0OQ==", "bodyText": "Please provide a brief explanation of the purpose of the procedure.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387550349", "createdAt": "2020-03-04T09:42:42Z", "author": {"login": "laidan6000"}, "path": "documentation/misc/zookeeper-manual-scaling-methods.md", "diffHunk": "@@ -0,0 +1,141 @@\n+# Zookeeper 3.5.x Manual Scaling Procedures\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb"}, "originalPosition": 2}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NjM5Mzc0", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#pullrequestreview-368639374", "createdAt": "2020-03-04T09:55:48Z", "commit": {"oid": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwOTo1NTo0OFrOFxmqBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDowMDoyM1rOFxm0hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1Nzg5Mg==", "bodyText": "We \u2192 The Cluster Operator", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387557892", "createdAt": "2020-03-04T09:55:48Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ZookeeperConfiguration.java", "diffHunk": "@@ -29,13 +29,18 @@\n         FORBIDDEN_OPTIONS.addAll(Arrays.asList(ZookeeperClusterSpec.FORBIDDEN_PREFIXES.split(\" *, *\")));\n         // This option is handled in the Zookeeper container startup script\n         FORBIDDEN_OPTIONS.add(\"snapshot.trust.empty\");\n+        // This option would prevent scaling beyond 1 node for clusters started with a single node\n+        FORBIDDEN_OPTIONS.add(\"standaloneEnabled\");\n+        // Reconfiguration needs to be enabled to allow scaling of the cluster\n+        FORBIDDEN_OPTIONS.add(\"reconfigEnabled\");\n+        // We require access to multiple 4LW and access to the nodes is secured by the TLS-Sidecars so we set all allowed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU2MDU4MA==", "bodyText": "Do you mean for the Future returned by this method to have completed before the status has been updated?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387560580", "createdAt": "2020-03-04T10:00:23Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1384,91 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = new ConditionBuilder()\n+                                    .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                    .withType(\"ZK-Manual-Scaling\");\n+\n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" annotation to false.\";\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = \"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until \" +\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" annotation is set to false.\";\n \n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+\n+                            } else {\n+                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n+                                zkManualScalingCondition\n+                                        .withStatus(\"False\")\n+                                        .withReason(\"manualScalingNotRequired\");\n+\n+                                if (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0) {\n+                                    zkManualScalingCondition\n+                                            .withMessage(\"Manual scaling of Zookeeper cluster is finished or not required\");\n+                                } else {\n+                                    zkManualScalingCondition\n+                                            .withMessage(\"Manual scaling of Zookeeper cluster is not needed for Zookeeper 3.4.x clusters\");\n+                                }\n+\n+                                zkManualScaling = false;\n+                            }\n+\n+                            KafkaStatus kStatus = this.kafkaStatus;\n+                            kStatus.setConditions(Collections.singletonList(zkManualScalingCondition.build()));\n+                            this.updateStatus(kStatus).setHandler(statusResult -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb"}, "originalPosition": 123}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NzExNTY4", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#pullrequestreview-368711568", "createdAt": "2020-03-04T11:46:18Z", "commit": {"oid": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMTo1MTowOFrOFxqR5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMjowNToxMFrOFxqqMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxNzI1Mg==", "bodyText": "Should \"3.4.99\" be in a variable. Also this line isn't very readable, would it make sense to wrap the zk version check in a helper function with a readable name?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387617252", "createdAt": "2020-03-04T11:51:08Z", "author": {"login": "katheris"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1384,91 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = new ConditionBuilder()\n+                                    .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                    .withType(\"ZK-Manual-Scaling\");\n+\n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxNzU3NQ==", "bodyText": "There is duplicate code here, so again a helper function would read better.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387617575", "createdAt": "2020-03-04T11:51:50Z", "author": {"login": "katheris"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1384,91 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = new ConditionBuilder()\n+                                    .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                    .withType(\"ZK-Manual-Scaling\");\n+\n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" annotation to false.\";\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = \"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until \" +\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE + \" annotation is set to false.\";\n \n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+\n+                            } else {\n+                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n+                                zkManualScalingCondition\n+                                        .withStatus(\"False\")\n+                                        .withReason(\"manualScalingNotRequired\");\n+\n+                                if (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxODUyNA==", "bodyText": "Might be nice to use string formatting here rather than all the concatenations.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387618524", "createdAt": "2020-03-04T11:53:48Z", "author": {"login": "katheris"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1384,91 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n+                                // TODO: For ZK 3.5.x we need to limit scaling to 1 at a time. Should we enforce that here?\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && zkCluster.getReplicas() < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = new ConditionBuilder()\n+                                    .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                    .withType(\"ZK-Manual-Scaling\");\n+\n+                            if ((zkScalingUp || zkScalingDown) && (KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0)) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYyMzQ3NQ==", "bodyText": "It might read easier to have an Optional here rather than the ternary operator.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387623475", "createdAt": "2020-03-04T12:05:10Z", "author": {"login": "katheris"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ZookeeperCluster.java", "diffHunk": "@@ -181,16 +182,18 @@ public static ZookeeperCluster fromCrd(Kafka kafkaAssembly, KafkaVersion.Lookup\n         if (replicas <= 0) {\n             replicas = ZookeeperClusterSpec.DEFAULT_REPLICAS;\n         }\n-\n         if (replicas == 1 && zookeeperClusterSpec.getStorage() != null && \"ephemeral\".equals(zookeeperClusterSpec.getStorage().getType())) {\n             log.warn(\"A ZooKeeper cluster with a single replica and ephemeral storage will be in a defective state after any restart or rolling update. It is recommended that a minimum of three replicas are used.\");\n         }\n-\n         zk.setReplicas(replicas);\n \n+        // Get the ZK version information from either the CRD or from the default setting\n+        KafkaClusterSpec kafkaClusterSpec = kafkaAssembly.getSpec().getKafka();\n+        String version = versions.version(kafkaClusterSpec != null ? kafkaClusterSpec.getVersion() : null).zookeeperVersion();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e95a9ba1fb9c3324d8b38c9eeadb29af6021e0fb"}, "originalPosition": 21}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "14f2892e9b0d97236b2f42ae55e4a9055936d860", "author": {"user": {"login": "tomncooper", "name": "Thomas Cooper"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/14f2892e9b0d97236b2f42ae55e4a9055936d860", "committedDate": "2020-03-04T14:16:12Z", "message": "Added logic to fail (with status) the reconciliation zk scale of more than one is set\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>"}, "afterCommit": {"oid": "1b8bc84b83bc553b0b5898bbddedb0de09e9b302", "author": {"user": {"login": "tomncooper", "name": "Thomas Cooper"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/1b8bc84b83bc553b0b5898bbddedb0de09e9b302", "committedDate": "2020-03-04T14:16:35Z", "message": "Added logic to fail (with status) the reconciliation zk scale of more than one is set\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODQ0MTkx", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#pullrequestreview-368844191", "createdAt": "2020-03-04T14:53:52Z", "commit": {"oid": "1b8bc84b83bc553b0b5898bbddedb0de09e9b302"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDo1Mzo1MlrOFxwaAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDo1Mzo1MlrOFxwaAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcxNzYzNA==", "bodyText": "Can we put the failedResult lambda on a new line? It's easily missed otherwise.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387717634", "createdAt": "2020-03-04T14:53:52Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1384,122 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            ConditionBuilder zkManualScalingCondition = new ConditionBuilder()\n+                                    .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                    .withType(\"ZK-Manual-Scaling\");\n+\n+                            if (currentReplicas > 0 && isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log and update status with the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"replicaChangeGreaterThanOne\")\n+                                        .withStatus(\"False\")\n+                                        .withMessage(scaleErrorMessage);\n+\n+                                KafkaStatus kStatus = this.kafkaStatus;\n+                                kStatus.setConditions(Collections.singletonList(zkManualScalingCondition.build()));\n+                                return this.updateStatus(kStatus).compose(successResult -> {\n+                                    log.debug(\"Status for {} is up to date\", kafkaAssembly.getMetadata().getName());\n+                                    return Future.succeededFuture(); }, failedResult -> {\n+                                        log.error(\"Failed to set status for {}\", kafkaAssembly.getMetadata().getName());\n+                                        return Future.succeededFuture();\n+                                    }).compose(result -> Future.failedFuture(new IllegalArgumentException(scaleErrorMessage)));\n+\n+                            } else if (currentReplicas > 0 && desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = String.format(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                         \"%s annotation to false.\", Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n \n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = String.format(\"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until %s annotation is set to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+\n+                            } else {\n+                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n+                                zkManualScalingCondition\n+                                        .withStatus(\"False\")\n+                                        .withReason(\"manualScalingNotRequired\");\n+\n+                                if (isZK35x) {\n+                                    zkManualScalingCondition\n+                                            .withMessage(\"Manual scaling of Zookeeper cluster is finished or not required\");\n+                                } else {\n+                                    zkManualScalingCondition\n+                                            .withMessage(\"Manual scaling of Zookeeper cluster is not needed for Zookeeper 3.4.x clusters\");\n+                                }\n+\n+                                zkManualScaling = false;\n+                            }\n+\n+                            KafkaStatus kStatus = this.kafkaStatus;\n+                            kStatus.setConditions(Collections.singletonList(zkManualScalingCondition.build()));\n+                            return this.updateStatus(kStatus).compose(successResult -> {\n+                                log.debug(\"Status for {} is up to date\", kafkaAssembly.getMetadata().getName());\n+                                return Future.succeededFuture(); }, failedResult -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b8bc84b83bc553b0b5898bbddedb0de09e9b302"}, "originalPosition": 157}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MDY5NjUw", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#pullrequestreview-369069650", "createdAt": "2020-03-04T19:43:41Z", "commit": {"oid": "78764a4ea39e7beb7625e0560e4886f390c0ed90"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOTo0Mzo0MlrOFx7H0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOTo0Nzo1OFrOFx7RPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg5MzIwMQ==", "bodyText": "This needs some more explaining about the port name (why 21813 and how does it change for other ports.)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387893201", "createdAt": "2020-03-04T19:43:42Z", "author": {"login": "scholzj"}, "path": "documentation/misc/zookeeper-manual-scaling-methods.md", "diffHunk": "@@ -0,0 +1,149 @@\n+# Zookeeper 3.5.x Manual Scaling Procedures\n+\n+Zookeeper 3.5.x uses a new configuration procedure compare to 3.4.x servers. This \n+[dynamic reconfiguration](https://zookeeper.apache.org/doc/r3.5.7/zookeeperReconfig.html) means that servers need to be\n+added and removed via the Zookeeper command line client (or Admin API) in order to properly maintain a stable Zookeeper \n+cluster. \n+\n+The procedures below outline the steps required to scale up (add) and scale down (remove) servers from an existing \n+Strimzi Kafka deployment.\n+\n+## Scale up procedure\n+\n+The cluster should be scaled **one server at a time**. \n+\n+1) Create an initial Strimzi cluster with n=3 replicas (3 Kafka + 3 ZK servers).\n+\n+2) Set the replica count to n=4 in the zookeeper section of the Kafka CR.\n+\n+3) Allow the ZK server (zookeeper-3) to start up normally and establish a link to the existing quorum.\n+\n+This can be checked with the following command:\n+\n+```\n+kubectl exec -n myproject -it my-cluster-zookeeper-3 -c zookeeper -- bash -c \"echo 'srvr' | nc 127.0.0.1 21813 | grep 'Mode:'\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78764a4ea39e7beb7625e0560e4886f390c0ed90"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg5NTYxNQ==", "bodyText": "This needs to again stress out the differences ... and also point out that the server.X has different index than all the ports.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r387895615", "createdAt": "2020-03-04T19:47:58Z", "author": {"login": "scholzj"}, "path": "documentation/misc/zookeeper-manual-scaling-methods.md", "diffHunk": "@@ -0,0 +1,149 @@\n+# Zookeeper 3.5.x Manual Scaling Procedures\n+\n+Zookeeper 3.5.x uses a new configuration procedure compare to 3.4.x servers. This \n+[dynamic reconfiguration](https://zookeeper.apache.org/doc/r3.5.7/zookeeperReconfig.html) means that servers need to be\n+added and removed via the Zookeeper command line client (or Admin API) in order to properly maintain a stable Zookeeper \n+cluster. \n+\n+The procedures below outline the steps required to scale up (add) and scale down (remove) servers from an existing \n+Strimzi Kafka deployment.\n+\n+## Scale up procedure\n+\n+The cluster should be scaled **one server at a time**. \n+\n+1) Create an initial Strimzi cluster with n=3 replicas (3 Kafka + 3 ZK servers).\n+\n+2) Set the replica count to n=4 in the zookeeper section of the Kafka CR.\n+\n+3) Allow the ZK server (zookeeper-3) to start up normally and establish a link to the existing quorum.\n+\n+This can be checked with the following command:\n+\n+```\n+kubectl exec -n myproject -it my-cluster-zookeeper-3 -c zookeeper -- bash -c \"echo 'srvr' | nc 127.0.0.1 21813 | grep 'Mode:'\"\n+```\n+\n+Which should show something like:\n+\n+```\n+Mode: follower\n+```\n+\n+4) Open a zookeeper-shell session on one of the nodes in the original cluster (in this case nodes 0, 1 or 2):\n+\n+```\n+kubectl exec -n myproject -it my-cluster-zookeeper-0 -c zookeeper -- ./bin/zookeeper-shell.sh localhost:21810\n+```\n+\n+5) Enter the following line to add the new server to the quorum as a voting member:\n+\n+```\n+reconfig -add server.4=127.0.0.1:28883:38883:participant;127.0.0.1:21813", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78764a4ea39e7beb7625e0560e4886f390c0ed90"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MzE5NTE0", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#pullrequestreview-369319514", "createdAt": "2020-03-05T06:22:48Z", "commit": {"oid": "78764a4ea39e7beb7625e0560e4886f390c0ed90"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNjoyMjo0OFrOFyHnPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNjozMDo1OFrOFyHwHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5Nzg1Mg==", "bodyText": "just one line using a ternary operator instead of this if/else block?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388097852", "createdAt": "2020-03-05T06:22:48Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -217,7 +217,15 @@ public KafkaAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n                         .build();\n             }\n \n-            status.setConditions(Collections.singletonList(readyCondition));\n+            List<Condition> oldConditions = status.getConditions();\n+            List<Condition> newConditions;\n+            if (oldConditions != null) {\n+                newConditions = new ArrayList<>(oldConditions);\n+            } else {\n+                newConditions = new ArrayList<>();\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78764a4ea39e7beb7625e0560e4886f390c0ed90"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5ODc4MA==", "bodyText": "Ditto as above", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388098780", "createdAt": "2020-03-05T06:26:06Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1392,106 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (currentReplicas > 0 && isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (currentReplicas > 0 && desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = new ConditionBuilder()\n+                                    .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                    .withType(\"ZK-Manual-Scaling\");\n+\n+                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = String.format(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                         \"%s annotation to false.\", Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n \n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = String.format(\"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until %s annotation is set to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+\n+                            } else {\n+                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n+                                if (isZK35x) {\n+                                    zkManualScalingCondition\n+                                            .withStatus(\"False\")\n+                                            .withReason(\"manualScalingNotRequired\")\n+                                            .withMessage(\"Manual scaling of Zookeeper cluster is finished or not required\");\n+                                }\n+\n+                                zkManualScaling = false;\n+                            }\n+\n+                            List<Condition> oldConditions = this.kafkaStatus.getConditions();\n+                            List<Condition> newConditions;\n+                            if (oldConditions != null) {\n+                                newConditions = new ArrayList<>(oldConditions);\n+                            } else {\n+                                newConditions = new ArrayList<>();\n+                            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78764a4ea39e7beb7625e0560e4886f390c0ed90"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5ODk3Mg==", "bodyText": "I see all three conditions verifying currentReplicas > 0. What if for any reason currentReplicas is zero?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388098972", "createdAt": "2020-03-05T06:26:48Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1392,106 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (currentReplicas > 0 && isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (currentReplicas > 0 && desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (currentReplicas > 0 && desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78764a4ea39e7beb7625e0560e4886f390c0ed90"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5OTc3OQ==", "bodyText": "You should also be more generic about the namespace (myproject) and the cluster name (my-cluster) I think.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388099779", "createdAt": "2020-03-05T06:29:50Z", "author": {"login": "ppatierno"}, "path": "documentation/misc/zookeeper-manual-scaling-methods.md", "diffHunk": "@@ -0,0 +1,149 @@\n+# Zookeeper 3.5.x Manual Scaling Procedures\n+\n+Zookeeper 3.5.x uses a new configuration procedure compare to 3.4.x servers. This \n+[dynamic reconfiguration](https://zookeeper.apache.org/doc/r3.5.7/zookeeperReconfig.html) means that servers need to be\n+added and removed via the Zookeeper command line client (or Admin API) in order to properly maintain a stable Zookeeper \n+cluster. \n+\n+The procedures below outline the steps required to scale up (add) and scale down (remove) servers from an existing \n+Strimzi Kafka deployment.\n+\n+## Scale up procedure\n+\n+The cluster should be scaled **one server at a time**. \n+\n+1) Create an initial Strimzi cluster with n=3 replicas (3 Kafka + 3 ZK servers).\n+\n+2) Set the replica count to n=4 in the zookeeper section of the Kafka CR.\n+\n+3) Allow the ZK server (zookeeper-3) to start up normally and establish a link to the existing quorum.\n+\n+This can be checked with the following command:\n+\n+```\n+kubectl exec -n myproject -it my-cluster-zookeeper-3 -c zookeeper -- bash -c \"echo 'srvr' | nc 127.0.0.1 21813 | grep 'Mode:'\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg5MzIwMQ=="}, "originalCommit": {"oid": "78764a4ea39e7beb7625e0560e4886f390c0ed90"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA5OTg2NQ==", "bodyText": "ditto as above.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388099865", "createdAt": "2020-03-05T06:30:09Z", "author": {"login": "ppatierno"}, "path": "documentation/misc/zookeeper-manual-scaling-methods.md", "diffHunk": "@@ -0,0 +1,149 @@\n+# Zookeeper 3.5.x Manual Scaling Procedures\n+\n+Zookeeper 3.5.x uses a new configuration procedure compare to 3.4.x servers. This \n+[dynamic reconfiguration](https://zookeeper.apache.org/doc/r3.5.7/zookeeperReconfig.html) means that servers need to be\n+added and removed via the Zookeeper command line client (or Admin API) in order to properly maintain a stable Zookeeper \n+cluster. \n+\n+The procedures below outline the steps required to scale up (add) and scale down (remove) servers from an existing \n+Strimzi Kafka deployment.\n+\n+## Scale up procedure\n+\n+The cluster should be scaled **one server at a time**. \n+\n+1) Create an initial Strimzi cluster with n=3 replicas (3 Kafka + 3 ZK servers).\n+\n+2) Set the replica count to n=4 in the zookeeper section of the Kafka CR.\n+\n+3) Allow the ZK server (zookeeper-3) to start up normally and establish a link to the existing quorum.\n+\n+This can be checked with the following command:\n+\n+```\n+kubectl exec -n myproject -it my-cluster-zookeeper-3 -c zookeeper -- bash -c \"echo 'srvr' | nc 127.0.0.1 21813 | grep 'Mode:'\"\n+```\n+\n+Which should show something like:\n+\n+```\n+Mode: follower\n+```\n+\n+4) Open a zookeeper-shell session on one of the nodes in the original cluster (in this case nodes 0, 1 or 2):\n+\n+```\n+kubectl exec -n myproject -it my-cluster-zookeeper-0 -c zookeeper -- ./bin/zookeeper-shell.sh localhost:21810", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78764a4ea39e7beb7625e0560e4886f390c0ed90"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEwMDEyNw==", "bodyText": "you know ;-)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388100127", "createdAt": "2020-03-05T06:30:58Z", "author": {"login": "ppatierno"}, "path": "documentation/misc/zookeeper-manual-scaling-methods.md", "diffHunk": "@@ -0,0 +1,149 @@\n+# Zookeeper 3.5.x Manual Scaling Procedures\n+\n+Zookeeper 3.5.x uses a new configuration procedure compare to 3.4.x servers. This \n+[dynamic reconfiguration](https://zookeeper.apache.org/doc/r3.5.7/zookeeperReconfig.html) means that servers need to be\n+added and removed via the Zookeeper command line client (or Admin API) in order to properly maintain a stable Zookeeper \n+cluster. \n+\n+The procedures below outline the steps required to scale up (add) and scale down (remove) servers from an existing \n+Strimzi Kafka deployment.\n+\n+## Scale up procedure\n+\n+The cluster should be scaled **one server at a time**. \n+\n+1) Create an initial Strimzi cluster with n=3 replicas (3 Kafka + 3 ZK servers).\n+\n+2) Set the replica count to n=4 in the zookeeper section of the Kafka CR.\n+\n+3) Allow the ZK server (zookeeper-3) to start up normally and establish a link to the existing quorum.\n+\n+This can be checked with the following command:\n+\n+```\n+kubectl exec -n myproject -it my-cluster-zookeeper-3 -c zookeeper -- bash -c \"echo 'srvr' | nc 127.0.0.1 21813 | grep 'Mode:'\"\n+```\n+\n+Which should show something like:\n+\n+```\n+Mode: follower\n+```\n+\n+4) Open a zookeeper-shell session on one of the nodes in the original cluster (in this case nodes 0, 1 or 2):\n+\n+```\n+kubectl exec -n myproject -it my-cluster-zookeeper-0 -c zookeeper -- ./bin/zookeeper-shell.sh localhost:21810\n+```\n+\n+5) Enter the following line to add the new server to the quorum as a voting member:\n+\n+```\n+reconfig -add server.4=127.0.0.1:28883:38883:participant;127.0.0.1:21813\n+```\n+\n+This should then show the new cluster configuration:\n+\n+```\n+server.1=127.0.0.1:28880:38880:participant;127.0.0.1:21810\n+server.2=127.0.0.1:28881:38881:participant;127.0.0.1:21811\n+server.3=127.0.0.1:28882:38882:participant;127.0.0.1:21812\n+server.4=127.0.0.1:28883:38883:participant;127.0.0.1:21813\n+version=100000054\n+```\n+ \n+This new configuration will then propagate to the other servers in the ZK cluster and the new server should now be a full member of the quorum.\n+ \n+6) Increase the replica count by 1 (n=5) in the zookeeper section of the Kafka CR.\n+\n+7) Allow the ZK server (zookeeper-<n-1>) to start up normally and establish a link to the existing quorum.\n+\n+This can be checked with the following command:\n+\n+```\n+kubectl exec -n myproject -it my-cluster-zookeeper-<n-1> -c zookeeper -- bash -c \"echo 'srvr' | nc 127.0.0.1 2181<n-1> | grep 'Mode:'\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78764a4ea39e7beb7625e0560e4886f390c0ed90"}, "originalPosition": 64}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "78764a4ea39e7beb7625e0560e4886f390c0ed90", "author": {"user": {"login": "tomncooper", "name": "Thomas Cooper"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/78764a4ea39e7beb7625e0560e4886f390c0ed90", "committedDate": "2020-03-04T16:46:45Z", "message": "Removed status update call in scaling setup method\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>"}, "afterCommit": {"oid": "83a762e3b8997ff8e16f72c6698c90db6597c36f", "author": {"user": {"login": "tomncooper", "name": "Thomas Cooper"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/83a762e3b8997ff8e16f72c6698c90db6597c36f", "committedDate": "2020-03-05T10:03:50Z", "message": "Addressed comments on ZK scaling procedures\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "83a762e3b8997ff8e16f72c6698c90db6597c36f", "author": {"user": {"login": "tomncooper", "name": "Thomas Cooper"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/83a762e3b8997ff8e16f72c6698c90db6597c36f", "committedDate": "2020-03-05T10:03:50Z", "message": "Addressed comments on ZK scaling procedures\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>"}, "afterCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c", "author": {"user": {"login": "tomncooper", "name": "Thomas Cooper"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/a22a3174c8dad0cf2939b7354d1212c66922b31c", "committedDate": "2020-03-05T11:24:09Z", "message": "Added logic to prevent ZK cluster roll when scaling 3.5.x clusters\n\n    * Updated settings to allow ZK 3.5.x cluster reconfiguration\n    * Switched ZK reconfig settings to be forbidden\n    * Made the ZK config gen script support 3.4.x and 3.5.x config\n      format\n    * Added annotation to signal that the user has finished manual\n      scaling\n    * Refactored zkScaleUpInSmallSteps to zkScalingSetup and added status updates\n    * Added logic to fail (with status) the reconciliation zk scale of more than one is set\n    * Added ZK 3.5.x scaling procedures document\n\nNote: This commit will require manual user intervention to scale a 3.5.x\ncluster.\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NTE1NzM5", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#pullrequestreview-369515739", "createdAt": "2020-03-05T12:07:58Z", "commit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMjowNzo1OVrOFyRGWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMjoyMjoxNlrOFyRfDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1MzI3NQ==", "bodyText": "Why do you create a new ArrayList and not just add it to the existing if it exists?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388253275", "createdAt": "2020-03-05T12:07:59Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -217,7 +217,10 @@ public KafkaAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n                         .build();\n             }\n \n-            status.setConditions(Collections.singletonList(readyCondition));\n+            List<Condition> oldConditions = status.getConditions();\n+            List<Condition> newConditions = oldConditions != null ? new ArrayList<>(oldConditions) : new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1MzgyNQ==", "bodyText": "I guess we should probably fix the JavaDoc?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388253825", "createdAt": "2020-03-05T12:09:21Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1NTA4OA==", "bodyText": "I'm not sure I understand the comment, because at this point you do not know this is 3.4 or 3.5 - it is not part of this particular else if, or?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388255088", "createdAt": "2020-03-05T12:12:13Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1NjQ2MQ==", "bodyText": "Do we need the empty line here?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388256461", "createdAt": "2020-03-05T12:15:14Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1ODg1MQ==", "bodyText": "If I read the code right, the initial status from line 1435 will be there only until the next reocnciliation which will replace it with the next one. That sounds like very short time and possibly people might not see it. Maybe you can add some parts of that message here as well to make the status more clear (such as the reference to the docs etc.).", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388258851", "createdAt": "2020-03-05T12:20:36Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = null;\n+\n+                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = String.format(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                         \"%s annotation on the Zookeeper StatefulSet to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n \n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = String.format(\"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until %s annotation is set to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition = new ConditionBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1OTI2Nw==", "bodyText": "I don't like nitpicking about empty lines, but it really hits me in the eyes that half of the code has empty line before } and the other half doesn't.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388259267", "createdAt": "2020-03-05T12:21:32Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = null;\n+\n+                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = String.format(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                         \"%s annotation on the Zookeeper StatefulSet to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n \n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = String.format(\"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until %s annotation is set to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1OTU5Ng==", "bodyText": "Again, what is the advantage of always creating new ArrayList over using the old one if it already exists? Also, this code seems to be used now at least twice - maybe we can factor it out?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#discussion_r388259596", "createdAt": "2020-03-05T12:22:16Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1374,22 +1387,99 @@ private KafkaVersionChange getKafkaVersionChange(StatefulSet kafkaSts) {\n          * There is one special case of scaling from standalone (single one) Zookeeper pod.\n          * In this case quorum cannot be preserved.\n          */\n-        Future<ReconciliationState> zkScaleUpInSmallSteps() {\n+        Future<ReconciliationState> zkScalingSetup() {\n             return zkSetOperations.getAsync(namespace, ZookeeperCluster.zookeeperClusterName(name))\n-                    .map(sts -> sts == null ? Integer.valueOf(0) : sts.getSpec().getReplicas())\n-                    .compose(currentReplicas -> {\n-                        if (currentReplicas > 0 && zkCluster.getReplicas() > currentReplicas) {\n-                            zkCluster.setReplicas(currentReplicas + 1);\n-                            zkScalingUp = true;\n-                        }\n+                    .compose(sts -> {\n+                        if (sts != null) {\n+                            int currentReplicas = sts.getSpec().getReplicas();\n+                            int desiredReplicas = zkCluster.getReplicas();\n+                            int replicaDiff = Math.abs(currentReplicas - desiredReplicas);\n+                            boolean isZK35x = KafkaVersion.compareDottedVersions(zkCluster.getVersion(), \"3.4.99\") > 0;\n+\n+                            if (isZK35x && replicaDiff > 1) {\n+                                // If the user is scaling a 3.5.x cluster and has specified as scale up or down of more than one\n+                                // then log the error and throw an exception halting the reconciliation.\n+\n+                                String scaleErrorMessage = String.format(\n+                                        \"Scaling of Zookeeper 3.5.x clusters must be done in steps of one only. \" +\n+                                                \"A change of %d was specified. Please set the Zookeeper replica count \" +\n+                                                \"to one greater or lesser than the original value (%d).\",\n+                                        replicaDiff, currentReplicas);\n+\n+                                log.error(scaleErrorMessage);\n+\n+                                return Future.failedFuture(new IllegalArgumentException(scaleErrorMessage));\n+\n+                            } else if (desiredReplicas > currentReplicas) {\n+                                // If this is a scale up of a 3.4.x cluster we want to scale in steps of one at a time\n+                                // automatically.\n+                                zkCluster.setReplicas(currentReplicas + 1);\n+                                zkScalingUp = true;\n+                            } else if (desiredReplicas < currentReplicas) {\n+                                zkScalingDown = true;\n+                            }\n+\n+                            ConditionBuilder zkManualScalingCondition = null;\n+\n+                            if ((zkScalingUp || zkScalingDown) && isZK35x) {\n+                                // This is a scale up or down of a ZK 3.5.x cluster\n+\n+                                String scaleMessage = String.format(\n+                                        \"Scaling Zookeeper 3.5.x cluster: Rolling updates will be skipped and the manual \" +\n+                                        \"update process defined in the documentation should be followed. When finished set \" +\n+                                         \"%s annotation on the Zookeeper StatefulSet to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n \n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"replicaChange\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                // Setting this will add the annotation to the STS in the state.zkStatefulSet() method\n+                                zkManualScaling = true;\n+\n+                            } else if (Annotations.booleanAnnotation(sts, Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE, false)) {\n+                                // This is an on-going manual scaling operation. Once the annotation has been set to true by the operator\n+                                // only the user can set it to false.\n+                                String scaleMessage = String.format(\"Detected manual Zookeeper scaling operation in progress. \" +\n+                                        \"Rolling of Zookeeper cluster will remain disabled until %s annotation is set to false.\",\n+                                        Annotations.ANNO_STRIMZI_IO_MANUAL_ZK_SCALE);\n+\n+                                log.info(scaleMessage);\n+\n+                                zkManualScalingCondition = new ConditionBuilder()\n+                                        .withLastTransitionTime(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").format(dateSupplier()))\n+                                        .withType(\"ZK-Manual-Scaling\")\n+                                        .withReason(\"manualScaleAnnotationSet\")\n+                                        .withStatus(\"True\")\n+                                        .withMessage(scaleMessage);\n+\n+                                zkManualScaling = true;\n+\n+                            } else {\n+                                // Either this is a ZK 3.4.x cluster or the user is not manually scaling the 3.5.x cluster.\n+                                zkManualScaling = false;\n+                            }\n+\n+                            if (zkManualScalingCondition != null && isZK35x) {\n+                                List<Condition> oldConditions = this.kafkaStatus.getConditions();\n+                                List<Condition> newConditions = oldConditions != null ? new ArrayList<>(oldConditions) : new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c"}, "originalPosition": 146}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e65be260c341df1c39e883d3179b1d898af45aab", "author": {"user": {"login": "tomncooper", "name": "Thomas Cooper"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e65be260c341df1c39e883d3179b1d898af45aab", "committedDate": "2020-03-05T15:42:22Z", "message": "Added logic to prevent ZK cluster roll when scaling 3.5.x clusters\n\n    * Updated settings to allow ZK 3.5.x cluster reconfiguration\n    * Switched ZK reconfig settings to be forbidden\n    * Made the ZK config gen script support 3.4.x and 3.5.x config\n      format\n    * Added annotation to signal that the user has finished manual\n      scaling\n    * Refactored zkScaleUpInSmallSteps to zkScalingSetup and added status updates\n    * Added logic to fail (with status) the reconciliation zk scale of more than one is set\n    * Added ZK 3.5.x scaling procedures document\n    * Added condition adding method to Status class\n\nNote: This commit will require manual user intervention to scale a 3.5.x\ncluster.\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a22a3174c8dad0cf2939b7354d1212c66922b31c", "author": {"user": {"login": "tomncooper", "name": "Thomas Cooper"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/a22a3174c8dad0cf2939b7354d1212c66922b31c", "committedDate": "2020-03-05T11:24:09Z", "message": "Added logic to prevent ZK cluster roll when scaling 3.5.x clusters\n\n    * Updated settings to allow ZK 3.5.x cluster reconfiguration\n    * Switched ZK reconfig settings to be forbidden\n    * Made the ZK config gen script support 3.4.x and 3.5.x config\n      format\n    * Added annotation to signal that the user has finished manual\n      scaling\n    * Refactored zkScaleUpInSmallSteps to zkScalingSetup and added status updates\n    * Added logic to fail (with status) the reconciliation zk scale of more than one is set\n    * Added ZK 3.5.x scaling procedures document\n\nNote: This commit will require manual user intervention to scale a 3.5.x\ncluster.\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>"}, "afterCommit": {"oid": "e65be260c341df1c39e883d3179b1d898af45aab", "author": {"user": {"login": "tomncooper", "name": "Thomas Cooper"}}, "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e65be260c341df1c39e883d3179b1d898af45aab", "committedDate": "2020-03-05T15:42:22Z", "message": "Added logic to prevent ZK cluster roll when scaling 3.5.x clusters\n\n    * Updated settings to allow ZK 3.5.x cluster reconfiguration\n    * Switched ZK reconfig settings to be forbidden\n    * Made the ZK config gen script support 3.4.x and 3.5.x config\n      format\n    * Added annotation to signal that the user has finished manual\n      scaling\n    * Refactored zkScaleUpInSmallSteps to zkScalingSetup and added status updates\n    * Added logic to fail (with status) the reconciliation zk scale of more than one is set\n    * Added ZK 3.5.x scaling procedures document\n    * Added condition adding method to Status class\n\nNote: This commit will require manual user intervention to scale a 3.5.x\ncluster.\n\nSigned-off-by: Thomas Cooper <tcooper@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NzQwODQ2", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2637#pullrequestreview-369740846", "createdAt": "2020-03-05T16:52:40Z", "commit": {"oid": "e65be260c341df1c39e883d3179b1d898af45aab"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1748, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}