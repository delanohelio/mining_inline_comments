{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc5MTI3NTU4", "number": 3603, "reviewThreads": {"totalCount": 43, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoyMTowNFrOEgSj_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QyMDo1NToyMlrOEhBeuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjk0MDEyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoyMTowNFrOHNEXUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo1NzowN1rOHNFlDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2NTA0Mg==", "bodyText": "Aren't arrays Objects too?  I know this is petty, but the fact that the new KafkaListeners handles objects or arrays is surely an implementations details (and therefore should be doc commented or made clear through the flow of the code?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483465042", "createdAt": "2020-09-04T08:21:04Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2OTM5Mg==", "bodyText": "While it's true that in Java arrays are reference types, this is about the JSON schema and in JSON array and object are considered separate types. To me the name makes sense.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483469392", "createdAt": "2020-09-04T08:29:07Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2NTA0Mg=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ4MDUyNg==", "bodyText": "Well, in YAML this is very different. But if you propose a better name I'm fine to use it. I think this describes the two form fairly well, but I agree it is a bit weird name.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483480526", "createdAt": "2020-09-04T08:49:23Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2NTA0Mg=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ4NDk0MQ==", "bodyText": "Ah fair, I hadn't thought through the meaning in JSON.\nGiven this is in the API, I agree this name names sense as it is a serializer.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483484941", "createdAt": "2020-09-04T08:57:07Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2NTA0Mg=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjk0NDI0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoyMjoxMFrOHNEZug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoyMjoxMFrOHNEZug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2NTY1OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public List<GenericKafkaListener> getListValue() {\n          \n          \n            \n                public List<GenericKafkaListener> getGenericKafkaListeners() {", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483465658", "createdAt": "2020-09-04T08:22:10Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final List<GenericKafkaListener> listValue;\n+    private final KafkaListeners objectValue;\n+\n+    public ArrayOrObjectKafkaListeners(List<GenericKafkaListener> listValue)   {\n+        this.listValue = listValue;\n+        this.objectValue = null;\n+    }\n+\n+    public ArrayOrObjectKafkaListeners(KafkaListeners objectValue)   {\n+        this.listValue = null;\n+        this.objectValue = objectValue;\n+    }\n+\n+    @Alternative()\n+    public List<GenericKafkaListener> getListValue() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjk0NTA1OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoyMjoyNVrOHNEaRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoyMjoyNVrOHNEaRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2NTc5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public KafkaListeners getObjectValue() {\n          \n          \n            \n                public KafkaListeners getKafkaListeners() {", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483465797", "createdAt": "2020-09-04T08:22:25Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final List<GenericKafkaListener> listValue;\n+    private final KafkaListeners objectValue;\n+\n+    public ArrayOrObjectKafkaListeners(List<GenericKafkaListener> listValue)   {\n+        this.listValue = listValue;\n+        this.objectValue = null;\n+    }\n+\n+    public ArrayOrObjectKafkaListeners(KafkaListeners objectValue)   {\n+        this.listValue = null;\n+        this.objectValue = objectValue;\n+    }\n+\n+    @Alternative()\n+    public List<GenericKafkaListener> getListValue() {\n+        return listValue;\n+    }\n+\n+    @Alternative()\n+    public KafkaListeners getObjectValue() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjk0ODYzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoyMzozMVrOHNEcmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMDoyOToyMFrOHNIdjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2NjM5Mw==", "bodyText": "this else can be removed, since we return in the if", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483466393", "createdAt": "2020-09-04T08:23:31Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final List<GenericKafkaListener> listValue;\n+    private final KafkaListeners objectValue;\n+\n+    public ArrayOrObjectKafkaListeners(List<GenericKafkaListener> listValue)   {\n+        this.listValue = listValue;\n+        this.objectValue = null;\n+    }\n+\n+    public ArrayOrObjectKafkaListeners(KafkaListeners objectValue)   {\n+        this.listValue = null;\n+        this.objectValue = objectValue;\n+    }\n+\n+    @Alternative()\n+    public List<GenericKafkaListener> getListValue() {\n+        return listValue;\n+    }\n+\n+    @Alternative()\n+    public KafkaListeners getObjectValue() {\n+        return objectValue;\n+    }\n+\n+    /**\n+     * Convenience method which returns either the new listener format if set, or converted old format.\n+     *\n+     * @return  List of new listeners\n+     */\n+    public List<GenericKafkaListener> newOrConverted()  {\n+        if (listValue != null)  {\n+            return listValue;\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMjE3Mg==", "bodyText": "I prefer to finish the else since it is more readable.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483532172", "createdAt": "2020-09-04T10:29:20Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final List<GenericKafkaListener> listValue;\n+    private final KafkaListeners objectValue;\n+\n+    public ArrayOrObjectKafkaListeners(List<GenericKafkaListener> listValue)   {\n+        this.listValue = listValue;\n+        this.objectValue = null;\n+    }\n+\n+    public ArrayOrObjectKafkaListeners(KafkaListeners objectValue)   {\n+        this.listValue = null;\n+        this.objectValue = objectValue;\n+    }\n+\n+    @Alternative()\n+    public List<GenericKafkaListener> getListValue() {\n+        return listValue;\n+    }\n+\n+    @Alternative()\n+    public KafkaListeners getObjectValue() {\n+        return objectValue;\n+    }\n+\n+    /**\n+     * Convenience method which returns either the new listener format if set, or converted old format.\n+     *\n+     * @return  List of new listeners\n+     */\n+    public List<GenericKafkaListener> newOrConverted()  {\n+        if (listValue != null)  {\n+            return listValue;\n+        } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2NjM5Mw=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjk2NjA0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoyODo0NFrOHNEnXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQxODoxNjoyMVrOHNje8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2OTE1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public void serialize(ArrayOrObjectKafkaListeners value, JsonGenerator generator, SerializerProvider provider) throws IOException {\n          \n          \n            \n                    public void serialize(ArrayOrObjectKafkaListeners value, JsonGenerator generator, SerializerProvider provider) throws IOException {\n          \n          \n            \n                    if (value == null) {\n          \n          \n            \n                        generator.writeNull();\n          \n          \n            \n                        return;\n          \n          \n            \n                    }\n          \n          \n            \n                            if (value.listValue != null)    {\n          \n          \n            \n                                generator.writeObject(value.listValue);\n          \n          \n            \n                                return;\n          \n          \n            \n                            } \n          \n          \n            \n                            if (value.objectValue != null)  {\n          \n          \n            \n                                generator.writeObject(value.objectValue);\n          \n          \n            \n                                return;\n          \n          \n            \n                            }\n          \n          \n            \n                            generator.writeNull();\n          \n          \n            \n                            return;\n          \n          \n            \n                           \n          \n          \n            \n                    }", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483469150", "createdAt": "2020-09-04T08:28:44Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final List<GenericKafkaListener> listValue;\n+    private final KafkaListeners objectValue;\n+\n+    public ArrayOrObjectKafkaListeners(List<GenericKafkaListener> listValue)   {\n+        this.listValue = listValue;\n+        this.objectValue = null;\n+    }\n+\n+    public ArrayOrObjectKafkaListeners(KafkaListeners objectValue)   {\n+        this.listValue = null;\n+        this.objectValue = objectValue;\n+    }\n+\n+    @Alternative()\n+    public List<GenericKafkaListener> getListValue() {\n+        return listValue;\n+    }\n+\n+    @Alternative()\n+    public KafkaListeners getObjectValue() {\n+        return objectValue;\n+    }\n+\n+    /**\n+     * Convenience method which returns either the new listener format if set, or converted old format.\n+     *\n+     * @return  List of new listeners\n+     */\n+    public List<GenericKafkaListener> newOrConverted()  {\n+        if (listValue != null)  {\n+            return listValue;\n+        } else {\n+            return ListenersConvertor.convertToNewFormat(objectValue);\n+        }\n+    }\n+\n+    public static class Serializer extends JsonSerializer<ArrayOrObjectKafkaListeners> {\n+        @Override\n+        public void serialize(ArrayOrObjectKafkaListeners value, JsonGenerator generator, SerializerProvider provider) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMjU5MA==", "bodyText": "I think this makes it much harder to read. What are the advantages?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483532590", "createdAt": "2020-09-04T10:30:13Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final List<GenericKafkaListener> listValue;\n+    private final KafkaListeners objectValue;\n+\n+    public ArrayOrObjectKafkaListeners(List<GenericKafkaListener> listValue)   {\n+        this.listValue = listValue;\n+        this.objectValue = null;\n+    }\n+\n+    public ArrayOrObjectKafkaListeners(KafkaListeners objectValue)   {\n+        this.listValue = null;\n+        this.objectValue = objectValue;\n+    }\n+\n+    @Alternative()\n+    public List<GenericKafkaListener> getListValue() {\n+        return listValue;\n+    }\n+\n+    @Alternative()\n+    public KafkaListeners getObjectValue() {\n+        return objectValue;\n+    }\n+\n+    /**\n+     * Convenience method which returns either the new listener format if set, or converted old format.\n+     *\n+     * @return  List of new listeners\n+     */\n+    public List<GenericKafkaListener> newOrConverted()  {\n+        if (listValue != null)  {\n+            return listValue;\n+        } else {\n+            return ListenersConvertor.convertToNewFormat(objectValue);\n+        }\n+    }\n+\n+    public static class Serializer extends JsonSerializer<ArrayOrObjectKafkaListeners> {\n+        @Override\n+        public void serialize(ArrayOrObjectKafkaListeners value, JsonGenerator generator, SerializerProvider provider) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2OTE1MA=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc3MTY1OQ==", "bodyText": "Personally I find nested ifs harder to read than an explicit list of priorities\nThis presents more like a checklist,\nif val == null write null\nif listValue != nul then return that.\nEspecially with things like trace entry/exit enabled it makes it easier to reasn where your code reaches and when it is early exiting.\nIf/elsiif isn't bad, but it leads to less maintainable code as it is added to, from my experience, not sure if other maintainers such as @ppatierno might have opinon on this.\nObviously it is just an issue of styling, but it can matter.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483771659", "createdAt": "2020-09-04T17:54:55Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final List<GenericKafkaListener> listValue;\n+    private final KafkaListeners objectValue;\n+\n+    public ArrayOrObjectKafkaListeners(List<GenericKafkaListener> listValue)   {\n+        this.listValue = listValue;\n+        this.objectValue = null;\n+    }\n+\n+    public ArrayOrObjectKafkaListeners(KafkaListeners objectValue)   {\n+        this.listValue = null;\n+        this.objectValue = objectValue;\n+    }\n+\n+    @Alternative()\n+    public List<GenericKafkaListener> getListValue() {\n+        return listValue;\n+    }\n+\n+    @Alternative()\n+    public KafkaListeners getObjectValue() {\n+        return objectValue;\n+    }\n+\n+    /**\n+     * Convenience method which returns either the new listener format if set, or converted old format.\n+     *\n+     * @return  List of new listeners\n+     */\n+    public List<GenericKafkaListener> newOrConverted()  {\n+        if (listValue != null)  {\n+            return listValue;\n+        } else {\n+            return ListenersConvertor.convertToNewFormat(objectValue);\n+        }\n+    }\n+\n+    public static class Serializer extends JsonSerializer<ArrayOrObjectKafkaListeners> {\n+        @Override\n+        public void serialize(ArrayOrObjectKafkaListeners value, JsonGenerator generator, SerializerProvider provider) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2OTE1MA=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk0NzI1Nw==", "bodyText": "Agree with @samuel-hawker I find the if/else harder too read when they are too nested. Of course, it is fine when there is no other solution but in this case Sam is proposing a good one.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483947257", "createdAt": "2020-09-05T12:37:24Z", "author": {"login": "ppatierno"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final List<GenericKafkaListener> listValue;\n+    private final KafkaListeners objectValue;\n+\n+    public ArrayOrObjectKafkaListeners(List<GenericKafkaListener> listValue)   {\n+        this.listValue = listValue;\n+        this.objectValue = null;\n+    }\n+\n+    public ArrayOrObjectKafkaListeners(KafkaListeners objectValue)   {\n+        this.listValue = null;\n+        this.objectValue = objectValue;\n+    }\n+\n+    @Alternative()\n+    public List<GenericKafkaListener> getListValue() {\n+        return listValue;\n+    }\n+\n+    @Alternative()\n+    public KafkaListeners getObjectValue() {\n+        return objectValue;\n+    }\n+\n+    /**\n+     * Convenience method which returns either the new listener format if set, or converted old format.\n+     *\n+     * @return  List of new listeners\n+     */\n+    public List<GenericKafkaListener> newOrConverted()  {\n+        if (listValue != null)  {\n+            return listValue;\n+        } else {\n+            return ListenersConvertor.convertToNewFormat(objectValue);\n+        }\n+    }\n+\n+    public static class Serializer extends JsonSerializer<ArrayOrObjectKafkaListeners> {\n+        @Override\n+        public void serialize(ArrayOrObjectKafkaListeners value, JsonGenerator generator, SerializerProvider provider) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2OTE1MA=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk3NDg5OQ==", "bodyText": "Ok, I changed it a bit. Hope you find it more readable now.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483974899", "createdAt": "2020-09-05T18:16:21Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final List<GenericKafkaListener> listValue;\n+    private final KafkaListeners objectValue;\n+\n+    public ArrayOrObjectKafkaListeners(List<GenericKafkaListener> listValue)   {\n+        this.listValue = listValue;\n+        this.objectValue = null;\n+    }\n+\n+    public ArrayOrObjectKafkaListeners(KafkaListeners objectValue)   {\n+        this.listValue = null;\n+        this.objectValue = objectValue;\n+    }\n+\n+    @Alternative()\n+    public List<GenericKafkaListener> getListValue() {\n+        return listValue;\n+    }\n+\n+    @Alternative()\n+    public KafkaListeners getObjectValue() {\n+        return objectValue;\n+    }\n+\n+    /**\n+     * Convenience method which returns either the new listener format if set, or converted old format.\n+     *\n+     * @return  List of new listeners\n+     */\n+    public List<GenericKafkaListener> newOrConverted()  {\n+        if (listValue != null)  {\n+            return listValue;\n+        } else {\n+            return ListenersConvertor.convertToNewFormat(objectValue);\n+        }\n+    }\n+\n+    public static class Serializer extends JsonSerializer<ArrayOrObjectKafkaListeners> {\n+        @Override\n+        public void serialize(ArrayOrObjectKafkaListeners value, JsonGenerator generator, SerializerProvider provider) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2OTE1MA=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjk3MzMxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozMDozNVrOHNErlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozMDozNVrOHNErlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MDIyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ArrayOrObjectKafkaListeners kafkaListeners;\n          \n          \n            \n                        ObjectCodec oc = jsonParser.getCodec();\n          \n          \n            \n                        if (jsonParser.currentToken() == JsonToken.START_ARRAY) {\n          \n          \n            \n                            return new ArrayOrObjectKafkaListeners(oc.readValue(jsonParser, new TypeReference<List<GenericKafkaListener>>() { }));\n          \n          \n            \n                        }\n          \n          \n            \n                        if (jsonParser.currentToken() == JsonToken.START_OBJECT) {\n          \n          \n            \n                            return new ArrayOrObjectKafkaListeners(oc.readValue(jsonParser, new TypeReference<KafkaListeners>() { }));\n          \n          \n            \n                        }\n          \n          \n            \n                        \n          \n          \n            \n                        throw new RuntimeException(\"Failed to deserialize ArrayOrObjectKafkaListeners. Please check .spec.kafka.listeners configuration.\");\n          \n          \n            \n                        }", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483470228", "createdAt": "2020-09-04T08:30:35Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final List<GenericKafkaListener> listValue;\n+    private final KafkaListeners objectValue;\n+\n+    public ArrayOrObjectKafkaListeners(List<GenericKafkaListener> listValue)   {\n+        this.listValue = listValue;\n+        this.objectValue = null;\n+    }\n+\n+    public ArrayOrObjectKafkaListeners(KafkaListeners objectValue)   {\n+        this.listValue = null;\n+        this.objectValue = objectValue;\n+    }\n+\n+    @Alternative()\n+    public List<GenericKafkaListener> getListValue() {\n+        return listValue;\n+    }\n+\n+    @Alternative()\n+    public KafkaListeners getObjectValue() {\n+        return objectValue;\n+    }\n+\n+    /**\n+     * Convenience method which returns either the new listener format if set, or converted old format.\n+     *\n+     * @return  List of new listeners\n+     */\n+    public List<GenericKafkaListener> newOrConverted()  {\n+        if (listValue != null)  {\n+            return listValue;\n+        } else {\n+            return ListenersConvertor.convertToNewFormat(objectValue);\n+        }\n+    }\n+\n+    public static class Serializer extends JsonSerializer<ArrayOrObjectKafkaListeners> {\n+        @Override\n+        public void serialize(ArrayOrObjectKafkaListeners value, JsonGenerator generator, SerializerProvider provider) throws IOException {\n+            if (value != null) {\n+                if (value.listValue != null)    {\n+                    generator.writeObject(value.listValue);\n+                } else if (value.objectValue != null)  {\n+                    generator.writeObject(value.objectValue);\n+                } else {\n+                    generator.writeNull();\n+                }\n+            } else {\n+                generator.writeNull();\n+            }\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC_ANON\")\n+    public static class Deserializer extends JsonDeserializer<ArrayOrObjectKafkaListeners> {\n+        @Override\n+        public ArrayOrObjectKafkaListeners deserialize(JsonParser jsonParser, DeserializationContext context) throws IOException {\n+            ArrayOrObjectKafkaListeners kafkaListeners;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjk3NDExOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozMDo1MFrOHNEsEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMDozMTo1MFrOHNIiKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MDM1NQ==", "bodyText": "We write an object for the list value?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483470355", "createdAt": "2020-09-04T08:30:50Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final List<GenericKafkaListener> listValue;\n+    private final KafkaListeners objectValue;\n+\n+    public ArrayOrObjectKafkaListeners(List<GenericKafkaListener> listValue)   {\n+        this.listValue = listValue;\n+        this.objectValue = null;\n+    }\n+\n+    public ArrayOrObjectKafkaListeners(KafkaListeners objectValue)   {\n+        this.listValue = null;\n+        this.objectValue = objectValue;\n+    }\n+\n+    @Alternative()\n+    public List<GenericKafkaListener> getListValue() {\n+        return listValue;\n+    }\n+\n+    @Alternative()\n+    public KafkaListeners getObjectValue() {\n+        return objectValue;\n+    }\n+\n+    /**\n+     * Convenience method which returns either the new listener format if set, or converted old format.\n+     *\n+     * @return  List of new listeners\n+     */\n+    public List<GenericKafkaListener> newOrConverted()  {\n+        if (listValue != null)  {\n+            return listValue;\n+        } else {\n+            return ListenersConvertor.convertToNewFormat(objectValue);\n+        }\n+    }\n+\n+    public static class Serializer extends JsonSerializer<ArrayOrObjectKafkaListeners> {\n+        @Override\n+        public void serialize(ArrayOrObjectKafkaListeners value, JsonGenerator generator, SerializerProvider provider) throws IOException {\n+            if (value != null) {\n+                if (value.listValue != null)    {\n+                    generator.writeObject(value.listValue);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMzM1Mg==", "bodyText": "Yes. This is one of the chaotic things where Object here is Java Object and not YAML / JSON Object :-(.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483533352", "createdAt": "2020-09-04T10:31:50Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+import io.sundr.builder.annotations.Buildable;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonDeserialize(using = ArrayOrObjectKafkaListeners.Deserializer.class)\n+@JsonSerialize(using = ArrayOrObjectKafkaListeners.Serializer.class)\n+@Alternation\n+public class ArrayOrObjectKafkaListeners implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final List<GenericKafkaListener> listValue;\n+    private final KafkaListeners objectValue;\n+\n+    public ArrayOrObjectKafkaListeners(List<GenericKafkaListener> listValue)   {\n+        this.listValue = listValue;\n+        this.objectValue = null;\n+    }\n+\n+    public ArrayOrObjectKafkaListeners(KafkaListeners objectValue)   {\n+        this.listValue = null;\n+        this.objectValue = objectValue;\n+    }\n+\n+    @Alternative()\n+    public List<GenericKafkaListener> getListValue() {\n+        return listValue;\n+    }\n+\n+    @Alternative()\n+    public KafkaListeners getObjectValue() {\n+        return objectValue;\n+    }\n+\n+    /**\n+     * Convenience method which returns either the new listener format if set, or converted old format.\n+     *\n+     * @return  List of new listeners\n+     */\n+    public List<GenericKafkaListener> newOrConverted()  {\n+        if (listValue != null)  {\n+            return listValue;\n+        } else {\n+            return ListenersConvertor.convertToNewFormat(objectValue);\n+        }\n+    }\n+\n+    public static class Serializer extends JsonSerializer<ArrayOrObjectKafkaListeners> {\n+        @Override\n+        public void serialize(ArrayOrObjectKafkaListeners value, JsonGenerator generator, SerializerProvider provider) throws IOException {\n+            if (value != null) {\n+                if (value.listValue != null)    {\n+                    generator.writeObject(value.listValue);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MDM1NQ=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjk3OTcxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozMjoyOVrOHNEvcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozMjoyOVrOHNEvcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MTIxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"The name has to be unique within given Kafka cluster. \" +\n          \n          \n            \n                        \"The name has to be unique within a given Kafka cluster. \" +", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483471219", "createdAt": "2020-09-04T08:32:29Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjk4Njc2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozNDozNlrOHNEzyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozNDozNlrOHNEzyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MjMzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"The port number has to be unique within given Kafka cluster. \" +\n          \n          \n            \n                        \"The port number has to be unique within a given Kafka cluster. \" +", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483472331", "createdAt": "2020-09-04T08:34:36Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjk5MjE2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozNjowOFrOHNE3DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozNjowOFrOHNE3DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MzE2NQ==", "bodyText": "A sentence shouldn't start with a \"But\"\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n          \n          \n            \n                        \"Depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n          \n      \n    \n    \n  \n\nAlternatively it might be better to merge this with the preceding sentence.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483473165", "createdAt": "2020-09-04T08:36:08Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +\n+            \"The port number will be used for the listener inside Kafka. \" +\n+            \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjk5MzIxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/KafkaListenerType.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozNjoyOVrOHNE3sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTo1NToyMFrOHNHd1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MzMyOQ==", "bodyText": "https://www.baeldung.com/java-enum-values\nWe can set values to the enums to remove all of the boilerplate toValue, forValue i believe", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483473329", "createdAt": "2020-09-04T08:36:29Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/KafkaListenerType.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonValue;\n+\n+public enum KafkaListenerType {\n+    INTERNAL,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5NTE0MA==", "bodyText": "You mean to use e.g. INTERNAL(\"internal\") instead of having the forValue / toValue methods? IIRC that does not work well with the (de)serialization in the APIs.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483495140", "createdAt": "2020-09-04T09:15:38Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/KafkaListenerType.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonValue;\n+\n+public enum KafkaListenerType {\n+    INTERNAL,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MzMyOQ=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxNTg2Mw==", "bodyText": "Ah that makes sense, apologies didn't know that!", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483515863", "createdAt": "2020-09-04T09:55:20Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/KafkaListenerType.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonValue;\n+\n+public enum KafkaListenerType {\n+    INTERNAL,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MzMyOQ=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjk5NDAxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozNjo0NlrOHNE4RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozNjo0NlrOHNE4RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MzQ3Ng==", "bodyText": "Is it an external listener if one of the types is internal?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483473476", "createdAt": "2020-09-04T08:36:46Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +\n+            \"The port number will be used for the listener inside Kafka. \" +\n+            \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n+    @JsonProperty(required = true)\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    @Description(\"Type of the external listener. \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjk5NTU3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozNzoxNlrOHNE5LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozNzoxNlrOHNE5LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MzcwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"* `internal` type exposes Kafka internally only within Kubernetes cluster.\" +\n          \n          \n            \n                        \"* `internal` type exposes Kafka internally only within the Kubernetes cluster.\\n\" +", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483473708", "createdAt": "2020-09-04T08:37:16Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +\n+            \"The port number will be used for the listener inside Kafka. \" +\n+            \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n+    @JsonProperty(required = true)\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    @Description(\"Type of the external listener. \" +\n+            \"Currently the supported types are `internal, `route`, `loadbalancer`, `nodeport` and `ingress`. \\n\\n\" +\n+            \"* `internal` type exposes Kafka internally only within Kubernetes cluster.\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjk5NjQwOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozNzoyOVrOHNE5qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozNzoyOVrOHNE5qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3MzgzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"* `route` type uses OpenShift Routes to expose Kafka.\" +\n          \n          \n            \n                        \"* `route` type uses OpenShift Routes to expose Kafka.\\n\" +", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483473835", "createdAt": "2020-09-04T08:37:29Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +\n+            \"The port number will be used for the listener inside Kafka. \" +\n+            \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n+    @JsonProperty(required = true)\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    @Description(\"Type of the external listener. \" +\n+            \"Currently the supported types are `internal, `route`, `loadbalancer`, `nodeport` and `ingress`. \\n\\n\" +\n+            \"* `internal` type exposes Kafka internally only within Kubernetes cluster.\" +\n+            \"* `route` type uses OpenShift Routes to expose Kafka.\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjk5NzIyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozNzo0N1rOHNE6Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozNzo0N1rOHNE6Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3Mzk4Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"* `loadbalancer` type uses LoadBalancer type services to expose Kafka.\" +\n          \n          \n            \n                        \"* `loadbalancer` type uses LoadBalancer type services to expose Kafka.\\n\" +", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483473982", "createdAt": "2020-09-04T08:37:47Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +\n+            \"The port number will be used for the listener inside Kafka. \" +\n+            \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n+    @JsonProperty(required = true)\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    @Description(\"Type of the external listener. \" +\n+            \"Currently the supported types are `internal, `route`, `loadbalancer`, `nodeport` and `ingress`. \\n\\n\" +\n+            \"* `internal` type exposes Kafka internally only within Kubernetes cluster.\" +\n+            \"* `route` type uses OpenShift Routes to expose Kafka.\" +\n+            \"* `loadbalancer` type uses LoadBalancer type services to expose Kafka.\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjk5ODE3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozNzo1OVrOHNE6vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozNzo1OVrOHNE6vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NDExMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"* `nodeport` type uses NodePort type services to expose Kafka.\" +\n          \n          \n            \n                        \"* `nodeport` type uses NodePort type services to expose Kafka.\\n\" +", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483474110", "createdAt": "2020-09-04T08:37:59Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +\n+            \"The port number will be used for the listener inside Kafka. \" +\n+            \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n+    @JsonProperty(required = true)\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    @Description(\"Type of the external listener. \" +\n+            \"Currently the supported types are `internal, `route`, `loadbalancer`, `nodeport` and `ingress`. \\n\\n\" +\n+            \"* `internal` type exposes Kafka internally only within Kubernetes cluster.\" +\n+            \"* `route` type uses OpenShift Routes to expose Kafka.\" +\n+            \"* `loadbalancer` type uses LoadBalancer type services to expose Kafka.\" +\n+            \"* `nodeport` type uses NodePort type services to expose Kafka.\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzAwMDI5OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozODozNVrOHNE8Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMDo0Mjo0NFrOHNI0aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NDQzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"* `ingress` type uses Kubernetes Nginx Ingress to expose Kafka.\")\n          \n          \n            \n                        \"* `ingress` type uses Kubernetes Nginx Ingress to expose Kafka.\\n\")\n          \n      \n    \n    \n  \n\nI thought we could (theorretically) configure ingress to use something other than Nginx?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483474438", "createdAt": "2020-09-04T08:38:35Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +\n+            \"The port number will be used for the listener inside Kafka. \" +\n+            \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n+    @JsonProperty(required = true)\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    @Description(\"Type of the external listener. \" +\n+            \"Currently the supported types are `internal, `route`, `loadbalancer`, `nodeport` and `ingress`. \\n\\n\" +\n+            \"* `internal` type exposes Kafka internally only within Kubernetes cluster.\" +\n+            \"* `route` type uses OpenShift Routes to expose Kafka.\" +\n+            \"* `loadbalancer` type uses LoadBalancer type services to expose Kafka.\" +\n+            \"* `nodeport` type uses NodePort type services to expose Kafka.\" +\n+            \"* `ingress` type uses Kubernetes Nginx Ingress to expose Kafka.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzODAyNA==", "bodyText": "The Ingresses are in general very incompatible with each other. Lot of things are handled by specific annotations etc. Kube 1.19 has Ingress v1 which might improve things, we have will see I guess.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483538024", "createdAt": "2020-09-04T10:42:44Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +\n+            \"The port number will be used for the listener inside Kafka. \" +\n+            \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n+    @JsonProperty(required = true)\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    @Description(\"Type of the external listener. \" +\n+            \"Currently the supported types are `internal, `route`, `loadbalancer`, `nodeport` and `ingress`. \\n\\n\" +\n+            \"* `internal` type exposes Kafka internally only within Kubernetes cluster.\" +\n+            \"* `route` type uses OpenShift Routes to expose Kafka.\" +\n+            \"* `loadbalancer` type uses LoadBalancer type services to expose Kafka.\" +\n+            \"* `nodeport` type uses NodePort type services to expose Kafka.\" +\n+            \"* `ingress` type uses Kubernetes Nginx Ingress to expose Kafka.\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NDQzOA=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzAwMzUxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozOTozMFrOHNE9_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozOTozMFrOHNE9_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NDk0MA==", "bodyText": "It's listener specific, so it's a bit misleading to bring brokers into it.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Description(\"Authentication configuration for Kafka brokers\")\n          \n          \n            \n                @Description(\"Authentication configuration for this listener\")", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483474940", "createdAt": "2020-09-04T08:39:30Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +\n+            \"The port number will be used for the listener inside Kafka. \" +\n+            \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n+    @JsonProperty(required = true)\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    @Description(\"Type of the external listener. \" +\n+            \"Currently the supported types are `internal, `route`, `loadbalancer`, `nodeport` and `ingress`. \\n\\n\" +\n+            \"* `internal` type exposes Kafka internally only within Kubernetes cluster.\" +\n+            \"* `route` type uses OpenShift Routes to expose Kafka.\" +\n+            \"* `loadbalancer` type uses LoadBalancer type services to expose Kafka.\" +\n+            \"* `nodeport` type uses NodePort type services to expose Kafka.\" +\n+            \"* `ingress` type uses Kubernetes Nginx Ingress to expose Kafka.\")\n+    @JsonProperty(required = true)\n+    public KafkaListenerType getType() {\n+        return type;\n+    }\n+\n+    public void setType(KafkaListenerType type) {\n+        this.type = type;\n+    }\n+\n+    @Description(\"Authentication configuration for Kafka brokers\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzAxMDY4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0MToxOVrOHNFCHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMjoxNTozNlrOHNLRJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NTk5Nw==", "bodyText": "I do wonder whether false is the best default for all listeners. If we used a Boolean we could have different defaults for different listener types, right? Or should be make it a mandatory property.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483475997", "createdAt": "2020-09-04T08:41:19Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +\n+            \"The port number will be used for the listener inside Kafka. \" +\n+            \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n+    @JsonProperty(required = true)\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    @Description(\"Type of the external listener. \" +\n+            \"Currently the supported types are `internal, `route`, `loadbalancer`, `nodeport` and `ingress`. \\n\\n\" +\n+            \"* `internal` type exposes Kafka internally only within Kubernetes cluster.\" +\n+            \"* `route` type uses OpenShift Routes to expose Kafka.\" +\n+            \"* `loadbalancer` type uses LoadBalancer type services to expose Kafka.\" +\n+            \"* `nodeport` type uses NodePort type services to expose Kafka.\" +\n+            \"* `ingress` type uses Kubernetes Nginx Ingress to expose Kafka.\")\n+    @JsonProperty(required = true)\n+    public KafkaListenerType getType() {\n+        return type;\n+    }\n+\n+    public void setType(KafkaListenerType type) {\n+        this.type = type;\n+    }\n+\n+    @Description(\"Authentication configuration for Kafka brokers\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @JsonProperty(\"authentication\")\n+    public KafkaListenerAuthentication getAuth() {\n+        return auth;\n+    }\n+\n+    public void setAuth(KafkaListenerAuthentication auth) {\n+        this.auth = auth;\n+    }\n+\n+    @Description(\"Enables TLS encryption on the listener. \" +\n+            \"By default set to `false` for disabled TLS encryption.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3ODE1MQ==", "bodyText": "I wondered about this as well ...\n\nWe are changing the default which was confusing but some for sure got used to it\nHaving a different default per type is IMHO also confusing\n\nSo maybe having it required might be the cleaner approach to make sure everyone sets it right?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483578151", "createdAt": "2020-09-04T12:15:36Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListener.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.fabric8.kubernetes.api.model.networking.NetworkPolicyPeer;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthentication;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.strimzi.crdgenerator.annotations.KubeLink;\n+import io.strimzi.crdgenerator.annotations.Pattern;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures the external listener which exposes Kafka outside of Kubernetes / OpenShift\n+ */\n+@Buildable(\n+        editableEnabled = false,\n+        builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@JsonPropertyOrder({\"name\", \"port\", \"type\", \"tls\", \"authentication\", \"configuration\", \"networkPolicyPeers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@EqualsAndHashCode\n+public class GenericKafkaListener implements UnknownPropertyPreserving, Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String LISTENER_NAME_REGEX = \"^[a-z0-9]{1,25}$\";\n+\n+    private String name;\n+    private int port;\n+    private KafkaListenerType type;\n+    private boolean tls = false;\n+    private KafkaListenerAuthentication auth;\n+    private GenericKafkaListenerConfiguration configuration;\n+    private List<NetworkPolicyPeer> networkPolicyPeers;\n+    private Map<String, Object> additionalProperties;\n+\n+    @Description(\"Name of the listener. \" +\n+            \"The name will be used to identify the listener and the related Kubernetes objects. \" +\n+            \"The name has to be unique within given Kafka cluster. \" +\n+            \"The name can consist of lowercase characters and numbers and be up to 25 characters long.\")\n+    @JsonProperty(required = true)\n+    @Pattern(LISTENER_NAME_REGEX)\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    @Description(\"Port number used by the listener. \" +\n+            \"The port number has to be unique within given Kafka cluster. \" +\n+            \"The port number will be used for the listener inside Kafka. \" +\n+            \"But depending on the listener type, it might not be the port number where the Kafka clients connect.\")\n+    @JsonProperty(required = true)\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    @Description(\"Type of the external listener. \" +\n+            \"Currently the supported types are `internal, `route`, `loadbalancer`, `nodeport` and `ingress`. \\n\\n\" +\n+            \"* `internal` type exposes Kafka internally only within Kubernetes cluster.\" +\n+            \"* `route` type uses OpenShift Routes to expose Kafka.\" +\n+            \"* `loadbalancer` type uses LoadBalancer type services to expose Kafka.\" +\n+            \"* `nodeport` type uses NodePort type services to expose Kafka.\" +\n+            \"* `ingress` type uses Kubernetes Nginx Ingress to expose Kafka.\")\n+    @JsonProperty(required = true)\n+    public KafkaListenerType getType() {\n+        return type;\n+    }\n+\n+    public void setType(KafkaListenerType type) {\n+        this.type = type;\n+    }\n+\n+    @Description(\"Authentication configuration for Kafka brokers\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @JsonProperty(\"authentication\")\n+    public KafkaListenerAuthentication getAuth() {\n+        return auth;\n+    }\n+\n+    public void setAuth(KafkaListenerAuthentication auth) {\n+        this.auth = auth;\n+    }\n+\n+    @Description(\"Enables TLS encryption on the listener. \" +\n+            \"By default set to `false` for disabled TLS encryption.\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NTk5Nw=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzAxMzEwOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ListenersConvertor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0MTo1OFrOHNFDgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0MTo1OFrOHNFDgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NjM1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (oldListener.getConfiguration() != null || oldListener.getOverrides() != null) {\n          \n          \n            \n                    if (oldListener.getConfiguration() == null && oldListener.getOverrides() == null) {\n          \n          \n            \n                        return;\n          \n          \n            \n                    }", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483476354", "createdAt": "2020-09-04T08:41:58Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ListenersConvertor.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import io.strimzi.api.kafka.model.listener.IngressListenerBrokerConfiguration;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerExternal;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerExternalIngress;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerExternalLoadBalancer;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerExternalNodePort;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerExternalRoute;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerPlain;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerTls;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.api.kafka.model.listener.LoadBalancerListenerBrokerOverride;\n+import io.strimzi.api.kafka.model.listener.NodePortListenerBrokerOverride;\n+import io.strimzi.api.kafka.model.listener.RouteListenerBrokerOverride;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Util methods used for working with Kafka listeners\n+ */\n+public class ListenersConvertor {\n+    /**\n+     * Converts the Kafka listener configuration from old format to the new format\n+     *\n+     * @param oldListeners  Old Kafka listeners configuration\n+     * @return  New Kafka listeners configuration\n+     */\n+    @SuppressWarnings(\"deprecation\")\n+    public static List<GenericKafkaListener> convertToNewFormat(KafkaListeners oldListeners)    {\n+        List<GenericKafkaListener> newListeners = new ArrayList<>(3);\n+\n+        if (oldListeners != null)   {\n+            if (oldListeners.getPlain() != null)    {\n+                newListeners.add(convertPlainListener(oldListeners.getPlain()));\n+            }\n+\n+            if (oldListeners.getTls() != null)    {\n+                newListeners.add(convertTlsListener(oldListeners.getTls()));\n+            }\n+\n+            if (oldListeners.getExternal() != null)    {\n+                newListeners.add(convertExternalListener(oldListeners.getExternal()));\n+            }\n+        }\n+\n+        return newListeners;\n+    }\n+\n+    /**\n+     * Converts plain listener into the new format\n+     *\n+     * @param plain Plain listener in old format\n+     * @return  Listener in the new format\n+     */\n+    /*test*/ static GenericKafkaListener convertPlainListener(KafkaListenerPlain plain)  {\n+        return new GenericKafkaListenerBuilder()\n+                .withName(\"plain\")\n+                .withPort(9092)\n+                .withType(KafkaListenerType.INTERNAL)\n+                .withTls(false)\n+                .withAuth(plain.getAuth())\n+                .withNetworkPolicyPeers(plain.getNetworkPolicyPeers())\n+                .build();\n+    }\n+\n+    /**\n+     * Converts TLS listener into the new format\n+     *\n+     * @param tls TLS listener in old format\n+     * @return  Listener in the new format\n+     */\n+    /*test*/ static GenericKafkaListener convertTlsListener(KafkaListenerTls tls)  {\n+        GenericKafkaListenerConfiguration configuration = null;\n+\n+        if (tls.getConfiguration() != null) {\n+            configuration = new GenericKafkaListenerConfigurationBuilder()\n+                    .withBrokerCertChainAndKey(tls.getConfiguration().getBrokerCertChainAndKey())\n+                    .build();\n+        }\n+\n+        return new GenericKafkaListenerBuilder()\n+                .withName(\"tls\")\n+                .withPort(9093)\n+                .withType(KafkaListenerType.INTERNAL)\n+                .withTls(true)\n+                .withAuth(tls.getAuth())\n+                .withNetworkPolicyPeers(tls.getNetworkPolicyPeers())\n+                .withConfiguration(configuration)\n+                .build();\n+    }\n+\n+    /**\n+     * Converts External listener into the new format\n+     *\n+     * @param external External listener in old format\n+     * @return  Listener in the new format\n+     */\n+    /*test*/ static GenericKafkaListener convertExternalListener(KafkaListenerExternal external)  {\n+        GenericKafkaListener listener = new GenericKafkaListenerBuilder()\n+                .withName(\"external\")\n+                .withPort(9094)\n+                .withAuth(external.getAuth())\n+                .withNetworkPolicyPeers(external.getNetworkPolicyPeers())\n+                .build();\n+\n+        if (KafkaListenerExternalLoadBalancer.TYPE_LOADBALANCER.equals(external.getType())) {\n+            convertLoadBalancerListener(listener, (KafkaListenerExternalLoadBalancer) external);\n+        } else if (KafkaListenerExternalNodePort.TYPE_NODEPORT.equals(external.getType())) {\n+            convertNodePortListener(listener, (KafkaListenerExternalNodePort) external);\n+        } else if (KafkaListenerExternalRoute.TYPE_ROUTE.equals(external.getType())) {\n+            convertRouteListener(listener, (KafkaListenerExternalRoute) external);\n+        } else if (KafkaListenerExternalIngress.TYPE_INGRESS.equals(external.getType())) {\n+            convertIngressListener(listener, (KafkaListenerExternalIngress) external);\n+        }\n+\n+        return listener;\n+    }\n+\n+    /**\n+     * Converts Load Balancer listener from old to new configuration\n+     *\n+     * @param newListener   New listener which will be configured\n+     * @param oldListener   Old listener\n+     */\n+    private static void convertLoadBalancerListener(GenericKafkaListener newListener, KafkaListenerExternalLoadBalancer oldListener)    {\n+        newListener.setType(KafkaListenerType.LOADBALANCER);\n+        newListener.setTls(oldListener.isTls());\n+\n+        if (oldListener.getConfiguration() != null || oldListener.getOverrides() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzAxNzI5OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ListenersConvertor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0MzowNVrOHNFF5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0MzowNVrOHNFF5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3Njk2Ng==", "bodyText": "Ditto flip this check", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483476966", "createdAt": "2020-09-04T08:43:05Z", "author": {"login": "samuel-hawker"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ListenersConvertor.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import io.strimzi.api.kafka.model.listener.IngressListenerBrokerConfiguration;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerExternal;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerExternalIngress;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerExternalLoadBalancer;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerExternalNodePort;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerExternalRoute;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerPlain;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerTls;\n+import io.strimzi.api.kafka.model.listener.KafkaListeners;\n+import io.strimzi.api.kafka.model.listener.LoadBalancerListenerBrokerOverride;\n+import io.strimzi.api.kafka.model.listener.NodePortListenerBrokerOverride;\n+import io.strimzi.api.kafka.model.listener.RouteListenerBrokerOverride;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Util methods used for working with Kafka listeners\n+ */\n+public class ListenersConvertor {\n+    /**\n+     * Converts the Kafka listener configuration from old format to the new format\n+     *\n+     * @param oldListeners  Old Kafka listeners configuration\n+     * @return  New Kafka listeners configuration\n+     */\n+    @SuppressWarnings(\"deprecation\")\n+    public static List<GenericKafkaListener> convertToNewFormat(KafkaListeners oldListeners)    {\n+        List<GenericKafkaListener> newListeners = new ArrayList<>(3);\n+\n+        if (oldListeners != null)   {\n+            if (oldListeners.getPlain() != null)    {\n+                newListeners.add(convertPlainListener(oldListeners.getPlain()));\n+            }\n+\n+            if (oldListeners.getTls() != null)    {\n+                newListeners.add(convertTlsListener(oldListeners.getTls()));\n+            }\n+\n+            if (oldListeners.getExternal() != null)    {\n+                newListeners.add(convertExternalListener(oldListeners.getExternal()));\n+            }\n+        }\n+\n+        return newListeners;\n+    }\n+\n+    /**\n+     * Converts plain listener into the new format\n+     *\n+     * @param plain Plain listener in old format\n+     * @return  Listener in the new format\n+     */\n+    /*test*/ static GenericKafkaListener convertPlainListener(KafkaListenerPlain plain)  {\n+        return new GenericKafkaListenerBuilder()\n+                .withName(\"plain\")\n+                .withPort(9092)\n+                .withType(KafkaListenerType.INTERNAL)\n+                .withTls(false)\n+                .withAuth(plain.getAuth())\n+                .withNetworkPolicyPeers(plain.getNetworkPolicyPeers())\n+                .build();\n+    }\n+\n+    /**\n+     * Converts TLS listener into the new format\n+     *\n+     * @param tls TLS listener in old format\n+     * @return  Listener in the new format\n+     */\n+    /*test*/ static GenericKafkaListener convertTlsListener(KafkaListenerTls tls)  {\n+        GenericKafkaListenerConfiguration configuration = null;\n+\n+        if (tls.getConfiguration() != null) {\n+            configuration = new GenericKafkaListenerConfigurationBuilder()\n+                    .withBrokerCertChainAndKey(tls.getConfiguration().getBrokerCertChainAndKey())\n+                    .build();\n+        }\n+\n+        return new GenericKafkaListenerBuilder()\n+                .withName(\"tls\")\n+                .withPort(9093)\n+                .withType(KafkaListenerType.INTERNAL)\n+                .withTls(true)\n+                .withAuth(tls.getAuth())\n+                .withNetworkPolicyPeers(tls.getNetworkPolicyPeers())\n+                .withConfiguration(configuration)\n+                .build();\n+    }\n+\n+    /**\n+     * Converts External listener into the new format\n+     *\n+     * @param external External listener in old format\n+     * @return  Listener in the new format\n+     */\n+    /*test*/ static GenericKafkaListener convertExternalListener(KafkaListenerExternal external)  {\n+        GenericKafkaListener listener = new GenericKafkaListenerBuilder()\n+                .withName(\"external\")\n+                .withPort(9094)\n+                .withAuth(external.getAuth())\n+                .withNetworkPolicyPeers(external.getNetworkPolicyPeers())\n+                .build();\n+\n+        if (KafkaListenerExternalLoadBalancer.TYPE_LOADBALANCER.equals(external.getType())) {\n+            convertLoadBalancerListener(listener, (KafkaListenerExternalLoadBalancer) external);\n+        } else if (KafkaListenerExternalNodePort.TYPE_NODEPORT.equals(external.getType())) {\n+            convertNodePortListener(listener, (KafkaListenerExternalNodePort) external);\n+        } else if (KafkaListenerExternalRoute.TYPE_ROUTE.equals(external.getType())) {\n+            convertRouteListener(listener, (KafkaListenerExternalRoute) external);\n+        } else if (KafkaListenerExternalIngress.TYPE_INGRESS.equals(external.getType())) {\n+            convertIngressListener(listener, (KafkaListenerExternalIngress) external);\n+        }\n+\n+        return listener;\n+    }\n+\n+    /**\n+     * Converts Load Balancer listener from old to new configuration\n+     *\n+     * @param newListener   New listener which will be configured\n+     * @param oldListener   Old listener\n+     */\n+    private static void convertLoadBalancerListener(GenericKafkaListener newListener, KafkaListenerExternalLoadBalancer oldListener)    {\n+        newListener.setType(KafkaListenerType.LOADBALANCER);\n+        newListener.setTls(oldListener.isTls());\n+\n+        if (oldListener.getConfiguration() != null || oldListener.getOverrides() != null) {\n+            GenericKafkaListenerConfiguration configuration = new GenericKafkaListenerConfiguration();\n+\n+            if (oldListener.getConfiguration() != null) {\n+                configuration.setBrokerCertChainAndKey(oldListener.getConfiguration().getBrokerCertChainAndKey());\n+            }\n+\n+            if (oldListener.getOverrides() != null) {\n+                if (oldListener.getOverrides().getBootstrap() != null) {\n+                    GenericKafkaListenerConfigurationBootstrap bootstrapConfiguration = new GenericKafkaListenerConfigurationBootstrap();\n+                    bootstrapConfiguration.setLoadBalancerIP(oldListener.getOverrides().getBootstrap().getLoadBalancerIP());\n+                    bootstrapConfiguration.setDnsAnnotations(oldListener.getOverrides().getBootstrap().getDnsAnnotations());\n+\n+                    if (oldListener.getOverrides().getBootstrap().getAddress() != null) {\n+                        bootstrapConfiguration.setAlternativeNames(Collections.singletonList(oldListener.getOverrides().getBootstrap().getAddress()));\n+                    }\n+\n+                    configuration.setBootstrap(bootstrapConfiguration);\n+                }\n+\n+                if (oldListener.getOverrides().getBrokers() != null) {\n+                    List<GenericKafkaListenerConfigurationBroker> brokers = new ArrayList<>(oldListener.getOverrides().getBrokers().size());\n+\n+                    for (LoadBalancerListenerBrokerOverride oldBroker : oldListener.getOverrides().getBrokers()) {\n+                        GenericKafkaListenerConfigurationBroker brokerConfiguration = new GenericKafkaListenerConfigurationBroker();\n+                        brokerConfiguration.setBroker(oldBroker.getBroker());\n+                        brokerConfiguration.setLoadBalancerIP(oldBroker.getLoadBalancerIP());\n+                        brokerConfiguration.setDnsAnnotations(oldBroker.getDnsAnnotations());\n+                        brokerConfiguration.setAdvertisedHost(oldBroker.getAdvertisedHost());\n+                        brokerConfiguration.setAdvertisedPort(oldBroker.getAdvertisedPort());\n+\n+                        brokers.add(brokerConfiguration);\n+                    }\n+\n+                    configuration.setBrokers(brokers);\n+                }\n+            }\n+\n+            newListener.setConfiguration(configuration);\n+        }\n+    }\n+\n+    /**\n+     * Converts Node Port listener from old to new configuration\n+     *\n+     * @param newListener   New listener which will be configured\n+     * @param oldListener   Old listener\n+     */\n+    private static void convertNodePortListener(GenericKafkaListener newListener, KafkaListenerExternalNodePort oldListener)    {\n+        newListener.setType(KafkaListenerType.NODEPORT);\n+        newListener.setTls(oldListener.isTls());\n+\n+        if (oldListener.getConfiguration() != null || oldListener.getOverrides() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzAzMTIxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListenerConfiguration.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0Njo1NlrOHNFOfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMzowODo0OVrOHNM4GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3OTE2Ng==", "bodyText": "In the ingress-specific property is called ingressClass shouldn't this be be preferredNodeportAddressType?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483479166", "createdAt": "2020-09-04T08:46:56Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListenerConfiguration.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.CertAndKeySecretSource;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Collections.emptyMap;\n+\n+/**\n+ * Configures Kafka listeners\n+ */\n+@JsonPropertyOrder({\"brokerCertChainAndKey\", \"ingressClass\", \"preferredAddressType\", \"externalTrafficPolicy\", \"loadBalancerSourceRanges\", \"bootstrap\", \"brokers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Buildable(\n+    editableEnabled = false,\n+    builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@EqualsAndHashCode\n+public class GenericKafkaListenerConfiguration implements Serializable, UnknownPropertyPreserving {\n+    private static final long serialVersionUID = 1L;\n+\n+    private CertAndKeySecretSource brokerCertChainAndKey;\n+    private String ingressClass;\n+    private NodeAddressType preferredAddressType;\n+    private ExternalTrafficPolicy externalTrafficPolicy;\n+    private List<String> loadBalancerSourceRanges = new ArrayList<>(0);\n+    private Boolean useServiceDnsDomain;\n+    private GenericKafkaListenerConfigurationBootstrap bootstrap;\n+    private List<GenericKafkaListenerConfigurationBroker> brokers;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. \" +\n+            \"The certificate can optionally contain the whole chain. \" +\n+            \"This field can be used only with listeners with enabled TLS encryption.\")\n+    public CertAndKeySecretSource getBrokerCertChainAndKey() {\n+        return brokerCertChainAndKey;\n+    }\n+\n+    public void setBrokerCertChainAndKey(CertAndKeySecretSource brokerCertChainAndKey) {\n+        this.brokerCertChainAndKey = brokerCertChainAndKey;\n+    }\n+\n+    @Description(\"Configures the `Ingress` class that defines which `Ingress` controller will be used. \" +\n+            \"If not set, the `Ingress` class is set to `nginx`. \" +\n+            \"This field can be used only with `ingress` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @JsonProperty(\"class\")\n+    public String getIngressClass() {\n+        return ingressClass;\n+    }\n+\n+    public void setIngressClass(String ingressClass) {\n+        this.ingressClass = ingressClass;\n+    }\n+\n+    @Description(\"Defines which address type should be used as the node address. \" +\n+            \"Available types are: `ExternalDNS`, `ExternalIP`, `InternalDNS`, `InternalIP` and `Hostname`. \" +\n+            \"By default, the addresses will be used in the following order (the first one found will be used):\\n\" +\n+            \"* `ExternalDNS`\\n\" +\n+            \"* `ExternalIP`\\n\" +\n+            \"* `InternalDNS`\\n\" +\n+            \"* `InternalIP`\\n\" +\n+            \"* `Hostname`\\n\" +\n+            \"\\n\" +\n+            \"This field can be used to select the address type which will be used as the preferred type and checked first. \" +\n+            \"In case no address will be found for this address type, the other types will be used in the default order.\" +\n+            \"This field can be used only with `nodeport` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public NodeAddressType getPreferredAddressType() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0MDQwNA==", "bodyText": "I called ingressClass that way because the field it changes is called like that and I do not think other things have any similar concept. On the other hand, I can for example imagine that preferredAddressType is in the future also used for load balancers to define whether a DNS name or an IP address should be preferred.\nIf I had to choose, I would probably tend to rename the ingressClass to class rather than the other way around. WDYT?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483540404", "createdAt": "2020-09-04T10:48:05Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListenerConfiguration.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.CertAndKeySecretSource;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Collections.emptyMap;\n+\n+/**\n+ * Configures Kafka listeners\n+ */\n+@JsonPropertyOrder({\"brokerCertChainAndKey\", \"ingressClass\", \"preferredAddressType\", \"externalTrafficPolicy\", \"loadBalancerSourceRanges\", \"bootstrap\", \"brokers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Buildable(\n+    editableEnabled = false,\n+    builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@EqualsAndHashCode\n+public class GenericKafkaListenerConfiguration implements Serializable, UnknownPropertyPreserving {\n+    private static final long serialVersionUID = 1L;\n+\n+    private CertAndKeySecretSource brokerCertChainAndKey;\n+    private String ingressClass;\n+    private NodeAddressType preferredAddressType;\n+    private ExternalTrafficPolicy externalTrafficPolicy;\n+    private List<String> loadBalancerSourceRanges = new ArrayList<>(0);\n+    private Boolean useServiceDnsDomain;\n+    private GenericKafkaListenerConfigurationBootstrap bootstrap;\n+    private List<GenericKafkaListenerConfigurationBroker> brokers;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. \" +\n+            \"The certificate can optionally contain the whole chain. \" +\n+            \"This field can be used only with listeners with enabled TLS encryption.\")\n+    public CertAndKeySecretSource getBrokerCertChainAndKey() {\n+        return brokerCertChainAndKey;\n+    }\n+\n+    public void setBrokerCertChainAndKey(CertAndKeySecretSource brokerCertChainAndKey) {\n+        this.brokerCertChainAndKey = brokerCertChainAndKey;\n+    }\n+\n+    @Description(\"Configures the `Ingress` class that defines which `Ingress` controller will be used. \" +\n+            \"If not set, the `Ingress` class is set to `nginx`. \" +\n+            \"This field can be used only with `ingress` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @JsonProperty(\"class\")\n+    public String getIngressClass() {\n+        return ingressClass;\n+    }\n+\n+    public void setIngressClass(String ingressClass) {\n+        this.ingressClass = ingressClass;\n+    }\n+\n+    @Description(\"Defines which address type should be used as the node address. \" +\n+            \"Available types are: `ExternalDNS`, `ExternalIP`, `InternalDNS`, `InternalIP` and `Hostname`. \" +\n+            \"By default, the addresses will be used in the following order (the first one found will be used):\\n\" +\n+            \"* `ExternalDNS`\\n\" +\n+            \"* `ExternalIP`\\n\" +\n+            \"* `InternalDNS`\\n\" +\n+            \"* `InternalIP`\\n\" +\n+            \"* `Hostname`\\n\" +\n+            \"\\n\" +\n+            \"This field can be used to select the address type which will be used as the preferred type and checked first. \" +\n+            \"In case no address will be found for this address type, the other types will be used in the default order.\" +\n+            \"This field can be used only with `nodeport` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public NodeAddressType getPreferredAddressType() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3OTE2Ng=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU1NTU3NA==", "bodyText": "Yeah, it's tricky. One of the hazards of using an object with properties which have to cope with the union of the different types. I think class would be a bit weird, because it would configure the ingressClass field you mentioned in the case of ingress and something else for another type so there wouldn't be a 1-to-1 correspondence. Not that there has to be, but it's helpful for people's mental model when there is. I think I would prefer what you already have over using class.\nIf load balancers gained a similar thing then having both preferredNodeportAddressType and preferredLoadBalancerAddressType would not be terrible. But I'm not wedded to the idea.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483555574", "createdAt": "2020-09-04T11:23:38Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListenerConfiguration.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.CertAndKeySecretSource;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Collections.emptyMap;\n+\n+/**\n+ * Configures Kafka listeners\n+ */\n+@JsonPropertyOrder({\"brokerCertChainAndKey\", \"ingressClass\", \"preferredAddressType\", \"externalTrafficPolicy\", \"loadBalancerSourceRanges\", \"bootstrap\", \"brokers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Buildable(\n+    editableEnabled = false,\n+    builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@EqualsAndHashCode\n+public class GenericKafkaListenerConfiguration implements Serializable, UnknownPropertyPreserving {\n+    private static final long serialVersionUID = 1L;\n+\n+    private CertAndKeySecretSource brokerCertChainAndKey;\n+    private String ingressClass;\n+    private NodeAddressType preferredAddressType;\n+    private ExternalTrafficPolicy externalTrafficPolicy;\n+    private List<String> loadBalancerSourceRanges = new ArrayList<>(0);\n+    private Boolean useServiceDnsDomain;\n+    private GenericKafkaListenerConfigurationBootstrap bootstrap;\n+    private List<GenericKafkaListenerConfigurationBroker> brokers;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. \" +\n+            \"The certificate can optionally contain the whole chain. \" +\n+            \"This field can be used only with listeners with enabled TLS encryption.\")\n+    public CertAndKeySecretSource getBrokerCertChainAndKey() {\n+        return brokerCertChainAndKey;\n+    }\n+\n+    public void setBrokerCertChainAndKey(CertAndKeySecretSource brokerCertChainAndKey) {\n+        this.brokerCertChainAndKey = brokerCertChainAndKey;\n+    }\n+\n+    @Description(\"Configures the `Ingress` class that defines which `Ingress` controller will be used. \" +\n+            \"If not set, the `Ingress` class is set to `nginx`. \" +\n+            \"This field can be used only with `ingress` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @JsonProperty(\"class\")\n+    public String getIngressClass() {\n+        return ingressClass;\n+    }\n+\n+    public void setIngressClass(String ingressClass) {\n+        this.ingressClass = ingressClass;\n+    }\n+\n+    @Description(\"Defines which address type should be used as the node address. \" +\n+            \"Available types are: `ExternalDNS`, `ExternalIP`, `InternalDNS`, `InternalIP` and `Hostname`. \" +\n+            \"By default, the addresses will be used in the following order (the first one found will be used):\\n\" +\n+            \"* `ExternalDNS`\\n\" +\n+            \"* `ExternalIP`\\n\" +\n+            \"* `InternalDNS`\\n\" +\n+            \"* `InternalIP`\\n\" +\n+            \"* `Hostname`\\n\" +\n+            \"\\n\" +\n+            \"This field can be used to select the address type which will be used as the preferred type and checked first. \" +\n+            \"In case no address will be found for this address type, the other types will be used in the default order.\" +\n+            \"This field can be used only with `nodeport` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public NodeAddressType getPreferredAddressType() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3OTE2Ng=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYwNDUwNQ==", "bodyText": "I will change it to preferredNodePortAddressType since the load balancers would have anyway different implementation if we add them in the future.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483604505", "createdAt": "2020-09-04T13:08:49Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListenerConfiguration.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.CertAndKeySecretSource;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Collections.emptyMap;\n+\n+/**\n+ * Configures Kafka listeners\n+ */\n+@JsonPropertyOrder({\"brokerCertChainAndKey\", \"ingressClass\", \"preferredAddressType\", \"externalTrafficPolicy\", \"loadBalancerSourceRanges\", \"bootstrap\", \"brokers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Buildable(\n+    editableEnabled = false,\n+    builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@EqualsAndHashCode\n+public class GenericKafkaListenerConfiguration implements Serializable, UnknownPropertyPreserving {\n+    private static final long serialVersionUID = 1L;\n+\n+    private CertAndKeySecretSource brokerCertChainAndKey;\n+    private String ingressClass;\n+    private NodeAddressType preferredAddressType;\n+    private ExternalTrafficPolicy externalTrafficPolicy;\n+    private List<String> loadBalancerSourceRanges = new ArrayList<>(0);\n+    private Boolean useServiceDnsDomain;\n+    private GenericKafkaListenerConfigurationBootstrap bootstrap;\n+    private List<GenericKafkaListenerConfigurationBroker> brokers;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. \" +\n+            \"The certificate can optionally contain the whole chain. \" +\n+            \"This field can be used only with listeners with enabled TLS encryption.\")\n+    public CertAndKeySecretSource getBrokerCertChainAndKey() {\n+        return brokerCertChainAndKey;\n+    }\n+\n+    public void setBrokerCertChainAndKey(CertAndKeySecretSource brokerCertChainAndKey) {\n+        this.brokerCertChainAndKey = brokerCertChainAndKey;\n+    }\n+\n+    @Description(\"Configures the `Ingress` class that defines which `Ingress` controller will be used. \" +\n+            \"If not set, the `Ingress` class is set to `nginx`. \" +\n+            \"This field can be used only with `ingress` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @JsonProperty(\"class\")\n+    public String getIngressClass() {\n+        return ingressClass;\n+    }\n+\n+    public void setIngressClass(String ingressClass) {\n+        this.ingressClass = ingressClass;\n+    }\n+\n+    @Description(\"Defines which address type should be used as the node address. \" +\n+            \"Available types are: `ExternalDNS`, `ExternalIP`, `InternalDNS`, `InternalIP` and `Hostname`. \" +\n+            \"By default, the addresses will be used in the following order (the first one found will be used):\\n\" +\n+            \"* `ExternalDNS`\\n\" +\n+            \"* `ExternalIP`\\n\" +\n+            \"* `InternalDNS`\\n\" +\n+            \"* `InternalIP`\\n\" +\n+            \"* `Hostname`\\n\" +\n+            \"\\n\" +\n+            \"This field can be used to select the address type which will be used as the preferred type and checked first. \" +\n+            \"In case no address will be found for this address type, the other types will be used in the default order.\" +\n+            \"This field can be used only with `nodeport` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public NodeAddressType getPreferredAddressType() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3OTE2Ng=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzAzMjY3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListenerConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0NzoyM1rOHNFPXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMjowMDoxN1rOHNK2fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3OTM5MQ==", "bodyText": "Similarly externalLoadbalancerTrafficPolicy?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483479391", "createdAt": "2020-09-04T08:47:23Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListenerConfiguration.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.CertAndKeySecretSource;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Collections.emptyMap;\n+\n+/**\n+ * Configures Kafka listeners\n+ */\n+@JsonPropertyOrder({\"brokerCertChainAndKey\", \"ingressClass\", \"preferredAddressType\", \"externalTrafficPolicy\", \"loadBalancerSourceRanges\", \"bootstrap\", \"brokers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Buildable(\n+    editableEnabled = false,\n+    builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@EqualsAndHashCode\n+public class GenericKafkaListenerConfiguration implements Serializable, UnknownPropertyPreserving {\n+    private static final long serialVersionUID = 1L;\n+\n+    private CertAndKeySecretSource brokerCertChainAndKey;\n+    private String ingressClass;\n+    private NodeAddressType preferredAddressType;\n+    private ExternalTrafficPolicy externalTrafficPolicy;\n+    private List<String> loadBalancerSourceRanges = new ArrayList<>(0);\n+    private Boolean useServiceDnsDomain;\n+    private GenericKafkaListenerConfigurationBootstrap bootstrap;\n+    private List<GenericKafkaListenerConfigurationBroker> brokers;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. \" +\n+            \"The certificate can optionally contain the whole chain. \" +\n+            \"This field can be used only with listeners with enabled TLS encryption.\")\n+    public CertAndKeySecretSource getBrokerCertChainAndKey() {\n+        return brokerCertChainAndKey;\n+    }\n+\n+    public void setBrokerCertChainAndKey(CertAndKeySecretSource brokerCertChainAndKey) {\n+        this.brokerCertChainAndKey = brokerCertChainAndKey;\n+    }\n+\n+    @Description(\"Configures the `Ingress` class that defines which `Ingress` controller will be used. \" +\n+            \"If not set, the `Ingress` class is set to `nginx`. \" +\n+            \"This field can be used only with `ingress` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @JsonProperty(\"class\")\n+    public String getIngressClass() {\n+        return ingressClass;\n+    }\n+\n+    public void setIngressClass(String ingressClass) {\n+        this.ingressClass = ingressClass;\n+    }\n+\n+    @Description(\"Defines which address type should be used as the node address. \" +\n+            \"Available types are: `ExternalDNS`, `ExternalIP`, `InternalDNS`, `InternalIP` and `Hostname`. \" +\n+            \"By default, the addresses will be used in the following order (the first one found will be used):\\n\" +\n+            \"* `ExternalDNS`\\n\" +\n+            \"* `ExternalIP`\\n\" +\n+            \"* `InternalDNS`\\n\" +\n+            \"* `InternalIP`\\n\" +\n+            \"* `Hostname`\\n\" +\n+            \"\\n\" +\n+            \"This field can be used to select the address type which will be used as the preferred type and checked first. \" +\n+            \"In case no address will be found for this address type, the other types will be used in the default order.\" +\n+            \"This field can be used only with `nodeport` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public NodeAddressType getPreferredAddressType() {\n+        return preferredAddressType;\n+    }\n+\n+    public void setPreferredAddressType(NodeAddressType preferredAddressType) {\n+        this.preferredAddressType = preferredAddressType;\n+    }\n+\n+    @Description(\"Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. \" +\n+            \"`Cluster` may cause a second hop to another node and obscures the client source IP. \" +\n+            \"`Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). \" +\n+            \"If unspecified, Kubernetes will use `Cluster` as the default.\" +\n+            \"This field can be used only with `loadbalancer` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public ExternalTrafficPolicy getExternalTrafficPolicy() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3MTMyNw==", "bodyText": "Again, I think externalTrafficPolicy is a Kubernetes field, so I think it is best to keep it that way. I also found out it could be used with node ports as well and updated the description.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483571327", "createdAt": "2020-09-04T12:00:17Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListenerConfiguration.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.CertAndKeySecretSource;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Collections.emptyMap;\n+\n+/**\n+ * Configures Kafka listeners\n+ */\n+@JsonPropertyOrder({\"brokerCertChainAndKey\", \"ingressClass\", \"preferredAddressType\", \"externalTrafficPolicy\", \"loadBalancerSourceRanges\", \"bootstrap\", \"brokers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Buildable(\n+    editableEnabled = false,\n+    builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@EqualsAndHashCode\n+public class GenericKafkaListenerConfiguration implements Serializable, UnknownPropertyPreserving {\n+    private static final long serialVersionUID = 1L;\n+\n+    private CertAndKeySecretSource brokerCertChainAndKey;\n+    private String ingressClass;\n+    private NodeAddressType preferredAddressType;\n+    private ExternalTrafficPolicy externalTrafficPolicy;\n+    private List<String> loadBalancerSourceRanges = new ArrayList<>(0);\n+    private Boolean useServiceDnsDomain;\n+    private GenericKafkaListenerConfigurationBootstrap bootstrap;\n+    private List<GenericKafkaListenerConfigurationBroker> brokers;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. \" +\n+            \"The certificate can optionally contain the whole chain. \" +\n+            \"This field can be used only with listeners with enabled TLS encryption.\")\n+    public CertAndKeySecretSource getBrokerCertChainAndKey() {\n+        return brokerCertChainAndKey;\n+    }\n+\n+    public void setBrokerCertChainAndKey(CertAndKeySecretSource brokerCertChainAndKey) {\n+        this.brokerCertChainAndKey = brokerCertChainAndKey;\n+    }\n+\n+    @Description(\"Configures the `Ingress` class that defines which `Ingress` controller will be used. \" +\n+            \"If not set, the `Ingress` class is set to `nginx`. \" +\n+            \"This field can be used only with `ingress` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @JsonProperty(\"class\")\n+    public String getIngressClass() {\n+        return ingressClass;\n+    }\n+\n+    public void setIngressClass(String ingressClass) {\n+        this.ingressClass = ingressClass;\n+    }\n+\n+    @Description(\"Defines which address type should be used as the node address. \" +\n+            \"Available types are: `ExternalDNS`, `ExternalIP`, `InternalDNS`, `InternalIP` and `Hostname`. \" +\n+            \"By default, the addresses will be used in the following order (the first one found will be used):\\n\" +\n+            \"* `ExternalDNS`\\n\" +\n+            \"* `ExternalIP`\\n\" +\n+            \"* `InternalDNS`\\n\" +\n+            \"* `InternalIP`\\n\" +\n+            \"* `Hostname`\\n\" +\n+            \"\\n\" +\n+            \"This field can be used to select the address type which will be used as the preferred type and checked first. \" +\n+            \"In case no address will be found for this address type, the other types will be used in the default order.\" +\n+            \"This field can be used only with `nodeport` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public NodeAddressType getPreferredAddressType() {\n+        return preferredAddressType;\n+    }\n+\n+    public void setPreferredAddressType(NodeAddressType preferredAddressType) {\n+        this.preferredAddressType = preferredAddressType;\n+    }\n+\n+    @Description(\"Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. \" +\n+            \"`Cluster` may cause a second hop to another node and obscures the client source IP. \" +\n+            \"`Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). \" +\n+            \"If unspecified, Kubernetes will use `Cluster` as the default.\" +\n+            \"This field can be used only with `loadbalancer` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public ExternalTrafficPolicy getExternalTrafficPolicy() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3OTM5MQ=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzAzMjkxOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaBrokerConfigurationBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0NzoyN1rOHNFPhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0NzoyN1rOHNFPhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3OTQyOA==", "bodyText": "I assume this can be removed?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483479428", "createdAt": "2020-09-04T08:47:27Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaBrokerConfigurationBuilder.java", "diffHunk": "@@ -301,15 +226,15 @@ private void configureReplicationListener() {\n      *\n      * @return  String with advertised listener configuration\n      */\n-    private String getAdvertisedListener(String clusterName, String namespace, String listenerName, int port)    {\n+    /*private String getAdvertisedListener(String clusterName, String namespace, String listenerName, int port)    {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzA0NTYyOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo1MDo1NVrOHNFXEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTowOTowNFrOHNF-aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ4MTM2Mw==", "bodyText": "Does this not break us for non openshift?\nSince it is always deploying with routes?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483481363", "createdAt": "2020-09-04T08:50:55Z", "author": {"login": "samuel-hawker"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -835,327 +766,261 @@ public Service generateService() {\n     /*test*/ Map<String, String> getInternalDiscoveryAnnotation() {\n         JsonArray anno = new JsonArray();\n \n-        if (listeners != null) {\n-            if (listeners.getPlain() != null) {\n-                JsonObject discovery = new JsonObject();\n-                discovery.put(\"port\", 9092);\n-                discovery.put(\"tls\", false);\n-                discovery.put(\"protocol\", \"kafka\");\n-\n-                if (listeners.getPlain().getAuth() != null) {\n-                    discovery.put(\"auth\", listeners.getPlain().getAuth().getType());\n-                } else {\n-                    discovery.put(\"auth\", \"none\");\n-                }\n+        for (GenericKafkaListener listener : listeners) {\n+            JsonObject discovery = new JsonObject();\n+            discovery.put(\"port\", listener.getPort());\n+            discovery.put(\"tls\", listener.isTls());\n+            discovery.put(\"protocol\", \"kafka\");\n \n-                anno.add(discovery);\n+            if (listener.getAuth() != null) {\n+                discovery.put(\"auth\", listener.getAuth().getType());\n+            } else {\n+                discovery.put(\"auth\", \"none\");\n             }\n \n-            if (listeners.getTls() != null) {\n-                JsonObject discovery = new JsonObject();\n-                discovery.put(\"port\", 9093);\n-                discovery.put(\"tls\", true);\n-                discovery.put(\"protocol\", \"kafka\");\n-\n-                if (listeners.getTls().getAuth() != null) {\n-                    discovery.put(\"auth\", listeners.getTls().getAuth().getType());\n-                } else {\n-                    discovery.put(\"auth\", \"none\");\n-                }\n-\n-                anno.add(discovery);\n-            }\n+            anno.add(discovery);\n         }\n \n         return singletonMap(Labels.STRIMZI_DISCOVERY_LABEL, anno.encodePrettily());\n     }\n \n     /**\n-     * Utility function to help to determine the type of service based on external listener configuration\n+     * Generates list of external bootstrap services. These services are used for exposing it externally.\n+     * Separate services are used to make sure that we do expose the right port in the right way.\n      *\n-     * @return Service type\n+     * @return The list with generated Services\n      */\n-    private String getExternalServiceType() {\n-        if (isExposedWithNodePort()) {\n-            return \"NodePort\";\n-        } else if (isExposedWithLoadBalancer()) {\n-            return \"LoadBalancer\";\n-        } else {\n-            return \"ClusterIP\";\n-        }\n-    }\n-\n-    /**\n-     * Generates external bootstrap service. This service is used for exposing it externally.\n-     * It exposes only the external port 9094.\n-     * Separate service is used to make sure that we do not expose the internal ports to the outside of the cluster\n-     *\n-     * @return The generated Service\n-     */\n-    public Service generateExternalBootstrapService() {\n-        if (isExposed()) {\n-            String externalBootstrapServiceName = externalBootstrapServiceName(cluster);\n-\n-            List<ServicePort> ports;\n-            Integer nodePort = null;\n-            if (isExposedWithNodePort()) {\n-                KafkaListenerExternalNodePort externalNodePort = (KafkaListenerExternalNodePort) listeners.getExternal();\n-                if (externalNodePort.getOverrides() != null && externalNodePort.getOverrides().getBootstrap() != null) {\n-                    nodePort = externalNodePort.getOverrides().getBootstrap().getNodePort();\n-                }\n-            }\n-            ports = Collections.singletonList(createServicePort(EXTERNAL_PORT_NAME, EXTERNAL_PORT, EXTERNAL_PORT,\n-                    nodePort, \"TCP\"));\n-\n-            Map<String, String> dnsAnnotations = Collections.emptyMap();\n-            String loadBalancerIP = null;\n-\n-            if (isExposedWithLoadBalancer())    {\n-                KafkaListenerExternalLoadBalancer externalLb = (KafkaListenerExternalLoadBalancer) listeners.getExternal();\n-\n-                if (externalLb.getOverrides() != null && externalLb.getOverrides().getBootstrap() != null) {\n-                    dnsAnnotations = externalLb.getOverrides().getBootstrap().getDnsAnnotations();\n-                    loadBalancerIP = externalLb.getOverrides().getBootstrap().getLoadBalancerIP();\n-                }\n-            } else if (isExposedWithNodePort()) {\n-                KafkaListenerExternalNodePort externalNp = (KafkaListenerExternalNodePort) listeners.getExternal();\n-\n-                if (externalNp.getOverrides() != null && externalNp.getOverrides().getBootstrap() != null) {\n-                    dnsAnnotations = externalNp.getOverrides().getBootstrap().getDnsAnnotations();\n+    public List<Service> generateExternalBootstrapServices() {\n+        List<GenericKafkaListener> externalListeners = ListenersUtils.externalListeners(listeners);\n+        List<Service> services = new ArrayList<>(externalListeners.size());\n+\n+        for (GenericKafkaListener listener : externalListeners)   {\n+            String serviceName = ListenersUtils.backwardsCompatibleBootstrapServiceName(cluster, listener);\n+\n+            List<ServicePort> ports = Collections.singletonList(\n+                    createServicePort(ListenersUtils.backwardsCompatiblePortName(listener),\n+                            listener.getPort(),\n+                            listener.getPort(),\n+                            ListenersUtils.bootstrapNodePort(listener),\n+                            \"TCP\")\n+            );\n+\n+            Service service = createService(\n+                    serviceName,\n+                    ListenersUtils.getServiceType(listener),\n+                    ports,\n+                    getLabelsWithStrimziName(name, templateExternalBootstrapServiceLabels),\n+                    getSelectorLabels(),\n+                    Util.mergeLabelsOrAnnotations(ListenersUtils.bootstrapDnsAnnotations(listener), templateExternalBootstrapServiceAnnotations)\n+            );\n+\n+            if (KafkaListenerType.LOADBALANCER == listener.getType()) {\n+                String loadBalancerIP = ListenersUtils.bootstrapLoadBalancerIP(listener);\n+                if (loadBalancerIP != null) {\n+                    service.getSpec().setLoadBalancerIP(loadBalancerIP);\n                 }\n             }\n \n-            Service service = createService(externalBootstrapServiceName, getExternalServiceType(), ports,\n-                    getLabelsWithStrimziName(externalBootstrapServiceName, templateExternalBootstrapServiceLabels), getSelectorLabels(),\n-                    Util.mergeLabelsOrAnnotations(dnsAnnotations, templateExternalBootstrapServiceAnnotations), loadBalancerIP);\n-\n-            if (isExposedWithLoadBalancer()) {\n-                if (templateExternalBootstrapServiceLoadBalancerSourceRanges != null) {\n+            if (KafkaListenerType.LOADBALANCER == listener.getType()) {\n+                List<String> loadBalancerSourceRanges = ListenersUtils.loadBalancerSourceRanges(listener);\n+                if (loadBalancerSourceRanges != null) {\n+                    service.getSpec().setLoadBalancerSourceRanges(loadBalancerSourceRanges);\n+                } else if (templateExternalBootstrapServiceLoadBalancerSourceRanges != null) {\n                     service.getSpec().setLoadBalancerSourceRanges(templateExternalBootstrapServiceLoadBalancerSourceRanges);\n                 }\n             }\n \n-            if (isExposedWithLoadBalancer() || isExposedWithNodePort()) {\n-                if (templateExternalBootstrapServiceTrafficPolicy != null)  {\n+            if (KafkaListenerType.LOADBALANCER == listener.getType() || KafkaListenerType.NODEPORT == listener.getType()) {\n+                ExternalTrafficPolicy etp = ListenersUtils.externalTrafficPolicy(listener);\n+                if (etp != null) {\n+                    service.getSpec().setExternalTrafficPolicy(etp.toValue());\n+                } else if (templateExternalBootstrapServiceTrafficPolicy != null) {\n                     service.getSpec().setExternalTrafficPolicy(templateExternalBootstrapServiceTrafficPolicy.toValue());\n                 }\n             }\n \n-            return service;\n+            services.add(service);\n         }\n \n-        return null;\n+        return services;\n     }\n \n     /**\n-     * Generates service for pod. This service is used for exposing it externally.\n+     * Generates list of service for pod. These services are used for exposing it externally.\n      *\n      * @param pod Number of the pod for which this service should be generated\n-     * @return The generated Service\n+     * @return The list with generated Services\n      */\n-    public Service generateExternalService(int pod) {\n-        if (isExposed()) {\n-            String perPodServiceName = externalServiceName(cluster, pod);\n-\n-            List<ServicePort> ports = new ArrayList<>(1);\n-            Integer nodePort = null;\n-            if (isExposedWithNodePort()) {\n-                KafkaListenerExternalNodePort externalNodePort = (KafkaListenerExternalNodePort) listeners.getExternal();\n-                if (externalNodePort.getOverrides() != null && externalNodePort.getOverrides().getBrokers() != null) {\n-                    nodePort = externalNodePort.getOverrides().getBrokers().stream()\n-                            .filter(broker -> broker != null && broker.getBroker() != null && broker.getBroker() == pod && broker.getNodePort() != null)\n-                            .map(NodePortListenerBrokerOverride::getNodePort)\n-                            .findAny().orElse(null);\n-                }\n-            }\n-            ports.add(createServicePort(EXTERNAL_PORT_NAME, EXTERNAL_PORT, EXTERNAL_PORT, nodePort, \"TCP\"));\n-\n-            Map<String, String> dnsAnnotations = Collections.emptyMap();\n-            String loadBalancerIP = null;\n-\n-            if (isExposedWithLoadBalancer())    {\n-                KafkaListenerExternalLoadBalancer externalLb = (KafkaListenerExternalLoadBalancer) listeners.getExternal();\n-\n-                if (externalLb.getOverrides() != null && externalLb.getOverrides().getBrokers() != null) {\n-                    dnsAnnotations = externalLb.getOverrides().getBrokers().stream()\n-                            .filter(broker -> broker != null && broker.getBroker() == pod)\n-                            .map(LoadBalancerListenerBrokerOverride::getDnsAnnotations)\n-                            .findAny()\n-                            .orElse(Collections.emptyMap());\n-\n-                    loadBalancerIP = externalLb.getOverrides().getBrokers().stream()\n-                            .filter(brokerService -> brokerService != null && brokerService.getBroker() == pod\n-                                    && brokerService.getLoadBalancerIP() != null)\n-                            .map(LoadBalancerListenerBrokerOverride::getLoadBalancerIP)\n-                            .findAny()\n-                            .orElse(null);\n-\n-                    if (loadBalancerIP != null && loadBalancerIP.isEmpty()) {\n-                        loadBalancerIP = null;\n-                    }\n-                }\n-            } else if (isExposedWithNodePort()) {\n-                KafkaListenerExternalNodePort externalNp = (KafkaListenerExternalNodePort) listeners.getExternal();\n-\n-                if (externalNp.getOverrides() != null && externalNp.getOverrides().getBrokers() != null) {\n-                    dnsAnnotations = externalNp.getOverrides().getBrokers().stream()\n-                            .filter(broker -> broker != null && broker.getBroker() == pod)\n-                            .map(NodePortListenerBrokerOverride::getDnsAnnotations)\n-                            .findAny()\n-                            .orElse(Collections.emptyMap());\n-                }\n-            }\n+    public List<Service> generateExternalServices(int pod) {\n+        List<GenericKafkaListener> externalListeners = ListenersUtils.externalListeners(listeners);\n+        List<Service> services = new ArrayList<>(externalListeners.size());\n+\n+        for (GenericKafkaListener listener : externalListeners)   {\n+            String serviceName = ListenersUtils.backwardsCompatibleBrokerServiceName(cluster, pod, listener);\n+\n+            List<ServicePort> ports = Collections.singletonList(\n+                    createServicePort(ListenersUtils.backwardsCompatiblePortName(listener),\n+                            listener.getPort(),\n+                            listener.getPort(),\n+                            ListenersUtils.brokerNodePort(listener, pod),\n+                            \"TCP\")\n+            );\n \n             Labels selector = getSelectorLabels().withStatefulSetPod(kafkaPodName(cluster, pod));\n \n-            Service service = createService(perPodServiceName, getExternalServiceType(), ports,\n-                    getLabelsWithStrimziName(perPodServiceName, templatePerPodServiceLabels), selector,\n-                    Util.mergeLabelsOrAnnotations(dnsAnnotations, templatePerPodServiceAnnotations), loadBalancerIP);\n+            Service service = createService(\n+                    serviceName,\n+                    ListenersUtils.getServiceType(listener),\n+                    ports,\n+                    getLabelsWithStrimziName(name, templatePerPodServiceLabels),\n+                    selector,\n+                    Util.mergeLabelsOrAnnotations(ListenersUtils.brokerDnsAnnotations(listener, pod), templatePerPodServiceAnnotations)\n+            );\n+\n+            if (KafkaListenerType.LOADBALANCER == listener.getType()) {\n+                String loadBalancerIP = ListenersUtils.brokerLoadBalancerIP(listener, pod);\n+                if (loadBalancerIP != null) {\n+                    service.getSpec().setLoadBalancerIP(loadBalancerIP);\n+                }\n+            }\n \n-            if (isExposedWithLoadBalancer()) {\n-                if (templatePerPodServiceLoadBalancerSourceRanges != null) {\n+            if (KafkaListenerType.LOADBALANCER == listener.getType()) {\n+                List<String> loadBalancerSourceRanges = ListenersUtils.loadBalancerSourceRanges(listener);\n+                if (loadBalancerSourceRanges != null) {\n+                    service.getSpec().setLoadBalancerSourceRanges(loadBalancerSourceRanges);\n+                } else if (templatePerPodServiceLoadBalancerSourceRanges != null) {\n                     service.getSpec().setLoadBalancerSourceRanges(templatePerPodServiceLoadBalancerSourceRanges);\n                 }\n             }\n \n-            if (isExposedWithLoadBalancer() || isExposedWithNodePort()) {\n-                if (templatePerPodServiceTrafficPolicy != null)  {\n+            if (KafkaListenerType.LOADBALANCER == listener.getType() || KafkaListenerType.NODEPORT == listener.getType()) {\n+                ExternalTrafficPolicy etp = ListenersUtils.externalTrafficPolicy(listener);\n+                if (etp != null) {\n+                    service.getSpec().setExternalTrafficPolicy(etp.toValue());\n+                } else if (templatePerPodServiceTrafficPolicy != null) {\n                     service.getSpec().setExternalTrafficPolicy(templatePerPodServiceTrafficPolicy.toValue());\n                 }\n             }\n \n-            return service;\n+            services.add(service);\n         }\n \n-        return null;\n+        return services;\n     }\n \n-    /**\n-     * Generates route for pod. This route is used for exposing it externally using OpenShift Routes.\n+        /**\n+     * Generates a list of bootstrap route which can be used to bootstrap clients outside of OpenShift.\n      *\n-     * @param pod Number of the pod for which this route should be generated\n-     * @return The generated Route\n+     * @return The list of generated Routes\n      */\n-    public Route generateExternalRoute(int pod) {\n-        if (isExposedWithRoute()) {\n-            String perPodServiceName = externalServiceName(cluster, pod);\n+    public List<Route> generateExternalBootstrapRoutes() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 568}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5MTQzMg==", "bodyText": "In a short, it does not. As a longer answer, this just generates some objects when called from KafkaAssemblyOperator which decides when to call it and when to not all it. So the protection is in there. I develop on Kubernetes, so this does not cause any issues.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483491432", "createdAt": "2020-09-04T09:09:04Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -835,327 +766,261 @@ public Service generateService() {\n     /*test*/ Map<String, String> getInternalDiscoveryAnnotation() {\n         JsonArray anno = new JsonArray();\n \n-        if (listeners != null) {\n-            if (listeners.getPlain() != null) {\n-                JsonObject discovery = new JsonObject();\n-                discovery.put(\"port\", 9092);\n-                discovery.put(\"tls\", false);\n-                discovery.put(\"protocol\", \"kafka\");\n-\n-                if (listeners.getPlain().getAuth() != null) {\n-                    discovery.put(\"auth\", listeners.getPlain().getAuth().getType());\n-                } else {\n-                    discovery.put(\"auth\", \"none\");\n-                }\n+        for (GenericKafkaListener listener : listeners) {\n+            JsonObject discovery = new JsonObject();\n+            discovery.put(\"port\", listener.getPort());\n+            discovery.put(\"tls\", listener.isTls());\n+            discovery.put(\"protocol\", \"kafka\");\n \n-                anno.add(discovery);\n+            if (listener.getAuth() != null) {\n+                discovery.put(\"auth\", listener.getAuth().getType());\n+            } else {\n+                discovery.put(\"auth\", \"none\");\n             }\n \n-            if (listeners.getTls() != null) {\n-                JsonObject discovery = new JsonObject();\n-                discovery.put(\"port\", 9093);\n-                discovery.put(\"tls\", true);\n-                discovery.put(\"protocol\", \"kafka\");\n-\n-                if (listeners.getTls().getAuth() != null) {\n-                    discovery.put(\"auth\", listeners.getTls().getAuth().getType());\n-                } else {\n-                    discovery.put(\"auth\", \"none\");\n-                }\n-\n-                anno.add(discovery);\n-            }\n+            anno.add(discovery);\n         }\n \n         return singletonMap(Labels.STRIMZI_DISCOVERY_LABEL, anno.encodePrettily());\n     }\n \n     /**\n-     * Utility function to help to determine the type of service based on external listener configuration\n+     * Generates list of external bootstrap services. These services are used for exposing it externally.\n+     * Separate services are used to make sure that we do expose the right port in the right way.\n      *\n-     * @return Service type\n+     * @return The list with generated Services\n      */\n-    private String getExternalServiceType() {\n-        if (isExposedWithNodePort()) {\n-            return \"NodePort\";\n-        } else if (isExposedWithLoadBalancer()) {\n-            return \"LoadBalancer\";\n-        } else {\n-            return \"ClusterIP\";\n-        }\n-    }\n-\n-    /**\n-     * Generates external bootstrap service. This service is used for exposing it externally.\n-     * It exposes only the external port 9094.\n-     * Separate service is used to make sure that we do not expose the internal ports to the outside of the cluster\n-     *\n-     * @return The generated Service\n-     */\n-    public Service generateExternalBootstrapService() {\n-        if (isExposed()) {\n-            String externalBootstrapServiceName = externalBootstrapServiceName(cluster);\n-\n-            List<ServicePort> ports;\n-            Integer nodePort = null;\n-            if (isExposedWithNodePort()) {\n-                KafkaListenerExternalNodePort externalNodePort = (KafkaListenerExternalNodePort) listeners.getExternal();\n-                if (externalNodePort.getOverrides() != null && externalNodePort.getOverrides().getBootstrap() != null) {\n-                    nodePort = externalNodePort.getOverrides().getBootstrap().getNodePort();\n-                }\n-            }\n-            ports = Collections.singletonList(createServicePort(EXTERNAL_PORT_NAME, EXTERNAL_PORT, EXTERNAL_PORT,\n-                    nodePort, \"TCP\"));\n-\n-            Map<String, String> dnsAnnotations = Collections.emptyMap();\n-            String loadBalancerIP = null;\n-\n-            if (isExposedWithLoadBalancer())    {\n-                KafkaListenerExternalLoadBalancer externalLb = (KafkaListenerExternalLoadBalancer) listeners.getExternal();\n-\n-                if (externalLb.getOverrides() != null && externalLb.getOverrides().getBootstrap() != null) {\n-                    dnsAnnotations = externalLb.getOverrides().getBootstrap().getDnsAnnotations();\n-                    loadBalancerIP = externalLb.getOverrides().getBootstrap().getLoadBalancerIP();\n-                }\n-            } else if (isExposedWithNodePort()) {\n-                KafkaListenerExternalNodePort externalNp = (KafkaListenerExternalNodePort) listeners.getExternal();\n-\n-                if (externalNp.getOverrides() != null && externalNp.getOverrides().getBootstrap() != null) {\n-                    dnsAnnotations = externalNp.getOverrides().getBootstrap().getDnsAnnotations();\n+    public List<Service> generateExternalBootstrapServices() {\n+        List<GenericKafkaListener> externalListeners = ListenersUtils.externalListeners(listeners);\n+        List<Service> services = new ArrayList<>(externalListeners.size());\n+\n+        for (GenericKafkaListener listener : externalListeners)   {\n+            String serviceName = ListenersUtils.backwardsCompatibleBootstrapServiceName(cluster, listener);\n+\n+            List<ServicePort> ports = Collections.singletonList(\n+                    createServicePort(ListenersUtils.backwardsCompatiblePortName(listener),\n+                            listener.getPort(),\n+                            listener.getPort(),\n+                            ListenersUtils.bootstrapNodePort(listener),\n+                            \"TCP\")\n+            );\n+\n+            Service service = createService(\n+                    serviceName,\n+                    ListenersUtils.getServiceType(listener),\n+                    ports,\n+                    getLabelsWithStrimziName(name, templateExternalBootstrapServiceLabels),\n+                    getSelectorLabels(),\n+                    Util.mergeLabelsOrAnnotations(ListenersUtils.bootstrapDnsAnnotations(listener), templateExternalBootstrapServiceAnnotations)\n+            );\n+\n+            if (KafkaListenerType.LOADBALANCER == listener.getType()) {\n+                String loadBalancerIP = ListenersUtils.bootstrapLoadBalancerIP(listener);\n+                if (loadBalancerIP != null) {\n+                    service.getSpec().setLoadBalancerIP(loadBalancerIP);\n                 }\n             }\n \n-            Service service = createService(externalBootstrapServiceName, getExternalServiceType(), ports,\n-                    getLabelsWithStrimziName(externalBootstrapServiceName, templateExternalBootstrapServiceLabels), getSelectorLabels(),\n-                    Util.mergeLabelsOrAnnotations(dnsAnnotations, templateExternalBootstrapServiceAnnotations), loadBalancerIP);\n-\n-            if (isExposedWithLoadBalancer()) {\n-                if (templateExternalBootstrapServiceLoadBalancerSourceRanges != null) {\n+            if (KafkaListenerType.LOADBALANCER == listener.getType()) {\n+                List<String> loadBalancerSourceRanges = ListenersUtils.loadBalancerSourceRanges(listener);\n+                if (loadBalancerSourceRanges != null) {\n+                    service.getSpec().setLoadBalancerSourceRanges(loadBalancerSourceRanges);\n+                } else if (templateExternalBootstrapServiceLoadBalancerSourceRanges != null) {\n                     service.getSpec().setLoadBalancerSourceRanges(templateExternalBootstrapServiceLoadBalancerSourceRanges);\n                 }\n             }\n \n-            if (isExposedWithLoadBalancer() || isExposedWithNodePort()) {\n-                if (templateExternalBootstrapServiceTrafficPolicy != null)  {\n+            if (KafkaListenerType.LOADBALANCER == listener.getType() || KafkaListenerType.NODEPORT == listener.getType()) {\n+                ExternalTrafficPolicy etp = ListenersUtils.externalTrafficPolicy(listener);\n+                if (etp != null) {\n+                    service.getSpec().setExternalTrafficPolicy(etp.toValue());\n+                } else if (templateExternalBootstrapServiceTrafficPolicy != null) {\n                     service.getSpec().setExternalTrafficPolicy(templateExternalBootstrapServiceTrafficPolicy.toValue());\n                 }\n             }\n \n-            return service;\n+            services.add(service);\n         }\n \n-        return null;\n+        return services;\n     }\n \n     /**\n-     * Generates service for pod. This service is used for exposing it externally.\n+     * Generates list of service for pod. These services are used for exposing it externally.\n      *\n      * @param pod Number of the pod for which this service should be generated\n-     * @return The generated Service\n+     * @return The list with generated Services\n      */\n-    public Service generateExternalService(int pod) {\n-        if (isExposed()) {\n-            String perPodServiceName = externalServiceName(cluster, pod);\n-\n-            List<ServicePort> ports = new ArrayList<>(1);\n-            Integer nodePort = null;\n-            if (isExposedWithNodePort()) {\n-                KafkaListenerExternalNodePort externalNodePort = (KafkaListenerExternalNodePort) listeners.getExternal();\n-                if (externalNodePort.getOverrides() != null && externalNodePort.getOverrides().getBrokers() != null) {\n-                    nodePort = externalNodePort.getOverrides().getBrokers().stream()\n-                            .filter(broker -> broker != null && broker.getBroker() != null && broker.getBroker() == pod && broker.getNodePort() != null)\n-                            .map(NodePortListenerBrokerOverride::getNodePort)\n-                            .findAny().orElse(null);\n-                }\n-            }\n-            ports.add(createServicePort(EXTERNAL_PORT_NAME, EXTERNAL_PORT, EXTERNAL_PORT, nodePort, \"TCP\"));\n-\n-            Map<String, String> dnsAnnotations = Collections.emptyMap();\n-            String loadBalancerIP = null;\n-\n-            if (isExposedWithLoadBalancer())    {\n-                KafkaListenerExternalLoadBalancer externalLb = (KafkaListenerExternalLoadBalancer) listeners.getExternal();\n-\n-                if (externalLb.getOverrides() != null && externalLb.getOverrides().getBrokers() != null) {\n-                    dnsAnnotations = externalLb.getOverrides().getBrokers().stream()\n-                            .filter(broker -> broker != null && broker.getBroker() == pod)\n-                            .map(LoadBalancerListenerBrokerOverride::getDnsAnnotations)\n-                            .findAny()\n-                            .orElse(Collections.emptyMap());\n-\n-                    loadBalancerIP = externalLb.getOverrides().getBrokers().stream()\n-                            .filter(brokerService -> brokerService != null && brokerService.getBroker() == pod\n-                                    && brokerService.getLoadBalancerIP() != null)\n-                            .map(LoadBalancerListenerBrokerOverride::getLoadBalancerIP)\n-                            .findAny()\n-                            .orElse(null);\n-\n-                    if (loadBalancerIP != null && loadBalancerIP.isEmpty()) {\n-                        loadBalancerIP = null;\n-                    }\n-                }\n-            } else if (isExposedWithNodePort()) {\n-                KafkaListenerExternalNodePort externalNp = (KafkaListenerExternalNodePort) listeners.getExternal();\n-\n-                if (externalNp.getOverrides() != null && externalNp.getOverrides().getBrokers() != null) {\n-                    dnsAnnotations = externalNp.getOverrides().getBrokers().stream()\n-                            .filter(broker -> broker != null && broker.getBroker() == pod)\n-                            .map(NodePortListenerBrokerOverride::getDnsAnnotations)\n-                            .findAny()\n-                            .orElse(Collections.emptyMap());\n-                }\n-            }\n+    public List<Service> generateExternalServices(int pod) {\n+        List<GenericKafkaListener> externalListeners = ListenersUtils.externalListeners(listeners);\n+        List<Service> services = new ArrayList<>(externalListeners.size());\n+\n+        for (GenericKafkaListener listener : externalListeners)   {\n+            String serviceName = ListenersUtils.backwardsCompatibleBrokerServiceName(cluster, pod, listener);\n+\n+            List<ServicePort> ports = Collections.singletonList(\n+                    createServicePort(ListenersUtils.backwardsCompatiblePortName(listener),\n+                            listener.getPort(),\n+                            listener.getPort(),\n+                            ListenersUtils.brokerNodePort(listener, pod),\n+                            \"TCP\")\n+            );\n \n             Labels selector = getSelectorLabels().withStatefulSetPod(kafkaPodName(cluster, pod));\n \n-            Service service = createService(perPodServiceName, getExternalServiceType(), ports,\n-                    getLabelsWithStrimziName(perPodServiceName, templatePerPodServiceLabels), selector,\n-                    Util.mergeLabelsOrAnnotations(dnsAnnotations, templatePerPodServiceAnnotations), loadBalancerIP);\n+            Service service = createService(\n+                    serviceName,\n+                    ListenersUtils.getServiceType(listener),\n+                    ports,\n+                    getLabelsWithStrimziName(name, templatePerPodServiceLabels),\n+                    selector,\n+                    Util.mergeLabelsOrAnnotations(ListenersUtils.brokerDnsAnnotations(listener, pod), templatePerPodServiceAnnotations)\n+            );\n+\n+            if (KafkaListenerType.LOADBALANCER == listener.getType()) {\n+                String loadBalancerIP = ListenersUtils.brokerLoadBalancerIP(listener, pod);\n+                if (loadBalancerIP != null) {\n+                    service.getSpec().setLoadBalancerIP(loadBalancerIP);\n+                }\n+            }\n \n-            if (isExposedWithLoadBalancer()) {\n-                if (templatePerPodServiceLoadBalancerSourceRanges != null) {\n+            if (KafkaListenerType.LOADBALANCER == listener.getType()) {\n+                List<String> loadBalancerSourceRanges = ListenersUtils.loadBalancerSourceRanges(listener);\n+                if (loadBalancerSourceRanges != null) {\n+                    service.getSpec().setLoadBalancerSourceRanges(loadBalancerSourceRanges);\n+                } else if (templatePerPodServiceLoadBalancerSourceRanges != null) {\n                     service.getSpec().setLoadBalancerSourceRanges(templatePerPodServiceLoadBalancerSourceRanges);\n                 }\n             }\n \n-            if (isExposedWithLoadBalancer() || isExposedWithNodePort()) {\n-                if (templatePerPodServiceTrafficPolicy != null)  {\n+            if (KafkaListenerType.LOADBALANCER == listener.getType() || KafkaListenerType.NODEPORT == listener.getType()) {\n+                ExternalTrafficPolicy etp = ListenersUtils.externalTrafficPolicy(listener);\n+                if (etp != null) {\n+                    service.getSpec().setExternalTrafficPolicy(etp.toValue());\n+                } else if (templatePerPodServiceTrafficPolicy != null) {\n                     service.getSpec().setExternalTrafficPolicy(templatePerPodServiceTrafficPolicy.toValue());\n                 }\n             }\n \n-            return service;\n+            services.add(service);\n         }\n \n-        return null;\n+        return services;\n     }\n \n-    /**\n-     * Generates route for pod. This route is used for exposing it externally using OpenShift Routes.\n+        /**\n+     * Generates a list of bootstrap route which can be used to bootstrap clients outside of OpenShift.\n      *\n-     * @param pod Number of the pod for which this route should be generated\n-     * @return The generated Route\n+     * @return The list of generated Routes\n      */\n-    public Route generateExternalRoute(int pod) {\n-        if (isExposedWithRoute()) {\n-            String perPodServiceName = externalServiceName(cluster, pod);\n+    public List<Route> generateExternalBootstrapRoutes() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ4MTM2Mw=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 568}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzA2NzM0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListenerConfigurationBootstrap.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo1NjozNlrOHNFjvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMjoxMjozM1rOHNLLyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ4NDYwNg==", "bodyText": "Can we constrain it using @Pattern to be an IP address?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483484606", "createdAt": "2020-09-04T08:56:36Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListenerConfigurationBootstrap.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures listener bootstrap configuration\n+ */\n+@JsonPropertyOrder({\"alternativeNames\", \"host\", \"dnsAnnotations\", \"nodePort\", \"loadBalancerIP\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Buildable(\n+    editableEnabled = false,\n+    builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@EqualsAndHashCode\n+public class GenericKafkaListenerConfigurationBootstrap implements Serializable, UnknownPropertyPreserving {\n+    private static final long serialVersionUID = 1L;\n+\n+    private List<String> alternativeNames;\n+    private String host;\n+    private Map<String, String> dnsAnnotations = new HashMap<>(0);\n+    private Integer nodePort;\n+    private String loadBalancerIP;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"Additional alternative names for the bootstrap service. \" +\n+            \"The alternative names will be added to the list of subject alternative names of the TLS certificates.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public List<String> getAlternativeNames() {\n+        return alternativeNames;\n+    }\n+\n+    public void setAlternativeNames(List<String> alternativeNames) {\n+        this.alternativeNames = alternativeNames;\n+    }\n+\n+    @Description(\"The bootstrap host. \" +\n+            \"This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. \" +\n+            \"This field can be used only with `route` (optional) or `ingress` (required) type listeners.\")\n+    @JsonProperty(required = true)\n+    public String getHost() {\n+        return host;\n+    }\n+\n+    public void setHost(String host) {\n+        this.host = host;\n+    }\n+\n+    @Description(\"Annotations that will be added to the `Ingress` or `Service` resource. \" +\n+            \"You can use this field to configure DNS providers such as External DNS. \" +\n+            \"This field can be used only with `loadbalancer`, `nodeport`, or `ingress` type listeners.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, String> getDnsAnnotations() {\n+        return dnsAnnotations;\n+    }\n+\n+    public void setDnsAnnotations(Map<String, String> dnsAnnotations) {\n+        this.dnsAnnotations = dnsAnnotations;\n+    }\n+\n+    @Description(\"Node port for the bootstrap service. \" +\n+            \"This field can be used only with `nodeport` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public Integer getNodePort() {\n+        return nodePort;\n+    }\n+\n+    public void setNodePort(Integer nodePort) {\n+        this.nodePort = nodePort;\n+    }\n+\n+    @Description(\"The loadbalancer is requested with the IP address specified in this field. \" +\n+            \"This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. \" +\n+            \"This field is ignored if the cloud provider does not support the feature.\" +\n+            \"This field can be used only with `loadbalancer` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public String getLoadBalancerIP() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3Njc3OQ==", "bodyText": "Kubernetes it self is not doing any validation. So I wonder if some applications might be using it for something what does not match the IP format etc. It gets also a bit more complicated with IPv6 support. So I would probably preffer to keep it as String and leave it for the user.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483576779", "createdAt": "2020-09-04T12:12:33Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListenerConfigurationBootstrap.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Configures listener bootstrap configuration\n+ */\n+@JsonPropertyOrder({\"alternativeNames\", \"host\", \"dnsAnnotations\", \"nodePort\", \"loadBalancerIP\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Buildable(\n+    editableEnabled = false,\n+    builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@EqualsAndHashCode\n+public class GenericKafkaListenerConfigurationBootstrap implements Serializable, UnknownPropertyPreserving {\n+    private static final long serialVersionUID = 1L;\n+\n+    private List<String> alternativeNames;\n+    private String host;\n+    private Map<String, String> dnsAnnotations = new HashMap<>(0);\n+    private Integer nodePort;\n+    private String loadBalancerIP;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"Additional alternative names for the bootstrap service. \" +\n+            \"The alternative names will be added to the list of subject alternative names of the TLS certificates.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public List<String> getAlternativeNames() {\n+        return alternativeNames;\n+    }\n+\n+    public void setAlternativeNames(List<String> alternativeNames) {\n+        this.alternativeNames = alternativeNames;\n+    }\n+\n+    @Description(\"The bootstrap host. \" +\n+            \"This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. \" +\n+            \"This field can be used only with `route` (optional) or `ingress` (required) type listeners.\")\n+    @JsonProperty(required = true)\n+    public String getHost() {\n+        return host;\n+    }\n+\n+    public void setHost(String host) {\n+        this.host = host;\n+    }\n+\n+    @Description(\"Annotations that will be added to the `Ingress` or `Service` resource. \" +\n+            \"You can use this field to configure DNS providers such as External DNS. \" +\n+            \"This field can be used only with `loadbalancer`, `nodeport`, or `ingress` type listeners.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, String> getDnsAnnotations() {\n+        return dnsAnnotations;\n+    }\n+\n+    public void setDnsAnnotations(Map<String, String> dnsAnnotations) {\n+        this.dnsAnnotations = dnsAnnotations;\n+    }\n+\n+    @Description(\"Node port for the bootstrap service. \" +\n+            \"This field can be used only with `nodeport` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public Integer getNodePort() {\n+        return nodePort;\n+    }\n+\n+    public void setNodePort(Integer nodePort) {\n+        this.nodePort = nodePort;\n+    }\n+\n+    @Description(\"The loadbalancer is requested with the IP address specified in this field. \" +\n+            \"This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. \" +\n+            \"This field is ignored if the cloud provider does not support the feature.\" +\n+            \"This field can be used only with `loadbalancer` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public String getLoadBalancerIP() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ4NDYwNg=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzA2OTEyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListenerConfigurationBroker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo1NzowMVrOHNFk1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMjoxMjozOFrOHNLL8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ4NDg4NQ==", "bodyText": "Again, can be use @Pattern?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483484885", "createdAt": "2020-09-04T08:57:01Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListenerConfigurationBroker.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.util.Collections.emptyMap;\n+\n+/**\n+ * Configures listener per-broker configuration\n+ */\n+@JsonPropertyOrder({\"broker\", \"advertisedHost\", \"advertisedPort\", \"host\", \"dnsAnnotations\", \"nodePort\", \"loadBalancerIP\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Buildable(\n+    editableEnabled = false,\n+    builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@EqualsAndHashCode\n+public class GenericKafkaListenerConfigurationBroker implements Serializable, UnknownPropertyPreserving {\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer broker;\n+    private String advertisedHost;\n+    private Integer advertisedPort;\n+    private String host;\n+    private Map<String, String> dnsAnnotations = new HashMap<>(0);\n+    private Integer nodePort;\n+    private String loadBalancerIP;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"ID of the kafka broker (broker identifier). \" +\n+            \"Broker IDs start from 0 and correspond to the number of broker replicas.\")\n+    @JsonProperty(required = true)\n+    public Integer getBroker() {\n+        return broker;\n+    }\n+\n+    public void setBroker(Integer broker) {\n+        this.broker = broker;\n+    }\n+\n+    @Description(\"The host name which will be used in the brokers' `advertised.brokers`\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public String getAdvertisedHost() {\n+        return advertisedHost;\n+    }\n+\n+    public void setAdvertisedHost(String advertisedHost) {\n+        this.advertisedHost = advertisedHost;\n+    }\n+\n+    @Description(\"The port number which will be used in the brokers' `advertised.brokers`\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public Integer getAdvertisedPort() {\n+        return advertisedPort;\n+    }\n+\n+    public void setAdvertisedPort(Integer advertisedPort) {\n+        this.advertisedPort = advertisedPort;\n+    }\n+\n+\n+    @Description(\"The broker host. \" +\n+            \"This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. \" +\n+            \"This field can be used only with `route` (optional) or `ingress` (required) type listeners.\")\n+    @JsonProperty(required = true)\n+    public String getHost() {\n+        return host;\n+    }\n+\n+    public void setHost(String host) {\n+        this.host = host;\n+    }\n+\n+    @Description(\"Annotations that will be added to the `Ingress` or `Service` resource. \" +\n+            \"You can use this field to configure DNS providers such as External DNS. \" +\n+            \"This field can be used only with `loadbalancer`, `nodeport`, or `ingress` type listeners.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, String> getDnsAnnotations() {\n+        return dnsAnnotations;\n+    }\n+\n+    public void setDnsAnnotations(Map<String, String> dnsAnnotations) {\n+        this.dnsAnnotations = dnsAnnotations;\n+    }\n+\n+    @Description(\"Node port for the per-broker service. \" +\n+            \"This field can be used only with `nodeport` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public Integer getNodePort() {\n+        return nodePort;\n+    }\n+\n+    public void setNodePort(Integer nodePort) {\n+        this.nodePort = nodePort;\n+    }\n+\n+    @Description(\"The loadbalancer is requested with the IP address specified in this field. \" +\n+            \"This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. \" +\n+            \"This field is ignored if the cloud provider does not support the feature.\" +\n+            \"This field can be used only with `loadbalancer` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public String getLoadBalancerIP() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3NjgxOQ==", "bodyText": "Kubernetes it self is not doing any validation. So I wonder if some applications might be using it for something what does not match the IP format etc. It gets also a bit more complicated with IPv6 support. So I would probably preffer to keep it as String and leave it for the user.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483576819", "createdAt": "2020-09-04T12:12:38Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/GenericKafkaListenerConfigurationBroker.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.util.Collections.emptyMap;\n+\n+/**\n+ * Configures listener per-broker configuration\n+ */\n+@JsonPropertyOrder({\"broker\", \"advertisedHost\", \"advertisedPort\", \"host\", \"dnsAnnotations\", \"nodePort\", \"loadBalancerIP\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Buildable(\n+    editableEnabled = false,\n+    builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@EqualsAndHashCode\n+public class GenericKafkaListenerConfigurationBroker implements Serializable, UnknownPropertyPreserving {\n+    private static final long serialVersionUID = 1L;\n+\n+    private Integer broker;\n+    private String advertisedHost;\n+    private Integer advertisedPort;\n+    private String host;\n+    private Map<String, String> dnsAnnotations = new HashMap<>(0);\n+    private Integer nodePort;\n+    private String loadBalancerIP;\n+\n+    private Map<String, Object> additionalProperties = new HashMap<>(0);\n+\n+    @Description(\"ID of the kafka broker (broker identifier). \" +\n+            \"Broker IDs start from 0 and correspond to the number of broker replicas.\")\n+    @JsonProperty(required = true)\n+    public Integer getBroker() {\n+        return broker;\n+    }\n+\n+    public void setBroker(Integer broker) {\n+        this.broker = broker;\n+    }\n+\n+    @Description(\"The host name which will be used in the brokers' `advertised.brokers`\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public String getAdvertisedHost() {\n+        return advertisedHost;\n+    }\n+\n+    public void setAdvertisedHost(String advertisedHost) {\n+        this.advertisedHost = advertisedHost;\n+    }\n+\n+    @Description(\"The port number which will be used in the brokers' `advertised.brokers`\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public Integer getAdvertisedPort() {\n+        return advertisedPort;\n+    }\n+\n+    public void setAdvertisedPort(Integer advertisedPort) {\n+        this.advertisedPort = advertisedPort;\n+    }\n+\n+\n+    @Description(\"The broker host. \" +\n+            \"This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. \" +\n+            \"This field can be used only with `route` (optional) or `ingress` (required) type listeners.\")\n+    @JsonProperty(required = true)\n+    public String getHost() {\n+        return host;\n+    }\n+\n+    public void setHost(String host) {\n+        this.host = host;\n+    }\n+\n+    @Description(\"Annotations that will be added to the `Ingress` or `Service` resource. \" +\n+            \"You can use this field to configure DNS providers such as External DNS. \" +\n+            \"This field can be used only with `loadbalancer`, `nodeport`, or `ingress` type listeners.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public Map<String, String> getDnsAnnotations() {\n+        return dnsAnnotations;\n+    }\n+\n+    public void setDnsAnnotations(Map<String, String> dnsAnnotations) {\n+        this.dnsAnnotations = dnsAnnotations;\n+    }\n+\n+    @Description(\"Node port for the per-broker service. \" +\n+            \"This field can be used only with `nodeport` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public Integer getNodePort() {\n+        return nodePort;\n+    }\n+\n+    public void setNodePort(Integer nodePort) {\n+        this.nodePort = nodePort;\n+    }\n+\n+    @Description(\"The loadbalancer is requested with the IP address specified in this field. \" +\n+            \"This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. \" +\n+            \"This field is ignored if the cloud provider does not support the feature.\" +\n+            \"This field can be used only with `loadbalancer` type listener.\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)\n+    public String getLoadBalancerIP() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ4NDg4NQ=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzA3ODkzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaBrokerConfigurationBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo1OTo0NFrOHNFqxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo1OTo0NFrOHNFqxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ4NjQwNw==", "bodyText": "Remove this, if it's not needed?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483486407", "createdAt": "2020-09-04T08:59:44Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaBrokerConfigurationBuilder.java", "diffHunk": "@@ -301,15 +226,15 @@ private void configureReplicationListener() {\n      *\n      * @return  String with advertised listener configuration\n      */\n-    private String getAdvertisedListener(String clusterName, String namespace, String listenerName, int port)    {\n+    /*private String getAdvertisedListener(String clusterName, String namespace, String listenerName, int port)    {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzA4MTc5OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTowMDozNlrOHNFskw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTowMDozNlrOHNFskw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ4Njg2Nw==", "bodyText": "Import this type?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483486867", "createdAt": "2020-09-04T09:00:36Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -244,7 +225,7 @@\n \n     // Configuration defaults\n     private static final int DEFAULT_REPLICAS = 3;\n-    public static final Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder().withTimeoutSeconds(5)\n+    public static final io.strimzi.api.kafka.model.Probe DEFAULT_HEALTHCHECK_OPTIONS = new ProbeBuilder().withTimeoutSeconds(5)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzEwMTIwOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTowNjoxOFrOHNF4mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTowNjoxOFrOHNF4mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ4OTk0Ng==", "bodyText": "Better have helper methods on ListenerUtils which return whether there are any listeners of a given sort without having to allocate a List (that way you don't have to allocate a List only to test its emptiness).", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483489946", "createdAt": "2020-09-04T09:06:18Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java", "diffHunk": "@@ -2099,7 +1770,7 @@ public boolean isExposedWithRoute() {\n      * @return true when the Kafka cluster is exposed using load balancer.\n      */\n     public boolean isExposedWithLoadBalancer() {\n-        return isExposed() && listeners.getExternal() instanceof KafkaListenerExternalLoadBalancer;\n+        return !ListenersUtils.loadBalancerListeners(listeners).isEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 1308}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzEwODYzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTowODoyN1rOHNF89w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTowODoyN1rOHNF89w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5MTA2Mw==", "bodyText": "filter(...).findFirst().isPresent()", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483491063", "createdAt": "2020-09-04T09:08:27Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersUtils.java", "diffHunk": "@@ -0,0 +1,489 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationOAuth;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListener;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfigurationBroker;\n+import io.strimzi.api.kafka.model.listener.v2.KafkaListenerType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Util methods for working with Kafka listeners\n+ */\n+public class ListenersUtils {\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_PLAIN_PORT_NAME = \"tcp-clients\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_TLS_PORT_NAME = \"tcp-clientstls\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_EXTERNAL_PORT_NAME = \"tcp-external\";\n+\n+    /**\n+     * Finds out if any of the listeners has OAuth authentication enabled\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of used names\n+     */\n+    public static boolean hasListenerWithOAuth(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> listener.getAuth() != null && KafkaListenerAuthenticationOAuth.TYPE_OAUTH.equals(listener.getAuth().getType()))\n+                .map(listener -> true)\n+                .findFirst()\n+                .orElse(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzExNDE5OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOToxMDowMFrOHNGAbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQxMjo1NzozNlrOHNh5Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5MTk1MQ==", "bodyText": "Factor out a private method which takes the desired KafkaListenerType as a param then each of these methods becomes a trivial return privateMethod(KafkaListenerType.XXX);", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483491951", "createdAt": "2020-09-04T09:10:00Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersUtils.java", "diffHunk": "@@ -0,0 +1,489 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationOAuth;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListener;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfigurationBroker;\n+import io.strimzi.api.kafka.model.listener.v2.KafkaListenerType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Util methods for working with Kafka listeners\n+ */\n+public class ListenersUtils {\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_PLAIN_PORT_NAME = \"tcp-clients\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_TLS_PORT_NAME = \"tcp-clientstls\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_EXTERNAL_PORT_NAME = \"tcp-external\";\n+\n+    /**\n+     * Finds out if any of the listeners has OAuth authentication enabled\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of used names\n+     */\n+    public static boolean hasListenerWithOAuth(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> listener.getAuth() != null && KafkaListenerAuthenticationOAuth.TYPE_OAUTH.equals(listener.getAuth().getType()))\n+                .map(listener -> true)\n+                .findFirst()\n+                .orElse(false);\n+    }\n+\n+    /**\n+     * Returns list of all internal listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of internal listeners\n+     */\n+    public static List<GenericKafkaListener> internalListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INTERNAL == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all external listeners (i.e. not internal)\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of external listeners\n+     */\n+    public static List<GenericKafkaListener> externalListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INTERNAL != listener.getType())\n+                .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk0ODg1OQ==", "bodyText": "There is already listenersByType but it is not applicable here because we need any other listener which is NOT internal. Maybe the method could be factored out having a predicate on type as parameter and not a specific type itself.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483948859", "createdAt": "2020-09-05T12:57:36Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersUtils.java", "diffHunk": "@@ -0,0 +1,489 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationOAuth;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListener;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfigurationBroker;\n+import io.strimzi.api.kafka.model.listener.v2.KafkaListenerType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Util methods for working with Kafka listeners\n+ */\n+public class ListenersUtils {\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_PLAIN_PORT_NAME = \"tcp-clients\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_TLS_PORT_NAME = \"tcp-clientstls\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_EXTERNAL_PORT_NAME = \"tcp-external\";\n+\n+    /**\n+     * Finds out if any of the listeners has OAuth authentication enabled\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of used names\n+     */\n+    public static boolean hasListenerWithOAuth(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> listener.getAuth() != null && KafkaListenerAuthenticationOAuth.TYPE_OAUTH.equals(listener.getAuth().getType()))\n+                .map(listener -> true)\n+                .findFirst()\n+                .orElse(false);\n+    }\n+\n+    /**\n+     * Returns list of all internal listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of internal listeners\n+     */\n+    public static List<GenericKafkaListener> internalListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INTERNAL == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all external listeners (i.e. not internal)\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of external listeners\n+     */\n+    public static List<GenericKafkaListener> externalListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INTERNAL != listener.getType())\n+                .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5MTk1MQ=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzExODcyOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOToxMToxMFrOHNGDAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOToxMToxMFrOHNGDAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5MjYwOA==", "bodyText": "This is just a single flatMap(listener -> listener.getConfiguration().getBootstrap().getAlternativeNames().stream() I think.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483492608", "createdAt": "2020-09-04T09:11:10Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersUtils.java", "diffHunk": "@@ -0,0 +1,489 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationOAuth;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListener;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfigurationBroker;\n+import io.strimzi.api.kafka.model.listener.v2.KafkaListenerType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Util methods for working with Kafka listeners\n+ */\n+public class ListenersUtils {\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_PLAIN_PORT_NAME = \"tcp-clients\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_TLS_PORT_NAME = \"tcp-clientstls\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_EXTERNAL_PORT_NAME = \"tcp-external\";\n+\n+    /**\n+     * Finds out if any of the listeners has OAuth authentication enabled\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of used names\n+     */\n+    public static boolean hasListenerWithOAuth(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> listener.getAuth() != null && KafkaListenerAuthenticationOAuth.TYPE_OAUTH.equals(listener.getAuth().getType()))\n+                .map(listener -> true)\n+                .findFirst()\n+                .orElse(false);\n+    }\n+\n+    /**\n+     * Returns list of all internal listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of internal listeners\n+     */\n+    public static List<GenericKafkaListener> internalListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INTERNAL == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all external listeners (i.e. not internal)\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of external listeners\n+     */\n+    public static List<GenericKafkaListener> externalListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INTERNAL != listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all Route type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of route listeners\n+     */\n+    public static List<GenericKafkaListener> routeListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.ROUTE == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all LoadBalancer type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of load balancer listeners\n+     */\n+    public static List<GenericKafkaListener> loadBalancerListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.LOADBALANCER == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all NodePort type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of node port listeners\n+     */\n+    public static List<GenericKafkaListener> nodePortListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.NODEPORT == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all Ingress type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of ingress listeners\n+     */\n+    public static List<GenericKafkaListener> ingressListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INGRESS == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all additional DNS addresses for certificates\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of external listeners\n+     */\n+    public static List<String> alternativeNames(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> listener.getConfiguration() != null\n+                        && listener.getConfiguration().getBootstrap() != null\n+                        && listener.getConfiguration().getBootstrap().getAlternativeNames() != null)\n+                .map(listener -> listener.getConfiguration().getBootstrap().getAlternativeNames())\n+                .flatMap(List::stream)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzEyMjM1OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOToxMjowOVrOHNGFUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMToyNDoyNFrOHNJ6Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5MzIwMA==", "bodyText": "I wonder if this is the best name. Is it used as a suffix or prefix?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483493200", "createdAt": "2020-09-04T09:12:09Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersUtils.java", "diffHunk": "@@ -0,0 +1,489 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationOAuth;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListener;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfigurationBroker;\n+import io.strimzi.api.kafka.model.listener.v2.KafkaListenerType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Util methods for working with Kafka listeners\n+ */\n+public class ListenersUtils {\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_PLAIN_PORT_NAME = \"tcp-clients\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_TLS_PORT_NAME = \"tcp-clientstls\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_EXTERNAL_PORT_NAME = \"tcp-external\";\n+\n+    /**\n+     * Finds out if any of the listeners has OAuth authentication enabled\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of used names\n+     */\n+    public static boolean hasListenerWithOAuth(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> listener.getAuth() != null && KafkaListenerAuthenticationOAuth.TYPE_OAUTH.equals(listener.getAuth().getType()))\n+                .map(listener -> true)\n+                .findFirst()\n+                .orElse(false);\n+    }\n+\n+    /**\n+     * Returns list of all internal listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of internal listeners\n+     */\n+    public static List<GenericKafkaListener> internalListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INTERNAL == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all external listeners (i.e. not internal)\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of external listeners\n+     */\n+    public static List<GenericKafkaListener> externalListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INTERNAL != listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all Route type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of route listeners\n+     */\n+    public static List<GenericKafkaListener> routeListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.ROUTE == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all LoadBalancer type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of load balancer listeners\n+     */\n+    public static List<GenericKafkaListener> loadBalancerListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.LOADBALANCER == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all NodePort type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of node port listeners\n+     */\n+    public static List<GenericKafkaListener> nodePortListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.NODEPORT == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all Ingress type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of ingress listeners\n+     */\n+    public static List<GenericKafkaListener> ingressListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INGRESS == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all additional DNS addresses for certificates\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of external listeners\n+     */\n+    public static List<String> alternativeNames(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> listener.getConfiguration() != null\n+                        && listener.getConfiguration().getBootstrap() != null\n+                        && listener.getConfiguration().getBootstrap().getAlternativeNames() != null)\n+                .map(listener -> listener.getConfiguration().getBootstrap().getAlternativeNames())\n+                .flatMap(List::stream)\n+                .distinct()\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Generates a listener identifier which is used to name the related volumes, volume mounts, etc.\n+     *\n+     * @param listener  Listener for which the name should be generated\n+     * @return          Identifier string\n+     */\n+    public static String identifier(GenericKafkaListener listener) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU1MTQ1Mw==", "bodyText": "It is used for everything -> for naming volumes and volume mounts where this is in the middle of the name, to naming Kafka listeners where this is the only name without anything else.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483551453", "createdAt": "2020-09-04T11:13:53Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersUtils.java", "diffHunk": "@@ -0,0 +1,489 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationOAuth;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListener;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfigurationBroker;\n+import io.strimzi.api.kafka.model.listener.v2.KafkaListenerType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Util methods for working with Kafka listeners\n+ */\n+public class ListenersUtils {\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_PLAIN_PORT_NAME = \"tcp-clients\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_TLS_PORT_NAME = \"tcp-clientstls\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_EXTERNAL_PORT_NAME = \"tcp-external\";\n+\n+    /**\n+     * Finds out if any of the listeners has OAuth authentication enabled\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of used names\n+     */\n+    public static boolean hasListenerWithOAuth(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> listener.getAuth() != null && KafkaListenerAuthenticationOAuth.TYPE_OAUTH.equals(listener.getAuth().getType()))\n+                .map(listener -> true)\n+                .findFirst()\n+                .orElse(false);\n+    }\n+\n+    /**\n+     * Returns list of all internal listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of internal listeners\n+     */\n+    public static List<GenericKafkaListener> internalListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INTERNAL == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all external listeners (i.e. not internal)\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of external listeners\n+     */\n+    public static List<GenericKafkaListener> externalListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INTERNAL != listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all Route type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of route listeners\n+     */\n+    public static List<GenericKafkaListener> routeListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.ROUTE == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all LoadBalancer type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of load balancer listeners\n+     */\n+    public static List<GenericKafkaListener> loadBalancerListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.LOADBALANCER == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all NodePort type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of node port listeners\n+     */\n+    public static List<GenericKafkaListener> nodePortListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.NODEPORT == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all Ingress type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of ingress listeners\n+     */\n+    public static List<GenericKafkaListener> ingressListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INGRESS == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all additional DNS addresses for certificates\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of external listeners\n+     */\n+    public static List<String> alternativeNames(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> listener.getConfiguration() != null\n+                        && listener.getConfiguration().getBootstrap() != null\n+                        && listener.getConfiguration().getBootstrap().getAlternativeNames() != null)\n+                .map(listener -> listener.getConfiguration().getBootstrap().getAlternativeNames())\n+                .flatMap(List::stream)\n+                .distinct()\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Generates a listener identifier which is used to name the related volumes, volume mounts, etc.\n+     *\n+     * @param listener  Listener for which the name should be generated\n+     * @return          Identifier string\n+     */\n+    public static String identifier(GenericKafkaListener listener) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5MzIwMA=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU1NTkxOA==", "bodyText": "Fair enough.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483555918", "createdAt": "2020-09-04T11:24:24Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersUtils.java", "diffHunk": "@@ -0,0 +1,489 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationOAuth;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListener;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfigurationBroker;\n+import io.strimzi.api.kafka.model.listener.v2.KafkaListenerType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Util methods for working with Kafka listeners\n+ */\n+public class ListenersUtils {\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_PLAIN_PORT_NAME = \"tcp-clients\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_TLS_PORT_NAME = \"tcp-clientstls\";\n+    /*test*/ static final String BACKWARDS_COMPATIBLE_EXTERNAL_PORT_NAME = \"tcp-external\";\n+\n+    /**\n+     * Finds out if any of the listeners has OAuth authentication enabled\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of used names\n+     */\n+    public static boolean hasListenerWithOAuth(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> listener.getAuth() != null && KafkaListenerAuthenticationOAuth.TYPE_OAUTH.equals(listener.getAuth().getType()))\n+                .map(listener -> true)\n+                .findFirst()\n+                .orElse(false);\n+    }\n+\n+    /**\n+     * Returns list of all internal listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of internal listeners\n+     */\n+    public static List<GenericKafkaListener> internalListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INTERNAL == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all external listeners (i.e. not internal)\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of external listeners\n+     */\n+    public static List<GenericKafkaListener> externalListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INTERNAL != listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all Route type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of route listeners\n+     */\n+    public static List<GenericKafkaListener> routeListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.ROUTE == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all LoadBalancer type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of load balancer listeners\n+     */\n+    public static List<GenericKafkaListener> loadBalancerListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.LOADBALANCER == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all NodePort type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of node port listeners\n+     */\n+    public static List<GenericKafkaListener> nodePortListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.NODEPORT == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all Ingress type listeners\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of ingress listeners\n+     */\n+    public static List<GenericKafkaListener> ingressListeners(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> KafkaListenerType.INGRESS == listener.getType())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Returns list of all additional DNS addresses for certificates\n+     *\n+     * @param listeners List of all listeners\n+     * @return          List of external listeners\n+     */\n+    public static List<String> alternativeNames(List<GenericKafkaListener> listeners)    {\n+        return listeners.stream()\n+                .filter(listener -> listener.getConfiguration() != null\n+                        && listener.getConfiguration().getBootstrap() != null\n+                        && listener.getConfiguration().getBootstrap().getAlternativeNames() != null)\n+                .map(listener -> listener.getConfiguration().getBootstrap().getAlternativeNames())\n+                .flatMap(List::stream)\n+                .distinct()\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Generates a listener identifier which is used to name the related volumes, volume mounts, etc.\n+     *\n+     * @param listener  Listener for which the name should be generated\n+     * @return          Identifier string\n+     */\n+    public static String identifier(GenericKafkaListener listener) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5MzIwMA=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzEyODgwOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersValidator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOToxNDowM1rOHNGJbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOToxNDowM1rOHNGJbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5NDI1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        errors.add(\"every listener needs to have unique name\");\n          \n          \n            \n                        errors.add(\"every listener needs to have a unique name\");", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483494255", "createdAt": "2020-09-04T09:14:03Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersValidator.java", "diffHunk": "@@ -0,0 +1,445 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationOAuth;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListener;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfiguration;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfigurationBroker;\n+import io.strimzi.api.kafka.model.listener.v2.KafkaListenerType;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * Util methods for validating Kafka listeners\n+ */\n+public class ListenersValidator {\n+    protected static final Logger LOG = LogManager.getLogger(ListenersValidator.class.getName());\n+    private final static Pattern LISTENER_NAME_PATTERN = Pattern.compile(GenericKafkaListener.LISTENER_NAME_REGEX);\n+    public final static List<Integer> FORBIDDEN_PORTS = unmodifiableList(Arrays.asList(9090, 9091, 9404, 9999));\n+\n+    /**\n+     * Validated the listener configuration. If the configuration is not valid, InvalidResourceException will be thrown.\n+     *\n+     * @param replicas   Number of replicas (required for Ingress validation)\n+     * @param listeners  Listeners which should be validated\n+     */\n+    public static void validate(int replicas, List<GenericKafkaListener> listeners) throws InvalidResourceException {\n+        Set<String> errors = validateAndGetErrorMessages(replicas, listeners);\n+\n+        if (!errors.isEmpty())  {\n+            LOG.error(\"Listener configuration is not valid: {}\", errors);\n+            throw new InvalidResourceException(\"Listener configuration is not valid: \" + errors);\n+        }\n+    }\n+\n+    /*test*/ static Set<String> validateAndGetErrorMessages(int replicas, List<GenericKafkaListener> listeners)    {\n+        Set<String> errors = new HashSet<>(0);\n+        List<Integer> ports = getPorts(listeners);\n+        List<String> names = getNames(listeners);\n+\n+        if (names.size() != listeners.size())   {\n+            errors.add(\"every listener needs to have unique name\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzEyOTczOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersValidator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOToxNDoxN1rOHNGJ9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOToxNDoxN1rOHNGJ9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5NDM4OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        errors.add(\"every listener needs to have unique port number\");\n          \n          \n            \n                        errors.add(\"every listener needs to have a unique port number\");", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483494389", "createdAt": "2020-09-04T09:14:17Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersValidator.java", "diffHunk": "@@ -0,0 +1,445 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationOAuth;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListener;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfiguration;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfigurationBroker;\n+import io.strimzi.api.kafka.model.listener.v2.KafkaListenerType;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * Util methods for validating Kafka listeners\n+ */\n+public class ListenersValidator {\n+    protected static final Logger LOG = LogManager.getLogger(ListenersValidator.class.getName());\n+    private final static Pattern LISTENER_NAME_PATTERN = Pattern.compile(GenericKafkaListener.LISTENER_NAME_REGEX);\n+    public final static List<Integer> FORBIDDEN_PORTS = unmodifiableList(Arrays.asList(9090, 9091, 9404, 9999));\n+\n+    /**\n+     * Validated the listener configuration. If the configuration is not valid, InvalidResourceException will be thrown.\n+     *\n+     * @param replicas   Number of replicas (required for Ingress validation)\n+     * @param listeners  Listeners which should be validated\n+     */\n+    public static void validate(int replicas, List<GenericKafkaListener> listeners) throws InvalidResourceException {\n+        Set<String> errors = validateAndGetErrorMessages(replicas, listeners);\n+\n+        if (!errors.isEmpty())  {\n+            LOG.error(\"Listener configuration is not valid: {}\", errors);\n+            throw new InvalidResourceException(\"Listener configuration is not valid: \" + errors);\n+        }\n+    }\n+\n+    /*test*/ static Set<String> validateAndGetErrorMessages(int replicas, List<GenericKafkaListener> listeners)    {\n+        Set<String> errors = new HashSet<>(0);\n+        List<Integer> ports = getPorts(listeners);\n+        List<String> names = getNames(listeners);\n+\n+        if (names.size() != listeners.size())   {\n+            errors.add(\"every listener needs to have unique name\");\n+        }\n+\n+        List<String> invalidNames = names.stream().filter(name -> !LISTENER_NAME_PATTERN.matcher(name).matches()).collect(Collectors.toList());\n+        if (!invalidNames.isEmpty())    {\n+            errors.add(\"listener names \" + invalidNames + \" are invalid and do not match the pattern \" + GenericKafkaListener.LISTENER_NAME_REGEX);\n+        }\n+\n+        if (ports.size() != listeners.size())   {\n+            errors.add(\"every listener needs to have unique port number\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzEzMjc2OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersValidator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOToxNTowMVrOHNGLqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOToxNTowMVrOHNGLqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5NDgyNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            errors.add(\"listener \" + listener.getName() + \" is missing bootstrap host name which is required for Ingress based listeners\");\n          \n          \n            \n                            errors.add(\"listener \" + listener.getName() + \" is missing a bootstrap host name which is required for Ingress based listeners\");", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483494827", "createdAt": "2020-09-04T09:15:01Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersValidator.java", "diffHunk": "@@ -0,0 +1,445 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationOAuth;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListener;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfiguration;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfigurationBroker;\n+import io.strimzi.api.kafka.model.listener.v2.KafkaListenerType;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * Util methods for validating Kafka listeners\n+ */\n+public class ListenersValidator {\n+    protected static final Logger LOG = LogManager.getLogger(ListenersValidator.class.getName());\n+    private final static Pattern LISTENER_NAME_PATTERN = Pattern.compile(GenericKafkaListener.LISTENER_NAME_REGEX);\n+    public final static List<Integer> FORBIDDEN_PORTS = unmodifiableList(Arrays.asList(9090, 9091, 9404, 9999));\n+\n+    /**\n+     * Validated the listener configuration. If the configuration is not valid, InvalidResourceException will be thrown.\n+     *\n+     * @param replicas   Number of replicas (required for Ingress validation)\n+     * @param listeners  Listeners which should be validated\n+     */\n+    public static void validate(int replicas, List<GenericKafkaListener> listeners) throws InvalidResourceException {\n+        Set<String> errors = validateAndGetErrorMessages(replicas, listeners);\n+\n+        if (!errors.isEmpty())  {\n+            LOG.error(\"Listener configuration is not valid: {}\", errors);\n+            throw new InvalidResourceException(\"Listener configuration is not valid: \" + errors);\n+        }\n+    }\n+\n+    /*test*/ static Set<String> validateAndGetErrorMessages(int replicas, List<GenericKafkaListener> listeners)    {\n+        Set<String> errors = new HashSet<>(0);\n+        List<Integer> ports = getPorts(listeners);\n+        List<String> names = getNames(listeners);\n+\n+        if (names.size() != listeners.size())   {\n+            errors.add(\"every listener needs to have unique name\");\n+        }\n+\n+        List<String> invalidNames = names.stream().filter(name -> !LISTENER_NAME_PATTERN.matcher(name).matches()).collect(Collectors.toList());\n+        if (!invalidNames.isEmpty())    {\n+            errors.add(\"listener names \" + invalidNames + \" are invalid and do not match the pattern \" + GenericKafkaListener.LISTENER_NAME_REGEX);\n+        }\n+\n+        if (ports.size() != listeners.size())   {\n+            errors.add(\"every listener needs to have unique port number\");\n+        }\n+\n+        if (!Collections.disjoint(ports, FORBIDDEN_PORTS))    {\n+            errors.add(\"ports \" + FORBIDDEN_PORTS + \" are forbidden and cannot be used\");\n+        }\n+\n+        for (GenericKafkaListener listener : listeners) {\n+            validateRouteAndIngressTlsOnly(errors, listener);\n+            validateTlsFeaturesOnNonTlsListener(errors, listener);\n+            validateOauth(errors, listener);\n+\n+            if (listener.getConfiguration() != null)    {\n+                validateServiceDnsDomain(errors, listener);\n+                validateIngressClass(errors, listener);\n+                validateExternalTrafficPolicy(errors, listener);\n+                validateLoadBalancerSourceRanges(errors, listener);\n+                validatePreferredAddressType(errors, listener);\n+\n+                if (listener.getConfiguration().getBootstrap() != null) {\n+                    validateBootstrapHost(errors, listener);\n+                    validateBootstrapLoadBalancerIp(errors, listener);\n+                    validateBootstrapNodePort(errors, listener);\n+                    validateBootstrapDnsAnnotations(errors, listener);\n+                }\n+\n+                if (listener.getConfiguration().getBrokers() != null) {\n+                    for (GenericKafkaListenerConfigurationBroker broker : listener.getConfiguration().getBrokers()) {\n+                        validateBrokerHost(errors, listener, broker);\n+                        validateBrokerLoadBalancerIp(errors, listener, broker);\n+                        validateBrokerNodePort(errors, listener, broker);\n+                        validateBrokerDnsAnnotations(errors, listener, broker);\n+                    }\n+                }\n+            }\n+\n+            if (KafkaListenerType.INGRESS.equals(listener.getType()))    {\n+                validateIngress(errors, replicas, listener);\n+            }\n+        }\n+\n+        return errors;\n+    }\n+\n+    /**\n+     * Validates that Ingress type listener has the right host configurations\n+     *\n+     * @param errors    List where any found errors will be added\n+     * @param replicas  Number of Kafka replicas\n+     * @param listener  Listener which needs to be validated\n+     */\n+    private static void validateIngress(Set<String> errors, int replicas, GenericKafkaListener listener) {\n+        if (listener.getConfiguration() != null)    {\n+            GenericKafkaListenerConfiguration conf = listener.getConfiguration();\n+\n+            if (conf.getBootstrap() == null\n+                    || conf.getBootstrap().getHost() == null)   {\n+                errors.add(\"listener \" + listener.getName() + \" is missing bootstrap host name which is required for Ingress based listeners\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzEzMzM2OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersValidator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOToxNToxM1rOHNGMCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOToxNToxM1rOHNGMCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5NDkyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    errors.add(\"listener \" + listener.getName() + \" is missing broker host name for broker with ID \" + i + \" which is required for Ingress based listeners\");\n          \n          \n            \n                                    errors.add(\"listener \" + listener.getName() + \" is missing a broker host name for broker with ID \" + i + \" which is required for Ingress based listeners\");", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483494923", "createdAt": "2020-09-04T09:15:13Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/ListenersValidator.java", "diffHunk": "@@ -0,0 +1,445 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.cluster.model;\n+\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationOAuth;\n+import io.strimzi.api.kafka.model.listener.KafkaListenerAuthenticationTls;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListener;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfiguration;\n+import io.strimzi.api.kafka.model.listener.v2.GenericKafkaListenerConfigurationBroker;\n+import io.strimzi.api.kafka.model.listener.v2.KafkaListenerType;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * Util methods for validating Kafka listeners\n+ */\n+public class ListenersValidator {\n+    protected static final Logger LOG = LogManager.getLogger(ListenersValidator.class.getName());\n+    private final static Pattern LISTENER_NAME_PATTERN = Pattern.compile(GenericKafkaListener.LISTENER_NAME_REGEX);\n+    public final static List<Integer> FORBIDDEN_PORTS = unmodifiableList(Arrays.asList(9090, 9091, 9404, 9999));\n+\n+    /**\n+     * Validated the listener configuration. If the configuration is not valid, InvalidResourceException will be thrown.\n+     *\n+     * @param replicas   Number of replicas (required for Ingress validation)\n+     * @param listeners  Listeners which should be validated\n+     */\n+    public static void validate(int replicas, List<GenericKafkaListener> listeners) throws InvalidResourceException {\n+        Set<String> errors = validateAndGetErrorMessages(replicas, listeners);\n+\n+        if (!errors.isEmpty())  {\n+            LOG.error(\"Listener configuration is not valid: {}\", errors);\n+            throw new InvalidResourceException(\"Listener configuration is not valid: \" + errors);\n+        }\n+    }\n+\n+    /*test*/ static Set<String> validateAndGetErrorMessages(int replicas, List<GenericKafkaListener> listeners)    {\n+        Set<String> errors = new HashSet<>(0);\n+        List<Integer> ports = getPorts(listeners);\n+        List<String> names = getNames(listeners);\n+\n+        if (names.size() != listeners.size())   {\n+            errors.add(\"every listener needs to have unique name\");\n+        }\n+\n+        List<String> invalidNames = names.stream().filter(name -> !LISTENER_NAME_PATTERN.matcher(name).matches()).collect(Collectors.toList());\n+        if (!invalidNames.isEmpty())    {\n+            errors.add(\"listener names \" + invalidNames + \" are invalid and do not match the pattern \" + GenericKafkaListener.LISTENER_NAME_REGEX);\n+        }\n+\n+        if (ports.size() != listeners.size())   {\n+            errors.add(\"every listener needs to have unique port number\");\n+        }\n+\n+        if (!Collections.disjoint(ports, FORBIDDEN_PORTS))    {\n+            errors.add(\"ports \" + FORBIDDEN_PORTS + \" are forbidden and cannot be used\");\n+        }\n+\n+        for (GenericKafkaListener listener : listeners) {\n+            validateRouteAndIngressTlsOnly(errors, listener);\n+            validateTlsFeaturesOnNonTlsListener(errors, listener);\n+            validateOauth(errors, listener);\n+\n+            if (listener.getConfiguration() != null)    {\n+                validateServiceDnsDomain(errors, listener);\n+                validateIngressClass(errors, listener);\n+                validateExternalTrafficPolicy(errors, listener);\n+                validateLoadBalancerSourceRanges(errors, listener);\n+                validatePreferredAddressType(errors, listener);\n+\n+                if (listener.getConfiguration().getBootstrap() != null) {\n+                    validateBootstrapHost(errors, listener);\n+                    validateBootstrapLoadBalancerIp(errors, listener);\n+                    validateBootstrapNodePort(errors, listener);\n+                    validateBootstrapDnsAnnotations(errors, listener);\n+                }\n+\n+                if (listener.getConfiguration().getBrokers() != null) {\n+                    for (GenericKafkaListenerConfigurationBroker broker : listener.getConfiguration().getBrokers()) {\n+                        validateBrokerHost(errors, listener, broker);\n+                        validateBrokerLoadBalancerIp(errors, listener, broker);\n+                        validateBrokerNodePort(errors, listener, broker);\n+                        validateBrokerDnsAnnotations(errors, listener, broker);\n+                    }\n+                }\n+            }\n+\n+            if (KafkaListenerType.INGRESS.equals(listener.getType()))    {\n+                validateIngress(errors, replicas, listener);\n+            }\n+        }\n+\n+        return errors;\n+    }\n+\n+    /**\n+     * Validates that Ingress type listener has the right host configurations\n+     *\n+     * @param errors    List where any found errors will be added\n+     * @param replicas  Number of Kafka replicas\n+     * @param listener  Listener which needs to be validated\n+     */\n+    private static void validateIngress(Set<String> errors, int replicas, GenericKafkaListener listener) {\n+        if (listener.getConfiguration() != null)    {\n+            GenericKafkaListenerConfiguration conf = listener.getConfiguration();\n+\n+            if (conf.getBootstrap() == null\n+                    || conf.getBootstrap().getHost() == null)   {\n+                errors.add(\"listener \" + listener.getName() + \" is missing bootstrap host name which is required for Ingress based listeners\");\n+            }\n+\n+            if (conf.getBrokers() != null) {\n+                for (int i = 0; i < replicas; i++)  {\n+                    final int id = i;\n+                    GenericKafkaListenerConfigurationBroker broker = conf.getBrokers().stream().filter(b -> b.getBroker() == id).findFirst().orElse(null);\n+\n+                    if (broker == null || broker.getHost() == null) {\n+                        errors.add(\"listener \" + listener.getName() + \" is missing broker host name for broker with ID \" + i + \" which is required for Ingress based listeners\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzE0NzgwOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorCustomCertTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOToxOTozMFrOHNGU8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMDozODo0N1rOHNItsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5NzIwMw==", "bodyText": "What changed here?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483497203", "createdAt": "2020-09-04T09:19:30Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorCustomCertTest.java", "diffHunk": "@@ -196,7 +204,7 @@ public Secret getTlsSecret() {\n     }\n \n     public String getTlsThumbprint()    {\n-        return \"vjPd/D/f0/X3yqitf65yoUZbyeWnQU4cPDJGbr7GA7I=\";\n+        return \"{external=COWn2zWLZMhoewfrmSTfUeKlQPifBKekyXzjm2iGTuc=, tls=vjPd/D/f0/X3yqitf65yoUZbyeWnQU4cPDJGbr7GA7I=}\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzNjMwNw==", "bodyText": "We used to have one thumbprint annotation for TLS listener and one for Externaland that was fine since we had only these two listeners where it was needed. But now we have X possible listeners with their own thumbprints. So we use one annotation for all of them.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r483536307", "createdAt": "2020-09-04T10:38:47Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorCustomCertTest.java", "diffHunk": "@@ -196,7 +204,7 @@ public Secret getTlsSecret() {\n     }\n \n     public String getTlsThumbprint()    {\n-        return \"vjPd/D/f0/X3yqitf65yoUZbyeWnQU4cPDJGbr7GA7I=\";\n+        return \"{external=COWn2zWLZMhoewfrmSTfUeKlQPifBKekyXzjm2iGTuc=, tls=vjPd/D/f0/X3yqitf65yoUZbyeWnQU4cPDJGbr7GA7I=}\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5NzIwMw=="}, "originalCommit": {"oid": "02e633103f40cd92a714e61ae8916108679727d1"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyOTU5OTYyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMjo1MToxNlrOHN-RLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMzoyNjoyMFrOHN_U2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQxMzc0MQ==", "bodyText": "I think the v2 in the package name might become confusing in the future if we ended up with a v1 and v2 API version in the CR and that got reflected in the package naming. Is there any benefit to putting this in a new package?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r484413741", "createdAt": "2020-09-07T12:51:16Z", "author": {"login": "tombentley"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b65396d690a4a1feb55b13c42bafce9328043b23"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQzMTA2Nw==", "bodyText": "I think that better separation from the old class is helpful when working with it. But I'm not fixated on it (or we can for example just rename the v2 to arraylisteners or something). TBH, the package does not manifest into the Kube API. So my plan was that once we remove the old listeners, we would just move it out of o.strimzi.api.kafka.model.listener.v2 to o.strimzi.api.kafka.model.listener.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r484431067", "createdAt": "2020-09-07T13:26:20Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/v2/ArrayOrObjectKafkaListeners.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.v2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQxMzc0MQ=="}, "originalCommit": {"oid": "b65396d690a4a1feb55b13c42bafce9328043b23"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMDQxNjExOnYy", "diffSide": "LEFT", "path": ".azure/regression-pipeline.yaml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxODowNDowNVrOHOFySw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxODowNDowNVrOHOFySw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUzNjkwNw==", "bodyText": "Are you sure this is working? I thought the hard timeout for each job is set to 6 hours by Azure itself.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r484536907", "createdAt": "2020-09-07T18:04:05Z", "author": {"login": "Frawless"}, "path": ".azure/regression-pipeline.yaml", "diffHunk": "@@ -16,7 +16,7 @@ jobs:\n       test_case: 'kafka.*ST,mirrormaker.*ST'\n       groups: 'regression'\n       cluster_operator_install_type: 'bundle'\n-      timeout: 360", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6065556ddc50ab435ac7d581afc7b57292ec37e"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMDYyMzc5OnYy", "diffSide": "RIGHT", "path": "CHANGELOG.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QyMDo1MjozOFrOHOHfPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QyMDo1MjozOFrOHOHfPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU2NDc5Ng==", "bodyText": "just a typo :)\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                type: loadlablancer\n          \n          \n            \n                type: loadbalancer", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r484564796", "createdAt": "2020-09-07T20:52:38Z", "author": {"login": "see-quick"}, "path": "CHANGELOG.md", "diffHunk": "@@ -19,9 +18,77 @@\n   * Fixed bug on maximum reconcile time graph\n   * Removed the avarage reconsile time graph\n   * Rearranged graphs\n+* Make `listeners` configurable as an array and add support for more different listeners in single cluster \n \n ### Deprecations and removals\n \n+#### Redesign of the `.spec.kafka.listeners` section\n+\n+The `.spec.kafka.listeners` section of the Kafka CRD has been redesigned to allow configuring more different listeners.\n+The old `listeners` object which allowed only configuration of one`plain`, one `tls`, and one `external` listener is now deprecated and will be removed in the future.\n+It is replaced with an array allowing configuration of multiple different listeners:\n+\n+```yaml\n+listeners:\n+  - name: local\n+    port: 9092\n+    type: internal\n+    tls: true\n+  - name: external1\n+    port: 9093\n+    type: loadbalancer\n+    tls: true\n+  - name: external2\n+    port: 9094\n+    type: nodeport\n+    tls: true\n+```\n+\n+This change includes some other changes:\n+* The `tls` field is now required.\n+* The former `overrides` section is now merged with the `configuration` section.\n+* The `dnsAnnotations` field has been renamed to `annotations` since we found out it has wider use.\n+* Configuration of `loadBalancerSourceRanges` and `externalTrafficPolicy` has been moved into listener configuration. Its use in the `template` section is now deprecated.\n+* For `type: internal` listeners, you can now use the flag `useServiceDnsDomain` to define whether they should use the fully qualified DNS names including the cluster service suffix (usually `.cluster.local`). This option defaults to false.\n+* All listeners now support configuring the advertised hostname and port.\n+* `preferredAddressType` has been removed to `preferredNodePortAddressType`.\n+\n+To convert the old format into the new format with backwards compatibility, you should use following names and types:\n+* For the old `plain` listener, use the name `plain`, port `9092` and type `internal`.\n+* For the old `tls` listener, use the name `tls`, port `9093` and type `internal`.\n+* For the old `external` listener, use the name `external`, port `9094`.\n+\n+For example the following old configuration:\n+\n+```yaml\n+listeners:\n+  plain:\n+    # ...\n+  tls: \n+    # ...\n+  external:\n+    type: loadbalancer \n+    # ...\n+```\n+\n+Will look like this in the new format:\n+\n+```yaml\n+listeners:\n+  - name: plain\n+    port: 9092\n+    type: internal\n+    tls: false\n+  - name: tls\n+    port: 9093\n+    type: internal\n+    tls: true\n+  - name: external\n+    port: 9094\n+    type: loadlablancer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6065556ddc50ab435ac7d581afc7b57292ec37e"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMDYyNzEyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/arraylistener/GenericKafkaListenerConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QyMDo1NToyMlrOHOHg3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QyMToxMDozNlrOHOHp3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU2NTIxNA==", "bodyText": "Why do you using new ArrayList<>(0); here? I assume it is for memory costs but would it be better to use at least 2 or something like that? Just a question.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r484565214", "createdAt": "2020-09-07T20:55:22Z", "author": {"login": "see-quick"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/arraylistener/GenericKafkaListenerConfiguration.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.arraylistener;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.CertAndKeySecretSource;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Collections.emptyMap;\n+\n+/**\n+ * Configures Kafka listeners\n+ */\n+@JsonPropertyOrder({\"brokerCertChainAndKey\", \"ingressClass\", \"preferredAddressType\", \"externalTrafficPolicy\", \"loadBalancerSourceRanges\", \"bootstrap\", \"brokers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Buildable(\n+    editableEnabled = false,\n+    builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@EqualsAndHashCode\n+public class GenericKafkaListenerConfiguration implements Serializable, UnknownPropertyPreserving {\n+    private static final long serialVersionUID = 1L;\n+\n+    private CertAndKeySecretSource brokerCertChainAndKey;\n+    private String ingressClass;\n+    private NodeAddressType preferredNodePortAddressType;\n+    private ExternalTrafficPolicy externalTrafficPolicy;\n+    private List<String> loadBalancerSourceRanges = new ArrayList<>(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6065556ddc50ab435ac7d581afc7b57292ec37e"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU2NzUxOQ==", "bodyText": "The expectation is that in most cases it will be empty. So this is as intended.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3603#discussion_r484567519", "createdAt": "2020-09-07T21:10:36Z", "author": {"login": "scholzj"}, "path": "api/src/main/java/io/strimzi/api/kafka/model/listener/arraylistener/GenericKafkaListenerConfiguration.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model.listener.arraylistener;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import io.strimzi.api.kafka.model.CertAndKeySecretSource;\n+import io.strimzi.api.kafka.model.Constants;\n+import io.strimzi.api.kafka.model.UnknownPropertyPreserving;\n+import io.strimzi.api.kafka.model.listener.NodeAddressType;\n+import io.strimzi.api.kafka.model.template.ExternalTrafficPolicy;\n+import io.strimzi.crdgenerator.annotations.Description;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Collections.emptyMap;\n+\n+/**\n+ * Configures Kafka listeners\n+ */\n+@JsonPropertyOrder({\"brokerCertChainAndKey\", \"ingressClass\", \"preferredAddressType\", \"externalTrafficPolicy\", \"loadBalancerSourceRanges\", \"bootstrap\", \"brokers\"})\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Buildable(\n+    editableEnabled = false,\n+    builderPackage = Constants.FABRIC8_KUBERNETES_API\n+)\n+@EqualsAndHashCode\n+public class GenericKafkaListenerConfiguration implements Serializable, UnknownPropertyPreserving {\n+    private static final long serialVersionUID = 1L;\n+\n+    private CertAndKeySecretSource brokerCertChainAndKey;\n+    private String ingressClass;\n+    private NodeAddressType preferredNodePortAddressType;\n+    private ExternalTrafficPolicy externalTrafficPolicy;\n+    private List<String> loadBalancerSourceRanges = new ArrayList<>(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU2NTIxNA=="}, "originalCommit": {"oid": "c6065556ddc50ab435ac7d581afc7b57292ec37e"}, "originalPosition": 44}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1086, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}