{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2NTgxMTQ5", "number": 2867, "reviewThreads": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTozNDowOFrOD0-56A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwODoxOTo1M1rOEMyqOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODgzMTc2OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTozNDowOFrOGKM0sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjo0Nzo0MVrOGKZOkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM0OTA0MA==", "bodyText": "This looks a bit weird ... by the name it is supposed to add something, but it just returns what it gets. Is this something what still needs to be added?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r413349040", "createdAt": "2020-04-22T21:34:08Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -368,6 +368,10 @@ public String parseLogging(Logging logging, ConfigMap externalCm) {\n         }\n     }\n \n+    protected String addMonitorIntervalToExternalLogging(String data) {\n+        return data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eef5f038315cc85ca5b732297d1a140c8b668d45"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1MjI3Mw==", "bodyText": "Yeah, it is my poor design. For all models, we do not need to add anything. This method is overridden in EO models to add monitorInterval.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r413552273", "createdAt": "2020-04-23T06:47:41Z", "author": {"login": "sknot-rh"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -368,6 +368,10 @@ public String parseLogging(Logging logging, ConfigMap externalCm) {\n         }\n     }\n \n+    protected String addMonitorIntervalToExternalLogging(String data) {\n+        return data;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM0OTA0MA=="}, "originalCommit": {"oid": "eef5f038315cc85ca5b732297d1a140c8b668d45"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODg0NDgzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityTopicOperator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTozNzozNlrOGKM8SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjo0NjoyMlrOGKZMIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MDk4NA==", "bodyText": "Is this 15 seconds? How do we know that is the right number? Also, since it is used on several places, should we have a constant?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r413350984", "createdAt": "2020-04-22T21:37:36Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityTopicOperator.java", "diffHunk": "@@ -310,8 +310,28 @@ public void setContainerEnvVars(List<ContainerEnvVar> envVars) {\n         templateContainerEnvVars = envVars;\n     }\n \n-\n     public void setContainerSecurityContext(SecurityContext securityContext) {\n         templateContainerSecurityContext = securityContext;\n     }\n+\n+    /**\n+     * Transforms map to log4j properties file format\n+     * @param properties map with properties\n+     * @return\n+     */\n+    @Override\n+    protected String createPropertiesString(OrderedProperties properties) {\n+        properties.addPair(\"monitorInterval\", \"15\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eef5f038315cc85ca5b732297d1a140c8b668d45"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1MTY0OQ==", "bodyText": "It is 15 seconds. I consider it a reasonable value. The log4j2.properties file is rewritten after periodic reconciliation.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r413551649", "createdAt": "2020-04-23T06:46:22Z", "author": {"login": "sknot-rh"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityTopicOperator.java", "diffHunk": "@@ -310,8 +310,28 @@ public void setContainerEnvVars(List<ContainerEnvVar> envVars) {\n         templateContainerEnvVars = envVars;\n     }\n \n-\n     public void setContainerSecurityContext(SecurityContext securityContext) {\n         templateContainerSecurityContext = securityContext;\n     }\n+\n+    /**\n+     * Transforms map to log4j properties file format\n+     * @param properties map with properties\n+     * @return\n+     */\n+    @Override\n+    protected String createPropertiesString(OrderedProperties properties) {\n+        properties.addPair(\"monitorInterval\", \"15\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MDk4NA=="}, "originalCommit": {"oid": "eef5f038315cc85ca5b732297d1a140c8b668d45"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODg0NzA0OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityUserOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTozODoxOFrOGKM9kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTozODoxOFrOGKM9kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MTMxMw==", "bodyText": "These seem to be duplicates with the EnttityTopicOperator. Should we factor them out somewhere?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r413351313", "createdAt": "2020-04-22T21:38:18Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityUserOperator.java", "diffHunk": "@@ -332,4 +332,25 @@ public void setContainerEnvVars(List<ContainerEnvVar> envVars) {\n     public void setContainerSecurityContext(SecurityContext securityContext) {\n         templateContainerSecurityContext = securityContext;\n     }\n+\n+    /**\n+     * Transforms map to log4j properties file format\n+     * @param properties map with properties\n+     * @return\n+     */\n+    @Override\n+    protected String createPropertiesString(OrderedProperties properties) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eef5f038315cc85ca5b732297d1a140c8b668d45"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODg1NDUyOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/LogSettingST.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo0MDozNlrOGKNB_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjo0MjozNFrOGKZExg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MjQ0Nw==", "bodyText": "This is f*cking confusing as hell. Is it testing that pod name did or didn't changed? I guess it is that it didn't?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r413352447", "createdAt": "2020-04-22T21:40:36Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/LogSettingST.java", "diffHunk": "@@ -479,6 +482,138 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @Order(14)\n+    void testDynamicallySetEOloggingLevels() {\n+        String eoName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoName);\n+\n+        // change inline logging\n+        InlineLogging il = new InlineLogging();\n+        il.setLoggers(Collections.singletonMap(\"rootLogger.level\", INFO));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(il);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(il);\n+        });\n+\n+        String eoPodName = eoPods.keySet().iterator().next();\n+        String eoPodHash = eoPods.get(eoPodName);\n+        String finalEoPodName = eoPodName;\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT, () -> {\n+                return cmdKubeClient().execInPodContainer(finalEoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                && cmdKubeClient().execInPodContainer(finalEoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\");\n+            }\n+        );\n+\n+        eoPods = DeploymentUtils.depSnapshot(eoName);\n+        String eoPodNameAfterLoggingChange = eoPods.keySet().iterator().next();\n+        assertThat(\"Pod name changed after logging changed\", eoPodNameAfterLoggingChange.equals(eoPodName), is(true));\n+        assertThat(\"Pod hash changed after logging changed\", eoPods.get(eoPodNameAfterLoggingChange).equals(eoPodHash), is(true));\n+\n+\n+        ConfigMap configMapTo = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-to\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withData(Collections.singletonMap(\"log4j2.properties\", \"name = TOConfig\\n\" +\n+                        \"\\n\" +\n+                        \"appender.console.type = Console\\n\" +\n+                        \"appender.console.name = STDOUT\\n\" +\n+                        \"appender.console.layout.type = PatternLayout\\n\" +\n+                        \"appender.console.layout.pattern = [%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                        \"\\n\" +\n+                        \"rootLogger.level = TRACE\\n\" +\n+                        \"rootLogger.appenderRefs = stdout\\n\" +\n+                        \"rootLogger.appenderRef.console.ref = STDOUT\\n\" +\n+                        \"rootLogger.additivity = false\"))\n+                .build();\n+\n+        ConfigMap configMapUo = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-uo\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .addToData(Collections.singletonMap(\"log4j2.properties\", \"name = UOConfig\\n\" +\n+                        \"\\n\" +\n+                        \"appender.console.type = Console\\n\" +\n+                        \"appender.console.name = STDOUT\\n\" +\n+                        \"appender.console.layout.type = PatternLayout\\n\" +\n+                        \"appender.console.layout.pattern = [%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                        \"\\n\" +\n+                        \"rootLogger.level = TRACE\\n\" +\n+                        \"rootLogger.appenderRefs = stdout\\n\" +\n+                        \"rootLogger.appenderRef.console.ref = STDOUT\\n\" +\n+                        \"rootLogger.additivity = false\"))\n+                .build();\n+\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapTo);\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapUo);\n+\n+        ExternalLogging elTo = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-to\")\n+                .build();\n+\n+        ExternalLogging elUo = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-uo\")\n+                .build();\n+\n+        // change to external logging\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(elTo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(elUo);\n+        });\n+\n+        String finalEoPodName1 = eoPodName;\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT, () -> {\n+                return cmdKubeClient().execInPodContainer(finalEoPodName1, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level = TRACE\")\n+                        && cmdKubeClient().execInPodContainer(finalEoPodName1, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level = TRACE\");\n+            }\n+        );\n+\n+        eoPodName = eoPods.keySet().iterator().next();\n+        eoPodHash = eoPods.get(eoPodName);\n+        eoPods = DeploymentUtils.depSnapshot(eoName);\n+        eoPodNameAfterLoggingChange = eoPods.keySet().iterator().next();\n+        assertThat(\"Pod name changed after logging changed\", eoPodNameAfterLoggingChange.equals(eoPodName), is(true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eef5f038315cc85ca5b732297d1a140c8b668d45"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0OTc2Ng==", "bodyText": "Sorry about that. Yes, it is testing the name is not changed. As EO is deployment, RU=new suffix for the pod name. So if the RU did not happen (it should not when dynamically changing), the name should remain.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r413549766", "createdAt": "2020-04-23T06:42:34Z", "author": {"login": "sknot-rh"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/LogSettingST.java", "diffHunk": "@@ -479,6 +482,138 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @Order(14)\n+    void testDynamicallySetEOloggingLevels() {\n+        String eoName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoName);\n+\n+        // change inline logging\n+        InlineLogging il = new InlineLogging();\n+        il.setLoggers(Collections.singletonMap(\"rootLogger.level\", INFO));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(il);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(il);\n+        });\n+\n+        String eoPodName = eoPods.keySet().iterator().next();\n+        String eoPodHash = eoPods.get(eoPodName);\n+        String finalEoPodName = eoPodName;\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT, () -> {\n+                return cmdKubeClient().execInPodContainer(finalEoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                && cmdKubeClient().execInPodContainer(finalEoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\");\n+            }\n+        );\n+\n+        eoPods = DeploymentUtils.depSnapshot(eoName);\n+        String eoPodNameAfterLoggingChange = eoPods.keySet().iterator().next();\n+        assertThat(\"Pod name changed after logging changed\", eoPodNameAfterLoggingChange.equals(eoPodName), is(true));\n+        assertThat(\"Pod hash changed after logging changed\", eoPods.get(eoPodNameAfterLoggingChange).equals(eoPodHash), is(true));\n+\n+\n+        ConfigMap configMapTo = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-to\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withData(Collections.singletonMap(\"log4j2.properties\", \"name = TOConfig\\n\" +\n+                        \"\\n\" +\n+                        \"appender.console.type = Console\\n\" +\n+                        \"appender.console.name = STDOUT\\n\" +\n+                        \"appender.console.layout.type = PatternLayout\\n\" +\n+                        \"appender.console.layout.pattern = [%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                        \"\\n\" +\n+                        \"rootLogger.level = TRACE\\n\" +\n+                        \"rootLogger.appenderRefs = stdout\\n\" +\n+                        \"rootLogger.appenderRef.console.ref = STDOUT\\n\" +\n+                        \"rootLogger.additivity = false\"))\n+                .build();\n+\n+        ConfigMap configMapUo = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-uo\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .addToData(Collections.singletonMap(\"log4j2.properties\", \"name = UOConfig\\n\" +\n+                        \"\\n\" +\n+                        \"appender.console.type = Console\\n\" +\n+                        \"appender.console.name = STDOUT\\n\" +\n+                        \"appender.console.layout.type = PatternLayout\\n\" +\n+                        \"appender.console.layout.pattern = [%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                        \"\\n\" +\n+                        \"rootLogger.level = TRACE\\n\" +\n+                        \"rootLogger.appenderRefs = stdout\\n\" +\n+                        \"rootLogger.appenderRef.console.ref = STDOUT\\n\" +\n+                        \"rootLogger.additivity = false\"))\n+                .build();\n+\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapTo);\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapUo);\n+\n+        ExternalLogging elTo = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-to\")\n+                .build();\n+\n+        ExternalLogging elUo = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-uo\")\n+                .build();\n+\n+        // change to external logging\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(elTo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(elUo);\n+        });\n+\n+        String finalEoPodName1 = eoPodName;\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT, () -> {\n+                return cmdKubeClient().execInPodContainer(finalEoPodName1, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level = TRACE\")\n+                        && cmdKubeClient().execInPodContainer(finalEoPodName1, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level = TRACE\");\n+            }\n+        );\n+\n+        eoPodName = eoPods.keySet().iterator().next();\n+        eoPodHash = eoPods.get(eoPodName);\n+        eoPods = DeploymentUtils.depSnapshot(eoName);\n+        eoPodNameAfterLoggingChange = eoPods.keySet().iterator().next();\n+        assertThat(\"Pod name changed after logging changed\", eoPodNameAfterLoggingChange.equals(eoPodName), is(true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MjQ0Nw=="}, "originalCommit": {"oid": "eef5f038315cc85ca5b732297d1a140c8b668d45"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODg1OTYzOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/LogSettingST.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo0MTo1NFrOGKNE6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjo1ODo1NFrOGKZtLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MzE5Mw==", "bodyText": "What kind of Hash is this comparing?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r413353193", "createdAt": "2020-04-22T21:41:54Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/LogSettingST.java", "diffHunk": "@@ -479,6 +482,138 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @Order(14)\n+    void testDynamicallySetEOloggingLevels() {\n+        String eoName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoName);\n+\n+        // change inline logging\n+        InlineLogging il = new InlineLogging();\n+        il.setLoggers(Collections.singletonMap(\"rootLogger.level\", INFO));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(il);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(il);\n+        });\n+\n+        String eoPodName = eoPods.keySet().iterator().next();\n+        String eoPodHash = eoPods.get(eoPodName);\n+        String finalEoPodName = eoPodName;\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT, () -> {\n+                return cmdKubeClient().execInPodContainer(finalEoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                && cmdKubeClient().execInPodContainer(finalEoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\");\n+            }\n+        );\n+\n+        eoPods = DeploymentUtils.depSnapshot(eoName);\n+        String eoPodNameAfterLoggingChange = eoPods.keySet().iterator().next();\n+        assertThat(\"Pod name changed after logging changed\", eoPodNameAfterLoggingChange.equals(eoPodName), is(true));\n+        assertThat(\"Pod hash changed after logging changed\", eoPods.get(eoPodNameAfterLoggingChange).equals(eoPodHash), is(true));\n+\n+\n+        ConfigMap configMapTo = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-to\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withData(Collections.singletonMap(\"log4j2.properties\", \"name = TOConfig\\n\" +\n+                        \"\\n\" +\n+                        \"appender.console.type = Console\\n\" +\n+                        \"appender.console.name = STDOUT\\n\" +\n+                        \"appender.console.layout.type = PatternLayout\\n\" +\n+                        \"appender.console.layout.pattern = [%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                        \"\\n\" +\n+                        \"rootLogger.level = TRACE\\n\" +\n+                        \"rootLogger.appenderRefs = stdout\\n\" +\n+                        \"rootLogger.appenderRef.console.ref = STDOUT\\n\" +\n+                        \"rootLogger.additivity = false\"))\n+                .build();\n+\n+        ConfigMap configMapUo = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-uo\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .addToData(Collections.singletonMap(\"log4j2.properties\", \"name = UOConfig\\n\" +\n+                        \"\\n\" +\n+                        \"appender.console.type = Console\\n\" +\n+                        \"appender.console.name = STDOUT\\n\" +\n+                        \"appender.console.layout.type = PatternLayout\\n\" +\n+                        \"appender.console.layout.pattern = [%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                        \"\\n\" +\n+                        \"rootLogger.level = TRACE\\n\" +\n+                        \"rootLogger.appenderRefs = stdout\\n\" +\n+                        \"rootLogger.appenderRef.console.ref = STDOUT\\n\" +\n+                        \"rootLogger.additivity = false\"))\n+                .build();\n+\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapTo);\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapUo);\n+\n+        ExternalLogging elTo = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-to\")\n+                .build();\n+\n+        ExternalLogging elUo = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-uo\")\n+                .build();\n+\n+        // change to external logging\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(elTo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(elUo);\n+        });\n+\n+        String finalEoPodName1 = eoPodName;\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT, () -> {\n+                return cmdKubeClient().execInPodContainer(finalEoPodName1, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level = TRACE\")\n+                        && cmdKubeClient().execInPodContainer(finalEoPodName1, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level = TRACE\");\n+            }\n+        );\n+\n+        eoPodName = eoPods.keySet().iterator().next();\n+        eoPodHash = eoPods.get(eoPodName);\n+        eoPods = DeploymentUtils.depSnapshot(eoName);\n+        eoPodNameAfterLoggingChange = eoPods.keySet().iterator().next();\n+        assertThat(\"Pod name changed after logging changed\", eoPodNameAfterLoggingChange.equals(eoPodName), is(true));\n+        assertThat(\"Pod hash changed after logging changed\", eoPods.get(eoPodNameAfterLoggingChange).equals(eoPodHash), is(true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eef5f038315cc85ca5b732297d1a140c8b668d45"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0OTEzMw==", "bodyText": "Whatever depSnapshot() is returning. @Frawless could you enlight us?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r413549133", "createdAt": "2020-04-23T06:41:18Z", "author": {"login": "sknot-rh"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/LogSettingST.java", "diffHunk": "@@ -479,6 +482,138 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @Order(14)\n+    void testDynamicallySetEOloggingLevels() {\n+        String eoName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoName);\n+\n+        // change inline logging\n+        InlineLogging il = new InlineLogging();\n+        il.setLoggers(Collections.singletonMap(\"rootLogger.level\", INFO));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(il);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(il);\n+        });\n+\n+        String eoPodName = eoPods.keySet().iterator().next();\n+        String eoPodHash = eoPods.get(eoPodName);\n+        String finalEoPodName = eoPodName;\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT, () -> {\n+                return cmdKubeClient().execInPodContainer(finalEoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                && cmdKubeClient().execInPodContainer(finalEoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\");\n+            }\n+        );\n+\n+        eoPods = DeploymentUtils.depSnapshot(eoName);\n+        String eoPodNameAfterLoggingChange = eoPods.keySet().iterator().next();\n+        assertThat(\"Pod name changed after logging changed\", eoPodNameAfterLoggingChange.equals(eoPodName), is(true));\n+        assertThat(\"Pod hash changed after logging changed\", eoPods.get(eoPodNameAfterLoggingChange).equals(eoPodHash), is(true));\n+\n+\n+        ConfigMap configMapTo = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-to\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withData(Collections.singletonMap(\"log4j2.properties\", \"name = TOConfig\\n\" +\n+                        \"\\n\" +\n+                        \"appender.console.type = Console\\n\" +\n+                        \"appender.console.name = STDOUT\\n\" +\n+                        \"appender.console.layout.type = PatternLayout\\n\" +\n+                        \"appender.console.layout.pattern = [%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                        \"\\n\" +\n+                        \"rootLogger.level = TRACE\\n\" +\n+                        \"rootLogger.appenderRefs = stdout\\n\" +\n+                        \"rootLogger.appenderRef.console.ref = STDOUT\\n\" +\n+                        \"rootLogger.additivity = false\"))\n+                .build();\n+\n+        ConfigMap configMapUo = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-uo\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .addToData(Collections.singletonMap(\"log4j2.properties\", \"name = UOConfig\\n\" +\n+                        \"\\n\" +\n+                        \"appender.console.type = Console\\n\" +\n+                        \"appender.console.name = STDOUT\\n\" +\n+                        \"appender.console.layout.type = PatternLayout\\n\" +\n+                        \"appender.console.layout.pattern = [%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                        \"\\n\" +\n+                        \"rootLogger.level = TRACE\\n\" +\n+                        \"rootLogger.appenderRefs = stdout\\n\" +\n+                        \"rootLogger.appenderRef.console.ref = STDOUT\\n\" +\n+                        \"rootLogger.additivity = false\"))\n+                .build();\n+\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapTo);\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapUo);\n+\n+        ExternalLogging elTo = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-to\")\n+                .build();\n+\n+        ExternalLogging elUo = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-uo\")\n+                .build();\n+\n+        // change to external logging\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(elTo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(elUo);\n+        });\n+\n+        String finalEoPodName1 = eoPodName;\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT, () -> {\n+                return cmdKubeClient().execInPodContainer(finalEoPodName1, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level = TRACE\")\n+                        && cmdKubeClient().execInPodContainer(finalEoPodName1, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level = TRACE\");\n+            }\n+        );\n+\n+        eoPodName = eoPods.keySet().iterator().next();\n+        eoPodHash = eoPods.get(eoPodName);\n+        eoPods = DeploymentUtils.depSnapshot(eoName);\n+        eoPodNameAfterLoggingChange = eoPods.keySet().iterator().next();\n+        assertThat(\"Pod name changed after logging changed\", eoPodNameAfterLoggingChange.equals(eoPodName), is(true));\n+        assertThat(\"Pod hash changed after logging changed\", eoPods.get(eoPodNameAfterLoggingChange).equals(eoPodHash), is(true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MzE5Mw=="}, "originalCommit": {"oid": "eef5f038315cc85ca5b732297d1a140c8b668d45"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1Njg5MA==", "bodyText": "I assume you want to wait for rolling update of EO. You should use something like\nDeploymentUtils.waitTillDepHasRolled(KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME), 1, eoPods);", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r413556890", "createdAt": "2020-04-23T06:52:40Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/LogSettingST.java", "diffHunk": "@@ -479,6 +482,138 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @Order(14)\n+    void testDynamicallySetEOloggingLevels() {\n+        String eoName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoName);\n+\n+        // change inline logging\n+        InlineLogging il = new InlineLogging();\n+        il.setLoggers(Collections.singletonMap(\"rootLogger.level\", INFO));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(il);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(il);\n+        });\n+\n+        String eoPodName = eoPods.keySet().iterator().next();\n+        String eoPodHash = eoPods.get(eoPodName);\n+        String finalEoPodName = eoPodName;\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT, () -> {\n+                return cmdKubeClient().execInPodContainer(finalEoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                && cmdKubeClient().execInPodContainer(finalEoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\");\n+            }\n+        );\n+\n+        eoPods = DeploymentUtils.depSnapshot(eoName);\n+        String eoPodNameAfterLoggingChange = eoPods.keySet().iterator().next();\n+        assertThat(\"Pod name changed after logging changed\", eoPodNameAfterLoggingChange.equals(eoPodName), is(true));\n+        assertThat(\"Pod hash changed after logging changed\", eoPods.get(eoPodNameAfterLoggingChange).equals(eoPodHash), is(true));\n+\n+\n+        ConfigMap configMapTo = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-to\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withData(Collections.singletonMap(\"log4j2.properties\", \"name = TOConfig\\n\" +\n+                        \"\\n\" +\n+                        \"appender.console.type = Console\\n\" +\n+                        \"appender.console.name = STDOUT\\n\" +\n+                        \"appender.console.layout.type = PatternLayout\\n\" +\n+                        \"appender.console.layout.pattern = [%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                        \"\\n\" +\n+                        \"rootLogger.level = TRACE\\n\" +\n+                        \"rootLogger.appenderRefs = stdout\\n\" +\n+                        \"rootLogger.appenderRef.console.ref = STDOUT\\n\" +\n+                        \"rootLogger.additivity = false\"))\n+                .build();\n+\n+        ConfigMap configMapUo = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-uo\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .addToData(Collections.singletonMap(\"log4j2.properties\", \"name = UOConfig\\n\" +\n+                        \"\\n\" +\n+                        \"appender.console.type = Console\\n\" +\n+                        \"appender.console.name = STDOUT\\n\" +\n+                        \"appender.console.layout.type = PatternLayout\\n\" +\n+                        \"appender.console.layout.pattern = [%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                        \"\\n\" +\n+                        \"rootLogger.level = TRACE\\n\" +\n+                        \"rootLogger.appenderRefs = stdout\\n\" +\n+                        \"rootLogger.appenderRef.console.ref = STDOUT\\n\" +\n+                        \"rootLogger.additivity = false\"))\n+                .build();\n+\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapTo);\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapUo);\n+\n+        ExternalLogging elTo = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-to\")\n+                .build();\n+\n+        ExternalLogging elUo = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-uo\")\n+                .build();\n+\n+        // change to external logging\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(elTo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(elUo);\n+        });\n+\n+        String finalEoPodName1 = eoPodName;\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT, () -> {\n+                return cmdKubeClient().execInPodContainer(finalEoPodName1, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level = TRACE\")\n+                        && cmdKubeClient().execInPodContainer(finalEoPodName1, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level = TRACE\");\n+            }\n+        );\n+\n+        eoPodName = eoPods.keySet().iterator().next();\n+        eoPodHash = eoPods.get(eoPodName);\n+        eoPods = DeploymentUtils.depSnapshot(eoName);\n+        eoPodNameAfterLoggingChange = eoPods.keySet().iterator().next();\n+        assertThat(\"Pod name changed after logging changed\", eoPodNameAfterLoggingChange.equals(eoPodName), is(true));\n+        assertThat(\"Pod hash changed after logging changed\", eoPods.get(eoPodNameAfterLoggingChange).equals(eoPodHash), is(true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MzE5Mw=="}, "originalCommit": {"oid": "eef5f038315cc85ca5b732297d1a140c8b668d45"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU2MDExMA==", "bodyText": "Oh no, I misunderstand few parts. If you want to check, that EO doesn't roll, you should store DeploymentUtils.depSnapshot(eoName); before you starting with any changes and compare the value with DeploymentUtils.depSnapshot(eoName); when the changes are applied. This method returns map with all pods connected to specific deployment and it's UIDs", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r413560110", "createdAt": "2020-04-23T06:58:54Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/LogSettingST.java", "diffHunk": "@@ -479,6 +482,138 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @Order(14)\n+    void testDynamicallySetEOloggingLevels() {\n+        String eoName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoName);\n+\n+        // change inline logging\n+        InlineLogging il = new InlineLogging();\n+        il.setLoggers(Collections.singletonMap(\"rootLogger.level\", INFO));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(il);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(il);\n+        });\n+\n+        String eoPodName = eoPods.keySet().iterator().next();\n+        String eoPodHash = eoPods.get(eoPodName);\n+        String finalEoPodName = eoPodName;\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT, () -> {\n+                return cmdKubeClient().execInPodContainer(finalEoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                && cmdKubeClient().execInPodContainer(finalEoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\");\n+            }\n+        );\n+\n+        eoPods = DeploymentUtils.depSnapshot(eoName);\n+        String eoPodNameAfterLoggingChange = eoPods.keySet().iterator().next();\n+        assertThat(\"Pod name changed after logging changed\", eoPodNameAfterLoggingChange.equals(eoPodName), is(true));\n+        assertThat(\"Pod hash changed after logging changed\", eoPods.get(eoPodNameAfterLoggingChange).equals(eoPodHash), is(true));\n+\n+\n+        ConfigMap configMapTo = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-to\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withData(Collections.singletonMap(\"log4j2.properties\", \"name = TOConfig\\n\" +\n+                        \"\\n\" +\n+                        \"appender.console.type = Console\\n\" +\n+                        \"appender.console.name = STDOUT\\n\" +\n+                        \"appender.console.layout.type = PatternLayout\\n\" +\n+                        \"appender.console.layout.pattern = [%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                        \"\\n\" +\n+                        \"rootLogger.level = TRACE\\n\" +\n+                        \"rootLogger.appenderRefs = stdout\\n\" +\n+                        \"rootLogger.appenderRef.console.ref = STDOUT\\n\" +\n+                        \"rootLogger.additivity = false\"))\n+                .build();\n+\n+        ConfigMap configMapUo = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-uo\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .addToData(Collections.singletonMap(\"log4j2.properties\", \"name = UOConfig\\n\" +\n+                        \"\\n\" +\n+                        \"appender.console.type = Console\\n\" +\n+                        \"appender.console.name = STDOUT\\n\" +\n+                        \"appender.console.layout.type = PatternLayout\\n\" +\n+                        \"appender.console.layout.pattern = [%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                        \"\\n\" +\n+                        \"rootLogger.level = TRACE\\n\" +\n+                        \"rootLogger.appenderRefs = stdout\\n\" +\n+                        \"rootLogger.appenderRef.console.ref = STDOUT\\n\" +\n+                        \"rootLogger.additivity = false\"))\n+                .build();\n+\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapTo);\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapUo);\n+\n+        ExternalLogging elTo = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-to\")\n+                .build();\n+\n+        ExternalLogging elUo = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-uo\")\n+                .build();\n+\n+        // change to external logging\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(elTo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(elUo);\n+        });\n+\n+        String finalEoPodName1 = eoPodName;\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT, () -> {\n+                return cmdKubeClient().execInPodContainer(finalEoPodName1, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level = TRACE\")\n+                        && cmdKubeClient().execInPodContainer(finalEoPodName1, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level = TRACE\");\n+            }\n+        );\n+\n+        eoPodName = eoPods.keySet().iterator().next();\n+        eoPodHash = eoPods.get(eoPodName);\n+        eoPods = DeploymentUtils.depSnapshot(eoName);\n+        eoPodNameAfterLoggingChange = eoPods.keySet().iterator().next();\n+        assertThat(\"Pod name changed after logging changed\", eoPodNameAfterLoggingChange.equals(eoPodName), is(true));\n+        assertThat(\"Pod hash changed after logging changed\", eoPods.get(eoPodNameAfterLoggingChange).equals(eoPodHash), is(true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MzE5Mw=="}, "originalCommit": {"oid": "eef5f038315cc85ca5b732297d1a140c8b668d45"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODg2MzQ5OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/LogSettingST.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo0Mjo1N1rOGKNHAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjo0MDoyOVrOGKZAeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MzczMA==", "bodyText": "How do ou know you are changing it? Aran't INFO levels usually the defaults?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r413353730", "createdAt": "2020-04-22T21:42:57Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/LogSettingST.java", "diffHunk": "@@ -479,6 +482,138 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @Order(14)\n+    void testDynamicallySetEOloggingLevels() {\n+        String eoName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoName);\n+\n+        // change inline logging\n+        InlineLogging il = new InlineLogging();\n+        il.setLoggers(Collections.singletonMap(\"rootLogger.level\", INFO));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eef5f038315cc85ca5b732297d1a140c8b668d45"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0ODY2Ng==", "bodyText": "The test are using DEBUG.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r413548666", "createdAt": "2020-04-23T06:40:29Z", "author": {"login": "sknot-rh"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/LogSettingST.java", "diffHunk": "@@ -479,6 +482,138 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @Order(14)\n+    void testDynamicallySetEOloggingLevels() {\n+        String eoName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoName);\n+\n+        // change inline logging\n+        InlineLogging il = new InlineLogging();\n+        il.setLoggers(Collections.singletonMap(\"rootLogger.level\", INFO));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MzczMA=="}, "originalCommit": {"oid": "eef5f038315cc85ca5b732297d1a140c8b668d45"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODg2OTM1OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/LogSettingST.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo0NDo1NVrOGKNKjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwOTo1MTo0N1rOGcWSkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1NDYzNg==", "bodyText": "Maybe I missed it. But I'm not sure where this really tests the reloading. But I do not see any test that the log4j2.properties was reloaded and the new log level is used. I think that is the mainpoint odf this change so it should be tested.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r413354636", "createdAt": "2020-04-22T21:44:55Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/LogSettingST.java", "diffHunk": "@@ -479,6 +482,138 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @Order(14)\n+    void testDynamicallySetEOloggingLevels() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eef5f038315cc85ca5b732297d1a140c8b668d45"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0ODU0Ng==", "bodyText": "It is testing th e log4j2.properties has been changed: https://github.com/strimzi/strimzi-kafka-operator/pull/2867/files/eef5f038315cc85ca5b732297d1a140c8b668d45#diff-406f189535ad433ebe2d832137206aa6R502\nYou are right we should also test the change really takes an effect. I gues I need help from @Frawless @see-quick there.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r413548546", "createdAt": "2020-04-23T06:40:11Z", "author": {"login": "sknot-rh"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/LogSettingST.java", "diffHunk": "@@ -479,6 +482,138 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @Order(14)\n+    void testDynamicallySetEOloggingLevels() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1NDYzNg=="}, "originalCommit": {"oid": "eef5f038315cc85ca5b732297d1a140c8b668d45"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1MjA3Mg==", "bodyText": "https://github.com/strimzi/strimzi-kafka-operator/blob/master/systemtest/src/test/java/io/strimzi/systemtest/RollingUpdateST.java#L689   Maybe we can add there a check that logging config file rly changed, but it's not a good idea to see if new debug level is available in logs, because oc cluster up is not friendly with that and from time to time just drop the logs", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r413552072", "createdAt": "2020-04-23T06:47:16Z", "author": {"login": "Frawless"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/LogSettingST.java", "diffHunk": "@@ -479,6 +482,138 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @Order(14)\n+    void testDynamicallySetEOloggingLevels() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1NDYzNg=="}, "originalCommit": {"oid": "eef5f038315cc85ca5b732297d1a140c8b668d45"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYxMTc3OA==", "bodyText": "I can understand that the reliability might be an issue here. But without that we should maybe consider the usefulness of this test maybe? Right now it really tests that Kube refreshs the config map volume. Does that need to be tested? Is it worth the testing time? If we actually check the logs, I would say yes. Without it? I'm not sure.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r413611778", "createdAt": "2020-04-23T08:20:38Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/LogSettingST.java", "diffHunk": "@@ -479,6 +482,138 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @Order(14)\n+    void testDynamicallySetEOloggingLevels() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1NDYzNg=="}, "originalCommit": {"oid": "eef5f038315cc85ca5b732297d1a140c8b668d45"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxMjY3Mw==", "bodyText": "I think this comment stands ... this test does not test dynamic logging reconfiguration. It just tests how Kuberetes update the mounted config map.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r430912673", "createdAt": "2020-05-27T07:31:20Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/LogSettingST.java", "diffHunk": "@@ -479,6 +482,138 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @Order(14)\n+    void testDynamicallySetEOloggingLevels() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1NDYzNg=="}, "originalCommit": {"oid": "eef5f038315cc85ca5b732297d1a140c8b668d45"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2MTUzNg==", "bodyText": "I see. IMHO it has to be tested by ST.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r432261536", "createdAt": "2020-05-29T05:23:33Z", "author": {"login": "sknot-rh"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/LogSettingST.java", "diffHunk": "@@ -479,6 +482,138 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @Order(14)\n+    void testDynamicallySetEOloggingLevels() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1NDYzNg=="}, "originalCommit": {"oid": "eef5f038315cc85ca5b732297d1a140c8b668d45"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM3ODUxNA==", "bodyText": "Why does the update of the ConfigMap which is Kubernetes thing need to be tested by our ST?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r432378514", "createdAt": "2020-05-29T09:51:47Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/LogSettingST.java", "diffHunk": "@@ -479,6 +482,138 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @Order(14)\n+    void testDynamicallySetEOloggingLevels() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1NDYzNg=="}, "originalCommit": {"oid": "eef5f038315cc85ca5b732297d1a140c8b668d45"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDAwMjE4OnYy", "diffSide": "RIGHT", "path": "CHANGELOG.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNzoyNDo1NVrOGa8nMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNzoyNDo1NVrOGa8nMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwOTIzMg==", "bodyText": "Thsi should move to 0.19.0", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r430909232", "createdAt": "2020-05-27T07:24:55Z", "author": {"login": "scholzj"}, "path": "CHANGELOG.md", "diffHunk": "@@ -19,6 +19,7 @@\n * Add support for CORS in the HTTP Kafka Bridge\n * Pass HTTP Proxy configuration from operator to operands\n * Add Cruise Control support, KafkaRebalance resource and rebalance operator\n+* Support dynamically changeable logging in the Entity Operator ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfa8483c65929106aa424f8b12e1c394ebb719c3"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDAwNzg0OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNzoyNjozNlrOGa8qyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMDoxMDoyNFrOGcW3Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxMDE1Mg==", "bodyText": "How can the users change this? Through the logger configuration in the CR? Or only with external logging configuration? In general, 5 seconds (is it seconds?) seems very short ... logging is not changed so often ... would 30 seconds or 1 minute be ore suitable?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r430910152", "createdAt": "2020-05-27T07:26:36Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -398,6 +398,21 @@ public String parseLogging(Logging logging, ConfigMap externalCm) {\n         }\n     }\n \n+    /**\n+     * Adds 'monitorInterval=5' to external logging ConfigMap. If ConfigMap already has this value, it is persisted.\n+     * This property is ignored by log4j but used by log4j2.\n+     * @param data\n+     * @return\n+     */\n+    protected String addMonitorIntervalToExternalLogging(String data) {\n+        if (!data.contains(\"monitorInterval=\")) {\n+            // do not override custom value\n+            return data + \"\\nmonitorInterval=5\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfa8483c65929106aa424f8b12e1c394ebb719c3"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2MDYxNg==", "bodyText": "I do not think it is crucial to make it changeable by user. Basically it should be <5, reconciliationPeriod>. 5 seconds is the minimum from log4j2. Setting it to low value will have effect she logging will be updated shortly after the reconciliation. Some bigger value will take a long time to reload new configuration although there will be less reloads from log4j2.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r432260616", "createdAt": "2020-05-29T05:19:53Z", "author": {"login": "sknot-rh"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -398,6 +398,21 @@ public String parseLogging(Logging logging, ConfigMap externalCm) {\n         }\n     }\n \n+    /**\n+     * Adds 'monitorInterval=5' to external logging ConfigMap. If ConfigMap already has this value, it is persisted.\n+     * This property is ignored by log4j but used by log4j2.\n+     * @param data\n+     * @return\n+     */\n+    protected String addMonitorIntervalToExternalLogging(String data) {\n+        if (!data.contains(\"monitorInterval=\")) {\n+            // do not override custom value\n+            return data + \"\\nmonitorInterval=5\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxMDE1Mg=="}, "originalCommit": {"oid": "bfa8483c65929106aa424f8b12e1c394ebb719c3"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4NjA3Ng==", "bodyText": "Have you done any tests how much does the reloading cost? I think 5 seconds is quite agressive given how much often would this happen. If the costs are negligible it is fine. If not, we should use some higher value I think.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r432386076", "createdAt": "2020-05-29T10:06:39Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -398,6 +398,21 @@ public String parseLogging(Logging logging, ConfigMap externalCm) {\n         }\n     }\n \n+    /**\n+     * Adds 'monitorInterval=5' to external logging ConfigMap. If ConfigMap already has this value, it is persisted.\n+     * This property is ignored by log4j but used by log4j2.\n+     * @param data\n+     * @return\n+     */\n+    protected String addMonitorIntervalToExternalLogging(String data) {\n+        if (!data.contains(\"monitorInterval=\")) {\n+            // do not override custom value\n+            return data + \"\\nmonitorInterval=5\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxMDE1Mg=="}, "originalCommit": {"oid": "bfa8483c65929106aa424f8b12e1c394ebb719c3"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4Nzg3OQ==", "bodyText": "No I did not. I increased the value to 30s.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r432387879", "createdAt": "2020-05-29T10:10:24Z", "author": {"login": "sknot-rh"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -398,6 +398,21 @@ public String parseLogging(Logging logging, ConfigMap externalCm) {\n         }\n     }\n \n+    /**\n+     * Adds 'monitorInterval=5' to external logging ConfigMap. If ConfigMap already has this value, it is persisted.\n+     * This property is ignored by log4j but used by log4j2.\n+     * @param data\n+     * @return\n+     */\n+    protected String addMonitorIntervalToExternalLogging(String data) {\n+        if (!data.contains(\"monitorInterval=\")) {\n+            // do not override custom value\n+            return data + \"\\nmonitorInterval=5\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxMDE1Mg=="}, "originalCommit": {"oid": "bfa8483c65929106aa424f8b12e1c394ebb719c3"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDAxMjI2OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityTopicOperator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNzoyNzo1N1rOGa8tlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMDowNToyMVrOGcWt0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxMDg3MQ==", "bodyText": "The javadoc suggests that this is Log4j specific method? If yes, it should be reflected in the name ... e.g. createLog4j2Properties", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r430910871", "createdAt": "2020-05-27T07:27:57Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityTopicOperator.java", "diffHunk": "@@ -313,8 +313,19 @@ public void setContainerEnvVars(List<ContainerEnvVar> envVars) {\n         templateContainerEnvVars = envVars;\n     }\n \n-\n     public void setContainerSecurityContext(SecurityContext securityContext) {\n         templateContainerSecurityContext = securityContext;\n     }\n+\n+    /**\n+     * Transforms properties to log4j2 properties file format and adds property for reloading the config\n+     * @param properties map with properties\n+     * @return modified string with monitorInterval\n+     */\n+    @Override\n+    public String createPropertiesString(OrderedProperties properties) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfa8483c65929106aa424f8b12e1c394ebb719c3"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI1OTI5NQ==", "bodyText": "It is called from the abstract model class (\n  \n    \n      strimzi-kafka-operator/cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java\n    \n    \n         Line 386\n      in\n      8f49fff\n    \n    \n    \n    \n\n        \n          \n           return createPropertiesString(newSettings); \n        \n    \n  \n\n)\nI am not sure whether renaming this is worth of overriding entire parseLogging method.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r432259295", "createdAt": "2020-05-29T05:14:18Z", "author": {"login": "sknot-rh"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityTopicOperator.java", "diffHunk": "@@ -313,8 +313,19 @@ public void setContainerEnvVars(List<ContainerEnvVar> envVars) {\n         templateContainerEnvVars = envVars;\n     }\n \n-\n     public void setContainerSecurityContext(SecurityContext securityContext) {\n         templateContainerSecurityContext = securityContext;\n     }\n+\n+    /**\n+     * Transforms properties to log4j2 properties file format and adds property for reloading the config\n+     * @param properties map with properties\n+     * @return modified string with monitorInterval\n+     */\n+    @Override\n+    public String createPropertiesString(OrderedProperties properties) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxMDg3MQ=="}, "originalCommit": {"oid": "bfa8483c65929106aa424f8b12e1c394ebb719c3"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4NTQ4OA==", "bodyText": "If that function is specific to log4j you should name it like that. I'm not sure you need to override anything - just rename it eevrywhere, or? Ad if it is not specific for Log4j, it should not say so in the comment.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r432385488", "createdAt": "2020-05-29T10:05:21Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/EntityTopicOperator.java", "diffHunk": "@@ -313,8 +313,19 @@ public void setContainerEnvVars(List<ContainerEnvVar> envVars) {\n         templateContainerEnvVars = envVars;\n     }\n \n-\n     public void setContainerSecurityContext(SecurityContext securityContext) {\n         templateContainerSecurityContext = securityContext;\n     }\n+\n+    /**\n+     * Transforms properties to log4j2 properties file format and adds property for reloading the config\n+     * @param properties map with properties\n+     * @return modified string with monitorInterval\n+     */\n+    @Override\n+    public String createPropertiesString(OrderedProperties properties) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxMDg3MQ=="}, "originalCommit": {"oid": "bfa8483c65929106aa424f8b12e1c394ebb719c3"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDAxNDc2OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/EntityOperatorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNzoyODo0MlrOGa8vKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNzoyODo0MlrOGa8vKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxMTI3Mg==", "bodyText": "So, what does this test? Is it missing some assert?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r430911272", "createdAt": "2020-05-27T07:28:42Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/model/EntityOperatorTest.java", "diffHunk": "@@ -93,6 +93,14 @@\n \n     private final EntityOperator entityOperator = EntityOperator.fromCrd(resource, VERSIONS);\n \n+    @Test\n+    public void lala() {\n+        OrderedProperties op = new OrderedProperties();\n+        op.addPair(\"karel\", \"42\");\n+        String res = entityOperator.createPropertiesString(op);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfa8483c65929106aa424f8b12e1c394ebb719c3"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMDQyMjEwOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMzoxNDoxNlrOGgdT1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMzoxNDoxNlrOGgdT1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4NzgyOQ==", "bodyText": "Can you please delete this @Order(14)? As we have new suite, we don't need to order the tests (because we are not deleting anything)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r436687829", "createdAt": "2020-06-08T13:14:16Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +184,162 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @Order(14)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2bf0a3d02a26a4885eeb67fb7d862aa442e88bf"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMDQzMDU0OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMzoxNTo0M1rOGgdZBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMzoxNTo0M1rOGgdZBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4OTE1OQ==", "bodyText": "The test will fail, because Kafka is not setup. Can you add it there? Or should I take a look at it?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r436689159", "createdAt": "2020-06-08T13:15:43Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +184,162 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @Order(14)\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2bf0a3d02a26a4885eeb67fb7d862aa442e88bf"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDYyMzk1OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjowMzo0MlrOGhGBZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNzoyNTowNVrOGhUzNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1NDg1Mw==", "bodyText": "what's data?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437354853", "createdAt": "2020-06-09T12:03:42Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -408,21 +407,35 @@ public String parseLogging(Logging logging, ConfigMap externalCm) {\n                 newSettings.addMapPairs(inlineLogging.getLoggers());\n             }\n \n-            return createPropertiesString(newSettings);\n-\n+            return createLog4jProperties(newSettings);\n         } else if (logging instanceof ExternalLogging) {\n             if (externalCm != null && externalCm.getData() != null && externalCm.getData().containsKey(getAncillaryConfigMapKeyLogConfig())) {\n-                return externalCm.getData().get(getAncillaryConfigMapKeyLogConfig());\n+                return addMonitorIntervalToExternalLogging(externalCm.getData().get(getAncillaryConfigMapKeyLogConfig()));\n             } else {\n                 log.warn(\"ConfigMap {} with external logging configuration does not exist or doesn't contain the configuration under the {} key. Default logging settings are used.\",\n                         ((ExternalLogging) getLogging()).getName(),\n                         getAncillaryConfigMapKeyLogConfig());\n-                return createPropertiesString(getDefaultLogConfig());\n+                return createLog4jProperties(getDefaultLogConfig());\n             }\n \n         } else {\n             log.debug(\"logging is not set, using default loggers\");\n-            return createPropertiesString(getDefaultLogConfig());\n+            return createLog4jProperties(getDefaultLogConfig());\n+        }\n+    }\n+\n+    /**\n+     * Adds 'monitorInterval=5' to external logging ConfigMap. If ConfigMap already has this value, it is persisted.\n+     * This property is ignored by log4j but used by log4j2.\n+     * @param data", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06cfd037f77c84bd2992caf3af8ef01f47de2b1f"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM5Mjk3Ng==", "bodyText": "data from configmap", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437392976", "createdAt": "2020-06-09T12:58:51Z", "author": {"login": "sknot-rh"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -408,21 +407,35 @@ public String parseLogging(Logging logging, ConfigMap externalCm) {\n                 newSettings.addMapPairs(inlineLogging.getLoggers());\n             }\n \n-            return createPropertiesString(newSettings);\n-\n+            return createLog4jProperties(newSettings);\n         } else if (logging instanceof ExternalLogging) {\n             if (externalCm != null && externalCm.getData() != null && externalCm.getData().containsKey(getAncillaryConfigMapKeyLogConfig())) {\n-                return externalCm.getData().get(getAncillaryConfigMapKeyLogConfig());\n+                return addMonitorIntervalToExternalLogging(externalCm.getData().get(getAncillaryConfigMapKeyLogConfig()));\n             } else {\n                 log.warn(\"ConfigMap {} with external logging configuration does not exist or doesn't contain the configuration under the {} key. Default logging settings are used.\",\n                         ((ExternalLogging) getLogging()).getName(),\n                         getAncillaryConfigMapKeyLogConfig());\n-                return createPropertiesString(getDefaultLogConfig());\n+                return createLog4jProperties(getDefaultLogConfig());\n             }\n \n         } else {\n             log.debug(\"logging is not set, using default loggers\");\n-            return createPropertiesString(getDefaultLogConfig());\n+            return createLog4jProperties(getDefaultLogConfig());\n+        }\n+    }\n+\n+    /**\n+     * Adds 'monitorInterval=5' to external logging ConfigMap. If ConfigMap already has this value, it is persisted.\n+     * This property is ignored by log4j but used by log4j2.\n+     * @param data", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1NDg1Mw=="}, "originalCommit": {"oid": "06cfd037f77c84bd2992caf3af8ef01f47de2b1f"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU5Njk4Mg==", "bodyText": "So, maybe it should be described there what exactly is this expected to be and in which format.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437596982", "createdAt": "2020-06-09T17:25:05Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -408,21 +407,35 @@ public String parseLogging(Logging logging, ConfigMap externalCm) {\n                 newSettings.addMapPairs(inlineLogging.getLoggers());\n             }\n \n-            return createPropertiesString(newSettings);\n-\n+            return createLog4jProperties(newSettings);\n         } else if (logging instanceof ExternalLogging) {\n             if (externalCm != null && externalCm.getData() != null && externalCm.getData().containsKey(getAncillaryConfigMapKeyLogConfig())) {\n-                return externalCm.getData().get(getAncillaryConfigMapKeyLogConfig());\n+                return addMonitorIntervalToExternalLogging(externalCm.getData().get(getAncillaryConfigMapKeyLogConfig()));\n             } else {\n                 log.warn(\"ConfigMap {} with external logging configuration does not exist or doesn't contain the configuration under the {} key. Default logging settings are used.\",\n                         ((ExternalLogging) getLogging()).getName(),\n                         getAncillaryConfigMapKeyLogConfig());\n-                return createPropertiesString(getDefaultLogConfig());\n+                return createLog4jProperties(getDefaultLogConfig());\n             }\n \n         } else {\n             log.debug(\"logging is not set, using default loggers\");\n-            return createPropertiesString(getDefaultLogConfig());\n+            return createLog4jProperties(getDefaultLogConfig());\n+        }\n+    }\n+\n+    /**\n+     * Adds 'monitorInterval=5' to external logging ConfigMap. If ConfigMap already has this value, it is persisted.\n+     * This property is ignored by log4j but used by log4j2.\n+     * @param data", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1NDg1Mw=="}, "originalCommit": {"oid": "06cfd037f77c84bd2992caf3af8ef01f47de2b1f"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDY2NjkzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjoxNjoyN1rOGhGcWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzowMjozMVrOGhIj5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2MTc1Mw==", "bodyText": "my doubt is ...\nThis feature seems to be available only when the user uses external logging configuration (via ConfigMap) and what we are doing here is just adding a field (the monitorInterval one). It means that the user could do that by himself, if we document it or if the user already knows about this feature.\nOr did I get it wrong on how it works?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437361753", "createdAt": "2020-06-09T12:16:27Z", "author": {"login": "ppatierno"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -408,21 +407,35 @@ public String parseLogging(Logging logging, ConfigMap externalCm) {\n                 newSettings.addMapPairs(inlineLogging.getLoggers());\n             }\n \n-            return createPropertiesString(newSettings);\n-\n+            return createLog4jProperties(newSettings);\n         } else if (logging instanceof ExternalLogging) {\n             if (externalCm != null && externalCm.getData() != null && externalCm.getData().containsKey(getAncillaryConfigMapKeyLogConfig())) {\n-                return externalCm.getData().get(getAncillaryConfigMapKeyLogConfig());\n+                return addMonitorIntervalToExternalLogging(externalCm.getData().get(getAncillaryConfigMapKeyLogConfig()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06cfd037f77c84bd2992caf3af8ef01f47de2b1f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM5NjQ1Mg==", "bodyText": "No, it works for internal logging as well (see method createLog4jProperties(OrderedProperties) overriden in EO classes). This monitorInterval=30 is added in both cases. If user specifies his own monitorInterval it is respected and his value is used.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437396452", "createdAt": "2020-06-09T13:02:31Z", "author": {"login": "sknot-rh"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -408,21 +407,35 @@ public String parseLogging(Logging logging, ConfigMap externalCm) {\n                 newSettings.addMapPairs(inlineLogging.getLoggers());\n             }\n \n-            return createPropertiesString(newSettings);\n-\n+            return createLog4jProperties(newSettings);\n         } else if (logging instanceof ExternalLogging) {\n             if (externalCm != null && externalCm.getData() != null && externalCm.getData().containsKey(getAncillaryConfigMapKeyLogConfig())) {\n-                return externalCm.getData().get(getAncillaryConfigMapKeyLogConfig());\n+                return addMonitorIntervalToExternalLogging(externalCm.getData().get(getAncillaryConfigMapKeyLogConfig()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2MTc1Mw=="}, "originalCommit": {"oid": "06cfd037f77c84bd2992caf3af8ef01f47de2b1f"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNjExNjk3OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNzoyMzozOFrOGhUv8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNzoyMzozOFrOGhUv8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU5NjE0NA==", "bodyText": "The interval is not 30 seconds.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437596144", "createdAt": "2020-06-09T17:23:38Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -408,21 +407,35 @@ public String parseLogging(Logging logging, ConfigMap externalCm) {\n                 newSettings.addMapPairs(inlineLogging.getLoggers());\n             }\n \n-            return createPropertiesString(newSettings);\n-\n+            return createLog4jProperties(newSettings);\n         } else if (logging instanceof ExternalLogging) {\n             if (externalCm != null && externalCm.getData() != null && externalCm.getData().containsKey(getAncillaryConfigMapKeyLogConfig())) {\n-                return externalCm.getData().get(getAncillaryConfigMapKeyLogConfig());\n+                return addMonitorIntervalToExternalLogging(externalCm.getData().get(getAncillaryConfigMapKeyLogConfig()));\n             } else {\n                 log.warn(\"ConfigMap {} with external logging configuration does not exist or doesn't contain the configuration under the {} key. Default logging settings are used.\",\n                         ((ExternalLogging) getLogging()).getName(),\n                         getAncillaryConfigMapKeyLogConfig());\n-                return createPropertiesString(getDefaultLogConfig());\n+                return createLog4jProperties(getDefaultLogConfig());\n             }\n \n         } else {\n             log.debug(\"logging is not set, using default loggers\");\n-            return createPropertiesString(getDefaultLogConfig());\n+            return createLog4jProperties(getDefaultLogConfig());\n+        }\n+    }\n+\n+    /**\n+     * Adds 'monitorInterval=5' to external logging ConfigMap. If ConfigMap already has this value, it is persisted.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "422dabcff73bf5407e8526c1eebaf241c0d2b411"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNjEyMDIzOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNzoyNDozNlrOGhUyAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNzoyNDozNlrOGhUyAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU5NjY3Mw==", "bodyText": "Does this mean we are adding this to both Log4j2 logs where it is used as well as to log4j logs where it is ignored? That would be wrong since it would be confusing to anyone who checks the map. You should add it only in the place where it is supported.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437596673", "createdAt": "2020-06-09T17:24:36Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -408,21 +407,35 @@ public String parseLogging(Logging logging, ConfigMap externalCm) {\n                 newSettings.addMapPairs(inlineLogging.getLoggers());\n             }\n \n-            return createPropertiesString(newSettings);\n-\n+            return createLog4jProperties(newSettings);\n         } else if (logging instanceof ExternalLogging) {\n             if (externalCm != null && externalCm.getData() != null && externalCm.getData().containsKey(getAncillaryConfigMapKeyLogConfig())) {\n-                return externalCm.getData().get(getAncillaryConfigMapKeyLogConfig());\n+                return addMonitorIntervalToExternalLogging(externalCm.getData().get(getAncillaryConfigMapKeyLogConfig()));\n             } else {\n                 log.warn(\"ConfigMap {} with external logging configuration does not exist or doesn't contain the configuration under the {} key. Default logging settings are used.\",\n                         ((ExternalLogging) getLogging()).getName(),\n                         getAncillaryConfigMapKeyLogConfig());\n-                return createPropertiesString(getDefaultLogConfig());\n+                return createLog4jProperties(getDefaultLogConfig());\n             }\n \n         } else {\n             log.debug(\"logging is not set, using default loggers\");\n-            return createPropertiesString(getDefaultLogConfig());\n+            return createLog4jProperties(getDefaultLogConfig());\n+        }\n+    }\n+\n+    /**\n+     * Adds 'monitorInterval=5' to external logging ConfigMap. If ConfigMap already has this value, it is persisted.\n+     * This property is ignored by log4j but used by log4j2.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "422dabcff73bf5407e8526c1eebaf241c0d2b411"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNjE2OTY2OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNzozODoxNFrOGhVRuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjo0MzowMFrOGhm3wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNDc5Mw==", "bodyText": "Quite a lot of waiting here. Is all needed?\n\nYou first wait for some unknown time for rolling update to not happen. How long is that waiting?\nThen you wait for the ConfigMap reload\nThan you wait 2*Reconciliation interval for the logging to ... reload?\n\nI wonder if this can be done faster. For example maybe you can check that the pod did not roll just after the other waits instead of waiting for it on the beginning?\nThis applies all over this test - maybe it is really what is needed ... but I wanna raise it just in case you did not considered it.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437604793", "createdAt": "2020-06-09T17:38:14Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,162 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"30s\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"30s\"), is(emptyString()));\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"INFO\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will appear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"5m\"), is(not(emptyString())));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"5m\"), is(not(emptyString())));\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "422dabcff73bf5407e8526c1eebaf241c0d2b411"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg5MDEwNQ==", "bodyText": "The first thing is 50s (it is the same as testing pod stability).\nI do wait for 2*Reconciliation because it is the worst-case time after which is the logging really set to the new value. Reconciliation in tests is 30s so in the worst case the log4j2.properties file is regenerated 30s after the change is applied. Then, there is another 30s monitorInterval after which the configuration is reloaded.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437890105", "createdAt": "2020-06-10T06:35:33Z", "author": {"login": "sknot-rh"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,162 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"30s\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"30s\"), is(emptyString()));\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"INFO\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will appear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"5m\"), is(not(emptyString())));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"5m\"), is(not(emptyString())));\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNDc5Mw=="}, "originalCommit": {"oid": "422dabcff73bf5407e8526c1eebaf241c0d2b411"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg5MzA1Ng==", "bodyText": "Just because today the intervals in the tests are the same you should not count on it for the future. So maybe it is better to use the timeout based on your calculation and explain it in comments than use 2*Reconciliation which might change and be different in the future (e.g. the default reconciliation in CO is 2 minutes and not 30 seconds, so it might not be something to rely on if your logic is based on 30 seconds comming from something else).", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437893056", "createdAt": "2020-06-10T06:43:00Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,162 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"30s\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"30s\"), is(emptyString()));\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"INFO\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will appear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"5m\"), is(not(emptyString())));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"5m\"), is(not(emptyString())));\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNDc5Mw=="}, "originalCommit": {"oid": "422dabcff73bf5407e8526c1eebaf241c0d2b411"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNjE4MTA0OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "isResolved": false, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNzo0MToyMVrOGhVY5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNzoxMzoyM1rOGhnsfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNjYyOQ==", "bodyText": "Why do you need to switch it off again before the external logging part of the test?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437606629", "createdAt": "2020-06-09T17:41:21Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,162 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"30s\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"30s\"), is(emptyString()));\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"INFO\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will appear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"5m\"), is(not(emptyString())));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"5m\"), is(not(emptyString())));\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "422dabcff73bf5407e8526c1eebaf241c0d2b411"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYzNTE4Ng==", "bodyText": "The idea here was to see if the logging is really changed (you see the difference that it will log something).", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437635186", "createdAt": "2020-06-09T18:30:29Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,162 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"30s\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"30s\"), is(emptyString()));\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"INFO\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will appear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"5m\"), is(not(emptyString())));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"5m\"), is(not(emptyString())));\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNjYyOQ=="}, "originalCommit": {"oid": "422dabcff73bf5407e8526c1eebaf241c0d2b411"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYzNzU1NA==", "bodyText": "Right ... but you seem to go OFF -> INFO -> OFF ... why is OFF-> INFO not enough?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437637554", "createdAt": "2020-06-09T18:34:46Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,162 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"30s\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"30s\"), is(emptyString()));\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"INFO\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will appear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"5m\"), is(not(emptyString())));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"5m\"), is(not(emptyString())));\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNjYyOQ=="}, "originalCommit": {"oid": "422dabcff73bf5407e8526c1eebaf241c0d2b411"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MzI1MQ==", "bodyText": "We wanted to try inline logging and external logging, so we done it this way. I can simplify it if you agree.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437653251", "createdAt": "2020-06-09T19:02:38Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,162 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"30s\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"30s\"), is(emptyString()));\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"INFO\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will appear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"5m\"), is(not(emptyString())));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"5m\"), is(not(emptyString())));\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNjYyOQ=="}, "originalCommit": {"oid": "422dabcff73bf5407e8526c1eebaf241c0d2b411"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1NzMwOA==", "bodyText": "I can simplify it like this -> setup the inline logging when we are deploying Kafka, then switch it to OFF and then using external logging change it to INFO -> WDYT @scholzj @Frawless @stanlyDoge ?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437657308", "createdAt": "2020-06-09T19:10:02Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,162 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"30s\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"30s\"), is(emptyString()));\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"INFO\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will appear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"5m\"), is(not(emptyString())));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"5m\"), is(not(emptyString())));\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNjYyOQ=="}, "originalCommit": {"oid": "422dabcff73bf5407e8526c1eebaf241c0d2b411"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3MDIyNw==", "bodyText": "That sounds like it might save some time.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437670227", "createdAt": "2020-06-09T19:34:46Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,162 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"30s\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"30s\"), is(emptyString()));\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"INFO\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will appear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"5m\"), is(not(emptyString())));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"5m\"), is(not(emptyString())));\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNjYyOQ=="}, "originalCommit": {"oid": "422dabcff73bf5407e8526c1eebaf241c0d2b411"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkwNTAzNQ==", "bodyText": "The idea of this test is to do OFF->INFO for inline and OFF->INFO for external logging, so the steps are (OFF->INFO)->(OFF->INFO).", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437905035", "createdAt": "2020-06-10T07:10:15Z", "author": {"login": "sknot-rh"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,162 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"30s\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"30s\"), is(emptyString()));\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"INFO\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will appear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"5m\"), is(not(emptyString())));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"5m\"), is(not(emptyString())));\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNjYyOQ=="}, "originalCommit": {"oid": "422dabcff73bf5407e8526c1eebaf241c0d2b411"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkwNjMwMg==", "bodyText": "That might have been the idea, but since both OFFs are done with internal logging, it is really (OFF -> INFO -> OFF) and the reloading of external logging changes is not tested.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437906302", "createdAt": "2020-06-10T07:12:54Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,162 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"30s\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"30s\"), is(emptyString()));\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"INFO\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will appear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"5m\"), is(not(emptyString())));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"5m\"), is(not(emptyString())));\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNjYyOQ=="}, "originalCommit": {"oid": "422dabcff73bf5407e8526c1eebaf241c0d2b411"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkwNjU1Nw==", "bodyText": "I think the idea makes sense, but the second OFF should be done with external logging.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437906557", "createdAt": "2020-06-10T07:13:23Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,162 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"30s\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"30s\"), is(emptyString()));\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"INFO\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will appear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"5m\"), is(not(emptyString())));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"5m\"), is(not(emptyString())));\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNjYyOQ=="}, "originalCommit": {"oid": "422dabcff73bf5407e8526c1eebaf241c0d2b411"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNjE4Mzg2OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNzo0MjowNlrOGhVavw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxOTowMTo0M1rOGhYNKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNzEwMw==", "bodyText": "Why is this waiting for 5 minutes while for no logs only 30 seconds? If 30 seconds are good there, shouldn't they be good also here and vice versa?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437607103", "createdAt": "2020-06-09T17:42:06Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,162 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"30s\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"30s\"), is(emptyString()));\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"INFO\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will appear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"5m\"), is(not(emptyString())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "422dabcff73bf5407e8526c1eebaf241c0d2b411"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYzNzY5Nw==", "bodyText": "I did this change -> if I remember what --since (I have this in the getLogFromPodByTime method) takes last x seconds/minutes/hours until the moment you execute ... so I thought that will cause some race conditions when we set only 30s to get log and the EO will not log anything in that time. I can try that and see, if I'm correct.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437637697", "createdAt": "2020-06-09T18:35:01Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,162 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"30s\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"30s\"), is(emptyString()));\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"INFO\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will appear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"5m\"), is(not(emptyString())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNzEwMw=="}, "originalCommit": {"oid": "422dabcff73bf5407e8526c1eebaf241c0d2b411"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY0MzY2Ng==", "bodyText": "Right. But, when switching the logging OFF, you approach it that 30s without any log message is enough to take it as configured. But when enabling the INFO level, you seem to suggest that 5 minutes are needed to ensure there is some log message. If you need 5 minutes to be sure you got some message, you also need 5 minutes to ensure you got no message, or?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437643666", "createdAt": "2020-06-09T18:45:38Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,162 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"30s\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"30s\"), is(emptyString()));\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"INFO\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will appear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"5m\"), is(not(emptyString())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNzEwMw=="}, "originalCommit": {"oid": "422dabcff73bf5407e8526c1eebaf241c0d2b411"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1Mjc3OA==", "bodyText": "Yeah, you are right, I gonna edit this :) thanks Jakub.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437652778", "createdAt": "2020-06-09T19:01:43Z", "author": {"login": "im-konge"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,162 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"30s\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"30s\"), is(emptyString()));\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"INFO\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will appear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"5m\"), is(not(emptyString())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNzEwMw=="}, "originalCommit": {"oid": "422dabcff73bf5407e8526c1eebaf241c0d2b411"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNjE4ODM2OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNzo0MzoyMVrOGhVdoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNzo0MzoyMVrOGhVdoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNzg0MQ==", "bodyText": "I wonder if we should follow with another part where you check that changes to external logging config map were applied as well.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r437607841", "createdAt": "2020-06-09T17:43:21Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,162 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1).done();\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"30s\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"30s\"), is(emptyString()));\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"INFO\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will appear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"5m\"), is(not(emptyString())));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"5m\"), is(not(emptyString())));\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"30s\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"30s\"), is(emptyString()));\n+\n+        LOGGER.info(\"Setting external logging INFO\");\n+        ConfigMap configMapTo = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-to\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withData(Collections.singletonMap(\"log4j2.properties\", \"name=TOConfig\\n\" +\n+                        \"appender.console.type=Console\\n\" +\n+                        \"appender.console.name=STDOUT\\n\" +\n+                        \"appender.console.layout.type=PatternLayout\\n\" +\n+                        \"appender.console.layout.pattern=[%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                        \"rootLogger.level=DEBUG\\n\" +\n+                        \"rootLogger.appenderRefs=stdout\\n\" +\n+                        \"rootLogger.appenderRef.console.ref=STDOUT\\n\" +\n+                        \"rootLogger.additivity=false\"))\n+                .build();\n+\n+        ConfigMap configMapUo = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-uo\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .addToData(Collections.singletonMap(\"log4j2.properties\", \"name=UOConfig\\n\" +\n+                        \"appender.console.type=Console\\n\" +\n+                        \"appender.console.name=STDOUT\\n\" +\n+                        \"appender.console.layout.type=PatternLayout\\n\" +\n+                        \"appender.console.layout.pattern=[%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                        \"rootLogger.level=DEBUG\\n\" +\n+                        \"rootLogger.appenderRefs=stdout\\n\" +\n+                        \"rootLogger.appenderRef.console.ref=STDOUT\\n\" +\n+                        \"rootLogger.additivity=false\"))\n+                .build();\n+\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapTo);\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapUo);\n+\n+        ExternalLogging elTo = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-to\")\n+                .build();\n+\n+        ExternalLogging elUo = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-uo\")\n+                .build();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to INFO - records should appear in log\");\n+        // change to external logging\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(elTo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(elUo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME), eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=DEBUG\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=DEBUG\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"monitorInterval=30\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"monitorInterval=30\")\n+        );\n+\n+        LOGGER.info(\"Waiting {}ms for INFO log will appear\", RECONCILIATION_INTERVAL * 2);\n+        // wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"5m\"), is(not(emptyString())));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"5m\"), is(not(emptyString())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "422dabcff73bf5407e8526c1eebaf241c0d2b411"}, "originalPosition": 195}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1OTg2NzIyOnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxODoxODo1MlrOGmdnQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxODoxODo1MlrOGmdnQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NDI1Nw==", "bodyText": "Should 30 be a constant defined somewhere? Just with doign this for EO, you seem to have already 4 places with hardcoded 30.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r442984257", "createdAt": "2020-06-19T18:18:52Z", "author": {"login": "scholzj"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -408,21 +407,34 @@ public String parseLogging(Logging logging, ConfigMap externalCm) {\n                 newSettings.addMapPairs(inlineLogging.getLoggers());\n             }\n \n-            return createPropertiesString(newSettings);\n-\n+            return createLog4jProperties(newSettings);\n         } else if (logging instanceof ExternalLogging) {\n             if (externalCm != null && externalCm.getData() != null && externalCm.getData().containsKey(getAncillaryConfigMapKeyLogConfig())) {\n-                return externalCm.getData().get(getAncillaryConfigMapKeyLogConfig());\n+                return maybeAddMonitorIntervalToExternalLogging(externalCm.getData().get(getAncillaryConfigMapKeyLogConfig()));\n             } else {\n                 log.warn(\"ConfigMap {} with external logging configuration does not exist or doesn't contain the configuration under the {} key. Default logging settings are used.\",\n                         ((ExternalLogging) getLogging()).getName(),\n                         getAncillaryConfigMapKeyLogConfig());\n-                return createPropertiesString(getDefaultLogConfig());\n+                return createLog4jProperties(getDefaultLogConfig());\n             }\n \n         } else {\n             log.debug(\"logging is not set, using default loggers\");\n-            return createPropertiesString(getDefaultLogConfig());\n+            return createLog4jProperties(getDefaultLogConfig());\n+        }\n+    }\n+\n+    /**\n+     * Adds 'monitorInterval=30' to external logging ConfigMap. If ConfigMap already has this value, it is persisted.\n+     * @param data String with log4j(2) properties in format key=value separated by new lines\n+     * @return\n+     */\n+    protected String maybeAddMonitorIntervalToExternalLogging(String data) {\n+        if (getAncillaryConfigMapKeyLogConfig().equals(\"log4j2.properties\") && !data.contains(\"monitorInterval\")) {\n+            // do not override custom value\n+            return data + \"\\nmonitorInterval=30\\n\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9530c2048a35d672f7396a207904a0274b27946"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1OTg3OTEzOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxODoyMzoxM1rOGmduhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxODoyMzoxM1rOGmduhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NjExNw==", "bodyText": "Should you wait double the interval? With reloading every 30 seconds, this might basically hit at the same time without any log message, or? Or does the waitForNoRollingUpdate incure some waiting time as well?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r442986117", "createdAt": "2020-06-19T18:23:13Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,179 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1)\n+                .editSpec()\n+                    .editEntityOperator()\n+                        .editTopicOperator()\n+                            .withInlineLogging(ilOff)\n+                        .endTopicOperator()\n+                        .editUserOperator()\n+                            .withInlineLogging(ilOff)\n+                        .endUserOperator()\n+                    .endEntityOperator()\n+                .endSpec()\n+                .done();\n+\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"INFO\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will appear\", LOGGING_RELOADING_INTERVAL);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(LOGGING_RELOADING_INTERVAL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9530c2048a35d672f7396a207904a0274b27946"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1OTg4Mjk4OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxODoyNDo1NFrOGmdxAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxODoyNDo1NFrOGmdxAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4Njc1NQ==", "bodyText": "Similar to above ... The sleep is for 30 seconds but you collect logs for one minute ... with previous logging off it should not hurt but seems unexplained. Maybe adding some comments explaining where we wait for how long and why would help.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r442986755", "createdAt": "2020-06-19T18:24:54Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,179 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1)\n+                .editSpec()\n+                    .editEntityOperator()\n+                        .editTopicOperator()\n+                            .withInlineLogging(ilOff)\n+                        .endTopicOperator()\n+                        .editUserOperator()\n+                            .withInlineLogging(ilOff)\n+                        .endUserOperator()\n+                    .endEntityOperator()\n+                .endSpec()\n+                .done();\n+\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"INFO\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will appear\", LOGGING_RELOADING_INTERVAL);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(LOGGING_RELOADING_INTERVAL);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"1m\"), is(not(emptyString())));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"1m\"), is(not(emptyString())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9530c2048a35d672f7396a207904a0274b27946"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1OTg4Njc5OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxODoyNjozNFrOGmdzcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxODoyNjozNFrOGmdzcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NzM3Nw==", "bodyText": "Same as above ... I think this no logical ... the logs might have just reloaded?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r442987377", "createdAt": "2020-06-19T18:26:34Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,179 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1)\n+                .editSpec()\n+                    .editEntityOperator()\n+                        .editTopicOperator()\n+                            .withInlineLogging(ilOff)\n+                        .endTopicOperator()\n+                        .editUserOperator()\n+                            .withInlineLogging(ilOff)\n+                        .endUserOperator()\n+                    .endEntityOperator()\n+                .endSpec()\n+                .done();\n+\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"INFO\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=INFO\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will appear\", LOGGING_RELOADING_INTERVAL);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(LOGGING_RELOADING_INTERVAL);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"1m\"), is(not(emptyString())));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"1m\"), is(not(emptyString())));\n+\n+        LOGGER.info(\"Setting external logging OFF\");\n+        ConfigMap configMapTo = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-to\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withData(Collections.singletonMap(\"log4j2.properties\", \"name=TOConfig\\n\" +\n+                        \"appender.console.type=Console\\n\" +\n+                        \"appender.console.name=STDOUT\\n\" +\n+                        \"appender.console.layout.type=PatternLayout\\n\" +\n+                        \"appender.console.layout.pattern=[%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                        \"rootLogger.level=OFF\\n\" +\n+                        \"rootLogger.appenderRefs=stdout\\n\" +\n+                        \"rootLogger.appenderRef.console.ref=STDOUT\\n\" +\n+                        \"rootLogger.additivity=false\"))\n+                .build();\n+\n+        ConfigMap configMapUo = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-uo\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .addToData(Collections.singletonMap(\"log4j2.properties\", \"name=UOConfig\\n\" +\n+                        \"appender.console.type=Console\\n\" +\n+                        \"appender.console.name=STDOUT\\n\" +\n+                        \"appender.console.layout.type=PatternLayout\\n\" +\n+                        \"appender.console.layout.pattern=[%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                        \"rootLogger.level=OFF\\n\" +\n+                        \"rootLogger.appenderRefs=stdout\\n\" +\n+                        \"rootLogger.appenderRef.console.ref=STDOUT\\n\" +\n+                        \"rootLogger.additivity=false\"))\n+                .build();\n+\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapTo);\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapUo);\n+\n+        ExternalLogging elTo = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-to\")\n+                .build();\n+\n+        ExternalLogging elUo = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-uo\")\n+                .build();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - records should not appear in log\");\n+        // change to external logging\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(elTo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(elUo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME), eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"monitorInterval=30\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"monitorInterval=30\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", LOGGING_RELOADING_INTERVAL);\n+        Thread.sleep(LOGGING_RELOADING_INTERVAL);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"1m\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"1m\"), is(emptyString()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9530c2048a35d672f7396a207904a0274b27946"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4OTUwODM0OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMDowODoyMVrOGq1c5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMDowODoyMVrOGq1c5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU2OTEyNA==", "bodyText": "Is the double empty line needed?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r447569124", "createdAt": "2020-06-30T10:08:21Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,179 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1)\n+                .editSpec()\n+                    .editEntityOperator()\n+                        .editTopicOperator()\n+                            .withInlineLogging(ilOff)\n+                        .endTopicOperator()\n+                        .editUserOperator()\n+                            .withInlineLogging(ilOff)\n+                        .endUserOperator()\n+                    .endEntityOperator()\n+                .endSpec()\n+                .done();\n+\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Changing rootLogger level to DEBUG with inline logging\");\n+        InlineLogging ilDebug = new InlineLogging();\n+        ilDebug.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"DEBUG\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilDebug);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilDebug);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=DEBUG\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=DEBUG\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for DEBUG log will appear\", LOGGING_RELOADING_INTERVAL);\n+        // wait some time and check whether logs (UO and TO) after this time contain anything\n+        Thread.sleep(LOGGING_RELOADING_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"1m\"), is(not(emptyString())));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"1m\"), is(not(emptyString())));\n+\n+        LOGGER.info(\"Setting external logging OFF\");\n+        ConfigMap configMapTo = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-to\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withData(Collections.singletonMap(\"log4j2.properties\", \"name=TOConfig\\n\" +\n+                        \"appender.console.type=Console\\n\" +\n+                        \"appender.console.name=STDOUT\\n\" +\n+                        \"appender.console.layout.type=PatternLayout\\n\" +\n+                        \"appender.console.layout.pattern=[%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                        \"rootLogger.level=OFF\\n\" +\n+                        \"rootLogger.appenderRefs=stdout\\n\" +\n+                        \"rootLogger.appenderRef.console.ref=STDOUT\\n\" +\n+                        \"rootLogger.additivity=false\"))\n+                .build();\n+\n+        ConfigMap configMapUo = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-uo\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .addToData(Collections.singletonMap(\"log4j2.properties\", \"name=UOConfig\\n\" +\n+                        \"appender.console.type=Console\\n\" +\n+                        \"appender.console.name=STDOUT\\n\" +\n+                        \"appender.console.layout.type=PatternLayout\\n\" +\n+                        \"appender.console.layout.pattern=[%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                        \"rootLogger.level=OFF\\n\" +\n+                        \"rootLogger.appenderRefs=stdout\\n\" +\n+                        \"rootLogger.appenderRef.console.ref=STDOUT\\n\" +\n+                        \"rootLogger.additivity=false\"))\n+                .build();\n+\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapTo);\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapUo);\n+\n+        ExternalLogging elTo = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-to\")\n+                .build();\n+\n+        ExternalLogging elUo = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-uo\")\n+                .build();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - records should not appear in log\");\n+        // change to external logging\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(elTo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(elUo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME), eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"monitorInterval=30\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"monitorInterval=30\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for DEBUG log will disappear\", LOGGING_RELOADING_INTERVAL);\n+        Thread.sleep(LOGGING_RELOADING_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"1m\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"1m\"), is(emptyString()));\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c77938028c8b6ef3da85f870d645e811b6ac601"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4OTUxODc4OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMDoxMToyNVrOGq1jlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMDoxMToyNVrOGq1jlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU3MDgzOQ==", "bodyText": "I think I still don't get this. You update the configuration and wait 2*30 seconds for the log reload. In the worst case, the reload happens at the end of the first 30 seconds and the new settings will be valid for the second 30 seconds. So checking the logs for last minut still does not seem to work for me. The same on the line 232.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r447570839", "createdAt": "2020-06-30T10:11:25Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LoggingChangeST.java", "diffHunk": "@@ -174,6 +183,179 @@ void testJSONFormatLogging() {\n         assertThat(StUtils.checkLogForJSONFormat(eoPods, \"user-operator\"), is(true));\n     }\n \n+    @Test\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"OFF\"));\n+\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, 1, 1)\n+                .editSpec()\n+                    .editEntityOperator()\n+                        .editTopicOperator()\n+                            .withInlineLogging(ilOff)\n+                        .endTopicOperator()\n+                        .editUserOperator()\n+                            .withInlineLogging(ilOff)\n+                        .endUserOperator()\n+                    .endEntityOperator()\n+                .endSpec()\n+                .done();\n+\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Changing rootLogger level to DEBUG with inline logging\");\n+        InlineLogging ilDebug = new InlineLogging();\n+        ilDebug.setLoggers(Collections.singletonMap(\"rootLogger.level\", \"DEBUG\"));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilDebug);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilDebug);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=DEBUG\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=DEBUG\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for DEBUG log will appear\", LOGGING_RELOADING_INTERVAL);\n+        // wait some time and check whether logs (UO and TO) after this time contain anything\n+        Thread.sleep(LOGGING_RELOADING_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log will contain some records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"1m\"), is(not(emptyString())));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"1m\"), is(not(emptyString())));\n+\n+        LOGGER.info(\"Setting external logging OFF\");\n+        ConfigMap configMapTo = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-to\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .withData(Collections.singletonMap(\"log4j2.properties\", \"name=TOConfig\\n\" +\n+                        \"appender.console.type=Console\\n\" +\n+                        \"appender.console.name=STDOUT\\n\" +\n+                        \"appender.console.layout.type=PatternLayout\\n\" +\n+                        \"appender.console.layout.pattern=[%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                        \"rootLogger.level=OFF\\n\" +\n+                        \"rootLogger.appenderRefs=stdout\\n\" +\n+                        \"rootLogger.appenderRef.console.ref=STDOUT\\n\" +\n+                        \"rootLogger.additivity=false\"))\n+                .build();\n+\n+        ConfigMap configMapUo = new ConfigMapBuilder()\n+                .withNewMetadata()\n+                .withName(\"external-configmap-uo\")\n+                .withNamespace(NAMESPACE)\n+                .endMetadata()\n+                .addToData(Collections.singletonMap(\"log4j2.properties\", \"name=UOConfig\\n\" +\n+                        \"appender.console.type=Console\\n\" +\n+                        \"appender.console.name=STDOUT\\n\" +\n+                        \"appender.console.layout.type=PatternLayout\\n\" +\n+                        \"appender.console.layout.pattern=[%d] %-5p <%-12.12c{1}:%L> [%-12.12t] %m%n\\n\" +\n+                        \"rootLogger.level=OFF\\n\" +\n+                        \"rootLogger.appenderRefs=stdout\\n\" +\n+                        \"rootLogger.appenderRef.console.ref=STDOUT\\n\" +\n+                        \"rootLogger.additivity=false\"))\n+                .build();\n+\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapTo);\n+        kubeClient().getClient().configMaps().inNamespace(NAMESPACE).createOrReplace(configMapUo);\n+\n+        ExternalLogging elTo = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-to\")\n+                .build();\n+\n+        ExternalLogging elUo = new ExternalLoggingBuilder()\n+                .withName(\"external-configmap-uo\")\n+                .build();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - records should not appear in log\");\n+        // change to external logging\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(elTo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(elUo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME), eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"monitorInterval=30\")\n+                        && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"monitorInterval=30\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for DEBUG log will disappear\", LOGGING_RELOADING_INTERVAL);\n+        Thread.sleep(LOGGING_RELOADING_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"1m\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"1m\"), is(emptyString()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c77938028c8b6ef3da85f870d645e811b6ac601"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NTQxNjc5OnYy", "diffSide": "RIGHT", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNzowMjo1OVrOGruQIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNzowMjo1OVrOGruQIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5OTc0NA==", "bodyText": "I don't think this is really good enough. monitorInterval could appear in a log4j2 properties config in numerous places other than the top level. You should at least use a regex like ^monitorInterval\\s+= (though you should verify even that). Or we just parse it as an OrderedProperties and check for the monitorInterval key, which I see you're also doing further on....???", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r448499744", "createdAt": "2020-07-01T17:02:59Z", "author": {"login": "tombentley"}, "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/AbstractModel.java", "diffHunk": "@@ -408,21 +408,34 @@ public String parseLogging(Logging logging, ConfigMap externalCm) {\n                 newSettings.addMapPairs(inlineLogging.getLoggers());\n             }\n \n-            return createPropertiesString(newSettings);\n-\n+            return createLog4jProperties(newSettings);\n         } else if (logging instanceof ExternalLogging) {\n             if (externalCm != null && externalCm.getData() != null && externalCm.getData().containsKey(getAncillaryConfigMapKeyLogConfig())) {\n-                return externalCm.getData().get(getAncillaryConfigMapKeyLogConfig());\n+                return maybeAddMonitorIntervalToExternalLogging(externalCm.getData().get(getAncillaryConfigMapKeyLogConfig()));\n             } else {\n                 log.warn(\"ConfigMap {} with external logging configuration does not exist or doesn't contain the configuration under the {} key. Default logging settings are used.\",\n                         ((ExternalLogging) getLogging()).getName(),\n                         getAncillaryConfigMapKeyLogConfig());\n-                return createPropertiesString(getDefaultLogConfig());\n+                return createLog4jProperties(getDefaultLogConfig());\n             }\n \n         } else {\n             log.debug(\"logging is not set, using default loggers\");\n-            return createPropertiesString(getDefaultLogConfig());\n+            return createLog4jProperties(getDefaultLogConfig());\n+        }\n+    }\n+\n+    /**\n+     * Adds 'monitorInterval=30' to external logging ConfigMap. If ConfigMap already has this value, it is persisted.\n+     * @param data String with log4j2 properties in format key=value separated by new lines\n+     * @return\n+     */\n+    protected String maybeAddMonitorIntervalToExternalLogging(String data) {\n+        if (getAncillaryConfigMapKeyLogConfig().equals(\"log4j2.properties\") && !data.contains(\"monitorInterval\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eee0fb11f4d92520bbee45fd54a02040b639e2d7"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NTQ0MDAwOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LogSettingST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNzoxMDozNVrOGrue9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNzoxMDozNVrOGrue9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUwMzU0MQ==", "bodyText": "Rather than adding these calls (which AFAICS just slow the test down) can't you take a pod snapshot (DeploymentUtils.depSnapshot()) at the start and verify that it's the same at the end?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r448503541", "createdAt": "2020-07-01T17:10:35Z", "author": {"login": "tombentley"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/log/LogSettingST.java", "diffHunk": "@@ -329,6 +341,162 @@ private String configMap(String configMapName) {\n         return configMapData.get(configMapKey);\n     }\n \n+    @Test\n+    @Order(14)\n+    @SuppressWarnings({\"checkstyle:MethodLength\"})\n+    void testDynamicallySetEOloggingLevels() throws InterruptedException {\n+        String eoDeploymentName = KafkaResources.entityOperatorDeploymentName(CLUSTER_NAME);\n+        Map<String, String> eoPods = DeploymentUtils.depSnapshot(eoDeploymentName);\n+\n+        final String eoPodName = eoPods.keySet().iterator().next();\n+\n+        LOGGER.info(\"Setting log level of TO and UO to OFF - no records should appear in log\");\n+        // change inline logging\n+        InlineLogging ilOff = new InlineLogging();\n+        ilOff.setLoggers(Collections.singletonMap(\"rootLogger.level\", OFF));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilOff);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilOff);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);\n+\n+        LOGGER.info(\"Waiting for log4j2.properties will contain desired settings\");\n+        TestUtils.waitFor(\"Logger change\", Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_TIMEOUT,\n+            () -> cmdKubeClient().execInPodContainer(eoPodName, \"topic-operator\", \"cat\", \"/opt/topic-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+                && cmdKubeClient().execInPodContainer(eoPodName, \"user-operator\", \"cat\", \"/opt/user-operator/custom-config/log4j2.properties\").out().contains(\"rootLogger.level=OFF\")\n+        );\n+\n+        LOGGER.info(\"Waiting {} ms for INFO log will disappear\", RECONCILIATION_INTERVAL * 2);\n+        //wait some time if TO and UO will log something\n+        Thread.sleep(RECONCILIATION_INTERVAL * 2);\n+\n+        LOGGER.info(\"Asserting if log is without records\");\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"topic-operator\", \"30s\"), is(emptyString()));\n+        assertThat(StUtils.getLogFromPodByTime(eoPodName, \"user-operator\", \"30s\"), is(emptyString()));\n+\n+        LOGGER.info(\"Changing rootLogger level to INFO with inline logging\");\n+        InlineLogging ilInfo = new InlineLogging();\n+        ilInfo.setLoggers(Collections.singletonMap(\"rootLogger.level\", INFO));\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, k -> {\n+            k.getSpec().getEntityOperator().getTopicOperator().setLogging(ilInfo);\n+            k.getSpec().getEntityOperator().getUserOperator().setLogging(ilInfo);\n+        });\n+\n+        LOGGER.info(\"The EO shouldn't roll - verifying pod stability\");\n+        DeploymentUtils.waitForNoRollingUpdate(eoDeploymentName, eoPods);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eee0fb11f4d92520bbee45fd54a02040b639e2d7"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxODQ4Mzc5OnYy", "diffSide": "RIGHT", "path": "operator-common/src/main/java/io/strimzi/operator/common/Annotations.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwODoxOTo1M1rOGvGs-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwODo1MDoyOVrOGvHzfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA0NjA3NQ==", "bodyText": "just curious, why should we have a different annotation to highlight that this is updated dynamically? Just because we haven't moved yet the others components to use the dynamic logging and we want to distinguish it? Does it mean that when all will be moved to use dynamic logging, we can revert back to use just \"logging\" annotation? I don't see great value to have \"dynamic-\" prefix.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r452046075", "createdAt": "2020-07-09T08:19:53Z", "author": {"login": "ppatierno"}, "path": "operator-common/src/main/java/io/strimzi/operator/common/Annotations.java", "diffHunk": "@@ -18,6 +18,7 @@\n \n     public static final String STRIMZI_DOMAIN = \"strimzi.io/\";\n     public static final String STRIMZI_LOGGING_ANNOTATION = STRIMZI_DOMAIN + \"logging\";\n+    public static final String STRIMZI_DYNAMIC_LOGGING_ANNOTATION = STRIMZI_DOMAIN + \"dynamic-logging\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c7bf869e0c0d8e1a4fcf03942a66ece7fc0ccf4"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA0OTIyNg==", "bodyText": "Not sure what name this annotation should have. Let me describe why we need this. Let's say user is running a strimzi without the dyn. logging and does not have monitorInterval entry in the log4j2.properties file. CO would add it but it does not have any effect until the pod is rolled and the log4j2 is started with log4j2.properties containing this entry. So it is necessary to roll the pod once the dynamic logging change is available.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r452049226", "createdAt": "2020-07-09T08:25:09Z", "author": {"login": "sknot-rh"}, "path": "operator-common/src/main/java/io/strimzi/operator/common/Annotations.java", "diffHunk": "@@ -18,6 +18,7 @@\n \n     public static final String STRIMZI_DOMAIN = \"strimzi.io/\";\n     public static final String STRIMZI_LOGGING_ANNOTATION = STRIMZI_DOMAIN + \"logging\";\n+    public static final String STRIMZI_DYNAMIC_LOGGING_ANNOTATION = STRIMZI_DOMAIN + \"dynamic-logging\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA0NjA3NQ=="}, "originalCommit": {"oid": "4c7bf869e0c0d8e1a4fcf03942a66ece7fc0ccf4"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA1MDkxNQ==", "bodyText": "That does not sound to me like a valid reason. When upgrading the CO, it will need to roll all pods to the newest image version. And that should also automatically roll it to use the monitorInterval, or? So I would say it is not needed really.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r452050915", "createdAt": "2020-07-09T08:27:55Z", "author": {"login": "scholzj"}, "path": "operator-common/src/main/java/io/strimzi/operator/common/Annotations.java", "diffHunk": "@@ -18,6 +18,7 @@\n \n     public static final String STRIMZI_DOMAIN = \"strimzi.io/\";\n     public static final String STRIMZI_LOGGING_ANNOTATION = STRIMZI_DOMAIN + \"logging\";\n+    public static final String STRIMZI_DYNAMIC_LOGGING_ANNOTATION = STRIMZI_DOMAIN + \"dynamic-logging\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA0NjA3NQ=="}, "originalCommit": {"oid": "4c7bf869e0c0d8e1a4fcf03942a66ece7fc0ccf4"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA2NDEyNA==", "bodyText": "In that case, I can remove it. Thanks.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2867#discussion_r452064124", "createdAt": "2020-07-09T08:50:29Z", "author": {"login": "sknot-rh"}, "path": "operator-common/src/main/java/io/strimzi/operator/common/Annotations.java", "diffHunk": "@@ -18,6 +18,7 @@\n \n     public static final String STRIMZI_DOMAIN = \"strimzi.io/\";\n     public static final String STRIMZI_LOGGING_ANNOTATION = STRIMZI_DOMAIN + \"logging\";\n+    public static final String STRIMZI_DYNAMIC_LOGGING_ANNOTATION = STRIMZI_DOMAIN + \"dynamic-logging\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA0NjA3NQ=="}, "originalCommit": {"oid": "4c7bf869e0c0d8e1a4fcf03942a66ece7fc0ccf4"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 205, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}