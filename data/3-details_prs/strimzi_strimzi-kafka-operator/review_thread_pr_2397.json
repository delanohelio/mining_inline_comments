{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyNjE5MDM0", "number": 2397, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMjowMjoxNVrODZMBew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMDo0NzozNFrODaIHZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NzM3OTc5OnYy", "diffSide": "RIGHT", "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/kubeUtils/objects/PodUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMjowMjoxNVrOFfcNYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMjowMjoxNVrOFfcNYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODUxMjM1NQ==", "bodyText": "It's not PodReplicasCount it's just ContainerInPodCount, better to use waitForPodsReady() I think or at least name it correctly.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2397#discussion_r368512355", "createdAt": "2020-01-20T12:02:15Z", "author": {"login": "Frawless"}, "path": "systemtest/src/main/java/io/strimzi/systemtest/utils/kubeUtils/objects/PodUtils.java", "diffHunk": "@@ -166,7 +166,15 @@ public static void waitUntilPodContainersCount(String podNamePrefix, int numberO\n         TestUtils.waitFor(\"Waiting till pod\" + podNamePrefix + \" will have \" + numberOfContainers + \" containers\",\n             Constants.GLOBAL_POLL_INTERVAL, Constants.GLOBAL_STATUS_TIMEOUT,\n             () -> kubeClient().listPodsByPrefixInName(podNamePrefix).get(0).getSpec().getContainers().size() == numberOfContainers);\n-        LOGGER.info(\"Waiting till pod {} will have {} containers\", podNamePrefix, numberOfContainers);\n+        LOGGER.info(\"Pod {} has {} containers\", podNamePrefix, numberOfContainers);\n+    }\n+\n+    public static void waitUntilPodReplicasCount(String podNamePrefix, int exceptedPods) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39032bfa459f051bf72900e147996faef3d290f9"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3OTg0MTUwOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/upgrade/ZookeeperUpgradeST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwOToyMjozOFrOFfzHGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwOToyMjozOFrOFfzHGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4NzU3Nw==", "bodyText": "You run with 3 replicas, so you should wait for 3 pods (the same below as well).", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2397#discussion_r368887577", "createdAt": "2020-01-21T09:22:38Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/upgrade/ZookeeperUpgradeST.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.upgrade;\n+\n+import io.strimzi.api.kafka.Crds;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.systemtest.BaseST;\n+import io.strimzi.systemtest.resources.KubernetesResource;\n+import io.strimzi.systemtest.resources.ResourceManager;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.utils.TestKafkaVersion;\n+import io.strimzi.systemtest.utils.kubeUtils.controllers.StatefulSetUtils;\n+import io.strimzi.systemtest.utils.kubeUtils.objects.PodUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.systemtest.Constants.UPGRADE;\n+import static io.strimzi.test.k8s.KubeClusterResource.cmdKubeClient;\n+import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+@Tag(UPGRADE)\n+public class ZookeeperUpgradeST extends BaseST {\n+\n+    private static final Logger LOGGER = LogManager.getLogger(ZookeeperUpgradeST.class);\n+\n+    public static final String NAMESPACE = \"zookeeper-upgrade-test\";\n+\n+    @Test\n+    void testKafkaClusterUpgrade() throws IOException, InterruptedException {\n+        List<TestKafkaVersion> sortedVersions = TestKafkaVersion.parseKafkaVersions();\n+\n+        TestKafkaVersion initialVersion = sortedVersions.get(sortedVersions.size() - 2);\n+        TestKafkaVersion newVersion = sortedVersions.get(sortedVersions.size() - 1);\n+\n+        runVersionChange(initialVersion, newVersion, 3, 3);\n+    }\n+\n+    @Test\n+    void testKafkaClusterDowngrade() throws IOException, InterruptedException {\n+        List<TestKafkaVersion> sortedVersions = TestKafkaVersion.parseKafkaVersions();\n+\n+        TestKafkaVersion initialVersion = sortedVersions.get(sortedVersions.size() - 1);\n+        TestKafkaVersion newVersion = sortedVersions.get(sortedVersions.size() - 2);\n+\n+        runVersionChange(initialVersion, newVersion, 3, 3);\n+    }\n+\n+    void runVersionChange(TestKafkaVersion initialVersion, TestKafkaVersion newVersion, int kafkaReplicas, int zkReplicas) throws InterruptedException {\n+        String logMsgFormat;\n+        if (initialVersion.compareTo(newVersion) < 0) {\n+            // If it is an upgrade test we keep the message format as the lower version number\n+            logMsgFormat = initialVersion.messageVersion();\n+        } else {\n+            // If it is a downgrade then we make sure to use the lower version number for the message format\n+            logMsgFormat = newVersion.messageVersion();\n+        }\n+\n+        LOGGER.info(\"Deploying initial Kafka version (\" + initialVersion.version() + \")\");\n+\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, kafkaReplicas, zkReplicas)\n+                .editSpec()\n+                    .editKafka()\n+                        .withVersion(initialVersion.version())\n+                        .addToConfig(\"log.message.format.version\", logMsgFormat)\n+                    .endKafka()\n+                .endSpec()\n+                .done();\n+\n+        LOGGER.info(\"Deployment of initial Kafka version (\" + initialVersion.version() + \") complete\");\n+\n+        String zkVersionCommand = \"ls libs | grep -Po 'zookeeper-\\\\K\\\\d+.\\\\d+.\\\\d+' | head -1\";\n+        String zkResult = cmdKubeClient().execInPodContainer(KafkaResources.zookeeperPodName(CLUSTER_NAME, 0),\n+                \"zookeeper\", \"/bin/bash\", \"-c\", zkVersionCommand).out().trim();\n+        LOGGER.info(\"Pre-change Zookeeper version query returned: \" + zkResult);\n+\n+        String kafkaVersionCommand = \"ls libs | grep -Po 'kafka_\\\\d+.\\\\d+-\\\\K(\\\\d+.\\\\d+.\\\\d+)(?=.jar)' | head -1\";\n+        String kafkaResult = cmdKubeClient().execInPodContainer(KafkaResources.kafkaPodName(CLUSTER_NAME, 0),\n+                \"kafka\", \"/bin/bash\", \"-c\", kafkaVersionCommand).out().trim();\n+        LOGGER.info(\"Pre-change Kafka version query returned: \" + kafkaResult);\n+\n+        Map<String, String> zkPods = StatefulSetUtils.ssSnapshot(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME));\n+        Map<String, String> kafkaPods = StatefulSetUtils.ssSnapshot(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME));\n+\n+        LOGGER.info(\"Updating Kafka CR version field to \" + newVersion.version());\n+\n+        // Get the Kafka resource from K8s\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setVersion(newVersion.version());\n+        });\n+\n+        Kafka retrievedKafka = Crds.kafkaOperation(kubeClient(NAMESPACE).getClient())\n+                .inNamespace(NAMESPACE)\n+                .withName(CLUSTER_NAME)\n+                .get();\n+\n+        // Change the Kafka version for the resource\n+        retrievedKafka.getSpec().getKafka().setVersion(newVersion.version());\n+\n+        // Patch the existing resource with this new version\n+        Crds.kafkaOperation(kubeClient().getClient()).inNamespace(NAMESPACE).withName(CLUSTER_NAME).patch(retrievedKafka);\n+\n+        LOGGER.info(\"Waiting for deployment of new Kafka version (\" + newVersion.version() + \") to complete\");\n+\n+        // Wait for the zk version change roll\n+        zkPods = StatefulSetUtils.waitTillSsHasRolled(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME), zkReplicas, zkPods);\n+        LOGGER.info(\"1st Zookeeper roll (image change) is complete\");\n+\n+        // Wait for the kafka broker version change roll\n+        kafkaPods = StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), kafkaReplicas, kafkaPods);\n+        LOGGER.info(\"Kafka roll (image change) is complete\");\n+\n+        PodUtils.waitUntilPodReplicasCount(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39032bfa459f051bf72900e147996faef3d290f9"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3OTg0NjM5OnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/upgrade/ZookeeperUpgradeST.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwOToyNDoyMFrOFfzKKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwOTo1OTo1N1rOFg4iKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4ODM2MA==", "bodyText": "This is a bit confusing. The message bellow says Zookeeper roll. But this method seems to check Kafka.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2397#discussion_r368888360", "createdAt": "2020-01-21T09:24:20Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/upgrade/ZookeeperUpgradeST.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.upgrade;\n+\n+import io.strimzi.api.kafka.Crds;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.systemtest.BaseST;\n+import io.strimzi.systemtest.resources.KubernetesResource;\n+import io.strimzi.systemtest.resources.ResourceManager;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.utils.TestKafkaVersion;\n+import io.strimzi.systemtest.utils.kubeUtils.controllers.StatefulSetUtils;\n+import io.strimzi.systemtest.utils.kubeUtils.objects.PodUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.systemtest.Constants.UPGRADE;\n+import static io.strimzi.test.k8s.KubeClusterResource.cmdKubeClient;\n+import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+@Tag(UPGRADE)\n+public class ZookeeperUpgradeST extends BaseST {\n+\n+    private static final Logger LOGGER = LogManager.getLogger(ZookeeperUpgradeST.class);\n+\n+    public static final String NAMESPACE = \"zookeeper-upgrade-test\";\n+\n+    @Test\n+    void testKafkaClusterUpgrade() throws IOException, InterruptedException {\n+        List<TestKafkaVersion> sortedVersions = TestKafkaVersion.parseKafkaVersions();\n+\n+        TestKafkaVersion initialVersion = sortedVersions.get(sortedVersions.size() - 2);\n+        TestKafkaVersion newVersion = sortedVersions.get(sortedVersions.size() - 1);\n+\n+        runVersionChange(initialVersion, newVersion, 3, 3);\n+    }\n+\n+    @Test\n+    void testKafkaClusterDowngrade() throws IOException, InterruptedException {\n+        List<TestKafkaVersion> sortedVersions = TestKafkaVersion.parseKafkaVersions();\n+\n+        TestKafkaVersion initialVersion = sortedVersions.get(sortedVersions.size() - 1);\n+        TestKafkaVersion newVersion = sortedVersions.get(sortedVersions.size() - 2);\n+\n+        runVersionChange(initialVersion, newVersion, 3, 3);\n+    }\n+\n+    void runVersionChange(TestKafkaVersion initialVersion, TestKafkaVersion newVersion, int kafkaReplicas, int zkReplicas) throws InterruptedException {\n+        String logMsgFormat;\n+        if (initialVersion.compareTo(newVersion) < 0) {\n+            // If it is an upgrade test we keep the message format as the lower version number\n+            logMsgFormat = initialVersion.messageVersion();\n+        } else {\n+            // If it is a downgrade then we make sure to use the lower version number for the message format\n+            logMsgFormat = newVersion.messageVersion();\n+        }\n+\n+        LOGGER.info(\"Deploying initial Kafka version (\" + initialVersion.version() + \")\");\n+\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, kafkaReplicas, zkReplicas)\n+                .editSpec()\n+                    .editKafka()\n+                        .withVersion(initialVersion.version())\n+                        .addToConfig(\"log.message.format.version\", logMsgFormat)\n+                    .endKafka()\n+                .endSpec()\n+                .done();\n+\n+        LOGGER.info(\"Deployment of initial Kafka version (\" + initialVersion.version() + \") complete\");\n+\n+        String zkVersionCommand = \"ls libs | grep -Po 'zookeeper-\\\\K\\\\d+.\\\\d+.\\\\d+' | head -1\";\n+        String zkResult = cmdKubeClient().execInPodContainer(KafkaResources.zookeeperPodName(CLUSTER_NAME, 0),\n+                \"zookeeper\", \"/bin/bash\", \"-c\", zkVersionCommand).out().trim();\n+        LOGGER.info(\"Pre-change Zookeeper version query returned: \" + zkResult);\n+\n+        String kafkaVersionCommand = \"ls libs | grep -Po 'kafka_\\\\d+.\\\\d+-\\\\K(\\\\d+.\\\\d+.\\\\d+)(?=.jar)' | head -1\";\n+        String kafkaResult = cmdKubeClient().execInPodContainer(KafkaResources.kafkaPodName(CLUSTER_NAME, 0),\n+                \"kafka\", \"/bin/bash\", \"-c\", kafkaVersionCommand).out().trim();\n+        LOGGER.info(\"Pre-change Kafka version query returned: \" + kafkaResult);\n+\n+        Map<String, String> zkPods = StatefulSetUtils.ssSnapshot(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME));\n+        Map<String, String> kafkaPods = StatefulSetUtils.ssSnapshot(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME));\n+\n+        LOGGER.info(\"Updating Kafka CR version field to \" + newVersion.version());\n+\n+        // Get the Kafka resource from K8s\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setVersion(newVersion.version());\n+        });\n+\n+        Kafka retrievedKafka = Crds.kafkaOperation(kubeClient(NAMESPACE).getClient())\n+                .inNamespace(NAMESPACE)\n+                .withName(CLUSTER_NAME)\n+                .get();\n+\n+        // Change the Kafka version for the resource\n+        retrievedKafka.getSpec().getKafka().setVersion(newVersion.version());\n+\n+        // Patch the existing resource with this new version\n+        Crds.kafkaOperation(kubeClient().getClient()).inNamespace(NAMESPACE).withName(CLUSTER_NAME).patch(retrievedKafka);\n+\n+        LOGGER.info(\"Waiting for deployment of new Kafka version (\" + newVersion.version() + \") to complete\");\n+\n+        // Wait for the zk version change roll\n+        zkPods = StatefulSetUtils.waitTillSsHasRolled(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME), zkReplicas, zkPods);\n+        LOGGER.info(\"1st Zookeeper roll (image change) is complete\");\n+\n+        // Wait for the kafka broker version change roll\n+        kafkaPods = StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), kafkaReplicas, kafkaPods);\n+        LOGGER.info(\"Kafka roll (image change) is complete\");\n+\n+        PodUtils.waitUntilPodReplicasCount(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), 2);\n+\n+        // Wait for the zk rolling update\n+        StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), kafkaReplicas, kafkaPods);\n+        LOGGER.info(\"2nd Kafka roll (update) is complete\");\n+\n+        PodUtils.waitUntilPodReplicasCount(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), 2);\n+\n+        StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), kafkaReplicas, zkPods);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39032bfa459f051bf72900e147996faef3d290f9"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkyNDkyMQ==", "bodyText": "This does seem confusing. When I designed the original ST the sequence was ZK Roll -> Kafka Roll -> ZK Roll then the update was complete. This seems to be ZK Roll -> Kafka Roll -> ZK Roll -> Kafka Roll -> Kafka Roll? Was the a change introduced by some new Kafka Rolling code? Or are there setup changes that require more rolls?", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2397#discussion_r368924921", "createdAt": "2020-01-21T10:37:40Z", "author": {"login": "tomncooper"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/upgrade/ZookeeperUpgradeST.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.upgrade;\n+\n+import io.strimzi.api.kafka.Crds;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.systemtest.BaseST;\n+import io.strimzi.systemtest.resources.KubernetesResource;\n+import io.strimzi.systemtest.resources.ResourceManager;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.utils.TestKafkaVersion;\n+import io.strimzi.systemtest.utils.kubeUtils.controllers.StatefulSetUtils;\n+import io.strimzi.systemtest.utils.kubeUtils.objects.PodUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.systemtest.Constants.UPGRADE;\n+import static io.strimzi.test.k8s.KubeClusterResource.cmdKubeClient;\n+import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+@Tag(UPGRADE)\n+public class ZookeeperUpgradeST extends BaseST {\n+\n+    private static final Logger LOGGER = LogManager.getLogger(ZookeeperUpgradeST.class);\n+\n+    public static final String NAMESPACE = \"zookeeper-upgrade-test\";\n+\n+    @Test\n+    void testKafkaClusterUpgrade() throws IOException, InterruptedException {\n+        List<TestKafkaVersion> sortedVersions = TestKafkaVersion.parseKafkaVersions();\n+\n+        TestKafkaVersion initialVersion = sortedVersions.get(sortedVersions.size() - 2);\n+        TestKafkaVersion newVersion = sortedVersions.get(sortedVersions.size() - 1);\n+\n+        runVersionChange(initialVersion, newVersion, 3, 3);\n+    }\n+\n+    @Test\n+    void testKafkaClusterDowngrade() throws IOException, InterruptedException {\n+        List<TestKafkaVersion> sortedVersions = TestKafkaVersion.parseKafkaVersions();\n+\n+        TestKafkaVersion initialVersion = sortedVersions.get(sortedVersions.size() - 1);\n+        TestKafkaVersion newVersion = sortedVersions.get(sortedVersions.size() - 2);\n+\n+        runVersionChange(initialVersion, newVersion, 3, 3);\n+    }\n+\n+    void runVersionChange(TestKafkaVersion initialVersion, TestKafkaVersion newVersion, int kafkaReplicas, int zkReplicas) throws InterruptedException {\n+        String logMsgFormat;\n+        if (initialVersion.compareTo(newVersion) < 0) {\n+            // If it is an upgrade test we keep the message format as the lower version number\n+            logMsgFormat = initialVersion.messageVersion();\n+        } else {\n+            // If it is a downgrade then we make sure to use the lower version number for the message format\n+            logMsgFormat = newVersion.messageVersion();\n+        }\n+\n+        LOGGER.info(\"Deploying initial Kafka version (\" + initialVersion.version() + \")\");\n+\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, kafkaReplicas, zkReplicas)\n+                .editSpec()\n+                    .editKafka()\n+                        .withVersion(initialVersion.version())\n+                        .addToConfig(\"log.message.format.version\", logMsgFormat)\n+                    .endKafka()\n+                .endSpec()\n+                .done();\n+\n+        LOGGER.info(\"Deployment of initial Kafka version (\" + initialVersion.version() + \") complete\");\n+\n+        String zkVersionCommand = \"ls libs | grep -Po 'zookeeper-\\\\K\\\\d+.\\\\d+.\\\\d+' | head -1\";\n+        String zkResult = cmdKubeClient().execInPodContainer(KafkaResources.zookeeperPodName(CLUSTER_NAME, 0),\n+                \"zookeeper\", \"/bin/bash\", \"-c\", zkVersionCommand).out().trim();\n+        LOGGER.info(\"Pre-change Zookeeper version query returned: \" + zkResult);\n+\n+        String kafkaVersionCommand = \"ls libs | grep -Po 'kafka_\\\\d+.\\\\d+-\\\\K(\\\\d+.\\\\d+.\\\\d+)(?=.jar)' | head -1\";\n+        String kafkaResult = cmdKubeClient().execInPodContainer(KafkaResources.kafkaPodName(CLUSTER_NAME, 0),\n+                \"kafka\", \"/bin/bash\", \"-c\", kafkaVersionCommand).out().trim();\n+        LOGGER.info(\"Pre-change Kafka version query returned: \" + kafkaResult);\n+\n+        Map<String, String> zkPods = StatefulSetUtils.ssSnapshot(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME));\n+        Map<String, String> kafkaPods = StatefulSetUtils.ssSnapshot(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME));\n+\n+        LOGGER.info(\"Updating Kafka CR version field to \" + newVersion.version());\n+\n+        // Get the Kafka resource from K8s\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setVersion(newVersion.version());\n+        });\n+\n+        Kafka retrievedKafka = Crds.kafkaOperation(kubeClient(NAMESPACE).getClient())\n+                .inNamespace(NAMESPACE)\n+                .withName(CLUSTER_NAME)\n+                .get();\n+\n+        // Change the Kafka version for the resource\n+        retrievedKafka.getSpec().getKafka().setVersion(newVersion.version());\n+\n+        // Patch the existing resource with this new version\n+        Crds.kafkaOperation(kubeClient().getClient()).inNamespace(NAMESPACE).withName(CLUSTER_NAME).patch(retrievedKafka);\n+\n+        LOGGER.info(\"Waiting for deployment of new Kafka version (\" + newVersion.version() + \") to complete\");\n+\n+        // Wait for the zk version change roll\n+        zkPods = StatefulSetUtils.waitTillSsHasRolled(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME), zkReplicas, zkPods);\n+        LOGGER.info(\"1st Zookeeper roll (image change) is complete\");\n+\n+        // Wait for the kafka broker version change roll\n+        kafkaPods = StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), kafkaReplicas, kafkaPods);\n+        LOGGER.info(\"Kafka roll (image change) is complete\");\n+\n+        PodUtils.waitUntilPodReplicasCount(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), 2);\n+\n+        // Wait for the zk rolling update\n+        StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), kafkaReplicas, kafkaPods);\n+        LOGGER.info(\"2nd Kafka roll (update) is complete\");\n+\n+        PodUtils.waitUntilPodReplicasCount(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), 2);\n+\n+        StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), kafkaReplicas, zkPods);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4ODM2MA=="}, "originalCommit": {"oid": "39032bfa459f051bf72900e147996faef3d290f9"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkzNDQ1MQ==", "bodyText": "I think that between two minor versions there were always 2 Kafka rolling updates. The third one is related to the configuration from file and how is Fabric 8 / Kubernetes seemingly randomly changing the different HereDoc styles in tha patched YAML.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2397#discussion_r368934451", "createdAt": "2020-01-21T10:57:18Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/upgrade/ZookeeperUpgradeST.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.upgrade;\n+\n+import io.strimzi.api.kafka.Crds;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.systemtest.BaseST;\n+import io.strimzi.systemtest.resources.KubernetesResource;\n+import io.strimzi.systemtest.resources.ResourceManager;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.utils.TestKafkaVersion;\n+import io.strimzi.systemtest.utils.kubeUtils.controllers.StatefulSetUtils;\n+import io.strimzi.systemtest.utils.kubeUtils.objects.PodUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.systemtest.Constants.UPGRADE;\n+import static io.strimzi.test.k8s.KubeClusterResource.cmdKubeClient;\n+import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+@Tag(UPGRADE)\n+public class ZookeeperUpgradeST extends BaseST {\n+\n+    private static final Logger LOGGER = LogManager.getLogger(ZookeeperUpgradeST.class);\n+\n+    public static final String NAMESPACE = \"zookeeper-upgrade-test\";\n+\n+    @Test\n+    void testKafkaClusterUpgrade() throws IOException, InterruptedException {\n+        List<TestKafkaVersion> sortedVersions = TestKafkaVersion.parseKafkaVersions();\n+\n+        TestKafkaVersion initialVersion = sortedVersions.get(sortedVersions.size() - 2);\n+        TestKafkaVersion newVersion = sortedVersions.get(sortedVersions.size() - 1);\n+\n+        runVersionChange(initialVersion, newVersion, 3, 3);\n+    }\n+\n+    @Test\n+    void testKafkaClusterDowngrade() throws IOException, InterruptedException {\n+        List<TestKafkaVersion> sortedVersions = TestKafkaVersion.parseKafkaVersions();\n+\n+        TestKafkaVersion initialVersion = sortedVersions.get(sortedVersions.size() - 1);\n+        TestKafkaVersion newVersion = sortedVersions.get(sortedVersions.size() - 2);\n+\n+        runVersionChange(initialVersion, newVersion, 3, 3);\n+    }\n+\n+    void runVersionChange(TestKafkaVersion initialVersion, TestKafkaVersion newVersion, int kafkaReplicas, int zkReplicas) throws InterruptedException {\n+        String logMsgFormat;\n+        if (initialVersion.compareTo(newVersion) < 0) {\n+            // If it is an upgrade test we keep the message format as the lower version number\n+            logMsgFormat = initialVersion.messageVersion();\n+        } else {\n+            // If it is a downgrade then we make sure to use the lower version number for the message format\n+            logMsgFormat = newVersion.messageVersion();\n+        }\n+\n+        LOGGER.info(\"Deploying initial Kafka version (\" + initialVersion.version() + \")\");\n+\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, kafkaReplicas, zkReplicas)\n+                .editSpec()\n+                    .editKafka()\n+                        .withVersion(initialVersion.version())\n+                        .addToConfig(\"log.message.format.version\", logMsgFormat)\n+                    .endKafka()\n+                .endSpec()\n+                .done();\n+\n+        LOGGER.info(\"Deployment of initial Kafka version (\" + initialVersion.version() + \") complete\");\n+\n+        String zkVersionCommand = \"ls libs | grep -Po 'zookeeper-\\\\K\\\\d+.\\\\d+.\\\\d+' | head -1\";\n+        String zkResult = cmdKubeClient().execInPodContainer(KafkaResources.zookeeperPodName(CLUSTER_NAME, 0),\n+                \"zookeeper\", \"/bin/bash\", \"-c\", zkVersionCommand).out().trim();\n+        LOGGER.info(\"Pre-change Zookeeper version query returned: \" + zkResult);\n+\n+        String kafkaVersionCommand = \"ls libs | grep -Po 'kafka_\\\\d+.\\\\d+-\\\\K(\\\\d+.\\\\d+.\\\\d+)(?=.jar)' | head -1\";\n+        String kafkaResult = cmdKubeClient().execInPodContainer(KafkaResources.kafkaPodName(CLUSTER_NAME, 0),\n+                \"kafka\", \"/bin/bash\", \"-c\", kafkaVersionCommand).out().trim();\n+        LOGGER.info(\"Pre-change Kafka version query returned: \" + kafkaResult);\n+\n+        Map<String, String> zkPods = StatefulSetUtils.ssSnapshot(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME));\n+        Map<String, String> kafkaPods = StatefulSetUtils.ssSnapshot(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME));\n+\n+        LOGGER.info(\"Updating Kafka CR version field to \" + newVersion.version());\n+\n+        // Get the Kafka resource from K8s\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setVersion(newVersion.version());\n+        });\n+\n+        Kafka retrievedKafka = Crds.kafkaOperation(kubeClient(NAMESPACE).getClient())\n+                .inNamespace(NAMESPACE)\n+                .withName(CLUSTER_NAME)\n+                .get();\n+\n+        // Change the Kafka version for the resource\n+        retrievedKafka.getSpec().getKafka().setVersion(newVersion.version());\n+\n+        // Patch the existing resource with this new version\n+        Crds.kafkaOperation(kubeClient().getClient()).inNamespace(NAMESPACE).withName(CLUSTER_NAME).patch(retrievedKafka);\n+\n+        LOGGER.info(\"Waiting for deployment of new Kafka version (\" + newVersion.version() + \") to complete\");\n+\n+        // Wait for the zk version change roll\n+        zkPods = StatefulSetUtils.waitTillSsHasRolled(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME), zkReplicas, zkPods);\n+        LOGGER.info(\"1st Zookeeper roll (image change) is complete\");\n+\n+        // Wait for the kafka broker version change roll\n+        kafkaPods = StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), kafkaReplicas, kafkaPods);\n+        LOGGER.info(\"Kafka roll (image change) is complete\");\n+\n+        PodUtils.waitUntilPodReplicasCount(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), 2);\n+\n+        // Wait for the zk rolling update\n+        StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), kafkaReplicas, kafkaPods);\n+        LOGGER.info(\"2nd Kafka roll (update) is complete\");\n+\n+        PodUtils.waitUntilPodReplicasCount(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), 2);\n+\n+        StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), kafkaReplicas, zkPods);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4ODM2MA=="}, "originalCommit": {"oid": "39032bfa459f051bf72900e147996faef3d290f9"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkzNDc1Mw==", "bodyText": "(The third should be solved with the dynamic reconfiguration)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2397#discussion_r368934753", "createdAt": "2020-01-21T10:57:56Z", "author": {"login": "scholzj"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/upgrade/ZookeeperUpgradeST.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.upgrade;\n+\n+import io.strimzi.api.kafka.Crds;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.systemtest.BaseST;\n+import io.strimzi.systemtest.resources.KubernetesResource;\n+import io.strimzi.systemtest.resources.ResourceManager;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.utils.TestKafkaVersion;\n+import io.strimzi.systemtest.utils.kubeUtils.controllers.StatefulSetUtils;\n+import io.strimzi.systemtest.utils.kubeUtils.objects.PodUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.systemtest.Constants.UPGRADE;\n+import static io.strimzi.test.k8s.KubeClusterResource.cmdKubeClient;\n+import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+@Tag(UPGRADE)\n+public class ZookeeperUpgradeST extends BaseST {\n+\n+    private static final Logger LOGGER = LogManager.getLogger(ZookeeperUpgradeST.class);\n+\n+    public static final String NAMESPACE = \"zookeeper-upgrade-test\";\n+\n+    @Test\n+    void testKafkaClusterUpgrade() throws IOException, InterruptedException {\n+        List<TestKafkaVersion> sortedVersions = TestKafkaVersion.parseKafkaVersions();\n+\n+        TestKafkaVersion initialVersion = sortedVersions.get(sortedVersions.size() - 2);\n+        TestKafkaVersion newVersion = sortedVersions.get(sortedVersions.size() - 1);\n+\n+        runVersionChange(initialVersion, newVersion, 3, 3);\n+    }\n+\n+    @Test\n+    void testKafkaClusterDowngrade() throws IOException, InterruptedException {\n+        List<TestKafkaVersion> sortedVersions = TestKafkaVersion.parseKafkaVersions();\n+\n+        TestKafkaVersion initialVersion = sortedVersions.get(sortedVersions.size() - 1);\n+        TestKafkaVersion newVersion = sortedVersions.get(sortedVersions.size() - 2);\n+\n+        runVersionChange(initialVersion, newVersion, 3, 3);\n+    }\n+\n+    void runVersionChange(TestKafkaVersion initialVersion, TestKafkaVersion newVersion, int kafkaReplicas, int zkReplicas) throws InterruptedException {\n+        String logMsgFormat;\n+        if (initialVersion.compareTo(newVersion) < 0) {\n+            // If it is an upgrade test we keep the message format as the lower version number\n+            logMsgFormat = initialVersion.messageVersion();\n+        } else {\n+            // If it is a downgrade then we make sure to use the lower version number for the message format\n+            logMsgFormat = newVersion.messageVersion();\n+        }\n+\n+        LOGGER.info(\"Deploying initial Kafka version (\" + initialVersion.version() + \")\");\n+\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, kafkaReplicas, zkReplicas)\n+                .editSpec()\n+                    .editKafka()\n+                        .withVersion(initialVersion.version())\n+                        .addToConfig(\"log.message.format.version\", logMsgFormat)\n+                    .endKafka()\n+                .endSpec()\n+                .done();\n+\n+        LOGGER.info(\"Deployment of initial Kafka version (\" + initialVersion.version() + \") complete\");\n+\n+        String zkVersionCommand = \"ls libs | grep -Po 'zookeeper-\\\\K\\\\d+.\\\\d+.\\\\d+' | head -1\";\n+        String zkResult = cmdKubeClient().execInPodContainer(KafkaResources.zookeeperPodName(CLUSTER_NAME, 0),\n+                \"zookeeper\", \"/bin/bash\", \"-c\", zkVersionCommand).out().trim();\n+        LOGGER.info(\"Pre-change Zookeeper version query returned: \" + zkResult);\n+\n+        String kafkaVersionCommand = \"ls libs | grep -Po 'kafka_\\\\d+.\\\\d+-\\\\K(\\\\d+.\\\\d+.\\\\d+)(?=.jar)' | head -1\";\n+        String kafkaResult = cmdKubeClient().execInPodContainer(KafkaResources.kafkaPodName(CLUSTER_NAME, 0),\n+                \"kafka\", \"/bin/bash\", \"-c\", kafkaVersionCommand).out().trim();\n+        LOGGER.info(\"Pre-change Kafka version query returned: \" + kafkaResult);\n+\n+        Map<String, String> zkPods = StatefulSetUtils.ssSnapshot(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME));\n+        Map<String, String> kafkaPods = StatefulSetUtils.ssSnapshot(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME));\n+\n+        LOGGER.info(\"Updating Kafka CR version field to \" + newVersion.version());\n+\n+        // Get the Kafka resource from K8s\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setVersion(newVersion.version());\n+        });\n+\n+        Kafka retrievedKafka = Crds.kafkaOperation(kubeClient(NAMESPACE).getClient())\n+                .inNamespace(NAMESPACE)\n+                .withName(CLUSTER_NAME)\n+                .get();\n+\n+        // Change the Kafka version for the resource\n+        retrievedKafka.getSpec().getKafka().setVersion(newVersion.version());\n+\n+        // Patch the existing resource with this new version\n+        Crds.kafkaOperation(kubeClient().getClient()).inNamespace(NAMESPACE).withName(CLUSTER_NAME).patch(retrievedKafka);\n+\n+        LOGGER.info(\"Waiting for deployment of new Kafka version (\" + newVersion.version() + \") to complete\");\n+\n+        // Wait for the zk version change roll\n+        zkPods = StatefulSetUtils.waitTillSsHasRolled(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME), zkReplicas, zkPods);\n+        LOGGER.info(\"1st Zookeeper roll (image change) is complete\");\n+\n+        // Wait for the kafka broker version change roll\n+        kafkaPods = StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), kafkaReplicas, kafkaPods);\n+        LOGGER.info(\"Kafka roll (image change) is complete\");\n+\n+        PodUtils.waitUntilPodReplicasCount(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), 2);\n+\n+        // Wait for the zk rolling update\n+        StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), kafkaReplicas, kafkaPods);\n+        LOGGER.info(\"2nd Kafka roll (update) is complete\");\n+\n+        PodUtils.waitUntilPodReplicasCount(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), 2);\n+\n+        StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), kafkaReplicas, zkPods);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4ODM2MA=="}, "originalCommit": {"oid": "39032bfa459f051bf72900e147996faef3d290f9"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAyNTAwMw==", "bodyText": "I have tested it many times.\n1) Upgrade has following approach - Z roll, K roll, Z roll\n2) Downgrade has - Z roll, K roll, K roll, K roll, K roll\n\nEverything passing. Executed few times.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2397#discussion_r370025003", "createdAt": "2020-01-23T09:59:57Z", "author": {"login": "see-quick"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/upgrade/ZookeeperUpgradeST.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.upgrade;\n+\n+import io.strimzi.api.kafka.Crds;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.systemtest.BaseST;\n+import io.strimzi.systemtest.resources.KubernetesResource;\n+import io.strimzi.systemtest.resources.ResourceManager;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.utils.TestKafkaVersion;\n+import io.strimzi.systemtest.utils.kubeUtils.controllers.StatefulSetUtils;\n+import io.strimzi.systemtest.utils.kubeUtils.objects.PodUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.systemtest.Constants.UPGRADE;\n+import static io.strimzi.test.k8s.KubeClusterResource.cmdKubeClient;\n+import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+@Tag(UPGRADE)\n+public class ZookeeperUpgradeST extends BaseST {\n+\n+    private static final Logger LOGGER = LogManager.getLogger(ZookeeperUpgradeST.class);\n+\n+    public static final String NAMESPACE = \"zookeeper-upgrade-test\";\n+\n+    @Test\n+    void testKafkaClusterUpgrade() throws IOException, InterruptedException {\n+        List<TestKafkaVersion> sortedVersions = TestKafkaVersion.parseKafkaVersions();\n+\n+        TestKafkaVersion initialVersion = sortedVersions.get(sortedVersions.size() - 2);\n+        TestKafkaVersion newVersion = sortedVersions.get(sortedVersions.size() - 1);\n+\n+        runVersionChange(initialVersion, newVersion, 3, 3);\n+    }\n+\n+    @Test\n+    void testKafkaClusterDowngrade() throws IOException, InterruptedException {\n+        List<TestKafkaVersion> sortedVersions = TestKafkaVersion.parseKafkaVersions();\n+\n+        TestKafkaVersion initialVersion = sortedVersions.get(sortedVersions.size() - 1);\n+        TestKafkaVersion newVersion = sortedVersions.get(sortedVersions.size() - 2);\n+\n+        runVersionChange(initialVersion, newVersion, 3, 3);\n+    }\n+\n+    void runVersionChange(TestKafkaVersion initialVersion, TestKafkaVersion newVersion, int kafkaReplicas, int zkReplicas) throws InterruptedException {\n+        String logMsgFormat;\n+        if (initialVersion.compareTo(newVersion) < 0) {\n+            // If it is an upgrade test we keep the message format as the lower version number\n+            logMsgFormat = initialVersion.messageVersion();\n+        } else {\n+            // If it is a downgrade then we make sure to use the lower version number for the message format\n+            logMsgFormat = newVersion.messageVersion();\n+        }\n+\n+        LOGGER.info(\"Deploying initial Kafka version (\" + initialVersion.version() + \")\");\n+\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, kafkaReplicas, zkReplicas)\n+                .editSpec()\n+                    .editKafka()\n+                        .withVersion(initialVersion.version())\n+                        .addToConfig(\"log.message.format.version\", logMsgFormat)\n+                    .endKafka()\n+                .endSpec()\n+                .done();\n+\n+        LOGGER.info(\"Deployment of initial Kafka version (\" + initialVersion.version() + \") complete\");\n+\n+        String zkVersionCommand = \"ls libs | grep -Po 'zookeeper-\\\\K\\\\d+.\\\\d+.\\\\d+' | head -1\";\n+        String zkResult = cmdKubeClient().execInPodContainer(KafkaResources.zookeeperPodName(CLUSTER_NAME, 0),\n+                \"zookeeper\", \"/bin/bash\", \"-c\", zkVersionCommand).out().trim();\n+        LOGGER.info(\"Pre-change Zookeeper version query returned: \" + zkResult);\n+\n+        String kafkaVersionCommand = \"ls libs | grep -Po 'kafka_\\\\d+.\\\\d+-\\\\K(\\\\d+.\\\\d+.\\\\d+)(?=.jar)' | head -1\";\n+        String kafkaResult = cmdKubeClient().execInPodContainer(KafkaResources.kafkaPodName(CLUSTER_NAME, 0),\n+                \"kafka\", \"/bin/bash\", \"-c\", kafkaVersionCommand).out().trim();\n+        LOGGER.info(\"Pre-change Kafka version query returned: \" + kafkaResult);\n+\n+        Map<String, String> zkPods = StatefulSetUtils.ssSnapshot(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME));\n+        Map<String, String> kafkaPods = StatefulSetUtils.ssSnapshot(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME));\n+\n+        LOGGER.info(\"Updating Kafka CR version field to \" + newVersion.version());\n+\n+        // Get the Kafka resource from K8s\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setVersion(newVersion.version());\n+        });\n+\n+        Kafka retrievedKafka = Crds.kafkaOperation(kubeClient(NAMESPACE).getClient())\n+                .inNamespace(NAMESPACE)\n+                .withName(CLUSTER_NAME)\n+                .get();\n+\n+        // Change the Kafka version for the resource\n+        retrievedKafka.getSpec().getKafka().setVersion(newVersion.version());\n+\n+        // Patch the existing resource with this new version\n+        Crds.kafkaOperation(kubeClient().getClient()).inNamespace(NAMESPACE).withName(CLUSTER_NAME).patch(retrievedKafka);\n+\n+        LOGGER.info(\"Waiting for deployment of new Kafka version (\" + newVersion.version() + \") to complete\");\n+\n+        // Wait for the zk version change roll\n+        zkPods = StatefulSetUtils.waitTillSsHasRolled(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME), zkReplicas, zkPods);\n+        LOGGER.info(\"1st Zookeeper roll (image change) is complete\");\n+\n+        // Wait for the kafka broker version change roll\n+        kafkaPods = StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), kafkaReplicas, kafkaPods);\n+        LOGGER.info(\"Kafka roll (image change) is complete\");\n+\n+        PodUtils.waitUntilPodReplicasCount(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), 2);\n+\n+        // Wait for the zk rolling update\n+        StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), kafkaReplicas, kafkaPods);\n+        LOGGER.info(\"2nd Kafka roll (update) is complete\");\n+\n+        PodUtils.waitUntilPodReplicasCount(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), 2);\n+\n+        StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), kafkaReplicas, zkPods);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4ODM2MA=="}, "originalCommit": {"oid": "39032bfa459f051bf72900e147996faef3d290f9"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NzIyNTMyOnYy", "diffSide": "RIGHT", "path": "systemtest/src/test/java/io/strimzi/systemtest/upgrade/ZookeeperUpgradeST.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMDo0NzozNFrOFg58cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMjoxNDo0NVrOFg8HJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0ODExMg==", "bodyText": "You could also just compare the intial and new Kafka versions: if (initialVersion.compareTo(newVersion) > 0)", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2397#discussion_r370048112", "createdAt": "2020-01-23T10:47:34Z", "author": {"login": "tomncooper"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/upgrade/ZookeeperUpgradeST.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.upgrade;\n+\n+import io.strimzi.api.kafka.Crds;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.systemtest.BaseST;\n+import io.strimzi.systemtest.resources.KubernetesResource;\n+import io.strimzi.systemtest.resources.ResourceManager;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.utils.StUtils;\n+import io.strimzi.systemtest.utils.TestKafkaVersion;\n+import io.strimzi.systemtest.utils.kubeUtils.controllers.StatefulSetUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.systemtest.Constants.UPGRADE;\n+import static io.strimzi.test.k8s.KubeClusterResource.cmdKubeClient;\n+import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+@Tag(UPGRADE)\n+public class ZookeeperUpgradeST extends BaseST {\n+\n+    private static final Logger LOGGER = LogManager.getLogger(ZookeeperUpgradeST.class);\n+\n+    public static final String NAMESPACE = \"zookeeper-upgrade-test\";\n+\n+    @Test\n+    void testKafkaClusterUpgrade(TestInfo testinfo) throws IOException, InterruptedException {\n+        List<TestKafkaVersion> sortedVersions = TestKafkaVersion.parseKafkaVersions();\n+\n+        TestKafkaVersion initialVersion = sortedVersions.get(sortedVersions.size() - 2);\n+        TestKafkaVersion newVersion = sortedVersions.get(sortedVersions.size() - 1);\n+\n+        runVersionChange(initialVersion, newVersion, 3, 3, testinfo);\n+    }\n+\n+    @Test\n+    void testKafkaClusterDowngrade(TestInfo testInfo) throws IOException, InterruptedException {\n+        List<TestKafkaVersion> sortedVersions = TestKafkaVersion.parseKafkaVersions();\n+\n+        TestKafkaVersion initialVersion = sortedVersions.get(sortedVersions.size() - 1);\n+        TestKafkaVersion newVersion = sortedVersions.get(sortedVersions.size() - 2);\n+\n+        runVersionChange(initialVersion, newVersion, 3, 3, testInfo);\n+    }\n+\n+    void runVersionChange(TestKafkaVersion initialVersion, TestKafkaVersion newVersion, int kafkaReplicas, int zkReplicas, TestInfo testInfo) throws InterruptedException {\n+        String logMsgFormat;\n+        if (initialVersion.compareTo(newVersion) < 0) {\n+            // If it is an upgrade test we keep the message format as the lower version number\n+            logMsgFormat = initialVersion.messageVersion();\n+        } else {\n+            // If it is a downgrade then we make sure to use the lower version number for the message format\n+            logMsgFormat = newVersion.messageVersion();\n+        }\n+\n+        LOGGER.info(\"Deploying initial Kafka version (\" + initialVersion.version() + \")\");\n+\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, kafkaReplicas, zkReplicas)\n+                .editSpec()\n+                    .editKafka()\n+                        .withVersion(initialVersion.version())\n+                        .addToConfig(\"log.message.format.version\", logMsgFormat)\n+                    .endKafka()\n+                .endSpec()\n+                .done();\n+\n+        LOGGER.info(\"Deployment of initial Kafka version (\" + initialVersion.version() + \") complete\");\n+\n+        String zkVersionCommand = \"ls libs | grep -Po 'zookeeper-\\\\K\\\\d+.\\\\d+.\\\\d+' | head -1\";\n+        String zkResult = cmdKubeClient().execInPodContainer(KafkaResources.zookeeperPodName(CLUSTER_NAME, 0),\n+                \"zookeeper\", \"/bin/bash\", \"-c\", zkVersionCommand).out().trim();\n+        LOGGER.info(\"Pre-change Zookeeper version query returned: \" + zkResult);\n+\n+        String kafkaVersionCommand = \"ls libs | grep -Po 'kafka_\\\\d+.\\\\d+-\\\\K(\\\\d+.\\\\d+.\\\\d+)(?=.jar)' | head -1\";\n+        String kafkaResult = cmdKubeClient().execInPodContainer(KafkaResources.kafkaPodName(CLUSTER_NAME, 0),\n+                \"kafka\", \"/bin/bash\", \"-c\", kafkaVersionCommand).out().trim();\n+        LOGGER.info(\"Pre-change Kafka version query returned: \" + kafkaResult);\n+\n+        Map<String, String> zkPods = StatefulSetUtils.ssSnapshot(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME));\n+        Map<String, String> kafkaPods = StatefulSetUtils.ssSnapshot(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME));\n+\n+        LOGGER.info(\"Updating Kafka CR version field to \" + newVersion.version());\n+\n+        // Get the Kafka resource from K8s\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setVersion(newVersion.version());\n+        });\n+\n+        Kafka retrievedKafka = Crds.kafkaOperation(kubeClient(NAMESPACE).getClient())\n+                .inNamespace(NAMESPACE)\n+                .withName(CLUSTER_NAME)\n+                .get();\n+\n+        // Change the Kafka version for the resource\n+        retrievedKafka.getSpec().getKafka().setVersion(newVersion.version());\n+\n+        // Patch the existing resource with this new version\n+        Crds.kafkaOperation(kubeClient().getClient()).inNamespace(NAMESPACE).withName(CLUSTER_NAME).patch(retrievedKafka);\n+\n+        LOGGER.info(\"Waiting for deployment of new Kafka version (\" + newVersion.version() + \") to complete\");\n+\n+        // Wait for the zk version change roll\n+        zkPods = StatefulSetUtils.waitTillSsHasRolled(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME), zkReplicas, zkPods);\n+        LOGGER.info(\"1st Zookeeper roll (image change) is complete\");\n+\n+        // Wait for the kafka broker version change roll\n+        kafkaPods = StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), kafkaReplicas, kafkaPods);\n+        LOGGER.info(\"Kafka roll (image change) is complete\");\n+\n+        if (testInfo.getDisplayName().contains(\"Downgrade\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845aab5b2b72364dcb4fdd4fd2e6451d17783a0d"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA4MzYyMw==", "bodyText": "Thanks. This Downgrade and Upgrade is maybe little bit more straight looking.", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2397#discussion_r370083623", "createdAt": "2020-01-23T12:14:45Z", "author": {"login": "see-quick"}, "path": "systemtest/src/test/java/io/strimzi/systemtest/upgrade/ZookeeperUpgradeST.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.systemtest.upgrade;\n+\n+import io.strimzi.api.kafka.Crds;\n+import io.strimzi.api.kafka.model.Kafka;\n+import io.strimzi.api.kafka.model.KafkaResources;\n+import io.strimzi.systemtest.BaseST;\n+import io.strimzi.systemtest.resources.KubernetesResource;\n+import io.strimzi.systemtest.resources.ResourceManager;\n+import io.strimzi.systemtest.resources.crd.KafkaResource;\n+import io.strimzi.systemtest.utils.StUtils;\n+import io.strimzi.systemtest.utils.TestKafkaVersion;\n+import io.strimzi.systemtest.utils.kubeUtils.controllers.StatefulSetUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.strimzi.systemtest.Constants.UPGRADE;\n+import static io.strimzi.test.k8s.KubeClusterResource.cmdKubeClient;\n+import static io.strimzi.test.k8s.KubeClusterResource.kubeClient;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+@Tag(UPGRADE)\n+public class ZookeeperUpgradeST extends BaseST {\n+\n+    private static final Logger LOGGER = LogManager.getLogger(ZookeeperUpgradeST.class);\n+\n+    public static final String NAMESPACE = \"zookeeper-upgrade-test\";\n+\n+    @Test\n+    void testKafkaClusterUpgrade(TestInfo testinfo) throws IOException, InterruptedException {\n+        List<TestKafkaVersion> sortedVersions = TestKafkaVersion.parseKafkaVersions();\n+\n+        TestKafkaVersion initialVersion = sortedVersions.get(sortedVersions.size() - 2);\n+        TestKafkaVersion newVersion = sortedVersions.get(sortedVersions.size() - 1);\n+\n+        runVersionChange(initialVersion, newVersion, 3, 3, testinfo);\n+    }\n+\n+    @Test\n+    void testKafkaClusterDowngrade(TestInfo testInfo) throws IOException, InterruptedException {\n+        List<TestKafkaVersion> sortedVersions = TestKafkaVersion.parseKafkaVersions();\n+\n+        TestKafkaVersion initialVersion = sortedVersions.get(sortedVersions.size() - 1);\n+        TestKafkaVersion newVersion = sortedVersions.get(sortedVersions.size() - 2);\n+\n+        runVersionChange(initialVersion, newVersion, 3, 3, testInfo);\n+    }\n+\n+    void runVersionChange(TestKafkaVersion initialVersion, TestKafkaVersion newVersion, int kafkaReplicas, int zkReplicas, TestInfo testInfo) throws InterruptedException {\n+        String logMsgFormat;\n+        if (initialVersion.compareTo(newVersion) < 0) {\n+            // If it is an upgrade test we keep the message format as the lower version number\n+            logMsgFormat = initialVersion.messageVersion();\n+        } else {\n+            // If it is a downgrade then we make sure to use the lower version number for the message format\n+            logMsgFormat = newVersion.messageVersion();\n+        }\n+\n+        LOGGER.info(\"Deploying initial Kafka version (\" + initialVersion.version() + \")\");\n+\n+        KafkaResource.kafkaPersistent(CLUSTER_NAME, kafkaReplicas, zkReplicas)\n+                .editSpec()\n+                    .editKafka()\n+                        .withVersion(initialVersion.version())\n+                        .addToConfig(\"log.message.format.version\", logMsgFormat)\n+                    .endKafka()\n+                .endSpec()\n+                .done();\n+\n+        LOGGER.info(\"Deployment of initial Kafka version (\" + initialVersion.version() + \") complete\");\n+\n+        String zkVersionCommand = \"ls libs | grep -Po 'zookeeper-\\\\K\\\\d+.\\\\d+.\\\\d+' | head -1\";\n+        String zkResult = cmdKubeClient().execInPodContainer(KafkaResources.zookeeperPodName(CLUSTER_NAME, 0),\n+                \"zookeeper\", \"/bin/bash\", \"-c\", zkVersionCommand).out().trim();\n+        LOGGER.info(\"Pre-change Zookeeper version query returned: \" + zkResult);\n+\n+        String kafkaVersionCommand = \"ls libs | grep -Po 'kafka_\\\\d+.\\\\d+-\\\\K(\\\\d+.\\\\d+.\\\\d+)(?=.jar)' | head -1\";\n+        String kafkaResult = cmdKubeClient().execInPodContainer(KafkaResources.kafkaPodName(CLUSTER_NAME, 0),\n+                \"kafka\", \"/bin/bash\", \"-c\", kafkaVersionCommand).out().trim();\n+        LOGGER.info(\"Pre-change Kafka version query returned: \" + kafkaResult);\n+\n+        Map<String, String> zkPods = StatefulSetUtils.ssSnapshot(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME));\n+        Map<String, String> kafkaPods = StatefulSetUtils.ssSnapshot(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME));\n+\n+        LOGGER.info(\"Updating Kafka CR version field to \" + newVersion.version());\n+\n+        // Get the Kafka resource from K8s\n+        KafkaResource.replaceKafkaResource(CLUSTER_NAME, kafka -> {\n+            kafka.getSpec().getKafka().setVersion(newVersion.version());\n+        });\n+\n+        Kafka retrievedKafka = Crds.kafkaOperation(kubeClient(NAMESPACE).getClient())\n+                .inNamespace(NAMESPACE)\n+                .withName(CLUSTER_NAME)\n+                .get();\n+\n+        // Change the Kafka version for the resource\n+        retrievedKafka.getSpec().getKafka().setVersion(newVersion.version());\n+\n+        // Patch the existing resource with this new version\n+        Crds.kafkaOperation(kubeClient().getClient()).inNamespace(NAMESPACE).withName(CLUSTER_NAME).patch(retrievedKafka);\n+\n+        LOGGER.info(\"Waiting for deployment of new Kafka version (\" + newVersion.version() + \") to complete\");\n+\n+        // Wait for the zk version change roll\n+        zkPods = StatefulSetUtils.waitTillSsHasRolled(KafkaResources.zookeeperStatefulSetName(CLUSTER_NAME), zkReplicas, zkPods);\n+        LOGGER.info(\"1st Zookeeper roll (image change) is complete\");\n+\n+        // Wait for the kafka broker version change roll\n+        kafkaPods = StatefulSetUtils.waitTillSsHasRolled(KafkaResources.kafkaStatefulSetName(CLUSTER_NAME), kafkaReplicas, kafkaPods);\n+        LOGGER.info(\"Kafka roll (image change) is complete\");\n+\n+        if (testInfo.getDisplayName().contains(\"Downgrade\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0ODExMg=="}, "originalCommit": {"oid": "845aab5b2b72364dcb4fdd4fd2e6451d17783a0d"}, "originalPosition": 125}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 601, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}