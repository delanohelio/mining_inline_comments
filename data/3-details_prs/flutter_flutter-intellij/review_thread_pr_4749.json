{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0NzE2MTMy", "number": 4749, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjo1Nzo0NVrOEWSX0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODowODoxOFrOEWTt7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxODA1MTM3OnYy", "diffSide": "RIGHT", "path": "src/io/flutter/run/test/FlutterTestRunner.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjo1Nzo0NVrOG9hG-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMTowNzo0M1rOG9n2qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1ODc3OQ==", "bodyText": "In DartVmServiceDebugProcess::scheduleConnect there's a check for whether the debug session has ended before the connection starts, but I'm not sure what the equivalent is to check for here.", "url": "https://github.com/flutter/flutter-intellij/pull/4749#discussion_r467158779", "createdAt": "2020-08-07T16:57:45Z", "author": {"login": "helin24"}, "path": "src/io/flutter/run/test/FlutterTestRunner.java", "diffHunk": "@@ -62,9 +71,64 @@ public boolean canRun(@NotNull String executorId, @NotNull RunProfile profile) {\n   @Override\n   protected RunContentDescriptor doExecute(@NotNull RunProfileState state, @NotNull ExecutionEnvironment env)\n     throws ExecutionException {\n-    return runInDebugger((TestLaunchState)state, env);\n+    if (env.getExecutor().getId().equals(ToolWindowId.RUN)) {\n+      return run((TestLaunchState)state, env);\n+    } else {\n+      return runInDebugger((TestLaunchState)state, env);\n+    }\n   }\n \n+  protected RunContentDescriptor run(@NotNull TestLaunchState launcher, @NotNull ExecutionEnvironment env)\n+    throws ExecutionException {\n+    final ExecutionResult executionResult = launcher.execute(env.getExecutor(), this);\n+    final ObservatoryConnector connector = new Connector(executionResult.getProcessHandler());\n+\n+    ApplicationManager.getApplication().executeOnPooledThread(() -> {\n+      // Poll, waiting for \"flutter run\" to give us a websocket.\n+      // This is adapted from DartVmServiceDebugProcess::scheduleConnect\n+      String url = connector.getWebSocketUrl();\n+\n+      while (url == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b25dafe7885bd30fc4cb589db3dddf18f25223c"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MjMwNQ==", "bodyText": "Is there a process we can query here, to see if it's still alive? I image there's something in the run state that we can check.", "url": "https://github.com/flutter/flutter-intellij/pull/4749#discussion_r467192305", "createdAt": "2020-08-07T18:06:05Z", "author": {"login": "devoncarew"}, "path": "src/io/flutter/run/test/FlutterTestRunner.java", "diffHunk": "@@ -62,9 +71,64 @@ public boolean canRun(@NotNull String executorId, @NotNull RunProfile profile) {\n   @Override\n   protected RunContentDescriptor doExecute(@NotNull RunProfileState state, @NotNull ExecutionEnvironment env)\n     throws ExecutionException {\n-    return runInDebugger((TestLaunchState)state, env);\n+    if (env.getExecutor().getId().equals(ToolWindowId.RUN)) {\n+      return run((TestLaunchState)state, env);\n+    } else {\n+      return runInDebugger((TestLaunchState)state, env);\n+    }\n   }\n \n+  protected RunContentDescriptor run(@NotNull TestLaunchState launcher, @NotNull ExecutionEnvironment env)\n+    throws ExecutionException {\n+    final ExecutionResult executionResult = launcher.execute(env.getExecutor(), this);\n+    final ObservatoryConnector connector = new Connector(executionResult.getProcessHandler());\n+\n+    ApplicationManager.getApplication().executeOnPooledThread(() -> {\n+      // Poll, waiting for \"flutter run\" to give us a websocket.\n+      // This is adapted from DartVmServiceDebugProcess::scheduleConnect\n+      String url = connector.getWebSocketUrl();\n+\n+      while (url == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1ODc3OQ=="}, "originalCommit": {"oid": "2b25dafe7885bd30fc4cb589db3dddf18f25223c"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1NDE5Mg==", "bodyText": "The other changes (in the new commit) look good.\nI assume from the question here that you'd want to find a way to address this (checking for process termination) before landing this PR?", "url": "https://github.com/flutter/flutter-intellij/pull/4749#discussion_r467254192", "createdAt": "2020-08-07T20:28:50Z", "author": {"login": "devoncarew"}, "path": "src/io/flutter/run/test/FlutterTestRunner.java", "diffHunk": "@@ -62,9 +71,64 @@ public boolean canRun(@NotNull String executorId, @NotNull RunProfile profile) {\n   @Override\n   protected RunContentDescriptor doExecute(@NotNull RunProfileState state, @NotNull ExecutionEnvironment env)\n     throws ExecutionException {\n-    return runInDebugger((TestLaunchState)state, env);\n+    if (env.getExecutor().getId().equals(ToolWindowId.RUN)) {\n+      return run((TestLaunchState)state, env);\n+    } else {\n+      return runInDebugger((TestLaunchState)state, env);\n+    }\n   }\n \n+  protected RunContentDescriptor run(@NotNull TestLaunchState launcher, @NotNull ExecutionEnvironment env)\n+    throws ExecutionException {\n+    final ExecutionResult executionResult = launcher.execute(env.getExecutor(), this);\n+    final ObservatoryConnector connector = new Connector(executionResult.getProcessHandler());\n+\n+    ApplicationManager.getApplication().executeOnPooledThread(() -> {\n+      // Poll, waiting for \"flutter run\" to give us a websocket.\n+      // This is adapted from DartVmServiceDebugProcess::scheduleConnect\n+      String url = connector.getWebSocketUrl();\n+\n+      while (url == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1ODc3OQ=="}, "originalCommit": {"oid": "2b25dafe7885bd30fc4cb589db3dddf18f25223c"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1OTE5Mw==", "bodyText": "Yeah I didn't find an easy way to do this but figured I'd look around a little more.", "url": "https://github.com/flutter/flutter-intellij/pull/4749#discussion_r467259193", "createdAt": "2020-08-07T20:41:26Z", "author": {"login": "helin24"}, "path": "src/io/flutter/run/test/FlutterTestRunner.java", "diffHunk": "@@ -62,9 +71,64 @@ public boolean canRun(@NotNull String executorId, @NotNull RunProfile profile) {\n   @Override\n   protected RunContentDescriptor doExecute(@NotNull RunProfileState state, @NotNull ExecutionEnvironment env)\n     throws ExecutionException {\n-    return runInDebugger((TestLaunchState)state, env);\n+    if (env.getExecutor().getId().equals(ToolWindowId.RUN)) {\n+      return run((TestLaunchState)state, env);\n+    } else {\n+      return runInDebugger((TestLaunchState)state, env);\n+    }\n   }\n \n+  protected RunContentDescriptor run(@NotNull TestLaunchState launcher, @NotNull ExecutionEnvironment env)\n+    throws ExecutionException {\n+    final ExecutionResult executionResult = launcher.execute(env.getExecutor(), this);\n+    final ObservatoryConnector connector = new Connector(executionResult.getProcessHandler());\n+\n+    ApplicationManager.getApplication().executeOnPooledThread(() -> {\n+      // Poll, waiting for \"flutter run\" to give us a websocket.\n+      // This is adapted from DartVmServiceDebugProcess::scheduleConnect\n+      String url = connector.getWebSocketUrl();\n+\n+      while (url == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1ODc3OQ=="}, "originalCommit": {"oid": "2b25dafe7885bd30fc4cb589db3dddf18f25223c"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI2OTI4OA==", "bodyText": "Exposing the process handler status seems to work here.", "url": "https://github.com/flutter/flutter-intellij/pull/4749#discussion_r467269288", "createdAt": "2020-08-07T21:07:43Z", "author": {"login": "helin24"}, "path": "src/io/flutter/run/test/FlutterTestRunner.java", "diffHunk": "@@ -62,9 +71,64 @@ public boolean canRun(@NotNull String executorId, @NotNull RunProfile profile) {\n   @Override\n   protected RunContentDescriptor doExecute(@NotNull RunProfileState state, @NotNull ExecutionEnvironment env)\n     throws ExecutionException {\n-    return runInDebugger((TestLaunchState)state, env);\n+    if (env.getExecutor().getId().equals(ToolWindowId.RUN)) {\n+      return run((TestLaunchState)state, env);\n+    } else {\n+      return runInDebugger((TestLaunchState)state, env);\n+    }\n   }\n \n+  protected RunContentDescriptor run(@NotNull TestLaunchState launcher, @NotNull ExecutionEnvironment env)\n+    throws ExecutionException {\n+    final ExecutionResult executionResult = launcher.execute(env.getExecutor(), this);\n+    final ObservatoryConnector connector = new Connector(executionResult.getProcessHandler());\n+\n+    ApplicationManager.getApplication().executeOnPooledThread(() -> {\n+      // Poll, waiting for \"flutter run\" to give us a websocket.\n+      // This is adapted from DartVmServiceDebugProcess::scheduleConnect\n+      String url = connector.getWebSocketUrl();\n+\n+      while (url == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1ODc3OQ=="}, "originalCommit": {"oid": "2b25dafe7885bd30fc4cb589db3dddf18f25223c"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxODI2OTk1OnYy", "diffSide": "RIGHT", "path": "src/io/flutter/run/test/FlutterTestRunner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODowNzo0OFrOG9jNNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODowNzo0OFrOG9jNNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MzE0Mg==", "bodyText": "Can this declaration move inside the try block?", "url": "https://github.com/flutter/flutter-intellij/pull/4749#discussion_r467193142", "createdAt": "2020-08-07T18:07:48Z", "author": {"login": "devoncarew"}, "path": "src/io/flutter/run/test/FlutterTestRunner.java", "diffHunk": "@@ -62,9 +71,64 @@ public boolean canRun(@NotNull String executorId, @NotNull RunProfile profile) {\n   @Override\n   protected RunContentDescriptor doExecute(@NotNull RunProfileState state, @NotNull ExecutionEnvironment env)\n     throws ExecutionException {\n-    return runInDebugger((TestLaunchState)state, env);\n+    if (env.getExecutor().getId().equals(ToolWindowId.RUN)) {\n+      return run((TestLaunchState)state, env);\n+    } else {\n+      return runInDebugger((TestLaunchState)state, env);\n+    }\n   }\n \n+  protected RunContentDescriptor run(@NotNull TestLaunchState launcher, @NotNull ExecutionEnvironment env)\n+    throws ExecutionException {\n+    final ExecutionResult executionResult = launcher.execute(env.getExecutor(), this);\n+    final ObservatoryConnector connector = new Connector(executionResult.getProcessHandler());\n+\n+    ApplicationManager.getApplication().executeOnPooledThread(() -> {\n+      // Poll, waiting for \"flutter run\" to give us a websocket.\n+      // This is adapted from DartVmServiceDebugProcess::scheduleConnect\n+      String url = connector.getWebSocketUrl();\n+\n+      while (url == null) {\n+        TimeoutUtil.sleep(100);\n+        url = connector.getWebSocketUrl();\n+      }\n+\n+      final VmService vmService;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b25dafe7885bd30fc4cb589db3dddf18f25223c"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxODI3MTgyOnYy", "diffSide": "RIGHT", "path": "src/io/flutter/run/test/FlutterTestRunner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODowODoxOFrOG9jOQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODowODoxOFrOG9jOQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MzQwOQ==", "bodyText": "Perhaps add a comment indicating that we're looking to resume any paused-at-start isolates here.", "url": "https://github.com/flutter/flutter-intellij/pull/4749#discussion_r467193409", "createdAt": "2020-08-07T18:08:18Z", "author": {"login": "devoncarew"}, "path": "src/io/flutter/run/test/FlutterTestRunner.java", "diffHunk": "@@ -62,9 +71,64 @@ public boolean canRun(@NotNull String executorId, @NotNull RunProfile profile) {\n   @Override\n   protected RunContentDescriptor doExecute(@NotNull RunProfileState state, @NotNull ExecutionEnvironment env)\n     throws ExecutionException {\n-    return runInDebugger((TestLaunchState)state, env);\n+    if (env.getExecutor().getId().equals(ToolWindowId.RUN)) {\n+      return run((TestLaunchState)state, env);\n+    } else {\n+      return runInDebugger((TestLaunchState)state, env);\n+    }\n   }\n \n+  protected RunContentDescriptor run(@NotNull TestLaunchState launcher, @NotNull ExecutionEnvironment env)\n+    throws ExecutionException {\n+    final ExecutionResult executionResult = launcher.execute(env.getExecutor(), this);\n+    final ObservatoryConnector connector = new Connector(executionResult.getProcessHandler());\n+\n+    ApplicationManager.getApplication().executeOnPooledThread(() -> {\n+      // Poll, waiting for \"flutter run\" to give us a websocket.\n+      // This is adapted from DartVmServiceDebugProcess::scheduleConnect\n+      String url = connector.getWebSocketUrl();\n+\n+      while (url == null) {\n+        TimeoutUtil.sleep(100);\n+        url = connector.getWebSocketUrl();\n+      }\n+\n+      final VmService vmService;\n+      try {\n+        vmService = VmService.connect(url);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b25dafe7885bd30fc4cb589db3dddf18f25223c"}, "originalPosition": 59}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 515, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}