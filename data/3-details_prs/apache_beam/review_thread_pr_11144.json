{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5NTcyNTQy", "number": 11144, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQyMDoyNjoxMVrODpREfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwMDo1NzowMlrODpVNTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTk3ODg0OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/graph/fn.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQyMDoyNjoxMVrOF4VnRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNDoyMzoxN1rOF4fquQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYxODY5Mg==", "bodyText": "A semantic note: the error shouldn't be ignored. Semantically if a function returns an error, the non error return values are not guaranteed to be valid.\nSo conventionally, the way to handle IsSplittable here is to check for the error, and return false if not nil, and otherwise return what the boolean is.", "url": "https://github.com/apache/beam/pull/11144#discussion_r394618692", "createdAt": "2020-03-18T20:26:11Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/graph/fn.go", "diffHunk": "@@ -196,13 +217,31 @@ func (f *DoFn) Name() string {\n \n // IsSplittable returns whether the DoFn is a valid Splittable DoFn.\n func (f *DoFn) IsSplittable() bool {\n-\treturn false // TODO(BEAM-3301): Implement this when we add SDFs.\n+\tisSdf, _ := validateSdfMethodsPresent((*Fn)(f))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4295ee7badff2ec8f0c5b07f325234e604d228f"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc4MzQxNw==", "bodyText": "Good point, I'll keep it in mind for the future. For this one, though, I realized it's better just to check for the presence of a single SDF method anyway, rather than calling that validation method.", "url": "https://github.com/apache/beam/pull/11144#discussion_r394783417", "createdAt": "2020-03-19T04:23:17Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/graph/fn.go", "diffHunk": "@@ -196,13 +217,31 @@ func (f *DoFn) Name() string {\n \n // IsSplittable returns whether the DoFn is a valid Splittable DoFn.\n func (f *DoFn) IsSplittable() bool {\n-\treturn false // TODO(BEAM-3301): Implement this when we add SDFs.\n+\tisSdf, _ := validateSdfMethodsPresent((*Fn)(f))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYxODY5Mg=="}, "originalCommit": {"oid": "f4295ee7badff2ec8f0c5b07f325234e604d228f"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NjYyMDgzOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/graph/fn.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwMDozMzo0NVrOF4b8tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNDoyMzoyMVrOF4fqxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcyMjQ4Nw==", "bodyText": "Prefer declaring empty slices using the var syntax.\nvar missing []string", "url": "https://github.com/apache/beam/pull/11144#discussion_r394722487", "createdAt": "2020-03-19T00:33:45Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/graph/fn.go", "diffHunk": "@@ -569,6 +622,188 @@ func validateSideInputsNumUnknown(processFnInputs []funcx.FnParam, method *funcx\n \treturn nil\n }\n \n+// validateSdfMethods validates that all SDF methods are either present or\n+// missing in a Fn, and then returns true if they're present and false\n+// otherwise. If some are present and some are missing, it returns an error.\n+func validateSdfMethodsPresent(fn *Fn) (bool, error) {\n+\t// Check if first sdf method is present or not, and compare all subsequent\n+\t// methods to that result. If there's a mismatch, then we only fail after\n+\t// finishing the loop so we can output all the missing methods.\n+\tmissing := make([]string, 0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4295ee7badff2ec8f0c5b07f325234e604d228f"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc4MzQzMA==", "bodyText": "Done. I forgot that append works on nil slices.", "url": "https://github.com/apache/beam/pull/11144#discussion_r394783430", "createdAt": "2020-03-19T04:23:21Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/graph/fn.go", "diffHunk": "@@ -569,6 +622,188 @@ func validateSideInputsNumUnknown(processFnInputs []funcx.FnParam, method *funcx\n \treturn nil\n }\n \n+// validateSdfMethods validates that all SDF methods are either present or\n+// missing in a Fn, and then returns true if they're present and false\n+// otherwise. If some are present and some are missing, it returns an error.\n+func validateSdfMethodsPresent(fn *Fn) (bool, error) {\n+\t// Check if first sdf method is present or not, and compare all subsequent\n+\t// methods to that result. If there's a mismatch, then we only fail after\n+\t// finishing the loop so we can output all the missing methods.\n+\tmissing := make([]string, 0)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcyMjQ4Nw=="}, "originalCommit": {"oid": "f4295ee7badff2ec8f0c5b07f325234e604d228f"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NjYzODIyOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/graph/fn.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwMDo0NDoyN1rOF4cHhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNDoyMzoyN1rOF4fq2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcyNTI1NA==", "bodyText": "I see that this function is trying to distinguish between partial coverage or complete coverage, but I think it could be simpler.\nConsider that the booleans could be removed by comparing whether len(missing) == len(sdfNames) to check if it's simply not an SDF at all (and thus, no error should be returned).\nswitch len(missing) {\ncase 0: \n  return true, nil\ncase len(sdfNames): \n  return false, nil\ndefault:\n  err := errors.Errorf(\"not all SplittableDoFn methods are present. Missing methods: %v\", missing)\n  return false, err\n}", "url": "https://github.com/apache/beam/pull/11144#discussion_r394725254", "createdAt": "2020-03-19T00:44:27Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/graph/fn.go", "diffHunk": "@@ -569,6 +622,188 @@ func validateSideInputsNumUnknown(processFnInputs []funcx.FnParam, method *funcx\n \treturn nil\n }\n \n+// validateSdfMethods validates that all SDF methods are either present or\n+// missing in a Fn, and then returns true if they're present and false\n+// otherwise. If some are present and some are missing, it returns an error.\n+func validateSdfMethodsPresent(fn *Fn) (bool, error) {\n+\t// Check if first sdf method is present or not, and compare all subsequent\n+\t// methods to that result. If there's a mismatch, then we only fail after\n+\t// finishing the loop so we can output all the missing methods.\n+\tmissing := make([]string, 0)\n+\tvar first, fail bool\n+\n+\tfor i, name := range sdfNames {\n+\t\t_, ok := fn.methods[name]\n+\t\tif !ok {\n+\t\t\tmissing = append(missing, name)\n+\t\t}\n+\n+\t\tif i == 0 {\n+\t\t\tfirst = ok\n+\t\t} else if ok != first {\n+\t\t\tfail = true\n+\t\t}\n+\t}\n+\n+\tif fail {\n+\t\terr := errors.Errorf(\"not all SplittableDoFn methods are present. Missing methods: %v\", missing)\n+\t\treturn false, err\n+\t}\n+\n+\treturn first, nil", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4295ee7badff2ec8f0c5b07f325234e604d228f"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc4MzQ1MA==", "bodyText": "That looks much more readable and easy to follow than the current one. Done.", "url": "https://github.com/apache/beam/pull/11144#discussion_r394783450", "createdAt": "2020-03-19T04:23:27Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/graph/fn.go", "diffHunk": "@@ -569,6 +622,188 @@ func validateSideInputsNumUnknown(processFnInputs []funcx.FnParam, method *funcx\n \treturn nil\n }\n \n+// validateSdfMethods validates that all SDF methods are either present or\n+// missing in a Fn, and then returns true if they're present and false\n+// otherwise. If some are present and some are missing, it returns an error.\n+func validateSdfMethodsPresent(fn *Fn) (bool, error) {\n+\t// Check if first sdf method is present or not, and compare all subsequent\n+\t// methods to that result. If there's a mismatch, then we only fail after\n+\t// finishing the loop so we can output all the missing methods.\n+\tmissing := make([]string, 0)\n+\tvar first, fail bool\n+\n+\tfor i, name := range sdfNames {\n+\t\t_, ok := fn.methods[name]\n+\t\tif !ok {\n+\t\t\tmissing = append(missing, name)\n+\t\t}\n+\n+\t\tif i == 0 {\n+\t\t\tfirst = ok\n+\t\t} else if ok != first {\n+\t\t\tfail = true\n+\t\t}\n+\t}\n+\n+\tif fail {\n+\t\terr := errors.Errorf(\"not all SplittableDoFn methods are present. Missing methods: %v\", missing)\n+\t\treturn false, err\n+\t}\n+\n+\treturn first, nil", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcyNTI1NA=="}, "originalCommit": {"oid": "f4295ee7badff2ec8f0c5b07f325234e604d228f"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NjY1Njc4OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/graph/fn_test.go", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwMDo1NzowMlrOF4cTuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMTo0OToyNVrOF5Bluw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcyODM3Nw==", "bodyText": "Shouldn't the ProcessElement method be adjusted here for the Restriction tracker parameter for a \"GoodSdf\" ?\nI guess technically if we don't care about dynamic splitting at all, it should be allowed. It's not unreasonable to prevent it until we have the right idea how to do that, but if so, lets put a TODO in here somewhere to make the intent explicit.", "url": "https://github.com/apache/beam/pull/11144#discussion_r394728377", "createdAt": "2020-03-19T00:57:02Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/graph/fn_test.go", "diffHunk": "@@ -470,6 +542,169 @@ func (fn *BadDoFnAmbiguousSideInput) StartBundle(bool) {\n func (fn *BadDoFnAmbiguousSideInput) FinishBundle(bool) {\n }\n \n+// Examples of correct SplittableDoFn signatures\n+\n+type RestT struct{}\n+\n+type GoodSdf struct {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4295ee7badff2ec8f0c5b07f325234e604d228f"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc4MzQ3Nw==", "bodyText": "I was just skipping it because this commit hasn't added restriction trackers yet, but adding a TODO to remind me to change it later is a good idea. Done.", "url": "https://github.com/apache/beam/pull/11144#discussion_r394783477", "createdAt": "2020-03-19T04:23:34Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/graph/fn_test.go", "diffHunk": "@@ -470,6 +542,169 @@ func (fn *BadDoFnAmbiguousSideInput) StartBundle(bool) {\n func (fn *BadDoFnAmbiguousSideInput) FinishBundle(bool) {\n }\n \n+// Examples of correct SplittableDoFn signatures\n+\n+type RestT struct{}\n+\n+type GoodSdf struct {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcyODM3Nw=="}, "originalCommit": {"oid": "f4295ee7badff2ec8f0c5b07f325234e604d228f"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzOTE5NQ==", "bodyText": "Makes sense! Thanks!", "url": "https://github.com/apache/beam/pull/11144#discussion_r395339195", "createdAt": "2020-03-19T21:49:25Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/graph/fn_test.go", "diffHunk": "@@ -470,6 +542,169 @@ func (fn *BadDoFnAmbiguousSideInput) StartBundle(bool) {\n func (fn *BadDoFnAmbiguousSideInput) FinishBundle(bool) {\n }\n \n+// Examples of correct SplittableDoFn signatures\n+\n+type RestT struct{}\n+\n+type GoodSdf struct {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcyODM3Nw=="}, "originalCommit": {"oid": "f4295ee7badff2ec8f0c5b07f325234e604d228f"}, "originalPosition": 134}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1660, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}