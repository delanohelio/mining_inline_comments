{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyODU5MjE2", "number": 12153, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODoyMToxMVrOEKnY-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMToxNDoxN1rOEKqcmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NTY2NTg3OnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/SqlAnalyzer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODoyMToxMlrOGrwscA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMDo0ODo0NVrOGr04lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzOTc2MA==", "bodyText": "I wasn't aware that this addFunction can throw an exception. Any example that could fail this line? E.g. adding a function with duplicated name?", "url": "https://github.com/apache/beam/pull/12153#discussion_r448539760", "createdAt": "2020-07-01T18:21:12Z", "author": {"login": "amaliujia"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/SqlAnalyzer.java", "diffHunk": "@@ -107,6 +128,43 @@ ResolvedStatement analyze(String sql) {\n     return Analyzer.analyzeStatement(sql, options, catalog);\n   }\n \n+  /**\n+   * Accepts the ParseResumeLocation for the current position in the SQL string. Advances the\n+   * ParseResumeLocation to the start of the next statement. Adds user-defined functions to the\n+   * catalog for use in following statements. Returns the resolved AST.\n+   */\n+  ResolvedStatement analyzeNextStatement(\n+      ParseResumeLocation parseResumeLocation, AnalyzerOptions options, SimpleCatalog catalog) {\n+    ResolvedStatement resolvedStatement =\n+        Analyzer.analyzeNextStatement(parseResumeLocation, options, catalog);\n+    if (resolvedStatement.nodeKind() == RESOLVED_CREATE_FUNCTION_STMT) {\n+      ResolvedCreateFunctionStmt createFunctionStmt =\n+          (ResolvedCreateFunctionStmt) resolvedStatement;\n+      Function userFunction =\n+          new Function(\n+              createFunctionStmt.getNamePath(),\n+              USER_DEFINED_FUNCTIONS,\n+              // TODO(BEAM-9954) handle aggregate functions\n+              // TODO(BEAM-9969) handle table functions\n+              Mode.SCALAR,\n+              com.google.common.collect.ImmutableList.of(createFunctionStmt.getSignature()));\n+      try {\n+        catalog.addFunction(userFunction);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52237a292ff1a3b001667976f8073744f0124cd3"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYwODQwNQ==", "bodyText": "Yes. See https://github.com/apache/beam/pull/12153/files#diff-bf7c0f0293cfabc387959dbd4494a5cfR2855-R2862", "url": "https://github.com/apache/beam/pull/12153#discussion_r448608405", "createdAt": "2020-07-01T20:48:45Z", "author": {"login": "ibzib"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/SqlAnalyzer.java", "diffHunk": "@@ -107,6 +128,43 @@ ResolvedStatement analyze(String sql) {\n     return Analyzer.analyzeStatement(sql, options, catalog);\n   }\n \n+  /**\n+   * Accepts the ParseResumeLocation for the current position in the SQL string. Advances the\n+   * ParseResumeLocation to the start of the next statement. Adds user-defined functions to the\n+   * catalog for use in following statements. Returns the resolved AST.\n+   */\n+  ResolvedStatement analyzeNextStatement(\n+      ParseResumeLocation parseResumeLocation, AnalyzerOptions options, SimpleCatalog catalog) {\n+    ResolvedStatement resolvedStatement =\n+        Analyzer.analyzeNextStatement(parseResumeLocation, options, catalog);\n+    if (resolvedStatement.nodeKind() == RESOLVED_CREATE_FUNCTION_STMT) {\n+      ResolvedCreateFunctionStmt createFunctionStmt =\n+          (ResolvedCreateFunctionStmt) resolvedStatement;\n+      Function userFunction =\n+          new Function(\n+              createFunctionStmt.getNamePath(),\n+              USER_DEFINED_FUNCTIONS,\n+              // TODO(BEAM-9954) handle aggregate functions\n+              // TODO(BEAM-9969) handle table functions\n+              Mode.SCALAR,\n+              com.google.common.collect.ImmutableList.of(createFunctionStmt.getSignature()));\n+      try {\n+        catalog.addFunction(userFunction);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzOTc2MA=="}, "originalCommit": {"oid": "52237a292ff1a3b001667976f8073744f0124cd3"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NTY2ODg1OnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/SqlAnalyzer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODoyMjowMVrOGrwuPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMTowMDoyNVrOGr1NTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0MDIyMw==", "bodyText": "Why add a ParseException? Seems to me that throw IllegalArgumentException e directly will give clear cause?", "url": "https://github.com/apache/beam/pull/12153#discussion_r448540223", "createdAt": "2020-07-01T18:22:01Z", "author": {"login": "amaliujia"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/SqlAnalyzer.java", "diffHunk": "@@ -107,6 +128,43 @@ ResolvedStatement analyze(String sql) {\n     return Analyzer.analyzeStatement(sql, options, catalog);\n   }\n \n+  /**\n+   * Accepts the ParseResumeLocation for the current position in the SQL string. Advances the\n+   * ParseResumeLocation to the start of the next statement. Adds user-defined functions to the\n+   * catalog for use in following statements. Returns the resolved AST.\n+   */\n+  ResolvedStatement analyzeNextStatement(\n+      ParseResumeLocation parseResumeLocation, AnalyzerOptions options, SimpleCatalog catalog) {\n+    ResolvedStatement resolvedStatement =\n+        Analyzer.analyzeNextStatement(parseResumeLocation, options, catalog);\n+    if (resolvedStatement.nodeKind() == RESOLVED_CREATE_FUNCTION_STMT) {\n+      ResolvedCreateFunctionStmt createFunctionStmt =\n+          (ResolvedCreateFunctionStmt) resolvedStatement;\n+      Function userFunction =\n+          new Function(\n+              createFunctionStmt.getNamePath(),\n+              USER_DEFINED_FUNCTIONS,\n+              // TODO(BEAM-9954) handle aggregate functions\n+              // TODO(BEAM-9969) handle table functions\n+              Mode.SCALAR,\n+              com.google.common.collect.ImmutableList.of(createFunctionStmt.getSignature()));\n+      try {\n+        catalog.addFunction(userFunction);\n+      } catch (IllegalArgumentException e) {\n+        throw new ParseException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52237a292ff1a3b001667976f8073744f0124cd3"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1Mjk0Mw==", "bodyText": "Also there is no test to cover this case. (Is there?)", "url": "https://github.com/apache/beam/pull/12153#discussion_r448552943", "createdAt": "2020-07-01T18:47:34Z", "author": {"login": "amaliujia"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/SqlAnalyzer.java", "diffHunk": "@@ -107,6 +128,43 @@ ResolvedStatement analyze(String sql) {\n     return Analyzer.analyzeStatement(sql, options, catalog);\n   }\n \n+  /**\n+   * Accepts the ParseResumeLocation for the current position in the SQL string. Advances the\n+   * ParseResumeLocation to the start of the next statement. Adds user-defined functions to the\n+   * catalog for use in following statements. Returns the resolved AST.\n+   */\n+  ResolvedStatement analyzeNextStatement(\n+      ParseResumeLocation parseResumeLocation, AnalyzerOptions options, SimpleCatalog catalog) {\n+    ResolvedStatement resolvedStatement =\n+        Analyzer.analyzeNextStatement(parseResumeLocation, options, catalog);\n+    if (resolvedStatement.nodeKind() == RESOLVED_CREATE_FUNCTION_STMT) {\n+      ResolvedCreateFunctionStmt createFunctionStmt =\n+          (ResolvedCreateFunctionStmt) resolvedStatement;\n+      Function userFunction =\n+          new Function(\n+              createFunctionStmt.getNamePath(),\n+              USER_DEFINED_FUNCTIONS,\n+              // TODO(BEAM-9954) handle aggregate functions\n+              // TODO(BEAM-9969) handle table functions\n+              Mode.SCALAR,\n+              com.google.common.collect.ImmutableList.of(createFunctionStmt.getSignature()));\n+      try {\n+        catalog.addFunction(userFunction);\n+      } catch (IllegalArgumentException e) {\n+        throw new ParseException(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0MDIyMw=="}, "originalCommit": {"oid": "52237a292ff1a3b001667976f8073744f0124cd3"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMzcxMA==", "bodyText": "see comment above", "url": "https://github.com/apache/beam/pull/12153#discussion_r448613710", "createdAt": "2020-07-01T21:00:25Z", "author": {"login": "ibzib"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/SqlAnalyzer.java", "diffHunk": "@@ -107,6 +128,43 @@ ResolvedStatement analyze(String sql) {\n     return Analyzer.analyzeStatement(sql, options, catalog);\n   }\n \n+  /**\n+   * Accepts the ParseResumeLocation for the current position in the SQL string. Advances the\n+   * ParseResumeLocation to the start of the next statement. Adds user-defined functions to the\n+   * catalog for use in following statements. Returns the resolved AST.\n+   */\n+  ResolvedStatement analyzeNextStatement(\n+      ParseResumeLocation parseResumeLocation, AnalyzerOptions options, SimpleCatalog catalog) {\n+    ResolvedStatement resolvedStatement =\n+        Analyzer.analyzeNextStatement(parseResumeLocation, options, catalog);\n+    if (resolvedStatement.nodeKind() == RESOLVED_CREATE_FUNCTION_STMT) {\n+      ResolvedCreateFunctionStmt createFunctionStmt =\n+          (ResolvedCreateFunctionStmt) resolvedStatement;\n+      Function userFunction =\n+          new Function(\n+              createFunctionStmt.getNamePath(),\n+              USER_DEFINED_FUNCTIONS,\n+              // TODO(BEAM-9954) handle aggregate functions\n+              // TODO(BEAM-9969) handle table functions\n+              Mode.SCALAR,\n+              com.google.common.collect.ImmutableList.of(createFunctionStmt.getSignature()));\n+      try {\n+        catalog.addFunction(userFunction);\n+      } catch (IllegalArgumentException e) {\n+        throw new ParseException(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0MDIyMw=="}, "originalCommit": {"oid": "52237a292ff1a3b001667976f8073744f0124cd3"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NTY3MjEyOnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/SqlAnalyzer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODoyMzowMVrOGrwwKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMTowMDoxN1rOGr1NKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0MDcxNA==", "bodyText": "line 159 and line 161 are duplicates and they can be put at the end of this function.", "url": "https://github.com/apache/beam/pull/12153#discussion_r448540714", "createdAt": "2020-07-01T18:23:01Z", "author": {"login": "amaliujia"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/SqlAnalyzer.java", "diffHunk": "@@ -107,6 +128,43 @@ ResolvedStatement analyze(String sql) {\n     return Analyzer.analyzeStatement(sql, options, catalog);\n   }\n \n+  /**\n+   * Accepts the ParseResumeLocation for the current position in the SQL string. Advances the\n+   * ParseResumeLocation to the start of the next statement. Adds user-defined functions to the\n+   * catalog for use in following statements. Returns the resolved AST.\n+   */\n+  ResolvedStatement analyzeNextStatement(\n+      ParseResumeLocation parseResumeLocation, AnalyzerOptions options, SimpleCatalog catalog) {\n+    ResolvedStatement resolvedStatement =\n+        Analyzer.analyzeNextStatement(parseResumeLocation, options, catalog);\n+    if (resolvedStatement.nodeKind() == RESOLVED_CREATE_FUNCTION_STMT) {\n+      ResolvedCreateFunctionStmt createFunctionStmt =\n+          (ResolvedCreateFunctionStmt) resolvedStatement;\n+      Function userFunction =\n+          new Function(\n+              createFunctionStmt.getNamePath(),\n+              USER_DEFINED_FUNCTIONS,\n+              // TODO(BEAM-9954) handle aggregate functions\n+              // TODO(BEAM-9969) handle table functions\n+              Mode.SCALAR,\n+              com.google.common.collect.ImmutableList.of(createFunctionStmt.getSignature()));\n+      try {\n+        catalog.addFunction(userFunction);\n+      } catch (IllegalArgumentException e) {\n+        throw new ParseException(\n+            String.format(\n+                \"Failed to define function %s\", String.join(\".\", createFunctionStmt.getNamePath())),\n+            e);\n+      }\n+      return resolvedStatement;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52237a292ff1a3b001667976f8073744f0124cd3"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMzY3NA==", "bodyText": "done", "url": "https://github.com/apache/beam/pull/12153#discussion_r448613674", "createdAt": "2020-07-01T21:00:17Z", "author": {"login": "ibzib"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/SqlAnalyzer.java", "diffHunk": "@@ -107,6 +128,43 @@ ResolvedStatement analyze(String sql) {\n     return Analyzer.analyzeStatement(sql, options, catalog);\n   }\n \n+  /**\n+   * Accepts the ParseResumeLocation for the current position in the SQL string. Advances the\n+   * ParseResumeLocation to the start of the next statement. Adds user-defined functions to the\n+   * catalog for use in following statements. Returns the resolved AST.\n+   */\n+  ResolvedStatement analyzeNextStatement(\n+      ParseResumeLocation parseResumeLocation, AnalyzerOptions options, SimpleCatalog catalog) {\n+    ResolvedStatement resolvedStatement =\n+        Analyzer.analyzeNextStatement(parseResumeLocation, options, catalog);\n+    if (resolvedStatement.nodeKind() == RESOLVED_CREATE_FUNCTION_STMT) {\n+      ResolvedCreateFunctionStmt createFunctionStmt =\n+          (ResolvedCreateFunctionStmt) resolvedStatement;\n+      Function userFunction =\n+          new Function(\n+              createFunctionStmt.getNamePath(),\n+              USER_DEFINED_FUNCTIONS,\n+              // TODO(BEAM-9954) handle aggregate functions\n+              // TODO(BEAM-9969) handle table functions\n+              Mode.SCALAR,\n+              com.google.common.collect.ImmutableList.of(createFunctionStmt.getSignature()));\n+      try {\n+        catalog.addFunction(userFunction);\n+      } catch (IllegalArgumentException e) {\n+        throw new ParseException(\n+            String.format(\n+                \"Failed to define function %s\", String.join(\".\", createFunctionStmt.getNamePath())),\n+            e);\n+      }\n+      return resolvedStatement;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0MDcxNA=="}, "originalCommit": {"oid": "52237a292ff1a3b001667976f8073744f0124cd3"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NTY3NjU3OnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/zetasql/src/test/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLDialectSpecTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODoyNDoyNVrOGrwy-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMTowMDowOFrOGr1M1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0MTQzMg==", "bodyText": "Any link to what this bug is (or log a JIRA to describe what has failed?)", "url": "https://github.com/apache/beam/pull/12153#discussion_r448541432", "createdAt": "2020-07-01T18:24:25Z", "author": {"login": "amaliujia"}, "path": "sdks/java/extensions/sql/zetasql/src/test/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLDialectSpecTest.java", "diffHunk": "@@ -2841,6 +2842,129 @@ public void testSelectNullExceptAll() {\n     pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n   }\n \n+  @Test\n+  public void testMultipleSelectStatementsThrowsException() {\n+    String sql = \"SELECT 1; SELECT 2;\";\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    thrown.expect(UnsupportedOperationException.class);\n+    thrown.expectMessage(\n+        \"Statement list must end in a SELECT statement, and cannot contain more than one SELECT statement.\");\n+    zetaSQLQueryPlanner.convertToBeamRel(sql);\n+  }\n+\n+  @Test\n+  public void testAlreadyDefinedUDFThrowsException() {\n+    String sql = \"CREATE FUNCTION foo() AS (0); CREATE FUNCTION foo() AS (1); SELECT foo();\";\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    thrown.expect(ParseException.class);\n+    thrown.expectMessage(\"Failed to define function foo\");\n+    zetaSQLQueryPlanner.convertToBeamRel(sql);\n+  }\n+\n+  @Test\n+  public void testCreateFunctionNoSelectThrowsException() {\n+    String sql = \"CREATE FUNCTION plusOne(x INT64) AS (x + 1);\";\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    thrown.expect(UnsupportedOperationException.class);\n+    thrown.expectMessage(\"Statement list must end in a SELECT statement, not CreateFunctionStmt\");\n+    zetaSQLQueryPlanner.convertToBeamRel(sql);\n+  }\n+\n+  @Test\n+  public void testNullaryUdf() {\n+    String sql = \"CREATE FUNCTION zero() AS (0); SELECT zero();\";\n+\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);\n+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);\n+\n+    PAssert.that(stream)\n+        .containsInAnyOrder(\n+            Row.withSchema(Schema.builder().addInt64Field(\"x\").build()).addValue(0L).build());\n+    pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n+  }\n+\n+  @Test\n+  public void testQualifiedNameUdfUnqualifiedCall() {\n+    String sql = \"CREATE FUNCTION foo.bar.baz() AS (\\\"uwu\\\"); SELECT baz();\";\n+\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);\n+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);\n+\n+    PAssert.that(stream)\n+        .containsInAnyOrder(\n+            Row.withSchema(Schema.builder().addStringField(\"x\").build()).addValue(\"uwu\").build());\n+    pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n+  }\n+\n+  @Test\n+  @Ignore(\"Qualified paths can't be resolved due to a bug in ZetaSQL.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52237a292ff1a3b001667976f8073744f0124cd3"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMzU5MQ==", "bodyText": "I filed a public bug for this: google/zetasql#42", "url": "https://github.com/apache/beam/pull/12153#discussion_r448613591", "createdAt": "2020-07-01T21:00:08Z", "author": {"login": "ibzib"}, "path": "sdks/java/extensions/sql/zetasql/src/test/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLDialectSpecTest.java", "diffHunk": "@@ -2841,6 +2842,129 @@ public void testSelectNullExceptAll() {\n     pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n   }\n \n+  @Test\n+  public void testMultipleSelectStatementsThrowsException() {\n+    String sql = \"SELECT 1; SELECT 2;\";\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    thrown.expect(UnsupportedOperationException.class);\n+    thrown.expectMessage(\n+        \"Statement list must end in a SELECT statement, and cannot contain more than one SELECT statement.\");\n+    zetaSQLQueryPlanner.convertToBeamRel(sql);\n+  }\n+\n+  @Test\n+  public void testAlreadyDefinedUDFThrowsException() {\n+    String sql = \"CREATE FUNCTION foo() AS (0); CREATE FUNCTION foo() AS (1); SELECT foo();\";\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    thrown.expect(ParseException.class);\n+    thrown.expectMessage(\"Failed to define function foo\");\n+    zetaSQLQueryPlanner.convertToBeamRel(sql);\n+  }\n+\n+  @Test\n+  public void testCreateFunctionNoSelectThrowsException() {\n+    String sql = \"CREATE FUNCTION plusOne(x INT64) AS (x + 1);\";\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    thrown.expect(UnsupportedOperationException.class);\n+    thrown.expectMessage(\"Statement list must end in a SELECT statement, not CreateFunctionStmt\");\n+    zetaSQLQueryPlanner.convertToBeamRel(sql);\n+  }\n+\n+  @Test\n+  public void testNullaryUdf() {\n+    String sql = \"CREATE FUNCTION zero() AS (0); SELECT zero();\";\n+\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);\n+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);\n+\n+    PAssert.that(stream)\n+        .containsInAnyOrder(\n+            Row.withSchema(Schema.builder().addInt64Field(\"x\").build()).addValue(0L).build());\n+    pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n+  }\n+\n+  @Test\n+  public void testQualifiedNameUdfUnqualifiedCall() {\n+    String sql = \"CREATE FUNCTION foo.bar.baz() AS (\\\"uwu\\\"); SELECT baz();\";\n+\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);\n+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);\n+\n+    PAssert.that(stream)\n+        .containsInAnyOrder(\n+            Row.withSchema(Schema.builder().addStringField(\"x\").build()).addValue(\"uwu\").build());\n+    pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n+  }\n+\n+  @Test\n+  @Ignore(\"Qualified paths can't be resolved due to a bug in ZetaSQL.\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0MTQzMg=="}, "originalCommit": {"oid": "52237a292ff1a3b001667976f8073744f0124cd3"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NTY4ODM4OnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLPlannerImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODoyODoxNVrOGrw6IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMDo0NzoyM1rOGr02Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0MzI2NQ==", "bodyText": "Can you clarify what is \"full function name\"?", "url": "https://github.com/apache/beam/pull/12153#discussion_r448543265", "createdAt": "2020-07-01T18:28:15Z", "author": {"login": "amaliujia"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLPlannerImpl.java", "diffHunk": "@@ -130,30 +135,57 @@ public RelRoot rel(SqlNode sqlNode) throws RelConversionException {\n   }\n \n   public RelRoot rel(String sql, QueryParameters params) {\n-    this.cluster = RelOptCluster.create(planner, new RexBuilder(typeFactory));\n-    this.expressionConverter = new ExpressionConverter(cluster, params);\n+    RelOptCluster cluster = RelOptCluster.create(planner, new RexBuilder(typeFactory));\n \n     QueryTrait trait = new QueryTrait();\n \n-    // Set up table providers that need to be pre-registered\n-    // TODO(https://issues.apache.org/jira/browse/BEAM-8817): share this logic between dialects\n-    List<List<String>> tables = Analyzer.extractTableNamesFromStatement(sql);\n-    TableResolution.registerTables(this.defaultSchemaPlus, tables);\n-\n-    ResolvedStatement statement =\n+    SqlAnalyzer analyzer =\n         SqlAnalyzer.getBuilder()\n             .withQueryParams(params)\n             .withQueryTrait(trait)\n             .withCalciteContext(config.getContext())\n             .withTopLevelSchema(defaultSchemaPlus)\n             .withTypeFactory((JavaTypeFactory) cluster.getTypeFactory())\n-            .analyze(sql);\n+            .build();\n+\n+    AnalyzerOptions options = SqlAnalyzer.initAnalyzerOptions(params);\n+\n+    // Set up table providers that need to be pre-registered\n+    List<List<String>> tables = analyzer.extractTableNames(sql, options);\n+    TableResolution.registerTables(this.defaultSchemaPlus, tables);\n+    SimpleCatalog catalog =\n+        analyzer.createPopulatedCatalog(defaultSchemaPlus.getName(), options, tables);\n+\n+    ImmutableMap.Builder<String, ResolvedCreateFunctionStmt> udfBuilder = ImmutableMap.builder();\n+\n+    ResolvedStatement statement;\n+    ParseResumeLocation parseResumeLocation = new ParseResumeLocation(sql);\n+    do {\n+      statement = analyzer.analyzeNextStatement(parseResumeLocation, options, catalog);\n+      if (statement.nodeKind() == RESOLVED_CREATE_FUNCTION_STMT) {\n+        ResolvedCreateFunctionStmt createFunctionStmt = (ResolvedCreateFunctionStmt) statement;\n+        // ResolvedCreateFunctionStmt does not include the full function name, so build it here.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52237a292ff1a3b001667976f8073744f0124cd3"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYwNzc2Nw==", "bodyText": "ResolvedCreateFunctionStmt contains the path as a list of strings, while we need the whole path as a single string.", "url": "https://github.com/apache/beam/pull/12153#discussion_r448607767", "createdAt": "2020-07-01T20:47:23Z", "author": {"login": "ibzib"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLPlannerImpl.java", "diffHunk": "@@ -130,30 +135,57 @@ public RelRoot rel(SqlNode sqlNode) throws RelConversionException {\n   }\n \n   public RelRoot rel(String sql, QueryParameters params) {\n-    this.cluster = RelOptCluster.create(planner, new RexBuilder(typeFactory));\n-    this.expressionConverter = new ExpressionConverter(cluster, params);\n+    RelOptCluster cluster = RelOptCluster.create(planner, new RexBuilder(typeFactory));\n \n     QueryTrait trait = new QueryTrait();\n \n-    // Set up table providers that need to be pre-registered\n-    // TODO(https://issues.apache.org/jira/browse/BEAM-8817): share this logic between dialects\n-    List<List<String>> tables = Analyzer.extractTableNamesFromStatement(sql);\n-    TableResolution.registerTables(this.defaultSchemaPlus, tables);\n-\n-    ResolvedStatement statement =\n+    SqlAnalyzer analyzer =\n         SqlAnalyzer.getBuilder()\n             .withQueryParams(params)\n             .withQueryTrait(trait)\n             .withCalciteContext(config.getContext())\n             .withTopLevelSchema(defaultSchemaPlus)\n             .withTypeFactory((JavaTypeFactory) cluster.getTypeFactory())\n-            .analyze(sql);\n+            .build();\n+\n+    AnalyzerOptions options = SqlAnalyzer.initAnalyzerOptions(params);\n+\n+    // Set up table providers that need to be pre-registered\n+    List<List<String>> tables = analyzer.extractTableNames(sql, options);\n+    TableResolution.registerTables(this.defaultSchemaPlus, tables);\n+    SimpleCatalog catalog =\n+        analyzer.createPopulatedCatalog(defaultSchemaPlus.getName(), options, tables);\n+\n+    ImmutableMap.Builder<String, ResolvedCreateFunctionStmt> udfBuilder = ImmutableMap.builder();\n+\n+    ResolvedStatement statement;\n+    ParseResumeLocation parseResumeLocation = new ParseResumeLocation(sql);\n+    do {\n+      statement = analyzer.analyzeNextStatement(parseResumeLocation, options, catalog);\n+      if (statement.nodeKind() == RESOLVED_CREATE_FUNCTION_STMT) {\n+        ResolvedCreateFunctionStmt createFunctionStmt = (ResolvedCreateFunctionStmt) statement;\n+        // ResolvedCreateFunctionStmt does not include the full function name, so build it here.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0MzI2NQ=="}, "originalCommit": {"oid": "52237a292ff1a3b001667976f8073744f0124cd3"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NTcxMTk4OnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLPlannerImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODozNTozOVrOGrxI4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMTowNTozOFrOGr1Vrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0NzA0MA==", "bodyText": "I can tell line 185 and this line combined together to verify:\n\nonly one SELECT in a statement list.\nthat SELECT statement should be in the end of list.\n\nBut from readability perspective, neither one explicitly tests there are more than one SELECT in a list. I am afraid that for people who don't have context to read code here, they could not get the one single SELECT constraint (although it is implied implicitly).\nMy suggestion is you only validate cannot contain more than one SELECT statement here and leave Statement list must end in a SELECT statement to line 185.", "url": "https://github.com/apache/beam/pull/12153#discussion_r448547040", "createdAt": "2020-07-01T18:35:39Z", "author": {"login": "amaliujia"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLPlannerImpl.java", "diffHunk": "@@ -130,30 +135,58 @@ public RelRoot rel(SqlNode sqlNode) throws RelConversionException {\n   }\n \n   public RelRoot rel(String sql, QueryParameters params) {\n-    this.cluster = RelOptCluster.create(planner, new RexBuilder(typeFactory));\n-    this.expressionConverter = new ExpressionConverter(cluster, params);\n+    RelOptCluster cluster = RelOptCluster.create(planner, new RexBuilder(typeFactory));\n \n     QueryTrait trait = new QueryTrait();\n \n-    // Set up table providers that need to be pre-registered\n-    // TODO(https://issues.apache.org/jira/browse/BEAM-8817): share this logic between dialects\n-    List<List<String>> tables = Analyzer.extractTableNamesFromStatement(sql);\n-    TableResolution.registerTables(this.defaultSchemaPlus, tables);\n-\n-    ResolvedStatement statement =\n+    SqlAnalyzer analyzer =\n         SqlAnalyzer.getBuilder()\n             .withQueryParams(params)\n             .withQueryTrait(trait)\n             .withCalciteContext(config.getContext())\n             .withTopLevelSchema(defaultSchemaPlus)\n             .withTypeFactory((JavaTypeFactory) cluster.getTypeFactory())\n-            .analyze(sql);\n+            .build();\n+\n+    AnalyzerOptions options = SqlAnalyzer.initAnalyzerOptions(params);\n+\n+    // Set up table providers that need to be pre-registered\n+    List<List<String>> tables = analyzer.extractTableNames(sql, options);\n+    TableResolution.registerTables(this.defaultSchemaPlus, tables);\n+    SimpleCatalog catalog =\n+        analyzer.createPopulatedCatalog(defaultSchemaPlus.getName(), options, tables);\n+\n+    ImmutableMap.Builder<String, ResolvedCreateFunctionStmt> udfBuilder = ImmutableMap.builder();\n+\n+    ResolvedStatement statement;\n+    ParseResumeLocation parseResumeLocation = new ParseResumeLocation(sql);\n+    do {\n+      statement = analyzer.analyzeNextStatement(parseResumeLocation, options, catalog);\n+      if (statement.nodeKind() == RESOLVED_CREATE_FUNCTION_STMT) {\n+        ResolvedCreateFunctionStmt createFunctionStmt = (ResolvedCreateFunctionStmt) statement;\n+        // ResolvedCreateFunctionStmt does not include the full function name, so build it here.\n+        String functionFullName =\n+            String.format(\n+                \"%s:%s\",\n+                SqlAnalyzer.USER_DEFINED_FUNCTIONS,\n+                String.join(\".\", createFunctionStmt.getNamePath()));\n+        udfBuilder.put(functionFullName, createFunctionStmt);\n+      } else if (statement.nodeKind() == RESOLVED_QUERY_STMT) {\n+        if (!SqlAnalyzer.isEndOfInput(parseResumeLocation)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ef98800152be68217ddeae3260a6c88da68b133"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNDgyNQ==", "bodyText": "This is really checking \"No additional statements are allowed after a SELECT statement.\"", "url": "https://github.com/apache/beam/pull/12153#discussion_r448614825", "createdAt": "2020-07-01T21:03:08Z", "author": {"login": "ibzib"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLPlannerImpl.java", "diffHunk": "@@ -130,30 +135,58 @@ public RelRoot rel(SqlNode sqlNode) throws RelConversionException {\n   }\n \n   public RelRoot rel(String sql, QueryParameters params) {\n-    this.cluster = RelOptCluster.create(planner, new RexBuilder(typeFactory));\n-    this.expressionConverter = new ExpressionConverter(cluster, params);\n+    RelOptCluster cluster = RelOptCluster.create(planner, new RexBuilder(typeFactory));\n \n     QueryTrait trait = new QueryTrait();\n \n-    // Set up table providers that need to be pre-registered\n-    // TODO(https://issues.apache.org/jira/browse/BEAM-8817): share this logic between dialects\n-    List<List<String>> tables = Analyzer.extractTableNamesFromStatement(sql);\n-    TableResolution.registerTables(this.defaultSchemaPlus, tables);\n-\n-    ResolvedStatement statement =\n+    SqlAnalyzer analyzer =\n         SqlAnalyzer.getBuilder()\n             .withQueryParams(params)\n             .withQueryTrait(trait)\n             .withCalciteContext(config.getContext())\n             .withTopLevelSchema(defaultSchemaPlus)\n             .withTypeFactory((JavaTypeFactory) cluster.getTypeFactory())\n-            .analyze(sql);\n+            .build();\n+\n+    AnalyzerOptions options = SqlAnalyzer.initAnalyzerOptions(params);\n+\n+    // Set up table providers that need to be pre-registered\n+    List<List<String>> tables = analyzer.extractTableNames(sql, options);\n+    TableResolution.registerTables(this.defaultSchemaPlus, tables);\n+    SimpleCatalog catalog =\n+        analyzer.createPopulatedCatalog(defaultSchemaPlus.getName(), options, tables);\n+\n+    ImmutableMap.Builder<String, ResolvedCreateFunctionStmt> udfBuilder = ImmutableMap.builder();\n+\n+    ResolvedStatement statement;\n+    ParseResumeLocation parseResumeLocation = new ParseResumeLocation(sql);\n+    do {\n+      statement = analyzer.analyzeNextStatement(parseResumeLocation, options, catalog);\n+      if (statement.nodeKind() == RESOLVED_CREATE_FUNCTION_STMT) {\n+        ResolvedCreateFunctionStmt createFunctionStmt = (ResolvedCreateFunctionStmt) statement;\n+        // ResolvedCreateFunctionStmt does not include the full function name, so build it here.\n+        String functionFullName =\n+            String.format(\n+                \"%s:%s\",\n+                SqlAnalyzer.USER_DEFINED_FUNCTIONS,\n+                String.join(\".\", createFunctionStmt.getNamePath()));\n+        udfBuilder.put(functionFullName, createFunctionStmt);\n+      } else if (statement.nodeKind() == RESOLVED_QUERY_STMT) {\n+        if (!SqlAnalyzer.isEndOfInput(parseResumeLocation)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0NzA0MA=="}, "originalCommit": {"oid": "5ef98800152be68217ddeae3260a6c88da68b133"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNTg1NQ==", "bodyText": "+1", "url": "https://github.com/apache/beam/pull/12153#discussion_r448615855", "createdAt": "2020-07-01T21:05:38Z", "author": {"login": "amaliujia"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLPlannerImpl.java", "diffHunk": "@@ -130,30 +135,58 @@ public RelRoot rel(SqlNode sqlNode) throws RelConversionException {\n   }\n \n   public RelRoot rel(String sql, QueryParameters params) {\n-    this.cluster = RelOptCluster.create(planner, new RexBuilder(typeFactory));\n-    this.expressionConverter = new ExpressionConverter(cluster, params);\n+    RelOptCluster cluster = RelOptCluster.create(planner, new RexBuilder(typeFactory));\n \n     QueryTrait trait = new QueryTrait();\n \n-    // Set up table providers that need to be pre-registered\n-    // TODO(https://issues.apache.org/jira/browse/BEAM-8817): share this logic between dialects\n-    List<List<String>> tables = Analyzer.extractTableNamesFromStatement(sql);\n-    TableResolution.registerTables(this.defaultSchemaPlus, tables);\n-\n-    ResolvedStatement statement =\n+    SqlAnalyzer analyzer =\n         SqlAnalyzer.getBuilder()\n             .withQueryParams(params)\n             .withQueryTrait(trait)\n             .withCalciteContext(config.getContext())\n             .withTopLevelSchema(defaultSchemaPlus)\n             .withTypeFactory((JavaTypeFactory) cluster.getTypeFactory())\n-            .analyze(sql);\n+            .build();\n+\n+    AnalyzerOptions options = SqlAnalyzer.initAnalyzerOptions(params);\n+\n+    // Set up table providers that need to be pre-registered\n+    List<List<String>> tables = analyzer.extractTableNames(sql, options);\n+    TableResolution.registerTables(this.defaultSchemaPlus, tables);\n+    SimpleCatalog catalog =\n+        analyzer.createPopulatedCatalog(defaultSchemaPlus.getName(), options, tables);\n+\n+    ImmutableMap.Builder<String, ResolvedCreateFunctionStmt> udfBuilder = ImmutableMap.builder();\n+\n+    ResolvedStatement statement;\n+    ParseResumeLocation parseResumeLocation = new ParseResumeLocation(sql);\n+    do {\n+      statement = analyzer.analyzeNextStatement(parseResumeLocation, options, catalog);\n+      if (statement.nodeKind() == RESOLVED_CREATE_FUNCTION_STMT) {\n+        ResolvedCreateFunctionStmt createFunctionStmt = (ResolvedCreateFunctionStmt) statement;\n+        // ResolvedCreateFunctionStmt does not include the full function name, so build it here.\n+        String functionFullName =\n+            String.format(\n+                \"%s:%s\",\n+                SqlAnalyzer.USER_DEFINED_FUNCTIONS,\n+                String.join(\".\", createFunctionStmt.getNamePath()));\n+        udfBuilder.put(functionFullName, createFunctionStmt);\n+      } else if (statement.nodeKind() == RESOLVED_QUERY_STMT) {\n+        if (!SqlAnalyzer.isEndOfInput(parseResumeLocation)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0NzA0MA=="}, "originalCommit": {"oid": "5ef98800152be68217ddeae3260a6c88da68b133"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NTcxNzc2OnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODozNzozOFrOGrxMlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMToxMTo1MFrOGr1gEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0Nzk5MQ==", "bodyText": "Do you think for Java UDF, will this code path help?", "url": "https://github.com/apache/beam/pull/12153#discussion_r448547991", "createdAt": "2020-07-01T18:37:38Z", "author": {"login": "amaliujia"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -920,8 +946,23 @@ private RexNode convertResolvedFunctionCall(\n       }\n \n       for (ResolvedExpr expr : functionCall.getArgumentList()) {\n-        operands.add(convertRexNodeFromResolvedExpr(expr, columnList, fieldList));\n+        operands.add(\n+            convertRexNodeFromResolvedExpr(expr, columnList, fieldList, outerFunctionArguments));\n+      }\n+    } else if (funGroup.equals(USER_DEFINED_FUNCTIONS)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ef98800152be68217ddeae3260a6c88da68b133"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMzMxOQ==", "bodyText": "I am pretty sure we will need it, unless we can somehow avoid ExpressionConverter for Java UDF?", "url": "https://github.com/apache/beam/pull/12153#discussion_r448613319", "createdAt": "2020-07-01T20:59:38Z", "author": {"login": "ibzib"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -920,8 +946,23 @@ private RexNode convertResolvedFunctionCall(\n       }\n \n       for (ResolvedExpr expr : functionCall.getArgumentList()) {\n-        operands.add(convertRexNodeFromResolvedExpr(expr, columnList, fieldList));\n+        operands.add(\n+            convertRexNodeFromResolvedExpr(expr, columnList, fieldList, outerFunctionArguments));\n+      }\n+    } else if (funGroup.equals(USER_DEFINED_FUNCTIONS)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0Nzk5MQ=="}, "originalCommit": {"oid": "5ef98800152be68217ddeae3260a6c88da68b133"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxODUxNQ==", "bodyText": "I see. For Java UDF (without a nested call), it might not go through the process to convert every of its arguments. But for nested call cases, especially with builtin functions, it could go through this process.\nWe can keep current implementation in this PR now.", "url": "https://github.com/apache/beam/pull/12153#discussion_r448618515", "createdAt": "2020-07-01T21:11:50Z", "author": {"login": "amaliujia"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -920,8 +946,23 @@ private RexNode convertResolvedFunctionCall(\n       }\n \n       for (ResolvedExpr expr : functionCall.getArgumentList()) {\n-        operands.add(convertRexNodeFromResolvedExpr(expr, columnList, fieldList));\n+        operands.add(\n+            convertRexNodeFromResolvedExpr(expr, columnList, fieldList, outerFunctionArguments));\n+      }\n+    } else if (funGroup.equals(USER_DEFINED_FUNCTIONS)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0Nzk5MQ=="}, "originalCommit": {"oid": "5ef98800152be68217ddeae3260a6c88da68b133"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NjE2NjY3OnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/zetasql/src/test/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLDialectSpecTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMToxNDoxN1rOGr1j_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMToxOTozNVrOGr1s6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxOTUxOQ==", "bodyText": "You will need to update this error message.", "url": "https://github.com/apache/beam/pull/12153#discussion_r448619519", "createdAt": "2020-07-01T21:14:17Z", "author": {"login": "amaliujia"}, "path": "sdks/java/extensions/sql/zetasql/src/test/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLDialectSpecTest.java", "diffHunk": "@@ -2841,6 +2842,131 @@ public void testSelectNullExceptAll() {\n     pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n   }\n \n+  @Test\n+  public void testMultipleSelectStatementsThrowsException() {\n+    String sql = \"SELECT 1; SELECT 2;\";\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    thrown.expect(UnsupportedOperationException.class);\n+    thrown.expectMessage(\n+        \"Statement list must end in a SELECT statement, and cannot contain more than one SELECT statement.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4421bca06243488b18778ea33bfed3868e0f780f"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYyMTgwMg==", "bodyText": "Oops, fixed", "url": "https://github.com/apache/beam/pull/12153#discussion_r448621802", "createdAt": "2020-07-01T21:19:35Z", "author": {"login": "ibzib"}, "path": "sdks/java/extensions/sql/zetasql/src/test/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLDialectSpecTest.java", "diffHunk": "@@ -2841,6 +2842,131 @@ public void testSelectNullExceptAll() {\n     pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n   }\n \n+  @Test\n+  public void testMultipleSelectStatementsThrowsException() {\n+    String sql = \"SELECT 1; SELECT 2;\";\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    thrown.expect(UnsupportedOperationException.class);\n+    thrown.expectMessage(\n+        \"Statement list must end in a SELECT statement, and cannot contain more than one SELECT statement.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxOTUxOQ=="}, "originalCommit": {"oid": "4421bca06243488b18778ea33bfed3868e0f780f"}, "originalPosition": 18}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3441, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}