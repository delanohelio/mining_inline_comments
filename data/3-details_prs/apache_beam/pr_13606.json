{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ0NjkzMjM3", "number": 13606, "title": "[BEAM-11519] Adding PYPI_INSTALL_REQ role and SDK container support", "bodyText": "Please add a meaningful description for your change here\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nDataflow\nFlink\nSamza\nSpark\nTwister2\n\n\n\n\nGo\n\n---\n\n---\n\n---\n\n\nJava\n\n\n\n\n\n\n\n\nPython\n\n\n\n---\n\n---\n\n\nXLang\n\n\n\n---\n\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\nWhitespace\nTypescript\n\n\n\n\nNon-portable\n\n \n\n\n\n\n\n\nPortable\n---\n\n---\n---\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.\nGitHub Actions Tests Status (on master branch)\n\n\n\nSee CI.md for more information about GitHub Actions CI.", "createdAt": "2020-12-23T10:15:11Z", "url": "https://github.com/apache/beam/pull/13606", "merged": true, "mergeCommit": {"oid": "cb52848db64f226d9b47b1c11eeb7b548af18e09"}, "closed": true, "closedAt": "2021-02-04T05:40:14Z", "author": {"login": "ihji"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdpGEUugBqjQxNDU1Nzc1ODY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABd2sAOigH2gAyNTQ0NjkzMjM3OjcxNWJjZDBmMDZmZTJhMTBjMDc2NTA4NjU1MzI1MmExYjhkOTk2NDg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0963a94f1fbba8c50a0c5dbbdb90e6df9c96c304", "author": {"user": {"login": "ihji", "name": "Heejong Lee"}}, "url": "https://github.com/apache/beam/commit/0963a94f1fbba8c50a0c5dbbdb90e6df9c96c304", "committedDate": "2020-12-23T08:57:54Z", "message": "[BEAM-11519] Adding PYPI_INSTALL_REQ role and SDK container support"}, "afterCommit": {"oid": "020d175a59e009dc700a6792cbe9b8e5f97128dc", "author": {"user": {"login": "ihji", "name": "Heejong Lee"}}, "url": "https://github.com/apache/beam/commit/020d175a59e009dc700a6792cbe9b8e5f97128dc", "committedDate": "2020-12-23T21:32:00Z", "message": "[BEAM-11519] Adding PYPI_INSTALL_REQ role and SDK container support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8da6a6c3b30a4d64a4f920021f98dbbfb16172d6", "author": {"user": {"login": "ihji", "name": "Heejong Lee"}}, "url": "https://github.com/apache/beam/commit/8da6a6c3b30a4d64a4f920021f98dbbfb16172d6", "committedDate": "2021-01-09T04:18:15Z", "message": "[BEAM-11519] Adding PYPI_INSTALL_REQ role and SDK container support"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "020d175a59e009dc700a6792cbe9b8e5f97128dc", "author": {"user": {"login": "ihji", "name": "Heejong Lee"}}, "url": "https://github.com/apache/beam/commit/020d175a59e009dc700a6792cbe9b8e5f97128dc", "committedDate": "2020-12-23T21:32:00Z", "message": "[BEAM-11519] Adding PYPI_INSTALL_REQ role and SDK container support"}, "afterCommit": {"oid": "8da6a6c3b30a4d64a4f920021f98dbbfb16172d6", "author": {"user": {"login": "ihji", "name": "Heejong Lee"}}, "url": "https://github.com/apache/beam/commit/8da6a6c3b30a4d64a4f920021f98dbbfb16172d6", "committedDate": "2021-01-09T04:18:15Z", "message": "[BEAM-11519] Adding PYPI_INSTALL_REQ role and SDK container support"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3NzI4NDU3", "url": "https://github.com/apache/beam/pull/13606#pullrequestreview-567728457", "createdAt": "2021-01-13T23:01:08Z", "commit": {"oid": "8da6a6c3b30a4d64a4f920021f98dbbfb16172d6"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMzowMTowOFrOITIlng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMzowMTowOFrOITIlng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzNDU1OA==", "bodyText": "Please move this line to just above the generateId function. Go style doesn't require package variables to be declared at the top of the file.\nPlease also add a comment why we need a global counter variable.", "url": "https://github.com/apache/beam/pull/13606#discussion_r556934558", "createdAt": "2021-01-13T23:01:08Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/artifact/materialize.go", "diffHunk": "@@ -39,27 +42,31 @@ import (\n \n // TODO(lostluck): 2018/05/28 Extract these from their enum descriptors in the pipeline_v1 proto\n const (\n+\tURNFileArtifact   = \"beam:artifact:type:file:v1\"\n+\tURNPypiInstallReq = \"beam:artifact:role:pypi_install_req:v1\"\n \tURNStagingTo      = \"beam:artifact:role:staging_to:v1\"\n \tNoArtifactsStaged = \"__no_artifacts_staged__\"\n )\n \n+var idCounter uint64", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8da6a6c3b30a4d64a4f920021f98dbbfb16172d6"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7cb569183d96ed6461a3dca6d72980d98edcbede", "author": {"user": {"login": "ihji", "name": "Heejong Lee"}}, "url": "https://github.com/apache/beam/commit/7cb569183d96ed6461a3dca6d72980d98edcbede", "committedDate": "2021-01-14T21:29:31Z", "message": "move idCounter variable and add comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcxNTUyMjQy", "url": "https://github.com/apache/beam/pull/13606#pullrequestreview-571552242", "createdAt": "2021-01-19T18:55:15Z", "commit": {"oid": "7cb569183d96ed6461a3dca6d72980d98edcbede"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxODo1NToxNVrOIWcqpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxOTowODo0OFrOIWdLmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQwOTI1NQ==", "bodyText": "Let's spell out requirements here.", "url": "https://github.com/apache/beam/pull/13606#discussion_r560409255", "createdAt": "2021-01-19T18:55:15Z", "author": {"login": "robertwb"}, "path": "model/pipeline/src/main/proto/beam_runner_api.proto", "diffHunk": "@@ -1342,7 +1342,11 @@ message StandardArtifacts {\n   enum Roles {\n     // A URN for staging-to role.\n     // payload: ArtifactStagingToRolePayload\n-    STAGING_TO  = 0 [(beam_urn) = \"beam:artifact:role:staging_to:v1\"];\n+    STAGING_TO        = 0 [(beam_urn) = \"beam:artifact:role:staging_to:v1\"];\n+\n+    // A URN for pypi-install-req role.\n+    // payload: None\n+    PYPI_INSTALL_REQ  = 1 [(beam_urn) = \"beam:artifact:role:pypi_install_req:v1\"];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cb569183d96ed6461a3dca6d72980d98edcbede"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQxMTc0Ng==", "bodyText": "Nit: I'd put this case, which is kind of like a default/everything else, last. Also, do we know this always works, or should we throw an error on unknown types?", "url": "https://github.com/apache/beam/pull/13606#discussion_r560411746", "createdAt": "2021-01-19T18:59:01Z", "author": {"login": "robertwb"}, "path": "sdks/go/pkg/beam/artifact/materialize.go", "diffHunk": "@@ -69,41 +74,100 @@ func newMaterialize(ctx context.Context, endpoint string, dependencies []*pipepb\n \treturn newMaterializeWithClient(ctx, jobpb.NewArtifactRetrievalServiceClient(cc), dependencies, dest)\n }\n \n-func newMaterializeWithClient(ctx context.Context, client jobpb.ArtifactRetrievalServiceClient, dependencies []*pipepb.ArtifactInformation, dest string) ([]*jobpb.ArtifactMetadata, error) {\n+func newMaterializeWithClient(ctx context.Context, client jobpb.ArtifactRetrievalServiceClient, dependencies []*pipepb.ArtifactInformation, dest string) ([]*pipepb.ArtifactInformation, error) {\n \tresolution, err := client.ResolveArtifacts(ctx, &jobpb.ResolveArtifactsRequest{Artifacts: dependencies})\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tvar md []*jobpb.ArtifactMetadata\n+\tvar artifacts []*pipepb.ArtifactInformation\n \tvar list []retrievable\n \tfor _, dep := range resolution.Replacements {\n \t\tpath, err := extractStagingToPath(dep)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tmd = append(md, &jobpb.ArtifactMetadata{\n-\t\t\tName: path,\n+\t\tvar filePayload pipepb.ArtifactFilePayload\n+\t\tif dep.TypeUrn != URNFileArtifact {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cb569183d96ed6461a3dca6d72980d98edcbede"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQxNDUzOA==", "bodyText": "Actually, this might be clearer constructing filePayload unconditionally based on Path, and then iff TypeUrn is URNFileArtifact, additionally setting the Sha256 attribute, if any.", "url": "https://github.com/apache/beam/pull/13606#discussion_r560414538", "createdAt": "2021-01-19T19:03:30Z", "author": {"login": "robertwb"}, "path": "sdks/go/pkg/beam/artifact/materialize.go", "diffHunk": "@@ -69,41 +74,100 @@ func newMaterialize(ctx context.Context, endpoint string, dependencies []*pipepb\n \treturn newMaterializeWithClient(ctx, jobpb.NewArtifactRetrievalServiceClient(cc), dependencies, dest)\n }\n \n-func newMaterializeWithClient(ctx context.Context, client jobpb.ArtifactRetrievalServiceClient, dependencies []*pipepb.ArtifactInformation, dest string) ([]*jobpb.ArtifactMetadata, error) {\n+func newMaterializeWithClient(ctx context.Context, client jobpb.ArtifactRetrievalServiceClient, dependencies []*pipepb.ArtifactInformation, dest string) ([]*pipepb.ArtifactInformation, error) {\n \tresolution, err := client.ResolveArtifacts(ctx, &jobpb.ResolveArtifactsRequest{Artifacts: dependencies})\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tvar md []*jobpb.ArtifactMetadata\n+\tvar artifacts []*pipepb.ArtifactInformation\n \tvar list []retrievable\n \tfor _, dep := range resolution.Replacements {\n \t\tpath, err := extractStagingToPath(dep)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tmd = append(md, &jobpb.ArtifactMetadata{\n-\t\t\tName: path,\n+\t\tvar filePayload pipepb.ArtifactFilePayload\n+\t\tif dep.TypeUrn != URNFileArtifact {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQxMTc0Ng=="}, "originalCommit": {"oid": "7cb569183d96ed6461a3dca6d72980d98edcbede"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQxNjI4Ng==", "bodyText": "Guard this with artifact.TypeUrn is URNFileArtifact? And a final else that's an error?", "url": "https://github.com/apache/beam/pull/13606#discussion_r560416286", "createdAt": "2021-01-19T19:06:22Z", "author": {"login": "robertwb"}, "path": "sdks/go/pkg/beam/artifact/materialize.go", "diffHunk": "@@ -69,41 +74,100 @@ func newMaterialize(ctx context.Context, endpoint string, dependencies []*pipepb\n \treturn newMaterializeWithClient(ctx, jobpb.NewArtifactRetrievalServiceClient(cc), dependencies, dest)\n }\n \n-func newMaterializeWithClient(ctx context.Context, client jobpb.ArtifactRetrievalServiceClient, dependencies []*pipepb.ArtifactInformation, dest string) ([]*jobpb.ArtifactMetadata, error) {\n+func newMaterializeWithClient(ctx context.Context, client jobpb.ArtifactRetrievalServiceClient, dependencies []*pipepb.ArtifactInformation, dest string) ([]*pipepb.ArtifactInformation, error) {\n \tresolution, err := client.ResolveArtifacts(ctx, &jobpb.ResolveArtifactsRequest{Artifacts: dependencies})\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tvar md []*jobpb.ArtifactMetadata\n+\tvar artifacts []*pipepb.ArtifactInformation\n \tvar list []retrievable\n \tfor _, dep := range resolution.Replacements {\n \t\tpath, err := extractStagingToPath(dep)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tmd = append(md, &jobpb.ArtifactMetadata{\n-\t\t\tName: path,\n+\t\tvar filePayload pipepb.ArtifactFilePayload\n+\t\tif dep.TypeUrn != URNFileArtifact {\n+\t\t\tfilePayload = pipepb.ArtifactFilePayload{\n+\t\t\t\tPath: path,\n+\t\t\t}\n+\t\t} else {\n+\t\t\ttypePayload := pipepb.ArtifactFilePayload{}\n+\t\t\tif err := proto.Unmarshal(dep.TypePayload, &typePayload); err != nil {\n+\t\t\t\treturn nil, errors.Wrap(err, \"failed to parse artifact file payload\")\n+\t\t\t}\n+\t\t\tfilePayload = pipepb.ArtifactFilePayload{\n+\t\t\t\tPath:   path,\n+\t\t\t\tSha256: typePayload.Sha256,\n+\t\t\t}\n+\t\t}\n+\t\tnewTypePayload, err := proto.Marshal(&filePayload)\n+\t\tif err != nil {\n+\t\t\treturn nil, errors.Wrap(err, \"failed to create artifact type payload\")\n+\t\t}\n+\t\tartifacts = append(artifacts, &pipepb.ArtifactInformation{\n+\t\t\tTypeUrn:     URNFileArtifact,\n+\t\t\tTypePayload: newTypePayload,\n+\t\t\tRoleUrn:     dep.RoleUrn,\n+\t\t\tRolePayload: dep.RolePayload,\n \t\t})\n \n+\t\trolePayload, err := proto.Marshal(&pipepb.ArtifactStagingToRolePayload{\n+\t\t\tStagedName: path,\n+\t\t})\n+\t\tif err != nil {\n+\t\t\treturn nil, errors.Wrap(err, \"failed to create artifact role payload\")\n+\t\t}\n \t\tlist = append(list, &artifact{\n \t\t\tclient: client,\n-\t\t\tdep:    dep,\n+\t\t\tdep: &pipepb.ArtifactInformation{\n+\t\t\t\tTypeUrn:     dep.TypeUrn,\n+\t\t\t\tTypePayload: dep.TypePayload,\n+\t\t\t\tRoleUrn:     URNStagingTo,\n+\t\t\t\tRolePayload: rolePayload,\n+\t\t\t},\n \t\t})\n \t}\n \n-\treturn md, MultiRetrieve(ctx, 10, list, dest)\n+\treturn artifacts, MultiRetrieve(ctx, 10, list, dest)\n+}\n+\n+// Used for generating unique IDs. We assign uniquely generated names to staged files without staging names.\n+var idCounter uint64\n+\n+func generateId() string {\n+\tid := atomic.AddUint64(&idCounter, 1)\n+\treturn strconv.FormatUint(id, 10)\n }\n \n func extractStagingToPath(artifact *pipepb.ArtifactInformation) (string, error) {\n-\tif artifact.RoleUrn != URNStagingTo {\n-\t\treturn \"\", errors.Errorf(\"Unsupported artifact role %s\", artifact.RoleUrn)\n+\tvar stagedName string\n+\tif artifact.RoleUrn == URNStagingTo {\n+\t\trole := pipepb.ArtifactStagingToRolePayload{}\n+\t\tif err := proto.Unmarshal(artifact.RolePayload, &role); err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tstagedName = role.StagedName\n+\t} else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cb569183d96ed6461a3dca6d72980d98edcbede"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQxNzY5MQ==", "bodyText": "Do you know what the state is of getting rid of the legacy protocol altogether?", "url": "https://github.com/apache/beam/pull/13606#discussion_r560417691", "createdAt": "2021-01-19T19:08:48Z", "author": {"login": "robertwb"}, "path": "sdks/go/pkg/beam/artifact/materialize.go", "diffHunk": "@@ -172,7 +236,7 @@ func writeChunks(stream jobpb.ArtifactRetrievalService_GetArtifactClient, w io.W\n \treturn nil\n }\n \n-func legacyMaterialize(ctx context.Context, endpoint string, rt string, dest string) ([]*jobpb.ArtifactMetadata, error) {\n+func legacyMaterialize(ctx context.Context, endpoint string, rt string, dest string) ([]*pipepb.ArtifactInformation, error) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cb569183d96ed6461a3dca6d72980d98edcbede"}, "originalPosition": 163}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcxNjAwODE1", "url": "https://github.com/apache/beam/pull/13606#pullrequestreview-571600815", "createdAt": "2021-01-19T19:59:21Z", "commit": {"oid": "7cb569183d96ed6461a3dca6d72980d98edcbede"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxOTo1OToyMVrOIWfC1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxOTo1OToyMVrOIWfC1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQ0ODIxMg==", "bodyText": "Perhaps for compactness?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tvar filePayload pipepb.ArtifactFilePayload\n          \n          \n            \n            \t\tif dep.TypeUrn != URNFileArtifact {\n          \n          \n            \n            \t\t\tfilePayload = pipepb.ArtifactFilePayload{\n          \n          \n            \n            \t\t\t\tPath: path,\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t} else {\n          \n          \n            \n            \t\t\ttypePayload := pipepb.ArtifactFilePayload{}\n          \n          \n            \n            \t\t\tif err := proto.Unmarshal(dep.TypePayload, &typePayload); err != nil {\n          \n          \n            \n            \t\t\t\treturn nil, errors.Wrap(err, \"failed to parse artifact file payload\")\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t\tfilePayload = pipepb.ArtifactFilePayload{\n          \n          \n            \n            \t\t\t\tPath:   path,\n          \n          \n            \n            \t\t\t\tSha256: typePayload.Sha256,\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tfilePayload := pipepb.ArtifactFilePayload{\n          \n          \n            \n            \t\t\t\tPath: path,\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tif dep.TypeUrn == URNFileArtifact {\n          \n          \n            \n            \t\t\ttypePayload := pipepb.ArtifactFilePayload{}\n          \n          \n            \n            \t\t\tif err := proto.Unmarshal(dep.TypePayload, &typePayload); err != nil {\n          \n          \n            \n            \t\t\t\treturn nil, errors.Wrap(err, \"failed to parse artifact file payload\")\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t\tfilePayload.Sha256 = typePayload.Sha256\n          \n          \n            \n            \t\t}\n          \n      \n    \n    \n  \n\nIf you'd like me go go full readability on you, WRT protos, it's the same either way whether you pre-declare as a pointer type or not. You do not need to dereference to access fields on a pointer to a struct, and escape analysis will determine whether to allocate values to the heap, regardless of if they are pointers or not. If a pointer value never escapes the stack, then it will be stack allocated.\nSo the following is identical.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tvar filePayload pipepb.ArtifactFilePayload\n          \n          \n            \n            \t\tif dep.TypeUrn != URNFileArtifact {\n          \n          \n            \n            \t\t\tfilePayload = pipepb.ArtifactFilePayload{\n          \n          \n            \n            \t\t\t\tPath: path,\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t} else {\n          \n          \n            \n            \t\t\ttypePayload := pipepb.ArtifactFilePayload{}\n          \n          \n            \n            \t\t\tif err := proto.Unmarshal(dep.TypePayload, &typePayload); err != nil {\n          \n          \n            \n            \t\t\t\treturn nil, errors.Wrap(err, \"failed to parse artifact file payload\")\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t\tfilePayload = pipepb.ArtifactFilePayload{\n          \n          \n            \n            \t\t\t\tPath:   path,\n          \n          \n            \n            \t\t\t\tSha256: typePayload.Sha256,\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tfilePayload := &pipepb.ArtifactFilePayload{\n          \n          \n            \n            \t\t\t\tPath: path,\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tif dep.TypeUrn == URNFileArtifact {\n          \n          \n            \n            \t\t\ttypePayload := &pipepb.ArtifactFilePayload{}\n          \n          \n            \n            \t\t\tif err := proto.Unmarshal(dep.TypePayload, typePayload); err != nil {\n          \n          \n            \n            \t\t\t\treturn nil, errors.Wrap(err, \"failed to parse artifact file payload\")\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t\tfilePayload.Sha256 = typePayload.Sha256\n          \n          \n            \n            \t\t}\n          \n      \n    \n    \n  \n\n(though the remaining &s will need to be removed as appropriate.", "url": "https://github.com/apache/beam/pull/13606#discussion_r560448212", "createdAt": "2021-01-19T19:59:21Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/artifact/materialize.go", "diffHunk": "@@ -69,41 +74,100 @@ func newMaterialize(ctx context.Context, endpoint string, dependencies []*pipepb\n \treturn newMaterializeWithClient(ctx, jobpb.NewArtifactRetrievalServiceClient(cc), dependencies, dest)\n }\n \n-func newMaterializeWithClient(ctx context.Context, client jobpb.ArtifactRetrievalServiceClient, dependencies []*pipepb.ArtifactInformation, dest string) ([]*jobpb.ArtifactMetadata, error) {\n+func newMaterializeWithClient(ctx context.Context, client jobpb.ArtifactRetrievalServiceClient, dependencies []*pipepb.ArtifactInformation, dest string) ([]*pipepb.ArtifactInformation, error) {\n \tresolution, err := client.ResolveArtifacts(ctx, &jobpb.ResolveArtifactsRequest{Artifacts: dependencies})\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tvar md []*jobpb.ArtifactMetadata\n+\tvar artifacts []*pipepb.ArtifactInformation\n \tvar list []retrievable\n \tfor _, dep := range resolution.Replacements {\n \t\tpath, err := extractStagingToPath(dep)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tmd = append(md, &jobpb.ArtifactMetadata{\n-\t\t\tName: path,\n+\t\tvar filePayload pipepb.ArtifactFilePayload\n+\t\tif dep.TypeUrn != URNFileArtifact {\n+\t\t\tfilePayload = pipepb.ArtifactFilePayload{\n+\t\t\t\tPath: path,\n+\t\t\t}\n+\t\t} else {\n+\t\t\ttypePayload := pipepb.ArtifactFilePayload{}\n+\t\t\tif err := proto.Unmarshal(dep.TypePayload, &typePayload); err != nil {\n+\t\t\t\treturn nil, errors.Wrap(err, \"failed to parse artifact file payload\")\n+\t\t\t}\n+\t\t\tfilePayload = pipepb.ArtifactFilePayload{\n+\t\t\t\tPath:   path,\n+\t\t\t\tSha256: typePayload.Sha256,\n+\t\t\t}\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cb569183d96ed6461a3dca6d72980d98edcbede"}, "originalPosition": 80}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2b7fbafb5020aa6b96fbc7cfcc70422facbd063", "author": {"user": {"login": "ihji", "name": "Heejong Lee"}}, "url": "https://github.com/apache/beam/commit/c2b7fbafb5020aa6b96fbc7cfcc70422facbd063", "committedDate": "2021-01-23T00:55:13Z", "message": "simplify the branches, change _req to _requirement"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgyOTY4Njk3", "url": "https://github.com/apache/beam/pull/13606#pullrequestreview-582968697", "createdAt": "2021-02-04T01:48:16Z", "commit": {"oid": "c2b7fbafb5020aa6b96fbc7cfcc70422facbd063"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQwMTo0ODoxN1rOIffCcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQwMTo0ODoxN1rOIffCcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTg4NTI5Nw==", "bodyText": "It's unclear here whether this is for requirements.txt files or actual tarballs that should be installed.\nCould we call this either PYTHON_PACKAGES or PIP_REQUIREMENTS_FILE?", "url": "https://github.com/apache/beam/pull/13606#discussion_r569885297", "createdAt": "2021-02-04T01:48:17Z", "author": {"login": "robertwb"}, "path": "model/pipeline/src/main/proto/beam_runner_api.proto", "diffHunk": "@@ -1342,7 +1342,11 @@ message StandardArtifacts {\n   enum Roles {\n     // A URN for staging-to role.\n     // payload: ArtifactStagingToRolePayload\n-    STAGING_TO  = 0 [(beam_urn) = \"beam:artifact:role:staging_to:v1\"];\n+    STAGING_TO        = 0 [(beam_urn) = \"beam:artifact:role:staging_to:v1\"];\n+\n+    // A URN for pypi-install-requirement role.\n+    // payload: None\n+    PYPI_INSTALL_REQUIREMENT  = 1 [(beam_urn) = \"beam:artifact:role:pypi_install_requirement:v1\"];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2b7fbafb5020aa6b96fbc7cfcc70422facbd063"}, "originalPosition": 9}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "715bcd0f06fe2a10c0765086553252a1b8d99648", "author": {"user": {"login": "ihji", "name": "Heejong Lee"}}, "url": "https://github.com/apache/beam/commit/715bcd0f06fe2a10c0765086553252a1b8d99648", "committedDate": "2021-02-04T03:05:13Z", "message": "change urn for pip install requirements file"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4246, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}