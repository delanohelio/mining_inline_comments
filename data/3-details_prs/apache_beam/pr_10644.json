{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1NDM3OTEx", "number": 10644, "title": "[BEAM-7427] Refactor JmsCheckpointMark to use SerializableCoder", "bodyText": "This refactoring uses JmsCheckpointMark coder compatible.\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nApex\nDataflow\nFlink\nGearpump\nSamza\nSpark\n\n\n\n\nGo\n\n---\n---\n\n---\n---\n\n\n\nJava\n\n\n\n\n\n\n\n\n\nPython\n\n---\n\n\n---\n---\n\n\n\nXLang\n---\n---\n---\n\n---\n---\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-01-21T18:02:21Z", "url": "https://github.com/apache/beam/pull/10644", "merged": true, "mergeCommit": {"oid": "0187bef0724af77c92a319a91077906892738012"}, "closed": true, "closedAt": "2020-01-28T14:50:24Z", "author": {"login": "jbonofre"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb83jOFAFqTM0NjY2MTU3MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABb-x_jeAFqTM0OTQwMzI1MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NjYxNTcx", "url": "https://github.com/apache/beam/pull/10644#pullrequestreview-346661571", "createdAt": "2020-01-22T15:10:21Z", "commit": {"oid": "1b7e4624ab1c5db7e62999caf9312669d797b757"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNToxMDoyMVrOFgfn6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNToyNToyMFrOFggMUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxNjg3Mg==", "bodyText": "This second test is not needed if you make UnboundedJmsSource#getCheckpointMarkCoder return the SerializableCoder. Also that is needed to get rid also of AvroCoder as part of these fixes.", "url": "https://github.com/apache/beam/pull/10644#discussion_r369616872", "createdAt": "2020-01-22T15:10:21Z", "author": {"login": "iemejia"}, "path": "sdks/java/io/jms/src/test/java/org/apache/beam/sdk/io/jms/JmsIOTest.java", "diffHunk": "@@ -406,6 +408,26 @@ public void testCheckpointMarkSafety() throws Exception {\n     runner.join();\n   }\n \n+  /** Test the checkpoint mark default coder, which is actually AvroCoder. */\n+  @Test\n+  public void testCheckpointMarkDefaultCoder() throws Exception {\n+    JmsIO.JmsCheckpointMark jmsCheckpointMark = new JmsIO.JmsCheckpointMark();\n+    jmsCheckpointMark.add(new ActiveMQMessage());\n+    Coder coder = new JmsIO.UnboundedJmsSource(null).getCheckpointMarkCoder();\n+    CoderProperties.coderSerializable(coder);\n+    CoderProperties.coderDecodeEncodeEqual(coder, jmsCheckpointMark);\n+  }\n+\n+  @Test\n+  public void testCheckpointMarkSerializableCoder() throws Exception {\n+    JmsIO.JmsCheckpointMark jmsCheckpointMark = new JmsIO.JmsCheckpointMark();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b7e4624ab1c5db7e62999caf9312669d797b757"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxOTIzNg==", "bodyText": "We need to add messages to the equals too.", "url": "https://github.com/apache/beam/pull/10644#discussion_r369619236", "createdAt": "2020-01-22T15:14:26Z", "author": {"login": "iemejia"}, "path": "sdks/java/io/jms/src/main/java/org/apache/beam/sdk/io/jms/JmsIO.java", "diffHunk": "@@ -404,9 +408,96 @@ private JmsIO() {}\n     T mapMessage(Message message) throws Exception;\n   }\n \n+  /**\n+   * Checkpoint for an unbounded JMS source. Consists of the JMS messages waiting to be acknowledged\n+   * and oldest pending message timestamp.\n+   */\n+  @VisibleForTesting\n+  static class JmsCheckpointMark implements UnboundedSource.CheckpointMark, Serializable {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(JmsCheckpointMark.class);\n+\n+    @VisibleForTesting Instant oldestMessageTimestamp = Instant.now();\n+    @VisibleForTesting transient List<Message> messages = new ArrayList<>();\n+\n+    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    public JmsCheckpointMark() {}\n+\n+    public void add(Message message) throws Exception {\n+      lock.writeLock().lock();\n+      try {\n+        Instant currentMessageTimestamp = new Instant(message.getJMSTimestamp());\n+        if (currentMessageTimestamp.isBefore(oldestMessageTimestamp)) {\n+          oldestMessageTimestamp = currentMessageTimestamp;\n+        }\n+        messages.add(message);\n+      } finally {\n+        lock.writeLock().unlock();\n+      }\n+    }\n+\n+    public Instant getOldestMessageTimestamp() {\n+      lock.readLock().lock();\n+      try {\n+        return this.oldestMessageTimestamp;\n+      } finally {\n+        lock.readLock().unlock();\n+      }\n+    }\n+\n+    /**\n+     * Acknowledge all outstanding message. Since we believe that messages will be delivered in\n+     * timestamp order, and acknowledged messages will not be retried, the newest message in this\n+     * batch is a good bound for future messages.\n+     */\n+    @Override\n+    public void finalizeCheckpoint() {\n+      lock.writeLock().lock();\n+      try {\n+        for (Message message : messages) {\n+          try {\n+            message.acknowledge();\n+            Instant currentMessageTimestamp = new Instant(message.getJMSTimestamp());\n+            if (currentMessageTimestamp.isAfter(oldestMessageTimestamp)) {\n+              oldestMessageTimestamp = currentMessageTimestamp;\n+            }\n+          } catch (Exception e) {\n+            LOG.error(\"Exception while finalizing message: {}\", e);\n+          }\n+        }\n+        messages.clear();\n+      } finally {\n+        lock.writeLock().unlock();\n+      }\n+    }\n+\n+    // set an empty list to messages when deserialize\n+    private void readObject(java.io.ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+      stream.defaultReadObject();\n+      messages = new ArrayList<>();\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+      if (other instanceof JmsCheckpointMark) {\n+        JmsCheckpointMark that = (JmsCheckpointMark) other;\n+        return Objects.equals(this.oldestMessageTimestamp, that.oldestMessageTimestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b7e4624ab1c5db7e62999caf9312669d797b757"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMDQ2Ng==", "bodyText": "A CheckpointMark is basically an object to save pending unprocessed state, in the case of JmsIO pending state are the messages. If we make the messages transient we are losing data. So we need to fix this to make the messages part of the serialized state of the object. However since Jms Messages are not Serializable probably what we need to store here are JmsRecords.", "url": "https://github.com/apache/beam/pull/10644#discussion_r369620466", "createdAt": "2020-01-22T15:16:19Z", "author": {"login": "iemejia"}, "path": "sdks/java/io/jms/src/main/java/org/apache/beam/sdk/io/jms/JmsIO.java", "diffHunk": "@@ -404,9 +408,96 @@ private JmsIO() {}\n     T mapMessage(Message message) throws Exception;\n   }\n \n+  /**\n+   * Checkpoint for an unbounded JMS source. Consists of the JMS messages waiting to be acknowledged\n+   * and oldest pending message timestamp.\n+   */\n+  @VisibleForTesting\n+  static class JmsCheckpointMark implements UnboundedSource.CheckpointMark, Serializable {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(JmsCheckpointMark.class);\n+\n+    @VisibleForTesting Instant oldestMessageTimestamp = Instant.now();\n+    @VisibleForTesting transient List<Message> messages = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b7e4624ab1c5db7e62999caf9312669d797b757"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMzg5NQ==", "bodyText": "Possible issue after changing the pending state to be JmsRecords is the fact that the records need to recreate Messages to be able to ack on finalizeCheckpoint. Doing ack on the CheckpointMark is probably an error because you would need also the connection information, so better to move that logick out of the CheckpointMark.", "url": "https://github.com/apache/beam/pull/10644#discussion_r369623895", "createdAt": "2020-01-22T15:21:48Z", "author": {"login": "iemejia"}, "path": "sdks/java/io/jms/src/main/java/org/apache/beam/sdk/io/jms/JmsIO.java", "diffHunk": "@@ -404,9 +408,96 @@ private JmsIO() {}\n     T mapMessage(Message message) throws Exception;\n   }\n \n+  /**\n+   * Checkpoint for an unbounded JMS source. Consists of the JMS messages waiting to be acknowledged\n+   * and oldest pending message timestamp.\n+   */\n+  @VisibleForTesting\n+  static class JmsCheckpointMark implements UnboundedSource.CheckpointMark, Serializable {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(JmsCheckpointMark.class);\n+\n+    @VisibleForTesting Instant oldestMessageTimestamp = Instant.now();\n+    @VisibleForTesting transient List<Message> messages = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMDQ2Ng=="}, "originalCommit": {"oid": "1b7e4624ab1c5db7e62999caf9312669d797b757"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyNjE5Mw==", "bodyText": "Better leave this as a separate class as it was, no? KafkaIO got splitted because it was almost unmanageable with so much code in one file, or is there a fundamental reason to do this?", "url": "https://github.com/apache/beam/pull/10644#discussion_r369626193", "createdAt": "2020-01-22T15:25:20Z", "author": {"login": "iemejia"}, "path": "sdks/java/io/jms/src/main/java/org/apache/beam/sdk/io/jms/JmsCheckpointMark.java", "diffHunk": "@@ -1,184 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.beam.sdk.io.jms;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.function.BiFunction;\n-import java.util.function.Supplier;\n-import javax.jms.Message;\n-import org.apache.beam.sdk.coders.AvroCoder;\n-import org.apache.beam.sdk.coders.DefaultCoder;\n-import org.apache.beam.sdk.io.UnboundedSource;\n-import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n-import org.joda.time.Instant;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Checkpoint for an unbounded JmsIO.Read. Consists of JMS destination name, and the latest message\n- * ID consumed so far.\n- */\n-@DefaultCoder(AvroCoder.class)\n-public class JmsCheckpointMark implements UnboundedSource.CheckpointMark {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b7e4624ab1c5db7e62999caf9312669d797b757"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NzUxMDk4", "url": "https://github.com/apache/beam/pull/10644#pullrequestreview-346751098", "createdAt": "2020-01-22T17:01:44Z", "commit": {"oid": "1b7e4624ab1c5db7e62999caf9312669d797b757"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNzowMTo0NVrOFgjyJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNzoxMjo0NFrOFgkJXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY4NTAyOA==", "bodyText": "@jbonofre  Could this logic be implemented using JmsCheckpointMark.State class as it was before? Well, for this case, at least, we need to make State serialisable but it should not be a problem with conversion from Message to JmsRecord.", "url": "https://github.com/apache/beam/pull/10644#discussion_r369685028", "createdAt": "2020-01-22T17:01:45Z", "author": {"login": "aromanenko-dev"}, "path": "sdks/java/io/jms/src/main/java/org/apache/beam/sdk/io/jms/JmsIO.java", "diffHunk": "@@ -404,9 +408,96 @@ private JmsIO() {}\n     T mapMessage(Message message) throws Exception;\n   }\n \n+  /**\n+   * Checkpoint for an unbounded JMS source. Consists of the JMS messages waiting to be acknowledged\n+   * and oldest pending message timestamp.\n+   */\n+  @VisibleForTesting\n+  static class JmsCheckpointMark implements UnboundedSource.CheckpointMark, Serializable {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(JmsCheckpointMark.class);\n+\n+    @VisibleForTesting Instant oldestMessageTimestamp = Instant.now();\n+    @VisibleForTesting transient List<Message> messages = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMDQ2Ng=="}, "originalCommit": {"oid": "1b7e4624ab1c5db7e62999caf9312669d797b757"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY4ODEzNQ==", "bodyText": "I agree with @iemejia - it would be more convenient to have JmsCheckpointMark as a separate class (as it was before).", "url": "https://github.com/apache/beam/pull/10644#discussion_r369688135", "createdAt": "2020-01-22T17:07:21Z", "author": {"login": "aromanenko-dev"}, "path": "sdks/java/io/jms/src/main/java/org/apache/beam/sdk/io/jms/JmsCheckpointMark.java", "diffHunk": "@@ -1,184 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.beam.sdk.io.jms;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.function.BiFunction;\n-import java.util.function.Supplier;\n-import javax.jms.Message;\n-import org.apache.beam.sdk.coders.AvroCoder;\n-import org.apache.beam.sdk.coders.DefaultCoder;\n-import org.apache.beam.sdk.io.UnboundedSource;\n-import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n-import org.joda.time.Instant;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Checkpoint for an unbounded JmsIO.Read. Consists of JMS destination name, and the latest message\n- * ID consumed so far.\n- */\n-@DefaultCoder(AvroCoder.class)\n-public class JmsCheckpointMark implements UnboundedSource.CheckpointMark {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyNjE5Mw=="}, "originalCommit": {"oid": "1b7e4624ab1c5db7e62999caf9312669d797b757"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5MDUwNA==", "bodyText": "Is it fine that we don't fail here in case of exception? Can it cause a data loss?", "url": "https://github.com/apache/beam/pull/10644#discussion_r369690504", "createdAt": "2020-01-22T17:11:47Z", "author": {"login": "aromanenko-dev"}, "path": "sdks/java/io/jms/src/main/java/org/apache/beam/sdk/io/jms/JmsIO.java", "diffHunk": "@@ -404,9 +408,96 @@ private JmsIO() {}\n     T mapMessage(Message message) throws Exception;\n   }\n \n+  /**\n+   * Checkpoint for an unbounded JMS source. Consists of the JMS messages waiting to be acknowledged\n+   * and oldest pending message timestamp.\n+   */\n+  @VisibleForTesting\n+  static class JmsCheckpointMark implements UnboundedSource.CheckpointMark, Serializable {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(JmsCheckpointMark.class);\n+\n+    @VisibleForTesting Instant oldestMessageTimestamp = Instant.now();\n+    @VisibleForTesting transient List<Message> messages = new ArrayList<>();\n+\n+    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    public JmsCheckpointMark() {}\n+\n+    public void add(Message message) throws Exception {\n+      lock.writeLock().lock();\n+      try {\n+        Instant currentMessageTimestamp = new Instant(message.getJMSTimestamp());\n+        if (currentMessageTimestamp.isBefore(oldestMessageTimestamp)) {\n+          oldestMessageTimestamp = currentMessageTimestamp;\n+        }\n+        messages.add(message);\n+      } finally {\n+        lock.writeLock().unlock();\n+      }\n+    }\n+\n+    public Instant getOldestMessageTimestamp() {\n+      lock.readLock().lock();\n+      try {\n+        return this.oldestMessageTimestamp;\n+      } finally {\n+        lock.readLock().unlock();\n+      }\n+    }\n+\n+    /**\n+     * Acknowledge all outstanding message. Since we believe that messages will be delivered in\n+     * timestamp order, and acknowledged messages will not be retried, the newest message in this\n+     * batch is a good bound for future messages.\n+     */\n+    @Override\n+    public void finalizeCheckpoint() {\n+      lock.writeLock().lock();\n+      try {\n+        for (Message message : messages) {\n+          try {\n+            message.acknowledge();\n+            Instant currentMessageTimestamp = new Instant(message.getJMSTimestamp());\n+            if (currentMessageTimestamp.isAfter(oldestMessageTimestamp)) {\n+              oldestMessageTimestamp = currentMessageTimestamp;\n+            }\n+          } catch (Exception e) {\n+            LOG.error(\"Exception while finalizing message: {}\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b7e4624ab1c5db7e62999caf9312669d797b757"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5MDk3NA==", "bodyText": "I'm also wondering if we can have potentially OOM here if the size of messages is large?", "url": "https://github.com/apache/beam/pull/10644#discussion_r369690974", "createdAt": "2020-01-22T17:12:44Z", "author": {"login": "aromanenko-dev"}, "path": "sdks/java/io/jms/src/main/java/org/apache/beam/sdk/io/jms/JmsIO.java", "diffHunk": "@@ -404,9 +408,96 @@ private JmsIO() {}\n     T mapMessage(Message message) throws Exception;\n   }\n \n+  /**\n+   * Checkpoint for an unbounded JMS source. Consists of the JMS messages waiting to be acknowledged\n+   * and oldest pending message timestamp.\n+   */\n+  @VisibleForTesting\n+  static class JmsCheckpointMark implements UnboundedSource.CheckpointMark, Serializable {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(JmsCheckpointMark.class);\n+\n+    @VisibleForTesting Instant oldestMessageTimestamp = Instant.now();\n+    @VisibleForTesting transient List<Message> messages = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMDQ2Ng=="}, "originalCommit": {"oid": "1b7e4624ab1c5db7e62999caf9312669d797b757"}, "originalPosition": 32}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fb94934d134709f78845020ca946a6a9ca00145e", "author": {"user": {"login": "jbonofre", "name": "Jean-Baptiste Onofr\u00e9"}}, "url": "https://github.com/apache/beam/commit/fb94934d134709f78845020ca946a6a9ca00145e", "committedDate": "2020-01-23T05:20:24Z", "message": "[BEAM-7427] Change the logic. ACK is now AUTO, allowing to store pending messages in the checkpoint mark."}, "afterCommit": {"oid": "1b7e4624ab1c5db7e62999caf9312669d797b757", "author": {"user": {"login": "jbonofre", "name": "Jean-Baptiste Onofr\u00e9"}}, "url": "https://github.com/apache/beam/commit/1b7e4624ab1c5db7e62999caf9312669d797b757", "committedDate": "2020-01-21T17:28:51Z", "message": "[BEAM-7427] Refactore JmsCheckpointMark to be usage via Coder"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f8778a996d91233d36991b5bdcf2313242f473e4", "author": {"user": {"login": "jbonofre", "name": "Jean-Baptiste Onofr\u00e9"}}, "url": "https://github.com/apache/beam/commit/f8778a996d91233d36991b5bdcf2313242f473e4", "committedDate": "2020-01-23T06:33:31Z", "message": "[BEAM-7427] Update test and use serialization coder"}, "afterCommit": {"oid": "f5c9150a8cc9bbb663ca0f92cbc0ee1668b3d2fb", "author": {"user": {"login": "jbonofre", "name": "Jean-Baptiste Onofr\u00e9"}}, "url": "https://github.com/apache/beam/commit/f5c9150a8cc9bbb663ca0f92cbc0ee1668b3d2fb", "committedDate": "2020-01-23T06:34:06Z", "message": "[BEAM-7427] Update test and use serialization coder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0187bef0724af77c92a319a91077906892738012", "author": {"user": {"login": "jbonofre", "name": "Jean-Baptiste Onofr\u00e9"}}, "url": "https://github.com/apache/beam/commit/0187bef0724af77c92a319a91077906892738012", "committedDate": "2020-01-28T13:24:35Z", "message": "[BEAM-7427] Refactore JmsCheckpointMark to be usage via Coder"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f5c9150a8cc9bbb663ca0f92cbc0ee1668b3d2fb", "author": {"user": {"login": "jbonofre", "name": "Jean-Baptiste Onofr\u00e9"}}, "url": "https://github.com/apache/beam/commit/f5c9150a8cc9bbb663ca0f92cbc0ee1668b3d2fb", "committedDate": "2020-01-23T06:34:06Z", "message": "[BEAM-7427] Update test and use serialization coder"}, "afterCommit": {"oid": "0187bef0724af77c92a319a91077906892738012", "author": {"user": {"login": "jbonofre", "name": "Jean-Baptiste Onofr\u00e9"}}, "url": "https://github.com/apache/beam/commit/0187bef0724af77c92a319a91077906892738012", "committedDate": "2020-01-28T13:24:35Z", "message": "[BEAM-7427] Refactore JmsCheckpointMark to be usage via Coder"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5NDAzMjUx", "url": "https://github.com/apache/beam/pull/10644#pullrequestreview-349403251", "createdAt": "2020-01-28T14:13:00Z", "commit": {"oid": "0187bef0724af77c92a319a91077906892738012"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3542, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}