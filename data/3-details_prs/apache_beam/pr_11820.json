{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzNDczNjMy", "number": 11820, "title": "[BEAM-10093] ZetaSql Nexmark variant", "bodyText": "Copy/paste/modify job. Split the test classes to make it easy to run just one of them. After this we can add a Jenkins run to report benchmarks.\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nApex\nDataflow\nFlink\nGearpump\nSamza\nSpark\n\n\n\n\nGo\n\n---\n---\n\n---\n---\n\n\n\nJava\n\n\n\n\n\n\n\n\n\nPython\n\n---\n\n\n---\n---\n\n\n\nXLang\n---\n---\n---\n\n---\n---\n\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-05-26T21:29:02Z", "url": "https://github.com/apache/beam/pull/11820", "merged": true, "mergeCommit": {"oid": "d4d45bff2ff010fd317c75b2dcdda61a3843f0da"}, "closed": true, "closedAt": "2020-06-10T16:29:41Z", "author": {"login": "kennknowles"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABclPefzAH2gAyNDIzNDczNjMyOjQxMDUzOTBmMTc3OWRlM2E3NzhhNjBjNDQwOGM0MzBjODFiZjhjNWM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcppjBIABqjM0MjYzMzgwNjU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4105390f1779de3a778a60c4408c430c81bf8c5c", "author": {"user": {"login": "kennknowles", "name": "Kenn Knowles"}}, "url": "https://github.com/apache/beam/commit/4105390f1779de3a778a60c4408c430c81bf8c5c", "committedDate": "2020-05-27T02:03:10Z", "message": "Split Nexmark QueryTest and SqlQueryTest for clarity"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a1c26af6de25f4a11cb5cc0e859f38365bfa0477", "author": {"user": {"login": "kennknowles", "name": "Kenn Knowles"}}, "url": "https://github.com/apache/beam/commit/a1c26af6de25f4a11cb5cc0e859f38365bfa0477", "committedDate": "2020-05-26T23:20:48Z", "message": "spotless apply to zetasql querytest"}, "afterCommit": {"oid": "ceffb998d96ba572d09d7674df41e65022391982", "author": {"user": {"login": "kennknowles", "name": "Kenn Knowles"}}, "url": "https://github.com/apache/beam/commit/ceffb998d96ba572d09d7674df41e65022391982", "committedDate": "2020-05-27T02:03:10Z", "message": "Add ZetaSQL Nexmark variant"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ceffb998d96ba572d09d7674df41e65022391982", "author": {"user": {"login": "kennknowles", "name": "Kenn Knowles"}}, "url": "https://github.com/apache/beam/commit/ceffb998d96ba572d09d7674df41e65022391982", "committedDate": "2020-05-27T02:03:10Z", "message": "Add ZetaSQL Nexmark variant"}, "afterCommit": {"oid": "40f7520dd7aa7b576f717f06c709ef87c24b595d", "author": {"user": {"login": "kennknowles", "name": "Kenn Knowles"}}, "url": "https://github.com/apache/beam/commit/40f7520dd7aa7b576f717f06c709ef87c24b595d", "committedDate": "2020-05-27T17:39:17Z", "message": "Add ZetaSQL Nexmark variant"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMTIwNDU4", "url": "https://github.com/apache/beam/pull/11820#pullrequestreview-423120458", "createdAt": "2020-06-02T23:20:58Z", "commit": {"oid": "40f7520dd7aa7b576f717f06c709ef87c24b595d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMzoyMDo1OFrOGeHGJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMzoyMDo1OFrOGeHGJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIyNjcyNA==", "bodyText": "Looking at this class and the other SQL classes, it looks like the only difference between SQL and ZetaSQL the SQL string and withQueryPlannerClass. I believe we expect that to be the case for all these queries. Can we take advantage of that and not copy the classes for ZetaSQL?\n(There are lots of ways to implement, but it seems like it would be really easy to add a factory method for each SQL dialect to the existing classes.)", "url": "https://github.com/apache/beam/pull/11820#discussion_r434226724", "createdAt": "2020-06-02T23:20:58Z", "author": {"login": "apilloud"}, "path": "sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/zetasql/ZetaSqlQuery0.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.nexmark.queries.zetasql;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.extensions.sql.SqlTransform;\n+import org.apache.beam.sdk.extensions.sql.zetasql.ZetaSQLQueryPlanner;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.nexmark.model.Bid;\n+import org.apache.beam.sdk.nexmark.model.Event;\n+import org.apache.beam.sdk.nexmark.model.Event.Type;\n+import org.apache.beam.sdk.nexmark.model.sql.SelectEvent;\n+import org.apache.beam.sdk.nexmark.queries.NexmarkQueryTransform;\n+import org.apache.beam.sdk.nexmark.queries.NexmarkQueryUtil;\n+import org.apache.beam.sdk.schemas.transforms.Convert;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.Filter;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.Row;\n+\n+/**\n+ * Query 0: Pass events through unchanged.\n+ *\n+ * <p>This measures the overhead of the Beam ZetaSql implementation and test harness like conversion\n+ * from Java model classes to Beam records.\n+ *\n+ * <p>{@link Bid} events are used here at the moment, \u00e5s they are most numerous with default\n+ * configuration.\n+ */\n+public class ZetaSqlQuery0 extends NexmarkQueryTransform<Bid> {\n+\n+  public ZetaSqlQuery0() {\n+    super(\"ZetaSqlQuery0\");\n+  }\n+\n+  @Override\n+  public PCollection<Bid> expand(PCollection<Event> allEvents) {\n+    PCollection<Row> rows =\n+        allEvents\n+            .apply(Filter.by(NexmarkQueryUtil.IS_BID))\n+            .apply(getName() + \".SelectEvent\", new SelectEvent(Type.BID));\n+\n+    return rows.apply(getName() + \".Serialize\", logBytesMetric(rows.getCoder()))\n+        .setRowSchema(rows.getSchema())\n+        .apply(\n+            SqlTransform.query(\"SELECT * FROM PCOLLECTION\")\n+                .withQueryPlannerClass(ZetaSQLQueryPlanner.class))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40f7520dd7aa7b576f717f06c709ef87c24b595d"}, "originalPosition": 68}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "40f7520dd7aa7b576f717f06c709ef87c24b595d", "author": {"user": {"login": "kennknowles", "name": "Kenn Knowles"}}, "url": "https://github.com/apache/beam/commit/40f7520dd7aa7b576f717f06c709ef87c24b595d", "committedDate": "2020-05-27T17:39:17Z", "message": "Add ZetaSQL Nexmark variant"}, "afterCommit": {"oid": "7d169d9454f22d175ad12e8dfc17922dc015b75f", "author": {"user": {"login": "kennknowles", "name": "Kenn Knowles"}}, "url": "https://github.com/apache/beam/commit/7d169d9454f22d175ad12e8dfc17922dc015b75f", "committedDate": "2020-06-05T18:21:53Z", "message": "Add ZetaSQL Nexmark variant"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NjYyMjQ4", "url": "https://github.com/apache/beam/pull/11820#pullrequestreview-425662248", "createdAt": "2020-06-05T22:27:14Z", "commit": {"oid": "7d169d9454f22d175ad12e8dfc17922dc015b75f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMjoyNzoxNFrOGf_BpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMjoyNzoxNFrOGf_BpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5MTY1Mg==", "bodyText": "Checkstyle says no on the underscore. It looks to be failing in a few other places as well.", "url": "https://github.com/apache/beam/pull/11820#discussion_r436191652", "createdAt": "2020-06-05T22:27:14Z", "author": {"login": "apilloud"}, "path": "sdks/java/testing/nexmark/src/test/java/org/apache/beam/sdk/nexmark/queries/sql/SqlBoundedSideInputJoinTest.java", "diffHunk": "@@ -48,166 +47,182 @@\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.experimental.categories.Category;\n+import org.junit.experimental.runners.Enclosed;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n /** Test the various NEXMark queries yield results coherent with their models. */\n-@RunWith(JUnit4.class)\n+@RunWith(Enclosed.class)\n public class SqlBoundedSideInputJoinTest {\n \n-  @Rule public TestPipeline p = TestPipeline.create();\n+  private abstract static class SqlBoundedSideInputJoinTestCases {\n \n-  @Before\n-  public void setupPipeline() {\n-    NexmarkUtils.setupPipeline(NexmarkUtils.CoderStrategy.HAND, p);\n-  }\n+    protected abstract SqlBoundedSideInputJoin getQuery(NexmarkConfiguration configuration);\n+\n+    @Rule public TestPipeline p = TestPipeline.create();\n+\n+    @Before\n+    public void setupPipeline() {\n+      NexmarkUtils.setupPipeline(NexmarkUtils.CoderStrategy.HAND, p);\n+    }\n \n-  /** Test {@code query} matches {@code model}. */\n-  private <T extends KnownSize> void queryMatchesModel(\n-      String name,\n-      NexmarkConfiguration config,\n-      NexmarkQueryTransform<T> query,\n-      NexmarkQueryModel<T> model,\n-      boolean streamingMode)\n-      throws Exception {\n-\n-    ResourceId sideInputResourceId =\n-        FileSystems.matchNewResource(\n-            String.format(\n-                \"%s/JoinToFiles-%s\", p.getOptions().getTempLocation(), new Random().nextInt()),\n-            false);\n-    config.sideInputUrl = sideInputResourceId.toString();\n-\n-    try {\n+    /** Test {@code query} matches {@code model}. */\n+    private <T extends KnownSize> void queryMatchesModel(\n+        String name,\n+        NexmarkConfiguration config,\n+        NexmarkQueryTransform<T> query,\n+        NexmarkQueryModel<T> model,\n+        boolean streamingMode)\n+        throws Exception {\n+\n+      ResourceId sideInputResourceId =\n+          FileSystems.matchNewResource(\n+              String.format(\n+                  \"%s/JoinToFiles-%s\", p.getOptions().getTempLocation(), new Random().nextInt()),\n+              false);\n+      config.sideInputUrl = sideInputResourceId.toString();\n+\n+      try {\n+        PCollection<KV<Long, String>> sideInput = NexmarkUtils.prepareSideInput(p, config);\n+        query.setSideInput(sideInput);\n+\n+        PCollection<Event> events =\n+            p.apply(\n+                name + \".Read\",\n+                streamingMode\n+                    ? NexmarkUtils.streamEventsSource(config)\n+                    : NexmarkUtils.batchEventsSource(config));\n+\n+        PCollection<TimestampedValue<T>> results =\n+            (PCollection<TimestampedValue<T>>) events.apply(new NexmarkQuery<>(config, query));\n+        PAssert.that(results).satisfies(model.assertionFor());\n+        PipelineResult result = p.run();\n+        result.waitUntilFinish();\n+      } finally {\n+        NexmarkUtils.cleanUpSideInput(config);\n+      }\n+    }\n+\n+    /**\n+     * A smoke test that the count of input bids and outputs are the same, to help diagnose\n+     * flakiness in more complex tests.\n+     */\n+    @Test\n+    public void inputOutputSameEvents() throws Exception {\n+      NexmarkConfiguration config = NexmarkConfiguration.DEFAULT.copy();\n+      config.sideInputType = NexmarkUtils.SideInputType.DIRECT;\n+      config.numEventGenerators = 1;\n+      config.numEvents = 5000;\n+      config.sideInputRowCount = 10;\n+      config.sideInputNumShards = 3;\n       PCollection<KV<Long, String>> sideInput = NexmarkUtils.prepareSideInput(p, config);\n-      query.setSideInput(sideInput);\n-\n-      PCollection<Event> events =\n-          p.apply(\n-              name + \".Read\",\n-              streamingMode\n-                  ? NexmarkUtils.streamEventsSource(config)\n-                  : NexmarkUtils.batchEventsSource(config));\n-\n-      PCollection<TimestampedValue<T>> results =\n-          (PCollection<TimestampedValue<T>>) events.apply(new NexmarkQuery<>(config, query));\n-      PAssert.that(results).satisfies(model.assertionFor());\n-      PipelineResult result = p.run();\n-      result.waitUntilFinish();\n-    } finally {\n-      NexmarkUtils.cleanUpSideInput(config);\n+\n+      try {\n+        PCollection<Event> input = p.apply(NexmarkUtils.batchEventsSource(config));\n+        PCollection<Bid> justBids = input.apply(NexmarkQueryUtil.JUST_BIDS);\n+        PCollection<Long> bidCount = justBids.apply(\"Count Bids\", Count.globally());\n+\n+        NexmarkQueryTransform<Bid> query = getQuery(config);\n+        query.setSideInput(sideInput);\n+\n+        PCollection<TimestampedValue<Bid>> output =\n+            (PCollection<TimestampedValue<Bid>>) input.apply(new NexmarkQuery(config, query));\n+        PCollection<Long> outputCount = output.apply(\"Count outputs\", Count.globally());\n+\n+        PAssert.that(PCollectionList.of(bidCount).and(outputCount).apply(Flatten.pCollections()))\n+            .satisfies(\n+                counts -> {\n+                  assertThat(Iterables.size(counts), equalTo(2));\n+                  assertThat(Iterables.get(counts, 0), greaterThan(0L));\n+                  assertThat(Iterables.get(counts, 0), equalTo(Iterables.get(counts, 1)));\n+                  return null;\n+                });\n+        p.run();\n+      } finally {\n+        NexmarkUtils.cleanUpSideInput(config);\n+      }\n     }\n-  }\n \n-  /**\n-   * A smoke test that the count of input bids and outputs are the same, to help diagnose flakiness\n-   * in more complex tests.\n-   */\n-  @Test\n-  @Category(NeedsRunner.class)\n-  public void inputOutputSameEvents() throws Exception {\n-    NexmarkConfiguration config = NexmarkConfiguration.DEFAULT.copy();\n-    config.sideInputType = NexmarkUtils.SideInputType.DIRECT;\n-    config.numEventGenerators = 1;\n-    config.numEvents = 5000;\n-    config.sideInputRowCount = 10;\n-    config.sideInputNumShards = 3;\n-    PCollection<KV<Long, String>> sideInput = NexmarkUtils.prepareSideInput(p, config);\n-\n-    try {\n-      PCollection<Event> input = p.apply(NexmarkUtils.batchEventsSource(config));\n-      PCollection<Bid> justBids = input.apply(NexmarkQueryUtil.JUST_BIDS);\n-      PCollection<Long> bidCount = justBids.apply(\"Count Bids\", Count.globally());\n-\n-      NexmarkQueryTransform<Bid> query = new SqlBoundedSideInputJoin(config);\n-      query.setSideInput(sideInput);\n-\n-      PCollection<TimestampedValue<Bid>> output =\n-          (PCollection<TimestampedValue<Bid>>) input.apply(new NexmarkQuery(config, query));\n-      PCollection<Long> outputCount = output.apply(\"Count outputs\", Count.globally());\n-\n-      PAssert.that(PCollectionList.of(bidCount).and(outputCount).apply(Flatten.pCollections()))\n-          .satisfies(\n-              counts -> {\n-                assertThat(Iterables.size(counts), equalTo(2));\n-                assertThat(Iterables.get(counts, 0), greaterThan(0L));\n-                assertThat(Iterables.get(counts, 0), equalTo(Iterables.get(counts, 1)));\n-                return null;\n-              });\n-      p.run();\n-    } finally {\n-      NexmarkUtils.cleanUpSideInput(config);\n+    @Test\n+    public void queryMatchesModelBatchDirect() throws Exception {\n+      NexmarkConfiguration config = NexmarkConfiguration.DEFAULT.copy();\n+      config.sideInputType = NexmarkUtils.SideInputType.DIRECT;\n+      config.numEventGenerators = 1;\n+      config.numEvents = 5000;\n+      config.sideInputRowCount = 10;\n+      config.sideInputNumShards = 3;\n+\n+      queryMatchesModel(\n+          \"SqlBoundedSideInputJoinTestBatch\",\n+          config,\n+          getQuery(config),\n+          new BoundedSideInputJoinModel(config),\n+          false);\n     }\n-  }\n \n-  @Test\n-  @Category(NeedsRunner.class)\n-  public void queryMatchesModelBatchDirect() throws Exception {\n-    NexmarkConfiguration config = NexmarkConfiguration.DEFAULT.copy();\n-    config.sideInputType = NexmarkUtils.SideInputType.DIRECT;\n-    config.numEventGenerators = 1;\n-    config.numEvents = 5000;\n-    config.sideInputRowCount = 10;\n-    config.sideInputNumShards = 3;\n-\n-    queryMatchesModel(\n-        \"SqlBoundedSideInputJoinTestBatch\",\n-        config,\n-        new SqlBoundedSideInputJoin(config),\n-        new BoundedSideInputJoinModel(config),\n-        false);\n-  }\n+    @Test\n+    public void queryMatchesModelStreamingDirect() throws Exception {\n+      NexmarkConfiguration config = NexmarkConfiguration.DEFAULT.copy();\n+      config.sideInputType = NexmarkUtils.SideInputType.DIRECT;\n+      config.numEventGenerators = 1;\n+      config.numEvents = 5000;\n+      config.sideInputRowCount = 10;\n+      config.sideInputNumShards = 3;\n+      queryMatchesModel(\n+          \"SqlBoundedSideInputJoinTestStreaming\",\n+          config,\n+          getQuery(config),\n+          new BoundedSideInputJoinModel(config),\n+          true);\n+    }\n+\n+    @Test\n+    public void queryMatchesModelBatchCsv() throws Exception {\n+      NexmarkConfiguration config = NexmarkConfiguration.DEFAULT.copy();\n+      config.sideInputType = NexmarkUtils.SideInputType.CSV;\n+      config.numEventGenerators = 1;\n+      config.numEvents = 5000;\n+      config.sideInputRowCount = 10;\n+      config.sideInputNumShards = 3;\n+\n+      queryMatchesModel(\n+          \"SqlBoundedSideInputJoinTestBatch\",\n+          config,\n+          getQuery(config),\n+          new BoundedSideInputJoinModel(config),\n+          false);\n+    }\n \n-  @Test\n-  @Category(NeedsRunner.class)\n-  public void queryMatchesModelStreamingDirect() throws Exception {\n-    NexmarkConfiguration config = NexmarkConfiguration.DEFAULT.copy();\n-    config.sideInputType = NexmarkUtils.SideInputType.DIRECT;\n-    config.numEventGenerators = 1;\n-    config.numEvents = 5000;\n-    config.sideInputRowCount = 10;\n-    config.sideInputNumShards = 3;\n-    queryMatchesModel(\n-        \"SqlBoundedSideInputJoinTestStreaming\",\n-        config,\n-        new SqlBoundedSideInputJoin(config),\n-        new BoundedSideInputJoinModel(config),\n-        true);\n+    @Test\n+    public void queryMatchesModelStreamingCsv() throws Exception {\n+      NexmarkConfiguration config = NexmarkConfiguration.DEFAULT.copy();\n+      config.sideInputType = NexmarkUtils.SideInputType.CSV;\n+      config.numEventGenerators = 1;\n+      config.numEvents = 5000;\n+      config.sideInputRowCount = 10;\n+      config.sideInputNumShards = 3;\n+      queryMatchesModel(\n+          \"SqlBoundedSideInputJoinTestStreaming\",\n+          config,\n+          getQuery(config),\n+          new BoundedSideInputJoinModel(config),\n+          true);\n+    }\n   }\n \n-  @Test\n-  @Category(NeedsRunner.class)\n-  public void queryMatchesModelBatchCsv() throws Exception {\n-    NexmarkConfiguration config = NexmarkConfiguration.DEFAULT.copy();\n-    config.sideInputType = NexmarkUtils.SideInputType.CSV;\n-    config.numEventGenerators = 1;\n-    config.numEvents = 5000;\n-    config.sideInputRowCount = 10;\n-    config.sideInputNumShards = 3;\n-\n-    queryMatchesModel(\n-        \"SqlBoundedSideInputJoinTestBatch\",\n-        config,\n-        new SqlBoundedSideInputJoin(config),\n-        new BoundedSideInputJoinModel(config),\n-        false);\n+  @RunWith(JUnit4.class)\n+  public static class SqlBoundedSideInputJoinTest_Calcite extends SqlBoundedSideInputJoinTestCases {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d169d9454f22d175ad12e8dfc17922dc015b75f"}, "originalPosition": 304}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NjYzMjk3", "url": "https://github.com/apache/beam/pull/11820#pullrequestreview-425663297", "createdAt": "2020-06-05T22:30:27Z", "commit": {"oid": "7d169d9454f22d175ad12e8dfc17922dc015b75f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7d169d9454f22d175ad12e8dfc17922dc015b75f", "author": {"user": {"login": "kennknowles", "name": "Kenn Knowles"}}, "url": "https://github.com/apache/beam/commit/7d169d9454f22d175ad12e8dfc17922dc015b75f", "committedDate": "2020-06-05T18:21:53Z", "message": "Add ZetaSQL Nexmark variant"}, "afterCommit": {"oid": "51fe401b259047dc393827dd02217418dec172f7", "author": {"user": {"login": "kennknowles", "name": "Kenn Knowles"}}, "url": "https://github.com/apache/beam/commit/51fe401b259047dc393827dd02217418dec172f7", "committedDate": "2020-06-08T18:05:50Z", "message": "Add ZetaSQL Nexmark variant"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fe2d7477f6ebfb9e60b46c1d8ca05587fc03107", "author": {"user": {"login": "kennknowles", "name": "Kenn Knowles"}}, "url": "https://github.com/apache/beam/commit/3fe2d7477f6ebfb9e60b46c1d8ca05587fc03107", "committedDate": "2020-06-09T18:41:09Z", "message": "Add ZetaSQL Nexmark variant"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "51fe401b259047dc393827dd02217418dec172f7", "author": {"user": {"login": "kennknowles", "name": "Kenn Knowles"}}, "url": "https://github.com/apache/beam/commit/51fe401b259047dc393827dd02217418dec172f7", "committedDate": "2020-06-08T18:05:50Z", "message": "Add ZetaSQL Nexmark variant"}, "afterCommit": {"oid": "3fe2d7477f6ebfb9e60b46c1d8ca05587fc03107", "author": {"user": {"login": "kennknowles", "name": "Kenn Knowles"}}, "url": "https://github.com/apache/beam/commit/3fe2d7477f6ebfb9e60b46c1d8ca05587fc03107", "committedDate": "2020-06-09T18:41:09Z", "message": "Add ZetaSQL Nexmark variant"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4361, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}