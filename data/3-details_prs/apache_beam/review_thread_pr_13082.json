{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxODkwODEw", "number": 13082, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMTo0Mjo0NFrOEtrCcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMjo0MDozMFrOEtsmAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MzI2NTEyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/dataframe/frames.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMTo0Mjo0NFrOHhmFWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwMDo0MTozM1rOHhs0HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk4OTAxOA==", "bodyText": "Could you update pandas_doctests_test?  It looks like the skipped DataFrame.groupby tests should pass now, and hopefully the Series.groupby ones as well.", "url": "https://github.com/apache/beam/pull/13082#discussion_r504989018", "createdAt": "2020-10-14T21:42:44Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -27,12 +28,118 @@\n from apache_beam.dataframe import partitionings\n \n \n-@frame_base.DeferredFrame._register_for(pd.Series)\n-class DeferredSeries(frame_base.DeferredFrame):\n+class DeferredDataFrameOrSeries(frame_base.DeferredFrame):\n   def __array__(self, dtype=None):\n     raise frame_base.WontImplementError(\n         'Conversion to a non-deferred a numpy array.')\n \n+  @frame_base.args_to_kwargs(pd.DataFrame)\n+  @frame_base.populate_defaults(pd.DataFrame)\n+  def droplevel(self, level, axis):\n+    return frame_base.DeferredFrame.wrap(\n+        expressions.ComputedExpression(\n+            'droplevel',\n+            lambda df: df.droplevel(level, axis=axis), [self._expr],\n+            requires_partition_by=partitionings.Nothing(),\n+            preserves_partition_by=partitionings.Index()\n+            if axis in (1, 'column') else partitionings.Nothing()))\n+\n+  @frame_base.args_to_kwargs(pd.DataFrame)\n+  @frame_base.populate_defaults(pd.DataFrame)\n+  def groupby(self, by, level, axis, as_index, group_keys, **kwargs):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96e17e174b4e9b2446b90f96eb29859cbf48132f"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA5OTI5Mw==", "bodyText": "Ah, yes, will do.", "url": "https://github.com/apache/beam/pull/13082#discussion_r505099293", "createdAt": "2020-10-15T00:41:33Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -27,12 +28,118 @@\n from apache_beam.dataframe import partitionings\n \n \n-@frame_base.DeferredFrame._register_for(pd.Series)\n-class DeferredSeries(frame_base.DeferredFrame):\n+class DeferredDataFrameOrSeries(frame_base.DeferredFrame):\n   def __array__(self, dtype=None):\n     raise frame_base.WontImplementError(\n         'Conversion to a non-deferred a numpy array.')\n \n+  @frame_base.args_to_kwargs(pd.DataFrame)\n+  @frame_base.populate_defaults(pd.DataFrame)\n+  def droplevel(self, level, axis):\n+    return frame_base.DeferredFrame.wrap(\n+        expressions.ComputedExpression(\n+            'droplevel',\n+            lambda df: df.droplevel(level, axis=axis), [self._expr],\n+            requires_partition_by=partitionings.Nothing(),\n+            preserves_partition_by=partitionings.Index()\n+            if axis in (1, 'column') else partitionings.Nothing()))\n+\n+  @frame_base.args_to_kwargs(pd.DataFrame)\n+  @frame_base.populate_defaults(pd.DataFrame)\n+  def groupby(self, by, level, axis, as_index, group_keys, **kwargs):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk4OTAxOA=="}, "originalCommit": {"oid": "96e17e174b4e9b2446b90f96eb29859cbf48132f"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MzQ1NTUxOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/dataframe/frames.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMjoyNTo0NlrOHhoEtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMjoyNTo0NlrOHhoEtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAyMTYyMw==", "bodyText": "I was going to suggest you allow tuple here, but after looking into it I realized the pandas groupby intentionally does the same thing, since a tuple could be a field name. TIL\nhttps://github.com/pandas-dev/pandas/blob/d7a5b838d8d6234f6bec5a30bfa33b24bd4afbd9/pandas/core/groupby/grouper.py#L713-L718", "url": "https://github.com/apache/beam/pull/13082#discussion_r505021623", "createdAt": "2020-10-14T22:25:46Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -27,12 +28,118 @@\n from apache_beam.dataframe import partitionings\n \n \n-@frame_base.DeferredFrame._register_for(pd.Series)\n-class DeferredSeries(frame_base.DeferredFrame):\n+class DeferredDataFrameOrSeries(frame_base.DeferredFrame):\n   def __array__(self, dtype=None):\n     raise frame_base.WontImplementError(\n         'Conversion to a non-deferred a numpy array.')\n \n+  @frame_base.args_to_kwargs(pd.DataFrame)\n+  @frame_base.populate_defaults(pd.DataFrame)\n+  def droplevel(self, level, axis):\n+    return frame_base.DeferredFrame.wrap(\n+        expressions.ComputedExpression(\n+            'droplevel',\n+            lambda df: df.droplevel(level, axis=axis), [self._expr],\n+            requires_partition_by=partitionings.Nothing(),\n+            preserves_partition_by=partitionings.Index()\n+            if axis in (1, 'column') else partitionings.Nothing()))\n+\n+  @frame_base.args_to_kwargs(pd.DataFrame)\n+  @frame_base.populate_defaults(pd.DataFrame)\n+  def groupby(self, by, level, axis, as_index, group_keys, **kwargs):\n+    if not as_index:\n+      raise NotImplementedError('groupby(as_index=False)')\n+    if not group_keys:\n+      raise NotImplementedError('groupby(group_keys=False)')\n+\n+    if axis in (1, 'columns'):\n+      return _DeferredGroupByCols(\n+          expressions.ComputedExpression(\n+              'groupbycols',\n+              lambda df: df.groupby(by, axis=axis, **kwargs), [self._expr],\n+              requires_partition_by=partitionings.Nothing(),\n+              preserves_partition_by=partitionings.Index()))\n+\n+    if level is None and by is None:\n+      raise TypeError(\"You have to supply one of 'by' and 'level'\")\n+\n+    elif level is not None:\n+      if isinstance(level, (list, tuple)):\n+        levels = level\n+      else:\n+        levels = [level]\n+      all_levels = self._expr.proxy().index.names\n+      levels = [all_levels[i] if isinstance(i, int) else i for i in levels]\n+      levels_to_drop = self._expr.proxy().index.names.difference(levels)\n+      if levels_to_drop:\n+        to_group = self.droplevel(levels_to_drop)._expr\n+      else:\n+        to_group = self._expr\n+\n+    elif callable(by):\n+\n+      def map_index(df):\n+        df = df.copy()\n+        df.index = df.index.map(by)\n+        return df\n+\n+      to_group = expressions.ComputedExpression(\n+          'map_index',\n+          map_index, [self._expr],\n+          requires_partition_by=partitionings.Nothing(),\n+          preserves_partition_by=partitionings.Singleton())\n+\n+    elif isinstance(by, DeferredSeries):\n+\n+      if isinstance(self, DeferredSeries):\n+\n+        def set_index(s, by):\n+          df = pd.DataFrame(s)\n+          df, by = df.align(by, axis=0)\n+          return df.set_index(by).iloc[:, 0]\n+      else:\n+\n+        def set_index(df, by):\n+          df, by = df.align(by, axis=0)\n+          return df.set_index(by)\n+\n+      to_group = expressions.ComputedExpression(\n+          'set_index',\n+          set_index,  #\n+          [self._expr, by._expr],\n+          requires_partition_by=partitionings.Index(),\n+          preserves_partition_by=partitionings.Singleton())\n+\n+    elif isinstance(by, np.ndarray):\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    else:\n+      if not isinstance(by, list):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96e17e174b4e9b2446b90f96eb29859cbf48132f"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MzUyMDAzOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/dataframe/frames.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMjo0MDozMFrOHhovoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwMDozNToyN1rOHhstgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAzMjYwOQ==", "bodyText": "Should we consider implementing this and groups for categorical grouping keys?", "url": "https://github.com/apache/beam/pull/13082#discussion_r505032609", "createdAt": "2020-10-14T22:40:30Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -1120,6 +1222,15 @@ def agg(self, fn):\n             requires_partition_by=partitionings.Index(),\n             preserves_partition_by=partitionings.Singleton()))\n \n+  aggregate = agg\n+\n+  first = last = head = tail = frame_base.not_implemented_method(\n+      'order sensitive')\n+\n+  __len__ = frame_base.wont_implement_method('non-deferred')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96e17e174b4e9b2446b90f96eb29859cbf48132f"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA5NzYwMw==", "bodyText": "Good thought. Dropped a TODO for now.", "url": "https://github.com/apache/beam/pull/13082#discussion_r505097603", "createdAt": "2020-10-15T00:35:27Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -1120,6 +1222,15 @@ def agg(self, fn):\n             requires_partition_by=partitionings.Index(),\n             preserves_partition_by=partitionings.Singleton()))\n \n+  aggregate = agg\n+\n+  first = last = head = tail = frame_base.not_implemented_method(\n+      'order sensitive')\n+\n+  __len__ = frame_base.wont_implement_method('non-deferred')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAzMjYwOQ=="}, "originalCommit": {"oid": "96e17e174b4e9b2446b90f96eb29859cbf48132f"}, "originalPosition": 207}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2957, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}