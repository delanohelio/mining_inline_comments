{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyMzQyOTk0", "number": 13221, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTowODo1NFrOE08YWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOToxMjowN1rOE08dZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzOTUwNjgwOnYy", "diffSide": "RIGHT", "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/triggers/AfterEachStateMachine.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTowODo1NFrOHs8wrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOTo0MzoxMVrOHs95jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5NDg5Mg==", "bodyText": "This was one of the cases where I was thinking it only made sense to prefetch the active subtrigger. Of course, I was missing the whole point that you can't know which one that is until you do a fetch. So maybe my whole idea was foolish.", "url": "https://github.com/apache/beam/pull/13221#discussion_r516894892", "createdAt": "2020-11-03T19:08:54Z", "author": {"login": "kennknowles"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/triggers/AfterEachStateMachine.java", "diffHunk": "@@ -48,6 +48,13 @@ private AfterEachStateMachine(List<TriggerStateMachine> subTriggers) {\n     checkArgument(subTriggers.size() > 1);\n   }\n \n+  @Override\n+  public void prefetchOnElement(PrefetchContext c) {\n+    for (ExecutableTriggerStateMachine subTrigger : c.trigger().subTriggers()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e093b5f5203caa1b754ec19e5341fb3a13d2cb7"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMzU0OA==", "bodyText": "Yeah when I embarked on this I was thinking also it might be possible to do better but it didn't pan out.\nOne idea I had was adding a isCached() method on the state objects that would indicate if the value was local (cached, in-memory, etc) and didn't require a fetch.  In such cases we could trim the trigger state to prefetch by looking at the closed triggers.  However if everything we actually needed was local, we've only called readLater on something we never actually read and thus never issue a fetch anyway.  And if we do have to issue a fetch for anything, fetching an additional unused tag to it is likely not much more overhead.", "url": "https://github.com/apache/beam/pull/13221#discussion_r516913548", "createdAt": "2020-11-03T19:43:11Z", "author": {"login": "scwhittle"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/triggers/AfterEachStateMachine.java", "diffHunk": "@@ -48,6 +48,13 @@ private AfterEachStateMachine(List<TriggerStateMachine> subTriggers) {\n     checkArgument(subTriggers.size() > 1);\n   }\n \n+  @Override\n+  public void prefetchOnElement(PrefetchContext c) {\n+    for (ExecutableTriggerStateMachine subTrigger : c.trigger().subTriggers()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5NDg5Mg=="}, "originalCommit": {"oid": "8e093b5f5203caa1b754ec19e5341fb3a13d2cb7"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzOTUxOTc1OnYy", "diffSide": "RIGHT", "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/triggers/AfterWatermarkStateMachine.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOToxMjowN1rOHs84LQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOToxMjowN1rOHs84LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5NjgxMw==", "bodyText": "This was the other one. Same problem with my thinking.", "url": "https://github.com/apache/beam/pull/13221#discussion_r516896813", "createdAt": "2020-11-03T19:12:07Z", "author": {"login": "kennknowles"}, "path": "runners/core-java/src/main/java/org/apache/beam/runners/core/triggers/AfterWatermarkStateMachine.java", "diffHunk": "@@ -91,6 +91,13 @@ public AfterWatermarkEarlyAndLate withLateFirings(TriggerStateMachine lateTrigge\n       return new AfterWatermarkEarlyAndLate(earlyTrigger, lateTrigger);\n     }\n \n+    @Override\n+    public void prefetchOnElement(PrefetchContext c) {\n+      for (ExecutableTriggerStateMachine subTrigger : c.trigger().subTriggers()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e093b5f5203caa1b754ec19e5341fb3a13d2cb7"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2881, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}