{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2OTczMTg1", "number": 11490, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMToxOTo1MVrOD0gr5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzoyNTo0NFrOD04CEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Mzg4MDcxOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/runners/universal/runnerlib/stage.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMToxOTo1MVrOGJfDuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMToxOTo1MVrOGJfDuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5OTIyNw==", "bodyText": "Typo: Portable", "url": "https://github.com/apache/beam/pull/11490#discussion_r412599227", "createdAt": "2020-04-22T01:19:51Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/runners/universal/runnerlib/stage.go", "diffHunk": "@@ -17,27 +17,128 @@ package runnerlib\n \n import (\n \t\"context\"\n+\t\"io\"\n+\t\"os\"\n \t\"time\"\n \n \t\"github.com/apache/beam/sdks/go/pkg/beam/artifact\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tjobpb \"github.com/apache/beam/sdks/go/pkg/beam/model/jobmanagement_v1\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/util/grpcx\"\n+\t\"google.golang.org/grpc\"\n )\n \n // Stage stages the worker binary and any additional files to the given\n // artifact staging endpoint. It returns the retrieval token if successful.\n-func Stage(ctx context.Context, id, endpoint, binary, st string, files ...artifact.KeyedFile) (retrievalToken string, err error) {\n+func Stage(ctx context.Context, id, endpoint, binary, st string) (retrievalToken string, err error) {\n \tctx = grpcx.WriteWorkerID(ctx, id)\n \tcc, err := grpcx.Dial(ctx, endpoint, 2*time.Minute)\n \tif err != nil {\n \t\treturn \"\", errors.WithContext(err, \"connecting to artifact service\")\n \t}\n \tdefer cc.Close()\n \n+\terr = StageViaPorableApi(ctx, cc, binary, st)\n+\n+\tif err == nil {\n+\t\treturn \"\", err\n+\t} else {\n+\t\treturn StageViaLegacyApi(ctx, cc, binary, st)\n+\t}\n+}\n+\n+func StageViaPorableApi(ctx context.Context, cc *grpc.ClientConn, binary, st string) error {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3570a8203a7d5cb2810d939f25ce24d71d6cf6e3"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Mzg4MjYyOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/graphx/translate.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMToyMDoyOFrOGJfErw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMToyMDoyOFrOGJfErw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5OTQ3MQ==", "bodyText": "Conventionally this should be named MustMarshal if it's going to panic.", "url": "https://github.com/apache/beam/pull/11490#discussion_r412599471", "createdAt": "2020-04-22T01:20:28Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/graphx/translate.go", "diffHunk": "@@ -93,14 +96,32 @@ func CreateEnvironment(ctx context.Context, urn string, extractEnvironmentConfig\n \t\t\tpanic(fmt.Sprintf(\n \t\t\t\t\"Failed to serialize Environment payload %v for config %v: %v\", payload, config, err))\n \t\t}\n+\n \t\treturn &pipepb.Environment{\n \t\t\tUrn:          urn,\n \t\t\tPayload:      serializedPayload,\n \t\t\tCapabilities: goCapabilities(),\n+\t\t\tDependencies: []*pipepb.ArtifactInformation{\n+\t\t\t\t&pipepb.ArtifactInformation{\n+\t\t\t\t\tTypeUrn: URNArtifactGoWorker,\n+\t\t\t\t\tRoleUrn: URNArtifactStagingTo,\n+\t\t\t\t\tRolePayload: MarshalOrPanic(&pipepb.ArtifactStagingToRolePayload{\n+\t\t\t\t\t\tStagedName: \"worker\",\n+\t\t\t\t\t}),\n+\t\t\t\t},\n+\t\t\t},\n \t\t}\n \t}\n }\n \n+func MarshalOrPanic(msg proto.Message) []byte {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3570a8203a7d5cb2810d939f25ce24d71d6cf6e3"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzkwMjA1OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/runners/universal/runnerlib/stage.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMToyODowOVrOGJfO6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMToyODowOVrOGJfO6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwMjA4OA==", "bodyText": "While not incorrect, it's a bit odd to see a capitalized variable name in Go because a capital letter indicates the identifier is Exported from the package.\nFrom a readability standpoint the capital initial tells the reader that the scope of this variable extends beyond this package, which isn't the case for a local variable in function scope. At the definition line (here) this is fine, but at later uses, it would be easy to make the mistake, miamatchign assumptions.\nMixedCaps are correct though.\nConsider typeUrn instead.\nAs a second note: you can put the definition inline in the switch header\nswitch typeUrn := ... ; typeUrn {\ncase ...\nwhich limits its scope to just the switch.", "url": "https://github.com/apache/beam/pull/11490#discussion_r412602088", "createdAt": "2020-04-22T01:28:09Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/runners/universal/runnerlib/stage.go", "diffHunk": "@@ -17,27 +17,128 @@ package runnerlib\n \n import (\n \t\"context\"\n+\t\"io\"\n+\t\"os\"\n \t\"time\"\n \n \t\"github.com/apache/beam/sdks/go/pkg/beam/artifact\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tjobpb \"github.com/apache/beam/sdks/go/pkg/beam/model/jobmanagement_v1\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/util/grpcx\"\n+\t\"google.golang.org/grpc\"\n )\n \n // Stage stages the worker binary and any additional files to the given\n // artifact staging endpoint. It returns the retrieval token if successful.\n-func Stage(ctx context.Context, id, endpoint, binary, st string, files ...artifact.KeyedFile) (retrievalToken string, err error) {\n+func Stage(ctx context.Context, id, endpoint, binary, st string) (retrievalToken string, err error) {\n \tctx = grpcx.WriteWorkerID(ctx, id)\n \tcc, err := grpcx.Dial(ctx, endpoint, 2*time.Minute)\n \tif err != nil {\n \t\treturn \"\", errors.WithContext(err, \"connecting to artifact service\")\n \t}\n \tdefer cc.Close()\n \n+\terr = StageViaPorableApi(ctx, cc, binary, st)\n+\n+\tif err == nil {\n+\t\treturn \"\", err\n+\t} else {\n+\t\treturn StageViaLegacyApi(ctx, cc, binary, st)\n+\t}\n+}\n+\n+func StageViaPorableApi(ctx context.Context, cc *grpc.ClientConn, binary, st string) error {\n+\tclient := jobpb.NewArtifactStagingServiceClient(cc)\n+\n+\tstream, err := client.ReverseArtifactRetrievalService(context.Background())\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif err := stream.Send(&jobpb.ArtifactResponseWrapper{StagingToken: st}); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfor {\n+\t\tin, err := stream.Recv()\n+\t\tif err == io.EOF {\n+\t\t\treturn nil\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tswitch request := in.Request.(type) {\n+\t\tcase *jobpb.ArtifactRequestWrapper_ResolveArtifact:\n+\t\t\terr = stream.Send(&jobpb.ArtifactResponseWrapper{\n+\t\t\t\tResponse: &jobpb.ArtifactResponseWrapper_ResolveArtifactResponse{\n+\t\t\t\t\t&jobpb.ResolveArtifactsResponse{\n+\t\t\t\t\t\tReplacements: request.ResolveArtifact.Artifacts,\n+\t\t\t\t\t},\n+\t\t\t\t}})\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\n+\t\tcase *jobpb.ArtifactRequestWrapper_GetArtifact:\n+\t\t\tTypeUrn := request.GetArtifact.Artifact.TypeUrn", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3570a8203a7d5cb2810d939f25ce24d71d6cf6e3"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzkxNjQ0OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/runners/universal/runnerlib/stage.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMTozMzozMVrOGJfWfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMTozMzozMVrOGJfWfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwNDAyOQ==", "bodyText": "Lint Nit: due to how errors are used in go, via prepending context, it's preferred to not capitalize error strings, so they end up reading better with the prepended context.\nHere and everywhere else Errorf is used.", "url": "https://github.com/apache/beam/pull/11490#discussion_r412604029", "createdAt": "2020-04-22T01:33:31Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/runners/universal/runnerlib/stage.go", "diffHunk": "@@ -17,27 +17,128 @@ package runnerlib\n \n import (\n \t\"context\"\n+\t\"io\"\n+\t\"os\"\n \t\"time\"\n \n \t\"github.com/apache/beam/sdks/go/pkg/beam/artifact\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tjobpb \"github.com/apache/beam/sdks/go/pkg/beam/model/jobmanagement_v1\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/util/grpcx\"\n+\t\"google.golang.org/grpc\"\n )\n \n // Stage stages the worker binary and any additional files to the given\n // artifact staging endpoint. It returns the retrieval token if successful.\n-func Stage(ctx context.Context, id, endpoint, binary, st string, files ...artifact.KeyedFile) (retrievalToken string, err error) {\n+func Stage(ctx context.Context, id, endpoint, binary, st string) (retrievalToken string, err error) {\n \tctx = grpcx.WriteWorkerID(ctx, id)\n \tcc, err := grpcx.Dial(ctx, endpoint, 2*time.Minute)\n \tif err != nil {\n \t\treturn \"\", errors.WithContext(err, \"connecting to artifact service\")\n \t}\n \tdefer cc.Close()\n \n+\terr = StageViaPorableApi(ctx, cc, binary, st)\n+\n+\tif err == nil {\n+\t\treturn \"\", err\n+\t} else {\n+\t\treturn StageViaLegacyApi(ctx, cc, binary, st)\n+\t}\n+}\n+\n+func StageViaPorableApi(ctx context.Context, cc *grpc.ClientConn, binary, st string) error {\n+\tclient := jobpb.NewArtifactStagingServiceClient(cc)\n+\n+\tstream, err := client.ReverseArtifactRetrievalService(context.Background())\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif err := stream.Send(&jobpb.ArtifactResponseWrapper{StagingToken: st}); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfor {\n+\t\tin, err := stream.Recv()\n+\t\tif err == io.EOF {\n+\t\t\treturn nil\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tswitch request := in.Request.(type) {\n+\t\tcase *jobpb.ArtifactRequestWrapper_ResolveArtifact:\n+\t\t\terr = stream.Send(&jobpb.ArtifactResponseWrapper{\n+\t\t\t\tResponse: &jobpb.ArtifactResponseWrapper_ResolveArtifactResponse{\n+\t\t\t\t\t&jobpb.ResolveArtifactsResponse{\n+\t\t\t\t\t\tReplacements: request.ResolveArtifact.Artifacts,\n+\t\t\t\t\t},\n+\t\t\t\t}})\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\n+\t\tcase *jobpb.ArtifactRequestWrapper_GetArtifact:\n+\t\t\tTypeUrn := request.GetArtifact.Artifact.TypeUrn\n+\t\t\tswitch TypeUrn {\n+\t\t\tcase graphx.URNArtifactGoWorker:\n+\t\t\t\tStageFile(binary, stream)\n+\n+\t\t\tdefault:\n+\t\t\t\treturn errors.Errorf(\"Request has unexpected artifact type %s\", TypeUrn)\n+\t\t\t}\n+\n+\t\tdefault:\n+\t\t\treturn errors.Errorf(\"Request has unexpected type %T\", request)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3570a8203a7d5cb2810d939f25ce24d71d6cf6e3"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NzY2ODA1OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/runners/universal/runnerlib/stage.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzoxNzoxNFrOGKBxYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxODowMzoxOVrOGKDzqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE2Nzk2OQ==", "bodyText": "Style nit: Idiomatically, if the \"if\" clause returns, elide the else block. Since Go has explicit brackets for if scopes, we avoid the \"1 line if\" in C(++) and accidental mis-alignment/scope errors with python.\nI'm not 100% but this advice only applies to if-else blocks where the remainder of the code is in the else, not for example, in default:switch cases, where dropping out of the switch instead of default is aesthetically awkward.", "url": "https://github.com/apache/beam/pull/11490#discussion_r413167969", "createdAt": "2020-04-22T17:17:14Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/runners/universal/runnerlib/stage.go", "diffHunk": "@@ -17,27 +17,127 @@ package runnerlib\n \n import (\n \t\"context\"\n+\t\"io\"\n+\t\"os\"\n \t\"time\"\n \n \t\"github.com/apache/beam/sdks/go/pkg/beam/artifact\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tjobpb \"github.com/apache/beam/sdks/go/pkg/beam/model/jobmanagement_v1\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/util/grpcx\"\n+\t\"google.golang.org/grpc\"\n )\n \n // Stage stages the worker binary and any additional files to the given\n // artifact staging endpoint. It returns the retrieval token if successful.\n-func Stage(ctx context.Context, id, endpoint, binary, st string, files ...artifact.KeyedFile) (retrievalToken string, err error) {\n+func Stage(ctx context.Context, id, endpoint, binary, st string) (retrievalToken string, err error) {\n \tctx = grpcx.WriteWorkerID(ctx, id)\n \tcc, err := grpcx.Dial(ctx, endpoint, 2*time.Minute)\n \tif err != nil {\n \t\treturn \"\", errors.WithContext(err, \"connecting to artifact service\")\n \t}\n \tdefer cc.Close()\n \n+\terr = StageViaPortableApi(ctx, cc, binary, st)\n+\n+\tif err == nil {\n+\t\treturn \"\", err\n+\t} else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f28f1efa1e6f64f69ae419b3470eaa9b13b3e879"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIwMTMyMA==", "bodyText": "To me it depends on whether it is \"one of two+ options\" (in which case an explicit else clause is clearer) or \"exit early vs. fallback\" (in which case not having the else is clearer). Removing the else clause for now; hopefully soon we'll be able to simply remove the fallback altogether.", "url": "https://github.com/apache/beam/pull/11490#discussion_r413201320", "createdAt": "2020-04-22T18:03:19Z", "author": {"login": "robertwb"}, "path": "sdks/go/pkg/beam/runners/universal/runnerlib/stage.go", "diffHunk": "@@ -17,27 +17,127 @@ package runnerlib\n \n import (\n \t\"context\"\n+\t\"io\"\n+\t\"os\"\n \t\"time\"\n \n \t\"github.com/apache/beam/sdks/go/pkg/beam/artifact\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tjobpb \"github.com/apache/beam/sdks/go/pkg/beam/model/jobmanagement_v1\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/util/grpcx\"\n+\t\"google.golang.org/grpc\"\n )\n \n // Stage stages the worker binary and any additional files to the given\n // artifact staging endpoint. It returns the retrieval token if successful.\n-func Stage(ctx context.Context, id, endpoint, binary, st string, files ...artifact.KeyedFile) (retrievalToken string, err error) {\n+func Stage(ctx context.Context, id, endpoint, binary, st string) (retrievalToken string, err error) {\n \tctx = grpcx.WriteWorkerID(ctx, id)\n \tcc, err := grpcx.Dial(ctx, endpoint, 2*time.Minute)\n \tif err != nil {\n \t\treturn \"\", errors.WithContext(err, \"connecting to artifact service\")\n \t}\n \tdefer cc.Close()\n \n+\terr = StageViaPortableApi(ctx, cc, binary, st)\n+\n+\tif err == nil {\n+\t\treturn \"\", err\n+\t} else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE2Nzk2OQ=="}, "originalCommit": {"oid": "f28f1efa1e6f64f69ae419b3470eaa9b13b3e879"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NzcwNTc4OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/runners/universal/runnerlib/stage.go", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzoyNTo0NFrOGKCIzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzoyNTo0NFrOGKCIzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3Mzk2Nw==", "bodyText": "I'm surprise this compiles TBH. Does the compiler detect there are no non-return escapes from the for loop?\nI would have expected return nil to be required.\nEdit: Apparently it does. https://play.golang.org/p/n0SGl6WzJYa Nifty!", "url": "https://github.com/apache/beam/pull/11490#discussion_r413173967", "createdAt": "2020-04-22T17:25:44Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/runners/universal/runnerlib/stage.go", "diffHunk": "@@ -17,27 +17,127 @@ package runnerlib\n \n import (\n \t\"context\"\n+\t\"io\"\n+\t\"os\"\n \t\"time\"\n \n \t\"github.com/apache/beam/sdks/go/pkg/beam/artifact\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tjobpb \"github.com/apache/beam/sdks/go/pkg/beam/model/jobmanagement_v1\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/util/grpcx\"\n+\t\"google.golang.org/grpc\"\n )\n \n // Stage stages the worker binary and any additional files to the given\n // artifact staging endpoint. It returns the retrieval token if successful.\n-func Stage(ctx context.Context, id, endpoint, binary, st string, files ...artifact.KeyedFile) (retrievalToken string, err error) {\n+func Stage(ctx context.Context, id, endpoint, binary, st string) (retrievalToken string, err error) {\n \tctx = grpcx.WriteWorkerID(ctx, id)\n \tcc, err := grpcx.Dial(ctx, endpoint, 2*time.Minute)\n \tif err != nil {\n \t\treturn \"\", errors.WithContext(err, \"connecting to artifact service\")\n \t}\n \tdefer cc.Close()\n \n+\terr = StageViaPortableApi(ctx, cc, binary, st)\n+\n+\tif err == nil {\n+\t\treturn \"\", err\n+\t} else {\n+\t\treturn StageViaLegacyApi(ctx, cc, binary, st)\n+\t}\n+}\n+\n+func StageViaPortableApi(ctx context.Context, cc *grpc.ClientConn, binary, st string) error {\n+\tclient := jobpb.NewArtifactStagingServiceClient(cc)\n+\n+\tstream, err := client.ReverseArtifactRetrievalService(context.Background())\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif err := stream.Send(&jobpb.ArtifactResponseWrapper{StagingToken: st}); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfor {\n+\t\tin, err := stream.Recv()\n+\t\tif err == io.EOF {\n+\t\t\treturn nil\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tswitch request := in.Request.(type) {\n+\t\tcase *jobpb.ArtifactRequestWrapper_ResolveArtifact:\n+\t\t\terr = stream.Send(&jobpb.ArtifactResponseWrapper{\n+\t\t\t\tResponse: &jobpb.ArtifactResponseWrapper_ResolveArtifactResponse{\n+\t\t\t\t\t&jobpb.ResolveArtifactsResponse{\n+\t\t\t\t\t\tReplacements: request.ResolveArtifact.Artifacts,\n+\t\t\t\t\t},\n+\t\t\t\t}})\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\n+\t\tcase *jobpb.ArtifactRequestWrapper_GetArtifact:\n+\t\t\tswitch typeUrn := request.GetArtifact.Artifact.TypeUrn; typeUrn {\n+\t\t\tcase graphx.URNArtifactGoWorker:\n+\t\t\t\tStageFile(binary, stream)\n+\n+\t\t\tdefault:\n+\t\t\t\treturn errors.Errorf(\"request has unexpected artifact type %s\", typeUrn)\n+\t\t\t}\n+\n+\t\tdefault:\n+\t\t\treturn errors.Errorf(\"request has unexpected type %T\", request)\n+\t\t}\n+\t}\n+}\n+\n+func StageFile(filename string, stream jobpb.ArtifactStagingService_ReverseArtifactRetrievalServiceClient) error {\n+\tfd, err := os.Open(filename)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer fd.Close()\n+\n+\tdata := make([]byte, 1<<20)\n+\tfor {\n+\t\tn, err := fd.Read(data)\n+\t\tif n > 0 {\n+\t\t\tsendErr := stream.Send(&jobpb.ArtifactResponseWrapper{\n+\t\t\t\tResponse: &jobpb.ArtifactResponseWrapper_GetArtifactResponse{\n+\t\t\t\t\t&jobpb.GetArtifactResponse{\n+\t\t\t\t\t\tData: data[:n],\n+\t\t\t\t\t},\n+\t\t\t\t}})\n+\n+\t\t\tif sendErr != nil {\n+\t\t\t\treturn errors.Wrap(sendErr, \"chunk send failed\")\n+\t\t\t}\n+\t\t}\n+\n+\t\tif err == io.EOF {\n+\t\t\tsendErr := stream.Send(&jobpb.ArtifactResponseWrapper{\n+\t\t\t\tIsLast: true,\n+\t\t\t\tResponse: &jobpb.ArtifactResponseWrapper_GetArtifactResponse{\n+\t\t\t\t\t&jobpb.GetArtifactResponse{},\n+\t\t\t\t}})\n+\t\t\treturn sendErr\n+\t\t}\n+\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f28f1efa1e6f64f69ae419b3470eaa9b13b3e879"}, "originalPosition": 119}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1354, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}