{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1MDA2NjYx", "number": 12184, "title": "[BEAM-10392] Make sure that messages that are unroutable are returned to the sender and redelivered.", "bodyText": "Thank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nDataflow\nFlink\nSamza\nSpark\nTwister2\n\n\n\n\nGo\n\n---\n\n---\n\n---\n\n\nJava\n\n\n\n\n\n\n\n\nPython\n\n\n\n---\n\n---\n\n\nXLang\n---\n---\n\n---\n\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-07-06T21:17:08Z", "url": "https://github.com/apache/beam/pull/12184", "merged": true, "mergeCommit": {"oid": "0b34546a74c4194da00d7c95838c915feee50eab"}, "closed": true, "closedAt": "2020-07-08T08:54:44Z", "author": {"login": "lukecwik"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcyX7rnAH2gAyNDQ1MDA2NjYxOmFmMWNlMjVjZjlhYWY5OWFlOTRhOThhMjVmZTgyODdjODg0ZDVmMmQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcy2gyfgFqTQ0NDU0MjE3OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "af1ce25cf9aaf99ae94a98a25fe8287c884d5f2d", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/af1ce25cf9aaf99ae94a98a25fe8287c884d5f2d", "committedDate": "2020-07-06T21:15:18Z", "message": "[BEAM-10392] Make sure that messages that are unroutable are returned to the sender and redelivered."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNzk0MzQ2", "url": "https://github.com/apache/beam/pull/12184#pullrequestreview-443794346", "createdAt": "2020-07-07T11:18:12Z", "commit": {"oid": "af1ce25cf9aaf99ae94a98a25fe8287c884d5f2d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMToxODoxMlrOGt6BqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMToxODoxMlrOGt6BqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc4OTgwMA==", "bodyText": "I think this has to be:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                waitForExchangeToBeDeclared.countDown();\n          \n          \n            \n                waitForExchangeToBeDeclared.await();", "url": "https://github.com/apache/beam/pull/12184#discussion_r450789800", "createdAt": "2020-07-07T11:18:12Z", "author": {"login": "mxm"}, "path": "sdks/java/io/rabbitmq/src/test/java/org/apache/beam/sdk/io/rabbitmq/RabbitMqIOTest.java", "diffHunk": "@@ -196,59 +200,74 @@ private void doExchangeTest(ExchangeTestPlan testPlan, boolean simulateIncompati\n         exchangeType = \"fanout\";\n       }\n     }\n+    final String finalExchangeType = exchangeType;\n+    final CountDownLatch waitForExchangeToBeDeclared = new CountDownLatch(1);\n+    final BlockingQueue<byte[]> recordsToPublish = new LinkedBlockingQueue<>();\n+    recordsToPublish.addAll(RabbitMqTestUtils.generateRecords(testPlan.getNumRecordsToPublish()));\n+    Thread publisher =\n+        new Thread(\n+            () -> {\n+              Connection connection = null;\n+              Channel channel = null;\n+              try {\n+                ConnectionFactory connectionFactory = new ConnectionFactory();\n+                connectionFactory.setAutomaticRecoveryEnabled(false);\n+                connectionFactory.setUri(uri);\n+                connection = connectionFactory.newConnection();\n+                channel = connection.createChannel();\n+                channel.exchangeDeclare(exchange, finalExchangeType);\n+                // We are relying on the pipeline to declare the queue and messages that are\n+                // published without a queue being declared are \"unroutable\". Since there is a race\n+                // between when the pipeline declares and when we can start publishing, we add a\n+                // handler to republish messages that are returned to us.\n+                channel.addReturnListener(\n+                    (replyCode, replyText, exchange1, routingKey, properties, body) -> {\n+                      try {\n+                        recordsToPublish.put(body);\n+                      } catch (Exception e) {\n+                        throw new RuntimeException(e);\n+                      }\n+                    });\n+                waitForExchangeToBeDeclared.countDown();\n+                while (true) {\n+                  byte[] record = recordsToPublish.take();\n+                  if (record == terminalRecord) {\n+                    return;\n+                  }\n+                  channel.basicPublish(\n+                      exchange,\n+                      testPlan.publishRoutingKeyGen().get(),\n+                      true, // ensure that messages are returned to sender\n+                      testPlan.getPublishProperties(),\n+                      record);\n+                }\n \n-    ConnectionFactory connectionFactory = new ConnectionFactory();\n-    connectionFactory.setAutomaticRecoveryEnabled(false);\n-    connectionFactory.setUri(uri);\n-    Connection connection = null;\n-    Channel channel = null;\n-\n-    try {\n-      connection = connectionFactory.newConnection();\n-      channel = connection.createChannel();\n-      channel.exchangeDeclare(exchange, exchangeType);\n-      final Channel finalChannel = channel;\n-      Thread publisher =\n-          new Thread(\n-              () -> {\n-                try {\n-                  Thread.sleep(5000);\n-                } catch (Exception e) {\n-                  LOG.error(e.getMessage(), e);\n+              } catch (Exception e) {\n+                throw new RuntimeException(e);\n+              } finally {\n+                if (channel != null) {\n+                  // channel may have already been closed automatically due to protocol failure\n+                  try {\n+                    channel.close();\n+                  } catch (Exception e) {\n+                    /* ignored */\n+                  }\n                 }\n-                for (int i = 0; i < testPlan.getNumRecordsToPublish(); i++) {\n+                if (connection != null) {\n+                  // connection may have already been closed automatically due to protocol failure\n                   try {\n-                    finalChannel.basicPublish(\n-                        exchange,\n-                        testPlan.publishRoutingKeyGen().get(),\n-                        testPlan.getPublishProperties(),\n-                        RabbitMqTestUtils.generateRecord(i));\n+                    connection.close();\n                   } catch (Exception e) {\n-                    LOG.error(e.getMessage(), e);\n+                    /* ignored */\n                   }\n                 }\n-              });\n-      publisher.start();\n-      p.run();\n-      publisher.join();\n-    } finally {\n-      if (channel != null) {\n-        // channel may have already been closed automatically due to protocol failure\n-        try {\n-          channel.close();\n-        } catch (Exception e) {\n-          /* ignored */\n-        }\n-      }\n-      if (connection != null) {\n-        // connection may have already been closed automatically due to protocol failure\n-        try {\n-          connection.close();\n-        } catch (Exception e) {\n-          /* ignored */\n-        }\n-      }\n-    }\n+              }\n+            });\n+    publisher.start();\n+    waitForExchangeToBeDeclared.countDown();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1ce25cf9aaf99ae94a98a25fe8287c884d5f2d"}, "originalPosition": 135}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b675acaf9093a1e0edf5c1ce181be95405227c09", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/b675acaf9093a1e0edf5c1ce181be95405227c09", "committedDate": "2020-07-07T20:27:28Z", "message": "Update sdks/java/io/rabbitmq/src/test/java/org/apache/beam/sdk/io/rabbitmq/RabbitMqIOTest.java\n\nCo-authored-by: Maximilian Michels <mxm@apache.org>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NTQyMTc5", "url": "https://github.com/apache/beam/pull/12184#pullrequestreview-444542179", "createdAt": "2020-07-08T08:52:59Z", "commit": {"oid": "b675acaf9093a1e0edf5c1ce181be95405227c09"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3378, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}