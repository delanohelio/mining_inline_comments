{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNzI3MTM0", "number": 13122, "title": "[BEAM-9547] More complete indexing capabilities.", "bodyText": "Thank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nDataflow\nFlink\nSamza\nSpark\nTwister2\n\n\n\n\nGo\n\n---\n\n---\n\n---\n\n\nJava\n\n\n\n\n\n\n\n\nPython\n\n\n\n---\n\n---\n\n\nXLang\n\n---\n\n---\n\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\nWhitespace\nTypescript\n\n\n\n\nNon-portable\n\n \n\n\n\n\n\n\nPortable\n---\n\n---\n---\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.\nGitHub Actions Tests Status (on master branch)\n\n\n\nSee CI.md for more information about GitHub Actions CI.", "createdAt": "2020-10-15T00:27:32Z", "url": "https://github.com/apache/beam/pull/13122", "merged": true, "mergeCommit": {"oid": "05e3dd027e8a1bdb6aa2b65800162cdeb3e724c5"}, "closed": true, "closedAt": "2020-10-23T17:01:55Z", "author": {"login": "robertwb"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSmmAvgH2gAyNTAzNzI3MTM0OjQ1OGU5ZjM4ZDlkNWE1ZWFmYzM3ZGFkNjJhMTBiNWVhODEyM2RkNzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdVLhoUAH2gAyNTAzNzI3MTM0OmQ2MzNjMmQ0NWQ3ZTY4ZDBhMDc1ODQyOGRjNGRiNDZmZmFkMTQ1NmE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "458e9f38d9d5a5eafc37dad62a10b5ea8123dd77", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/458e9f38d9d5a5eafc37dad62a10b5ea8123dd77", "committedDate": "2020-10-15T00:25:47Z", "message": "[BEAM-9547] More complete indexing capabilities."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODM5NTcw", "url": "https://github.com/apache/beam/pull/13122#pullrequestreview-510839570", "createdAt": "2020-10-16T23:00:39Z", "commit": {"oid": "458e9f38d9d5a5eafc37dad62a10b5ea8123dd77"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMzowMDozOVrOHjR6Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMzoyMDo1MlrOHjSLJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1NTU5OA==", "bodyText": "You could use _is_null_slice and _is_integer_slice here for clarity.", "url": "https://github.com/apache/beam/pull/13122#discussion_r506755598", "createdAt": "2020-10-16T23:00:39Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -32,9 +32,74 @@ def __array__(self, dtype=None):\n     raise frame_base.WontImplementError(\n         'Conversion to a non-deferred a numpy array.')\n \n+  get = frame_base.not_implemented_method('get')\n+\n \n @frame_base.DeferredFrame._register_for(pd.Series)\n class DeferredSeries(DeferredDataFrameOrSeries):\n+  def __getitem__(self, key):\n+    if _is_null_slice(key) or key is Ellipsis:\n+      return self\n+\n+    elif (isinstance(key, int) or _is_integer_slice(key)\n+          ) and self._expr.proxy().index._should_fallback_to_positional():\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    elif isinstance(key, slice) or callable(key):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              # yapf: disable\n+              'getitem',\n+              lambda df: df[key],\n+              [self._expr],\n+              requires_partition_by=partitionings.Nothing(),\n+              preserves_partition_by=partitionings.Singleton()))\n+\n+    elif isinstance(key, DeferredSeries):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              # yapf: disable\n+              'getitem',\n+              lambda df, indexer: df[indexer],\n+              [self._expr, key._expr],\n+              requires_partition_by=partitionings.Index(),\n+              preserves_partition_by=partitionings.Singleton()))\n+\n+    elif pd.core.series.is_iterator(key) or pd.core.common.is_bool_indexer(key):\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    else:\n+      # We could consider returning a deferred scalar, but that might\n+      # be more surprising than a clear error.\n+      raise frame_base.WontImplementError('non-deferred')\n+\n+    if isinstance(key, frame_base.DeferredBase):\n+      # Fail early if key is a DeferredBase as it interacts surprisingly with\n+      # key in self._expr.proxy().columns\n+      raise NotImplementedError(\n+          \"Indexing with a deferred frame is not yet supported. Consider \"\n+          \"using df.loc[...]\")\n+\n+    if isinstance(key, slice):\n+      types = set([type(key.start), type(key.stop), type(key.step)])\n+      if types == {type(None)}:\n+        # Empty slice is just a copy.\n+        return frame_base.DeferredFrame.wrap(self._expr)\n+      elif types in [{int}, {type(None), int}]:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "458e9f38d9d5a5eafc37dad62a10b5ea8123dd77"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1OTEzMA==", "bodyText": "Doesn't iloc only work for a null slice? I think we should just direct users to loc iff the proxy has an integer index. If it has a non-integer index we could tell the user they're going to have a bad time (maybe eventually it would link to some documentation about the dangers of integer-location based indexing in DataframeTransform).", "url": "https://github.com/apache/beam/pull/13122#discussion_r506759130", "createdAt": "2020-10-16T23:16:50Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -32,9 +32,74 @@ def __array__(self, dtype=None):\n     raise frame_base.WontImplementError(\n         'Conversion to a non-deferred a numpy array.')\n \n+  get = frame_base.not_implemented_method('get')\n+\n \n @frame_base.DeferredFrame._register_for(pd.Series)\n class DeferredSeries(DeferredDataFrameOrSeries):\n+  def __getitem__(self, key):\n+    if _is_null_slice(key) or key is Ellipsis:\n+      return self\n+\n+    elif (isinstance(key, int) or _is_integer_slice(key)\n+          ) and self._expr.proxy().index._should_fallback_to_positional():\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    elif isinstance(key, slice) or callable(key):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              # yapf: disable\n+              'getitem',\n+              lambda df: df[key],\n+              [self._expr],\n+              requires_partition_by=partitionings.Nothing(),\n+              preserves_partition_by=partitionings.Singleton()))\n+\n+    elif isinstance(key, DeferredSeries):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              # yapf: disable\n+              'getitem',\n+              lambda df, indexer: df[indexer],\n+              [self._expr, key._expr],\n+              requires_partition_by=partitionings.Index(),\n+              preserves_partition_by=partitionings.Singleton()))\n+\n+    elif pd.core.series.is_iterator(key) or pd.core.common.is_bool_indexer(key):\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    else:\n+      # We could consider returning a deferred scalar, but that might\n+      # be more surprising than a clear error.\n+      raise frame_base.WontImplementError('non-deferred')\n+\n+    if isinstance(key, frame_base.DeferredBase):\n+      # Fail early if key is a DeferredBase as it interacts surprisingly with\n+      # key in self._expr.proxy().columns\n+      raise NotImplementedError(\n+          \"Indexing with a deferred frame is not yet supported. Consider \"\n+          \"using df.loc[...]\")\n+\n+    if isinstance(key, slice):\n+      types = set([type(key.start), type(key.stop), type(key.step)])\n+      if types == {type(None)}:\n+        # Empty slice is just a copy.\n+        return frame_base.DeferredFrame.wrap(self._expr)\n+      elif types in [{int}, {type(None), int}]:\n+        # This depends on the contents of the index.\n+        raise frame_base.WontImplementError(\n+            'Use iloc or loc with integer slices.')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "458e9f38d9d5a5eafc37dad62a10b5ea8123dd77"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1OTk3Mw==", "bodyText": "Should we have this logic in DeferredSeries.__getitem__ too?", "url": "https://github.com/apache/beam/pull/13122#discussion_r506759973", "createdAt": "2020-10-16T23:20:52Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -453,17 +518,31 @@ def __getattr__(self, name):\n \n   def __getitem__(self, key):\n     # TODO: Replicate pd.DataFrame.__getitem__ logic\n-    if isinstance(key, frame_base.DeferredBase):\n+    if isinstance(key, DeferredSeries) and key._expr.proxy().dtype == bool:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "458e9f38d9d5a5eafc37dad62a10b5ea8123dd77"}, "originalPosition": 80}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c3ec4edb70cf11df5c2b3cee872c57ee52b9450", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/6c3ec4edb70cf11df5c2b3cee872c57ee52b9450", "committedDate": "2020-10-19T18:03:32Z", "message": "reviewer comments, cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4b7e77ad0d83c831a53dc511e4b548e73852949", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/d4b7e77ad0d83c831a53dc511e4b548e73852949", "committedDate": "2020-10-19T18:06:19Z", "message": "Merge branch 'master' into dataframe-index"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "544fee4baa61d01a9919e5980b0b28530b5aac36", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/544fee4baa61d01a9919e5980b0b28530b5aac36", "committedDate": "2020-10-19T19:47:26Z", "message": "lint"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f99f33be6ac19d7039ed3b9666685621406f3d8d", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/f99f33be6ac19d7039ed3b9666685621406f3d8d", "committedDate": "2020-10-20T18:01:11Z", "message": "yapf"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMDAxNTI5", "url": "https://github.com/apache/beam/pull/13122#pullrequestreview-512001529", "createdAt": "2020-10-19T17:37:28Z", "commit": {"oid": "458e9f38d9d5a5eafc37dad62a10b5ea8123dd77"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNzozNzoyOFrOHkZytA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNzo0NzozNlrOHkaWuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkzMzM2NA==", "bodyText": "Ah, yes, I meant to go back and change this. Thanks.", "url": "https://github.com/apache/beam/pull/13122#discussion_r507933364", "createdAt": "2020-10-19T17:37:28Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -32,9 +32,74 @@ def __array__(self, dtype=None):\n     raise frame_base.WontImplementError(\n         'Conversion to a non-deferred a numpy array.')\n \n+  get = frame_base.not_implemented_method('get')\n+\n \n @frame_base.DeferredFrame._register_for(pd.Series)\n class DeferredSeries(DeferredDataFrameOrSeries):\n+  def __getitem__(self, key):\n+    if _is_null_slice(key) or key is Ellipsis:\n+      return self\n+\n+    elif (isinstance(key, int) or _is_integer_slice(key)\n+          ) and self._expr.proxy().index._should_fallback_to_positional():\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    elif isinstance(key, slice) or callable(key):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              # yapf: disable\n+              'getitem',\n+              lambda df: df[key],\n+              [self._expr],\n+              requires_partition_by=partitionings.Nothing(),\n+              preserves_partition_by=partitionings.Singleton()))\n+\n+    elif isinstance(key, DeferredSeries):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              # yapf: disable\n+              'getitem',\n+              lambda df, indexer: df[indexer],\n+              [self._expr, key._expr],\n+              requires_partition_by=partitionings.Index(),\n+              preserves_partition_by=partitionings.Singleton()))\n+\n+    elif pd.core.series.is_iterator(key) or pd.core.common.is_bool_indexer(key):\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    else:\n+      # We could consider returning a deferred scalar, but that might\n+      # be more surprising than a clear error.\n+      raise frame_base.WontImplementError('non-deferred')\n+\n+    if isinstance(key, frame_base.DeferredBase):\n+      # Fail early if key is a DeferredBase as it interacts surprisingly with\n+      # key in self._expr.proxy().columns\n+      raise NotImplementedError(\n+          \"Indexing with a deferred frame is not yet supported. Consider \"\n+          \"using df.loc[...]\")\n+\n+    if isinstance(key, slice):\n+      types = set([type(key.start), type(key.stop), type(key.step)])\n+      if types == {type(None)}:\n+        # Empty slice is just a copy.\n+        return frame_base.DeferredFrame.wrap(self._expr)\n+      elif types in [{int}, {type(None), int}]:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1NTU5OA=="}, "originalCommit": {"oid": "458e9f38d9d5a5eafc37dad62a10b5ea8123dd77"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkzNTU4Mg==", "bodyText": "Eventually we may make iloc work for integer indices, but if not they'll get a better error there. The problem with directing users to loc directly is that df.loc[ix] is not a drop in replacement for df[ix] here, in fact it can be quite different, and so we need to force people to think about what they're trying to do.", "url": "https://github.com/apache/beam/pull/13122#discussion_r507935582", "createdAt": "2020-10-19T17:40:23Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -32,9 +32,74 @@ def __array__(self, dtype=None):\n     raise frame_base.WontImplementError(\n         'Conversion to a non-deferred a numpy array.')\n \n+  get = frame_base.not_implemented_method('get')\n+\n \n @frame_base.DeferredFrame._register_for(pd.Series)\n class DeferredSeries(DeferredDataFrameOrSeries):\n+  def __getitem__(self, key):\n+    if _is_null_slice(key) or key is Ellipsis:\n+      return self\n+\n+    elif (isinstance(key, int) or _is_integer_slice(key)\n+          ) and self._expr.proxy().index._should_fallback_to_positional():\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    elif isinstance(key, slice) or callable(key):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              # yapf: disable\n+              'getitem',\n+              lambda df: df[key],\n+              [self._expr],\n+              requires_partition_by=partitionings.Nothing(),\n+              preserves_partition_by=partitionings.Singleton()))\n+\n+    elif isinstance(key, DeferredSeries):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              # yapf: disable\n+              'getitem',\n+              lambda df, indexer: df[indexer],\n+              [self._expr, key._expr],\n+              requires_partition_by=partitionings.Index(),\n+              preserves_partition_by=partitionings.Singleton()))\n+\n+    elif pd.core.series.is_iterator(key) or pd.core.common.is_bool_indexer(key):\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    else:\n+      # We could consider returning a deferred scalar, but that might\n+      # be more surprising than a clear error.\n+      raise frame_base.WontImplementError('non-deferred')\n+\n+    if isinstance(key, frame_base.DeferredBase):\n+      # Fail early if key is a DeferredBase as it interacts surprisingly with\n+      # key in self._expr.proxy().columns\n+      raise NotImplementedError(\n+          \"Indexing with a deferred frame is not yet supported. Consider \"\n+          \"using df.loc[...]\")\n+\n+    if isinstance(key, slice):\n+      types = set([type(key.start), type(key.stop), type(key.step)])\n+      if types == {type(None)}:\n+        # Empty slice is just a copy.\n+        return frame_base.DeferredFrame.wrap(self._expr)\n+      elif types in [{int}, {type(None), int}]:\n+        # This depends on the contents of the index.\n+        raise frame_base.WontImplementError(\n+            'Use iloc or loc with integer slices.')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1OTEzMA=="}, "originalCommit": {"oid": "458e9f38d9d5a5eafc37dad62a10b5ea8123dd77"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk0MjU4Nw==", "bodyText": "Ah, yes, done.", "url": "https://github.com/apache/beam/pull/13122#discussion_r507942587", "createdAt": "2020-10-19T17:47:36Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -453,17 +518,31 @@ def __getattr__(self, name):\n \n   def __getitem__(self, key):\n     # TODO: Replicate pd.DataFrame.__getitem__ logic\n-    if isinstance(key, frame_base.DeferredBase):\n+    if isinstance(key, DeferredSeries) and key._expr.proxy().dtype == bool:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1OTk3Mw=="}, "originalCommit": {"oid": "458e9f38d9d5a5eafc37dad62a10b5ea8123dd77"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MDc3OTA3", "url": "https://github.com/apache/beam/pull/13122#pullrequestreview-515077907", "createdAt": "2020-10-22T20:05:43Z", "commit": {"oid": "f99f33be6ac19d7039ed3b9666685621406f3d8d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d633c2d45d7e68d0a0758428dc4db46ffad1456a", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/d633c2d45d7e68d0a0758428dc4db46ffad1456a", "committedDate": "2020-10-23T00:35:20Z", "message": "Merge branch 'master' into dataframe-index"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2074, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}