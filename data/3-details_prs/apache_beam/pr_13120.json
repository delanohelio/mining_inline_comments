{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNjk2MTg0", "number": 13120, "title": "[BEAM-10940] Lengthprefix any input coder for an ProcessBundleDescriptor.", "bodyText": "We need to length-prefix the coder of the input pcollection for one executable stage especially when there is an SDF or a stateful DoFn, where:\n\n\nIn SDF, the input coder is for encoding DelayedBundleApplication\n\n\nIn one stateful DoFn, the input coder is for encoding the key for state request.\n\n\nr: @lukecwik @mxm\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nDataflow\nFlink\nSamza\nSpark\nTwister2\n\n\n\n\nGo\n\n---\n\n---\n\n---\n\n\nJava\n\n\n\n\n\n\n\n\nPython\n\n\n\n---\n\n---\n\n\nXLang\n\n---\n\n---\n\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\nWhitespace\nTypescript\n\n\n\n\nNon-portable\n\n \n\n\n\n\n\n\nPortable\n---\n\n---\n---\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.\nGitHub Actions Tests Status (on master branch)\n\n\n\nSee CI.md for more information about GitHub Actions CI.", "createdAt": "2020-10-14T22:46:17Z", "url": "https://github.com/apache/beam/pull/13120", "merged": true, "mergeCommit": {"oid": "5419c3b6631f7e2d7f39c769dbfba8336de7338d"}, "closed": true, "closedAt": "2020-10-21T18:35:31Z", "author": {"login": "boyuanzz"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdTDziKAFqTUxMDM0MzczOA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdUxdvMgFqTUxNDA0NzE5NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwMzQzNzM4", "url": "https://github.com/apache/beam/pull/13120#pullrequestreview-510343738", "createdAt": "2020-10-16T10:24:11Z", "commit": {"oid": "d78347c63196c69d27a3af05b9cbb9a7f84a6d09"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMDoyNDoxMVrOHiz-lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMDoyNDoxMVrOHiz-lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI2NTIzNg==", "bodyText": "Worth mentioning this will break any existing non-stateful pipelines. We could add another exception here for SDFs, but it's probably better to have a consistent encoding which does not depend on DoFns using state or timers.", "url": "https://github.com/apache/beam/pull/13120#discussion_r506265236", "createdAt": "2020-10-16T10:24:11Z", "author": {"login": "mxm"}, "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptors.java", "diffHunk": "@@ -141,9 +139,7 @@ private static ExecutableProcessBundleDescriptor fromExecutableStageInternal(\n \n     Map<String, Map<String, TimerSpec>> timerSpecs = forTimerSpecs(stage, components);\n \n-    if (bagUserStateSpecs.size() > 0 || timerSpecs.size() > 0) {\n-      lengthPrefixKeyCoder(stage.getInputPCollection().getId(), components);\n-    }\n+    lengthPrefixAnyInputCoder(stage.getInputPCollection().getId(), components);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d78347c63196c69d27a3af05b9cbb9a7f84a6d09"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNzc2MzEy", "url": "https://github.com/apache/beam/pull/13120#pullrequestreview-512776312", "createdAt": "2020-10-20T14:24:20Z", "commit": {"oid": "d78347c63196c69d27a3af05b9cbb9a7f84a6d09"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNDoyNDoyMVrOHk_qtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNDoyNDoyMVrOHk_qtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU1MzkxMA==", "bodyText": "I'm wondering, why is length-prefixing the key coder not necessary anymore? Wouldn't the SDK Harness be able to extract a non-length-prefixed key coder even though the input coder has been legth-prefixed? This would then cause a regression like in #9997 if the SDK Harness didn't use the NESTED contex, which it currently does because we had fix this a while ago: \n  \n    \n      beam/sdks/python/apache_beam/runners/worker/bundle_processor.py\n    \n    \n         Line 769\n      in\n      57d2497\n    \n    \n    \n    \n\n        \n          \n           key=self._key_coder.encode_nested(key))), \n        \n    \n  \n\n The idea was to always ensure keys are length-prefixed, so we never run into inconsistent key encodings between the Runner and the SDK Harness.", "url": "https://github.com/apache/beam/pull/13120#discussion_r508553910", "createdAt": "2020-10-20T14:24:21Z", "author": {"login": "mxm"}, "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptors.java", "diffHunk": "@@ -174,26 +170,18 @@ private static ExecutableProcessBundleDescriptor fromExecutableStageInternal(\n   }\n \n   /**\n-   * Patches the input coder of a stateful transform to ensure that the byte representation of a key\n-   * used to partition the input element at the Runner, matches the key byte representation received\n-   * for state requests and timers from the SDK Harness. Stateful transforms always have a KvCoder\n-   * as input.\n+   * Patches the input coder of the transform to ensure that the byte representation of input used\n+   * at the Runner, matches the byte representation received from the SDK Harness.\n    */\n-  private static void lengthPrefixKeyCoder(\n-      String inputColId, Components.Builder componentsBuilder) {\n-    RunnerApi.PCollection pcollection = componentsBuilder.getPcollectionsOrThrow(inputColId);\n-    RunnerApi.Coder kvCoder = componentsBuilder.getCodersOrThrow(pcollection.getCoderId());\n-    Preconditions.checkState(\n-        ModelCoders.KV_CODER_URN.equals(kvCoder.getSpec().getUrn()),\n-        \"Stateful executable stages must use a KV coder, but is: %s\",\n-        kvCoder.getSpec().getUrn());\n-    String keyCoderId = ModelCoders.getKvCoderComponents(kvCoder).keyCoderId();\n-    // Retain the original coder, but wrap in LengthPrefixCoder\n-    String newKeyCoderId =\n-        LengthPrefixUnknownCoders.addLengthPrefixedCoder(keyCoderId, componentsBuilder, false);\n-    // Replace old key coder with LengthPrefixCoder<old_key_coder>\n-    kvCoder = kvCoder.toBuilder().setComponentCoderIds(0, newKeyCoderId).build();\n-    componentsBuilder.putCoders(pcollection.getCoderId(), kvCoder);\n+  private static void lengthPrefixAnyInputCoder(\n+      String inputPCollectionId, Components.Builder componentsBuilder) {\n+    RunnerApi.PCollection pcollection =\n+        componentsBuilder.getPcollectionsOrThrow(inputPCollectionId);\n+    String newInputCoderId =\n+        LengthPrefixUnknownCoders.addLengthPrefixedCoder(\n+            pcollection.getCoderId(), componentsBuilder, false);\n+    componentsBuilder.putPcollections(\n+        inputPCollectionId, pcollection.toBuilder().setCoderId(newInputCoderId).build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d78347c63196c69d27a3af05b9cbb9a7f84a6d09"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzOTM2ODM3", "url": "https://github.com/apache/beam/pull/13120#pullrequestreview-513936837", "createdAt": "2020-10-21T16:46:13Z", "commit": {"oid": "d78347c63196c69d27a3af05b9cbb9a7f84a6d09"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0NjoxM1rOHl13iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0NzoxN1rOHl16MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0MTkyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                RunnerApi.Coder elementCoder =\n          \n          \n            \n                RunnerApi.Coder keyCoder =", "url": "https://github.com/apache/beam/pull/13120#discussion_r509441928", "createdAt": "2020-10-21T16:46:13Z", "author": {"login": "mxm"}, "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptorsTest.java", "diffHunk": "@@ -151,6 +157,99 @@ public void onTimer() {}\n     ensureLengthPrefixed(timerKeyCoder, originalKeyCoder, pbsCoderMap);\n   }\n \n+  @Test\n+  public void testLengthPrefixingOfInputCoderExecutableStage() throws Exception {\n+    Pipeline p = Pipeline.create();\n+    Coder<Void> voidCoder = VoidCoder.of();\n+    assertThat(ModelCoderRegistrar.isKnownCoder(voidCoder), is(false));\n+    p.apply(\"impulse\", Impulse.create())\n+        .apply(\n+            ParDo.of(\n+                new DoFn<byte[], Void>() {\n+                  @ProcessElement\n+                  public void process(ProcessContext ctxt) {}\n+                }))\n+        .setCoder(voidCoder)\n+        .apply(\n+            ParDo.of(\n+                new DoFn<Void, Void>() {\n+                  @ProcessElement\n+                  public void processElement(\n+                      ProcessContext context, RestrictionTracker<Void, Void> tracker) {}\n+\n+                  @GetInitialRestriction\n+                  public Void getInitialRestriction() {\n+                    return null;\n+                  }\n+\n+                  @NewTracker\n+                  public SomeTracker newTracker(@Restriction Void restriction) {\n+                    return null;\n+                  }\n+                }))\n+        .setCoder(voidCoder);\n+    RunnerApi.Pipeline pipelineProto = PipelineTranslation.toProto(p);\n+    RunnerApi.Pipeline pipelineWithSdfExpanded =\n+        ProtoOverrides.updateTransform(\n+            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+            pipelineProto,\n+            SplittableParDoExpander.createSizedReplacement());\n+    FusedPipeline fused = GreedyPipelineFuser.fuse(pipelineWithSdfExpanded);\n+    Optional<ExecutableStage> optionalStage =\n+        Iterables.tryFind(\n+            fused.getFusedStages(),\n+            (ExecutableStage stage) ->\n+                stage.getTransforms().stream()\n+                    .anyMatch(\n+                        transform ->\n+                            transform\n+                                .getTransform()\n+                                .getSpec()\n+                                .getUrn()\n+                                .equals(\n+                                    PTransformTranslation\n+                                        .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)));\n+    checkState(\n+        optionalStage.isPresent(),\n+        \"Expected a stage with SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN.\");\n+\n+    ExecutableStage stage = optionalStage.get();\n+    PipelineNode.PCollectionNode inputPCollection = stage.getInputPCollection();\n+    Map<String, RunnerApi.Coder> stageCoderMap = stage.getComponents().getCodersMap();\n+    RunnerApi.Coder originalMainInputCoder =\n+        stageCoderMap.get(inputPCollection.getPCollection().getCoderId());\n+\n+    BeamFnApi.ProcessBundleDescriptor pbd =\n+        ProcessBundleDescriptors.fromExecutableStage(\n+                \"test_stage\", stage, Endpoints.ApiServiceDescriptor.getDefaultInstance())\n+            .getProcessBundleDescriptor();\n+    Map<String, RunnerApi.Coder> pbsCoderMap = pbd.getCodersMap();\n+\n+    RunnerApi.Coder pbsMainInputCoder =\n+        pbsCoderMap.get(pbd.getPcollectionsOrThrow(inputPCollection.getId()).getCoderId());\n+\n+    RunnerApi.Coder kvCoder =\n+        pbsCoderMap.get(ModelCoders.getKvCoderComponents(pbsMainInputCoder).keyCoderId());\n+    RunnerApi.Coder elementCoder =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d78347c63196c69d27a3af05b9cbb9a7f84a6d09"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0MjIzOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                RunnerApi.Coder originalElementCoder =\n          \n          \n            \n                RunnerApi.Coder originalKeyCoder =", "url": "https://github.com/apache/beam/pull/13120#discussion_r509442238", "createdAt": "2020-10-21T16:46:45Z", "author": {"login": "mxm"}, "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptorsTest.java", "diffHunk": "@@ -151,6 +157,99 @@ public void onTimer() {}\n     ensureLengthPrefixed(timerKeyCoder, originalKeyCoder, pbsCoderMap);\n   }\n \n+  @Test\n+  public void testLengthPrefixingOfInputCoderExecutableStage() throws Exception {\n+    Pipeline p = Pipeline.create();\n+    Coder<Void> voidCoder = VoidCoder.of();\n+    assertThat(ModelCoderRegistrar.isKnownCoder(voidCoder), is(false));\n+    p.apply(\"impulse\", Impulse.create())\n+        .apply(\n+            ParDo.of(\n+                new DoFn<byte[], Void>() {\n+                  @ProcessElement\n+                  public void process(ProcessContext ctxt) {}\n+                }))\n+        .setCoder(voidCoder)\n+        .apply(\n+            ParDo.of(\n+                new DoFn<Void, Void>() {\n+                  @ProcessElement\n+                  public void processElement(\n+                      ProcessContext context, RestrictionTracker<Void, Void> tracker) {}\n+\n+                  @GetInitialRestriction\n+                  public Void getInitialRestriction() {\n+                    return null;\n+                  }\n+\n+                  @NewTracker\n+                  public SomeTracker newTracker(@Restriction Void restriction) {\n+                    return null;\n+                  }\n+                }))\n+        .setCoder(voidCoder);\n+    RunnerApi.Pipeline pipelineProto = PipelineTranslation.toProto(p);\n+    RunnerApi.Pipeline pipelineWithSdfExpanded =\n+        ProtoOverrides.updateTransform(\n+            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+            pipelineProto,\n+            SplittableParDoExpander.createSizedReplacement());\n+    FusedPipeline fused = GreedyPipelineFuser.fuse(pipelineWithSdfExpanded);\n+    Optional<ExecutableStage> optionalStage =\n+        Iterables.tryFind(\n+            fused.getFusedStages(),\n+            (ExecutableStage stage) ->\n+                stage.getTransforms().stream()\n+                    .anyMatch(\n+                        transform ->\n+                            transform\n+                                .getTransform()\n+                                .getSpec()\n+                                .getUrn()\n+                                .equals(\n+                                    PTransformTranslation\n+                                        .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)));\n+    checkState(\n+        optionalStage.isPresent(),\n+        \"Expected a stage with SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN.\");\n+\n+    ExecutableStage stage = optionalStage.get();\n+    PipelineNode.PCollectionNode inputPCollection = stage.getInputPCollection();\n+    Map<String, RunnerApi.Coder> stageCoderMap = stage.getComponents().getCodersMap();\n+    RunnerApi.Coder originalMainInputCoder =\n+        stageCoderMap.get(inputPCollection.getPCollection().getCoderId());\n+\n+    BeamFnApi.ProcessBundleDescriptor pbd =\n+        ProcessBundleDescriptors.fromExecutableStage(\n+                \"test_stage\", stage, Endpoints.ApiServiceDescriptor.getDefaultInstance())\n+            .getProcessBundleDescriptor();\n+    Map<String, RunnerApi.Coder> pbsCoderMap = pbd.getCodersMap();\n+\n+    RunnerApi.Coder pbsMainInputCoder =\n+        pbsCoderMap.get(pbd.getPcollectionsOrThrow(inputPCollection.getId()).getCoderId());\n+\n+    RunnerApi.Coder kvCoder =\n+        pbsCoderMap.get(ModelCoders.getKvCoderComponents(pbsMainInputCoder).keyCoderId());\n+    RunnerApi.Coder elementCoder =\n+        pbsCoderMap.get(ModelCoders.getKvCoderComponents(kvCoder).keyCoderId());\n+    RunnerApi.Coder valueKvCoder =\n+        pbsCoderMap.get(ModelCoders.getKvCoderComponents(kvCoder).valueCoderId());\n+    RunnerApi.Coder valueCoder =\n+        pbsCoderMap.get(ModelCoders.getKvCoderComponents(valueKvCoder).keyCoderId());\n+\n+    RunnerApi.Coder originalKvCoder =\n+        stageCoderMap.get(ModelCoders.getKvCoderComponents(originalMainInputCoder).keyCoderId());\n+    RunnerApi.Coder originalElementCoder =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d78347c63196c69d27a3af05b9cbb9a7f84a6d09"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0MjYwOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ensureLengthPrefixed(elementCoder, originalElementCoder, pbsCoderMap);\n          \n          \n            \n                ensureLengthPrefixed(keyCoder, originalKeyCoder, pbsCoderMap);", "url": "https://github.com/apache/beam/pull/13120#discussion_r509442609", "createdAt": "2020-10-21T16:47:17Z", "author": {"login": "mxm"}, "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptorsTest.java", "diffHunk": "@@ -151,6 +157,99 @@ public void onTimer() {}\n     ensureLengthPrefixed(timerKeyCoder, originalKeyCoder, pbsCoderMap);\n   }\n \n+  @Test\n+  public void testLengthPrefixingOfInputCoderExecutableStage() throws Exception {\n+    Pipeline p = Pipeline.create();\n+    Coder<Void> voidCoder = VoidCoder.of();\n+    assertThat(ModelCoderRegistrar.isKnownCoder(voidCoder), is(false));\n+    p.apply(\"impulse\", Impulse.create())\n+        .apply(\n+            ParDo.of(\n+                new DoFn<byte[], Void>() {\n+                  @ProcessElement\n+                  public void process(ProcessContext ctxt) {}\n+                }))\n+        .setCoder(voidCoder)\n+        .apply(\n+            ParDo.of(\n+                new DoFn<Void, Void>() {\n+                  @ProcessElement\n+                  public void processElement(\n+                      ProcessContext context, RestrictionTracker<Void, Void> tracker) {}\n+\n+                  @GetInitialRestriction\n+                  public Void getInitialRestriction() {\n+                    return null;\n+                  }\n+\n+                  @NewTracker\n+                  public SomeTracker newTracker(@Restriction Void restriction) {\n+                    return null;\n+                  }\n+                }))\n+        .setCoder(voidCoder);\n+    RunnerApi.Pipeline pipelineProto = PipelineTranslation.toProto(p);\n+    RunnerApi.Pipeline pipelineWithSdfExpanded =\n+        ProtoOverrides.updateTransform(\n+            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+            pipelineProto,\n+            SplittableParDoExpander.createSizedReplacement());\n+    FusedPipeline fused = GreedyPipelineFuser.fuse(pipelineWithSdfExpanded);\n+    Optional<ExecutableStage> optionalStage =\n+        Iterables.tryFind(\n+            fused.getFusedStages(),\n+            (ExecutableStage stage) ->\n+                stage.getTransforms().stream()\n+                    .anyMatch(\n+                        transform ->\n+                            transform\n+                                .getTransform()\n+                                .getSpec()\n+                                .getUrn()\n+                                .equals(\n+                                    PTransformTranslation\n+                                        .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)));\n+    checkState(\n+        optionalStage.isPresent(),\n+        \"Expected a stage with SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN.\");\n+\n+    ExecutableStage stage = optionalStage.get();\n+    PipelineNode.PCollectionNode inputPCollection = stage.getInputPCollection();\n+    Map<String, RunnerApi.Coder> stageCoderMap = stage.getComponents().getCodersMap();\n+    RunnerApi.Coder originalMainInputCoder =\n+        stageCoderMap.get(inputPCollection.getPCollection().getCoderId());\n+\n+    BeamFnApi.ProcessBundleDescriptor pbd =\n+        ProcessBundleDescriptors.fromExecutableStage(\n+                \"test_stage\", stage, Endpoints.ApiServiceDescriptor.getDefaultInstance())\n+            .getProcessBundleDescriptor();\n+    Map<String, RunnerApi.Coder> pbsCoderMap = pbd.getCodersMap();\n+\n+    RunnerApi.Coder pbsMainInputCoder =\n+        pbsCoderMap.get(pbd.getPcollectionsOrThrow(inputPCollection.getId()).getCoderId());\n+\n+    RunnerApi.Coder kvCoder =\n+        pbsCoderMap.get(ModelCoders.getKvCoderComponents(pbsMainInputCoder).keyCoderId());\n+    RunnerApi.Coder elementCoder =\n+        pbsCoderMap.get(ModelCoders.getKvCoderComponents(kvCoder).keyCoderId());\n+    RunnerApi.Coder valueKvCoder =\n+        pbsCoderMap.get(ModelCoders.getKvCoderComponents(kvCoder).valueCoderId());\n+    RunnerApi.Coder valueCoder =\n+        pbsCoderMap.get(ModelCoders.getKvCoderComponents(valueKvCoder).keyCoderId());\n+\n+    RunnerApi.Coder originalKvCoder =\n+        stageCoderMap.get(ModelCoders.getKvCoderComponents(originalMainInputCoder).keyCoderId());\n+    RunnerApi.Coder originalElementCoder =\n+        stageCoderMap.get(ModelCoders.getKvCoderComponents(originalKvCoder).keyCoderId());\n+    RunnerApi.Coder originalvalueKvCoder =\n+        stageCoderMap.get(ModelCoders.getKvCoderComponents(originalKvCoder).valueCoderId());\n+    RunnerApi.Coder originalvalueCoder =\n+        stageCoderMap.get(ModelCoders.getKvCoderComponents(originalvalueKvCoder).keyCoderId());\n+\n+    ensureLengthPrefixed(elementCoder, originalElementCoder, pbsCoderMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d78347c63196c69d27a3af05b9cbb9a7f84a6d09"}, "originalPosition": 121}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc955ded10e0a054d437adf5c7117004de978d46", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/bc955ded10e0a054d437adf5c7117004de978d46", "committedDate": "2020-10-21T17:31:27Z", "message": "Lengthprefix any input coder for an ProcessBundleDescriptor."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6c302de206818b1f9541b3da0acf0e27356d778b", "author": {"user": {"login": "boyuanzz", "name": "Boyuan Zhang"}}, "url": "https://github.com/apache/beam/commit/6c302de206818b1f9541b3da0acf0e27356d778b", "committedDate": "2020-10-21T17:28:10Z", "message": "Update runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptorsTest.java\n\nCo-authored-by: Maximilian Michels <mxm@apache.org>"}, "afterCommit": {"oid": "bc955ded10e0a054d437adf5c7117004de978d46", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/bc955ded10e0a054d437adf5c7117004de978d46", "committedDate": "2020-10-21T17:31:27Z", "message": "Lengthprefix any input coder for an ProcessBundleDescriptor."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MDQ3MTk1", "url": "https://github.com/apache/beam/pull/13120#pullrequestreview-514047195", "createdAt": "2020-10-21T18:13:33Z", "commit": {"oid": "bc955ded10e0a054d437adf5c7117004de978d46"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2069, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}