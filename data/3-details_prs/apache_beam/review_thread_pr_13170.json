{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA4NTM2ODcw", "number": 13170, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxODo1NToyMVrOE2M5iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMjoyNzozNlrOE7xJjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjY5ODk3OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/io/gcp/bigquery.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxODo1NToyMVrOHu5xoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QyMzo1NjoyN1rOHzDPQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk0MzEzNg==", "bodyText": "I see a few different names here,\nReadAllFromBigQuery\nReadFromBigQueryRequest\nBigQueryReadRequest\nI'm a bit confused by the differences and interaction between these classes.\nIf ReadFromBigQueryRequest is something users interact with it should not be in an internal file (e.g. bigquery_read_internal.py). Is there a need to expose that at all? Instead could it just be:\nside_input = (\n  p\n  | 'PeriodicImpulse' >> PeriodicImpulse(...)\n  | beam.io.ReadAllFromBigQuery(table=...))\n\nThough this would make the initial example of several requests being included in a single ReadAll not possible. Is this something that needs to be special cased, as opposed to say, using a flatten?", "url": "https://github.com/apache/beam/pull/13170#discussion_r518943136", "createdAt": "2020-11-06T18:55:21Z", "author": {"login": "tysonjh"}, "path": "sdks/python/apache_beam/io/gcp/bigquery.py", "diffHunk": "@@ -79,6 +79,41 @@\n `ReadFromBigQuery`, you can use the flag `use_json_exports` to export\n data as JSON, and receive base64-encoded bytes.\n \n+ReadAllFromBigQuery\n+-------------------\n+Beam 2.27.0 introduces a new transform called `ReadAllFromBigQuery` which\n+allows you to define table and query reads from BigQuery at pipeline\n+runtime.:::\n+\n+  read_requests = p | beam.Create([\n+      ReadFromBigQueryRequest(query='SELECT * FROM mydataset.mytable'),\n+      ReadFromBigQueryRequest(table='myproject.mydataset.mytable')])\n+  results = read_requests | ReadAllFromBigQuery()\n+\n+A good application for this transform is in streaming pipelines to\n+refresh a side input coming from BigQuery. This would work like so:::\n+\n+  side_input = (\n+      p\n+      | 'PeriodicImpulse' >> PeriodicImpulse(\n+          first_timestamp, last_timestamp, interval, True)\n+      | 'MapToReadRequest' >> beam.Map(\n+          lambda x: BigQueryReadRequest(table='dataset.table'))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da42abab1ea6f987ba5e121b4c249455f968ee7f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQwNTg2OA==", "bodyText": "Regarding names - yes, that's a little confusing. The only names should be:\n\nReadFromBigQueryRequest - this is an input element for ReadAllFromBigQuery, and it represents a query or a table to be read (with a few other parameters).\nReadAllFromBigQuery - This is the transform that issues BQ reads.\n\nAll other names are misnaming in the configuration\n\nRegarding your example - that's interesting. I recognize that what you show would be the most common use case (same query/table always, rather than varying) - with the only exception that some queries could be slightly updated over time (e.g. read only partitions of the last few days).\notoh, this would create two ways of using the transform, and complicate the constructor (all of the parameters in ReadFromBQRequest would need to be available in the constructor).\nUsers could build this functionality themselves though. My feeling is that it's better to build a transform that is more composable, and provide an example for users trying to build the functionality you propose. WDYT?", "url": "https://github.com/apache/beam/pull/13170#discussion_r522405868", "createdAt": "2020-11-12T20:28:33Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/io/gcp/bigquery.py", "diffHunk": "@@ -79,6 +79,41 @@\n `ReadFromBigQuery`, you can use the flag `use_json_exports` to export\n data as JSON, and receive base64-encoded bytes.\n \n+ReadAllFromBigQuery\n+-------------------\n+Beam 2.27.0 introduces a new transform called `ReadAllFromBigQuery` which\n+allows you to define table and query reads from BigQuery at pipeline\n+runtime.:::\n+\n+  read_requests = p | beam.Create([\n+      ReadFromBigQueryRequest(query='SELECT * FROM mydataset.mytable'),\n+      ReadFromBigQueryRequest(table='myproject.mydataset.mytable')])\n+  results = read_requests | ReadAllFromBigQuery()\n+\n+A good application for this transform is in streaming pipelines to\n+refresh a side input coming from BigQuery. This would work like so:::\n+\n+  side_input = (\n+      p\n+      | 'PeriodicImpulse' >> PeriodicImpulse(\n+          first_timestamp, last_timestamp, interval, True)\n+      | 'MapToReadRequest' >> beam.Map(\n+          lambda x: BigQueryReadRequest(table='dataset.table'))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk0MzEzNg=="}, "originalCommit": {"oid": "da42abab1ea6f987ba5e121b4c249455f968ee7f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5MjQ4Mg==", "bodyText": "My feeling is that it's better to build a transform that is more composable, and provide an example for users trying to build the functionality you propose. WDYT?\n\n+1.", "url": "https://github.com/apache/beam/pull/13170#discussion_r523292482", "createdAt": "2020-11-13T23:56:27Z", "author": {"login": "tysonjh"}, "path": "sdks/python/apache_beam/io/gcp/bigquery.py", "diffHunk": "@@ -79,6 +79,41 @@\n `ReadFromBigQuery`, you can use the flag `use_json_exports` to export\n data as JSON, and receive base64-encoded bytes.\n \n+ReadAllFromBigQuery\n+-------------------\n+Beam 2.27.0 introduces a new transform called `ReadAllFromBigQuery` which\n+allows you to define table and query reads from BigQuery at pipeline\n+runtime.:::\n+\n+  read_requests = p | beam.Create([\n+      ReadFromBigQueryRequest(query='SELECT * FROM mydataset.mytable'),\n+      ReadFromBigQueryRequest(table='myproject.mydataset.mytable')])\n+  results = read_requests | ReadAllFromBigQuery()\n+\n+A good application for this transform is in streaming pipelines to\n+refresh a side input coming from BigQuery. This would work like so:::\n+\n+  side_input = (\n+      p\n+      | 'PeriodicImpulse' >> PeriodicImpulse(\n+          first_timestamp, last_timestamp, interval, True)\n+      | 'MapToReadRequest' >> beam.Map(\n+          lambda x: BigQueryReadRequest(table='dataset.table'))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk0MzEzNg=="}, "originalCommit": {"oid": "da42abab1ea6f987ba5e121b4c249455f968ee7f"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MTAwNDUwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/io/gcp/bigquery.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMzoyNTowNFrOHwFlkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMDoyMjowOVrOHyMw4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4NTIzNA==", "bodyText": "This should be resolved or attributed to a Jira issue.", "url": "https://github.com/apache/beam/pull/13170#discussion_r520185234", "createdAt": "2020-11-09T23:25:04Z", "author": {"login": "tysonjh"}, "path": "sdks/python/apache_beam/io/gcp/bigquery.py", "diffHunk": "@@ -1919,3 +1890,77 @@ def file_path_to_remove(unused_elm):\n                 *self._args,\n                 **self._kwargs))\n         | _PassThroughThenCleanup(files_to_remove_pcoll))\n+\n+\n+@experimental()\n+class ReadAllFromBigQuery(PTransform):\n+  \"\"\"Read data from BigQuery.\n+\n+    PTransform:ReadAllFromBigQueryRequest->Rows\n+\n+    This PTransform uses a BigQuery export job to take a snapshot of the table\n+    on GCS, and then reads from each produced JSON file.\n+\n+    It is recommended not to use this PTransform for streaming jobs on\n+    GlobalWindow, since it will not be able to cleanup snapshots.\n+\n+  Args:\n+    gcs_location (str): The name of the Google Cloud Storage\n+      bucket where the extracted table should be written as a string. If\n+      :data:`None`, then the temp_location parameter is used.\n+    validate (bool): If :data:`True`, various checks will be done when source\n+      gets initialized (e.g., is table present?).\n+    kms_key (str): Experimental. Optional Cloud KMS key name for use when\n+      creating new temporary tables.\n+   \"\"\"\n+  COUNTER = 0\n+\n+  def __init__(\n+      self,\n+      gcs_location: Union[str, ValueProvider] = None,\n+      validate: bool = False,\n+      kms_key: str = None,\n+      bigquery_job_labels: Dict[str, str] = None):\n+    if gcs_location:\n+      if not isinstance(gcs_location, (str, ValueProvider)):\n+        raise TypeError(\n+            '%s: gcs_location must be of type string'\n+            ' or ValueProvider; got %r instead' %\n+            (self.__class__.__name__, type(gcs_location)))\n+\n+    self.gcs_location = gcs_location\n+    self.validate = validate\n+    self.kms_key = kms_key\n+    self.bigquery_job_labels = bigquery_job_labels\n+\n+  def expand(self, pcoll):\n+    job_name = pcoll.pipeline.options.view_as(GoogleCloudOptions).job_name\n+    project = pcoll.pipeline.options.view_as(GoogleCloudOptions).project\n+    unique_id = str(uuid.uuid4())[0:10]\n+\n+    try:\n+      step_name = self.label\n+    except AttributeError:\n+      step_name = 'ReadAllFromBigQuery_%d' % ReadAllFromBigQuery.COUNTER\n+      ReadAllFromBigQuery.COUNTER += 1\n+\n+    sources_to_read, cleanup_locations = (\n+        pcoll\n+        | beam.ParDo(\n+        # TODO(pabloem): Make sure we have all necessary args.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da42abab1ea6f987ba5e121b4c249455f968ee7f"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM5OTk2OA==", "bodyText": "removed. thanks Tyson!", "url": "https://github.com/apache/beam/pull/13170#discussion_r522399968", "createdAt": "2020-11-12T20:22:09Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/io/gcp/bigquery.py", "diffHunk": "@@ -1919,3 +1890,77 @@ def file_path_to_remove(unused_elm):\n                 *self._args,\n                 **self._kwargs))\n         | _PassThroughThenCleanup(files_to_remove_pcoll))\n+\n+\n+@experimental()\n+class ReadAllFromBigQuery(PTransform):\n+  \"\"\"Read data from BigQuery.\n+\n+    PTransform:ReadAllFromBigQueryRequest->Rows\n+\n+    This PTransform uses a BigQuery export job to take a snapshot of the table\n+    on GCS, and then reads from each produced JSON file.\n+\n+    It is recommended not to use this PTransform for streaming jobs on\n+    GlobalWindow, since it will not be able to cleanup snapshots.\n+\n+  Args:\n+    gcs_location (str): The name of the Google Cloud Storage\n+      bucket where the extracted table should be written as a string. If\n+      :data:`None`, then the temp_location parameter is used.\n+    validate (bool): If :data:`True`, various checks will be done when source\n+      gets initialized (e.g., is table present?).\n+    kms_key (str): Experimental. Optional Cloud KMS key name for use when\n+      creating new temporary tables.\n+   \"\"\"\n+  COUNTER = 0\n+\n+  def __init__(\n+      self,\n+      gcs_location: Union[str, ValueProvider] = None,\n+      validate: bool = False,\n+      kms_key: str = None,\n+      bigquery_job_labels: Dict[str, str] = None):\n+    if gcs_location:\n+      if not isinstance(gcs_location, (str, ValueProvider)):\n+        raise TypeError(\n+            '%s: gcs_location must be of type string'\n+            ' or ValueProvider; got %r instead' %\n+            (self.__class__.__name__, type(gcs_location)))\n+\n+    self.gcs_location = gcs_location\n+    self.validate = validate\n+    self.kms_key = kms_key\n+    self.bigquery_job_labels = bigquery_job_labels\n+\n+  def expand(self, pcoll):\n+    job_name = pcoll.pipeline.options.view_as(GoogleCloudOptions).job_name\n+    project = pcoll.pipeline.options.view_as(GoogleCloudOptions).project\n+    unique_id = str(uuid.uuid4())[0:10]\n+\n+    try:\n+      step_name = self.label\n+    except AttributeError:\n+      step_name = 'ReadAllFromBigQuery_%d' % ReadAllFromBigQuery.COUNTER\n+      ReadAllFromBigQuery.COUNTER += 1\n+\n+    sources_to_read, cleanup_locations = (\n+        pcoll\n+        | beam.ParDo(\n+        # TODO(pabloem): Make sure we have all necessary args.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4NTIzNA=="}, "originalCommit": {"oid": "da42abab1ea6f987ba5e121b4c249455f968ee7f"}, "originalPosition": 279}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MTAxNjkyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMzozMDowNFrOHwFtFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMDoyMjoxMlrOHyMw-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4NzE1Ng==", "bodyText": "The default here is False.", "url": "https://github.com/apache/beam/pull/13170#discussion_r520187156", "createdAt": "2020-11-09T23:30:04Z", "author": {"login": "tysonjh"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "diffHunk": "@@ -100,3 +121,290 @@ def process(self, unused_element, unused_signal, gcs_locations):\n     )\n \n     return main_output\n+\n+\n+class ReadFromBigQueryRequest:\n+  \"\"\"\n+  Class that defines data to read from BQ.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      query: str = None,\n+      use_standard_sql: bool = True,\n+      table: Union[str, TableReference] = None,\n+      flatten_results: bool = False):\n+    \"\"\"\n+    Only one of query or table should be specified.\n+\n+    :param query: SQL query to fetch data.\n+    :param use_standard_sql:\n+      Specifies whether to use BigQuery's standard SQL dialect for this query.\n+      The default value is :data:`True`. If set to :data:`False`,\n+      the query will use BigQuery's legacy SQL dialect.\n+      This parameter is ignored for table inputs.\n+    :param table:\n+      The ID of the table to read. The ID must contain only letters\n+      ``a-z``, ``A-Z``, numbers ``0-9``, or underscores ``_``. Table should\n+      define project and dataset (ex.: ``'PROJECT:DATASET.TABLE'``).\n+    :param flatten_results:\n+      Flattens all nested and repeated fields in the query results.\n+      The default value is :data:`True`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da42abab1ea6f987ba5e121b4c249455f968ee7f"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM5OTk5NA==", "bodyText": "oops good catch. Thanks Tyson!", "url": "https://github.com/apache/beam/pull/13170#discussion_r522399994", "createdAt": "2020-11-12T20:22:12Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "diffHunk": "@@ -100,3 +121,290 @@ def process(self, unused_element, unused_signal, gcs_locations):\n     )\n \n     return main_output\n+\n+\n+class ReadFromBigQueryRequest:\n+  \"\"\"\n+  Class that defines data to read from BQ.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      query: str = None,\n+      use_standard_sql: bool = True,\n+      table: Union[str, TableReference] = None,\n+      flatten_results: bool = False):\n+    \"\"\"\n+    Only one of query or table should be specified.\n+\n+    :param query: SQL query to fetch data.\n+    :param use_standard_sql:\n+      Specifies whether to use BigQuery's standard SQL dialect for this query.\n+      The default value is :data:`True`. If set to :data:`False`,\n+      the query will use BigQuery's legacy SQL dialect.\n+      This parameter is ignored for table inputs.\n+    :param table:\n+      The ID of the table to read. The ID must contain only letters\n+      ``a-z``, ``A-Z``, numbers ``0-9``, or underscores ``_``. Table should\n+      define project and dataset (ex.: ``'PROJECT:DATASET.TABLE'``).\n+    :param flatten_results:\n+      Flattens all nested and repeated fields in the query results.\n+      The default value is :data:`True`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4NzE1Ng=="}, "originalCommit": {"oid": "da42abab1ea6f987ba5e121b4c249455f968ee7f"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MTA4NzE5OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMzo1ODozMVrOHwGWIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMDoyMjoxNVrOHyMxDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE5NzY2NQ==", "bodyText": "Can this be moved up to the other if element.query condition? That may allow putting the yield into the for loop above, getting rid of the intermediate split_result and avoiding the additional iteration.", "url": "https://github.com/apache/beam/pull/13170#discussion_r520197665", "createdAt": "2020-11-09T23:58:31Z", "author": {"login": "tysonjh"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "diffHunk": "@@ -100,3 +121,290 @@ def process(self, unused_element, unused_signal, gcs_locations):\n     )\n \n     return main_output\n+\n+\n+class ReadFromBigQueryRequest:\n+  \"\"\"\n+  Class that defines data to read from BQ.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      query: str = None,\n+      use_standard_sql: bool = True,\n+      table: Union[str, TableReference] = None,\n+      flatten_results: bool = False):\n+    \"\"\"\n+    Only one of query or table should be specified.\n+\n+    :param query: SQL query to fetch data.\n+    :param use_standard_sql:\n+      Specifies whether to use BigQuery's standard SQL dialect for this query.\n+      The default value is :data:`True`. If set to :data:`False`,\n+      the query will use BigQuery's legacy SQL dialect.\n+      This parameter is ignored for table inputs.\n+    :param table:\n+      The ID of the table to read. The ID must contain only letters\n+      ``a-z``, ``A-Z``, numbers ``0-9``, or underscores ``_``. Table should\n+      define project and dataset (ex.: ``'PROJECT:DATASET.TABLE'``).\n+    :param flatten_results:\n+      Flattens all nested and repeated fields in the query results.\n+      The default value is :data:`True`.\n+    \"\"\"\n+    self.flatten_results = flatten_results\n+    self.query = query\n+    self.use_standard_sql = use_standard_sql\n+    self.table = table\n+    self.validate()\n+\n+    # We use this internal object ID to generate BigQuery export directories.\n+    self.obj_id = random.randint(0, 100000)\n+\n+  def validate(self):\n+    if self.table is not None and self.query is not None:\n+      raise ValueError(\n+          'Both a BigQuery table and a query were specified.'\n+          ' Please specify only one of these.')\n+    elif self.table is None and self.query is None:\n+      raise ValueError('A BigQuery table or a query must be specified')\n+    if self.table is not None:\n+      if isinstance(self.table, str):\n+        assert self.table.find('.'), (\n+            'Expected a table reference '\n+            '(PROJECT:DATASET.TABLE or DATASET.TABLE) instead of %s'\n+            % self.table)\n+\n+\n+class _BigQueryReadSplit(beam.transforms.DoFn):\n+  def __init__(\n+      self,\n+      options: PipelineOptions,\n+      gcs_location: Union[str, ValueProvider] = None,\n+      use_json_exports: bool = False,\n+      bigquery_job_labels: Dict[str, str] = None,\n+      step_name: str = None,\n+      job_name: str = None,\n+      unique_id: str = None,\n+      kms_key: str = None,\n+      project: str = None):\n+    self.options = options\n+    self.use_json_exports = use_json_exports\n+    self.gcs_location = gcs_location\n+    self.bigquery_job_labels = bigquery_job_labels or {}\n+    self._step_name = step_name\n+    self._job_name = job_name or 'BQ_READ_SPLIT'\n+    self._source_uuid = unique_id\n+    self.kms_key = kms_key\n+    self.project = project\n+    self.bq_io_metadata = None\n+\n+  def process(self, element: ReadFromBigQueryRequest, *args,\n+              **kwargs) -> Iterable[BoundedSource]:\n+    bq = bigquery_tools.BigQueryWrapper()\n+\n+    if element.query is not None:\n+      self._setup_temporary_dataset(bq, element)\n+      table_reference = self._execute_query(bq, element)\n+    else:\n+      assert element.table\n+      table_reference = bigquery_tools.parse_table_reference(\n+          element.table, project=self._get_project())\n+\n+    if not table_reference.projectId:\n+      table_reference.projectId = self._get_project()\n+\n+    schema, metadata_list = self._export_files(bq, element, table_reference)\n+    split_result = [\n+        self._create_source(metadata.path, schema) for metadata in metadata_list\n+    ]\n+\n+    if element.query is not None:\n+      bq.clean_up_temporary_dataset(self._get_project())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da42abab1ea6f987ba5e121b4c249455f968ee7f"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQwMDAxNQ==", "bodyText": "that's not possible in this case. We issue a table export in export_files, and only after that's finished is that we can delete the dataset. But I've moved the yield above.", "url": "https://github.com/apache/beam/pull/13170#discussion_r522400015", "createdAt": "2020-11-12T20:22:15Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "diffHunk": "@@ -100,3 +121,290 @@ def process(self, unused_element, unused_signal, gcs_locations):\n     )\n \n     return main_output\n+\n+\n+class ReadFromBigQueryRequest:\n+  \"\"\"\n+  Class that defines data to read from BQ.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      query: str = None,\n+      use_standard_sql: bool = True,\n+      table: Union[str, TableReference] = None,\n+      flatten_results: bool = False):\n+    \"\"\"\n+    Only one of query or table should be specified.\n+\n+    :param query: SQL query to fetch data.\n+    :param use_standard_sql:\n+      Specifies whether to use BigQuery's standard SQL dialect for this query.\n+      The default value is :data:`True`. If set to :data:`False`,\n+      the query will use BigQuery's legacy SQL dialect.\n+      This parameter is ignored for table inputs.\n+    :param table:\n+      The ID of the table to read. The ID must contain only letters\n+      ``a-z``, ``A-Z``, numbers ``0-9``, or underscores ``_``. Table should\n+      define project and dataset (ex.: ``'PROJECT:DATASET.TABLE'``).\n+    :param flatten_results:\n+      Flattens all nested and repeated fields in the query results.\n+      The default value is :data:`True`.\n+    \"\"\"\n+    self.flatten_results = flatten_results\n+    self.query = query\n+    self.use_standard_sql = use_standard_sql\n+    self.table = table\n+    self.validate()\n+\n+    # We use this internal object ID to generate BigQuery export directories.\n+    self.obj_id = random.randint(0, 100000)\n+\n+  def validate(self):\n+    if self.table is not None and self.query is not None:\n+      raise ValueError(\n+          'Both a BigQuery table and a query were specified.'\n+          ' Please specify only one of these.')\n+    elif self.table is None and self.query is None:\n+      raise ValueError('A BigQuery table or a query must be specified')\n+    if self.table is not None:\n+      if isinstance(self.table, str):\n+        assert self.table.find('.'), (\n+            'Expected a table reference '\n+            '(PROJECT:DATASET.TABLE or DATASET.TABLE) instead of %s'\n+            % self.table)\n+\n+\n+class _BigQueryReadSplit(beam.transforms.DoFn):\n+  def __init__(\n+      self,\n+      options: PipelineOptions,\n+      gcs_location: Union[str, ValueProvider] = None,\n+      use_json_exports: bool = False,\n+      bigquery_job_labels: Dict[str, str] = None,\n+      step_name: str = None,\n+      job_name: str = None,\n+      unique_id: str = None,\n+      kms_key: str = None,\n+      project: str = None):\n+    self.options = options\n+    self.use_json_exports = use_json_exports\n+    self.gcs_location = gcs_location\n+    self.bigquery_job_labels = bigquery_job_labels or {}\n+    self._step_name = step_name\n+    self._job_name = job_name or 'BQ_READ_SPLIT'\n+    self._source_uuid = unique_id\n+    self.kms_key = kms_key\n+    self.project = project\n+    self.bq_io_metadata = None\n+\n+  def process(self, element: ReadFromBigQueryRequest, *args,\n+              **kwargs) -> Iterable[BoundedSource]:\n+    bq = bigquery_tools.BigQueryWrapper()\n+\n+    if element.query is not None:\n+      self._setup_temporary_dataset(bq, element)\n+      table_reference = self._execute_query(bq, element)\n+    else:\n+      assert element.table\n+      table_reference = bigquery_tools.parse_table_reference(\n+          element.table, project=self._get_project())\n+\n+    if not table_reference.projectId:\n+      table_reference.projectId = self._get_project()\n+\n+    schema, metadata_list = self._export_files(bq, element, table_reference)\n+    split_result = [\n+        self._create_source(metadata.path, schema) for metadata in metadata_list\n+    ]\n+\n+    if element.query is not None:\n+      bq.clean_up_temporary_dataset(self._get_project())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE5NzY2NQ=="}, "originalCommit": {"oid": "da42abab1ea6f987ba5e121b4c249455f968ee7f"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTk4Njc5OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxOTo0OToxOVrOHxb5gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMDoyMzo0MVrOHyM2IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU5OTM2Mg==", "bodyText": "May be worth noting that there is also a UUID involved. I was worried about collisions until I read on a bit further.", "url": "https://github.com/apache/beam/pull/13170#discussion_r521599362", "createdAt": "2020-11-11T19:49:19Z", "author": {"login": "tysonjh"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "diffHunk": "@@ -100,3 +121,290 @@ def process(self, unused_element, unused_signal, gcs_locations):\n     )\n \n     return main_output\n+\n+\n+class ReadFromBigQueryRequest:\n+  \"\"\"\n+  Class that defines data to read from BQ.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      query: str = None,\n+      use_standard_sql: bool = True,\n+      table: Union[str, TableReference] = None,\n+      flatten_results: bool = False):\n+    \"\"\"\n+    Only one of query or table should be specified.\n+\n+    :param query: SQL query to fetch data.\n+    :param use_standard_sql:\n+      Specifies whether to use BigQuery's standard SQL dialect for this query.\n+      The default value is :data:`True`. If set to :data:`False`,\n+      the query will use BigQuery's legacy SQL dialect.\n+      This parameter is ignored for table inputs.\n+    :param table:\n+      The ID of the table to read. The ID must contain only letters\n+      ``a-z``, ``A-Z``, numbers ``0-9``, or underscores ``_``. Table should\n+      define project and dataset (ex.: ``'PROJECT:DATASET.TABLE'``).\n+    :param flatten_results:\n+      Flattens all nested and repeated fields in the query results.\n+      The default value is :data:`True`.\n+    \"\"\"\n+    self.flatten_results = flatten_results\n+    self.query = query\n+    self.use_standard_sql = use_standard_sql\n+    self.table = table\n+    self.validate()\n+\n+    # We use this internal object ID to generate BigQuery export directories.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da42abab1ea6f987ba5e121b4c249455f968ee7f"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQwMTMxMg==", "bodyText": "I've added this to the Pydoc of the transform.", "url": "https://github.com/apache/beam/pull/13170#discussion_r522401312", "createdAt": "2020-11-12T20:23:41Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "diffHunk": "@@ -100,3 +121,290 @@ def process(self, unused_element, unused_signal, gcs_locations):\n     )\n \n     return main_output\n+\n+\n+class ReadFromBigQueryRequest:\n+  \"\"\"\n+  Class that defines data to read from BQ.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      query: str = None,\n+      use_standard_sql: bool = True,\n+      table: Union[str, TableReference] = None,\n+      flatten_results: bool = False):\n+    \"\"\"\n+    Only one of query or table should be specified.\n+\n+    :param query: SQL query to fetch data.\n+    :param use_standard_sql:\n+      Specifies whether to use BigQuery's standard SQL dialect for this query.\n+      The default value is :data:`True`. If set to :data:`False`,\n+      the query will use BigQuery's legacy SQL dialect.\n+      This parameter is ignored for table inputs.\n+    :param table:\n+      The ID of the table to read. The ID must contain only letters\n+      ``a-z``, ``A-Z``, numbers ``0-9``, or underscores ``_``. Table should\n+      define project and dataset (ex.: ``'PROJECT:DATASET.TABLE'``).\n+    :param flatten_results:\n+      Flattens all nested and repeated fields in the query results.\n+      The default value is :data:`True`.\n+    \"\"\"\n+    self.flatten_results = flatten_results\n+    self.query = query\n+    self.use_standard_sql = use_standard_sql\n+    self.table = table\n+    self.validate()\n+\n+    # We use this internal object ID to generate BigQuery export directories.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU5OTM2Mg=="}, "originalCommit": {"oid": "da42abab1ea6f987ba5e121b4c249455f968ee7f"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4MDcyMzMxOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNFQwMDowMDozN1rOHzDSrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNjoyODozMVrOH3W2fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5MzM1OQ==", "bodyText": "I still find it strange that this is a user API but is inside bigquery_read_internal.py. Is this normal for python? I would expect that users should not be using classes in internal files.", "url": "https://github.com/apache/beam/pull/13170#discussion_r523293359", "createdAt": "2020-11-14T00:00:37Z", "author": {"login": "tysonjh"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "diffHunk": "@@ -100,3 +123,309 @@ def process(self, unused_element, unused_signal, gcs_locations):\n     )\n \n     return main_output\n+\n+\n+class ReadFromBigQueryRequest:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a20b7d6994efba7c63c976a312f30cb9adebef04"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgwODEyNA==", "bodyText": "You're right. I've moved it to a public-facing file.", "url": "https://github.com/apache/beam/pull/13170#discussion_r527808124", "createdAt": "2020-11-20T16:28:31Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "diffHunk": "@@ -100,3 +123,309 @@ def process(self, unused_element, unused_signal, gcs_locations):\n     )\n \n     return main_output\n+\n+\n+class ReadFromBigQueryRequest:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5MzM1OQ=="}, "originalCommit": {"oid": "a20b7d6994efba7c63c976a312f30cb9adebef04"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTA0MjM2OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/io/gcp/bigquery_read_it_test.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMzo0MDowMFrOH2GtnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNjo0NDoxOVrOH3XeBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5NTEzMw==", "bodyText": "Does this need to be here? Or can it be in the groovy config for running these tests instead?", "url": "https://github.com/apache/beam/pull/13170#discussion_r526495133", "createdAt": "2020-11-18T23:40:00Z", "author": {"login": "tysonjh"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_it_test.py", "diffHunk": "@@ -298,6 +298,108 @@ def test_iobase_source(self):\n       assert_that(result, equal_to(self.get_expected_data(native=False)))\n \n \n+class ReadAllBQTests(BigQueryReadIntegrationTests):\n+  TABLE_DATA_1 = [{\n+      'number': 1, 'str': 'abc'\n+  }, {\n+      'number': 2, 'str': 'def'\n+  }, {\n+      'number': 3, 'str': u'\u4f60\u597d'\n+  }, {\n+      'number': 4, 'str': u'\u043f\u0440\u0438\u0432\u0435\u0442'\n+  }]\n+\n+  TABLE_DATA_2 = [{\n+      'number': 10, 'str': 'abcd'\n+  }, {\n+      'number': 20, 'str': 'defg'\n+  }, {\n+      'number': 30, 'str': u'\u4f60\u597d'\n+  }, {\n+      'number': 40, 'str': u'\u043f\u0440\u0438\u0432\u0435\u0442'\n+  }]\n+\n+  TABLE_DATA_3 = [{'number': 10, 'str': 'abcde', 'extra': 3}]\n+\n+  @classmethod\n+  def setUpClass(cls):\n+    super(ReadAllBQTests, cls).setUpClass()\n+    cls.SCHEMA_BQ = cls.create_bq_schema()\n+    cls.SCHEMA_BQ_WITH_EXTRA = cls.create_bq_schema(True)\n+\n+    cls.table_name1 = 'python_rd_table_1'\n+    cls.table_schema1 = cls.create_table(\n+        cls.table_name1, cls.TABLE_DATA_1, cls.SCHEMA_BQ)\n+    table_id1 = '{}.{}'.format(cls.dataset_id, cls.table_name1)\n+    cls.query1 = 'SELECT number, str FROM `%s`' % table_id1\n+\n+    cls.table_name2 = 'python_rd_table_2'\n+    cls.table_schema2 = cls.create_table(\n+        cls.table_name2, cls.TABLE_DATA_2, cls.SCHEMA_BQ)\n+    table_id2 = '{}.{}'.format(cls.dataset_id, cls.table_name2)\n+    cls.query2 = 'SELECT number, str FROM %s' % table_id2\n+\n+    cls.table_name3 = 'python_rd_table_3'\n+    cls.table_schema3 = cls.create_table(\n+        cls.table_name3, cls.TABLE_DATA_3, cls.SCHEMA_BQ_WITH_EXTRA)\n+    table_id3 = '{}.{}'.format(cls.dataset_id, cls.table_name3)\n+    cls.query3 = 'SELECT number, str, extra FROM `%s`' % table_id3\n+\n+  @classmethod\n+  def create_table(cls, table_name, data, table_schema):\n+    table = bigquery.Table(\n+        tableReference=bigquery.TableReference(\n+            projectId=cls.project, datasetId=cls.dataset_id,\n+            tableId=table_name),\n+        schema=table_schema)\n+    request = bigquery.BigqueryTablesInsertRequest(\n+        projectId=cls.project, datasetId=cls.dataset_id, table=table)\n+    cls.bigquery_client.client.tables.Insert(request)\n+    cls.bigquery_client.insert_rows(\n+        cls.project, cls.dataset_id, table_name, data)\n+    return table_schema\n+\n+  @classmethod\n+  def create_bq_schema(cls, with_extra=False):\n+    table_schema = bigquery.TableSchema()\n+    table_field = bigquery.TableFieldSchema()\n+    table_field.name = 'number'\n+    table_field.type = 'INTEGER'\n+    table_field.mode = 'NULLABLE'\n+    table_schema.fields.append(table_field)\n+    table_field = bigquery.TableFieldSchema()\n+    table_field.name = 'str'\n+    table_field.type = 'STRING'\n+    table_field.mode = 'NULLABLE'\n+    table_schema.fields.append(table_field)\n+    if with_extra:\n+      table_field = bigquery.TableFieldSchema()\n+      table_field.name = 'extra'\n+      table_field.type = 'INTEGER'\n+      table_field.mode = 'NULLABLE'\n+      table_schema.fields.append(table_field)\n+    return table_schema\n+\n+  @skip(['PortableRunner', 'FlinkRunner'])\n+  @attr('IT')\n+  def test_read_queries(self):\n+    args = self.args + [\"--experiments=use_runner_v2\"]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a20b7d6994efba7c63c976a312f30cb9adebef04"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgxMzI2MA==", "bodyText": "let me see if I can do that....", "url": "https://github.com/apache/beam/pull/13170#discussion_r527813260", "createdAt": "2020-11-20T16:36:40Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_it_test.py", "diffHunk": "@@ -298,6 +298,108 @@ def test_iobase_source(self):\n       assert_that(result, equal_to(self.get_expected_data(native=False)))\n \n \n+class ReadAllBQTests(BigQueryReadIntegrationTests):\n+  TABLE_DATA_1 = [{\n+      'number': 1, 'str': 'abc'\n+  }, {\n+      'number': 2, 'str': 'def'\n+  }, {\n+      'number': 3, 'str': u'\u4f60\u597d'\n+  }, {\n+      'number': 4, 'str': u'\u043f\u0440\u0438\u0432\u0435\u0442'\n+  }]\n+\n+  TABLE_DATA_2 = [{\n+      'number': 10, 'str': 'abcd'\n+  }, {\n+      'number': 20, 'str': 'defg'\n+  }, {\n+      'number': 30, 'str': u'\u4f60\u597d'\n+  }, {\n+      'number': 40, 'str': u'\u043f\u0440\u0438\u0432\u0435\u0442'\n+  }]\n+\n+  TABLE_DATA_3 = [{'number': 10, 'str': 'abcde', 'extra': 3}]\n+\n+  @classmethod\n+  def setUpClass(cls):\n+    super(ReadAllBQTests, cls).setUpClass()\n+    cls.SCHEMA_BQ = cls.create_bq_schema()\n+    cls.SCHEMA_BQ_WITH_EXTRA = cls.create_bq_schema(True)\n+\n+    cls.table_name1 = 'python_rd_table_1'\n+    cls.table_schema1 = cls.create_table(\n+        cls.table_name1, cls.TABLE_DATA_1, cls.SCHEMA_BQ)\n+    table_id1 = '{}.{}'.format(cls.dataset_id, cls.table_name1)\n+    cls.query1 = 'SELECT number, str FROM `%s`' % table_id1\n+\n+    cls.table_name2 = 'python_rd_table_2'\n+    cls.table_schema2 = cls.create_table(\n+        cls.table_name2, cls.TABLE_DATA_2, cls.SCHEMA_BQ)\n+    table_id2 = '{}.{}'.format(cls.dataset_id, cls.table_name2)\n+    cls.query2 = 'SELECT number, str FROM %s' % table_id2\n+\n+    cls.table_name3 = 'python_rd_table_3'\n+    cls.table_schema3 = cls.create_table(\n+        cls.table_name3, cls.TABLE_DATA_3, cls.SCHEMA_BQ_WITH_EXTRA)\n+    table_id3 = '{}.{}'.format(cls.dataset_id, cls.table_name3)\n+    cls.query3 = 'SELECT number, str, extra FROM `%s`' % table_id3\n+\n+  @classmethod\n+  def create_table(cls, table_name, data, table_schema):\n+    table = bigquery.Table(\n+        tableReference=bigquery.TableReference(\n+            projectId=cls.project, datasetId=cls.dataset_id,\n+            tableId=table_name),\n+        schema=table_schema)\n+    request = bigquery.BigqueryTablesInsertRequest(\n+        projectId=cls.project, datasetId=cls.dataset_id, table=table)\n+    cls.bigquery_client.client.tables.Insert(request)\n+    cls.bigquery_client.insert_rows(\n+        cls.project, cls.dataset_id, table_name, data)\n+    return table_schema\n+\n+  @classmethod\n+  def create_bq_schema(cls, with_extra=False):\n+    table_schema = bigquery.TableSchema()\n+    table_field = bigquery.TableFieldSchema()\n+    table_field.name = 'number'\n+    table_field.type = 'INTEGER'\n+    table_field.mode = 'NULLABLE'\n+    table_schema.fields.append(table_field)\n+    table_field = bigquery.TableFieldSchema()\n+    table_field.name = 'str'\n+    table_field.type = 'STRING'\n+    table_field.mode = 'NULLABLE'\n+    table_schema.fields.append(table_field)\n+    if with_extra:\n+      table_field = bigquery.TableFieldSchema()\n+      table_field.name = 'extra'\n+      table_field.type = 'INTEGER'\n+      table_field.mode = 'NULLABLE'\n+      table_schema.fields.append(table_field)\n+    return table_schema\n+\n+  @skip(['PortableRunner', 'FlinkRunner'])\n+  @attr('IT')\n+  def test_read_queries(self):\n+    args = self.args + [\"--experiments=use_runner_v2\"]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5NTEzMw=="}, "originalCommit": {"oid": "a20b7d6994efba7c63c976a312f30cb9adebef04"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgxODI0Nw==", "bodyText": "I think we dont have external runner_v2 tests, and this feature works only on runner_v2, so to avoid deactivating it on Dataflow, I'm adding the flag. I can add a TODO to fix when we move to runner_v2 for DF tests.", "url": "https://github.com/apache/beam/pull/13170#discussion_r527818247", "createdAt": "2020-11-20T16:44:19Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_it_test.py", "diffHunk": "@@ -298,6 +298,108 @@ def test_iobase_source(self):\n       assert_that(result, equal_to(self.get_expected_data(native=False)))\n \n \n+class ReadAllBQTests(BigQueryReadIntegrationTests):\n+  TABLE_DATA_1 = [{\n+      'number': 1, 'str': 'abc'\n+  }, {\n+      'number': 2, 'str': 'def'\n+  }, {\n+      'number': 3, 'str': u'\u4f60\u597d'\n+  }, {\n+      'number': 4, 'str': u'\u043f\u0440\u0438\u0432\u0435\u0442'\n+  }]\n+\n+  TABLE_DATA_2 = [{\n+      'number': 10, 'str': 'abcd'\n+  }, {\n+      'number': 20, 'str': 'defg'\n+  }, {\n+      'number': 30, 'str': u'\u4f60\u597d'\n+  }, {\n+      'number': 40, 'str': u'\u043f\u0440\u0438\u0432\u0435\u0442'\n+  }]\n+\n+  TABLE_DATA_3 = [{'number': 10, 'str': 'abcde', 'extra': 3}]\n+\n+  @classmethod\n+  def setUpClass(cls):\n+    super(ReadAllBQTests, cls).setUpClass()\n+    cls.SCHEMA_BQ = cls.create_bq_schema()\n+    cls.SCHEMA_BQ_WITH_EXTRA = cls.create_bq_schema(True)\n+\n+    cls.table_name1 = 'python_rd_table_1'\n+    cls.table_schema1 = cls.create_table(\n+        cls.table_name1, cls.TABLE_DATA_1, cls.SCHEMA_BQ)\n+    table_id1 = '{}.{}'.format(cls.dataset_id, cls.table_name1)\n+    cls.query1 = 'SELECT number, str FROM `%s`' % table_id1\n+\n+    cls.table_name2 = 'python_rd_table_2'\n+    cls.table_schema2 = cls.create_table(\n+        cls.table_name2, cls.TABLE_DATA_2, cls.SCHEMA_BQ)\n+    table_id2 = '{}.{}'.format(cls.dataset_id, cls.table_name2)\n+    cls.query2 = 'SELECT number, str FROM %s' % table_id2\n+\n+    cls.table_name3 = 'python_rd_table_3'\n+    cls.table_schema3 = cls.create_table(\n+        cls.table_name3, cls.TABLE_DATA_3, cls.SCHEMA_BQ_WITH_EXTRA)\n+    table_id3 = '{}.{}'.format(cls.dataset_id, cls.table_name3)\n+    cls.query3 = 'SELECT number, str, extra FROM `%s`' % table_id3\n+\n+  @classmethod\n+  def create_table(cls, table_name, data, table_schema):\n+    table = bigquery.Table(\n+        tableReference=bigquery.TableReference(\n+            projectId=cls.project, datasetId=cls.dataset_id,\n+            tableId=table_name),\n+        schema=table_schema)\n+    request = bigquery.BigqueryTablesInsertRequest(\n+        projectId=cls.project, datasetId=cls.dataset_id, table=table)\n+    cls.bigquery_client.client.tables.Insert(request)\n+    cls.bigquery_client.insert_rows(\n+        cls.project, cls.dataset_id, table_name, data)\n+    return table_schema\n+\n+  @classmethod\n+  def create_bq_schema(cls, with_extra=False):\n+    table_schema = bigquery.TableSchema()\n+    table_field = bigquery.TableFieldSchema()\n+    table_field.name = 'number'\n+    table_field.type = 'INTEGER'\n+    table_field.mode = 'NULLABLE'\n+    table_schema.fields.append(table_field)\n+    table_field = bigquery.TableFieldSchema()\n+    table_field.name = 'str'\n+    table_field.type = 'STRING'\n+    table_field.mode = 'NULLABLE'\n+    table_schema.fields.append(table_field)\n+    if with_extra:\n+      table_field = bigquery.TableFieldSchema()\n+      table_field.name = 'extra'\n+      table_field.type = 'INTEGER'\n+      table_field.mode = 'NULLABLE'\n+      table_schema.fields.append(table_field)\n+    return table_schema\n+\n+  @skip(['PortableRunner', 'FlinkRunner'])\n+  @attr('IT')\n+  def test_read_queries(self):\n+    args = self.args + [\"--experiments=use_runner_v2\"]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5NTEzMw=="}, "originalCommit": {"oid": "a20b7d6994efba7c63c976a312f30cb9adebef04"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTA2OTE0OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/io/gcp/bigquery.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMzo1MDo1OFrOH2G90g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMzo1NDo0NlrOH3kYuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5OTI4Mg==", "bodyText": "Why ? Also is this supported for Dataflow Runnner v2 ?", "url": "https://github.com/apache/beam/pull/13170#discussion_r526499282", "createdAt": "2020-11-18T23:50:58Z", "author": {"login": "chamikaramj"}, "path": "sdks/python/apache_beam/io/gcp/bigquery.py", "diffHunk": "@@ -79,6 +79,41 @@\n `ReadFromBigQuery`, you can use the flag `use_json_exports` to export\n data as JSON, and receive base64-encoded bytes.\n \n+ReadAllFromBigQuery\n+-------------------\n+Beam 2.27.0 introduces a new transform called `ReadAllFromBigQuery` which\n+allows you to define table and query reads from BigQuery at pipeline\n+runtime.:::\n+\n+  read_requests = p | beam.Create([\n+      ReadFromBigQueryRequest(query='SELECT * FROM mydataset.mytable'),\n+      ReadFromBigQueryRequest(table='myproject.mydataset.mytable')])\n+  results = read_requests | ReadAllFromBigQuery()\n+\n+A good application for this transform is in streaming pipelines to\n+refresh a side input coming from BigQuery. This would work like so:::\n+\n+  side_input = (\n+      p\n+      | 'PeriodicImpulse' >> PeriodicImpulse(\n+          first_timestamp, last_timestamp, interval, True)\n+      | 'MapToReadRequest' >> beam.Map(\n+          lambda x: ReadFromBigQueryRequest(table='dataset.table'))\n+      | beam.io.ReadAllFromBigQuery())\n+  main_input = (\n+      p\n+      | 'MpImpulse' >> beam.Create(sample_main_input_elements)\n+      |\n+      'MapMpToTimestamped' >> beam.Map(lambda src: TimestampedValue(src, src))\n+      | 'WindowMpInto' >> beam.WindowInto(\n+          window.FixedWindows(main_input_windowing_interval)))\n+  result = (\n+      main_input\n+      | 'ApplyCrossJoin' >> beam.FlatMap(\n+          cross_join, rights=beam.pvalue.AsIter(side_input)))\n+\n+**Note**: This transform is supported on Portable runners only.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a20b7d6994efba7c63c976a312f30cb9adebef04"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyOTg4MA==", "bodyText": "yes, runner v2 supports this as well", "url": "https://github.com/apache/beam/pull/13170#discussion_r528029880", "createdAt": "2020-11-20T23:54:46Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/io/gcp/bigquery.py", "diffHunk": "@@ -79,6 +79,41 @@\n `ReadFromBigQuery`, you can use the flag `use_json_exports` to export\n data as JSON, and receive base64-encoded bytes.\n \n+ReadAllFromBigQuery\n+-------------------\n+Beam 2.27.0 introduces a new transform called `ReadAllFromBigQuery` which\n+allows you to define table and query reads from BigQuery at pipeline\n+runtime.:::\n+\n+  read_requests = p | beam.Create([\n+      ReadFromBigQueryRequest(query='SELECT * FROM mydataset.mytable'),\n+      ReadFromBigQueryRequest(table='myproject.mydataset.mytable')])\n+  results = read_requests | ReadAllFromBigQuery()\n+\n+A good application for this transform is in streaming pipelines to\n+refresh a side input coming from BigQuery. This would work like so:::\n+\n+  side_input = (\n+      p\n+      | 'PeriodicImpulse' >> PeriodicImpulse(\n+          first_timestamp, last_timestamp, interval, True)\n+      | 'MapToReadRequest' >> beam.Map(\n+          lambda x: ReadFromBigQueryRequest(table='dataset.table'))\n+      | beam.io.ReadAllFromBigQuery())\n+  main_input = (\n+      p\n+      | 'MpImpulse' >> beam.Create(sample_main_input_elements)\n+      |\n+      'MapMpToTimestamped' >> beam.Map(lambda src: TimestampedValue(src, src))\n+      | 'WindowMpInto' >> beam.WindowInto(\n+          window.FixedWindows(main_input_windowing_interval)))\n+  result = (\n+      main_input\n+      | 'ApplyCrossJoin' >> beam.FlatMap(\n+          cross_join, rights=beam.pvalue.AsIter(side_input)))\n+\n+**Note**: This transform is supported on Portable runners only.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5OTI4Mg=="}, "originalCommit": {"oid": "a20b7d6994efba7c63c976a312f30cb9adebef04"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDIyNzMzOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/io/gcp/bigquery.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxOTo0MDoxOVrOH3eXzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMzo1NToyNVrOH3kZYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkzMTM0MA==", "bodyText": "What about other args here ? https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/gcp/bigquery.py#L1823\n(probably this can be a followup PR)", "url": "https://github.com/apache/beam/pull/13170#discussion_r527931340", "createdAt": "2020-11-20T19:40:19Z", "author": {"login": "chamikaramj"}, "path": "sdks/python/apache_beam/io/gcp/bigquery.py", "diffHunk": "@@ -1931,3 +1903,132 @@ def file_path_to_remove(unused_elm):\n                 *self._args,\n                 **self._kwargs))\n         | _PassThroughThenCleanup(files_to_remove_pcoll))\n+\n+\n+class ReadFromBigQueryRequest:\n+  \"\"\"\n+  Class that defines data to read from BQ.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      query: str = None,\n+      use_standard_sql: bool = True,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5b718b9acfefffb660efe8a8b11cc8e775ad5f9"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAzMDA0OQ==", "bodyText": "args are split between the read request and the transform. I would say all args exist in either.", "url": "https://github.com/apache/beam/pull/13170#discussion_r528030049", "createdAt": "2020-11-20T23:55:25Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/io/gcp/bigquery.py", "diffHunk": "@@ -1931,3 +1903,132 @@ def file_path_to_remove(unused_elm):\n                 *self._args,\n                 **self._kwargs))\n         | _PassThroughThenCleanup(files_to_remove_pcoll))\n+\n+\n+class ReadFromBigQueryRequest:\n+  \"\"\"\n+  Class that defines data to read from BQ.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      query: str = None,\n+      use_standard_sql: bool = True,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkzMTM0MA=="}, "originalCommit": {"oid": "d5b718b9acfefffb660efe8a8b11cc8e775ad5f9"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDI3ODQ1OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxOTo1NzoyM1rOH3e3OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxOTo1NzoyM1rOH3e3OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkzOTM4NQ==", "bodyText": "Add some pydocs here to clarify what this does ?", "url": "https://github.com/apache/beam/pull/13170#discussion_r527939385", "createdAt": "2020-11-20T19:57:23Z", "author": {"login": "chamikaramj"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "diffHunk": "@@ -100,3 +127,258 @@ def process(self, unused_element, unused_signal, gcs_locations):\n     )\n \n     return main_output\n+\n+\n+class _BigQueryReadSplit(beam.transforms.DoFn):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5b718b9acfefffb660efe8a8b11cc8e775ad5f9"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDI4MjgyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxOTo1ODo1OFrOH3e58w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMDoyNjoyMlrOH3k1Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0MDA4Mw==", "bodyText": "Will we run into BQ quotas if we try to create a large number of datasets ?", "url": "https://github.com/apache/beam/pull/13170#discussion_r527940083", "createdAt": "2020-11-20T19:58:58Z", "author": {"login": "chamikaramj"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "diffHunk": "@@ -100,3 +127,258 @@ def process(self, unused_element, unused_signal, gcs_locations):\n     )\n \n     return main_output\n+\n+\n+class _BigQueryReadSplit(beam.transforms.DoFn):\n+  def __init__(\n+      self,\n+      options: PipelineOptions,\n+      gcs_location: Union[str, ValueProvider] = None,\n+      use_json_exports: bool = False,\n+      bigquery_job_labels: Dict[str, str] = None,\n+      step_name: str = None,\n+      job_name: str = None,\n+      unique_id: str = None,\n+      kms_key: str = None,\n+      project: str = None,\n+      temp_dataset: Union[str, DatasetReference] = None):\n+    self.options = options\n+    self.use_json_exports = use_json_exports\n+    self.gcs_location = gcs_location\n+    self.bigquery_job_labels = bigquery_job_labels or {}\n+    self._step_name = step_name\n+    self._job_name = job_name or 'BQ_READ_SPLIT'\n+    self._source_uuid = unique_id\n+    self.kms_key = kms_key\n+    self.project = project\n+    self.temp_dataset = temp_dataset\n+    self.bq_io_metadata = None\n+\n+  def display_data(self):\n+    return {\n+        'use_json_exports': str(self.use_json_exports),\n+        'gcs_location': str(self.gcs_location),\n+        'bigquery_job_labels': json.dumps(self.bigquery_job_labels),\n+        'kms_key': str(self.kms_key),\n+        'project': str(self.project),\n+        'temp_dataset': str(self.temp_dataset)\n+    }\n+\n+  def _get_temp_dataset(self):\n+    if isinstance(self.temp_dataset, str):\n+      return DatasetReference(\n+          datasetId=self.temp_dataset, projectId=self._get_project())\n+    else:\n+      return self.temp_dataset\n+\n+  def process(self, element: 'ReadFromBigQueryRequest', *args,\n+              **kwargs) -> Iterable[BoundedSource]:\n+    bq = bigquery_tools.BigQueryWrapper(\n+        temp_dataset_id=(\n+            self._get_temp_dataset().datasetId if self._get_temp_dataset(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5b718b9acfefffb660efe8a8b11cc8e775ad5f9"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAzNzEyNw==", "bodyText": "hm this is a great catch Cham. I've changed this so we always use the same Dataset, and we just delete the temporary table. WDYT?", "url": "https://github.com/apache/beam/pull/13170#discussion_r528037127", "createdAt": "2020-11-21T00:26:22Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "diffHunk": "@@ -100,3 +127,258 @@ def process(self, unused_element, unused_signal, gcs_locations):\n     )\n \n     return main_output\n+\n+\n+class _BigQueryReadSplit(beam.transforms.DoFn):\n+  def __init__(\n+      self,\n+      options: PipelineOptions,\n+      gcs_location: Union[str, ValueProvider] = None,\n+      use_json_exports: bool = False,\n+      bigquery_job_labels: Dict[str, str] = None,\n+      step_name: str = None,\n+      job_name: str = None,\n+      unique_id: str = None,\n+      kms_key: str = None,\n+      project: str = None,\n+      temp_dataset: Union[str, DatasetReference] = None):\n+    self.options = options\n+    self.use_json_exports = use_json_exports\n+    self.gcs_location = gcs_location\n+    self.bigquery_job_labels = bigquery_job_labels or {}\n+    self._step_name = step_name\n+    self._job_name = job_name or 'BQ_READ_SPLIT'\n+    self._source_uuid = unique_id\n+    self.kms_key = kms_key\n+    self.project = project\n+    self.temp_dataset = temp_dataset\n+    self.bq_io_metadata = None\n+\n+  def display_data(self):\n+    return {\n+        'use_json_exports': str(self.use_json_exports),\n+        'gcs_location': str(self.gcs_location),\n+        'bigquery_job_labels': json.dumps(self.bigquery_job_labels),\n+        'kms_key': str(self.kms_key),\n+        'project': str(self.project),\n+        'temp_dataset': str(self.temp_dataset)\n+    }\n+\n+  def _get_temp_dataset(self):\n+    if isinstance(self.temp_dataset, str):\n+      return DatasetReference(\n+          datasetId=self.temp_dataset, projectId=self._get_project())\n+    else:\n+      return self.temp_dataset\n+\n+  def process(self, element: 'ReadFromBigQueryRequest', *args,\n+              **kwargs) -> Iterable[BoundedSource]:\n+    bq = bigquery_tools.BigQueryWrapper(\n+        temp_dataset_id=(\n+            self._get_temp_dataset().datasetId if self._get_temp_dataset(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0MDA4Mw=="}, "originalCommit": {"oid": "d5b718b9acfefffb660efe8a8b11cc8e775ad5f9"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDI4ODAxOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMDowMDozNVrOH3e9AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMDo0MDo0M1rOH3k_4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0MDg2NA==", "bodyText": "Is there a reason why we couldn't use existing coders ?", "url": "https://github.com/apache/beam/pull/13170#discussion_r527940864", "createdAt": "2020-11-20T20:00:35Z", "author": {"login": "chamikaramj"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "diffHunk": "@@ -100,3 +127,258 @@ def process(self, unused_element, unused_signal, gcs_locations):\n     )\n \n     return main_output\n+\n+\n+class _BigQueryReadSplit(beam.transforms.DoFn):\n+  def __init__(\n+      self,\n+      options: PipelineOptions,\n+      gcs_location: Union[str, ValueProvider] = None,\n+      use_json_exports: bool = False,\n+      bigquery_job_labels: Dict[str, str] = None,\n+      step_name: str = None,\n+      job_name: str = None,\n+      unique_id: str = None,\n+      kms_key: str = None,\n+      project: str = None,\n+      temp_dataset: Union[str, DatasetReference] = None):\n+    self.options = options\n+    self.use_json_exports = use_json_exports\n+    self.gcs_location = gcs_location\n+    self.bigquery_job_labels = bigquery_job_labels or {}\n+    self._step_name = step_name\n+    self._job_name = job_name or 'BQ_READ_SPLIT'\n+    self._source_uuid = unique_id\n+    self.kms_key = kms_key\n+    self.project = project\n+    self.temp_dataset = temp_dataset\n+    self.bq_io_metadata = None\n+\n+  def display_data(self):\n+    return {\n+        'use_json_exports': str(self.use_json_exports),\n+        'gcs_location': str(self.gcs_location),\n+        'bigquery_job_labels': json.dumps(self.bigquery_job_labels),\n+        'kms_key': str(self.kms_key),\n+        'project': str(self.project),\n+        'temp_dataset': str(self.temp_dataset)\n+    }\n+\n+  def _get_temp_dataset(self):\n+    if isinstance(self.temp_dataset, str):\n+      return DatasetReference(\n+          datasetId=self.temp_dataset, projectId=self._get_project())\n+    else:\n+      return self.temp_dataset\n+\n+  def process(self, element: 'ReadFromBigQueryRequest', *args,\n+              **kwargs) -> Iterable[BoundedSource]:\n+    bq = bigquery_tools.BigQueryWrapper(\n+        temp_dataset_id=(\n+            self._get_temp_dataset().datasetId if self._get_temp_dataset(\n+            ) else None))\n+\n+    if element.query is not None:\n+      self._setup_temporary_dataset(bq, element)\n+      table_reference = self._execute_query(bq, element)\n+    else:\n+      assert element.table\n+      table_reference = bigquery_tools.parse_table_reference(\n+          element.table, project=self._get_project())\n+\n+    if not table_reference.projectId:\n+      table_reference.projectId = self._get_project()\n+\n+    schema, metadata_list = self._export_files(bq, element, table_reference)\n+\n+    for metadata in metadata_list:\n+      yield self._create_source(metadata.path, schema)\n+\n+    if element.query is not None:\n+      bq.clean_up_temporary_dataset(self._get_project())\n+\n+  def _get_bq_metadata(self):\n+    if not self.bq_io_metadata:\n+      self.bq_io_metadata = create_bigquery_io_metadata(self._step_name)\n+    return self.bq_io_metadata\n+\n+  def _create_source(self, path, schema):\n+    if not self.use_json_exports:\n+      return _create_avro_source(path, use_fastavro=True)\n+    else:\n+      return _TextSource(\n+          path,\n+          min_bundle_size=0,\n+          compression_type=CompressionTypes.UNCOMPRESSED,\n+          strip_trailing_newlines=True,\n+          coder=_JsonToDictCoder(schema))\n+\n+  def _setup_temporary_dataset(\n+      self,\n+      bq: bigquery_tools.BigQueryWrapper,\n+      element: 'ReadFromBigQueryRequest'):\n+    location = bq.get_query_location(\n+        self._get_project(), element.query, not element.use_standard_sql)\n+    bq.create_temporary_dataset(self._get_project(), location)\n+\n+  def _execute_query(\n+      self,\n+      bq: bigquery_tools.BigQueryWrapper,\n+      element: 'ReadFromBigQueryRequest'):\n+    query_job_name = bigquery_tools.generate_bq_job_name(\n+        self._job_name,\n+        self._source_uuid,\n+        bigquery_tools.BigQueryJobTypes.QUERY,\n+        random.randint(0, 1000))\n+    job = bq._start_query_job(\n+        self._get_project(),\n+        element.query,\n+        not element.use_standard_sql,\n+        element.flatten_results,\n+        job_id=query_job_name,\n+        kms_key=self.kms_key,\n+        job_labels=self._get_bq_metadata().add_additional_bq_job_labels(\n+            self.bigquery_job_labels))\n+    job_ref = job.jobReference\n+    bq.wait_for_bq_job(job_ref, max_retries=0)\n+    return bq._get_temp_table(self._get_project())\n+\n+  def _export_files(\n+      self,\n+      bq: bigquery_tools.BigQueryWrapper,\n+      element: 'ReadFromBigQueryRequest',\n+      table_reference: TableReference):\n+    \"\"\"Runs a BigQuery export job.\n+\n+    Returns:\n+      bigquery.TableSchema instance, a list of FileMetadata instances\n+    \"\"\"\n+    job_labels = self._get_bq_metadata().add_additional_bq_job_labels(\n+        self.bigquery_job_labels)\n+    export_job_name = bigquery_tools.generate_bq_job_name(\n+        self._job_name,\n+        self._source_uuid,\n+        bigquery_tools.BigQueryJobTypes.EXPORT,\n+        element.obj_id)\n+    temp_location = self.options.view_as(GoogleCloudOptions).temp_location\n+    gcs_location = bigquery_export_destination_uri(\n+        self.gcs_location,\n+        temp_location,\n+        '%s%s' % (self._source_uuid, element.obj_id))\n+    if self.use_json_exports:\n+      job_ref = bq.perform_extract_job([gcs_location],\n+                                       export_job_name,\n+                                       table_reference,\n+                                       bigquery_tools.FileFormat.JSON,\n+                                       project=self._get_project(),\n+                                       job_labels=job_labels,\n+                                       include_header=False)\n+    else:\n+      job_ref = bq.perform_extract_job([gcs_location],\n+                                       export_job_name,\n+                                       table_reference,\n+                                       bigquery_tools.FileFormat.AVRO,\n+                                       project=self._get_project(),\n+                                       include_header=False,\n+                                       job_labels=job_labels,\n+                                       use_avro_logical_types=True)\n+    bq.wait_for_bq_job(job_ref)\n+    metadata_list = FileSystems.match([gcs_location])[0].metadata_list\n+\n+    if isinstance(table_reference, ValueProvider):\n+      table_ref = bigquery_tools.parse_table_reference(\n+          element.table, project=self._get_project())\n+    else:\n+      table_ref = table_reference\n+    table = bq.get_table(\n+        table_ref.projectId, table_ref.datasetId, table_ref.tableId)\n+\n+    return table.schema, metadata_list\n+\n+  def _get_project(self):\n+    \"\"\"Returns the project that queries and exports will be billed to.\"\"\"\n+\n+    project = self.options.view_as(GoogleCloudOptions).project\n+    if isinstance(project, ValueProvider):\n+      project = project.get()\n+    if not project:\n+      project = self.project\n+    return project\n+\n+\n+FieldSchema = collections.namedtuple('FieldSchema', 'fields mode name type')\n+\n+\n+class _JsonToDictCoder(coders.Coder):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5b718b9acfefffb660efe8a8b11cc8e775ad5f9"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNDc0OQ==", "bodyText": "This coder was just moved from bigquery.py to bq_read_internal.py", "url": "https://github.com/apache/beam/pull/13170#discussion_r528024749", "createdAt": "2020-11-20T23:34:16Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "diffHunk": "@@ -100,3 +127,258 @@ def process(self, unused_element, unused_signal, gcs_locations):\n     )\n \n     return main_output\n+\n+\n+class _BigQueryReadSplit(beam.transforms.DoFn):\n+  def __init__(\n+      self,\n+      options: PipelineOptions,\n+      gcs_location: Union[str, ValueProvider] = None,\n+      use_json_exports: bool = False,\n+      bigquery_job_labels: Dict[str, str] = None,\n+      step_name: str = None,\n+      job_name: str = None,\n+      unique_id: str = None,\n+      kms_key: str = None,\n+      project: str = None,\n+      temp_dataset: Union[str, DatasetReference] = None):\n+    self.options = options\n+    self.use_json_exports = use_json_exports\n+    self.gcs_location = gcs_location\n+    self.bigquery_job_labels = bigquery_job_labels or {}\n+    self._step_name = step_name\n+    self._job_name = job_name or 'BQ_READ_SPLIT'\n+    self._source_uuid = unique_id\n+    self.kms_key = kms_key\n+    self.project = project\n+    self.temp_dataset = temp_dataset\n+    self.bq_io_metadata = None\n+\n+  def display_data(self):\n+    return {\n+        'use_json_exports': str(self.use_json_exports),\n+        'gcs_location': str(self.gcs_location),\n+        'bigquery_job_labels': json.dumps(self.bigquery_job_labels),\n+        'kms_key': str(self.kms_key),\n+        'project': str(self.project),\n+        'temp_dataset': str(self.temp_dataset)\n+    }\n+\n+  def _get_temp_dataset(self):\n+    if isinstance(self.temp_dataset, str):\n+      return DatasetReference(\n+          datasetId=self.temp_dataset, projectId=self._get_project())\n+    else:\n+      return self.temp_dataset\n+\n+  def process(self, element: 'ReadFromBigQueryRequest', *args,\n+              **kwargs) -> Iterable[BoundedSource]:\n+    bq = bigquery_tools.BigQueryWrapper(\n+        temp_dataset_id=(\n+            self._get_temp_dataset().datasetId if self._get_temp_dataset(\n+            ) else None))\n+\n+    if element.query is not None:\n+      self._setup_temporary_dataset(bq, element)\n+      table_reference = self._execute_query(bq, element)\n+    else:\n+      assert element.table\n+      table_reference = bigquery_tools.parse_table_reference(\n+          element.table, project=self._get_project())\n+\n+    if not table_reference.projectId:\n+      table_reference.projectId = self._get_project()\n+\n+    schema, metadata_list = self._export_files(bq, element, table_reference)\n+\n+    for metadata in metadata_list:\n+      yield self._create_source(metadata.path, schema)\n+\n+    if element.query is not None:\n+      bq.clean_up_temporary_dataset(self._get_project())\n+\n+  def _get_bq_metadata(self):\n+    if not self.bq_io_metadata:\n+      self.bq_io_metadata = create_bigquery_io_metadata(self._step_name)\n+    return self.bq_io_metadata\n+\n+  def _create_source(self, path, schema):\n+    if not self.use_json_exports:\n+      return _create_avro_source(path, use_fastavro=True)\n+    else:\n+      return _TextSource(\n+          path,\n+          min_bundle_size=0,\n+          compression_type=CompressionTypes.UNCOMPRESSED,\n+          strip_trailing_newlines=True,\n+          coder=_JsonToDictCoder(schema))\n+\n+  def _setup_temporary_dataset(\n+      self,\n+      bq: bigquery_tools.BigQueryWrapper,\n+      element: 'ReadFromBigQueryRequest'):\n+    location = bq.get_query_location(\n+        self._get_project(), element.query, not element.use_standard_sql)\n+    bq.create_temporary_dataset(self._get_project(), location)\n+\n+  def _execute_query(\n+      self,\n+      bq: bigquery_tools.BigQueryWrapper,\n+      element: 'ReadFromBigQueryRequest'):\n+    query_job_name = bigquery_tools.generate_bq_job_name(\n+        self._job_name,\n+        self._source_uuid,\n+        bigquery_tools.BigQueryJobTypes.QUERY,\n+        random.randint(0, 1000))\n+    job = bq._start_query_job(\n+        self._get_project(),\n+        element.query,\n+        not element.use_standard_sql,\n+        element.flatten_results,\n+        job_id=query_job_name,\n+        kms_key=self.kms_key,\n+        job_labels=self._get_bq_metadata().add_additional_bq_job_labels(\n+            self.bigquery_job_labels))\n+    job_ref = job.jobReference\n+    bq.wait_for_bq_job(job_ref, max_retries=0)\n+    return bq._get_temp_table(self._get_project())\n+\n+  def _export_files(\n+      self,\n+      bq: bigquery_tools.BigQueryWrapper,\n+      element: 'ReadFromBigQueryRequest',\n+      table_reference: TableReference):\n+    \"\"\"Runs a BigQuery export job.\n+\n+    Returns:\n+      bigquery.TableSchema instance, a list of FileMetadata instances\n+    \"\"\"\n+    job_labels = self._get_bq_metadata().add_additional_bq_job_labels(\n+        self.bigquery_job_labels)\n+    export_job_name = bigquery_tools.generate_bq_job_name(\n+        self._job_name,\n+        self._source_uuid,\n+        bigquery_tools.BigQueryJobTypes.EXPORT,\n+        element.obj_id)\n+    temp_location = self.options.view_as(GoogleCloudOptions).temp_location\n+    gcs_location = bigquery_export_destination_uri(\n+        self.gcs_location,\n+        temp_location,\n+        '%s%s' % (self._source_uuid, element.obj_id))\n+    if self.use_json_exports:\n+      job_ref = bq.perform_extract_job([gcs_location],\n+                                       export_job_name,\n+                                       table_reference,\n+                                       bigquery_tools.FileFormat.JSON,\n+                                       project=self._get_project(),\n+                                       job_labels=job_labels,\n+                                       include_header=False)\n+    else:\n+      job_ref = bq.perform_extract_job([gcs_location],\n+                                       export_job_name,\n+                                       table_reference,\n+                                       bigquery_tools.FileFormat.AVRO,\n+                                       project=self._get_project(),\n+                                       include_header=False,\n+                                       job_labels=job_labels,\n+                                       use_avro_logical_types=True)\n+    bq.wait_for_bq_job(job_ref)\n+    metadata_list = FileSystems.match([gcs_location])[0].metadata_list\n+\n+    if isinstance(table_reference, ValueProvider):\n+      table_ref = bigquery_tools.parse_table_reference(\n+          element.table, project=self._get_project())\n+    else:\n+      table_ref = table_reference\n+    table = bq.get_table(\n+        table_ref.projectId, table_ref.datasetId, table_ref.tableId)\n+\n+    return table.schema, metadata_list\n+\n+  def _get_project(self):\n+    \"\"\"Returns the project that queries and exports will be billed to.\"\"\"\n+\n+    project = self.options.view_as(GoogleCloudOptions).project\n+    if isinstance(project, ValueProvider):\n+      project = project.get()\n+    if not project:\n+      project = self.project\n+    return project\n+\n+\n+FieldSchema = collections.namedtuple('FieldSchema', 'fields mode name type')\n+\n+\n+class _JsonToDictCoder(coders.Coder):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0MDg2NA=="}, "originalCommit": {"oid": "d5b718b9acfefffb660efe8a8b11cc8e775ad5f9"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAzOTkwNA==", "bodyText": "Ah ok. Thanks.", "url": "https://github.com/apache/beam/pull/13170#discussion_r528039904", "createdAt": "2020-11-21T00:40:43Z", "author": {"login": "chamikaramj"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "diffHunk": "@@ -100,3 +127,258 @@ def process(self, unused_element, unused_signal, gcs_locations):\n     )\n \n     return main_output\n+\n+\n+class _BigQueryReadSplit(beam.transforms.DoFn):\n+  def __init__(\n+      self,\n+      options: PipelineOptions,\n+      gcs_location: Union[str, ValueProvider] = None,\n+      use_json_exports: bool = False,\n+      bigquery_job_labels: Dict[str, str] = None,\n+      step_name: str = None,\n+      job_name: str = None,\n+      unique_id: str = None,\n+      kms_key: str = None,\n+      project: str = None,\n+      temp_dataset: Union[str, DatasetReference] = None):\n+    self.options = options\n+    self.use_json_exports = use_json_exports\n+    self.gcs_location = gcs_location\n+    self.bigquery_job_labels = bigquery_job_labels or {}\n+    self._step_name = step_name\n+    self._job_name = job_name or 'BQ_READ_SPLIT'\n+    self._source_uuid = unique_id\n+    self.kms_key = kms_key\n+    self.project = project\n+    self.temp_dataset = temp_dataset\n+    self.bq_io_metadata = None\n+\n+  def display_data(self):\n+    return {\n+        'use_json_exports': str(self.use_json_exports),\n+        'gcs_location': str(self.gcs_location),\n+        'bigquery_job_labels': json.dumps(self.bigquery_job_labels),\n+        'kms_key': str(self.kms_key),\n+        'project': str(self.project),\n+        'temp_dataset': str(self.temp_dataset)\n+    }\n+\n+  def _get_temp_dataset(self):\n+    if isinstance(self.temp_dataset, str):\n+      return DatasetReference(\n+          datasetId=self.temp_dataset, projectId=self._get_project())\n+    else:\n+      return self.temp_dataset\n+\n+  def process(self, element: 'ReadFromBigQueryRequest', *args,\n+              **kwargs) -> Iterable[BoundedSource]:\n+    bq = bigquery_tools.BigQueryWrapper(\n+        temp_dataset_id=(\n+            self._get_temp_dataset().datasetId if self._get_temp_dataset(\n+            ) else None))\n+\n+    if element.query is not None:\n+      self._setup_temporary_dataset(bq, element)\n+      table_reference = self._execute_query(bq, element)\n+    else:\n+      assert element.table\n+      table_reference = bigquery_tools.parse_table_reference(\n+          element.table, project=self._get_project())\n+\n+    if not table_reference.projectId:\n+      table_reference.projectId = self._get_project()\n+\n+    schema, metadata_list = self._export_files(bq, element, table_reference)\n+\n+    for metadata in metadata_list:\n+      yield self._create_source(metadata.path, schema)\n+\n+    if element.query is not None:\n+      bq.clean_up_temporary_dataset(self._get_project())\n+\n+  def _get_bq_metadata(self):\n+    if not self.bq_io_metadata:\n+      self.bq_io_metadata = create_bigquery_io_metadata(self._step_name)\n+    return self.bq_io_metadata\n+\n+  def _create_source(self, path, schema):\n+    if not self.use_json_exports:\n+      return _create_avro_source(path, use_fastavro=True)\n+    else:\n+      return _TextSource(\n+          path,\n+          min_bundle_size=0,\n+          compression_type=CompressionTypes.UNCOMPRESSED,\n+          strip_trailing_newlines=True,\n+          coder=_JsonToDictCoder(schema))\n+\n+  def _setup_temporary_dataset(\n+      self,\n+      bq: bigquery_tools.BigQueryWrapper,\n+      element: 'ReadFromBigQueryRequest'):\n+    location = bq.get_query_location(\n+        self._get_project(), element.query, not element.use_standard_sql)\n+    bq.create_temporary_dataset(self._get_project(), location)\n+\n+  def _execute_query(\n+      self,\n+      bq: bigquery_tools.BigQueryWrapper,\n+      element: 'ReadFromBigQueryRequest'):\n+    query_job_name = bigquery_tools.generate_bq_job_name(\n+        self._job_name,\n+        self._source_uuid,\n+        bigquery_tools.BigQueryJobTypes.QUERY,\n+        random.randint(0, 1000))\n+    job = bq._start_query_job(\n+        self._get_project(),\n+        element.query,\n+        not element.use_standard_sql,\n+        element.flatten_results,\n+        job_id=query_job_name,\n+        kms_key=self.kms_key,\n+        job_labels=self._get_bq_metadata().add_additional_bq_job_labels(\n+            self.bigquery_job_labels))\n+    job_ref = job.jobReference\n+    bq.wait_for_bq_job(job_ref, max_retries=0)\n+    return bq._get_temp_table(self._get_project())\n+\n+  def _export_files(\n+      self,\n+      bq: bigquery_tools.BigQueryWrapper,\n+      element: 'ReadFromBigQueryRequest',\n+      table_reference: TableReference):\n+    \"\"\"Runs a BigQuery export job.\n+\n+    Returns:\n+      bigquery.TableSchema instance, a list of FileMetadata instances\n+    \"\"\"\n+    job_labels = self._get_bq_metadata().add_additional_bq_job_labels(\n+        self.bigquery_job_labels)\n+    export_job_name = bigquery_tools.generate_bq_job_name(\n+        self._job_name,\n+        self._source_uuid,\n+        bigquery_tools.BigQueryJobTypes.EXPORT,\n+        element.obj_id)\n+    temp_location = self.options.view_as(GoogleCloudOptions).temp_location\n+    gcs_location = bigquery_export_destination_uri(\n+        self.gcs_location,\n+        temp_location,\n+        '%s%s' % (self._source_uuid, element.obj_id))\n+    if self.use_json_exports:\n+      job_ref = bq.perform_extract_job([gcs_location],\n+                                       export_job_name,\n+                                       table_reference,\n+                                       bigquery_tools.FileFormat.JSON,\n+                                       project=self._get_project(),\n+                                       job_labels=job_labels,\n+                                       include_header=False)\n+    else:\n+      job_ref = bq.perform_extract_job([gcs_location],\n+                                       export_job_name,\n+                                       table_reference,\n+                                       bigquery_tools.FileFormat.AVRO,\n+                                       project=self._get_project(),\n+                                       include_header=False,\n+                                       job_labels=job_labels,\n+                                       use_avro_logical_types=True)\n+    bq.wait_for_bq_job(job_ref)\n+    metadata_list = FileSystems.match([gcs_location])[0].metadata_list\n+\n+    if isinstance(table_reference, ValueProvider):\n+      table_ref = bigquery_tools.parse_table_reference(\n+          element.table, project=self._get_project())\n+    else:\n+      table_ref = table_reference\n+    table = bq.get_table(\n+        table_ref.projectId, table_ref.datasetId, table_ref.tableId)\n+\n+    return table.schema, metadata_list\n+\n+  def _get_project(self):\n+    \"\"\"Returns the project that queries and exports will be billed to.\"\"\"\n+\n+    project = self.options.view_as(GoogleCloudOptions).project\n+    if isinstance(project, ValueProvider):\n+      project = project.get()\n+    if not project:\n+      project = self.project\n+    return project\n+\n+\n+FieldSchema = collections.namedtuple('FieldSchema', 'fields mode name type')\n+\n+\n+class _JsonToDictCoder(coders.Coder):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0MDg2NA=="}, "originalCommit": {"oid": "d5b718b9acfefffb660efe8a8b11cc8e775ad5f9"}, "originalPosition": 229}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDI4OTk5OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMDowMToxNVrOH3e-OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMzozNDo0M1rOH3kFQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0MTE3Ng==", "bodyText": "Please add unit tests for the new coder.", "url": "https://github.com/apache/beam/pull/13170#discussion_r527941176", "createdAt": "2020-11-20T20:01:15Z", "author": {"login": "chamikaramj"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "diffHunk": "@@ -100,3 +127,258 @@ def process(self, unused_element, unused_signal, gcs_locations):\n     )\n \n     return main_output\n+\n+\n+class _BigQueryReadSplit(beam.transforms.DoFn):\n+  def __init__(\n+      self,\n+      options: PipelineOptions,\n+      gcs_location: Union[str, ValueProvider] = None,\n+      use_json_exports: bool = False,\n+      bigquery_job_labels: Dict[str, str] = None,\n+      step_name: str = None,\n+      job_name: str = None,\n+      unique_id: str = None,\n+      kms_key: str = None,\n+      project: str = None,\n+      temp_dataset: Union[str, DatasetReference] = None):\n+    self.options = options\n+    self.use_json_exports = use_json_exports\n+    self.gcs_location = gcs_location\n+    self.bigquery_job_labels = bigquery_job_labels or {}\n+    self._step_name = step_name\n+    self._job_name = job_name or 'BQ_READ_SPLIT'\n+    self._source_uuid = unique_id\n+    self.kms_key = kms_key\n+    self.project = project\n+    self.temp_dataset = temp_dataset\n+    self.bq_io_metadata = None\n+\n+  def display_data(self):\n+    return {\n+        'use_json_exports': str(self.use_json_exports),\n+        'gcs_location': str(self.gcs_location),\n+        'bigquery_job_labels': json.dumps(self.bigquery_job_labels),\n+        'kms_key': str(self.kms_key),\n+        'project': str(self.project),\n+        'temp_dataset': str(self.temp_dataset)\n+    }\n+\n+  def _get_temp_dataset(self):\n+    if isinstance(self.temp_dataset, str):\n+      return DatasetReference(\n+          datasetId=self.temp_dataset, projectId=self._get_project())\n+    else:\n+      return self.temp_dataset\n+\n+  def process(self, element: 'ReadFromBigQueryRequest', *args,\n+              **kwargs) -> Iterable[BoundedSource]:\n+    bq = bigquery_tools.BigQueryWrapper(\n+        temp_dataset_id=(\n+            self._get_temp_dataset().datasetId if self._get_temp_dataset(\n+            ) else None))\n+\n+    if element.query is not None:\n+      self._setup_temporary_dataset(bq, element)\n+      table_reference = self._execute_query(bq, element)\n+    else:\n+      assert element.table\n+      table_reference = bigquery_tools.parse_table_reference(\n+          element.table, project=self._get_project())\n+\n+    if not table_reference.projectId:\n+      table_reference.projectId = self._get_project()\n+\n+    schema, metadata_list = self._export_files(bq, element, table_reference)\n+\n+    for metadata in metadata_list:\n+      yield self._create_source(metadata.path, schema)\n+\n+    if element.query is not None:\n+      bq.clean_up_temporary_dataset(self._get_project())\n+\n+  def _get_bq_metadata(self):\n+    if not self.bq_io_metadata:\n+      self.bq_io_metadata = create_bigquery_io_metadata(self._step_name)\n+    return self.bq_io_metadata\n+\n+  def _create_source(self, path, schema):\n+    if not self.use_json_exports:\n+      return _create_avro_source(path, use_fastavro=True)\n+    else:\n+      return _TextSource(\n+          path,\n+          min_bundle_size=0,\n+          compression_type=CompressionTypes.UNCOMPRESSED,\n+          strip_trailing_newlines=True,\n+          coder=_JsonToDictCoder(schema))\n+\n+  def _setup_temporary_dataset(\n+      self,\n+      bq: bigquery_tools.BigQueryWrapper,\n+      element: 'ReadFromBigQueryRequest'):\n+    location = bq.get_query_location(\n+        self._get_project(), element.query, not element.use_standard_sql)\n+    bq.create_temporary_dataset(self._get_project(), location)\n+\n+  def _execute_query(\n+      self,\n+      bq: bigquery_tools.BigQueryWrapper,\n+      element: 'ReadFromBigQueryRequest'):\n+    query_job_name = bigquery_tools.generate_bq_job_name(\n+        self._job_name,\n+        self._source_uuid,\n+        bigquery_tools.BigQueryJobTypes.QUERY,\n+        random.randint(0, 1000))\n+    job = bq._start_query_job(\n+        self._get_project(),\n+        element.query,\n+        not element.use_standard_sql,\n+        element.flatten_results,\n+        job_id=query_job_name,\n+        kms_key=self.kms_key,\n+        job_labels=self._get_bq_metadata().add_additional_bq_job_labels(\n+            self.bigquery_job_labels))\n+    job_ref = job.jobReference\n+    bq.wait_for_bq_job(job_ref, max_retries=0)\n+    return bq._get_temp_table(self._get_project())\n+\n+  def _export_files(\n+      self,\n+      bq: bigquery_tools.BigQueryWrapper,\n+      element: 'ReadFromBigQueryRequest',\n+      table_reference: TableReference):\n+    \"\"\"Runs a BigQuery export job.\n+\n+    Returns:\n+      bigquery.TableSchema instance, a list of FileMetadata instances\n+    \"\"\"\n+    job_labels = self._get_bq_metadata().add_additional_bq_job_labels(\n+        self.bigquery_job_labels)\n+    export_job_name = bigquery_tools.generate_bq_job_name(\n+        self._job_name,\n+        self._source_uuid,\n+        bigquery_tools.BigQueryJobTypes.EXPORT,\n+        element.obj_id)\n+    temp_location = self.options.view_as(GoogleCloudOptions).temp_location\n+    gcs_location = bigquery_export_destination_uri(\n+        self.gcs_location,\n+        temp_location,\n+        '%s%s' % (self._source_uuid, element.obj_id))\n+    if self.use_json_exports:\n+      job_ref = bq.perform_extract_job([gcs_location],\n+                                       export_job_name,\n+                                       table_reference,\n+                                       bigquery_tools.FileFormat.JSON,\n+                                       project=self._get_project(),\n+                                       job_labels=job_labels,\n+                                       include_header=False)\n+    else:\n+      job_ref = bq.perform_extract_job([gcs_location],\n+                                       export_job_name,\n+                                       table_reference,\n+                                       bigquery_tools.FileFormat.AVRO,\n+                                       project=self._get_project(),\n+                                       include_header=False,\n+                                       job_labels=job_labels,\n+                                       use_avro_logical_types=True)\n+    bq.wait_for_bq_job(job_ref)\n+    metadata_list = FileSystems.match([gcs_location])[0].metadata_list\n+\n+    if isinstance(table_reference, ValueProvider):\n+      table_ref = bigquery_tools.parse_table_reference(\n+          element.table, project=self._get_project())\n+    else:\n+      table_ref = table_reference\n+    table = bq.get_table(\n+        table_ref.projectId, table_ref.datasetId, table_ref.tableId)\n+\n+    return table.schema, metadata_list\n+\n+  def _get_project(self):\n+    \"\"\"Returns the project that queries and exports will be billed to.\"\"\"\n+\n+    project = self.options.view_as(GoogleCloudOptions).project\n+    if isinstance(project, ValueProvider):\n+      project = project.get()\n+    if not project:\n+      project = self.project\n+    return project\n+\n+\n+FieldSchema = collections.namedtuple('FieldSchema', 'fields mode name type')\n+\n+\n+class _JsonToDictCoder(coders.Coder):\n+  \"\"\"A coder for a JSON string to a Python dict.\"\"\"\n+  def __init__(self, table_schema):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5b718b9acfefffb660efe8a8b11cc8e775ad5f9"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNDg5OQ==", "bodyText": "The coder was just moved from bq.py to bq_read_internal.py", "url": "https://github.com/apache/beam/pull/13170#discussion_r528024899", "createdAt": "2020-11-20T23:34:43Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "diffHunk": "@@ -100,3 +127,258 @@ def process(self, unused_element, unused_signal, gcs_locations):\n     )\n \n     return main_output\n+\n+\n+class _BigQueryReadSplit(beam.transforms.DoFn):\n+  def __init__(\n+      self,\n+      options: PipelineOptions,\n+      gcs_location: Union[str, ValueProvider] = None,\n+      use_json_exports: bool = False,\n+      bigquery_job_labels: Dict[str, str] = None,\n+      step_name: str = None,\n+      job_name: str = None,\n+      unique_id: str = None,\n+      kms_key: str = None,\n+      project: str = None,\n+      temp_dataset: Union[str, DatasetReference] = None):\n+    self.options = options\n+    self.use_json_exports = use_json_exports\n+    self.gcs_location = gcs_location\n+    self.bigquery_job_labels = bigquery_job_labels or {}\n+    self._step_name = step_name\n+    self._job_name = job_name or 'BQ_READ_SPLIT'\n+    self._source_uuid = unique_id\n+    self.kms_key = kms_key\n+    self.project = project\n+    self.temp_dataset = temp_dataset\n+    self.bq_io_metadata = None\n+\n+  def display_data(self):\n+    return {\n+        'use_json_exports': str(self.use_json_exports),\n+        'gcs_location': str(self.gcs_location),\n+        'bigquery_job_labels': json.dumps(self.bigquery_job_labels),\n+        'kms_key': str(self.kms_key),\n+        'project': str(self.project),\n+        'temp_dataset': str(self.temp_dataset)\n+    }\n+\n+  def _get_temp_dataset(self):\n+    if isinstance(self.temp_dataset, str):\n+      return DatasetReference(\n+          datasetId=self.temp_dataset, projectId=self._get_project())\n+    else:\n+      return self.temp_dataset\n+\n+  def process(self, element: 'ReadFromBigQueryRequest', *args,\n+              **kwargs) -> Iterable[BoundedSource]:\n+    bq = bigquery_tools.BigQueryWrapper(\n+        temp_dataset_id=(\n+            self._get_temp_dataset().datasetId if self._get_temp_dataset(\n+            ) else None))\n+\n+    if element.query is not None:\n+      self._setup_temporary_dataset(bq, element)\n+      table_reference = self._execute_query(bq, element)\n+    else:\n+      assert element.table\n+      table_reference = bigquery_tools.parse_table_reference(\n+          element.table, project=self._get_project())\n+\n+    if not table_reference.projectId:\n+      table_reference.projectId = self._get_project()\n+\n+    schema, metadata_list = self._export_files(bq, element, table_reference)\n+\n+    for metadata in metadata_list:\n+      yield self._create_source(metadata.path, schema)\n+\n+    if element.query is not None:\n+      bq.clean_up_temporary_dataset(self._get_project())\n+\n+  def _get_bq_metadata(self):\n+    if not self.bq_io_metadata:\n+      self.bq_io_metadata = create_bigquery_io_metadata(self._step_name)\n+    return self.bq_io_metadata\n+\n+  def _create_source(self, path, schema):\n+    if not self.use_json_exports:\n+      return _create_avro_source(path, use_fastavro=True)\n+    else:\n+      return _TextSource(\n+          path,\n+          min_bundle_size=0,\n+          compression_type=CompressionTypes.UNCOMPRESSED,\n+          strip_trailing_newlines=True,\n+          coder=_JsonToDictCoder(schema))\n+\n+  def _setup_temporary_dataset(\n+      self,\n+      bq: bigquery_tools.BigQueryWrapper,\n+      element: 'ReadFromBigQueryRequest'):\n+    location = bq.get_query_location(\n+        self._get_project(), element.query, not element.use_standard_sql)\n+    bq.create_temporary_dataset(self._get_project(), location)\n+\n+  def _execute_query(\n+      self,\n+      bq: bigquery_tools.BigQueryWrapper,\n+      element: 'ReadFromBigQueryRequest'):\n+    query_job_name = bigquery_tools.generate_bq_job_name(\n+        self._job_name,\n+        self._source_uuid,\n+        bigquery_tools.BigQueryJobTypes.QUERY,\n+        random.randint(0, 1000))\n+    job = bq._start_query_job(\n+        self._get_project(),\n+        element.query,\n+        not element.use_standard_sql,\n+        element.flatten_results,\n+        job_id=query_job_name,\n+        kms_key=self.kms_key,\n+        job_labels=self._get_bq_metadata().add_additional_bq_job_labels(\n+            self.bigquery_job_labels))\n+    job_ref = job.jobReference\n+    bq.wait_for_bq_job(job_ref, max_retries=0)\n+    return bq._get_temp_table(self._get_project())\n+\n+  def _export_files(\n+      self,\n+      bq: bigquery_tools.BigQueryWrapper,\n+      element: 'ReadFromBigQueryRequest',\n+      table_reference: TableReference):\n+    \"\"\"Runs a BigQuery export job.\n+\n+    Returns:\n+      bigquery.TableSchema instance, a list of FileMetadata instances\n+    \"\"\"\n+    job_labels = self._get_bq_metadata().add_additional_bq_job_labels(\n+        self.bigquery_job_labels)\n+    export_job_name = bigquery_tools.generate_bq_job_name(\n+        self._job_name,\n+        self._source_uuid,\n+        bigquery_tools.BigQueryJobTypes.EXPORT,\n+        element.obj_id)\n+    temp_location = self.options.view_as(GoogleCloudOptions).temp_location\n+    gcs_location = bigquery_export_destination_uri(\n+        self.gcs_location,\n+        temp_location,\n+        '%s%s' % (self._source_uuid, element.obj_id))\n+    if self.use_json_exports:\n+      job_ref = bq.perform_extract_job([gcs_location],\n+                                       export_job_name,\n+                                       table_reference,\n+                                       bigquery_tools.FileFormat.JSON,\n+                                       project=self._get_project(),\n+                                       job_labels=job_labels,\n+                                       include_header=False)\n+    else:\n+      job_ref = bq.perform_extract_job([gcs_location],\n+                                       export_job_name,\n+                                       table_reference,\n+                                       bigquery_tools.FileFormat.AVRO,\n+                                       project=self._get_project(),\n+                                       include_header=False,\n+                                       job_labels=job_labels,\n+                                       use_avro_logical_types=True)\n+    bq.wait_for_bq_job(job_ref)\n+    metadata_list = FileSystems.match([gcs_location])[0].metadata_list\n+\n+    if isinstance(table_reference, ValueProvider):\n+      table_ref = bigquery_tools.parse_table_reference(\n+          element.table, project=self._get_project())\n+    else:\n+      table_ref = table_reference\n+    table = bq.get_table(\n+        table_ref.projectId, table_ref.datasetId, table_ref.tableId)\n+\n+    return table.schema, metadata_list\n+\n+  def _get_project(self):\n+    \"\"\"Returns the project that queries and exports will be billed to.\"\"\"\n+\n+    project = self.options.view_as(GoogleCloudOptions).project\n+    if isinstance(project, ValueProvider):\n+      project = project.get()\n+    if not project:\n+      project = self.project\n+    return project\n+\n+\n+FieldSchema = collections.namedtuple('FieldSchema', 'fields mode name type')\n+\n+\n+class _JsonToDictCoder(coders.Coder):\n+  \"\"\"A coder for a JSON string to a Python dict.\"\"\"\n+  def __init__(self, table_schema):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0MTE3Ng=="}, "originalCommit": {"oid": "d5b718b9acfefffb660efe8a8b11cc8e775ad5f9"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDI5MjY1OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/io/gcp/bigquery_read_it_test.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMDowMjoxMlrOH3e_3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMDo0MTozNlrOH3lAfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0MTU5OA==", "bodyText": "We should also add an integration test.", "url": "https://github.com/apache/beam/pull/13170#discussion_r527941598", "createdAt": "2020-11-20T20:02:12Z", "author": {"login": "chamikaramj"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_it_test.py", "diffHunk": "@@ -298,6 +298,109 @@ def test_iobase_source(self):\n       assert_that(result, equal_to(self.get_expected_data(native=False)))\n \n \n+class ReadAllBQTests(BigQueryReadIntegrationTests):\n+  TABLE_DATA_1 = [{\n+      'number': 1, 'str': 'abc'\n+  }, {\n+      'number': 2, 'str': 'def'\n+  }, {\n+      'number': 3, 'str': u'\u4f60\u597d'\n+  }, {\n+      'number': 4, 'str': u'\u043f\u0440\u0438\u0432\u0435\u0442'\n+  }]\n+\n+  TABLE_DATA_2 = [{\n+      'number': 10, 'str': 'abcd'\n+  }, {\n+      'number': 20, 'str': 'defg'\n+  }, {\n+      'number': 30, 'str': u'\u4f60\u597d'\n+  }, {\n+      'number': 40, 'str': u'\u043f\u0440\u0438\u0432\u0435\u0442'\n+  }]\n+\n+  TABLE_DATA_3 = [{'number': 10, 'str': 'abcde', 'extra': 3}]\n+\n+  @classmethod\n+  def setUpClass(cls):\n+    super(ReadAllBQTests, cls).setUpClass()\n+    cls.SCHEMA_BQ = cls.create_bq_schema()\n+    cls.SCHEMA_BQ_WITH_EXTRA = cls.create_bq_schema(True)\n+\n+    cls.table_name1 = 'python_rd_table_1'\n+    cls.table_schema1 = cls.create_table(\n+        cls.table_name1, cls.TABLE_DATA_1, cls.SCHEMA_BQ)\n+    table_id1 = '{}.{}'.format(cls.dataset_id, cls.table_name1)\n+    cls.query1 = 'SELECT number, str FROM `%s`' % table_id1\n+\n+    cls.table_name2 = 'python_rd_table_2'\n+    cls.table_schema2 = cls.create_table(\n+        cls.table_name2, cls.TABLE_DATA_2, cls.SCHEMA_BQ)\n+    table_id2 = '{}.{}'.format(cls.dataset_id, cls.table_name2)\n+    cls.query2 = 'SELECT number, str FROM %s' % table_id2\n+\n+    cls.table_name3 = 'python_rd_table_3'\n+    cls.table_schema3 = cls.create_table(\n+        cls.table_name3, cls.TABLE_DATA_3, cls.SCHEMA_BQ_WITH_EXTRA)\n+    table_id3 = '{}.{}'.format(cls.dataset_id, cls.table_name3)\n+    cls.query3 = 'SELECT number, str, extra FROM `%s`' % table_id3\n+\n+  @classmethod\n+  def create_table(cls, table_name, data, table_schema):\n+    table = bigquery.Table(\n+        tableReference=bigquery.TableReference(\n+            projectId=cls.project, datasetId=cls.dataset_id,\n+            tableId=table_name),\n+        schema=table_schema)\n+    request = bigquery.BigqueryTablesInsertRequest(\n+        projectId=cls.project, datasetId=cls.dataset_id, table=table)\n+    cls.bigquery_client.client.tables.Insert(request)\n+    cls.bigquery_client.insert_rows(\n+        cls.project, cls.dataset_id, table_name, data)\n+    return table_schema\n+\n+  @classmethod\n+  def create_bq_schema(cls, with_extra=False):\n+    table_schema = bigquery.TableSchema()\n+    table_field = bigquery.TableFieldSchema()\n+    table_field.name = 'number'\n+    table_field.type = 'INTEGER'\n+    table_field.mode = 'NULLABLE'\n+    table_schema.fields.append(table_field)\n+    table_field = bigquery.TableFieldSchema()\n+    table_field.name = 'str'\n+    table_field.type = 'STRING'\n+    table_field.mode = 'NULLABLE'\n+    table_schema.fields.append(table_field)\n+    if with_extra:\n+      table_field = bigquery.TableFieldSchema()\n+      table_field.name = 'extra'\n+      table_field.type = 'INTEGER'\n+      table_field.mode = 'NULLABLE'\n+      table_schema.fields.append(table_field)\n+    return table_schema\n+\n+  @skip(['PortableRunner', 'FlinkRunner'])\n+  @attr('IT')\n+  def test_read_queries(self):\n+    # TODO(BEAM-11311): Remove experiment when tests run on r_v2.\n+    args = self.args + [\"--experiments=use_runner_v2\"]\n+    with beam.Pipeline(argv=args) as p:\n+      result = (\n+          p\n+          | beam.Create([\n+              beam.io.ReadFromBigQueryRequest(query=self.query1),\n+              beam.io.ReadFromBigQueryRequest(\n+                  query=self.query2, use_standard_sql=False),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5b718b9acfefffb660efe8a8b11cc8e775ad5f9"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNTAyOQ==", "bodyText": "This is an integration test (attr('IT')) - do you mean something else?", "url": "https://github.com/apache/beam/pull/13170#discussion_r528025029", "createdAt": "2020-11-20T23:35:13Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_it_test.py", "diffHunk": "@@ -298,6 +298,109 @@ def test_iobase_source(self):\n       assert_that(result, equal_to(self.get_expected_data(native=False)))\n \n \n+class ReadAllBQTests(BigQueryReadIntegrationTests):\n+  TABLE_DATA_1 = [{\n+      'number': 1, 'str': 'abc'\n+  }, {\n+      'number': 2, 'str': 'def'\n+  }, {\n+      'number': 3, 'str': u'\u4f60\u597d'\n+  }, {\n+      'number': 4, 'str': u'\u043f\u0440\u0438\u0432\u0435\u0442'\n+  }]\n+\n+  TABLE_DATA_2 = [{\n+      'number': 10, 'str': 'abcd'\n+  }, {\n+      'number': 20, 'str': 'defg'\n+  }, {\n+      'number': 30, 'str': u'\u4f60\u597d'\n+  }, {\n+      'number': 40, 'str': u'\u043f\u0440\u0438\u0432\u0435\u0442'\n+  }]\n+\n+  TABLE_DATA_3 = [{'number': 10, 'str': 'abcde', 'extra': 3}]\n+\n+  @classmethod\n+  def setUpClass(cls):\n+    super(ReadAllBQTests, cls).setUpClass()\n+    cls.SCHEMA_BQ = cls.create_bq_schema()\n+    cls.SCHEMA_BQ_WITH_EXTRA = cls.create_bq_schema(True)\n+\n+    cls.table_name1 = 'python_rd_table_1'\n+    cls.table_schema1 = cls.create_table(\n+        cls.table_name1, cls.TABLE_DATA_1, cls.SCHEMA_BQ)\n+    table_id1 = '{}.{}'.format(cls.dataset_id, cls.table_name1)\n+    cls.query1 = 'SELECT number, str FROM `%s`' % table_id1\n+\n+    cls.table_name2 = 'python_rd_table_2'\n+    cls.table_schema2 = cls.create_table(\n+        cls.table_name2, cls.TABLE_DATA_2, cls.SCHEMA_BQ)\n+    table_id2 = '{}.{}'.format(cls.dataset_id, cls.table_name2)\n+    cls.query2 = 'SELECT number, str FROM %s' % table_id2\n+\n+    cls.table_name3 = 'python_rd_table_3'\n+    cls.table_schema3 = cls.create_table(\n+        cls.table_name3, cls.TABLE_DATA_3, cls.SCHEMA_BQ_WITH_EXTRA)\n+    table_id3 = '{}.{}'.format(cls.dataset_id, cls.table_name3)\n+    cls.query3 = 'SELECT number, str, extra FROM `%s`' % table_id3\n+\n+  @classmethod\n+  def create_table(cls, table_name, data, table_schema):\n+    table = bigquery.Table(\n+        tableReference=bigquery.TableReference(\n+            projectId=cls.project, datasetId=cls.dataset_id,\n+            tableId=table_name),\n+        schema=table_schema)\n+    request = bigquery.BigqueryTablesInsertRequest(\n+        projectId=cls.project, datasetId=cls.dataset_id, table=table)\n+    cls.bigquery_client.client.tables.Insert(request)\n+    cls.bigquery_client.insert_rows(\n+        cls.project, cls.dataset_id, table_name, data)\n+    return table_schema\n+\n+  @classmethod\n+  def create_bq_schema(cls, with_extra=False):\n+    table_schema = bigquery.TableSchema()\n+    table_field = bigquery.TableFieldSchema()\n+    table_field.name = 'number'\n+    table_field.type = 'INTEGER'\n+    table_field.mode = 'NULLABLE'\n+    table_schema.fields.append(table_field)\n+    table_field = bigquery.TableFieldSchema()\n+    table_field.name = 'str'\n+    table_field.type = 'STRING'\n+    table_field.mode = 'NULLABLE'\n+    table_schema.fields.append(table_field)\n+    if with_extra:\n+      table_field = bigquery.TableFieldSchema()\n+      table_field.name = 'extra'\n+      table_field.type = 'INTEGER'\n+      table_field.mode = 'NULLABLE'\n+      table_schema.fields.append(table_field)\n+    return table_schema\n+\n+  @skip(['PortableRunner', 'FlinkRunner'])\n+  @attr('IT')\n+  def test_read_queries(self):\n+    # TODO(BEAM-11311): Remove experiment when tests run on r_v2.\n+    args = self.args + [\"--experiments=use_runner_v2\"]\n+    with beam.Pipeline(argv=args) as p:\n+      result = (\n+          p\n+          | beam.Create([\n+              beam.io.ReadFromBigQueryRequest(query=self.query1),\n+              beam.io.ReadFromBigQueryRequest(\n+                  query=self.query2, use_standard_sql=False),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0MTU5OA=="}, "originalCommit": {"oid": "d5b718b9acfefffb660efe8a8b11cc8e775ad5f9"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MDA2Mw==", "bodyText": "I see. Thanks. No this is good.", "url": "https://github.com/apache/beam/pull/13170#discussion_r528040063", "createdAt": "2020-11-21T00:41:36Z", "author": {"login": "chamikaramj"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_it_test.py", "diffHunk": "@@ -298,6 +298,109 @@ def test_iobase_source(self):\n       assert_that(result, equal_to(self.get_expected_data(native=False)))\n \n \n+class ReadAllBQTests(BigQueryReadIntegrationTests):\n+  TABLE_DATA_1 = [{\n+      'number': 1, 'str': 'abc'\n+  }, {\n+      'number': 2, 'str': 'def'\n+  }, {\n+      'number': 3, 'str': u'\u4f60\u597d'\n+  }, {\n+      'number': 4, 'str': u'\u043f\u0440\u0438\u0432\u0435\u0442'\n+  }]\n+\n+  TABLE_DATA_2 = [{\n+      'number': 10, 'str': 'abcd'\n+  }, {\n+      'number': 20, 'str': 'defg'\n+  }, {\n+      'number': 30, 'str': u'\u4f60\u597d'\n+  }, {\n+      'number': 40, 'str': u'\u043f\u0440\u0438\u0432\u0435\u0442'\n+  }]\n+\n+  TABLE_DATA_3 = [{'number': 10, 'str': 'abcde', 'extra': 3}]\n+\n+  @classmethod\n+  def setUpClass(cls):\n+    super(ReadAllBQTests, cls).setUpClass()\n+    cls.SCHEMA_BQ = cls.create_bq_schema()\n+    cls.SCHEMA_BQ_WITH_EXTRA = cls.create_bq_schema(True)\n+\n+    cls.table_name1 = 'python_rd_table_1'\n+    cls.table_schema1 = cls.create_table(\n+        cls.table_name1, cls.TABLE_DATA_1, cls.SCHEMA_BQ)\n+    table_id1 = '{}.{}'.format(cls.dataset_id, cls.table_name1)\n+    cls.query1 = 'SELECT number, str FROM `%s`' % table_id1\n+\n+    cls.table_name2 = 'python_rd_table_2'\n+    cls.table_schema2 = cls.create_table(\n+        cls.table_name2, cls.TABLE_DATA_2, cls.SCHEMA_BQ)\n+    table_id2 = '{}.{}'.format(cls.dataset_id, cls.table_name2)\n+    cls.query2 = 'SELECT number, str FROM %s' % table_id2\n+\n+    cls.table_name3 = 'python_rd_table_3'\n+    cls.table_schema3 = cls.create_table(\n+        cls.table_name3, cls.TABLE_DATA_3, cls.SCHEMA_BQ_WITH_EXTRA)\n+    table_id3 = '{}.{}'.format(cls.dataset_id, cls.table_name3)\n+    cls.query3 = 'SELECT number, str, extra FROM `%s`' % table_id3\n+\n+  @classmethod\n+  def create_table(cls, table_name, data, table_schema):\n+    table = bigquery.Table(\n+        tableReference=bigquery.TableReference(\n+            projectId=cls.project, datasetId=cls.dataset_id,\n+            tableId=table_name),\n+        schema=table_schema)\n+    request = bigquery.BigqueryTablesInsertRequest(\n+        projectId=cls.project, datasetId=cls.dataset_id, table=table)\n+    cls.bigquery_client.client.tables.Insert(request)\n+    cls.bigquery_client.insert_rows(\n+        cls.project, cls.dataset_id, table_name, data)\n+    return table_schema\n+\n+  @classmethod\n+  def create_bq_schema(cls, with_extra=False):\n+    table_schema = bigquery.TableSchema()\n+    table_field = bigquery.TableFieldSchema()\n+    table_field.name = 'number'\n+    table_field.type = 'INTEGER'\n+    table_field.mode = 'NULLABLE'\n+    table_schema.fields.append(table_field)\n+    table_field = bigquery.TableFieldSchema()\n+    table_field.name = 'str'\n+    table_field.type = 'STRING'\n+    table_field.mode = 'NULLABLE'\n+    table_schema.fields.append(table_field)\n+    if with_extra:\n+      table_field = bigquery.TableFieldSchema()\n+      table_field.name = 'extra'\n+      table_field.type = 'INTEGER'\n+      table_field.mode = 'NULLABLE'\n+      table_schema.fields.append(table_field)\n+    return table_schema\n+\n+  @skip(['PortableRunner', 'FlinkRunner'])\n+  @attr('IT')\n+  def test_read_queries(self):\n+    # TODO(BEAM-11311): Remove experiment when tests run on r_v2.\n+    args = self.args + [\"--experiments=use_runner_v2\"]\n+    with beam.Pipeline(argv=args) as p:\n+      result = (\n+          p\n+          | beam.Create([\n+              beam.io.ReadFromBigQueryRequest(query=self.query1),\n+              beam.io.ReadFromBigQueryRequest(\n+                  query=self.query2, use_standard_sql=False),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0MTU5OA=="}, "originalCommit": {"oid": "d5b718b9acfefffb660efe8a8b11cc8e775ad5f9"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMTA2NTU5OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMjoyNjowNVrOH3l_fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMjoyNjowNVrOH3l_fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA1NjE5MQ==", "bodyText": "We should also cleanup the temporary datasets that are created by the pipeline (may be at the end of every window).", "url": "https://github.com/apache/beam/pull/13170#discussion_r528056191", "createdAt": "2020-11-21T02:26:05Z", "author": {"login": "chamikaramj"}, "path": "sdks/python/apache_beam/io/gcp/bigquery_read_internal.py", "diffHunk": "@@ -100,3 +127,264 @@ def process(self, unused_element, unused_signal, gcs_locations):\n     )\n \n     return main_output\n+\n+\n+class _BigQueryReadSplit(beam.transforms.DoFn):\n+  \"\"\"Starts the process of reading from BigQuery.\n+\n+  This transform will start a BigQuery export job, and output a number of\n+  file sources that are consumed downstream.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      options: PipelineOptions,\n+      gcs_location: Union[str, ValueProvider] = None,\n+      use_json_exports: bool = False,\n+      bigquery_job_labels: Dict[str, str] = None,\n+      step_name: str = None,\n+      job_name: str = None,\n+      unique_id: str = None,\n+      kms_key: str = None,\n+      project: str = None,\n+      temp_dataset: Union[str, DatasetReference] = None):\n+    self.options = options\n+    self.use_json_exports = use_json_exports\n+    self.gcs_location = gcs_location\n+    self.bigquery_job_labels = bigquery_job_labels or {}\n+    self._step_name = step_name\n+    self._job_name = job_name or 'BQ_READ_SPLIT'\n+    self._source_uuid = unique_id\n+    self.kms_key = kms_key\n+    self.project = project\n+    self.temp_dataset = temp_dataset or 'bq_read_all_%s' % uuid.uuid4().hex\n+    self.bq_io_metadata = None\n+\n+  def display_data(self):\n+    return {\n+        'use_json_exports': str(self.use_json_exports),\n+        'gcs_location': str(self.gcs_location),\n+        'bigquery_job_labels': json.dumps(self.bigquery_job_labels),\n+        'kms_key': str(self.kms_key),\n+        'project': str(self.project),\n+        'temp_dataset': str(self.temp_dataset)\n+    }\n+\n+  def _get_temp_dataset(self):\n+    if isinstance(self.temp_dataset, str):\n+      return DatasetReference(\n+          datasetId=self.temp_dataset, projectId=self._get_project())\n+    else:\n+      return self.temp_dataset\n+\n+  def process(self, element: 'ReadFromBigQueryRequest', *args,\n+              **kwargs) -> Iterable[BoundedSource]:\n+    bq = bigquery_tools.BigQueryWrapper(\n+        temp_dataset_id=self._get_temp_dataset().datasetId)\n+\n+    if element.query is not None:\n+      self._setup_temporary_dataset(bq, element)\n+      table_reference = self._execute_query(bq, element)\n+    else:\n+      assert element.table\n+      table_reference = bigquery_tools.parse_table_reference(\n+          element.table, project=self._get_project())\n+\n+    if not table_reference.projectId:\n+      table_reference.projectId = self._get_project()\n+\n+    schema, metadata_list = self._export_files(bq, element, table_reference)\n+\n+    for metadata in metadata_list:\n+      yield self._create_source(metadata.path, schema)\n+\n+    if element.query is not None:\n+      bq._delete_table(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d470c4f34e0616e548b4f0cae10054bdb314125b"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMTA2NzAwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/io/gcp/bigquery.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMjoyNzozNlrOH3mANQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNDo0MTowN1rOH7-HVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA1NjM3Mw==", "bodyText": "We might need a reshuffle before this cleanup step to make sure that above read is stable in case of a failure (unless we already have a reshuffle inside one of these transforms).", "url": "https://github.com/apache/beam/pull/13170#discussion_r528056373", "createdAt": "2020-11-21T02:27:36Z", "author": {"login": "chamikaramj"}, "path": "sdks/python/apache_beam/io/gcp/bigquery.py", "diffHunk": "@@ -1931,3 +1903,132 @@ def file_path_to_remove(unused_elm):\n                 *self._args,\n                 **self._kwargs))\n         | _PassThroughThenCleanup(files_to_remove_pcoll))\n+\n+\n+class ReadFromBigQueryRequest:\n+  \"\"\"\n+  Class that defines data to read from BQ.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      query: str = None,\n+      use_standard_sql: bool = True,\n+      table: Union[str, TableReference] = None,\n+      flatten_results: bool = False):\n+    \"\"\"\n+    Only one of query or table should be specified.\n+\n+    :param query: SQL query to fetch data.\n+    :param use_standard_sql:\n+      Specifies whether to use BigQuery's standard SQL dialect for this query.\n+      The default value is :data:`True`. If set to :data:`False`,\n+      the query will use BigQuery's legacy SQL dialect.\n+      This parameter is ignored for table inputs.\n+    :param table:\n+      The ID of the table to read. The ID must contain only letters\n+      ``a-z``, ``A-Z``, numbers ``0-9``, or underscores ``_``. Table should\n+      define project and dataset (ex.: ``'PROJECT:DATASET.TABLE'``).\n+    :param flatten_results:\n+      Flattens all nested and repeated fields in the query results.\n+      The default value is :data:`False`.\n+    \"\"\"\n+    self.flatten_results = flatten_results\n+    self.query = query\n+    self.use_standard_sql = use_standard_sql\n+    self.table = table\n+    self.validate()\n+\n+    # We use this internal object ID to generate BigQuery export directories.\n+    self.obj_id = random.randint(0, 100000)\n+\n+  def validate(self):\n+    if self.table is not None and self.query is not None:\n+      raise ValueError(\n+          'Both a BigQuery table and a query were specified.'\n+          ' Please specify only one of these.')\n+    elif self.table is None and self.query is None:\n+      raise ValueError('A BigQuery table or a query must be specified')\n+    if self.table is not None:\n+      if isinstance(self.table, str):\n+        assert self.table.find('.'), (\n+            'Expected a table reference '\n+            '(PROJECT:DATASET.TABLE or DATASET.TABLE) instead of %s'\n+            % self.table)\n+\n+\n+@experimental()\n+class ReadAllFromBigQuery(PTransform):\n+  \"\"\"Read data from BigQuery.\n+\n+    PTransform:ReadFromBigQueryRequest->Rows\n+\n+    This PTransform uses a BigQuery export job to take a snapshot of the table\n+    on GCS, and then reads from each produced file. Data is exported into\n+    a new subdirectory for each export using UUIDs generated in\n+    `ReadFromBigQueryRequest` objects.\n+\n+    It is recommended not to use this PTransform for streaming jobs on\n+    GlobalWindow, since it will not be able to cleanup snapshots.\n+\n+  Args:\n+    gcs_location (str): The name of the Google Cloud Storage\n+      bucket where the extracted table should be written as a string. If\n+      :data:`None`, then the temp_location parameter is used.\n+    validate (bool): If :data:`True`, various checks will be done when source\n+      gets initialized (e.g., is table present?).\n+    kms_key (str): Experimental. Optional Cloud KMS key name for use when\n+      creating new temporary tables.\n+   \"\"\"\n+  COUNTER = 0\n+\n+  def __init__(\n+      self,\n+      gcs_location: Union[str, ValueProvider] = None,\n+      validate: bool = False,\n+      kms_key: str = None,\n+      temp_dataset: Union[str, DatasetReference] = None,\n+      bigquery_job_labels: Dict[str, str] = None):\n+    if gcs_location:\n+      if not isinstance(gcs_location, (str, ValueProvider)):\n+        raise TypeError(\n+            '%s: gcs_location must be of type string'\n+            ' or ValueProvider; got %r instead' %\n+            (self.__class__.__name__, type(gcs_location)))\n+\n+    self.gcs_location = gcs_location\n+    self.validate = validate\n+    self.kms_key = kms_key\n+    self.bigquery_job_labels = bigquery_job_labels\n+    self.temp_dataset = temp_dataset\n+\n+  def expand(self, pcoll):\n+    job_name = pcoll.pipeline.options.view_as(GoogleCloudOptions).job_name\n+    project = pcoll.pipeline.options.view_as(GoogleCloudOptions).project\n+    unique_id = str(uuid.uuid4())[0:10]\n+\n+    try:\n+      step_name = self.label\n+    except AttributeError:\n+      step_name = 'ReadAllFromBigQuery_%d' % ReadAllFromBigQuery.COUNTER\n+      ReadAllFromBigQuery.COUNTER += 1\n+\n+    sources_to_read, cleanup_locations = (\n+        pcoll\n+        | beam.ParDo(\n+        _BigQueryReadSplit(\n+            options=pcoll.pipeline.options,\n+            gcs_location=self.gcs_location,\n+            bigquery_job_labels=self.bigquery_job_labels,\n+            job_name=job_name,\n+            step_name=step_name,\n+            unique_id=unique_id,\n+            kms_key=self.kms_key,\n+            project=project,\n+            temp_dataset=self.temp_dataset)).with_outputs(\n+        \"location_to_cleanup\", main=\"files_to_read\")\n+    )\n+\n+    return (\n+        sources_to_read\n+        | SDFBoundedSourceReader()\n+        | _PassThroughThenCleanup(beam.pvalue.AsIter(cleanup_locations)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d470c4f34e0616e548b4f0cae10054bdb314125b"}, "originalPosition": 351}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY0NTcxNg==", "bodyText": "The fusion break comes form the side input from AsIter. The files to cleaned up are passed as a side input to a downstream transform, which only executes after the previous is 'committed'", "url": "https://github.com/apache/beam/pull/13170#discussion_r532645716", "createdAt": "2020-11-30T14:41:07Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/io/gcp/bigquery.py", "diffHunk": "@@ -1931,3 +1903,132 @@ def file_path_to_remove(unused_elm):\n                 *self._args,\n                 **self._kwargs))\n         | _PassThroughThenCleanup(files_to_remove_pcoll))\n+\n+\n+class ReadFromBigQueryRequest:\n+  \"\"\"\n+  Class that defines data to read from BQ.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      query: str = None,\n+      use_standard_sql: bool = True,\n+      table: Union[str, TableReference] = None,\n+      flatten_results: bool = False):\n+    \"\"\"\n+    Only one of query or table should be specified.\n+\n+    :param query: SQL query to fetch data.\n+    :param use_standard_sql:\n+      Specifies whether to use BigQuery's standard SQL dialect for this query.\n+      The default value is :data:`True`. If set to :data:`False`,\n+      the query will use BigQuery's legacy SQL dialect.\n+      This parameter is ignored for table inputs.\n+    :param table:\n+      The ID of the table to read. The ID must contain only letters\n+      ``a-z``, ``A-Z``, numbers ``0-9``, or underscores ``_``. Table should\n+      define project and dataset (ex.: ``'PROJECT:DATASET.TABLE'``).\n+    :param flatten_results:\n+      Flattens all nested and repeated fields in the query results.\n+      The default value is :data:`False`.\n+    \"\"\"\n+    self.flatten_results = flatten_results\n+    self.query = query\n+    self.use_standard_sql = use_standard_sql\n+    self.table = table\n+    self.validate()\n+\n+    # We use this internal object ID to generate BigQuery export directories.\n+    self.obj_id = random.randint(0, 100000)\n+\n+  def validate(self):\n+    if self.table is not None and self.query is not None:\n+      raise ValueError(\n+          'Both a BigQuery table and a query were specified.'\n+          ' Please specify only one of these.')\n+    elif self.table is None and self.query is None:\n+      raise ValueError('A BigQuery table or a query must be specified')\n+    if self.table is not None:\n+      if isinstance(self.table, str):\n+        assert self.table.find('.'), (\n+            'Expected a table reference '\n+            '(PROJECT:DATASET.TABLE or DATASET.TABLE) instead of %s'\n+            % self.table)\n+\n+\n+@experimental()\n+class ReadAllFromBigQuery(PTransform):\n+  \"\"\"Read data from BigQuery.\n+\n+    PTransform:ReadFromBigQueryRequest->Rows\n+\n+    This PTransform uses a BigQuery export job to take a snapshot of the table\n+    on GCS, and then reads from each produced file. Data is exported into\n+    a new subdirectory for each export using UUIDs generated in\n+    `ReadFromBigQueryRequest` objects.\n+\n+    It is recommended not to use this PTransform for streaming jobs on\n+    GlobalWindow, since it will not be able to cleanup snapshots.\n+\n+  Args:\n+    gcs_location (str): The name of the Google Cloud Storage\n+      bucket where the extracted table should be written as a string. If\n+      :data:`None`, then the temp_location parameter is used.\n+    validate (bool): If :data:`True`, various checks will be done when source\n+      gets initialized (e.g., is table present?).\n+    kms_key (str): Experimental. Optional Cloud KMS key name for use when\n+      creating new temporary tables.\n+   \"\"\"\n+  COUNTER = 0\n+\n+  def __init__(\n+      self,\n+      gcs_location: Union[str, ValueProvider] = None,\n+      validate: bool = False,\n+      kms_key: str = None,\n+      temp_dataset: Union[str, DatasetReference] = None,\n+      bigquery_job_labels: Dict[str, str] = None):\n+    if gcs_location:\n+      if not isinstance(gcs_location, (str, ValueProvider)):\n+        raise TypeError(\n+            '%s: gcs_location must be of type string'\n+            ' or ValueProvider; got %r instead' %\n+            (self.__class__.__name__, type(gcs_location)))\n+\n+    self.gcs_location = gcs_location\n+    self.validate = validate\n+    self.kms_key = kms_key\n+    self.bigquery_job_labels = bigquery_job_labels\n+    self.temp_dataset = temp_dataset\n+\n+  def expand(self, pcoll):\n+    job_name = pcoll.pipeline.options.view_as(GoogleCloudOptions).job_name\n+    project = pcoll.pipeline.options.view_as(GoogleCloudOptions).project\n+    unique_id = str(uuid.uuid4())[0:10]\n+\n+    try:\n+      step_name = self.label\n+    except AttributeError:\n+      step_name = 'ReadAllFromBigQuery_%d' % ReadAllFromBigQuery.COUNTER\n+      ReadAllFromBigQuery.COUNTER += 1\n+\n+    sources_to_read, cleanup_locations = (\n+        pcoll\n+        | beam.ParDo(\n+        _BigQueryReadSplit(\n+            options=pcoll.pipeline.options,\n+            gcs_location=self.gcs_location,\n+            bigquery_job_labels=self.bigquery_job_labels,\n+            job_name=job_name,\n+            step_name=step_name,\n+            unique_id=unique_id,\n+            kms_key=self.kms_key,\n+            project=project,\n+            temp_dataset=self.temp_dataset)).with_outputs(\n+        \"location_to_cleanup\", main=\"files_to_read\")\n+    )\n+\n+    return (\n+        sources_to_read\n+        | SDFBoundedSourceReader()\n+        | _PassThroughThenCleanup(beam.pvalue.AsIter(cleanup_locations)))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA1NjM3Mw=="}, "originalCommit": {"oid": "d470c4f34e0616e548b4f0cae10054bdb314125b"}, "originalPosition": 351}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2832, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}