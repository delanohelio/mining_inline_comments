{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1Mjg3NTMw", "number": 11448, "title": "[BEAM-3836] Enable dynamic splitting/checkpointing within the Java SDK harness.", "bodyText": "Thank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nApex\nDataflow\nFlink\nGearpump\nSamza\nSpark\n\n\n\n\nGo\n\n---\n---\n\n---\n---\n\n\n\nJava\n\n\n\n\n\n\n\n\n\nPython\n\n---\n\n\n---\n---\n\n\n\nXLang\n---\n---\n---\n\n---\n---\n\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-04-17T18:50:33Z", "url": "https://github.com/apache/beam/pull/11448", "merged": true, "mergeCommit": {"oid": "12c66a0a4c5e370d912452a5a0dcf349654949b5"}, "closed": true, "closedAt": "2020-04-18T03:05:46Z", "author": {"login": "lukecwik"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcYl5T2gH2gAyNDA1Mjg3NTMwOmVmNTFhNjM2NzhmNzNmZmFhNDE5YjhkNzExMTU2ZTg2M2RlZjY5ZDI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcYsb63gFqTM5NTg3MjgyMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ef51a63678f73ffaa419b8d711156e863def69d2", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/ef51a63678f73ffaa419b8d711156e863def69d2", "committedDate": "2020-04-17T18:49:21Z", "message": "[BEAM-3836] Enable dynamic splitting/checkpointing within the Java SDK harness."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e65952a39b037eeef5dc16b82010483e3fa1e5f", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/7e65952a39b037eeef5dc16b82010483e3fa1e5f", "committedDate": "2020-04-17T19:54:10Z", "message": "fixup! Spotless"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODQ2MjU2", "url": "https://github.com/apache/beam/pull/11448#pullrequestreview-395846256", "createdAt": "2020-04-18T00:59:11Z", "commit": {"oid": "7e65952a39b037eeef5dc16b82010483e3fa1e5f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDo1OToxMlrOGHgsLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMToyNDo0MFrOGHhJ6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyODgxMg==", "bodyText": "Can we force a split at element by only feeding in WAIT_TILL_SPLIT ?", "url": "https://github.com/apache/beam/pull/11448#discussion_r410528812", "createdAt": "2020-04-18T00:59:12Z", "author": {"login": "boyuanzz"}, "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/RemoteExecutionTest.java", "diffHunk": "@@ -1246,16 +1249,230 @@ public void process(ProcessContext c) {\n               StateRequestHandler.unsupported(),\n               BundleProgressHandler.ignored())) {\n         Iterables.getOnlyElement(bundle.getInputReceivers().values())\n-            .accept(\n-                WindowedValue.valueInGlobalWindow(\n-                    CoderUtils.encodeToByteArray(StringUtf8Coder.of(), \"X\")));\n+            .accept(valueInGlobalWindow(CoderUtils.encodeToByteArray(StringUtf8Coder.of(), \"X\")));\n       }\n     }\n     assertThat(\n         outputValues,\n         containsInAnyOrder(\n-            WindowedValue.valueInGlobalWindow(KV.of(\"stream1X\", \"\")),\n-            WindowedValue.valueInGlobalWindow(KV.of(\"stream2X\", \"\"))));\n+            valueInGlobalWindow(KV.of(\"stream1X\", \"\")),\n+            valueInGlobalWindow(KV.of(\"stream2X\", \"\"))));\n+  }\n+\n+  /**\n+   * A restriction tracker that will block making progress on {@link #WAIT_TILL_SPLIT} until a try\n+   * split is invoked.\n+   */\n+  private static class WaitingTillSplitRestrictionTracker extends RestrictionTracker<String, Void> {\n+    private static final String WAIT_TILL_SPLIT = \"WaitTillSplit\";\n+    private static final String PRIMARY = \"Primary\";\n+    private static final String RESIDUAL = \"Residual\";\n+\n+    private String currentRestriction;\n+\n+    private WaitingTillSplitRestrictionTracker(String restriction) {\n+      this.currentRestriction = restriction;\n+    }\n+\n+    @Override\n+    public boolean tryClaim(Void position) {\n+      return needsSplitting();\n+    }\n+\n+    @Override\n+    public String currentRestriction() {\n+      return currentRestriction;\n+    }\n+\n+    @Override\n+    public SplitResult<String> trySplit(double fractionOfRemainder) {\n+      if (!needsSplitting()) {\n+        return null;\n+      }\n+      this.currentRestriction = PRIMARY;\n+      return SplitResult.of(currentRestriction, RESIDUAL);\n+    }\n+\n+    private boolean needsSplitting() {\n+      return WAIT_TILL_SPLIT.equals(currentRestriction);\n+    }\n+\n+    @Override\n+    public void checkDone() throws IllegalStateException {\n+      checkState(!needsSplitting(), \"Expected for this restriction to have been split.\");\n+    }\n+  }\n+\n+  @Test(timeout = 60000L)\n+  public void testSplit() throws Exception {\n+    Pipeline p = Pipeline.create();\n+    p.apply(\"impulse\", Impulse.create())\n+        .apply(\n+            \"create\",\n+            ParDo.of(\n+                new DoFn<byte[], String>() {\n+                  @ProcessElement\n+                  public void process(ProcessContext ctxt) {\n+                    ctxt.output(\"zero\");\n+                    ctxt.output(WaitingTillSplitRestrictionTracker.WAIT_TILL_SPLIT);\n+                    ctxt.output(\"two\");\n+                  }\n+                }))\n+        .apply(\n+            \"forceSplit\",\n+            ParDo.of(\n+                new DoFn<String, String>() {\n+                  @GetInitialRestriction\n+                  public String getInitialRestriction(@Element String element) {\n+                    return element;\n+                  }\n+\n+                  @NewTracker\n+                  public WaitingTillSplitRestrictionTracker newTracker(\n+                      @Restriction String restriction) {\n+                    return new WaitingTillSplitRestrictionTracker(restriction);\n+                  }\n+\n+                  @ProcessElement\n+                  public void process(\n+                      RestrictionTracker<String, Void> tracker, ProcessContext context) {\n+                    while (tracker.tryClaim(null)) {}\n+                    context.output(tracker.currentRestriction());\n+                  }\n+                }))\n+        .apply(\"addKeys\", WithKeys.of(\"foo\"))\n+        // Use some unknown coders\n+        .setCoder(KvCoder.of(StringUtf8Coder.of(), StringUtf8Coder.of()))\n+        // Force the output to be materialized\n+        .apply(\"gbk\", GroupByKey.create());\n+\n+    RunnerApi.Pipeline pipeline = PipelineTranslation.toProto(p);\n+    // Expand any splittable DoFns within the graph to enable sizing and splitting of bundles.\n+    RunnerApi.Pipeline pipelineWithSdfExpanded =\n+        ProtoOverrides.updateTransform(\n+            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+            pipeline,\n+            SplittableParDoExpander.createSizedReplacement());\n+    FusedPipeline fused = GreedyPipelineFuser.fuse(pipelineWithSdfExpanded);\n+\n+    // Find the fused stage with the SDF ProcessSizedElementAndRestriction transform\n+    Optional<ExecutableStage> optionalStage =\n+        Iterables.tryFind(\n+            fused.getFusedStages(),\n+            (ExecutableStage stage) ->\n+                Iterables.filter(\n+                        stage.getTransforms(),\n+                        (PTransformNode node) ->\n+                            PTransformTranslation\n+                                .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN\n+                                .equals(node.getTransform().getSpec().getUrn()))\n+                    .iterator()\n+                    .hasNext());\n+    checkState(\n+        optionalStage.isPresent(), \"Expected a stage with SDF ProcessSizedElementAndRestriction.\");\n+    ExecutableStage stage = optionalStage.get();\n+\n+    ExecutableProcessBundleDescriptor descriptor =\n+        ProcessBundleDescriptors.fromExecutableStage(\n+            \"my_stage\", stage, dataServer.getApiServiceDescriptor());\n+\n+    BundleProcessor processor =\n+        controlClient.getProcessor(\n+            descriptor.getProcessBundleDescriptor(), descriptor.getRemoteInputDestinations());\n+    Map<String, ? super Coder<WindowedValue<?>>> remoteOutputCoders =\n+        descriptor.getRemoteOutputCoders();\n+    Map<String, Collection<? super WindowedValue<?>>> outputValues = new HashMap<>();\n+    Map<String, RemoteOutputReceiver<?>> outputReceivers = new HashMap<>();\n+    for (Entry<String, ? super Coder<WindowedValue<?>>> remoteOutputCoder :\n+        remoteOutputCoders.entrySet()) {\n+      List<? super WindowedValue<?>> outputContents =\n+          Collections.synchronizedList(new ArrayList<>());\n+      outputValues.put(remoteOutputCoder.getKey(), outputContents);\n+      outputReceivers.put(\n+          remoteOutputCoder.getKey(),\n+          RemoteOutputReceiver.of(\n+              (Coder) remoteOutputCoder.getValue(),\n+              (FnDataReceiver<? super WindowedValue<?>>) outputContents::add));\n+    }\n+\n+    List<ProcessBundleSplitResponse> splitResponses = new ArrayList<>();\n+    List<ProcessBundleResponse> checkpointResponses = new ArrayList<>();\n+    List<String> requestsFinalization = new ArrayList<>();\n+\n+    ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n+    ScheduledFuture<Object> future;\n+\n+    // Execute the remote bundle.\n+    try (RemoteBundle bundle =\n+        processor.newBundle(\n+            outputReceivers,\n+            Collections.emptyMap(),\n+            StateRequestHandler.unsupported(),\n+            BundleProgressHandler.ignored(),\n+            splitResponses::add,\n+            checkpointResponses::add,\n+            requestsFinalization::add)) {\n+      Iterables.getOnlyElement(bundle.getInputReceivers().values())\n+          .accept(valueInGlobalWindow(sdfSizedElementAndRestrictionForTest(\"zero\")));\n+      Iterables.getOnlyElement(bundle.getInputReceivers().values())\n+          .accept(\n+              valueInGlobalWindow(\n+                  sdfSizedElementAndRestrictionForTest(\n+                      WaitingTillSplitRestrictionTracker.WAIT_TILL_SPLIT)));\n+      Iterables.getOnlyElement(bundle.getInputReceivers().values())\n+          .accept(valueInGlobalWindow(sdfSizedElementAndRestrictionForTest(\"two\")));\n+      // Keep sending splits until the bundle terminates, we specifically use 0.5 so that we will\n+      // choose a split point before the end of WAIT_TILL_SPLIT regardless of where we are during\n+      // processing.\n+      future =\n+          (ScheduledFuture)\n+              executor.scheduleWithFixedDelay(\n+                  () -> bundle.split(0.5), 0L, 100L, TimeUnit.MILLISECONDS);\n+    }\n+    future.cancel(false);\n+    executor.shutdown();\n+\n+    assertTrue(requestsFinalization.isEmpty());\n+    assertTrue(checkpointResponses.isEmpty());\n+\n+    List<WindowedValue<KV<String, String>>> expectedOutputs = new ArrayList<>();\n+\n+    // We only validate the last split response since it is the only one that could possibly\n+    // contain the SDF split, all others will be a reduction in the ChannelSplit\n+    assertFalse(splitResponses.isEmpty());\n+    ProcessBundleSplitResponse splitResponse = splitResponses.get(splitResponses.size() - 1);\n+    ChannelSplit channelSplit = Iterables.getOnlyElement(splitResponse.getChannelSplitsList());\n+\n+    // There are only a few outcomes that could happen with splitting due to timing:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e65952a39b037eeef5dc16b82010483e3fa1e5f"}, "originalPosition": 399}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUzNjQyNA==", "bodyText": "Is it intended that all roots process the same split request?", "url": "https://github.com/apache/beam/pull/11448#discussion_r410536424", "createdAt": "2020-04-18T01:24:40Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/control/ProcessBundleHandler.java", "diffHunk": "@@ -340,7 +347,12 @@ private void createRunnerAndConsumersForPTransformRecursively(\n               \"Unable to find active bundle for instruction id %s.\",\n               request.getProcessBundleSplit().getInstructionId()));\n     }\n-    throw new UnsupportedOperationException(\"TODO: BEAM-3836, support splitting within SDK.\");\n+    BeamFnApi.ProcessBundleSplitResponse.Builder response =\n+        BeamFnApi.ProcessBundleSplitResponse.newBuilder();\n+    for (BeamFnDataReadRunner channelRoot : bundleProcessor.getChannelRoots()) {\n+      channelRoot.trySplit(request.getProcessBundleSplit(), response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e65952a39b037eeef5dc16b82010483e3fa1e5f"}, "originalPosition": 94}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f2542e4993cc738f762311e5c995f1123b3718e", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/6f2542e4993cc738f762311e5c995f1123b3718e", "committedDate": "2020-04-18T02:11:26Z", "message": "fixup! Address PR comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODcyODIx", "url": "https://github.com/apache/beam/pull/11448#pullrequestreview-395872821", "createdAt": "2020-04-18T02:26:35Z", "commit": {"oid": "6f2542e4993cc738f762311e5c995f1123b3718e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4277, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}