{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNjk2MTg0", "number": 13120, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMDoyNDoxMVrOEua_Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0NzoxN1rOEwWDQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MTEyMTMwOnYy", "diffSide": "RIGHT", "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptors.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMDoyNDoxMVrOHiz-lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNDowNzoxNFrOHk-vJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI2NTIzNg==", "bodyText": "Worth mentioning this will break any existing non-stateful pipelines. We could add another exception here for SDFs, but it's probably better to have a consistent encoding which does not depend on DoFns using state or timers.", "url": "https://github.com/apache/beam/pull/13120#discussion_r506265236", "createdAt": "2020-10-16T10:24:11Z", "author": {"login": "mxm"}, "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptors.java", "diffHunk": "@@ -141,9 +139,7 @@ private static ExecutableProcessBundleDescriptor fromExecutableStageInternal(\n \n     Map<String, Map<String, TimerSpec>> timerSpecs = forTimerSpecs(stage, components);\n \n-    if (bagUserStateSpecs.size() > 0 || timerSpecs.size() > 0) {\n-      lengthPrefixKeyCoder(stage.getInputPCollection().getId(), components);\n-    }\n+    lengthPrefixAnyInputCoder(stage.getInputPCollection().getId(), components);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d78347c63196c69d27a3af05b9cbb9a7f84a6d09"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYzMzUwMA==", "bodyText": "I would not expect it will break non-stateful pipelines since non-stateful transform doesn't look into this coder?", "url": "https://github.com/apache/beam/pull/13120#discussion_r506633500", "createdAt": "2020-10-16T17:50:37Z", "author": {"login": "boyuanzz"}, "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptors.java", "diffHunk": "@@ -141,9 +139,7 @@ private static ExecutableProcessBundleDescriptor fromExecutableStageInternal(\n \n     Map<String, Map<String, TimerSpec>> timerSpecs = forTimerSpecs(stage, components);\n \n-    if (bagUserStateSpecs.size() > 0 || timerSpecs.size() > 0) {\n-      lengthPrefixKeyCoder(stage.getInputPCollection().getId(), components);\n-    }\n+    lengthPrefixAnyInputCoder(stage.getInputPCollection().getId(), components);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI2NTIzNg=="}, "originalCommit": {"oid": "d78347c63196c69d27a3af05b9cbb9a7f84a6d09"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzgyNjcwMQ==", "bodyText": "It does, e.g. for buffering data during checkpoints. However, there are usually also other changes in Beam which makes restoring state from previous Beam versions hard.", "url": "https://github.com/apache/beam/pull/13120#discussion_r507826701", "createdAt": "2020-10-19T15:03:27Z", "author": {"login": "mxm"}, "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptors.java", "diffHunk": "@@ -141,9 +139,7 @@ private static ExecutableProcessBundleDescriptor fromExecutableStageInternal(\n \n     Map<String, Map<String, TimerSpec>> timerSpecs = forTimerSpecs(stage, components);\n \n-    if (bagUserStateSpecs.size() > 0 || timerSpecs.size() > 0) {\n-      lengthPrefixKeyCoder(stage.getInputPCollection().getId(), components);\n-    }\n+    lengthPrefixAnyInputCoder(stage.getInputPCollection().getId(), components);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI2NTIzNg=="}, "originalCommit": {"oid": "d78347c63196c69d27a3af05b9cbb9a7f84a6d09"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkxOTY1MQ==", "bodyText": "In that case, I would image that the buffering data should be encoded/decoded with grpc input coder, which has been lengthperfixed already. Would you like to elaborate more on this?", "url": "https://github.com/apache/beam/pull/13120#discussion_r507919651", "createdAt": "2020-10-19T17:16:29Z", "author": {"login": "boyuanzz"}, "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptors.java", "diffHunk": "@@ -141,9 +139,7 @@ private static ExecutableProcessBundleDescriptor fromExecutableStageInternal(\n \n     Map<String, Map<String, TimerSpec>> timerSpecs = forTimerSpecs(stage, components);\n \n-    if (bagUserStateSpecs.size() > 0 || timerSpecs.size() > 0) {\n-      lengthPrefixKeyCoder(stage.getInputPCollection().getId(), components);\n-    }\n+    lengthPrefixAnyInputCoder(stage.getInputPCollection().getId(), components);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI2NTIzNg=="}, "originalCommit": {"oid": "d78347c63196c69d27a3af05b9cbb9a7f84a6d09"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkyODExNQ==", "bodyText": "Or do we have some test cases that we can verify?", "url": "https://github.com/apache/beam/pull/13120#discussion_r507928115", "createdAt": "2020-10-19T17:30:26Z", "author": {"login": "boyuanzz"}, "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptors.java", "diffHunk": "@@ -141,9 +139,7 @@ private static ExecutableProcessBundleDescriptor fromExecutableStageInternal(\n \n     Map<String, Map<String, TimerSpec>> timerSpecs = forTimerSpecs(stage, components);\n \n-    if (bagUserStateSpecs.size() > 0 || timerSpecs.size() > 0) {\n-      lengthPrefixKeyCoder(stage.getInputPCollection().getId(), components);\n-    }\n+    lengthPrefixAnyInputCoder(stage.getInputPCollection().getId(), components);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI2NTIzNg=="}, "originalCommit": {"oid": "d78347c63196c69d27a3af05b9cbb9a7f84a6d09"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODUzODY2Mw==", "bodyText": "My bad, the length prefixing here only applies to the coder in the ProcessBundleDescriptor. Indeed, any buffering won't be affected by this because the elements have already been decoded when they are buffered.\nFor the test case, FlinkSavepointITCase should verify that.", "url": "https://github.com/apache/beam/pull/13120#discussion_r508538663", "createdAt": "2020-10-20T14:07:14Z", "author": {"login": "mxm"}, "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptors.java", "diffHunk": "@@ -141,9 +139,7 @@ private static ExecutableProcessBundleDescriptor fromExecutableStageInternal(\n \n     Map<String, Map<String, TimerSpec>> timerSpecs = forTimerSpecs(stage, components);\n \n-    if (bagUserStateSpecs.size() > 0 || timerSpecs.size() > 0) {\n-      lengthPrefixKeyCoder(stage.getInputPCollection().getId(), components);\n-    }\n+    lengthPrefixAnyInputCoder(stage.getInputPCollection().getId(), components);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI2NTIzNg=="}, "originalCommit": {"oid": "d78347c63196c69d27a3af05b9cbb9a7f84a6d09"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NTY1MTI2OnYy", "diffSide": "RIGHT", "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptors.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNDoyNDoyMVrOHk_qtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0Mzo0OVrOHl1wrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU1MzkxMA==", "bodyText": "I'm wondering, why is length-prefixing the key coder not necessary anymore? Wouldn't the SDK Harness be able to extract a non-length-prefixed key coder even though the input coder has been legth-prefixed? This would then cause a regression like in #9997 if the SDK Harness didn't use the NESTED contex, which it currently does because we had fix this a while ago: \n  \n    \n      beam/sdks/python/apache_beam/runners/worker/bundle_processor.py\n    \n    \n         Line 769\n      in\n      57d2497\n    \n    \n    \n    \n\n        \n          \n           key=self._key_coder.encode_nested(key))), \n        \n    \n  \n\n The idea was to always ensure keys are length-prefixed, so we never run into inconsistent key encodings between the Runner and the SDK Harness.", "url": "https://github.com/apache/beam/pull/13120#discussion_r508553910", "createdAt": "2020-10-20T14:24:21Z", "author": {"login": "mxm"}, "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptors.java", "diffHunk": "@@ -174,26 +170,18 @@ private static ExecutableProcessBundleDescriptor fromExecutableStageInternal(\n   }\n \n   /**\n-   * Patches the input coder of a stateful transform to ensure that the byte representation of a key\n-   * used to partition the input element at the Runner, matches the key byte representation received\n-   * for state requests and timers from the SDK Harness. Stateful transforms always have a KvCoder\n-   * as input.\n+   * Patches the input coder of the transform to ensure that the byte representation of input used\n+   * at the Runner, matches the byte representation received from the SDK Harness.\n    */\n-  private static void lengthPrefixKeyCoder(\n-      String inputColId, Components.Builder componentsBuilder) {\n-    RunnerApi.PCollection pcollection = componentsBuilder.getPcollectionsOrThrow(inputColId);\n-    RunnerApi.Coder kvCoder = componentsBuilder.getCodersOrThrow(pcollection.getCoderId());\n-    Preconditions.checkState(\n-        ModelCoders.KV_CODER_URN.equals(kvCoder.getSpec().getUrn()),\n-        \"Stateful executable stages must use a KV coder, but is: %s\",\n-        kvCoder.getSpec().getUrn());\n-    String keyCoderId = ModelCoders.getKvCoderComponents(kvCoder).keyCoderId();\n-    // Retain the original coder, but wrap in LengthPrefixCoder\n-    String newKeyCoderId =\n-        LengthPrefixUnknownCoders.addLengthPrefixedCoder(keyCoderId, componentsBuilder, false);\n-    // Replace old key coder with LengthPrefixCoder<old_key_coder>\n-    kvCoder = kvCoder.toBuilder().setComponentCoderIds(0, newKeyCoderId).build();\n-    componentsBuilder.putCoders(pcollection.getCoderId(), kvCoder);\n+  private static void lengthPrefixAnyInputCoder(\n+      String inputPCollectionId, Components.Builder componentsBuilder) {\n+    RunnerApi.PCollection pcollection =\n+        componentsBuilder.getPcollectionsOrThrow(inputPCollectionId);\n+    String newInputCoderId =\n+        LengthPrefixUnknownCoders.addLengthPrefixedCoder(\n+            pcollection.getCoderId(), componentsBuilder, false);\n+    componentsBuilder.putPcollections(\n+        inputPCollectionId, pcollection.toBuilder().setCoderId(newInputCoderId).build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d78347c63196c69d27a3af05b9cbb9a7f84a6d09"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU2MDgwNQ==", "bodyText": "I guess this will still work because if we have a KV Coder we will always end up length-prefixing the key because the KV coder is a known coder and it will recurse into the key afterwards.", "url": "https://github.com/apache/beam/pull/13120#discussion_r508560805", "createdAt": "2020-10-20T14:32:24Z", "author": {"login": "mxm"}, "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptors.java", "diffHunk": "@@ -174,26 +170,18 @@ private static ExecutableProcessBundleDescriptor fromExecutableStageInternal(\n   }\n \n   /**\n-   * Patches the input coder of a stateful transform to ensure that the byte representation of a key\n-   * used to partition the input element at the Runner, matches the key byte representation received\n-   * for state requests and timers from the SDK Harness. Stateful transforms always have a KvCoder\n-   * as input.\n+   * Patches the input coder of the transform to ensure that the byte representation of input used\n+   * at the Runner, matches the byte representation received from the SDK Harness.\n    */\n-  private static void lengthPrefixKeyCoder(\n-      String inputColId, Components.Builder componentsBuilder) {\n-    RunnerApi.PCollection pcollection = componentsBuilder.getPcollectionsOrThrow(inputColId);\n-    RunnerApi.Coder kvCoder = componentsBuilder.getCodersOrThrow(pcollection.getCoderId());\n-    Preconditions.checkState(\n-        ModelCoders.KV_CODER_URN.equals(kvCoder.getSpec().getUrn()),\n-        \"Stateful executable stages must use a KV coder, but is: %s\",\n-        kvCoder.getSpec().getUrn());\n-    String keyCoderId = ModelCoders.getKvCoderComponents(kvCoder).keyCoderId();\n-    // Retain the original coder, but wrap in LengthPrefixCoder\n-    String newKeyCoderId =\n-        LengthPrefixUnknownCoders.addLengthPrefixedCoder(keyCoderId, componentsBuilder, false);\n-    // Replace old key coder with LengthPrefixCoder<old_key_coder>\n-    kvCoder = kvCoder.toBuilder().setComponentCoderIds(0, newKeyCoderId).build();\n-    componentsBuilder.putCoders(pcollection.getCoderId(), kvCoder);\n+  private static void lengthPrefixAnyInputCoder(\n+      String inputPCollectionId, Components.Builder componentsBuilder) {\n+    RunnerApi.PCollection pcollection =\n+        componentsBuilder.getPcollectionsOrThrow(inputPCollectionId);\n+    String newInputCoderId =\n+        LengthPrefixUnknownCoders.addLengthPrefixedCoder(\n+            pcollection.getCoderId(), componentsBuilder, false);\n+    componentsBuilder.putPcollections(\n+        inputPCollectionId, pcollection.toBuilder().setCoderId(newInputCoderId).build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU1MzkxMA=="}, "originalCommit": {"oid": "d78347c63196c69d27a3af05b9cbb9a7f84a6d09"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0MDE3NQ==", "bodyText": "Yeah that's right. This logic is also verified by the unit test.", "url": "https://github.com/apache/beam/pull/13120#discussion_r509440175", "createdAt": "2020-10-21T16:43:49Z", "author": {"login": "boyuanzz"}, "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptors.java", "diffHunk": "@@ -174,26 +170,18 @@ private static ExecutableProcessBundleDescriptor fromExecutableStageInternal(\n   }\n \n   /**\n-   * Patches the input coder of a stateful transform to ensure that the byte representation of a key\n-   * used to partition the input element at the Runner, matches the key byte representation received\n-   * for state requests and timers from the SDK Harness. Stateful transforms always have a KvCoder\n-   * as input.\n+   * Patches the input coder of the transform to ensure that the byte representation of input used\n+   * at the Runner, matches the byte representation received from the SDK Harness.\n    */\n-  private static void lengthPrefixKeyCoder(\n-      String inputColId, Components.Builder componentsBuilder) {\n-    RunnerApi.PCollection pcollection = componentsBuilder.getPcollectionsOrThrow(inputColId);\n-    RunnerApi.Coder kvCoder = componentsBuilder.getCodersOrThrow(pcollection.getCoderId());\n-    Preconditions.checkState(\n-        ModelCoders.KV_CODER_URN.equals(kvCoder.getSpec().getUrn()),\n-        \"Stateful executable stages must use a KV coder, but is: %s\",\n-        kvCoder.getSpec().getUrn());\n-    String keyCoderId = ModelCoders.getKvCoderComponents(kvCoder).keyCoderId();\n-    // Retain the original coder, but wrap in LengthPrefixCoder\n-    String newKeyCoderId =\n-        LengthPrefixUnknownCoders.addLengthPrefixedCoder(keyCoderId, componentsBuilder, false);\n-    // Replace old key coder with LengthPrefixCoder<old_key_coder>\n-    kvCoder = kvCoder.toBuilder().setComponentCoderIds(0, newKeyCoderId).build();\n-    componentsBuilder.putCoders(pcollection.getCoderId(), kvCoder);\n+  private static void lengthPrefixAnyInputCoder(\n+      String inputPCollectionId, Components.Builder componentsBuilder) {\n+    RunnerApi.PCollection pcollection =\n+        componentsBuilder.getPcollectionsOrThrow(inputPCollectionId);\n+    String newInputCoderId =\n+        LengthPrefixUnknownCoders.addLengthPrefixedCoder(\n+            pcollection.getCoderId(), componentsBuilder, false);\n+    componentsBuilder.putPcollections(\n+        inputPCollectionId, pcollection.toBuilder().setCoderId(newInputCoderId).build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU1MzkxMA=="}, "originalCommit": {"oid": "d78347c63196c69d27a3af05b9cbb9a7f84a6d09"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTI3OTcwOnYy", "diffSide": "RIGHT", "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptorsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0NjoxM1rOHl13iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0NjoxM1rOHl13iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0MTkyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                RunnerApi.Coder elementCoder =\n          \n          \n            \n                RunnerApi.Coder keyCoder =", "url": "https://github.com/apache/beam/pull/13120#discussion_r509441928", "createdAt": "2020-10-21T16:46:13Z", "author": {"login": "mxm"}, "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptorsTest.java", "diffHunk": "@@ -151,6 +157,99 @@ public void onTimer() {}\n     ensureLengthPrefixed(timerKeyCoder, originalKeyCoder, pbsCoderMap);\n   }\n \n+  @Test\n+  public void testLengthPrefixingOfInputCoderExecutableStage() throws Exception {\n+    Pipeline p = Pipeline.create();\n+    Coder<Void> voidCoder = VoidCoder.of();\n+    assertThat(ModelCoderRegistrar.isKnownCoder(voidCoder), is(false));\n+    p.apply(\"impulse\", Impulse.create())\n+        .apply(\n+            ParDo.of(\n+                new DoFn<byte[], Void>() {\n+                  @ProcessElement\n+                  public void process(ProcessContext ctxt) {}\n+                }))\n+        .setCoder(voidCoder)\n+        .apply(\n+            ParDo.of(\n+                new DoFn<Void, Void>() {\n+                  @ProcessElement\n+                  public void processElement(\n+                      ProcessContext context, RestrictionTracker<Void, Void> tracker) {}\n+\n+                  @GetInitialRestriction\n+                  public Void getInitialRestriction() {\n+                    return null;\n+                  }\n+\n+                  @NewTracker\n+                  public SomeTracker newTracker(@Restriction Void restriction) {\n+                    return null;\n+                  }\n+                }))\n+        .setCoder(voidCoder);\n+    RunnerApi.Pipeline pipelineProto = PipelineTranslation.toProto(p);\n+    RunnerApi.Pipeline pipelineWithSdfExpanded =\n+        ProtoOverrides.updateTransform(\n+            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+            pipelineProto,\n+            SplittableParDoExpander.createSizedReplacement());\n+    FusedPipeline fused = GreedyPipelineFuser.fuse(pipelineWithSdfExpanded);\n+    Optional<ExecutableStage> optionalStage =\n+        Iterables.tryFind(\n+            fused.getFusedStages(),\n+            (ExecutableStage stage) ->\n+                stage.getTransforms().stream()\n+                    .anyMatch(\n+                        transform ->\n+                            transform\n+                                .getTransform()\n+                                .getSpec()\n+                                .getUrn()\n+                                .equals(\n+                                    PTransformTranslation\n+                                        .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)));\n+    checkState(\n+        optionalStage.isPresent(),\n+        \"Expected a stage with SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN.\");\n+\n+    ExecutableStage stage = optionalStage.get();\n+    PipelineNode.PCollectionNode inputPCollection = stage.getInputPCollection();\n+    Map<String, RunnerApi.Coder> stageCoderMap = stage.getComponents().getCodersMap();\n+    RunnerApi.Coder originalMainInputCoder =\n+        stageCoderMap.get(inputPCollection.getPCollection().getCoderId());\n+\n+    BeamFnApi.ProcessBundleDescriptor pbd =\n+        ProcessBundleDescriptors.fromExecutableStage(\n+                \"test_stage\", stage, Endpoints.ApiServiceDescriptor.getDefaultInstance())\n+            .getProcessBundleDescriptor();\n+    Map<String, RunnerApi.Coder> pbsCoderMap = pbd.getCodersMap();\n+\n+    RunnerApi.Coder pbsMainInputCoder =\n+        pbsCoderMap.get(pbd.getPcollectionsOrThrow(inputPCollection.getId()).getCoderId());\n+\n+    RunnerApi.Coder kvCoder =\n+        pbsCoderMap.get(ModelCoders.getKvCoderComponents(pbsMainInputCoder).keyCoderId());\n+    RunnerApi.Coder elementCoder =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d78347c63196c69d27a3af05b9cbb9a7f84a6d09"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTI4MTQ1OnYy", "diffSide": "RIGHT", "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptorsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0Njo0NVrOHl14vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0Njo0NVrOHl14vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0MjIzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                RunnerApi.Coder originalElementCoder =\n          \n          \n            \n                RunnerApi.Coder originalKeyCoder =", "url": "https://github.com/apache/beam/pull/13120#discussion_r509442238", "createdAt": "2020-10-21T16:46:45Z", "author": {"login": "mxm"}, "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptorsTest.java", "diffHunk": "@@ -151,6 +157,99 @@ public void onTimer() {}\n     ensureLengthPrefixed(timerKeyCoder, originalKeyCoder, pbsCoderMap);\n   }\n \n+  @Test\n+  public void testLengthPrefixingOfInputCoderExecutableStage() throws Exception {\n+    Pipeline p = Pipeline.create();\n+    Coder<Void> voidCoder = VoidCoder.of();\n+    assertThat(ModelCoderRegistrar.isKnownCoder(voidCoder), is(false));\n+    p.apply(\"impulse\", Impulse.create())\n+        .apply(\n+            ParDo.of(\n+                new DoFn<byte[], Void>() {\n+                  @ProcessElement\n+                  public void process(ProcessContext ctxt) {}\n+                }))\n+        .setCoder(voidCoder)\n+        .apply(\n+            ParDo.of(\n+                new DoFn<Void, Void>() {\n+                  @ProcessElement\n+                  public void processElement(\n+                      ProcessContext context, RestrictionTracker<Void, Void> tracker) {}\n+\n+                  @GetInitialRestriction\n+                  public Void getInitialRestriction() {\n+                    return null;\n+                  }\n+\n+                  @NewTracker\n+                  public SomeTracker newTracker(@Restriction Void restriction) {\n+                    return null;\n+                  }\n+                }))\n+        .setCoder(voidCoder);\n+    RunnerApi.Pipeline pipelineProto = PipelineTranslation.toProto(p);\n+    RunnerApi.Pipeline pipelineWithSdfExpanded =\n+        ProtoOverrides.updateTransform(\n+            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+            pipelineProto,\n+            SplittableParDoExpander.createSizedReplacement());\n+    FusedPipeline fused = GreedyPipelineFuser.fuse(pipelineWithSdfExpanded);\n+    Optional<ExecutableStage> optionalStage =\n+        Iterables.tryFind(\n+            fused.getFusedStages(),\n+            (ExecutableStage stage) ->\n+                stage.getTransforms().stream()\n+                    .anyMatch(\n+                        transform ->\n+                            transform\n+                                .getTransform()\n+                                .getSpec()\n+                                .getUrn()\n+                                .equals(\n+                                    PTransformTranslation\n+                                        .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)));\n+    checkState(\n+        optionalStage.isPresent(),\n+        \"Expected a stage with SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN.\");\n+\n+    ExecutableStage stage = optionalStage.get();\n+    PipelineNode.PCollectionNode inputPCollection = stage.getInputPCollection();\n+    Map<String, RunnerApi.Coder> stageCoderMap = stage.getComponents().getCodersMap();\n+    RunnerApi.Coder originalMainInputCoder =\n+        stageCoderMap.get(inputPCollection.getPCollection().getCoderId());\n+\n+    BeamFnApi.ProcessBundleDescriptor pbd =\n+        ProcessBundleDescriptors.fromExecutableStage(\n+                \"test_stage\", stage, Endpoints.ApiServiceDescriptor.getDefaultInstance())\n+            .getProcessBundleDescriptor();\n+    Map<String, RunnerApi.Coder> pbsCoderMap = pbd.getCodersMap();\n+\n+    RunnerApi.Coder pbsMainInputCoder =\n+        pbsCoderMap.get(pbd.getPcollectionsOrThrow(inputPCollection.getId()).getCoderId());\n+\n+    RunnerApi.Coder kvCoder =\n+        pbsCoderMap.get(ModelCoders.getKvCoderComponents(pbsMainInputCoder).keyCoderId());\n+    RunnerApi.Coder elementCoder =\n+        pbsCoderMap.get(ModelCoders.getKvCoderComponents(kvCoder).keyCoderId());\n+    RunnerApi.Coder valueKvCoder =\n+        pbsCoderMap.get(ModelCoders.getKvCoderComponents(kvCoder).valueCoderId());\n+    RunnerApi.Coder valueCoder =\n+        pbsCoderMap.get(ModelCoders.getKvCoderComponents(valueKvCoder).keyCoderId());\n+\n+    RunnerApi.Coder originalKvCoder =\n+        stageCoderMap.get(ModelCoders.getKvCoderComponents(originalMainInputCoder).keyCoderId());\n+    RunnerApi.Coder originalElementCoder =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d78347c63196c69d27a3af05b9cbb9a7f84a6d09"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTI4Mzg2OnYy", "diffSide": "RIGHT", "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptorsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0NzoxN1rOHl16MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0NzoxN1rOHl16MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0MjYwOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ensureLengthPrefixed(elementCoder, originalElementCoder, pbsCoderMap);\n          \n          \n            \n                ensureLengthPrefixed(keyCoder, originalKeyCoder, pbsCoderMap);", "url": "https://github.com/apache/beam/pull/13120#discussion_r509442609", "createdAt": "2020-10-21T16:47:17Z", "author": {"login": "mxm"}, "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/ProcessBundleDescriptorsTest.java", "diffHunk": "@@ -151,6 +157,99 @@ public void onTimer() {}\n     ensureLengthPrefixed(timerKeyCoder, originalKeyCoder, pbsCoderMap);\n   }\n \n+  @Test\n+  public void testLengthPrefixingOfInputCoderExecutableStage() throws Exception {\n+    Pipeline p = Pipeline.create();\n+    Coder<Void> voidCoder = VoidCoder.of();\n+    assertThat(ModelCoderRegistrar.isKnownCoder(voidCoder), is(false));\n+    p.apply(\"impulse\", Impulse.create())\n+        .apply(\n+            ParDo.of(\n+                new DoFn<byte[], Void>() {\n+                  @ProcessElement\n+                  public void process(ProcessContext ctxt) {}\n+                }))\n+        .setCoder(voidCoder)\n+        .apply(\n+            ParDo.of(\n+                new DoFn<Void, Void>() {\n+                  @ProcessElement\n+                  public void processElement(\n+                      ProcessContext context, RestrictionTracker<Void, Void> tracker) {}\n+\n+                  @GetInitialRestriction\n+                  public Void getInitialRestriction() {\n+                    return null;\n+                  }\n+\n+                  @NewTracker\n+                  public SomeTracker newTracker(@Restriction Void restriction) {\n+                    return null;\n+                  }\n+                }))\n+        .setCoder(voidCoder);\n+    RunnerApi.Pipeline pipelineProto = PipelineTranslation.toProto(p);\n+    RunnerApi.Pipeline pipelineWithSdfExpanded =\n+        ProtoOverrides.updateTransform(\n+            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+            pipelineProto,\n+            SplittableParDoExpander.createSizedReplacement());\n+    FusedPipeline fused = GreedyPipelineFuser.fuse(pipelineWithSdfExpanded);\n+    Optional<ExecutableStage> optionalStage =\n+        Iterables.tryFind(\n+            fused.getFusedStages(),\n+            (ExecutableStage stage) ->\n+                stage.getTransforms().stream()\n+                    .anyMatch(\n+                        transform ->\n+                            transform\n+                                .getTransform()\n+                                .getSpec()\n+                                .getUrn()\n+                                .equals(\n+                                    PTransformTranslation\n+                                        .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)));\n+    checkState(\n+        optionalStage.isPresent(),\n+        \"Expected a stage with SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN.\");\n+\n+    ExecutableStage stage = optionalStage.get();\n+    PipelineNode.PCollectionNode inputPCollection = stage.getInputPCollection();\n+    Map<String, RunnerApi.Coder> stageCoderMap = stage.getComponents().getCodersMap();\n+    RunnerApi.Coder originalMainInputCoder =\n+        stageCoderMap.get(inputPCollection.getPCollection().getCoderId());\n+\n+    BeamFnApi.ProcessBundleDescriptor pbd =\n+        ProcessBundleDescriptors.fromExecutableStage(\n+                \"test_stage\", stage, Endpoints.ApiServiceDescriptor.getDefaultInstance())\n+            .getProcessBundleDescriptor();\n+    Map<String, RunnerApi.Coder> pbsCoderMap = pbd.getCodersMap();\n+\n+    RunnerApi.Coder pbsMainInputCoder =\n+        pbsCoderMap.get(pbd.getPcollectionsOrThrow(inputPCollection.getId()).getCoderId());\n+\n+    RunnerApi.Coder kvCoder =\n+        pbsCoderMap.get(ModelCoders.getKvCoderComponents(pbsMainInputCoder).keyCoderId());\n+    RunnerApi.Coder elementCoder =\n+        pbsCoderMap.get(ModelCoders.getKvCoderComponents(kvCoder).keyCoderId());\n+    RunnerApi.Coder valueKvCoder =\n+        pbsCoderMap.get(ModelCoders.getKvCoderComponents(kvCoder).valueCoderId());\n+    RunnerApi.Coder valueCoder =\n+        pbsCoderMap.get(ModelCoders.getKvCoderComponents(valueKvCoder).keyCoderId());\n+\n+    RunnerApi.Coder originalKvCoder =\n+        stageCoderMap.get(ModelCoders.getKvCoderComponents(originalMainInputCoder).keyCoderId());\n+    RunnerApi.Coder originalElementCoder =\n+        stageCoderMap.get(ModelCoders.getKvCoderComponents(originalKvCoder).keyCoderId());\n+    RunnerApi.Coder originalvalueKvCoder =\n+        stageCoderMap.get(ModelCoders.getKvCoderComponents(originalKvCoder).valueCoderId());\n+    RunnerApi.Coder originalvalueCoder =\n+        stageCoderMap.get(ModelCoders.getKvCoderComponents(originalvalueKvCoder).keyCoderId());\n+\n+    ensureLengthPrefixed(elementCoder, originalElementCoder, pbsCoderMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d78347c63196c69d27a3af05b9cbb9a7f84a6d09"}, "originalPosition": 121}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2998, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}