{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1MDYwMjgx", "number": 11257, "title": "[BEAM-9642] Create runtime invokers for SDF methods.", "bodyText": "This is just a first pass, and I now realize that I can do a bunch\nmore to optimize this for execution time, but that will come in a\nsubsequent commit probably. For now, this commit adds SDF method\ninvokers that have functioning unit tests. Next stage will be trying to\nget it to return a function, so we can avoid a lot of the unnecessary\ncode that's currently getting executed once per element, like the switch\nstatements.\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nApex\nDataflow\nFlink\nGearpump\nSamza\nSpark\n\n\n\n\nGo\n\n---\n---\n\n---\n---\n\n\n\nJava\n\n\n\n\n\n\n\n\n\nPython\n\n---\n\n\n---\n---\n\n\n\nXLang\n---\n---\n---\n\n---\n---\n\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-03-28T07:35:15Z", "url": "https://github.com/apache/beam/pull/11257", "merged": true, "mergeCommit": {"oid": "296e94b6112e833e6d467d5f9e8dfc83789aaa09"}, "closed": true, "closedAt": "2020-04-01T23:53:17Z", "author": {"login": "youngoli"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcSxkWJAFqTM4NDA1NDkwNw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcTgLi8gBqjMxOTAwMTI2NDM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MDU0OTA3", "url": "https://github.com/apache/beam/pull/11257#pullrequestreview-384054907", "createdAt": "2020-03-30T17:01:45Z", "commit": {"oid": "60668631a04599b88ea8cafe93eaa7869a6b2d62"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNzowMTo0NVrOF9zbiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNzowMTo0NVrOF9zbiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1MDA4OQ==", "bodyText": "This feels like the only bit that doesn't fit into the existing invokers. It would just need an additional wrapper to handle this part (since it's equivalent to the single return value kind), though handling the *FullValue we get back might be less clean. Hmmm.", "url": "https://github.com/apache/beam/pull/11257#discussion_r400350089", "createdAt": "2020-03-30T17:01:45Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/sdf_invokers.go", "diffHunk": "@@ -0,0 +1,131 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package exec\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/funcx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/sdf\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/reflectx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+\t\"reflect\"\n+)\n+\n+func invokeCreateInitialRestriction(fn *funcx.Fn, elms *FullValue) (rest interface{}, err error) {\n+\tif fn == nil {\n+\t\treturn nil, nil\n+\t}\n+\n+\tswitch fnT := fn.Fn.(type) {\n+\tcase reflectx.Func1x1:\n+\t\treturn fnT.Call1x1(elms.Elm), nil\n+\tcase reflectx.Func2x1:\n+\t\treturn fnT.Call2x1(elms.Elm, elms.Elm2), nil\n+\tdefault:\n+\t\tvar inputs []interface{}\n+\t\tswitch fn.Fn.Type().NumIn() {\n+\t\tcase 1:\n+\t\t\tinputs = []interface{}{elms.Elm}\n+\t\tcase 2:\n+\t\t\tinputs = []interface{}{elms.Elm, elms.Elm2}\n+\t\tdefault:\n+\t\t\terr := errors.Errorf(\"fn %v has unexpected number of inputs: %v\", fn.Fn.Name(), fn.Fn.Type().NumIn())\n+\t\t\treturn nil, errors.WithContext(err, \"sdf CreateInitialRestriction invoker\")\n+\t\t}\n+\t\trets := fn.Fn.Call(inputs)\n+\t\treturn rets[0], nil\n+\t}\n+}\n+\n+func invokeSplitRestriction(fn *funcx.Fn, elms *FullValue, rest interface{}) ([]interface{}, error) {\n+\tif fn == nil {\n+\t\treturn nil, nil\n+\t}\n+\n+\tvar ret interface{}\n+\tswitch fnT := fn.Fn.(type) {\n+\tcase reflectx.Func2x1:\n+\t\tret = fnT.Call2x1(elms.Elm, rest)\n+\tcase reflectx.Func3x1:\n+\t\tret = fnT.Call3x1(elms.Elm, elms.Elm2, rest)\n+\tdefault:\n+\t\tvar inputs []interface{}\n+\t\tswitch fn.Fn.Type().NumIn() {\n+\t\tcase 2:\n+\t\t\tinputs = []interface{}{elms.Elm, rest}\n+\t\tcase 3:\n+\t\t\tinputs = []interface{}{elms.Elm, elms.Elm2, rest}\n+\t\tdefault:\n+\t\t\terr := errors.Errorf(\"fn %v has unexpected number of inputs: %v\", fn.Fn.Name(), fn.Fn.Type().NumIn())\n+\t\t\treturn nil, errors.WithContext(err, \"sdf SplitRestriction invoker\")\n+\t\t}\n+\t\tret = fn.Fn.Call(inputs)[0]\n+\t}\n+\n+\t// Return value is an interface{}, but we need to convert it to a []interface{}.\n+\tval := reflect.ValueOf(ret)\n+\ts := make([]interface{}, 0, val.Len())\n+\tfor i := 0; i < val.Len(); i++ {\n+\t\ts = append(s, val.Index(i).Interface())\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60668631a04599b88ea8cafe93eaa7869a6b2d62"}, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MDg4MTc0", "url": "https://github.com/apache/beam/pull/11257#pullrequestreview-384088174", "createdAt": "2020-03-30T17:45:09Z", "commit": {"oid": "60668631a04599b88ea8cafe93eaa7869a6b2d62"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNzo0NTowOVrOF91HFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNzo0NTowOVrOF91HFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM3NzYyMQ==", "bodyText": "Just the concrete note that the reason the existing invokers are written the way they are, is so every time they're called, they don't need to make these choices over again. This is a WIP PR, so no worries.", "url": "https://github.com/apache/beam/pull/11257#discussion_r400377621", "createdAt": "2020-03-30T17:45:09Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/sdf_invokers.go", "diffHunk": "@@ -0,0 +1,131 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package exec\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/funcx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/sdf\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/reflectx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+\t\"reflect\"\n+)\n+\n+func invokeCreateInitialRestriction(fn *funcx.Fn, elms *FullValue) (rest interface{}, err error) {\n+\tif fn == nil {\n+\t\treturn nil, nil\n+\t}\n+\n+\tswitch fnT := fn.Fn.(type) {\n+\tcase reflectx.Func1x1:\n+\t\treturn fnT.Call1x1(elms.Elm), nil\n+\tcase reflectx.Func2x1:\n+\t\treturn fnT.Call2x1(elms.Elm, elms.Elm2), nil\n+\tdefault:\n+\t\tvar inputs []interface{}\n+\t\tswitch fn.Fn.Type().NumIn() {\n+\t\tcase 1:\n+\t\t\tinputs = []interface{}{elms.Elm}\n+\t\tcase 2:\n+\t\t\tinputs = []interface{}{elms.Elm, elms.Elm2}\n+\t\tdefault:\n+\t\t\terr := errors.Errorf(\"fn %v has unexpected number of inputs: %v\", fn.Fn.Name(), fn.Fn.Type().NumIn())\n+\t\t\treturn nil, errors.WithContext(err, \"sdf CreateInitialRestriction invoker\")\n+\t\t}\n+\t\trets := fn.Fn.Call(inputs)\n+\t\treturn rets[0], nil\n+\t}\n+}\n+\n+func invokeSplitRestriction(fn *funcx.Fn, elms *FullValue, rest interface{}) ([]interface{}, error) {\n+\tif fn == nil {\n+\t\treturn nil, nil\n+\t}\n+\n+\tvar ret interface{}\n+\tswitch fnT := fn.Fn.(type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60668631a04599b88ea8cafe93eaa7869a6b2d62"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MTA4Mjgx", "url": "https://github.com/apache/beam/pull/11257#pullrequestreview-384108281", "createdAt": "2020-03-30T18:11:31Z", "commit": {"oid": "60668631a04599b88ea8cafe93eaa7869a6b2d62"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxODoxMTozMVrOF92HWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxODoxNjo1N1rOF92UdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM5NDA3Mw==", "bodyText": "It occurs to me that we don't seem to have the abstract signatures documented for the \"Provider\" methods like SplitRestriction. IIRC we avoided doing that for now to avoid accidental usage? It might be good to document the expectation here at least, for this and the other SDF methods. eg. SplitRestriction(K?, V, RT) []RT", "url": "https://github.com/apache/beam/pull/11257#discussion_r400394073", "createdAt": "2020-03-30T18:11:31Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/sdf_invokers.go", "diffHunk": "@@ -0,0 +1,131 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package exec\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/funcx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/sdf\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/reflectx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+\t\"reflect\"\n+)\n+\n+func invokeCreateInitialRestriction(fn *funcx.Fn, elms *FullValue) (rest interface{}, err error) {\n+\tif fn == nil {\n+\t\treturn nil, nil\n+\t}\n+\n+\tswitch fnT := fn.Fn.(type) {\n+\tcase reflectx.Func1x1:\n+\t\treturn fnT.Call1x1(elms.Elm), nil\n+\tcase reflectx.Func2x1:\n+\t\treturn fnT.Call2x1(elms.Elm, elms.Elm2), nil\n+\tdefault:\n+\t\tvar inputs []interface{}\n+\t\tswitch fn.Fn.Type().NumIn() {\n+\t\tcase 1:\n+\t\t\tinputs = []interface{}{elms.Elm}\n+\t\tcase 2:\n+\t\t\tinputs = []interface{}{elms.Elm, elms.Elm2}\n+\t\tdefault:\n+\t\t\terr := errors.Errorf(\"fn %v has unexpected number of inputs: %v\", fn.Fn.Name(), fn.Fn.Type().NumIn())\n+\t\t\treturn nil, errors.WithContext(err, \"sdf CreateInitialRestriction invoker\")\n+\t\t}\n+\t\trets := fn.Fn.Call(inputs)\n+\t\treturn rets[0], nil\n+\t}\n+}\n+\n+func invokeSplitRestriction(fn *funcx.Fn, elms *FullValue, rest interface{}) ([]interface{}, error) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60668631a04599b88ea8cafe93eaa7869a6b2d62"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM5NjczOA==", "bodyText": "I won't worry about it until after optimization, where it might be clearer what we can re-use. This is presently nicely factored, so unless we can make it shorter/clearer with a reuse of DoFn invoker (possibly by adding other helpers/generated methods, etc or otherwise), this is fine.", "url": "https://github.com/apache/beam/pull/11257#discussion_r400396738", "createdAt": "2020-03-30T18:15:48Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/sdf_invokers.go", "diffHunk": "@@ -0,0 +1,131 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package exec\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/funcx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/sdf\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/reflectx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+\t\"reflect\"\n+)\n+\n+func invokeCreateInitialRestriction(fn *funcx.Fn, elms *FullValue) (rest interface{}, err error) {\n+\tif fn == nil {\n+\t\treturn nil, nil\n+\t}\n+\n+\tswitch fnT := fn.Fn.(type) {\n+\tcase reflectx.Func1x1:\n+\t\treturn fnT.Call1x1(elms.Elm), nil\n+\tcase reflectx.Func2x1:\n+\t\treturn fnT.Call2x1(elms.Elm, elms.Elm2), nil\n+\tdefault:\n+\t\tvar inputs []interface{}\n+\t\tswitch fn.Fn.Type().NumIn() {\n+\t\tcase 1:\n+\t\t\tinputs = []interface{}{elms.Elm}\n+\t\tcase 2:\n+\t\t\tinputs = []interface{}{elms.Elm, elms.Elm2}\n+\t\tdefault:\n+\t\t\terr := errors.Errorf(\"fn %v has unexpected number of inputs: %v\", fn.Fn.Name(), fn.Fn.Type().NumIn())\n+\t\t\treturn nil, errors.WithContext(err, \"sdf CreateInitialRestriction invoker\")\n+\t\t}\n+\t\trets := fn.Fn.Call(inputs)\n+\t\treturn rets[0], nil\n+\t}\n+}\n+\n+func invokeSplitRestriction(fn *funcx.Fn, elms *FullValue, rest interface{}) ([]interface{}, error) {\n+\tif fn == nil {\n+\t\treturn nil, nil\n+\t}\n+\n+\tvar ret interface{}\n+\tswitch fnT := fn.Fn.(type) {\n+\tcase reflectx.Func2x1:\n+\t\tret = fnT.Call2x1(elms.Elm, rest)\n+\tcase reflectx.Func3x1:\n+\t\tret = fnT.Call3x1(elms.Elm, elms.Elm2, rest)\n+\tdefault:\n+\t\tvar inputs []interface{}\n+\t\tswitch fn.Fn.Type().NumIn() {\n+\t\tcase 2:\n+\t\t\tinputs = []interface{}{elms.Elm, rest}\n+\t\tcase 3:\n+\t\t\tinputs = []interface{}{elms.Elm, elms.Elm2, rest}\n+\t\tdefault:\n+\t\t\terr := errors.Errorf(\"fn %v has unexpected number of inputs: %v\", fn.Fn.Name(), fn.Fn.Type().NumIn())\n+\t\t\treturn nil, errors.WithContext(err, \"sdf SplitRestriction invoker\")\n+\t\t}\n+\t\tret = fn.Fn.Call(inputs)[0]\n+\t}\n+\n+\t// Return value is an interface{}, but we need to convert it to a []interface{}.\n+\tval := reflect.ValueOf(ret)\n+\ts := make([]interface{}, 0, val.Len())\n+\tfor i := 0; i < val.Len(); i++ {\n+\t\ts = append(s, val.Index(i).Interface())\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1MDA4OQ=="}, "originalCommit": {"oid": "60668631a04599b88ea8cafe93eaa7869a6b2d62"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM5NzQyOQ==", "bodyText": "While this type and methods are only for test purposes, please adhere to the Go documentation idiom of having the method name in full to start the comment.", "url": "https://github.com/apache/beam/pull/11257#discussion_r400397429", "createdAt": "2020-03-30T18:16:57Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/sdf_invokers_test.go", "diffHunk": "@@ -0,0 +1,262 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package exec\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n+\t\"github.com/google/go-cmp/cmp\"\n+\t\"testing\"\n+)\n+\n+func init() {\n+}\n+\n+// TestInvokes runs tests on each SDF method invoker, using the SDFs defined\n+// in this file. Tests both single-element and KV element cases.\n+func TestInvokes(t *testing.T) {\n+\t// Setup.\n+\tdfn, err := graph.NewDoFn(&Sdf{}, graph.NumMainInputs(graph.MainSingle))\n+\tif err != nil {\n+\t\tt.Fatalf(\"invalid function: %v\", err)\n+\t}\n+\tsdf := (*graph.SplittableDoFn)(dfn)\n+\n+\tdfn, err = graph.NewDoFn(&KvSdf{}, graph.NumMainInputs(graph.MainKv))\n+\tif err != nil {\n+\t\tt.Fatalf(\"invalid function: %v\", err)\n+\t}\n+\tkvsdf := (*graph.SplittableDoFn)(dfn)\n+\n+\t// Tests.\n+\tt.Run(\"invokeCreateInitialRestriction\", func(t *testing.T) {\n+\t\ttests := []struct {\n+\t\t\tname string\n+\t\t\tsdf  *graph.SplittableDoFn\n+\t\t\telms *FullValue\n+\t\t\twant Restriction\n+\t\t}{\n+\t\t\t{\"SingleElem\", sdf, &FullValue{Elm: 5}, Restriction{5}},\n+\t\t\t{\"KvElem\", kvsdf, &FullValue{Elm: 5, Elm2: 2}, Restriction{7}},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tfn := test.sdf.CreateInitialRestrictionFn()\n+\t\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\t\tgot, err := invokeCreateInitialRestriction(fn, test.elms)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatalf(\"invokeCreateInitialRestriction failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif !cmp.Equal(got, test.want) {\n+\t\t\t\t\tt.Errorf(\"invokeCreateInitialRestriction(%v) has incorrect output: got: %v, want: %v\", test.elms, got, test.want)\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n+\n+\tt.Run(\"invokeSplitRestriction\", func(t *testing.T) {\n+\t\ttests := []struct {\n+\t\t\tname string\n+\t\t\tsdf  *graph.SplittableDoFn\n+\t\t\telms *FullValue\n+\t\t\trest Restriction\n+\t\t\twant []interface{}\n+\t\t}{\n+\t\t\t{\n+\t\t\t\t\"SingleElem\",\n+\t\t\t\tsdf,\n+\t\t\t\t&FullValue{Elm: 5},\n+\t\t\t\tRestriction{3},\n+\t\t\t\t[]interface{}{Restriction{8}, Restriction{9}},\n+\t\t\t}, {\n+\t\t\t\t\"KvElem\",\n+\t\t\t\tkvsdf,\n+\t\t\t\t&FullValue{Elm: 5, Elm2: 2},\n+\t\t\t\tRestriction{3},\n+\t\t\t\t[]interface{}{Restriction{8}, Restriction{5}},\n+\t\t\t},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tfn := test.sdf.SplitRestrictionFn()\n+\t\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\t\tgot, err := invokeSplitRestriction(fn, test.elms, test.rest)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatalf(\"invokeSplitRestriction failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif !cmp.Equal(got, test.want) {\n+\t\t\t\t\tt.Errorf(\"invokeSplitRestriction(%v, %v) has incorrect output: got: %v, want: %v\",\n+\t\t\t\t\t\ttest.elms, test.rest, got, test.want)\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n+\n+\tt.Run(\"invokeRestrictionSize\", func(t *testing.T) {\n+\t\ttests := []struct {\n+\t\t\tname string\n+\t\t\tsdf  *graph.SplittableDoFn\n+\t\t\telms *FullValue\n+\t\t\trest Restriction\n+\t\t\twant float64\n+\t\t}{\n+\t\t\t{\n+\t\t\t\t\"SingleElem\",\n+\t\t\t\tsdf,\n+\t\t\t\t&FullValue{Elm: 5},\n+\t\t\t\tRestriction{3},\n+\t\t\t\t8,\n+\t\t\t}, {\n+\t\t\t\t\"KvElem\",\n+\t\t\t\tkvsdf,\n+\t\t\t\t&FullValue{Elm: 5, Elm2: 2},\n+\t\t\t\tRestriction{3},\n+\t\t\t\t10,\n+\t\t\t},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tfn := test.sdf.RestrictionSizeFn()\n+\t\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\t\tgot, err := invokeRestrictionSize(fn, test.elms, test.rest)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatalf(\"invokeRestrictionSize failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif !cmp.Equal(got, test.want) {\n+\t\t\t\t\tt.Errorf(\"invokeRestrictionSize(%v, %v) has incorrect output: got: %v, want: %v\",\n+\t\t\t\t\t\ttest.elms, test.rest, got, test.want)\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n+\n+\tt.Run(\"invokeCreateTracker\", func(t *testing.T) {\n+\t\ttests := []struct {\n+\t\t\tname string\n+\t\t\tsdf  *graph.SplittableDoFn\n+\t\t\trest Restriction\n+\t\t\twant *RTracker\n+\t\t}{\n+\t\t\t{\n+\t\t\t\t\"SingleElem\",\n+\t\t\t\tsdf,\n+\t\t\t\tRestriction{3},\n+\t\t\t\t&RTracker{\n+\t\t\t\t\tRestriction{3},\n+\t\t\t\t\t1,\n+\t\t\t\t},\n+\t\t\t}, {\n+\t\t\t\t\"KvElem\",\n+\t\t\t\tkvsdf,\n+\t\t\t\tRestriction{5},\n+\t\t\t\t&RTracker{\n+\t\t\t\t\tRestriction{5},\n+\t\t\t\t\t2,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tfn := test.sdf.CreateTrackerFn()\n+\t\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\t\tgot, err := invokeCreateTracker(fn, test.rest)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatalf(\"invokeCreateTracker failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif !cmp.Equal(got, test.want) {\n+\t\t\t\t\tt.Errorf(\"invokeCreateTracker(%v) has incorrect output: got: %v, want: %v\",\n+\t\t\t\t\t\ttest.rest, got, test.want)\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n+}\n+\n+type Restriction struct {\n+\tVal int\n+}\n+\n+// RTracker's methods can all be no-ops, we just need it to implement sdf.RTracker.\n+type RTracker struct {\n+\tRest Restriction\n+\tVal  int\n+}\n+\n+func (rt *RTracker) TryClaim(interface{}) bool                      { return false }\n+func (rt *RTracker) GetError() error                                { return nil }\n+func (rt *RTracker) TrySplit(fraction float64) (interface{}, error) { return nil, nil }\n+func (rt *RTracker) GetProgress() float64                           { return 0 }\n+func (rt *RTracker) IsDone() bool                                   { return false }\n+\n+// In order to test that these methods get called properly, each one has an\n+// implementation that lets us confirm that each argument was passed properly.\n+\n+type Sdf struct {\n+}\n+\n+// Creates a restriction with the given value.\n+func (fn *Sdf) CreateInitialRestriction(i int) Restriction {\n+\treturn Restriction{i}\n+}\n+\n+// Outputs two restrictions, the first containing the sum of i and rest.Val, the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60668631a04599b88ea8cafe93eaa7869a6b2d62"}, "originalPosition": 214}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6456769fd9bbba584ccd8300c80f882c3c75d338", "author": {"user": {"login": "youngoli", "name": "Daniel Oliveira"}}, "url": "https://github.com/apache/beam/commit/6456769fd9bbba584ccd8300c80f882c3c75d338", "committedDate": "2020-03-30T21:56:23Z", "message": "[BEAM-3301] Optimize CreateInitialRestriction invoker."}, "afterCommit": {"oid": "580b6ab2c8894421ff51f42f43c5b4fc714165d9", "author": {"user": {"login": "youngoli", "name": "Daniel Oliveira"}}, "url": "https://github.com/apache/beam/commit/580b6ab2c8894421ff51f42f43c5b4fc714165d9", "committedDate": "2020-03-31T02:39:33Z", "message": "[BEAM-9642] Optimize invokers."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MjcyMzkw", "url": "https://github.com/apache/beam/pull/11257#pullrequestreview-384272390", "createdAt": "2020-03-30T22:18:09Z", "commit": {"oid": "6456769fd9bbba584ccd8300c80f882c3c75d338"}, "state": "APPROVED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMjoxODoxMFrOF9-Trw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxODo1MTo1MlrOF_OIPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyODMwMw==", "bodyText": "I'm surprised that the return func type doesn't have the return value pair wrapped in (), but if gofmt likes it' it's fine.", "url": "https://github.com/apache/beam/pull/11257#discussion_r400528303", "createdAt": "2020-03-30T22:18:10Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/sdf_invokers.go", "diffHunk": "@@ -23,29 +23,36 @@ import (\n \t\"reflect\"\n )\n \n-func invokeCreateInitialRestriction(fn *funcx.Fn, elms *FullValue) (rest interface{}, err error) {\n+func createInitialRestrictionCallFn(fn *funcx.Fn) (callFn func(*FullValue) interface{}, err error) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6456769fd9bbba584ccd8300c80f882c3c75d338"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc3MzkyOQ==", "bodyText": "Well in principle we could embed the normal invoker in each of these, and have customized initCall or Ret functions which could save some work/optimization duplication. I agree that there's some complexity around doing that, so we can punt it for now. Similarly, the fn_arity thing could be adjusted to generate additional things later on.\nNo action required. Just commentary.", "url": "https://github.com/apache/beam/pull/11257#discussion_r401773929", "createdAt": "2020-04-01T17:08:23Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/sdf_invokers.go", "diffHunk": "@@ -0,0 +1,302 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package exec\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/funcx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/sdf\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/reflectx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+\t\"reflect\"\n+)\n+\n+// This file contains invokers for SDF methods. These invokers are based off\n+// exec.invoker which is used for regular DoFns. Since exec.invoker is\n+// specialized for DoFns it cannot be used for SDF methods. Instead, these", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "580b6ab2c8894421ff51f42f43c5b4fc714165d9"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc3OTgzOA==", "bodyText": "No action required, just commentary.\nOptimization note: We know this will never be more than 3 (or similar for the other methods), so it could be used as an actual Array instead of a slice [3]interface{}, and we could similarly simply unroll the loops or, even full clear it by assigning a new instance in Reset for maximum efficiency.  (eg. n.args = [3]interface{}{})\nThe tricky bit is we still arguably should cache the slice part itself since that could repeatedly get heap allocated on each call.\nThis doesn't work for the general invoker since the number of emit functions could be arbitrary, and we don't gain as much from it.", "url": "https://github.com/apache/beam/pull/11257#discussion_r401779838", "createdAt": "2020-04-01T17:17:31Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/sdf_invokers.go", "diffHunk": "@@ -0,0 +1,302 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package exec\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/funcx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/sdf\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/reflectx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+\t\"reflect\"\n+)\n+\n+// This file contains invokers for SDF methods. These invokers are based off\n+// exec.invoker which is used for regular DoFns. Since exec.invoker is\n+// specialized for DoFns it cannot be used for SDF methods. Instead, these\n+// invokers pare down the functionality to only what is essential for\n+// executing SDF methods, including per-element optimizations.\n+//\n+// Each SDF method invoker in this file is specific to a certain method, but\n+// they are all used the same way. Create an invoker with new[Method]Invoker\n+// in the Up method of an exec.Unit, and then invoke it with Invoke. Finally,\n+// call Reset on it when the bundle ends in FinishBundle.\n+//\n+// These invokers are not thread-safe.\n+\n+// cirInvoker is an invoker for CreateInitialRestriction.\n+type cirInvoker struct {\n+\tfn   *funcx.Fn\n+\targs []interface{} // Cache to avoid allocating new slices per-element.\n+\tcall func(elms *FullValue) (rest interface{})\n+}\n+\n+func newCreateInitialRestrictionInvoker(fn *funcx.Fn) (*cirInvoker, error) {\n+\tn := &cirInvoker{\n+\t\tfn:   fn,\n+\t\targs: make([]interface{}, len(fn.Param)),\n+\t}\n+\tif err := n.initCallFn(); err != nil {\n+\t\treturn nil, errors.WithContext(err, \"sdf CreateInitialRestriction invoker\")\n+\t}\n+\treturn n, nil\n+}\n+\n+func (n *cirInvoker) initCallFn() error {\n+\t// Expects a signature of the form:\n+\t// (key?, value) restriction\n+\t// TODO(BEAM-9643): Link to full documentation.\n+\tswitch fnT := n.fn.Fn.(type) {\n+\tcase reflectx.Func1x1:\n+\t\tn.call = func(elms *FullValue) interface{} {\n+\t\t\treturn fnT.Call1x1(elms.Elm)\n+\t\t}\n+\tcase reflectx.Func2x1:\n+\t\tn.call = func(elms *FullValue) interface{} {\n+\t\t\treturn fnT.Call2x1(elms.Elm, elms.Elm2)\n+\t\t}\n+\tdefault:\n+\t\tswitch len(n.fn.Param) {\n+\t\tcase 1:\n+\t\t\tn.call = func(elms *FullValue) interface{} {\n+\t\t\t\tn.args[0] = elms.Elm\n+\t\t\t\treturn n.fn.Fn.Call(n.args)[0]\n+\t\t\t}\n+\t\tcase 2:\n+\t\t\tn.call = func(elms *FullValue) interface{} {\n+\t\t\t\tn.args[0] = elms.Elm\n+\t\t\t\tn.args[1] = elms.Elm2\n+\t\t\t\treturn n.fn.Fn.Call(n.args)[0]\n+\t\t\t}\n+\t\tdefault:\n+\t\t\treturn errors.Errorf(\"CreateInitialRestriction fn %v has unexpected number of parameters: %v\",\n+\t\t\t\tn.fn.Fn.Name(), len(n.fn.Param))\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// Invoke calls CreateInitialRestriction with the given FullValue as the element\n+// and returns the resulting restriction.\n+func (n *cirInvoker) Invoke(elms *FullValue) (rest interface{}) {\n+\treturn n.call(elms)\n+}\n+\n+// Reset zeroes argument entries in the cached slice to allow values to be\n+// garbage collected after the bundle ends.\n+func (n *cirInvoker) Reset() {\n+\tfor i := range n.args {\n+\t\tn.args[i] = nil\n+\t}\n+}\n+\n+// srInvoker is an invoker for SplitRestriction.\n+type srInvoker struct {\n+\tfn   *funcx.Fn\n+\targs []interface{} // Cache to avoid allocating new slices per-element.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "580b6ab2c8894421ff51f42f43c5b4fc714165d9"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgzMzUyOQ==", "bodyText": "As a rule, naming return values where the meaning is already clear, and you aren't needing to modify the return in a defer is considered an anti pattern, unless it's a primitive type like string or a number, where the meaning of the type isn't necessarily clear.\nIt's also not necessary to do just because other functions/methods in the same file are doing it. There's no consistency requirement for it, and it can make things more confusing.\nIn short, drop the tracker, it's cleaner. :)", "url": "https://github.com/apache/beam/pull/11257#discussion_r401833529", "createdAt": "2020-04-01T18:47:25Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/sdf_invokers.go", "diffHunk": "@@ -0,0 +1,302 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package exec\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/funcx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/sdf\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/reflectx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+\t\"reflect\"\n+)\n+\n+// This file contains invokers for SDF methods. These invokers are based off\n+// exec.invoker which is used for regular DoFns. Since exec.invoker is\n+// specialized for DoFns it cannot be used for SDF methods. Instead, these\n+// invokers pare down the functionality to only what is essential for\n+// executing SDF methods, including per-element optimizations.\n+//\n+// Each SDF method invoker in this file is specific to a certain method, but\n+// they are all used the same way. Create an invoker with new[Method]Invoker\n+// in the Up method of an exec.Unit, and then invoke it with Invoke. Finally,\n+// call Reset on it when the bundle ends in FinishBundle.\n+//\n+// These invokers are not thread-safe.\n+\n+// cirInvoker is an invoker for CreateInitialRestriction.\n+type cirInvoker struct {\n+\tfn   *funcx.Fn\n+\targs []interface{} // Cache to avoid allocating new slices per-element.\n+\tcall func(elms *FullValue) (rest interface{})\n+}\n+\n+func newCreateInitialRestrictionInvoker(fn *funcx.Fn) (*cirInvoker, error) {\n+\tn := &cirInvoker{\n+\t\tfn:   fn,\n+\t\targs: make([]interface{}, len(fn.Param)),\n+\t}\n+\tif err := n.initCallFn(); err != nil {\n+\t\treturn nil, errors.WithContext(err, \"sdf CreateInitialRestriction invoker\")\n+\t}\n+\treturn n, nil\n+}\n+\n+func (n *cirInvoker) initCallFn() error {\n+\t// Expects a signature of the form:\n+\t// (key?, value) restriction\n+\t// TODO(BEAM-9643): Link to full documentation.\n+\tswitch fnT := n.fn.Fn.(type) {\n+\tcase reflectx.Func1x1:\n+\t\tn.call = func(elms *FullValue) interface{} {\n+\t\t\treturn fnT.Call1x1(elms.Elm)\n+\t\t}\n+\tcase reflectx.Func2x1:\n+\t\tn.call = func(elms *FullValue) interface{} {\n+\t\t\treturn fnT.Call2x1(elms.Elm, elms.Elm2)\n+\t\t}\n+\tdefault:\n+\t\tswitch len(n.fn.Param) {\n+\t\tcase 1:\n+\t\t\tn.call = func(elms *FullValue) interface{} {\n+\t\t\t\tn.args[0] = elms.Elm\n+\t\t\t\treturn n.fn.Fn.Call(n.args)[0]\n+\t\t\t}\n+\t\tcase 2:\n+\t\t\tn.call = func(elms *FullValue) interface{} {\n+\t\t\t\tn.args[0] = elms.Elm\n+\t\t\t\tn.args[1] = elms.Elm2\n+\t\t\t\treturn n.fn.Fn.Call(n.args)[0]\n+\t\t\t}\n+\t\tdefault:\n+\t\t\treturn errors.Errorf(\"CreateInitialRestriction fn %v has unexpected number of parameters: %v\",\n+\t\t\t\tn.fn.Fn.Name(), len(n.fn.Param))\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// Invoke calls CreateInitialRestriction with the given FullValue as the element\n+// and returns the resulting restriction.\n+func (n *cirInvoker) Invoke(elms *FullValue) (rest interface{}) {\n+\treturn n.call(elms)\n+}\n+\n+// Reset zeroes argument entries in the cached slice to allow values to be\n+// garbage collected after the bundle ends.\n+func (n *cirInvoker) Reset() {\n+\tfor i := range n.args {\n+\t\tn.args[i] = nil\n+\t}\n+}\n+\n+// srInvoker is an invoker for SplitRestriction.\n+type srInvoker struct {\n+\tfn   *funcx.Fn\n+\targs []interface{} // Cache to avoid allocating new slices per-element.\n+\tcall func(elms *FullValue, rest interface{}) (split interface{})\n+}\n+\n+func newSplitRestrictionInvoker(fn *funcx.Fn) (*srInvoker, error) {\n+\tn := &srInvoker{\n+\t\tfn:   fn,\n+\t\targs: make([]interface{}, len(fn.Param)),\n+\t}\n+\tif err := n.initCallFn(); err != nil {\n+\t\treturn nil, errors.WithContext(err, \"sdf SplitRestriction invoker\")\n+\t}\n+\treturn n, nil\n+}\n+\n+func (n *srInvoker) initCallFn() error {\n+\t// Expects a signature of the form:\n+\t// (key?, value, restriction) []restriction\n+\t// TODO(BEAM-9643): Link to full documentation.\n+\tswitch fnT := n.fn.Fn.(type) {\n+\tcase reflectx.Func2x1:\n+\t\tn.call = func(elms *FullValue, rest interface{}) interface{} {\n+\t\t\treturn fnT.Call2x1(elms.Elm, rest)\n+\t\t}\n+\tcase reflectx.Func3x1:\n+\t\tn.call = func(elms *FullValue, rest interface{}) interface{} {\n+\t\t\treturn fnT.Call3x1(elms.Elm, elms.Elm2, rest)\n+\t\t}\n+\tdefault:\n+\t\tswitch len(n.fn.Param) {\n+\t\tcase 2:\n+\t\t\tn.call = func(elms *FullValue, rest interface{}) interface{} {\n+\t\t\t\tn.args[0] = elms.Elm\n+\t\t\t\tn.args[1] = rest\n+\t\t\t\treturn n.fn.Fn.Call(n.args)[0]\n+\t\t\t}\n+\t\tcase 3:\n+\t\t\tn.call = func(elms *FullValue, rest interface{}) interface{} {\n+\t\t\t\tn.args[0] = elms.Elm\n+\t\t\t\tn.args[1] = elms.Elm2\n+\t\t\t\tn.args[2] = rest\n+\t\t\t\treturn n.fn.Fn.Call(n.args)[0]\n+\t\t\t}\n+\t\tdefault:\n+\t\t\treturn errors.Errorf(\"SplitRestriction fn %v has unexpected number of parameters: %v\",\n+\t\t\t\tn.fn.Fn.Name(), len(n.fn.Param))\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// Invoke calls SplitRestriction given a FullValue containing an element and\n+// the associated restriction, and returns a slice of split restrictions.\n+func (n *srInvoker) Invoke(elms *FullValue, rest interface{}) (split []interface{}) {\n+\tret := n.call(elms, rest)\n+\n+\t// Return value is an interface{}, but we need to convert it to a []interface{}.\n+\tval := reflect.ValueOf(ret)\n+\ts := make([]interface{}, 0, val.Len())\n+\tfor i := 0; i < val.Len(); i++ {\n+\t\ts = append(s, val.Index(i).Interface())\n+\t}\n+\treturn s\n+}\n+\n+// Reset zeroes argument entries in the cached slice to allow values to be\n+// garbage collected after the bundle ends.\n+func (n *srInvoker) Reset() {\n+\tfor i := range n.args {\n+\t\tn.args[i] = nil\n+\t}\n+}\n+\n+// rsInvoker is an invoker for RestrictionSize.\n+type rsInvoker struct {\n+\tfn   *funcx.Fn\n+\targs []interface{} // Cache to avoid allocating new slices per-element.\n+\tcall func(elms *FullValue, rest interface{}) (size float64)\n+}\n+\n+func newRestrictionSizeInvoker(fn *funcx.Fn) (*rsInvoker, error) {\n+\tn := &rsInvoker{\n+\t\tfn:   fn,\n+\t\targs: make([]interface{}, len(fn.Param)),\n+\t}\n+\tif err := n.initCallFn(); err != nil {\n+\t\treturn nil, errors.WithContext(err, \"sdf RestrictionSize invoker\")\n+\t}\n+\treturn n, nil\n+}\n+\n+func (n *rsInvoker) initCallFn() error {\n+\t// Expects a signature of the form:\n+\t// (key?, value, restriction) float64\n+\t// TODO(BEAM-9643): Link to full documentation.\n+\tswitch fnT := n.fn.Fn.(type) {\n+\tcase reflectx.Func2x1:\n+\t\tn.call = func(elms *FullValue, rest interface{}) float64 {\n+\t\t\treturn fnT.Call2x1(elms.Elm, rest).(float64)\n+\t\t}\n+\tcase reflectx.Func3x1:\n+\t\tn.call = func(elms *FullValue, rest interface{}) float64 {\n+\t\t\treturn fnT.Call3x1(elms.Elm, elms.Elm2, rest).(float64)\n+\t\t}\n+\tdefault:\n+\t\tswitch len(n.fn.Param) {\n+\t\tcase 2:\n+\t\t\tn.call = func(elms *FullValue, rest interface{}) float64 {\n+\t\t\t\tn.args[0] = elms.Elm\n+\t\t\t\tn.args[1] = rest\n+\t\t\t\treturn n.fn.Fn.Call(n.args)[0].(float64)\n+\t\t\t}\n+\t\tcase 3:\n+\t\t\tn.call = func(elms *FullValue, rest interface{}) float64 {\n+\t\t\t\tn.args[0] = elms.Elm\n+\t\t\t\tn.args[1] = elms.Elm2\n+\t\t\t\tn.args[2] = rest\n+\t\t\t\treturn n.fn.Fn.Call(n.args)[0].(float64)\n+\t\t\t}\n+\t\tdefault:\n+\t\t\treturn errors.Errorf(\"RestrictionSize fn %v has unexpected number of parameters: %v\",\n+\t\t\t\tn.fn.Fn.Name(), len(n.fn.Param))\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// Invoke calls RestrictionSize given a FullValue containing an element and\n+// the associated restriction, and returns a size.\n+func (n *rsInvoker) Invoke(elms *FullValue, rest interface{}) (size float64) {\n+\treturn n.call(elms, rest)\n+}\n+\n+// Reset zeroes argument entries in the cached slice to allow values to be\n+// garbage collected after the bundle ends.\n+func (n *rsInvoker) Reset() {\n+\tfor i := range n.args {\n+\t\tn.args[i] = nil\n+\t}\n+}\n+\n+// ctInvoker is an invoker for CreateTracker.\n+type ctInvoker struct {\n+\tfn   *funcx.Fn\n+\targs []interface{} // Cache to avoid allocating new slices per-element.\n+\tcall func(rest interface{}) (tracker sdf.RTracker)\n+}\n+\n+func newCreateTrackerInvoker(fn *funcx.Fn) (*ctInvoker, error) {\n+\tn := &ctInvoker{\n+\t\tfn:   fn,\n+\t\targs: make([]interface{}, len(fn.Param)),\n+\t}\n+\tif err := n.initCallFn(); err != nil {\n+\t\treturn nil, errors.WithContext(err, \"sdf CreateTracker invoker\")\n+\t}\n+\treturn n, nil\n+}\n+\n+func (n *ctInvoker) initCallFn() error {\n+\t// Expects a signature of the form:\n+\t// (restriction) sdf.RTracker\n+\t// TODO(BEAM-9643): Link to full documentation.\n+\tswitch fnT := n.fn.Fn.(type) {\n+\tcase reflectx.Func1x1:\n+\t\tn.call = func(rest interface{}) sdf.RTracker {\n+\t\t\treturn fnT.Call1x1(rest).(sdf.RTracker)\n+\t\t}\n+\tdefault:\n+\t\tif len(n.fn.Param) != 1 {\n+\t\t\treturn errors.Errorf(\"CreateTracker fn %v has unexpected number of parameters: %v\",\n+\t\t\t\tn.fn.Fn.Name(), len(n.fn.Param))\n+\t\t}\n+\t\tn.call = func(rest interface{}) sdf.RTracker {\n+\t\t\tn.args[0] = rest\n+\t\t\treturn n.fn.Fn.Call(n.args)[0].(sdf.RTracker)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// Invoke calls CreateTracker given a restriction and returns an sdf.RTracker.\n+// the associated restriction, and returns a size.\n+func (n *ctInvoker) Invoke(rest interface{}) (tracker sdf.RTracker) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "580b6ab2c8894421ff51f42f43c5b4fc714165d9"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgzNDY5Mg==", "bodyText": "This documentation line is copypasta I think.", "url": "https://github.com/apache/beam/pull/11257#discussion_r401834692", "createdAt": "2020-04-01T18:49:22Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/sdf_invokers.go", "diffHunk": "@@ -0,0 +1,302 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package exec\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/funcx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/sdf\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/reflectx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+\t\"reflect\"\n+)\n+\n+// This file contains invokers for SDF methods. These invokers are based off\n+// exec.invoker which is used for regular DoFns. Since exec.invoker is\n+// specialized for DoFns it cannot be used for SDF methods. Instead, these\n+// invokers pare down the functionality to only what is essential for\n+// executing SDF methods, including per-element optimizations.\n+//\n+// Each SDF method invoker in this file is specific to a certain method, but\n+// they are all used the same way. Create an invoker with new[Method]Invoker\n+// in the Up method of an exec.Unit, and then invoke it with Invoke. Finally,\n+// call Reset on it when the bundle ends in FinishBundle.\n+//\n+// These invokers are not thread-safe.\n+\n+// cirInvoker is an invoker for CreateInitialRestriction.\n+type cirInvoker struct {\n+\tfn   *funcx.Fn\n+\targs []interface{} // Cache to avoid allocating new slices per-element.\n+\tcall func(elms *FullValue) (rest interface{})\n+}\n+\n+func newCreateInitialRestrictionInvoker(fn *funcx.Fn) (*cirInvoker, error) {\n+\tn := &cirInvoker{\n+\t\tfn:   fn,\n+\t\targs: make([]interface{}, len(fn.Param)),\n+\t}\n+\tif err := n.initCallFn(); err != nil {\n+\t\treturn nil, errors.WithContext(err, \"sdf CreateInitialRestriction invoker\")\n+\t}\n+\treturn n, nil\n+}\n+\n+func (n *cirInvoker) initCallFn() error {\n+\t// Expects a signature of the form:\n+\t// (key?, value) restriction\n+\t// TODO(BEAM-9643): Link to full documentation.\n+\tswitch fnT := n.fn.Fn.(type) {\n+\tcase reflectx.Func1x1:\n+\t\tn.call = func(elms *FullValue) interface{} {\n+\t\t\treturn fnT.Call1x1(elms.Elm)\n+\t\t}\n+\tcase reflectx.Func2x1:\n+\t\tn.call = func(elms *FullValue) interface{} {\n+\t\t\treturn fnT.Call2x1(elms.Elm, elms.Elm2)\n+\t\t}\n+\tdefault:\n+\t\tswitch len(n.fn.Param) {\n+\t\tcase 1:\n+\t\t\tn.call = func(elms *FullValue) interface{} {\n+\t\t\t\tn.args[0] = elms.Elm\n+\t\t\t\treturn n.fn.Fn.Call(n.args)[0]\n+\t\t\t}\n+\t\tcase 2:\n+\t\t\tn.call = func(elms *FullValue) interface{} {\n+\t\t\t\tn.args[0] = elms.Elm\n+\t\t\t\tn.args[1] = elms.Elm2\n+\t\t\t\treturn n.fn.Fn.Call(n.args)[0]\n+\t\t\t}\n+\t\tdefault:\n+\t\t\treturn errors.Errorf(\"CreateInitialRestriction fn %v has unexpected number of parameters: %v\",\n+\t\t\t\tn.fn.Fn.Name(), len(n.fn.Param))\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// Invoke calls CreateInitialRestriction with the given FullValue as the element\n+// and returns the resulting restriction.\n+func (n *cirInvoker) Invoke(elms *FullValue) (rest interface{}) {\n+\treturn n.call(elms)\n+}\n+\n+// Reset zeroes argument entries in the cached slice to allow values to be\n+// garbage collected after the bundle ends.\n+func (n *cirInvoker) Reset() {\n+\tfor i := range n.args {\n+\t\tn.args[i] = nil\n+\t}\n+}\n+\n+// srInvoker is an invoker for SplitRestriction.\n+type srInvoker struct {\n+\tfn   *funcx.Fn\n+\targs []interface{} // Cache to avoid allocating new slices per-element.\n+\tcall func(elms *FullValue, rest interface{}) (split interface{})\n+}\n+\n+func newSplitRestrictionInvoker(fn *funcx.Fn) (*srInvoker, error) {\n+\tn := &srInvoker{\n+\t\tfn:   fn,\n+\t\targs: make([]interface{}, len(fn.Param)),\n+\t}\n+\tif err := n.initCallFn(); err != nil {\n+\t\treturn nil, errors.WithContext(err, \"sdf SplitRestriction invoker\")\n+\t}\n+\treturn n, nil\n+}\n+\n+func (n *srInvoker) initCallFn() error {\n+\t// Expects a signature of the form:\n+\t// (key?, value, restriction) []restriction\n+\t// TODO(BEAM-9643): Link to full documentation.\n+\tswitch fnT := n.fn.Fn.(type) {\n+\tcase reflectx.Func2x1:\n+\t\tn.call = func(elms *FullValue, rest interface{}) interface{} {\n+\t\t\treturn fnT.Call2x1(elms.Elm, rest)\n+\t\t}\n+\tcase reflectx.Func3x1:\n+\t\tn.call = func(elms *FullValue, rest interface{}) interface{} {\n+\t\t\treturn fnT.Call3x1(elms.Elm, elms.Elm2, rest)\n+\t\t}\n+\tdefault:\n+\t\tswitch len(n.fn.Param) {\n+\t\tcase 2:\n+\t\t\tn.call = func(elms *FullValue, rest interface{}) interface{} {\n+\t\t\t\tn.args[0] = elms.Elm\n+\t\t\t\tn.args[1] = rest\n+\t\t\t\treturn n.fn.Fn.Call(n.args)[0]\n+\t\t\t}\n+\t\tcase 3:\n+\t\t\tn.call = func(elms *FullValue, rest interface{}) interface{} {\n+\t\t\t\tn.args[0] = elms.Elm\n+\t\t\t\tn.args[1] = elms.Elm2\n+\t\t\t\tn.args[2] = rest\n+\t\t\t\treturn n.fn.Fn.Call(n.args)[0]\n+\t\t\t}\n+\t\tdefault:\n+\t\t\treturn errors.Errorf(\"SplitRestriction fn %v has unexpected number of parameters: %v\",\n+\t\t\t\tn.fn.Fn.Name(), len(n.fn.Param))\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// Invoke calls SplitRestriction given a FullValue containing an element and\n+// the associated restriction, and returns a slice of split restrictions.\n+func (n *srInvoker) Invoke(elms *FullValue, rest interface{}) (split []interface{}) {\n+\tret := n.call(elms, rest)\n+\n+\t// Return value is an interface{}, but we need to convert it to a []interface{}.\n+\tval := reflect.ValueOf(ret)\n+\ts := make([]interface{}, 0, val.Len())\n+\tfor i := 0; i < val.Len(); i++ {\n+\t\ts = append(s, val.Index(i).Interface())\n+\t}\n+\treturn s\n+}\n+\n+// Reset zeroes argument entries in the cached slice to allow values to be\n+// garbage collected after the bundle ends.\n+func (n *srInvoker) Reset() {\n+\tfor i := range n.args {\n+\t\tn.args[i] = nil\n+\t}\n+}\n+\n+// rsInvoker is an invoker for RestrictionSize.\n+type rsInvoker struct {\n+\tfn   *funcx.Fn\n+\targs []interface{} // Cache to avoid allocating new slices per-element.\n+\tcall func(elms *FullValue, rest interface{}) (size float64)\n+}\n+\n+func newRestrictionSizeInvoker(fn *funcx.Fn) (*rsInvoker, error) {\n+\tn := &rsInvoker{\n+\t\tfn:   fn,\n+\t\targs: make([]interface{}, len(fn.Param)),\n+\t}\n+\tif err := n.initCallFn(); err != nil {\n+\t\treturn nil, errors.WithContext(err, \"sdf RestrictionSize invoker\")\n+\t}\n+\treturn n, nil\n+}\n+\n+func (n *rsInvoker) initCallFn() error {\n+\t// Expects a signature of the form:\n+\t// (key?, value, restriction) float64\n+\t// TODO(BEAM-9643): Link to full documentation.\n+\tswitch fnT := n.fn.Fn.(type) {\n+\tcase reflectx.Func2x1:\n+\t\tn.call = func(elms *FullValue, rest interface{}) float64 {\n+\t\t\treturn fnT.Call2x1(elms.Elm, rest).(float64)\n+\t\t}\n+\tcase reflectx.Func3x1:\n+\t\tn.call = func(elms *FullValue, rest interface{}) float64 {\n+\t\t\treturn fnT.Call3x1(elms.Elm, elms.Elm2, rest).(float64)\n+\t\t}\n+\tdefault:\n+\t\tswitch len(n.fn.Param) {\n+\t\tcase 2:\n+\t\t\tn.call = func(elms *FullValue, rest interface{}) float64 {\n+\t\t\t\tn.args[0] = elms.Elm\n+\t\t\t\tn.args[1] = rest\n+\t\t\t\treturn n.fn.Fn.Call(n.args)[0].(float64)\n+\t\t\t}\n+\t\tcase 3:\n+\t\t\tn.call = func(elms *FullValue, rest interface{}) float64 {\n+\t\t\t\tn.args[0] = elms.Elm\n+\t\t\t\tn.args[1] = elms.Elm2\n+\t\t\t\tn.args[2] = rest\n+\t\t\t\treturn n.fn.Fn.Call(n.args)[0].(float64)\n+\t\t\t}\n+\t\tdefault:\n+\t\t\treturn errors.Errorf(\"RestrictionSize fn %v has unexpected number of parameters: %v\",\n+\t\t\t\tn.fn.Fn.Name(), len(n.fn.Param))\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// Invoke calls RestrictionSize given a FullValue containing an element and\n+// the associated restriction, and returns a size.\n+func (n *rsInvoker) Invoke(elms *FullValue, rest interface{}) (size float64) {\n+\treturn n.call(elms, rest)\n+}\n+\n+// Reset zeroes argument entries in the cached slice to allow values to be\n+// garbage collected after the bundle ends.\n+func (n *rsInvoker) Reset() {\n+\tfor i := range n.args {\n+\t\tn.args[i] = nil\n+\t}\n+}\n+\n+// ctInvoker is an invoker for CreateTracker.\n+type ctInvoker struct {\n+\tfn   *funcx.Fn\n+\targs []interface{} // Cache to avoid allocating new slices per-element.\n+\tcall func(rest interface{}) (tracker sdf.RTracker)\n+}\n+\n+func newCreateTrackerInvoker(fn *funcx.Fn) (*ctInvoker, error) {\n+\tn := &ctInvoker{\n+\t\tfn:   fn,\n+\t\targs: make([]interface{}, len(fn.Param)),\n+\t}\n+\tif err := n.initCallFn(); err != nil {\n+\t\treturn nil, errors.WithContext(err, \"sdf CreateTracker invoker\")\n+\t}\n+\treturn n, nil\n+}\n+\n+func (n *ctInvoker) initCallFn() error {\n+\t// Expects a signature of the form:\n+\t// (restriction) sdf.RTracker\n+\t// TODO(BEAM-9643): Link to full documentation.\n+\tswitch fnT := n.fn.Fn.(type) {\n+\tcase reflectx.Func1x1:\n+\t\tn.call = func(rest interface{}) sdf.RTracker {\n+\t\t\treturn fnT.Call1x1(rest).(sdf.RTracker)\n+\t\t}\n+\tdefault:\n+\t\tif len(n.fn.Param) != 1 {\n+\t\t\treturn errors.Errorf(\"CreateTracker fn %v has unexpected number of parameters: %v\",\n+\t\t\t\tn.fn.Fn.Name(), len(n.fn.Param))\n+\t\t}\n+\t\tn.call = func(rest interface{}) sdf.RTracker {\n+\t\t\tn.args[0] = rest\n+\t\t\treturn n.fn.Fn.Call(n.args)[0].(sdf.RTracker)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// Invoke calls CreateTracker given a restriction and returns an sdf.RTracker.\n+// the associated restriction, and returns a size.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "580b6ab2c8894421ff51f42f43c5b4fc714165d9"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgzNTM4Mw==", "bodyText": "eg. This is a great use of a named return value to add clarity.\nI'd call it \"splits\" though, since it's a slice and there could be more than one.", "url": "https://github.com/apache/beam/pull/11257#discussion_r401835383", "createdAt": "2020-04-01T18:50:38Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/sdf_invokers.go", "diffHunk": "@@ -0,0 +1,302 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package exec\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/funcx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/sdf\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/reflectx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+\t\"reflect\"\n+)\n+\n+// This file contains invokers for SDF methods. These invokers are based off\n+// exec.invoker which is used for regular DoFns. Since exec.invoker is\n+// specialized for DoFns it cannot be used for SDF methods. Instead, these\n+// invokers pare down the functionality to only what is essential for\n+// executing SDF methods, including per-element optimizations.\n+//\n+// Each SDF method invoker in this file is specific to a certain method, but\n+// they are all used the same way. Create an invoker with new[Method]Invoker\n+// in the Up method of an exec.Unit, and then invoke it with Invoke. Finally,\n+// call Reset on it when the bundle ends in FinishBundle.\n+//\n+// These invokers are not thread-safe.\n+\n+// cirInvoker is an invoker for CreateInitialRestriction.\n+type cirInvoker struct {\n+\tfn   *funcx.Fn\n+\targs []interface{} // Cache to avoid allocating new slices per-element.\n+\tcall func(elms *FullValue) (rest interface{})\n+}\n+\n+func newCreateInitialRestrictionInvoker(fn *funcx.Fn) (*cirInvoker, error) {\n+\tn := &cirInvoker{\n+\t\tfn:   fn,\n+\t\targs: make([]interface{}, len(fn.Param)),\n+\t}\n+\tif err := n.initCallFn(); err != nil {\n+\t\treturn nil, errors.WithContext(err, \"sdf CreateInitialRestriction invoker\")\n+\t}\n+\treturn n, nil\n+}\n+\n+func (n *cirInvoker) initCallFn() error {\n+\t// Expects a signature of the form:\n+\t// (key?, value) restriction\n+\t// TODO(BEAM-9643): Link to full documentation.\n+\tswitch fnT := n.fn.Fn.(type) {\n+\tcase reflectx.Func1x1:\n+\t\tn.call = func(elms *FullValue) interface{} {\n+\t\t\treturn fnT.Call1x1(elms.Elm)\n+\t\t}\n+\tcase reflectx.Func2x1:\n+\t\tn.call = func(elms *FullValue) interface{} {\n+\t\t\treturn fnT.Call2x1(elms.Elm, elms.Elm2)\n+\t\t}\n+\tdefault:\n+\t\tswitch len(n.fn.Param) {\n+\t\tcase 1:\n+\t\t\tn.call = func(elms *FullValue) interface{} {\n+\t\t\t\tn.args[0] = elms.Elm\n+\t\t\t\treturn n.fn.Fn.Call(n.args)[0]\n+\t\t\t}\n+\t\tcase 2:\n+\t\t\tn.call = func(elms *FullValue) interface{} {\n+\t\t\t\tn.args[0] = elms.Elm\n+\t\t\t\tn.args[1] = elms.Elm2\n+\t\t\t\treturn n.fn.Fn.Call(n.args)[0]\n+\t\t\t}\n+\t\tdefault:\n+\t\t\treturn errors.Errorf(\"CreateInitialRestriction fn %v has unexpected number of parameters: %v\",\n+\t\t\t\tn.fn.Fn.Name(), len(n.fn.Param))\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// Invoke calls CreateInitialRestriction with the given FullValue as the element\n+// and returns the resulting restriction.\n+func (n *cirInvoker) Invoke(elms *FullValue) (rest interface{}) {\n+\treturn n.call(elms)\n+}\n+\n+// Reset zeroes argument entries in the cached slice to allow values to be\n+// garbage collected after the bundle ends.\n+func (n *cirInvoker) Reset() {\n+\tfor i := range n.args {\n+\t\tn.args[i] = nil\n+\t}\n+}\n+\n+// srInvoker is an invoker for SplitRestriction.\n+type srInvoker struct {\n+\tfn   *funcx.Fn\n+\targs []interface{} // Cache to avoid allocating new slices per-element.\n+\tcall func(elms *FullValue, rest interface{}) (split interface{})\n+}\n+\n+func newSplitRestrictionInvoker(fn *funcx.Fn) (*srInvoker, error) {\n+\tn := &srInvoker{\n+\t\tfn:   fn,\n+\t\targs: make([]interface{}, len(fn.Param)),\n+\t}\n+\tif err := n.initCallFn(); err != nil {\n+\t\treturn nil, errors.WithContext(err, \"sdf SplitRestriction invoker\")\n+\t}\n+\treturn n, nil\n+}\n+\n+func (n *srInvoker) initCallFn() error {\n+\t// Expects a signature of the form:\n+\t// (key?, value, restriction) []restriction\n+\t// TODO(BEAM-9643): Link to full documentation.\n+\tswitch fnT := n.fn.Fn.(type) {\n+\tcase reflectx.Func2x1:\n+\t\tn.call = func(elms *FullValue, rest interface{}) interface{} {\n+\t\t\treturn fnT.Call2x1(elms.Elm, rest)\n+\t\t}\n+\tcase reflectx.Func3x1:\n+\t\tn.call = func(elms *FullValue, rest interface{}) interface{} {\n+\t\t\treturn fnT.Call3x1(elms.Elm, elms.Elm2, rest)\n+\t\t}\n+\tdefault:\n+\t\tswitch len(n.fn.Param) {\n+\t\tcase 2:\n+\t\t\tn.call = func(elms *FullValue, rest interface{}) interface{} {\n+\t\t\t\tn.args[0] = elms.Elm\n+\t\t\t\tn.args[1] = rest\n+\t\t\t\treturn n.fn.Fn.Call(n.args)[0]\n+\t\t\t}\n+\t\tcase 3:\n+\t\t\tn.call = func(elms *FullValue, rest interface{}) interface{} {\n+\t\t\t\tn.args[0] = elms.Elm\n+\t\t\t\tn.args[1] = elms.Elm2\n+\t\t\t\tn.args[2] = rest\n+\t\t\t\treturn n.fn.Fn.Call(n.args)[0]\n+\t\t\t}\n+\t\tdefault:\n+\t\t\treturn errors.Errorf(\"SplitRestriction fn %v has unexpected number of parameters: %v\",\n+\t\t\t\tn.fn.Fn.Name(), len(n.fn.Param))\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// Invoke calls SplitRestriction given a FullValue containing an element and\n+// the associated restriction, and returns a slice of split restrictions.\n+func (n *srInvoker) Invoke(elms *FullValue, rest interface{}) (split []interface{}) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "580b6ab2c8894421ff51f42f43c5b4fc714165d9"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgzNjA5NQ==", "bodyText": "remove empty init block?", "url": "https://github.com/apache/beam/pull/11257#discussion_r401836095", "createdAt": "2020-04-01T18:51:52Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/sdf_invokers_test.go", "diffHunk": "@@ -0,0 +1,282 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package exec\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n+\t\"github.com/google/go-cmp/cmp\"\n+\t\"testing\"\n+)\n+\n+func init() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "580b6ab2c8894421ff51f42f43c5b4fc714165d9"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d02e4ba5aba6243b0085780800d97c0c85da873", "author": {"user": {"login": "youngoli", "name": "Daniel Oliveira"}}, "url": "https://github.com/apache/beam/commit/4d02e4ba5aba6243b0085780800d97c0c85da873", "committedDate": "2020-04-01T23:15:23Z", "message": "[BEAM-9642] Create runtime invokers for SDF methods.\n\nAdds runtime invokers for the various SDF-specific methods. These\ninvokers will need to be used for executing expanded SDF URNs, and\ncurrently the normal Invoker code is too specific to non-splittable\nDoFns to be used for this purpose, so these custom invokers are needed."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "580b6ab2c8894421ff51f42f43c5b4fc714165d9", "author": {"user": {"login": "youngoli", "name": "Daniel Oliveira"}}, "url": "https://github.com/apache/beam/commit/580b6ab2c8894421ff51f42f43c5b4fc714165d9", "committedDate": "2020-03-31T02:39:33Z", "message": "[BEAM-9642] Optimize invokers."}, "afterCommit": {"oid": "4d02e4ba5aba6243b0085780800d97c0c85da873", "author": {"user": {"login": "youngoli", "name": "Daniel Oliveira"}}, "url": "https://github.com/apache/beam/commit/4d02e4ba5aba6243b0085780800d97c0c85da873", "committedDate": "2020-04-01T23:15:23Z", "message": "[BEAM-9642] Create runtime invokers for SDF methods.\n\nAdds runtime invokers for the various SDF-specific methods. These\ninvokers will need to be used for executing expanded SDF URNs, and\ncurrently the normal Invoker code is too specific to non-splittable\nDoFns to be used for this purpose, so these custom invokers are needed."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4759, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}