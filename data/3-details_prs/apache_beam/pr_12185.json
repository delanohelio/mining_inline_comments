{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1MDE1NzQy", "number": 12185, "title": "[BEAM-10409] Add combiner packing to graph optimizer phases", "bodyText": "Adds pack_combiners graph optimization phases to the translations module. This allows  packs compatible CombinePerKey stages with a common input into a single stage. This improves performance for use cases of Beam that create thousands of Combine stages with a common input.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nDataflow\nFlink\nSamza\nSpark\nTwister2\n\n\n\n\nGo\n\n---\n\n---\n\n---\n\n\nJava\n\n\n\n\n\n\n\n\nPython\n\n\n\n---\n\n---\n\n\nXLang\n---\n---\n\n---\n\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-07-06T21:38:42Z", "url": "https://github.com/apache/beam/pull/12185", "merged": true, "mergeCommit": {"oid": "2e77e46d35e4e37cc3953cc3a725fe94b12cde08"}, "closed": true, "closedAt": "2020-08-28T16:09:30Z", "author": {"login": "yifanmai"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcy_N6vgFqTQ0NTAwMzE5OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdDH6bpAH2gAyNDQ1MDE1NzQyOmUwMmUwOWI5ZGVhZDBjOGMxMWZjZjQ1NGNkYTAyZmE2N2RiNTgzMmU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MDAzMTk4", "url": "https://github.com/apache/beam/pull/12185#pullrequestreview-445003198", "createdAt": "2020-07-08T17:56:37Z", "commit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxNzo1NjozN1rOGuzOng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxODo1ODo1NFrOGu1ULA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcyNzAwNg==", "bodyText": "This transform is not safe to do ubiquitously (due to the possibility of side effects).", "url": "https://github.com/apache/beam/pull/12185#discussion_r451727006", "createdAt": "2020-07-08T17:56:37Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -289,6 +289,8 @@ def create_stages(\n         phases=[\n             translations.annotate_downstream_side_inputs,\n             translations.fix_side_input_pcoll_coders,\n+            translations.eliminate_common_siblings,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcyODE5Ng==", "bodyText": "One can omit the environment here--if two specs and payloads are identical, they are the same operation.", "url": "https://github.com/apache/beam/pull/12185#discussion_r451728196", "createdAt": "2020-07-08T17:58:40Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -685,6 +687,264 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def eliminate_common_siblings(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterable[Stage]\n+  \"\"\"Runs common subexpression elimination for common siblings.\n+\n+  If stages have common input, an identical transform, and one output each,\n+  then all but one stages will be eliminated, and the output of the remaining\n+  will be connected to the original output PCollections of the eliminated\n+  stages. This elimination runs only once, not recursively, and will only\n+  eliminate the first stage after a common input, rather than a chain of\n+  stages.\n+  \"\"\"\n+\n+  SiblingKey = collections.namedtuple(\n+      'SiblingKey', ['spec_urn', 'spec_payload', 'inputs', 'environment_id'])\n+\n+  def get_sibling_key(transform):\n+    \"\"\"Returns a key that will be identical for common siblings.\"\"\"\n+    transform_output_keys = list(transform.outputs.keys())\n+    # Return None as the sibling key for ineligible transforms.\n+    if len(transform_output_keys\n+          ) != 1 or transform.spec.urn != common_urns.primitives.PAR_DO.urn:\n+      return None\n+    return SiblingKey(\n+        spec_urn=transform.spec.urn,\n+        spec_payload=transform.spec.payload,\n+        inputs=tuple(transform.inputs.items()),\n+        environment_id=transform.environment_id)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcyOTMyMA==", "bodyText": "(Just a thought) I wonder if this should be a global tracked in the context for being able to properly reconstruct composites.", "url": "https://github.com/apache/beam/pull/12185#discussion_r451729320", "createdAt": "2020-07-08T18:00:35Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -685,6 +687,264 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def eliminate_common_siblings(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterable[Stage]\n+  \"\"\"Runs common subexpression elimination for common siblings.\n+\n+  If stages have common input, an identical transform, and one output each,\n+  then all but one stages will be eliminated, and the output of the remaining\n+  will be connected to the original output PCollections of the eliminated\n+  stages. This elimination runs only once, not recursively, and will only\n+  eliminate the first stage after a common input, rather than a chain of\n+  stages.\n+  \"\"\"\n+\n+  SiblingKey = collections.namedtuple(\n+      'SiblingKey', ['spec_urn', 'spec_payload', 'inputs', 'environment_id'])\n+\n+  def get_sibling_key(transform):\n+    \"\"\"Returns a key that will be identical for common siblings.\"\"\"\n+    transform_output_keys = list(transform.outputs.keys())\n+    # Return None as the sibling key for ineligible transforms.\n+    if len(transform_output_keys\n+          ) != 1 or transform.spec.urn != common_urns.primitives.PAR_DO.urn:\n+      return None\n+    return SiblingKey(\n+        spec_urn=transform.spec.urn,\n+        spec_payload=transform.spec.payload,\n+        inputs=tuple(transform.inputs.items()),\n+        environment_id=transform.environment_id)\n+\n+  # Group stages by keys.\n+  stages_by_sibling_key = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    stages_by_sibling_key[get_sibling_key(transform)].append(stage)\n+\n+  # Eliminate stages and build the output PCollection remapping dictionary.\n+  pcoll_id_remap = {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc1ODc0Mg==", "bodyText": "Was this copied from above? If needed, perhaps refactor? (Similarly for try_fuse_stages.)", "url": "https://github.com/apache/beam/pull/12185#discussion_r451758742", "createdAt": "2020-07-08T18:54:20Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -685,6 +687,264 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def eliminate_common_siblings(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterable[Stage]\n+  \"\"\"Runs common subexpression elimination for common siblings.\n+\n+  If stages have common input, an identical transform, and one output each,\n+  then all but one stages will be eliminated, and the output of the remaining\n+  will be connected to the original output PCollections of the eliminated\n+  stages. This elimination runs only once, not recursively, and will only\n+  eliminate the first stage after a common input, rather than a chain of\n+  stages.\n+  \"\"\"\n+\n+  SiblingKey = collections.namedtuple(\n+      'SiblingKey', ['spec_urn', 'spec_payload', 'inputs', 'environment_id'])\n+\n+  def get_sibling_key(transform):\n+    \"\"\"Returns a key that will be identical for common siblings.\"\"\"\n+    transform_output_keys = list(transform.outputs.keys())\n+    # Return None as the sibling key for ineligible transforms.\n+    if len(transform_output_keys\n+          ) != 1 or transform.spec.urn != common_urns.primitives.PAR_DO.urn:\n+      return None\n+    return SiblingKey(\n+        spec_urn=transform.spec.urn,\n+        spec_payload=transform.spec.payload,\n+        inputs=tuple(transform.inputs.items()),\n+        environment_id=transform.environment_id)\n+\n+  # Group stages by keys.\n+  stages_by_sibling_key = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    stages_by_sibling_key[get_sibling_key(transform)].append(stage)\n+\n+  # Eliminate stages and build the output PCollection remapping dictionary.\n+  pcoll_id_remap = {}\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    if sibling_key is None or len(sibling_stages) == 1:\n+      continue\n+    output_pcoll_ids = [\n+        only_element(stage.transforms[0].outputs.values())\n+        for stage in sibling_stages\n+    ]\n+    to_delete_pcoll_ids = output_pcoll_ids[1:]\n+    for to_delete_pcoll_id in to_delete_pcoll_ids:\n+      pcoll_id_remap[to_delete_pcoll_id] = output_pcoll_ids[0]\n+      del context.components.pcollections[to_delete_pcoll_id]\n+    del sibling_stages[1:]\n+\n+  # Yield stages while remapping output PCollections if needed.\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    for stage in sibling_stages:\n+      input_keys_to_remap = []\n+      for input_key, input_pcoll_id in stage.transforms[0].inputs.items():\n+        if input_pcoll_id in pcoll_id_remap:\n+          input_keys_to_remap.append(input_key)\n+      for input_key_to_remap in input_keys_to_remap:\n+        stage.transforms[0].inputs[input_key_to_remap] = pcoll_id_remap[\n+            stage.transforms[0].inputs[input_key_to_remap]]\n+      yield stage\n+\n+\n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  def _try_merge_environments(env1, env2):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MDY3OQ==", "bodyText": "This will only work for Python combine fns (and should be guarded against that).", "url": "https://github.com/apache/beam/pull/12185#discussion_r451760679", "createdAt": "2020-07-08T18:57:58Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -685,6 +687,264 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def eliminate_common_siblings(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterable[Stage]\n+  \"\"\"Runs common subexpression elimination for common siblings.\n+\n+  If stages have common input, an identical transform, and one output each,\n+  then all but one stages will be eliminated, and the output of the remaining\n+  will be connected to the original output PCollections of the eliminated\n+  stages. This elimination runs only once, not recursively, and will only\n+  eliminate the first stage after a common input, rather than a chain of\n+  stages.\n+  \"\"\"\n+\n+  SiblingKey = collections.namedtuple(\n+      'SiblingKey', ['spec_urn', 'spec_payload', 'inputs', 'environment_id'])\n+\n+  def get_sibling_key(transform):\n+    \"\"\"Returns a key that will be identical for common siblings.\"\"\"\n+    transform_output_keys = list(transform.outputs.keys())\n+    # Return None as the sibling key for ineligible transforms.\n+    if len(transform_output_keys\n+          ) != 1 or transform.spec.urn != common_urns.primitives.PAR_DO.urn:\n+      return None\n+    return SiblingKey(\n+        spec_urn=transform.spec.urn,\n+        spec_payload=transform.spec.payload,\n+        inputs=tuple(transform.inputs.items()),\n+        environment_id=transform.environment_id)\n+\n+  # Group stages by keys.\n+  stages_by_sibling_key = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    stages_by_sibling_key[get_sibling_key(transform)].append(stage)\n+\n+  # Eliminate stages and build the output PCollection remapping dictionary.\n+  pcoll_id_remap = {}\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    if sibling_key is None or len(sibling_stages) == 1:\n+      continue\n+    output_pcoll_ids = [\n+        only_element(stage.transforms[0].outputs.values())\n+        for stage in sibling_stages\n+    ]\n+    to_delete_pcoll_ids = output_pcoll_ids[1:]\n+    for to_delete_pcoll_id in to_delete_pcoll_ids:\n+      pcoll_id_remap[to_delete_pcoll_id] = output_pcoll_ids[0]\n+      del context.components.pcollections[to_delete_pcoll_id]\n+    del sibling_stages[1:]\n+\n+  # Yield stages while remapping output PCollections if needed.\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    for stage in sibling_stages:\n+      input_keys_to_remap = []\n+      for input_key, input_pcoll_id in stage.transforms[0].inputs.items():\n+        if input_pcoll_id in pcoll_id_remap:\n+          input_keys_to_remap.append(input_key)\n+      for input_key_to_remap in input_keys_to_remap:\n+        stage.transforms[0].inputs[input_key_to_remap] = pcoll_id_remap[\n+            stage.transforms[0].inputs[input_key_to_remap]]\n+      yield stage\n+\n+\n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  def _try_merge_environments(env1, env2):\n+    if env1 is None:\n+      return env2\n+    elif env2 is None:\n+      return env1\n+    else:\n+      if env1 != env2:\n+        raise ValueError\n+      return env1\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(\n+          _try_merge_environments,\n+          [transform.environment_id or None for transform in transforms])\n+    except ValueError:\n+      for stage in packable_stages:\n+        yield stage\n+      continue\n+\n+    output_pcoll_ids = [\n+        only_element(transform.outputs.values()) for transform in transforms\n+    ]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Build accumulator coder for (acc1, acc2, ...)\n+    accumulator_coder_ids = [\n+        combine_payload.accumulator_coder_id\n+        for combine_payload in combine_payloads\n+    ]\n+    tuple_accumulator_coder_id = context.add_or_get_coder_id(\n+        beam_runner_api_pb2.Coder(\n+            spec=beam_runner_api_pb2.FunctionSpec(\n+                urn=common_urns.coders.KV.urn),\n+            component_coder_ids=accumulator_coder_ids))\n+\n+    # Build packed output coder for (key, (out1, out2, ...))\n+    input_kv_coder_id = context.components.pcollections[input_pcoll_id].coder_id\n+    key_coder_id = _get_key_coder_id_from_kv_coder(\n+        context.components.coders[input_kv_coder_id])\n+    output_kv_coder_ids = [\n+        context.components.pcollections[output_pcoll_id].coder_id\n+        for output_pcoll_id in output_pcoll_ids\n+    ]\n+    output_value_coder_ids = [\n+        _get_value_coder_id_from_kv_coder(\n+            context.components.coders[output_kv_coder_id])\n+        for output_kv_coder_id in output_kv_coder_ids\n+    ]\n+    pack_output_value_coder = beam_runner_api_pb2.Coder(\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        component_coder_ids=output_value_coder_ids)\n+    pack_output_value_coder_id = context.add_or_get_coder_id(\n+        pack_output_value_coder)\n+    pack_output_kv_coder = beam_runner_api_pb2.Coder(\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        component_coder_ids=[key_coder_id, pack_output_value_coder_id])\n+    pack_output_kv_coder_id = context.add_or_get_coder_id(pack_output_kv_coder)\n+\n+    # Set up packed PCollection\n+    pack_combine_name = fused_stage.name\n+    pack_pcoll_id = unique_name(context.components.pcollections, 'pcollection')\n+    input_pcoll = context.components.pcollections[input_pcoll_id]\n+    context.components.pcollections[pack_pcoll_id].CopyFrom(\n+        beam_runner_api_pb2.PCollection(\n+            unique_name=pack_combine_name + '.out',\n+            coder_id=pack_output_kv_coder_id,\n+            windowing_strategy_id=input_pcoll.windowing_strategy_id,\n+            is_bounded=input_pcoll.is_bounded))\n+\n+    # Set up Pack stage.\n+    pack_combine_fn = combiners.SingleInputTupleCombineFn(*[\n+        core.CombineFn.from_runner_api(combine_payload.combine_fn, context)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTE5Ng==", "bodyText": "Similarly, this environment must be a Python environment for this to work.", "url": "https://github.com/apache/beam/pull/12185#discussion_r451761196", "createdAt": "2020-07-08T18:58:54Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -685,6 +687,264 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def eliminate_common_siblings(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterable[Stage]\n+  \"\"\"Runs common subexpression elimination for common siblings.\n+\n+  If stages have common input, an identical transform, and one output each,\n+  then all but one stages will be eliminated, and the output of the remaining\n+  will be connected to the original output PCollections of the eliminated\n+  stages. This elimination runs only once, not recursively, and will only\n+  eliminate the first stage after a common input, rather than a chain of\n+  stages.\n+  \"\"\"\n+\n+  SiblingKey = collections.namedtuple(\n+      'SiblingKey', ['spec_urn', 'spec_payload', 'inputs', 'environment_id'])\n+\n+  def get_sibling_key(transform):\n+    \"\"\"Returns a key that will be identical for common siblings.\"\"\"\n+    transform_output_keys = list(transform.outputs.keys())\n+    # Return None as the sibling key for ineligible transforms.\n+    if len(transform_output_keys\n+          ) != 1 or transform.spec.urn != common_urns.primitives.PAR_DO.urn:\n+      return None\n+    return SiblingKey(\n+        spec_urn=transform.spec.urn,\n+        spec_payload=transform.spec.payload,\n+        inputs=tuple(transform.inputs.items()),\n+        environment_id=transform.environment_id)\n+\n+  # Group stages by keys.\n+  stages_by_sibling_key = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    stages_by_sibling_key[get_sibling_key(transform)].append(stage)\n+\n+  # Eliminate stages and build the output PCollection remapping dictionary.\n+  pcoll_id_remap = {}\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    if sibling_key is None or len(sibling_stages) == 1:\n+      continue\n+    output_pcoll_ids = [\n+        only_element(stage.transforms[0].outputs.values())\n+        for stage in sibling_stages\n+    ]\n+    to_delete_pcoll_ids = output_pcoll_ids[1:]\n+    for to_delete_pcoll_id in to_delete_pcoll_ids:\n+      pcoll_id_remap[to_delete_pcoll_id] = output_pcoll_ids[0]\n+      del context.components.pcollections[to_delete_pcoll_id]\n+    del sibling_stages[1:]\n+\n+  # Yield stages while remapping output PCollections if needed.\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    for stage in sibling_stages:\n+      input_keys_to_remap = []\n+      for input_key, input_pcoll_id in stage.transforms[0].inputs.items():\n+        if input_pcoll_id in pcoll_id_remap:\n+          input_keys_to_remap.append(input_key)\n+      for input_key_to_remap in input_keys_to_remap:\n+        stage.transforms[0].inputs[input_key_to_remap] = pcoll_id_remap[\n+            stage.transforms[0].inputs[input_key_to_remap]]\n+      yield stage\n+\n+\n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  def _try_merge_environments(env1, env2):\n+    if env1 is None:\n+      return env2\n+    elif env2 is None:\n+      return env1\n+    else:\n+      if env1 != env2:\n+        raise ValueError\n+      return env1\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(\n+          _try_merge_environments,\n+          [transform.environment_id or None for transform in transforms])\n+    except ValueError:\n+      for stage in packable_stages:\n+        yield stage\n+      continue\n+\n+    output_pcoll_ids = [\n+        only_element(transform.outputs.values()) for transform in transforms\n+    ]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Build accumulator coder for (acc1, acc2, ...)\n+    accumulator_coder_ids = [\n+        combine_payload.accumulator_coder_id\n+        for combine_payload in combine_payloads\n+    ]\n+    tuple_accumulator_coder_id = context.add_or_get_coder_id(\n+        beam_runner_api_pb2.Coder(\n+            spec=beam_runner_api_pb2.FunctionSpec(\n+                urn=common_urns.coders.KV.urn),\n+            component_coder_ids=accumulator_coder_ids))\n+\n+    # Build packed output coder for (key, (out1, out2, ...))\n+    input_kv_coder_id = context.components.pcollections[input_pcoll_id].coder_id\n+    key_coder_id = _get_key_coder_id_from_kv_coder(\n+        context.components.coders[input_kv_coder_id])\n+    output_kv_coder_ids = [\n+        context.components.pcollections[output_pcoll_id].coder_id\n+        for output_pcoll_id in output_pcoll_ids\n+    ]\n+    output_value_coder_ids = [\n+        _get_value_coder_id_from_kv_coder(\n+            context.components.coders[output_kv_coder_id])\n+        for output_kv_coder_id in output_kv_coder_ids\n+    ]\n+    pack_output_value_coder = beam_runner_api_pb2.Coder(\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        component_coder_ids=output_value_coder_ids)\n+    pack_output_value_coder_id = context.add_or_get_coder_id(\n+        pack_output_value_coder)\n+    pack_output_kv_coder = beam_runner_api_pb2.Coder(\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        component_coder_ids=[key_coder_id, pack_output_value_coder_id])\n+    pack_output_kv_coder_id = context.add_or_get_coder_id(pack_output_kv_coder)\n+\n+    # Set up packed PCollection\n+    pack_combine_name = fused_stage.name\n+    pack_pcoll_id = unique_name(context.components.pcollections, 'pcollection')\n+    input_pcoll = context.components.pcollections[input_pcoll_id]\n+    context.components.pcollections[pack_pcoll_id].CopyFrom(\n+        beam_runner_api_pb2.PCollection(\n+            unique_name=pack_combine_name + '.out',\n+            coder_id=pack_output_kv_coder_id,\n+            windowing_strategy_id=input_pcoll.windowing_strategy_id,\n+            is_bounded=input_pcoll.is_bounded))\n+\n+    # Set up Pack stage.\n+    pack_combine_fn = combiners.SingleInputTupleCombineFn(*[\n+        core.CombineFn.from_runner_api(combine_payload.combine_fn, context)\n+        for combine_payload in combine_payloads\n+    ]).to_runner_api(context)\n+    pack_transform = beam_runner_api_pb2.PTransform(\n+        unique_name=pack_combine_name + '/Pack',\n+        spec=beam_runner_api_pb2.FunctionSpec(\n+            urn=common_urns.composites.COMBINE_PER_KEY.urn,\n+            payload=beam_runner_api_pb2.CombinePayload(\n+                combine_fn=pack_combine_fn,\n+                accumulator_coder_id=tuple_accumulator_coder_id)\n+            .SerializeToString()),\n+        inputs={'in': input_pcoll_id},\n+        outputs={'out': pack_pcoll_id},\n+        environment_id=merged_transform_environment_id)\n+    pack_stage = Stage(\n+        pack_combine_name + '/Pack', [pack_transform],\n+        downstream_side_inputs=fused_stage.downstream_side_inputs,\n+        must_follow=fused_stage.must_follow,\n+        parent=fused_stage,\n+        environment=fused_stage.environment)\n+    yield pack_stage\n+\n+    # Set up Unpack stage\n+    tags = [str(i) for i in range(len(output_pcoll_ids))]\n+    pickled_do_fn_data = pickler.dumps((_UnpackFn(tags), (), {}, [], None))\n+    unpack_transform = beam_runner_api_pb2.PTransform(\n+        unique_name=pack_combine_name + '/Unpack',\n+        spec=beam_runner_api_pb2.FunctionSpec(\n+            urn=common_urns.primitives.PAR_DO.urn,\n+            payload=beam_runner_api_pb2.ParDoPayload(\n+                do_fn=beam_runner_api_pb2.FunctionSpec(\n+                    urn=python_urns.PICKLED_DOFN_INFO,\n+                    payload=pickled_do_fn_data)).SerializeToString()),\n+        inputs={'in': pack_pcoll_id},\n+        outputs=dict(zip(tags, output_pcoll_ids)),\n+        environment_id=merged_transform_environment_id)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 283}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f0aefe4147b5a8c5920efffd83a58398ade9ac2", "author": {"user": {"login": "yifanmai", "name": "Yifan Mai"}}, "url": "https://github.com/apache/beam/commit/0f0aefe4147b5a8c5920efffd83a58398ade9ac2", "committedDate": "2020-08-05T17:52:51Z", "message": "Add combiner packing to graph optimizer phases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c51c62f51002d3f37821759135e5af8f71703165", "author": {"user": {"login": "yifanmai", "name": "Yifan Mai"}}, "url": "https://github.com/apache/beam/commit/c51c62f51002d3f37821759135e5af8f71703165", "committedDate": "2020-08-05T17:52:51Z", "message": "Remove eliminate_common_siblings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d", "author": {"user": {"login": "yifanmai", "name": "Yifan Mai"}}, "url": "https://github.com/apache/beam/commit/734ce02a824ee44aab69f11484575c013a1faf9d", "committedDate": "2020-08-05T18:20:42Z", "message": "Review fixes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1a7b3557c7b566a12327ee773bd3db216261f060", "author": {"user": {"login": "yifanmai", "name": "Yifan Mai"}}, "url": "https://github.com/apache/beam/commit/1a7b3557c7b566a12327ee773bd3db216261f060", "committedDate": "2020-07-21T02:28:49Z", "message": "Remove eliminate_common_siblings"}, "afterCommit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d", "author": {"user": {"login": "yifanmai", "name": "Yifan Mai"}}, "url": "https://github.com/apache/beam/commit/734ce02a824ee44aab69f11484575c013a1faf9d", "committedDate": "2020-08-05T18:20:42Z", "message": "Review fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDc2NzY5", "url": "https://github.com/apache/beam/pull/12185#pullrequestreview-464476769", "createdAt": "2020-08-10T18:34:37Z", "commit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODozNDozN1rOG-ajog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODo1Mjo0MlrOG-bJiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwMDAwMg==", "bodyText": "We need to group and filter on the environment of the transform as well, lest we try to pack Java or Go combiners here.\nThe easiest way to do that would be to add a \"beam:combinefn:packed_python:v1\" URN at https://github.com/apache/beam/blob/master/sdks/python/apache_beam/portability/python_urns.py , inject it into the list at https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/environments.py#L587 , and then here you can look up the environment attached to the transform, and whether that URN shows up in its capabilities, so see if this is OK.\nI'd be glad to explain more if this doesn't make sense.", "url": "https://github.com/apache/beam/pull/12185#discussion_r468100002", "createdAt": "2020-08-10T18:34:37Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,196 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwMjAwNA==", "bodyText": "Can't we pull this off of the fused_stage?", "url": "https://github.com/apache/beam/pull/12185#discussion_r468102004", "createdAt": "2020-08-10T18:38:19Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,196 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNDQzNQ==", "bodyText": "Oh, I see you are checking for PICKLED_COMBINE_FN below. We should keep this, but the reason it may be insufficient is that one might use PICKLED_COMBINE_FN across different environments. (People using Python 2 transforms of an old version of Beam in Python 3 pipelines is an actual scenario that may come up soon as we're dropping Python 2 support.)", "url": "https://github.com/apache/beam/pull/12185#discussion_r468104435", "createdAt": "2020-08-10T18:42:49Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,196 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwMDAwMg=="}, "originalCommit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNzUzNg==", "bodyText": "OK, so this continue breaks goes back to the next set of packable stages. Just a suggestion: it might be easier to follow if you did all the checking of whether it's OK (e.g. can_fuse, the payload type) above when building these lists, rather than here.", "url": "https://github.com/apache/beam/pull/12185#discussion_r468107536", "createdAt": "2020-08-10T18:48:44Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,196 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(\n+          Stage._merge_environments,\n+          [transform.environment_id or None for transform in transforms])\n+      # Combiner packing only supports Python CombineFns.\n+      for combine_payload in combine_payloads:\n+        if combine_payload.combine_fn.urn != python_urns.PICKLED_COMBINE_FN:\n+          raise ValueError('Combiner packing only supports Python CombineFns')\n+    except ValueError:\n+      for stage in packable_stages:\n+        yield stage\n+      continue", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNzg0MQ==", "bodyText": "Commented above.", "url": "https://github.com/apache/beam/pull/12185#discussion_r468107841", "createdAt": "2020-08-10T18:49:19Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -685,6 +687,264 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def eliminate_common_siblings(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterable[Stage]\n+  \"\"\"Runs common subexpression elimination for common siblings.\n+\n+  If stages have common input, an identical transform, and one output each,\n+  then all but one stages will be eliminated, and the output of the remaining\n+  will be connected to the original output PCollections of the eliminated\n+  stages. This elimination runs only once, not recursively, and will only\n+  eliminate the first stage after a common input, rather than a chain of\n+  stages.\n+  \"\"\"\n+\n+  SiblingKey = collections.namedtuple(\n+      'SiblingKey', ['spec_urn', 'spec_payload', 'inputs', 'environment_id'])\n+\n+  def get_sibling_key(transform):\n+    \"\"\"Returns a key that will be identical for common siblings.\"\"\"\n+    transform_output_keys = list(transform.outputs.keys())\n+    # Return None as the sibling key for ineligible transforms.\n+    if len(transform_output_keys\n+          ) != 1 or transform.spec.urn != common_urns.primitives.PAR_DO.urn:\n+      return None\n+    return SiblingKey(\n+        spec_urn=transform.spec.urn,\n+        spec_payload=transform.spec.payload,\n+        inputs=tuple(transform.inputs.items()),\n+        environment_id=transform.environment_id)\n+\n+  # Group stages by keys.\n+  stages_by_sibling_key = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    stages_by_sibling_key[get_sibling_key(transform)].append(stage)\n+\n+  # Eliminate stages and build the output PCollection remapping dictionary.\n+  pcoll_id_remap = {}\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    if sibling_key is None or len(sibling_stages) == 1:\n+      continue\n+    output_pcoll_ids = [\n+        only_element(stage.transforms[0].outputs.values())\n+        for stage in sibling_stages\n+    ]\n+    to_delete_pcoll_ids = output_pcoll_ids[1:]\n+    for to_delete_pcoll_id in to_delete_pcoll_ids:\n+      pcoll_id_remap[to_delete_pcoll_id] = output_pcoll_ids[0]\n+      del context.components.pcollections[to_delete_pcoll_id]\n+    del sibling_stages[1:]\n+\n+  # Yield stages while remapping output PCollections if needed.\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    for stage in sibling_stages:\n+      input_keys_to_remap = []\n+      for input_key, input_pcoll_id in stage.transforms[0].inputs.items():\n+        if input_pcoll_id in pcoll_id_remap:\n+          input_keys_to_remap.append(input_key)\n+      for input_key_to_remap in input_keys_to_remap:\n+        stage.transforms[0].inputs[input_key_to_remap] = pcoll_id_remap[\n+            stage.transforms[0].inputs[input_key_to_remap]]\n+      yield stage\n+\n+\n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  def _try_merge_environments(env1, env2):\n+    if env1 is None:\n+      return env2\n+    elif env2 is None:\n+      return env1\n+    else:\n+      if env1 != env2:\n+        raise ValueError\n+      return env1\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(\n+          _try_merge_environments,\n+          [transform.environment_id or None for transform in transforms])\n+    except ValueError:\n+      for stage in packable_stages:\n+        yield stage\n+      continue\n+\n+    output_pcoll_ids = [\n+        only_element(transform.outputs.values()) for transform in transforms\n+    ]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Build accumulator coder for (acc1, acc2, ...)\n+    accumulator_coder_ids = [\n+        combine_payload.accumulator_coder_id\n+        for combine_payload in combine_payloads\n+    ]\n+    tuple_accumulator_coder_id = context.add_or_get_coder_id(\n+        beam_runner_api_pb2.Coder(\n+            spec=beam_runner_api_pb2.FunctionSpec(\n+                urn=common_urns.coders.KV.urn),\n+            component_coder_ids=accumulator_coder_ids))\n+\n+    # Build packed output coder for (key, (out1, out2, ...))\n+    input_kv_coder_id = context.components.pcollections[input_pcoll_id].coder_id\n+    key_coder_id = _get_key_coder_id_from_kv_coder(\n+        context.components.coders[input_kv_coder_id])\n+    output_kv_coder_ids = [\n+        context.components.pcollections[output_pcoll_id].coder_id\n+        for output_pcoll_id in output_pcoll_ids\n+    ]\n+    output_value_coder_ids = [\n+        _get_value_coder_id_from_kv_coder(\n+            context.components.coders[output_kv_coder_id])\n+        for output_kv_coder_id in output_kv_coder_ids\n+    ]\n+    pack_output_value_coder = beam_runner_api_pb2.Coder(\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        component_coder_ids=output_value_coder_ids)\n+    pack_output_value_coder_id = context.add_or_get_coder_id(\n+        pack_output_value_coder)\n+    pack_output_kv_coder = beam_runner_api_pb2.Coder(\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        component_coder_ids=[key_coder_id, pack_output_value_coder_id])\n+    pack_output_kv_coder_id = context.add_or_get_coder_id(pack_output_kv_coder)\n+\n+    # Set up packed PCollection\n+    pack_combine_name = fused_stage.name\n+    pack_pcoll_id = unique_name(context.components.pcollections, 'pcollection')\n+    input_pcoll = context.components.pcollections[input_pcoll_id]\n+    context.components.pcollections[pack_pcoll_id].CopyFrom(\n+        beam_runner_api_pb2.PCollection(\n+            unique_name=pack_combine_name + '.out',\n+            coder_id=pack_output_kv_coder_id,\n+            windowing_strategy_id=input_pcoll.windowing_strategy_id,\n+            is_bounded=input_pcoll.is_bounded))\n+\n+    # Set up Pack stage.\n+    pack_combine_fn = combiners.SingleInputTupleCombineFn(*[\n+        core.CombineFn.from_runner_api(combine_payload.combine_fn, context)\n+        for combine_payload in combine_payloads\n+    ]).to_runner_api(context)\n+    pack_transform = beam_runner_api_pb2.PTransform(\n+        unique_name=pack_combine_name + '/Pack',\n+        spec=beam_runner_api_pb2.FunctionSpec(\n+            urn=common_urns.composites.COMBINE_PER_KEY.urn,\n+            payload=beam_runner_api_pb2.CombinePayload(\n+                combine_fn=pack_combine_fn,\n+                accumulator_coder_id=tuple_accumulator_coder_id)\n+            .SerializeToString()),\n+        inputs={'in': input_pcoll_id},\n+        outputs={'out': pack_pcoll_id},\n+        environment_id=merged_transform_environment_id)\n+    pack_stage = Stage(\n+        pack_combine_name + '/Pack', [pack_transform],\n+        downstream_side_inputs=fused_stage.downstream_side_inputs,\n+        must_follow=fused_stage.must_follow,\n+        parent=fused_stage,\n+        environment=fused_stage.environment)\n+    yield pack_stage\n+\n+    # Set up Unpack stage\n+    tags = [str(i) for i in range(len(output_pcoll_ids))]\n+    pickled_do_fn_data = pickler.dumps((_UnpackFn(tags), (), {}, [], None))\n+    unpack_transform = beam_runner_api_pb2.PTransform(\n+        unique_name=pack_combine_name + '/Unpack',\n+        spec=beam_runner_api_pb2.FunctionSpec(\n+            urn=common_urns.primitives.PAR_DO.urn,\n+            payload=beam_runner_api_pb2.ParDoPayload(\n+                do_fn=beam_runner_api_pb2.FunctionSpec(\n+                    urn=python_urns.PICKLED_DOFN_INFO,\n+                    payload=pickled_do_fn_data)).SerializeToString()),\n+        inputs={'in': pack_pcoll_id},\n+        outputs=dict(zip(tags, output_pcoll_ids)),\n+        environment_id=merged_transform_environment_id)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTE5Ng=="}, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwOTcwNQ==", "bodyText": "KV?", "url": "https://github.com/apache/beam/pull/12185#discussion_r468109705", "createdAt": "2020-08-10T18:52:42Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,196 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(\n+          Stage._merge_environments,\n+          [transform.environment_id or None for transform in transforms])\n+      # Combiner packing only supports Python CombineFns.\n+      for combine_payload in combine_payloads:\n+        if combine_payload.combine_fn.urn != python_urns.PICKLED_COMBINE_FN:\n+          raise ValueError('Combiner packing only supports Python CombineFns')\n+    except ValueError:\n+      for stage in packable_stages:\n+        yield stage\n+      continue\n+\n+    output_pcoll_ids = [\n+        only_element(transform.outputs.values()) for transform in transforms\n+    ]\n+\n+    # Build accumulator coder for (acc1, acc2, ...)\n+    accumulator_coder_ids = [\n+        combine_payload.accumulator_coder_id\n+        for combine_payload in combine_payloads\n+    ]\n+    tuple_accumulator_coder_id = context.add_or_get_coder_id(\n+        beam_runner_api_pb2.Coder(\n+            spec=beam_runner_api_pb2.FunctionSpec(\n+                urn=common_urns.coders.KV.urn),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d"}, "originalPosition": 141}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a65c0c4afa7b792fde3e256b7337e4003e6b84c", "author": {"user": {"login": "yifanmai", "name": "Yifan Mai"}}, "url": "https://github.com/apache/beam/commit/4a65c0c4afa7b792fde3e256b7337e4003e6b84c", "committedDate": "2020-08-13T23:48:42Z", "message": "Add environment capability check"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3OTQ2NzI1", "url": "https://github.com/apache/beam/pull/12185#pullrequestreview-467946725", "createdAt": "2020-08-15T04:25:46Z", "commit": {"oid": "4a65c0c4afa7b792fde3e256b7337e4003e6b84c"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwNDoyNTo0NlrOHBHqAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwNDozMjoxNVrOHBHrrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkzNjA2Ng==", "bodyText": "Perhaps key by environment and input pcollection (to not even attempt to fuse across environments).", "url": "https://github.com/apache/beam/pull/12185#discussion_r470936066", "createdAt": "2020-08-15T04:25:46Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,199 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    is_packable_combine = False\n+\n+    if (len(stage.transforms) == 1 and \n+        stage.environment is not None and\n+        python_urns.PACKED_COMBINE_FN in\n+        context.components.environments[stage.environment].capabilities):\n+      transform = only_transform(stage.transforms)\n+      if (transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and\n+          len(transform.inputs) == 1 and\n+          len(transform.outputs) == 1):\n+        combine_payload = proto_utils.parse_Bytes(\n+            transform.spec.payload, beam_runner_api_pb2.CombinePayload)\n+        if combine_payload.combine_fn.urn == python_urns.PICKLED_COMBINE_FN:\n+          is_packable_combine = True\n+\n+    if is_packable_combine:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a65c0c4afa7b792fde3e256b7337e4003e6b84c"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkzNjQ5NQ==", "bodyText": "Technically, a KV coder can only have two components. You may have to make an actual Tuple coder here with a new (again, feel free to do Python-only for now) URN.\nYou should be able to add another Coder.register_urn decorator to https://github.com/apache/beam/blob/release-2.23.0/sdks/python/apache_beam/coders/coders.py#L1029 and it'll just work.", "url": "https://github.com/apache/beam/pull/12185#discussion_r470936495", "createdAt": "2020-08-15T04:32:15Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,196 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(\n+          Stage._merge_environments,\n+          [transform.environment_id or None for transform in transforms])\n+      # Combiner packing only supports Python CombineFns.\n+      for combine_payload in combine_payloads:\n+        if combine_payload.combine_fn.urn != python_urns.PICKLED_COMBINE_FN:\n+          raise ValueError('Combiner packing only supports Python CombineFns')\n+    except ValueError:\n+      for stage in packable_stages:\n+        yield stage\n+      continue\n+\n+    output_pcoll_ids = [\n+        only_element(transform.outputs.values()) for transform in transforms\n+    ]\n+\n+    # Build accumulator coder for (acc1, acc2, ...)\n+    accumulator_coder_ids = [\n+        combine_payload.accumulator_coder_id\n+        for combine_payload in combine_payloads\n+    ]\n+    tuple_accumulator_coder_id = context.add_or_get_coder_id(\n+        beam_runner_api_pb2.Coder(\n+            spec=beam_runner_api_pb2.FunctionSpec(\n+                urn=common_urns.coders.KV.urn),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwOTcwNQ=="}, "originalCommit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d"}, "originalPosition": 141}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff2d4a3983d94ba42afd5b3a6a37549ec293646a", "author": {"user": {"login": "yifanmai", "name": "Yifan Mai"}}, "url": "https://github.com/apache/beam/commit/ff2d4a3983d94ba42afd5b3a6a37549ec293646a", "committedDate": "2020-08-20T20:23:37Z", "message": "Added tuple coder urn"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0ODA2ODYx", "url": "https://github.com/apache/beam/pull/12185#pullrequestreview-474806861", "createdAt": "2020-08-25T19:56:56Z", "commit": {"oid": "ff2d4a3983d94ba42afd5b3a6a37549ec293646a"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxOTo1Njo1NlrOHGnjeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxOTo1OTowNlrOHGnoQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcwMTU2MQ==", "bodyText": "Shouldn't this be python_urns.TUPLE_CODER?", "url": "https://github.com/apache/beam/pull/12185#discussion_r476701561", "createdAt": "2020-08-25T19:56:56Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -818,7 +819,7 @@ def _try_fuse_stages(a, b):\n         for output_kv_coder_id in output_kv_coder_ids\n     ]\n     pack_output_value_coder = beam_runner_api_pb2.Coder(\n-        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=python_urns.tuple.KV.urn),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff2d4a3983d94ba42afd5b3a6a37549ec293646a"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcwMjc4NQ==", "bodyText": "Now use python_urns.TUPLE_CODER here rather than the KV one.", "url": "https://github.com/apache/beam/pull/12185#discussion_r476702785", "createdAt": "2020-08-25T19:59:06Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,200 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent and environment, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    is_packable_combine = False\n+\n+    if (len(stage.transforms) == 1 and\n+        stage.environment is not None and\n+        python_urns.PACKED_COMBINE_FN in\n+        context.components.environments[stage.environment].capabilities):\n+      transform = only_transform(stage.transforms)\n+      if (transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and\n+          len(transform.inputs) == 1 and\n+          len(transform.outputs) == 1):\n+        combine_payload = proto_utils.parse_Bytes(\n+            transform.spec.payload, beam_runner_api_pb2.CombinePayload)\n+        if combine_payload.combine_fn.urn == python_urns.PICKLED_COMBINE_FN:\n+          is_packable_combine = True\n+\n+    if is_packable_combine:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      stage_key = (input_pcoll_id, stage.environment)\n+      combine_stages_by_input_pcoll_id[stage_key].append(stage)\n+    else:\n+      yield stage\n+\n+  for stage_key, packable_stages in combine_stages_by_input_pcoll_id.items():\n+    input_pcoll_id, _ = stage_key\n+    try:\n+      if not len(packable_stages) > 1:\n+        raise ValueError('Only one stage in this group: Skipping stage packing')\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+    except ValueError:\n+      # Skip packing stages in this group.\n+      # Yield the stages unmodified, and then continue to the next group.\n+      for stage in packable_stages:\n+        yield stage\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+    output_pcoll_ids = [\n+        only_element(transform.outputs.values()) for transform in transforms\n+    ]\n+\n+    # Build accumulator coder for (acc1, acc2, ...)\n+    accumulator_coder_ids = [\n+        combine_payload.accumulator_coder_id\n+        for combine_payload in combine_payloads\n+    ]\n+    tuple_accumulator_coder_id = context.add_or_get_coder_id(\n+        beam_runner_api_pb2.Coder(\n+            spec=beam_runner_api_pb2.FunctionSpec(\n+                urn=common_urns.coders.KV.urn),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff2d4a3983d94ba42afd5b3a6a37549ec293646a"}, "originalPosition": 145}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2ab49c6b7941c0be56438891f8ed11078499457", "author": {"user": {"login": "yifanmai", "name": "Yifan Mai"}}, "url": "https://github.com/apache/beam/commit/a2ab49c6b7941c0be56438891f8ed11078499457", "committedDate": "2020-08-26T18:35:09Z", "message": "Use tuple coder URN"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2MDA4Mzgw", "url": "https://github.com/apache/beam/pull/12185#pullrequestreview-476008380", "createdAt": "2020-08-26T22:46:37Z", "commit": {"oid": "a2ab49c6b7941c0be56438891f8ed11078499457"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e3a90e03f635b8901f616f22c4845f0a11614bd", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/9e3a90e03f635b8901f616f22c4845f0a11614bd", "committedDate": "2020-08-26T23:04:06Z", "message": "lint"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e02e09b9dead0c8c11fcf454cda02fa67db5832e", "author": {"user": {"login": "yifanmai", "name": "Yifan Mai"}}, "url": "https://github.com/apache/beam/commit/e02e09b9dead0c8c11fcf454cda02fa67db5832e", "committedDate": "2020-08-27T22:12:10Z", "message": "Merge pull request #2 from robertwb/combiner-packing\n\nlint"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3385, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}