{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1NDc0MDUw", "number": 11645, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxODozOToyOFrOD7AoFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxOToxNjo0MVrOD7A10w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMjAyODM4OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/exec/sdf.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxODozOToyOFrOGTGg0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwMDoyMjoyMFrOGTx2iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY4MjgzNQ==", "bodyText": "Consider just using the auto String() print to add as context instead of adding the extra words. eg. (err, \"%v\", n)", "url": "https://github.com/apache/beam/pull/11645#discussion_r422682835", "createdAt": "2020-05-10T18:39:28Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/sdf.go", "diffHunk": "@@ -313,3 +313,94 @@ func (n *ProcessSizedElementsAndRestrictions) Down(ctx context.Context) error {\n func (n *ProcessSizedElementsAndRestrictions) String() string {\n \treturn fmt.Sprintf(\"SDF.ProcessSizedElementsAndRestrictions[%v] Out:%v\", path.Base(n.PDo.Fn.Name()), IDs(n.PDo.Out...))\n }\n+\n+// SdfFallback is an executor used when an SDF isn't expanded into steps by the\n+// runner, indicating that the runner doesn't support splitting. It executes all\n+// the SDF steps together in one unit.\n+type SdfFallback struct {\n+\tPDo *ParDo\n+\n+\tinitRestInv *cirInvoker\n+\tsplitInv    *srInvoker\n+\ttrackerInv  *ctInvoker\n+}\n+\n+// ID just defers to the ParDo's ID method.\n+func (n *SdfFallback) ID() UnitID {\n+\treturn n.PDo.UID\n+}\n+\n+// Up performs some one-time setup and then defers to the ParDo's Up method.\n+func (n *SdfFallback) Up(ctx context.Context) error {\n+\tsdf := (*graph.SplittableDoFn)(n.PDo.Fn)\n+\taddContext := func(err error) error {\n+\t\treturn errors.WithContextf(err, \"SdfFallback transform with UID %v\", n.ID())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "900549da8eb31a02646e3f192f653694fc49c203"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM5MjkwNQ==", "bodyText": "Good idea. Actually went ahead and did that for all the errors in this file, since that seems better,", "url": "https://github.com/apache/beam/pull/11645#discussion_r423392905", "createdAt": "2020-05-12T00:22:20Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/exec/sdf.go", "diffHunk": "@@ -313,3 +313,94 @@ func (n *ProcessSizedElementsAndRestrictions) Down(ctx context.Context) error {\n func (n *ProcessSizedElementsAndRestrictions) String() string {\n \treturn fmt.Sprintf(\"SDF.ProcessSizedElementsAndRestrictions[%v] Out:%v\", path.Base(n.PDo.Fn.Name()), IDs(n.PDo.Out...))\n }\n+\n+// SdfFallback is an executor used when an SDF isn't expanded into steps by the\n+// runner, indicating that the runner doesn't support splitting. It executes all\n+// the SDF steps together in one unit.\n+type SdfFallback struct {\n+\tPDo *ParDo\n+\n+\tinitRestInv *cirInvoker\n+\tsplitInv    *srInvoker\n+\ttrackerInv  *ctInvoker\n+}\n+\n+// ID just defers to the ParDo's ID method.\n+func (n *SdfFallback) ID() UnitID {\n+\treturn n.PDo.UID\n+}\n+\n+// Up performs some one-time setup and then defers to the ParDo's Up method.\n+func (n *SdfFallback) Up(ctx context.Context) error {\n+\tsdf := (*graph.SplittableDoFn)(n.PDo.Fn)\n+\taddContext := func(err error) error {\n+\t\treturn errors.WithContextf(err, \"SdfFallback transform with UID %v\", n.ID())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY4MjgzNQ=="}, "originalCommit": {"oid": "900549da8eb31a02646e3f192f653694fc49c203"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMjA2MDA2OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/exec/sdf.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxOToxMzoyMlrOGTGwOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwMDoyNTowOFrOGTx56A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY4Njc3OQ==", "bodyText": "Editorial nits:\nWe can probably remove the \"just\".\nGiven \"defer\" is a keyword in Go, using defers might be misinterpreted. Consider replacing it with \"calls\"\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // StartBundle just defers to the ParDo's StartBundle method.\n          \n          \n            \n            // StartBundle calls the ParDo's StartBundle method.", "url": "https://github.com/apache/beam/pull/11645#discussion_r422686779", "createdAt": "2020-05-10T19:13:22Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/sdf.go", "diffHunk": "@@ -313,3 +313,94 @@ func (n *ProcessSizedElementsAndRestrictions) Down(ctx context.Context) error {\n func (n *ProcessSizedElementsAndRestrictions) String() string {\n \treturn fmt.Sprintf(\"SDF.ProcessSizedElementsAndRestrictions[%v] Out:%v\", path.Base(n.PDo.Fn.Name()), IDs(n.PDo.Out...))\n }\n+\n+// SdfFallback is an executor used when an SDF isn't expanded into steps by the\n+// runner, indicating that the runner doesn't support splitting. It executes all\n+// the SDF steps together in one unit.\n+type SdfFallback struct {\n+\tPDo *ParDo\n+\n+\tinitRestInv *cirInvoker\n+\tsplitInv    *srInvoker\n+\ttrackerInv  *ctInvoker\n+}\n+\n+// ID just defers to the ParDo's ID method.\n+func (n *SdfFallback) ID() UnitID {\n+\treturn n.PDo.UID\n+}\n+\n+// Up performs some one-time setup and then defers to the ParDo's Up method.\n+func (n *SdfFallback) Up(ctx context.Context) error {\n+\tsdf := (*graph.SplittableDoFn)(n.PDo.Fn)\n+\taddContext := func(err error) error {\n+\t\treturn errors.WithContextf(err, \"SdfFallback transform with UID %v\", n.ID())\n+\t}\n+\tvar err error\n+\tif n.initRestInv, err = newCreateInitialRestrictionInvoker(sdf.CreateInitialRestrictionFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\tif n.splitInv, err = newSplitRestrictionInvoker(sdf.SplitRestrictionFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\tif n.trackerInv, err = newCreateTrackerInvoker(sdf.CreateTrackerFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\treturn n.PDo.Up(ctx)\n+}\n+\n+// StartBundle just defers to the ParDo's StartBundle method.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "900549da8eb31a02646e3f192f653694fc49c203"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM5Mzc2OA==", "bodyText": "Done, for all the comments in this file.", "url": "https://github.com/apache/beam/pull/11645#discussion_r423393768", "createdAt": "2020-05-12T00:25:08Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/exec/sdf.go", "diffHunk": "@@ -313,3 +313,94 @@ func (n *ProcessSizedElementsAndRestrictions) Down(ctx context.Context) error {\n func (n *ProcessSizedElementsAndRestrictions) String() string {\n \treturn fmt.Sprintf(\"SDF.ProcessSizedElementsAndRestrictions[%v] Out:%v\", path.Base(n.PDo.Fn.Name()), IDs(n.PDo.Out...))\n }\n+\n+// SdfFallback is an executor used when an SDF isn't expanded into steps by the\n+// runner, indicating that the runner doesn't support splitting. It executes all\n+// the SDF steps together in one unit.\n+type SdfFallback struct {\n+\tPDo *ParDo\n+\n+\tinitRestInv *cirInvoker\n+\tsplitInv    *srInvoker\n+\ttrackerInv  *ctInvoker\n+}\n+\n+// ID just defers to the ParDo's ID method.\n+func (n *SdfFallback) ID() UnitID {\n+\treturn n.PDo.UID\n+}\n+\n+// Up performs some one-time setup and then defers to the ParDo's Up method.\n+func (n *SdfFallback) Up(ctx context.Context) error {\n+\tsdf := (*graph.SplittableDoFn)(n.PDo.Fn)\n+\taddContext := func(err error) error {\n+\t\treturn errors.WithContextf(err, \"SdfFallback transform with UID %v\", n.ID())\n+\t}\n+\tvar err error\n+\tif n.initRestInv, err = newCreateInitialRestrictionInvoker(sdf.CreateInitialRestrictionFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\tif n.splitInv, err = newSplitRestrictionInvoker(sdf.SplitRestrictionFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\tif n.trackerInv, err = newCreateTrackerInvoker(sdf.CreateTrackerFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\treturn n.PDo.Up(ctx)\n+}\n+\n+// StartBundle just defers to the ParDo's StartBundle method.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY4Njc3OQ=="}, "originalCommit": {"oid": "900549da8eb31a02646e3f192f653694fc49c203"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMjA2MjE5OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/exec/sdf.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxOToxNTozMVrOGTGxRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwMDoyNToyMVrOGTx6IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY4NzA0Nw==", "bodyText": "Same comment here WRT context.", "url": "https://github.com/apache/beam/pull/11645#discussion_r422687047", "createdAt": "2020-05-10T19:15:31Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/sdf.go", "diffHunk": "@@ -313,3 +313,94 @@ func (n *ProcessSizedElementsAndRestrictions) Down(ctx context.Context) error {\n func (n *ProcessSizedElementsAndRestrictions) String() string {\n \treturn fmt.Sprintf(\"SDF.ProcessSizedElementsAndRestrictions[%v] Out:%v\", path.Base(n.PDo.Fn.Name()), IDs(n.PDo.Out...))\n }\n+\n+// SdfFallback is an executor used when an SDF isn't expanded into steps by the\n+// runner, indicating that the runner doesn't support splitting. It executes all\n+// the SDF steps together in one unit.\n+type SdfFallback struct {\n+\tPDo *ParDo\n+\n+\tinitRestInv *cirInvoker\n+\tsplitInv    *srInvoker\n+\ttrackerInv  *ctInvoker\n+}\n+\n+// ID just defers to the ParDo's ID method.\n+func (n *SdfFallback) ID() UnitID {\n+\treturn n.PDo.UID\n+}\n+\n+// Up performs some one-time setup and then defers to the ParDo's Up method.\n+func (n *SdfFallback) Up(ctx context.Context) error {\n+\tsdf := (*graph.SplittableDoFn)(n.PDo.Fn)\n+\taddContext := func(err error) error {\n+\t\treturn errors.WithContextf(err, \"SdfFallback transform with UID %v\", n.ID())\n+\t}\n+\tvar err error\n+\tif n.initRestInv, err = newCreateInitialRestrictionInvoker(sdf.CreateInitialRestrictionFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\tif n.splitInv, err = newSplitRestrictionInvoker(sdf.SplitRestrictionFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\tif n.trackerInv, err = newCreateTrackerInvoker(sdf.CreateTrackerFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\treturn n.PDo.Up(ctx)\n+}\n+\n+// StartBundle just defers to the ParDo's StartBundle method.\n+func (n *SdfFallback) StartBundle(ctx context.Context, id string, data DataContext) error {\n+\treturn n.PDo.StartBundle(ctx, id, data)\n+}\n+\n+// ProcessElement performs all the work from the steps above in one transform.\n+// This means creating initial restrictions, performing initial splits on those\n+// restrictions, and then creating restriction trackers and processing each\n+// restriction with the underlying ParDo. This executor skips the sizing step\n+// because sizing information is unnecessary for unexpanded SDFs.\n+func (n *SdfFallback) ProcessElement(ctx context.Context, elm *FullValue, values ...ReStream) error {\n+\tif n.PDo.status != Active {\n+\t\treturn errors.Errorf(\"invalid status for ParDo %v: %v, want Active\", n.PDo.UID, n.PDo.status)\n+\t}\n+\n+\trest := n.initRestInv.Invoke(elm)\n+\tsplitRests := n.splitInv.Invoke(elm, rest)\n+\tif len(splitRests) == 0 {\n+\t\terr := errors.Errorf(\"initial splitting returned 0 restrictions.\")\n+\t\treturn errors.WithContextf(err, \"SdfFallback transform with UID %v\", n.ID())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "900549da8eb31a02646e3f192f653694fc49c203"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM5MzgyNQ==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/11645#discussion_r423393825", "createdAt": "2020-05-12T00:25:21Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/exec/sdf.go", "diffHunk": "@@ -313,3 +313,94 @@ func (n *ProcessSizedElementsAndRestrictions) Down(ctx context.Context) error {\n func (n *ProcessSizedElementsAndRestrictions) String() string {\n \treturn fmt.Sprintf(\"SDF.ProcessSizedElementsAndRestrictions[%v] Out:%v\", path.Base(n.PDo.Fn.Name()), IDs(n.PDo.Out...))\n }\n+\n+// SdfFallback is an executor used when an SDF isn't expanded into steps by the\n+// runner, indicating that the runner doesn't support splitting. It executes all\n+// the SDF steps together in one unit.\n+type SdfFallback struct {\n+\tPDo *ParDo\n+\n+\tinitRestInv *cirInvoker\n+\tsplitInv    *srInvoker\n+\ttrackerInv  *ctInvoker\n+}\n+\n+// ID just defers to the ParDo's ID method.\n+func (n *SdfFallback) ID() UnitID {\n+\treturn n.PDo.UID\n+}\n+\n+// Up performs some one-time setup and then defers to the ParDo's Up method.\n+func (n *SdfFallback) Up(ctx context.Context) error {\n+\tsdf := (*graph.SplittableDoFn)(n.PDo.Fn)\n+\taddContext := func(err error) error {\n+\t\treturn errors.WithContextf(err, \"SdfFallback transform with UID %v\", n.ID())\n+\t}\n+\tvar err error\n+\tif n.initRestInv, err = newCreateInitialRestrictionInvoker(sdf.CreateInitialRestrictionFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\tif n.splitInv, err = newSplitRestrictionInvoker(sdf.SplitRestrictionFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\tif n.trackerInv, err = newCreateTrackerInvoker(sdf.CreateTrackerFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\treturn n.PDo.Up(ctx)\n+}\n+\n+// StartBundle just defers to the ParDo's StartBundle method.\n+func (n *SdfFallback) StartBundle(ctx context.Context, id string, data DataContext) error {\n+\treturn n.PDo.StartBundle(ctx, id, data)\n+}\n+\n+// ProcessElement performs all the work from the steps above in one transform.\n+// This means creating initial restrictions, performing initial splits on those\n+// restrictions, and then creating restriction trackers and processing each\n+// restriction with the underlying ParDo. This executor skips the sizing step\n+// because sizing information is unnecessary for unexpanded SDFs.\n+func (n *SdfFallback) ProcessElement(ctx context.Context, elm *FullValue, values ...ReStream) error {\n+\tif n.PDo.status != Active {\n+\t\treturn errors.Errorf(\"invalid status for ParDo %v: %v, want Active\", n.PDo.UID, n.PDo.status)\n+\t}\n+\n+\trest := n.initRestInv.Invoke(elm)\n+\tsplitRests := n.splitInv.Invoke(elm, rest)\n+\tif len(splitRests) == 0 {\n+\t\terr := errors.Errorf(\"initial splitting returned 0 restrictions.\")\n+\t\treturn errors.WithContextf(err, \"SdfFallback transform with UID %v\", n.ID())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY4NzA0Nw=="}, "originalCommit": {"oid": "900549da8eb31a02646e3f192f653694fc49c203"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMjA2MzU1OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/exec/sdf.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxOToxNjo0MVrOGTGx4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwMDoyNzoyNlrOGTx8fQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY4NzIwMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // FinishBundle does some teardown for the end of the bundle and then defers to\n          \n          \n            \n            // the ParDo's FinishBundle method.\n          \n          \n            \n            // FinishBundle resets the invokers and then calls the ParDo's FinishBundle method.", "url": "https://github.com/apache/beam/pull/11645#discussion_r422687203", "createdAt": "2020-05-10T19:16:41Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/sdf.go", "diffHunk": "@@ -313,3 +313,94 @@ func (n *ProcessSizedElementsAndRestrictions) Down(ctx context.Context) error {\n func (n *ProcessSizedElementsAndRestrictions) String() string {\n \treturn fmt.Sprintf(\"SDF.ProcessSizedElementsAndRestrictions[%v] Out:%v\", path.Base(n.PDo.Fn.Name()), IDs(n.PDo.Out...))\n }\n+\n+// SdfFallback is an executor used when an SDF isn't expanded into steps by the\n+// runner, indicating that the runner doesn't support splitting. It executes all\n+// the SDF steps together in one unit.\n+type SdfFallback struct {\n+\tPDo *ParDo\n+\n+\tinitRestInv *cirInvoker\n+\tsplitInv    *srInvoker\n+\ttrackerInv  *ctInvoker\n+}\n+\n+// ID just defers to the ParDo's ID method.\n+func (n *SdfFallback) ID() UnitID {\n+\treturn n.PDo.UID\n+}\n+\n+// Up performs some one-time setup and then defers to the ParDo's Up method.\n+func (n *SdfFallback) Up(ctx context.Context) error {\n+\tsdf := (*graph.SplittableDoFn)(n.PDo.Fn)\n+\taddContext := func(err error) error {\n+\t\treturn errors.WithContextf(err, \"SdfFallback transform with UID %v\", n.ID())\n+\t}\n+\tvar err error\n+\tif n.initRestInv, err = newCreateInitialRestrictionInvoker(sdf.CreateInitialRestrictionFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\tif n.splitInv, err = newSplitRestrictionInvoker(sdf.SplitRestrictionFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\tif n.trackerInv, err = newCreateTrackerInvoker(sdf.CreateTrackerFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\treturn n.PDo.Up(ctx)\n+}\n+\n+// StartBundle just defers to the ParDo's StartBundle method.\n+func (n *SdfFallback) StartBundle(ctx context.Context, id string, data DataContext) error {\n+\treturn n.PDo.StartBundle(ctx, id, data)\n+}\n+\n+// ProcessElement performs all the work from the steps above in one transform.\n+// This means creating initial restrictions, performing initial splits on those\n+// restrictions, and then creating restriction trackers and processing each\n+// restriction with the underlying ParDo. This executor skips the sizing step\n+// because sizing information is unnecessary for unexpanded SDFs.\n+func (n *SdfFallback) ProcessElement(ctx context.Context, elm *FullValue, values ...ReStream) error {\n+\tif n.PDo.status != Active {\n+\t\treturn errors.Errorf(\"invalid status for ParDo %v: %v, want Active\", n.PDo.UID, n.PDo.status)\n+\t}\n+\n+\trest := n.initRestInv.Invoke(elm)\n+\tsplitRests := n.splitInv.Invoke(elm, rest)\n+\tif len(splitRests) == 0 {\n+\t\terr := errors.Errorf(\"initial splitting returned 0 restrictions.\")\n+\t\treturn errors.WithContextf(err, \"SdfFallback transform with UID %v\", n.ID())\n+\t}\n+\n+\tfor _, splitRest := range splitRests {\n+\t\trt := n.trackerInv.Invoke(splitRest)\n+\t\tmainIn := &MainInput{\n+\t\t\tKey:      *elm,\n+\t\t\tValues:   values,\n+\t\t\tRTracker: rt,\n+\t\t}\n+\t\tif err := n.PDo.processMainInput(mainIn); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// FinishBundle does some teardown for the end of the bundle and then defers to\n+// the ParDo's FinishBundle method.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "900549da8eb31a02646e3f192f653694fc49c203"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM5NDQyOQ==", "bodyText": "Done, for the other FinishBundle methods too.", "url": "https://github.com/apache/beam/pull/11645#discussion_r423394429", "createdAt": "2020-05-12T00:27:26Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/exec/sdf.go", "diffHunk": "@@ -313,3 +313,94 @@ func (n *ProcessSizedElementsAndRestrictions) Down(ctx context.Context) error {\n func (n *ProcessSizedElementsAndRestrictions) String() string {\n \treturn fmt.Sprintf(\"SDF.ProcessSizedElementsAndRestrictions[%v] Out:%v\", path.Base(n.PDo.Fn.Name()), IDs(n.PDo.Out...))\n }\n+\n+// SdfFallback is an executor used when an SDF isn't expanded into steps by the\n+// runner, indicating that the runner doesn't support splitting. It executes all\n+// the SDF steps together in one unit.\n+type SdfFallback struct {\n+\tPDo *ParDo\n+\n+\tinitRestInv *cirInvoker\n+\tsplitInv    *srInvoker\n+\ttrackerInv  *ctInvoker\n+}\n+\n+// ID just defers to the ParDo's ID method.\n+func (n *SdfFallback) ID() UnitID {\n+\treturn n.PDo.UID\n+}\n+\n+// Up performs some one-time setup and then defers to the ParDo's Up method.\n+func (n *SdfFallback) Up(ctx context.Context) error {\n+\tsdf := (*graph.SplittableDoFn)(n.PDo.Fn)\n+\taddContext := func(err error) error {\n+\t\treturn errors.WithContextf(err, \"SdfFallback transform with UID %v\", n.ID())\n+\t}\n+\tvar err error\n+\tif n.initRestInv, err = newCreateInitialRestrictionInvoker(sdf.CreateInitialRestrictionFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\tif n.splitInv, err = newSplitRestrictionInvoker(sdf.SplitRestrictionFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\tif n.trackerInv, err = newCreateTrackerInvoker(sdf.CreateTrackerFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\treturn n.PDo.Up(ctx)\n+}\n+\n+// StartBundle just defers to the ParDo's StartBundle method.\n+func (n *SdfFallback) StartBundle(ctx context.Context, id string, data DataContext) error {\n+\treturn n.PDo.StartBundle(ctx, id, data)\n+}\n+\n+// ProcessElement performs all the work from the steps above in one transform.\n+// This means creating initial restrictions, performing initial splits on those\n+// restrictions, and then creating restriction trackers and processing each\n+// restriction with the underlying ParDo. This executor skips the sizing step\n+// because sizing information is unnecessary for unexpanded SDFs.\n+func (n *SdfFallback) ProcessElement(ctx context.Context, elm *FullValue, values ...ReStream) error {\n+\tif n.PDo.status != Active {\n+\t\treturn errors.Errorf(\"invalid status for ParDo %v: %v, want Active\", n.PDo.UID, n.PDo.status)\n+\t}\n+\n+\trest := n.initRestInv.Invoke(elm)\n+\tsplitRests := n.splitInv.Invoke(elm, rest)\n+\tif len(splitRests) == 0 {\n+\t\terr := errors.Errorf(\"initial splitting returned 0 restrictions.\")\n+\t\treturn errors.WithContextf(err, \"SdfFallback transform with UID %v\", n.ID())\n+\t}\n+\n+\tfor _, splitRest := range splitRests {\n+\t\trt := n.trackerInv.Invoke(splitRest)\n+\t\tmainIn := &MainInput{\n+\t\t\tKey:      *elm,\n+\t\t\tValues:   values,\n+\t\t\tRTracker: rt,\n+\t\t}\n+\t\tif err := n.PDo.processMainInput(mainIn); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// FinishBundle does some teardown for the end of the bundle and then defers to\n+// the ParDo's FinishBundle method.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY4NzIwMw=="}, "originalCommit": {"oid": "900549da8eb31a02646e3f192f653694fc49c203"}, "originalPosition": 78}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3884, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}