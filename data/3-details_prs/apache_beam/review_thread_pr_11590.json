{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyMjg5NjAy", "number": 11590, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzozMjoyMVrOD5njYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMToxNTo1NVrOD8PWAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzQzNDU5OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/utils/thread_pool_executor.py", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzozMjoyMlrOGQ_Vyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNzo1NjoxNFrOGReyFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2ODE3MQ==", "bodyText": "should we remove a total of self._max_idle_threads - self._idle_worker_queue.qsize() workers rather than just one?\nIIUC, this is the only point (besides shutdown) where workers are removed, so maybe yes?", "url": "https://github.com/apache/beam/pull/11590#discussion_r420468171", "createdAt": "2020-05-05T23:32:22Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/utils/thread_pool_executor.py", "diffHunk": "@@ -137,35 +101,33 @@ def submit(self, fn, *args, **kwargs):\n     \"\"\"\n     future = _base.Future()\n     work_item = _WorkItem(future, fn, args, kwargs)\n-    try:\n-      # Keep trying to get an idle worker from the queue until we find one\n-      # that accepts the work.\n-      while not self._idle_worker_queue.get(\n-          block=False).accepted_work(work_item):\n-        pass\n-      return future\n-    except queue.Empty:\n-      with self._lock:\n-        if self._shutdown:\n-          raise RuntimeError(\n-              'Cannot schedule new tasks after thread pool '\n-              'has been shutdown.')\n-\n-        worker = _Worker(\n-            self._idle_worker_queue,\n-            self._permitted_thread_age_in_seconds,\n-            work_item)\n+    with self._lock:\n+      if self._shutdown:\n+        raise RuntimeError(\n+            'Cannot schedule new tasks after thread pool has been shutdown.')\n+      try:\n+        self._idle_worker_queue.get(block=False).assign_work(work_item)\n+\n+        # If we have more idle threads then the max allowed, shutdown a thread.\n+        if self._idle_worker_queue.qsize() > self._max_idle_threads:\n+          try:\n+            self._idle_worker_queue.get(block=False).shutdown()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b740404ec4f9c06940cfcd06388f3fb920364a62"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg5NDkyMA==", "bodyText": "I was thinking removing one at a time to reduce the rate at which we kill threads would \"average\" out the thread creation/death rate better but I have no data to support this hunch.", "url": "https://github.com/apache/beam/pull/11590#discussion_r420894920", "createdAt": "2020-05-06T15:44:09Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/utils/thread_pool_executor.py", "diffHunk": "@@ -137,35 +101,33 @@ def submit(self, fn, *args, **kwargs):\n     \"\"\"\n     future = _base.Future()\n     work_item = _WorkItem(future, fn, args, kwargs)\n-    try:\n-      # Keep trying to get an idle worker from the queue until we find one\n-      # that accepts the work.\n-      while not self._idle_worker_queue.get(\n-          block=False).accepted_work(work_item):\n-        pass\n-      return future\n-    except queue.Empty:\n-      with self._lock:\n-        if self._shutdown:\n-          raise RuntimeError(\n-              'Cannot schedule new tasks after thread pool '\n-              'has been shutdown.')\n-\n-        worker = _Worker(\n-            self._idle_worker_queue,\n-            self._permitted_thread_age_in_seconds,\n-            work_item)\n+    with self._lock:\n+      if self._shutdown:\n+        raise RuntimeError(\n+            'Cannot schedule new tasks after thread pool has been shutdown.')\n+      try:\n+        self._idle_worker_queue.get(block=False).assign_work(work_item)\n+\n+        # If we have more idle threads then the max allowed, shutdown a thread.\n+        if self._idle_worker_queue.qsize() > self._max_idle_threads:\n+          try:\n+            self._idle_worker_queue.get(block=False).shutdown()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2ODE3MQ=="}, "originalCommit": {"oid": "b740404ec4f9c06940cfcd06388f3fb920364a62"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkyNjkzNA==", "bodyText": "Removing one thread at a time seems sensible to me.", "url": "https://github.com/apache/beam/pull/11590#discussion_r420926934", "createdAt": "2020-05-06T16:29:44Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/utils/thread_pool_executor.py", "diffHunk": "@@ -137,35 +101,33 @@ def submit(self, fn, *args, **kwargs):\n     \"\"\"\n     future = _base.Future()\n     work_item = _WorkItem(future, fn, args, kwargs)\n-    try:\n-      # Keep trying to get an idle worker from the queue until we find one\n-      # that accepts the work.\n-      while not self._idle_worker_queue.get(\n-          block=False).accepted_work(work_item):\n-        pass\n-      return future\n-    except queue.Empty:\n-      with self._lock:\n-        if self._shutdown:\n-          raise RuntimeError(\n-              'Cannot schedule new tasks after thread pool '\n-              'has been shutdown.')\n-\n-        worker = _Worker(\n-            self._idle_worker_queue,\n-            self._permitted_thread_age_in_seconds,\n-            work_item)\n+    with self._lock:\n+      if self._shutdown:\n+        raise RuntimeError(\n+            'Cannot schedule new tasks after thread pool has been shutdown.')\n+      try:\n+        self._idle_worker_queue.get(block=False).assign_work(work_item)\n+\n+        # If we have more idle threads then the max allowed, shutdown a thread.\n+        if self._idle_worker_queue.qsize() > self._max_idle_threads:\n+          try:\n+            self._idle_worker_queue.get(block=False).shutdown()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2ODE3MQ=="}, "originalCommit": {"oid": "b740404ec4f9c06940cfcd06388f3fb920364a62"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk4MzMxNg==", "bodyText": "sounds good then!", "url": "https://github.com/apache/beam/pull/11590#discussion_r420983316", "createdAt": "2020-05-06T17:56:14Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/utils/thread_pool_executor.py", "diffHunk": "@@ -137,35 +101,33 @@ def submit(self, fn, *args, **kwargs):\n     \"\"\"\n     future = _base.Future()\n     work_item = _WorkItem(future, fn, args, kwargs)\n-    try:\n-      # Keep trying to get an idle worker from the queue until we find one\n-      # that accepts the work.\n-      while not self._idle_worker_queue.get(\n-          block=False).accepted_work(work_item):\n-        pass\n-      return future\n-    except queue.Empty:\n-      with self._lock:\n-        if self._shutdown:\n-          raise RuntimeError(\n-              'Cannot schedule new tasks after thread pool '\n-              'has been shutdown.')\n-\n-        worker = _Worker(\n-            self._idle_worker_queue,\n-            self._permitted_thread_age_in_seconds,\n-            work_item)\n+    with self._lock:\n+      if self._shutdown:\n+        raise RuntimeError(\n+            'Cannot schedule new tasks after thread pool has been shutdown.')\n+      try:\n+        self._idle_worker_queue.get(block=False).assign_work(work_item)\n+\n+        # If we have more idle threads then the max allowed, shutdown a thread.\n+        if self._idle_worker_queue.qsize() > self._max_idle_threads:\n+          try:\n+            self._idle_worker_queue.get(block=False).shutdown()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2ODE3MQ=="}, "originalCommit": {"oid": "b740404ec4f9c06940cfcd06388f3fb920364a62"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDkyNTQ1OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/utils/thread_pool_executor.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMToxNTo1NVrOGVDz_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMjo0OTo0N1rOGVGMew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDczNTc0MQ==", "bodyText": "Also remove the shutdown worker from self._workers?", "url": "https://github.com/apache/beam/pull/11590#discussion_r424735741", "createdAt": "2020-05-13T21:15:55Z", "author": {"login": "udim"}, "path": "sdks/python/apache_beam/utils/thread_pool_executor.py", "diffHunk": "@@ -137,35 +101,33 @@ def submit(self, fn, *args, **kwargs):\n     \"\"\"\n     future = _base.Future()\n     work_item = _WorkItem(future, fn, args, kwargs)\n-    try:\n-      # Keep trying to get an idle worker from the queue until we find one\n-      # that accepts the work.\n-      while not self._idle_worker_queue.get(\n-          block=False).accepted_work(work_item):\n-        pass\n-      return future\n-    except queue.Empty:\n-      with self._lock:\n-        if self._shutdown:\n-          raise RuntimeError(\n-              'Cannot schedule new tasks after thread pool '\n-              'has been shutdown.')\n-\n-        worker = _Worker(\n-            self._idle_worker_queue,\n-            self._permitted_thread_age_in_seconds,\n-            work_item)\n+    with self._lock:\n+      if self._shutdown:\n+        raise RuntimeError(\n+            'Cannot schedule new tasks after thread pool has been shutdown.')\n+      try:\n+        self._idle_worker_queue.get(block=False).assign_work(work_item)\n+\n+        # If we have more idle threads then the max allowed, shutdown a thread.\n+        if self._idle_worker_queue.qsize() > self._max_idle_threads:\n+          try:\n+            self._idle_worker_queue.get(block=False).shutdown()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b740404ec4f9c06940cfcd06388f3fb920364a62"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1NTM3Mw==", "bodyText": "self._workers is a weakref set so when the thread dies it should automatically be removed from the set. Calling shutdown multiple times should be a non-issue as well for each worker as all it does is make the worker eligible to wake up.\nDo you have any more details as to why you think this is an issue?", "url": "https://github.com/apache/beam/pull/11590#discussion_r424755373", "createdAt": "2020-05-13T21:59:25Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/utils/thread_pool_executor.py", "diffHunk": "@@ -137,35 +101,33 @@ def submit(self, fn, *args, **kwargs):\n     \"\"\"\n     future = _base.Future()\n     work_item = _WorkItem(future, fn, args, kwargs)\n-    try:\n-      # Keep trying to get an idle worker from the queue until we find one\n-      # that accepts the work.\n-      while not self._idle_worker_queue.get(\n-          block=False).accepted_work(work_item):\n-        pass\n-      return future\n-    except queue.Empty:\n-      with self._lock:\n-        if self._shutdown:\n-          raise RuntimeError(\n-              'Cannot schedule new tasks after thread pool '\n-              'has been shutdown.')\n-\n-        worker = _Worker(\n-            self._idle_worker_queue,\n-            self._permitted_thread_age_in_seconds,\n-            work_item)\n+    with self._lock:\n+      if self._shutdown:\n+        raise RuntimeError(\n+            'Cannot schedule new tasks after thread pool has been shutdown.')\n+      try:\n+        self._idle_worker_queue.get(block=False).assign_work(work_item)\n+\n+        # If we have more idle threads then the max allowed, shutdown a thread.\n+        if self._idle_worker_queue.qsize() > self._max_idle_threads:\n+          try:\n+            self._idle_worker_queue.get(block=False).shutdown()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDczNTc0MQ=="}, "originalCommit": {"oid": "b740404ec4f9c06940cfcd06388f3fb920364a62"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3NDc3OQ==", "bodyText": "Sorry, I missed that it was a WeakSet. Multiple shutdowns look ok as well.", "url": "https://github.com/apache/beam/pull/11590#discussion_r424774779", "createdAt": "2020-05-13T22:49:47Z", "author": {"login": "udim"}, "path": "sdks/python/apache_beam/utils/thread_pool_executor.py", "diffHunk": "@@ -137,35 +101,33 @@ def submit(self, fn, *args, **kwargs):\n     \"\"\"\n     future = _base.Future()\n     work_item = _WorkItem(future, fn, args, kwargs)\n-    try:\n-      # Keep trying to get an idle worker from the queue until we find one\n-      # that accepts the work.\n-      while not self._idle_worker_queue.get(\n-          block=False).accepted_work(work_item):\n-        pass\n-      return future\n-    except queue.Empty:\n-      with self._lock:\n-        if self._shutdown:\n-          raise RuntimeError(\n-              'Cannot schedule new tasks after thread pool '\n-              'has been shutdown.')\n-\n-        worker = _Worker(\n-            self._idle_worker_queue,\n-            self._permitted_thread_age_in_seconds,\n-            work_item)\n+    with self._lock:\n+      if self._shutdown:\n+        raise RuntimeError(\n+            'Cannot schedule new tasks after thread pool has been shutdown.')\n+      try:\n+        self._idle_worker_queue.get(block=False).assign_work(work_item)\n+\n+        # If we have more idle threads then the max allowed, shutdown a thread.\n+        if self._idle_worker_queue.qsize() > self._max_idle_threads:\n+          try:\n+            self._idle_worker_queue.get(block=False).shutdown()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDczNTc0MQ=="}, "originalCommit": {"oid": "b740404ec4f9c06940cfcd06388f3fb920364a62"}, "originalPosition": 124}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1226, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}