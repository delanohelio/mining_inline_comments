{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxMjgxNzI3", "number": 11174, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDo0NzoxNVrODqApMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMzo0MTozOFrODqCnrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Mzc3MzI4OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/transforms/core.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDo0NzoxNlrOF5ivNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMTowNzoxMlrOF5jNag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4MjI5Mw==", "bodyText": "This is not the right place to pop this (internal) stack. Instead, we should popping from the stack in a finally clause of a try block that pushes to the stack. (Alternatively, we could manage the stack with a Python context, but that might be overkill.)", "url": "https://github.com/apache/beam/pull/11174#discussion_r395882293", "createdAt": "2020-03-20T20:47:16Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -1811,6 +1811,8 @@ def add_input_types(transform):\n       return view\n     else:\n       if pcoll.windowing.windowfn != GlobalWindows():\n+        # Remove the broken transform when running into value error.\n+        pcoll.pipeline.transforms_stack.pop()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3469e5dca131a5cd8f53f7174c4ae0310f71c097"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4MzE5Ng==", "bodyText": "E.g. put this https://github.com/apache/beam/blob/release-2.19.0/sdks/python/apache_beam/pipeline.py#L330 in a finally clause of a try block that starts where it's pushed.", "url": "https://github.com/apache/beam/pull/11174#discussion_r395883196", "createdAt": "2020-03-20T20:49:19Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -1811,6 +1811,8 @@ def add_input_types(transform):\n       return view\n     else:\n       if pcoll.windowing.windowfn != GlobalWindows():\n+        # Remove the broken transform when running into value error.\n+        pcoll.pipeline.transforms_stack.pop()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4MjI5Mw=="}, "originalCommit": {"oid": "3469e5dca131a5cd8f53f7174c4ae0310f71c097"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg5MDAyNg==", "bodyText": "Yes, agree with it! I'll make the change.", "url": "https://github.com/apache/beam/pull/11174#discussion_r395890026", "createdAt": "2020-03-20T21:07:12Z", "author": {"login": "KevinGG"}, "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -1811,6 +1811,8 @@ def add_input_types(transform):\n       return view\n     else:\n       if pcoll.windowing.windowfn != GlobalWindows():\n+        # Remove the broken transform when running into value error.\n+        pcoll.pipeline.transforms_stack.pop()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4MjI5Mw=="}, "originalCommit": {"oid": "3469e5dca131a5cd8f53f7174c4ae0310f71c097"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NDA5NzA5OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/pipeline.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMzo0MTozOVrOF5l3pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMDozOTo0M1rOF6XPlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkzMzYwNA==", "bodyText": "This is a python newbie question. Does list.append() ever throw an exception? If so, should we move this out of the try block so that we don't pop() if list.append() fails?", "url": "https://github.com/apache/beam/pull/11174#discussion_r395933604", "createdAt": "2020-03-20T23:41:39Z", "author": {"login": "davidyan74"}, "path": "sdks/python/apache_beam/pipeline.py", "diffHunk": "@@ -307,58 +307,61 @@ def _replace_if_needed(self, original_transform_node):\n           elif len(inputs) == 0:\n             input_node = pvalue.PBegin(self.pipeline)\n \n-          # We have to add the new AppliedTransform to the stack before expand()\n-          # and pop it out later to make sure that parts get added correctly.\n-          self.pipeline.transforms_stack.append(replacement_transform_node)\n-\n-          # Keeping the same label for the replaced node but recursively\n-          # removing labels of child transforms of original transform since they\n-          # will be replaced during the expand below. This is needed in case\n-          # the replacement contains children that have labels that conflicts\n-          # with labels of the children of the original.\n-          self.pipeline._remove_labels_recursively(original_transform_node)\n-\n-          new_output = replacement_transform.expand(input_node)\n-          assert isinstance(\n-              new_output, (dict, pvalue.PValue, pvalue.DoOutputsTuple))\n-\n-          if isinstance(new_output, pvalue.PValue):\n-            new_output.element_type = None\n-            self.pipeline._infer_result_type(\n-                replacement_transform, inputs, new_output)\n-\n-          if isinstance(new_output, dict):\n-            for new_tag, new_pcoll in new_output.items():\n-              replacement_transform_node.add_output(new_pcoll, new_tag)\n-          elif isinstance(new_output, pvalue.DoOutputsTuple):\n-            replacement_transform_node.add_output(\n-                new_output, new_output._main_tag)\n-          else:\n-            replacement_transform_node.add_output(new_output, new_output.tag)\n-\n-          # Recording updated outputs. This cannot be done in the same visitor\n-          # since if we dynamically update output type here, we'll run into\n-          # errors when visiting child nodes.\n-          #\n-          # NOTE: When replacing multiple outputs, the replacement PCollection\n-          # tags must have a matching tag in the original transform.\n-          if isinstance(new_output, pvalue.PValue):\n-            if not new_output.producer:\n-              new_output.producer = replacement_transform_node\n-            output_map[original_transform_node.outputs[new_output.tag]] = \\\n-                new_output\n-          elif isinstance(new_output, (pvalue.DoOutputsTuple, tuple)):\n-            for pcoll in new_output:\n-              if not pcoll.producer:\n-                pcoll.producer = replacement_transform_node\n-              output_map[original_transform_node.outputs[pcoll.tag]] = pcoll\n-          elif isinstance(new_output, dict):\n-            for tag, pcoll in new_output.items():\n-              if not pcoll.producer:\n-                pcoll.producer = replacement_transform_node\n-              output_map[original_transform_node.outputs[tag]] = pcoll\n-\n-          self.pipeline.transforms_stack.pop()\n+          try:\n+            # We have to add the new AppliedTransform to the stack before\n+            # expand() and pop it out later to make sure that parts get added\n+            # correctly.\n+            self.pipeline.transforms_stack.append(replacement_transform_node)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3f8e4b23f7aaccdcd18e9799e1ebe61a9956b8e"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0MjU0OA==", "bodyText": "It wouldn't raise an error if it's still a list on the line, and if it's not a list (becomes a None or some other object) at the moment it causes an error, the finally block would error out too. So it's not necessary to exclude it from the try block.\nPutting it inside the try makes it a little bit more self-explained.", "url": "https://github.com/apache/beam/pull/11174#discussion_r396742548", "createdAt": "2020-03-23T20:39:43Z", "author": {"login": "KevinGG"}, "path": "sdks/python/apache_beam/pipeline.py", "diffHunk": "@@ -307,58 +307,61 @@ def _replace_if_needed(self, original_transform_node):\n           elif len(inputs) == 0:\n             input_node = pvalue.PBegin(self.pipeline)\n \n-          # We have to add the new AppliedTransform to the stack before expand()\n-          # and pop it out later to make sure that parts get added correctly.\n-          self.pipeline.transforms_stack.append(replacement_transform_node)\n-\n-          # Keeping the same label for the replaced node but recursively\n-          # removing labels of child transforms of original transform since they\n-          # will be replaced during the expand below. This is needed in case\n-          # the replacement contains children that have labels that conflicts\n-          # with labels of the children of the original.\n-          self.pipeline._remove_labels_recursively(original_transform_node)\n-\n-          new_output = replacement_transform.expand(input_node)\n-          assert isinstance(\n-              new_output, (dict, pvalue.PValue, pvalue.DoOutputsTuple))\n-\n-          if isinstance(new_output, pvalue.PValue):\n-            new_output.element_type = None\n-            self.pipeline._infer_result_type(\n-                replacement_transform, inputs, new_output)\n-\n-          if isinstance(new_output, dict):\n-            for new_tag, new_pcoll in new_output.items():\n-              replacement_transform_node.add_output(new_pcoll, new_tag)\n-          elif isinstance(new_output, pvalue.DoOutputsTuple):\n-            replacement_transform_node.add_output(\n-                new_output, new_output._main_tag)\n-          else:\n-            replacement_transform_node.add_output(new_output, new_output.tag)\n-\n-          # Recording updated outputs. This cannot be done in the same visitor\n-          # since if we dynamically update output type here, we'll run into\n-          # errors when visiting child nodes.\n-          #\n-          # NOTE: When replacing multiple outputs, the replacement PCollection\n-          # tags must have a matching tag in the original transform.\n-          if isinstance(new_output, pvalue.PValue):\n-            if not new_output.producer:\n-              new_output.producer = replacement_transform_node\n-            output_map[original_transform_node.outputs[new_output.tag]] = \\\n-                new_output\n-          elif isinstance(new_output, (pvalue.DoOutputsTuple, tuple)):\n-            for pcoll in new_output:\n-              if not pcoll.producer:\n-                pcoll.producer = replacement_transform_node\n-              output_map[original_transform_node.outputs[pcoll.tag]] = pcoll\n-          elif isinstance(new_output, dict):\n-            for tag, pcoll in new_output.items():\n-              if not pcoll.producer:\n-                pcoll.producer = replacement_transform_node\n-              output_map[original_transform_node.outputs[tag]] = pcoll\n-\n-          self.pipeline.transforms_stack.pop()\n+          try:\n+            # We have to add the new AppliedTransform to the stack before\n+            # expand() and pop it out later to make sure that parts get added\n+            # correctly.\n+            self.pipeline.transforms_stack.append(replacement_transform_node)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkzMzYwNA=="}, "originalCommit": {"oid": "d3f8e4b23f7aaccdcd18e9799e1ebe61a9956b8e"}, "originalPosition": 60}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1698, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}