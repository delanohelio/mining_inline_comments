{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1Njc0MTM0", "number": 10655, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNDowMDowMlrODbOsgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMzo0MjozMVrODcPR4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5ODc4OTEyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNDowMDowMlrOFil8Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMTozMzo1M1rOFkIz5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgxNzU0Nw==", "bodyText": "This won't update the access time when we first create the processor in the except block.", "url": "https://github.com/apache/beam/pull/10655#discussion_r371817547", "createdAt": "2020-01-28T14:00:02Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -280,6 +283,7 @@ def get(self, instruction_id, bundle_descriptor_id):\n     try:\n       # pop() is threadsafe\n       processor = self.cached_bundle_processors[bundle_descriptor_id].pop()\n+      self.last_access_time[bundle_descriptor_id] = time.time()\n     except IndexError:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94d67c719e0a784c0139358992a1c7010b4ad292"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE3NzA1Ng==", "bodyText": "This is expected. The last_access_time represents the last time the cached_bundle_processors for some bundle_descriptor is accessed. If it exceeds the time limit, the remaining bundle processors cached in the cached_bundle_processors will be shutdown. What's your thought?", "url": "https://github.com/apache/beam/pull/10655#discussion_r372177056", "createdAt": "2020-01-29T03:49:44Z", "author": {"login": "sunjincheng121"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -280,6 +283,7 @@ def get(self, instruction_id, bundle_descriptor_id):\n     try:\n       # pop() is threadsafe\n       processor = self.cached_bundle_processors[bundle_descriptor_id].pop()\n+      self.last_access_time[bundle_descriptor_id] = time.time()\n     except IndexError:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgxNzU0Nw=="}, "originalCommit": {"oid": "94d67c719e0a784c0139358992a1c7010b4ad292"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjMxMjQzMQ==", "bodyText": "In my eyes, the first time it is accessed is when it is created.", "url": "https://github.com/apache/beam/pull/10655#discussion_r372312431", "createdAt": "2020-01-29T10:50:30Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -280,6 +283,7 @@ def get(self, instruction_id, bundle_descriptor_id):\n     try:\n       # pop() is threadsafe\n       processor = self.cached_bundle_processors[bundle_descriptor_id].pop()\n+      self.last_access_time[bundle_descriptor_id] = time.time()\n     except IndexError:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgxNzU0Nw=="}, "originalCommit": {"oid": "94d67c719e0a784c0139358992a1c7010b4ad292"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY1NTA3NA==", "bodyText": "The strategy here is that the bundle processors which are unused after an amount of time will be shutdown. When a bundle processor is created in the exception block, there are no cached(unused) bundle processors. The bundle processors become unused only when they are added to the cached bundle processors list. What about rename last_access_time to cached_bundle_processors_last_access_time to make it more clear?", "url": "https://github.com/apache/beam/pull/10655#discussion_r372655074", "createdAt": "2020-01-29T22:01:21Z", "author": {"login": "sunjincheng121"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -280,6 +283,7 @@ def get(self, instruction_id, bundle_descriptor_id):\n     try:\n       # pop() is threadsafe\n       processor = self.cached_bundle_processors[bundle_descriptor_id].pop()\n+      self.last_access_time[bundle_descriptor_id] = time.time()\n     except IndexError:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgxNzU0Nw=="}, "originalCommit": {"oid": "94d67c719e0a784c0139358992a1c7010b4ad292"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk0NjA2Mw==", "bodyText": "I still do not understand, the method is named get, so we access the bundle processor independently of whether we create it or not. It is cached, regardless of whether it is created and added to the cache, or retrieved from the cache.\nLogically, you might want to update the time when putting the processor into the cache. That would be in release.\nWhat is the advantage of updating the time here? It should be sufficient to update it in release, directly before putting it back.", "url": "https://github.com/apache/beam/pull/10655#discussion_r372946063", "createdAt": "2020-01-30T13:28:19Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -280,6 +283,7 @@ def get(self, instruction_id, bundle_descriptor_id):\n     try:\n       # pop() is threadsafe\n       processor = self.cached_bundle_processors[bundle_descriptor_id].pop()\n+      self.last_access_time[bundle_descriptor_id] = time.time()\n     except IndexError:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgxNzU0Nw=="}, "originalCommit": {"oid": "94d67c719e0a784c0139358992a1c7010b4ad292"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk3MjIyMw==", "bodyText": "Hmm, If a bundle processor is retrieved from the cache, there is a high possibility that the remaining cached bundle processors will be needed in the future and so the last access time is updated.\nIf the bundle processor is newly created, it means that the cached bundle processor list is empty. This is the main reason that the last access time is only updated when bundle processor is retrieved from the cache. However, I think that it does no harm to update the last access time in both cases if it makes the code more readable.\nWhat do you think?", "url": "https://github.com/apache/beam/pull/10655#discussion_r372972223", "createdAt": "2020-01-30T14:16:11Z", "author": {"login": "sunjincheng121"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -280,6 +283,7 @@ def get(self, instruction_id, bundle_descriptor_id):\n     try:\n       # pop() is threadsafe\n       processor = self.cached_bundle_processors[bundle_descriptor_id].pop()\n+      self.last_access_time[bundle_descriptor_id] = time.time()\n     except IndexError:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgxNzU0Nw=="}, "originalCommit": {"oid": "94d67c719e0a784c0139358992a1c7010b4ad292"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM4NDk0OA==", "bodyText": "If the bundle processor is newly created, it means that the cached bundle processor list is empty. This is the main reason that the last access time is only updated when bundle processor is retrieved from the cache.\n\nConsider the case where we just have a single bundle processor. When we call get for the first time, we won't update the last-used time. However, every time we retrieve it afterwards, we will update the time, but the list of cached bundle processors will remain empty.\nI think we should either (1) always update the last-used timestamp in get, regardless of creation or (2) update it only on release.\nI'm leaning towards (2) because while a bundle processor is in-use, it can't be removed anyways. We update the timestamp when we put it back in release.", "url": "https://github.com/apache/beam/pull/10655#discussion_r373384948", "createdAt": "2020-01-31T09:26:43Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -280,6 +283,7 @@ def get(self, instruction_id, bundle_descriptor_id):\n     try:\n       # pop() is threadsafe\n       processor = self.cached_bundle_processors[bundle_descriptor_id].pop()\n+      self.last_access_time[bundle_descriptor_id] = time.time()\n     except IndexError:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgxNzU0Nw=="}, "originalCommit": {"oid": "94d67c719e0a784c0139358992a1c7010b4ad292"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzNzQxNA==", "bodyText": "Regarding the single bundle processor case, it doesn't harm to update the time as the cached bundle processors is empty. However, in cases where there are multiple bundle processors, it will update the time for the remaining cached bundle processors and so improve the cache hit rate. I think this is main difference between solution (1) and (2). However, I'm fine with both solutions as I think both of them work. Will update the PR according to solution (2) if you are favor of it according to your experience.", "url": "https://github.com/apache/beam/pull/10655#discussion_r373437414", "createdAt": "2020-01-31T11:33:53Z", "author": {"login": "sunjincheng121"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -280,6 +283,7 @@ def get(self, instruction_id, bundle_descriptor_id):\n     try:\n       # pop() is threadsafe\n       processor = self.cached_bundle_processors[bundle_descriptor_id].pop()\n+      self.last_access_time[bundle_descriptor_id] = time.time()\n     except IndexError:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgxNzU0Nw=="}, "originalCommit": {"oid": "94d67c719e0a784c0139358992a1c7010b4ad292"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5ODc5MTg5OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNDowMDo1NFrOFil9-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMDo1NDowM1rOFjEQCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgxNzk3OA==", "bodyText": "We may want to make this configurable.", "url": "https://github.com/apache/beam/pull/10655#discussion_r371817978", "createdAt": "2020-01-28T14:00:54Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -315,18 +319,47 @@ def release(self, instruction_id):\n     \"\"\"\n     descriptor_id, processor = self.active_bundle_processors.pop(instruction_id)\n     processor.reset()\n+    self.last_access_time[descriptor_id] = time.time()\n     self.cached_bundle_processors[descriptor_id].append(processor)\n \n   def shutdown(self):\n     \"\"\"\n     Shutdown all ``BundleProcessor``s in the cache.\n     \"\"\"\n+    if self.periodic_shutdown:\n+      self.periodic_shutdown.cancel()\n+      self.periodic_shutdown.join()\n+      self.periodic_shutdown = None\n+\n     for instruction_id in self.active_bundle_processors:\n       self.active_bundle_processors[instruction_id][1].shutdown()\n       del self.active_bundle_processors[instruction_id]\n     for cached_bundle_processors in self.cached_bundle_processors.values():\n-      while len(cached_bundle_processors) > 0:\n-        cached_bundle_processors.pop().shutdown()\n+      BundleProcessorCache._shutdown_cached_bundle_processors(\n+          cached_bundle_processors)\n+\n+  def _schedule_periodic_shutdown(self):\n+    def shutdown_inactive_bundle_processors():\n+      for descriptor_id, last_access_time in self.last_access_time.items():\n+        if time.time() - last_access_time > 60:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94d67c719e0a784c0139358992a1c7010b4ad292"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE3NzM1NA==", "bodyText": "I'm not pretty sure if it deserves a configuration. What about extracting it to a variable initially as you suggested below?", "url": "https://github.com/apache/beam/pull/10655#discussion_r372177354", "createdAt": "2020-01-29T03:51:35Z", "author": {"login": "sunjincheng121"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -315,18 +319,47 @@ def release(self, instruction_id):\n     \"\"\"\n     descriptor_id, processor = self.active_bundle_processors.pop(instruction_id)\n     processor.reset()\n+    self.last_access_time[descriptor_id] = time.time()\n     self.cached_bundle_processors[descriptor_id].append(processor)\n \n   def shutdown(self):\n     \"\"\"\n     Shutdown all ``BundleProcessor``s in the cache.\n     \"\"\"\n+    if self.periodic_shutdown:\n+      self.periodic_shutdown.cancel()\n+      self.periodic_shutdown.join()\n+      self.periodic_shutdown = None\n+\n     for instruction_id in self.active_bundle_processors:\n       self.active_bundle_processors[instruction_id][1].shutdown()\n       del self.active_bundle_processors[instruction_id]\n     for cached_bundle_processors in self.cached_bundle_processors.values():\n-      while len(cached_bundle_processors) > 0:\n-        cached_bundle_processors.pop().shutdown()\n+      BundleProcessorCache._shutdown_cached_bundle_processors(\n+          cached_bundle_processors)\n+\n+  def _schedule_periodic_shutdown(self):\n+    def shutdown_inactive_bundle_processors():\n+      for descriptor_id, last_access_time in self.last_access_time.items():\n+        if time.time() - last_access_time > 60:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgxNzk3OA=="}, "originalCommit": {"oid": "94d67c719e0a784c0139358992a1c7010b4ad292"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjMxNDEyMw==", "bodyText": "Sounds good.", "url": "https://github.com/apache/beam/pull/10655#discussion_r372314123", "createdAt": "2020-01-29T10:54:03Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -315,18 +319,47 @@ def release(self, instruction_id):\n     \"\"\"\n     descriptor_id, processor = self.active_bundle_processors.pop(instruction_id)\n     processor.reset()\n+    self.last_access_time[descriptor_id] = time.time()\n     self.cached_bundle_processors[descriptor_id].append(processor)\n \n   def shutdown(self):\n     \"\"\"\n     Shutdown all ``BundleProcessor``s in the cache.\n     \"\"\"\n+    if self.periodic_shutdown:\n+      self.periodic_shutdown.cancel()\n+      self.periodic_shutdown.join()\n+      self.periodic_shutdown = None\n+\n     for instruction_id in self.active_bundle_processors:\n       self.active_bundle_processors[instruction_id][1].shutdown()\n       del self.active_bundle_processors[instruction_id]\n     for cached_bundle_processors in self.cached_bundle_processors.values():\n-      while len(cached_bundle_processors) > 0:\n-        cached_bundle_processors.pop().shutdown()\n+      BundleProcessorCache._shutdown_cached_bundle_processors(\n+          cached_bundle_processors)\n+\n+  def _schedule_periodic_shutdown(self):\n+    def shutdown_inactive_bundle_processors():\n+      for descriptor_id, last_access_time in self.last_access_time.items():\n+        if time.time() - last_access_time > 60:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgxNzk3OA=="}, "originalCommit": {"oid": "94d67c719e0a784c0139358992a1c7010b4ad292"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5ODc5Mjk1OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNDowMToxN1rOFil-sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNDowMToxN1rOFil-sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgxODE2Mg==", "bodyText": "Same here. Should be configurable or at least be extracted to a variable.", "url": "https://github.com/apache/beam/pull/10655#discussion_r371818162", "createdAt": "2020-01-28T14:01:17Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -315,18 +319,47 @@ def release(self, instruction_id):\n     \"\"\"\n     descriptor_id, processor = self.active_bundle_processors.pop(instruction_id)\n     processor.reset()\n+    self.last_access_time[descriptor_id] = time.time()\n     self.cached_bundle_processors[descriptor_id].append(processor)\n \n   def shutdown(self):\n     \"\"\"\n     Shutdown all ``BundleProcessor``s in the cache.\n     \"\"\"\n+    if self.periodic_shutdown:\n+      self.periodic_shutdown.cancel()\n+      self.periodic_shutdown.join()\n+      self.periodic_shutdown = None\n+\n     for instruction_id in self.active_bundle_processors:\n       self.active_bundle_processors[instruction_id][1].shutdown()\n       del self.active_bundle_processors[instruction_id]\n     for cached_bundle_processors in self.cached_bundle_processors.values():\n-      while len(cached_bundle_processors) > 0:\n-        cached_bundle_processors.pop().shutdown()\n+      BundleProcessorCache._shutdown_cached_bundle_processors(\n+          cached_bundle_processors)\n+\n+  def _schedule_periodic_shutdown(self):\n+    def shutdown_inactive_bundle_processors():\n+      for descriptor_id, last_access_time in self.last_access_time.items():\n+        if time.time() - last_access_time > 60:\n+          BundleProcessorCache._shutdown_cached_bundle_processors(\n+              self.cached_bundle_processors[descriptor_id])\n+\n+    from apache_beam.runners.worker.data_plane import PeriodicThread\n+    self.periodic_shutdown = PeriodicThread(\n+        60, shutdown_inactive_bundle_processors)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94d67c719e0a784c0139358992a1c7010b4ad292"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5ODc5Nzk3OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNDowMjo1OVrOFimCCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNDowMjo1OVrOFimCCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgxOTAxOA==", "bodyText": "I think we should move this to the import section.", "url": "https://github.com/apache/beam/pull/10655#discussion_r371819018", "createdAt": "2020-01-28T14:02:59Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -315,18 +319,47 @@ def release(self, instruction_id):\n     \"\"\"\n     descriptor_id, processor = self.active_bundle_processors.pop(instruction_id)\n     processor.reset()\n+    self.last_access_time[descriptor_id] = time.time()\n     self.cached_bundle_processors[descriptor_id].append(processor)\n \n   def shutdown(self):\n     \"\"\"\n     Shutdown all ``BundleProcessor``s in the cache.\n     \"\"\"\n+    if self.periodic_shutdown:\n+      self.periodic_shutdown.cancel()\n+      self.periodic_shutdown.join()\n+      self.periodic_shutdown = None\n+\n     for instruction_id in self.active_bundle_processors:\n       self.active_bundle_processors[instruction_id][1].shutdown()\n       del self.active_bundle_processors[instruction_id]\n     for cached_bundle_processors in self.cached_bundle_processors.values():\n-      while len(cached_bundle_processors) > 0:\n-        cached_bundle_processors.pop().shutdown()\n+      BundleProcessorCache._shutdown_cached_bundle_processors(\n+          cached_bundle_processors)\n+\n+  def _schedule_periodic_shutdown(self):\n+    def shutdown_inactive_bundle_processors():\n+      for descriptor_id, last_access_time in self.last_access_time.items():\n+        if time.time() - last_access_time > 60:\n+          BundleProcessorCache._shutdown_cached_bundle_processors(\n+              self.cached_bundle_processors[descriptor_id])\n+\n+    from apache_beam.runners.worker.data_plane import PeriodicThread", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94d67c719e0a784c0139358992a1c7010b4ad292"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5ODgwOTg4OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNDowNjozMVrOFimJgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMDo1MjoxNVrOFjEMoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgyMDkzMQ==", "bodyText": "Don't we have to remove the bundle processor list from the dictionary? Otherwise we may access a cached shutdown bundle processor.", "url": "https://github.com/apache/beam/pull/10655#discussion_r371820931", "createdAt": "2020-01-28T14:06:31Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -315,18 +319,47 @@ def release(self, instruction_id):\n     \"\"\"\n     descriptor_id, processor = self.active_bundle_processors.pop(instruction_id)\n     processor.reset()\n+    self.last_access_time[descriptor_id] = time.time()\n     self.cached_bundle_processors[descriptor_id].append(processor)\n \n   def shutdown(self):\n     \"\"\"\n     Shutdown all ``BundleProcessor``s in the cache.\n     \"\"\"\n+    if self.periodic_shutdown:\n+      self.periodic_shutdown.cancel()\n+      self.periodic_shutdown.join()\n+      self.periodic_shutdown = None\n+\n     for instruction_id in self.active_bundle_processors:\n       self.active_bundle_processors[instruction_id][1].shutdown()\n       del self.active_bundle_processors[instruction_id]\n     for cached_bundle_processors in self.cached_bundle_processors.values():\n-      while len(cached_bundle_processors) > 0:\n-        cached_bundle_processors.pop().shutdown()\n+      BundleProcessorCache._shutdown_cached_bundle_processors(\n+          cached_bundle_processors)\n+\n+  def _schedule_periodic_shutdown(self):\n+    def shutdown_inactive_bundle_processors():\n+      for descriptor_id, last_access_time in self.last_access_time.items():\n+        if time.time() - last_access_time > 60:\n+          BundleProcessorCache._shutdown_cached_bundle_processors(\n+              self.cached_bundle_processors[descriptor_id])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94d67c719e0a784c0139358992a1c7010b4ad292"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE3Nzk3Mg==", "bodyText": "The bundle processor will be popped from the bundle processor list before shutdown and the pop operation is thread safe and so I think this will not happen. What's your thought?", "url": "https://github.com/apache/beam/pull/10655#discussion_r372177972", "createdAt": "2020-01-29T03:55:36Z", "author": {"login": "sunjincheng121"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -315,18 +319,47 @@ def release(self, instruction_id):\n     \"\"\"\n     descriptor_id, processor = self.active_bundle_processors.pop(instruction_id)\n     processor.reset()\n+    self.last_access_time[descriptor_id] = time.time()\n     self.cached_bundle_processors[descriptor_id].append(processor)\n \n   def shutdown(self):\n     \"\"\"\n     Shutdown all ``BundleProcessor``s in the cache.\n     \"\"\"\n+    if self.periodic_shutdown:\n+      self.periodic_shutdown.cancel()\n+      self.periodic_shutdown.join()\n+      self.periodic_shutdown = None\n+\n     for instruction_id in self.active_bundle_processors:\n       self.active_bundle_processors[instruction_id][1].shutdown()\n       del self.active_bundle_processors[instruction_id]\n     for cached_bundle_processors in self.cached_bundle_processors.values():\n-      while len(cached_bundle_processors) > 0:\n-        cached_bundle_processors.pop().shutdown()\n+      BundleProcessorCache._shutdown_cached_bundle_processors(\n+          cached_bundle_processors)\n+\n+  def _schedule_periodic_shutdown(self):\n+    def shutdown_inactive_bundle_processors():\n+      for descriptor_id, last_access_time in self.last_access_time.items():\n+        if time.time() - last_access_time > 60:\n+          BundleProcessorCache._shutdown_cached_bundle_processors(\n+              self.cached_bundle_processors[descriptor_id])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgyMDkzMQ=="}, "originalCommit": {"oid": "94d67c719e0a784c0139358992a1c7010b4ad292"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjMxMzI0OA==", "bodyText": "True, since the pop on the list is thread-safe, we can't wind up with a cached bundle processor being in use.", "url": "https://github.com/apache/beam/pull/10655#discussion_r372313248", "createdAt": "2020-01-29T10:52:15Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -315,18 +319,47 @@ def release(self, instruction_id):\n     \"\"\"\n     descriptor_id, processor = self.active_bundle_processors.pop(instruction_id)\n     processor.reset()\n+    self.last_access_time[descriptor_id] = time.time()\n     self.cached_bundle_processors[descriptor_id].append(processor)\n \n   def shutdown(self):\n     \"\"\"\n     Shutdown all ``BundleProcessor``s in the cache.\n     \"\"\"\n+    if self.periodic_shutdown:\n+      self.periodic_shutdown.cancel()\n+      self.periodic_shutdown.join()\n+      self.periodic_shutdown = None\n+\n     for instruction_id in self.active_bundle_processors:\n       self.active_bundle_processors[instruction_id][1].shutdown()\n       del self.active_bundle_processors[instruction_id]\n     for cached_bundle_processors in self.cached_bundle_processors.values():\n-      while len(cached_bundle_processors) > 0:\n-        cached_bundle_processors.pop().shutdown()\n+      BundleProcessorCache._shutdown_cached_bundle_processors(\n+          cached_bundle_processors)\n+\n+  def _schedule_periodic_shutdown(self):\n+    def shutdown_inactive_bundle_processors():\n+      for descriptor_id, last_access_time in self.last_access_time.items():\n+        if time.time() - last_access_time > 60:\n+          BundleProcessorCache._shutdown_cached_bundle_processors(\n+              self.cached_bundle_processors[descriptor_id])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgyMDkzMQ=="}, "originalCommit": {"oid": "94d67c719e0a784c0139358992a1c7010b4ad292"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwOTM2NjQ3OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMzo0MToxMlrOFkLn9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMzo0MToxMlrOFkLn9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ4MzUwOA==", "bodyText": "nit: you could surround the condition with paranthesis which would make it easier to read, e.g.\n       if (time.time() - last_access_time >\n                DEFAULT_BUNDLE_PROCESSOR_CACHE_THRESHOLD_S):", "url": "https://github.com/apache/beam/pull/10655#discussion_r373483508", "createdAt": "2020-01-31T13:41:12Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -315,18 +322,49 @@ def release(self, instruction_id):\n     \"\"\"\n     descriptor_id, processor = self.active_bundle_processors.pop(instruction_id)\n     processor.reset()\n+    self.cached_bundle_processors_last_access_time[descriptor_id] = time.time()\n     self.cached_bundle_processors[descriptor_id].append(processor)\n \n   def shutdown(self):\n     \"\"\"\n     Shutdown all ``BundleProcessor``s in the cache.\n     \"\"\"\n+    if self.periodic_shutdown:\n+      self.periodic_shutdown.cancel()\n+      self.periodic_shutdown.join()\n+      self.periodic_shutdown = None\n+\n     for instruction_id in self.active_bundle_processors:\n       self.active_bundle_processors[instruction_id][1].shutdown()\n       del self.active_bundle_processors[instruction_id]\n     for cached_bundle_processors in self.cached_bundle_processors.values():\n-      while len(cached_bundle_processors) > 0:\n-        cached_bundle_processors.pop().shutdown()\n+      BundleProcessorCache._shutdown_cached_bundle_processors(\n+          cached_bundle_processors)\n+\n+  def _schedule_periodic_shutdown(self):\n+    def shutdown_inactive_bundle_processors():\n+      for descriptor_id, last_access_time in \\\n+              self.cached_bundle_processors_last_access_time.items():\n+        if time.time() - last_access_time > \\\n+                DEFAULT_BUNDLE_PROCESSOR_CACHE_THRESHOLD_S:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddf68a2630f9e77ac41b94955e1fb9b2834cdda6"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwOTM2OTk0OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMzo0MjoxNlrOFkLqDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMzo0MjoxNlrOFkLqDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ4NDA0Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            DEFAULT_BUNDLE_PROCESSOR_CACHE_THRESHOLD_S = 60\n          \n          \n            \n            DEFAULT_BUNDLE_PROCESSOR_CACHE_SHUTDOWN_THRESHOLD_S = 60", "url": "https://github.com/apache/beam/pull/10655#discussion_r373484046", "createdAt": "2020-01-31T13:42:16Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -69,6 +71,8 @@\n # 5 minutes * 60 seconds * 1020 millis * 1000 micros * 1000 nanoseconds\n DEFAULT_LOG_LULL_TIMEOUT_NS = 5 * 60 * 1000 * 1000 * 1000\n \n+DEFAULT_BUNDLE_PROCESSOR_CACHE_THRESHOLD_S = 60", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddf68a2630f9e77ac41b94955e1fb9b2834cdda6"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwOTM3MDU5OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMzo0MjozMVrOFkLqeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMDo1NDowM1rOFm5bkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ4NDE1NA==", "bodyText": "Same here, use parenthesis.", "url": "https://github.com/apache/beam/pull/10655#discussion_r373484154", "createdAt": "2020-01-31T13:42:31Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -315,18 +322,49 @@ def release(self, instruction_id):\n     \"\"\"\n     descriptor_id, processor = self.active_bundle_processors.pop(instruction_id)\n     processor.reset()\n+    self.cached_bundle_processors_last_access_time[descriptor_id] = time.time()\n     self.cached_bundle_processors[descriptor_id].append(processor)\n \n   def shutdown(self):\n     \"\"\"\n     Shutdown all ``BundleProcessor``s in the cache.\n     \"\"\"\n+    if self.periodic_shutdown:\n+      self.periodic_shutdown.cancel()\n+      self.periodic_shutdown.join()\n+      self.periodic_shutdown = None\n+\n     for instruction_id in self.active_bundle_processors:\n       self.active_bundle_processors[instruction_id][1].shutdown()\n       del self.active_bundle_processors[instruction_id]\n     for cached_bundle_processors in self.cached_bundle_processors.values():\n-      while len(cached_bundle_processors) > 0:\n-        cached_bundle_processors.pop().shutdown()\n+      BundleProcessorCache._shutdown_cached_bundle_processors(\n+          cached_bundle_processors)\n+\n+  def _schedule_periodic_shutdown(self):\n+    def shutdown_inactive_bundle_processors():\n+      for descriptor_id, last_access_time in \\\n+              self.cached_bundle_processors_last_access_time.items():", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddf68a2630f9e77ac41b94955e1fb9b2834cdda6"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0OTc4Ng==", "bodyText": "It seems that it doesn't support parenthesis in the for loop\uff1f", "url": "https://github.com/apache/beam/pull/10655#discussion_r373749786", "createdAt": "2020-02-01T02:01:14Z", "author": {"login": "sunjincheng121"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -315,18 +322,49 @@ def release(self, instruction_id):\n     \"\"\"\n     descriptor_id, processor = self.active_bundle_processors.pop(instruction_id)\n     processor.reset()\n+    self.cached_bundle_processors_last_access_time[descriptor_id] = time.time()\n     self.cached_bundle_processors[descriptor_id].append(processor)\n \n   def shutdown(self):\n     \"\"\"\n     Shutdown all ``BundleProcessor``s in the cache.\n     \"\"\"\n+    if self.periodic_shutdown:\n+      self.periodic_shutdown.cancel()\n+      self.periodic_shutdown.join()\n+      self.periodic_shutdown = None\n+\n     for instruction_id in self.active_bundle_processors:\n       self.active_bundle_processors[instruction_id][1].shutdown()\n       del self.active_bundle_processors[instruction_id]\n     for cached_bundle_processors in self.cached_bundle_processors.values():\n-      while len(cached_bundle_processors) > 0:\n-        cached_bundle_processors.pop().shutdown()\n+      BundleProcessorCache._shutdown_cached_bundle_processors(\n+          cached_bundle_processors)\n+\n+  def _schedule_periodic_shutdown(self):\n+    def shutdown_inactive_bundle_processors():\n+      for descriptor_id, last_access_time in \\\n+              self.cached_bundle_processors_last_access_time.items():", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ4NDE1NA=="}, "originalCommit": {"oid": "ddf68a2630f9e77ac41b94955e1fb9b2834cdda6"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ2ODM1Ng==", "bodyText": "It should, there are many examples of for loops using parentheses in the code base already.", "url": "https://github.com/apache/beam/pull/10655#discussion_r375468356", "createdAt": "2020-02-05T19:41:48Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -315,18 +322,49 @@ def release(self, instruction_id):\n     \"\"\"\n     descriptor_id, processor = self.active_bundle_processors.pop(instruction_id)\n     processor.reset()\n+    self.cached_bundle_processors_last_access_time[descriptor_id] = time.time()\n     self.cached_bundle_processors[descriptor_id].append(processor)\n \n   def shutdown(self):\n     \"\"\"\n     Shutdown all ``BundleProcessor``s in the cache.\n     \"\"\"\n+    if self.periodic_shutdown:\n+      self.periodic_shutdown.cancel()\n+      self.periodic_shutdown.join()\n+      self.periodic_shutdown = None\n+\n     for instruction_id in self.active_bundle_processors:\n       self.active_bundle_processors[instruction_id][1].shutdown()\n       del self.active_bundle_processors[instruction_id]\n     for cached_bundle_processors in self.cached_bundle_processors.values():\n-      while len(cached_bundle_processors) > 0:\n-        cached_bundle_processors.pop().shutdown()\n+      BundleProcessorCache._shutdown_cached_bundle_processors(\n+          cached_bundle_processors)\n+\n+  def _schedule_periodic_shutdown(self):\n+    def shutdown_inactive_bundle_processors():\n+      for descriptor_id, last_access_time in \\\n+              self.cached_bundle_processors_last_access_time.items():", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ4NDE1NA=="}, "originalCommit": {"oid": "ddf68a2630f9e77ac41b94955e1fb9b2834cdda6"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMzMTE1Mw==", "bodyText": "Ah, I have added a local variable and it should have no this problem now. Is that make sense to you?", "url": "https://github.com/apache/beam/pull/10655#discussion_r376331153", "createdAt": "2020-02-07T10:54:03Z", "author": {"login": "sunjincheng121"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -315,18 +322,49 @@ def release(self, instruction_id):\n     \"\"\"\n     descriptor_id, processor = self.active_bundle_processors.pop(instruction_id)\n     processor.reset()\n+    self.cached_bundle_processors_last_access_time[descriptor_id] = time.time()\n     self.cached_bundle_processors[descriptor_id].append(processor)\n \n   def shutdown(self):\n     \"\"\"\n     Shutdown all ``BundleProcessor``s in the cache.\n     \"\"\"\n+    if self.periodic_shutdown:\n+      self.periodic_shutdown.cancel()\n+      self.periodic_shutdown.join()\n+      self.periodic_shutdown = None\n+\n     for instruction_id in self.active_bundle_processors:\n       self.active_bundle_processors[instruction_id][1].shutdown()\n       del self.active_bundle_processors[instruction_id]\n     for cached_bundle_processors in self.cached_bundle_processors.values():\n-      while len(cached_bundle_processors) > 0:\n-        cached_bundle_processors.pop().shutdown()\n+      BundleProcessorCache._shutdown_cached_bundle_processors(\n+          cached_bundle_processors)\n+\n+  def _schedule_periodic_shutdown(self):\n+    def shutdown_inactive_bundle_processors():\n+      for descriptor_id, last_access_time in \\\n+              self.cached_bundle_processors_last_access_time.items():", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ4NDE1NA=="}, "originalCommit": {"oid": "ddf68a2630f9e77ac41b94955e1fb9b2834cdda6"}, "originalPosition": 63}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2241, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}