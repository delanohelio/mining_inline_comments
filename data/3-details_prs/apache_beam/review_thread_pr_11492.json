{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3MzYwMzc1", "number": 11492, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzoyNzozMVrOD04FlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMzozMTo0NFrOD4gp5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NzcxNDc2OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/common.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzoyNzozMVrOGKCOIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzoyNzozMVrOGKCOIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3NTMzMA==", "bodyText": "The paneinfo should also be passed in here. You can get paneinfo from timer.paneinfo", "url": "https://github.com/apache/beam/pull/11492#discussion_r413175330", "createdAt": "2020-04-22T17:27:31Z", "author": {"login": "boyuanzz"}, "path": "sdks/python/apache_beam/runners/common.py", "diffHunk": "@@ -229,7 +229,7 @@ def invoke_timer_callback(self, user_state_context, key, window, timestamp):\n         kwargs[kw] = user_state_context.get_state(state_spec, key, window)\n       for kw, timer_spec in self.timer_args_to_replace.items():\n         kwargs[kw] = user_state_context.get_timer(\n-            timer_spec, key, window, None, None)\n+            timer_spec, key, window, timestamp, None)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c840654747306a2135a55ed1f6f9e426dea2748"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODYwOTg4OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/operations.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMDo0MjowM1rOGKKvEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMDo0Mjo0OFrOGKKw0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMxNDgzNQ==", "bodyText": "timer_data.paneinfo", "url": "https://github.com/apache/beam/pull/11492#discussion_r413314835", "createdAt": "2020-04-22T20:42:03Z", "author": {"login": "boyuanzz"}, "path": "sdks/python/apache_beam/runners/worker/operations.py", "diffHunk": "@@ -685,7 +685,8 @@ def process_timer(self, tag, timer_data):\n         timer_spec,\n         timer_data.user_key,\n         timer_data.windows[0],\n-        timer_data.fire_timestamp)\n+        timer_data.fire_timestamp,\n+        timer_data.pane_info)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9961394d4e25c8c3dd1ed5e59983b9a238664957"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMxNTI4MQ==", "bodyText": "https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/userstate.py#L134-L142", "url": "https://github.com/apache/beam/pull/11492#discussion_r413315281", "createdAt": "2020-04-22T20:42:48Z", "author": {"login": "boyuanzz"}, "path": "sdks/python/apache_beam/runners/worker/operations.py", "diffHunk": "@@ -685,7 +685,8 @@ def process_timer(self, tag, timer_data):\n         timer_spec,\n         timer_data.user_key,\n         timer_data.windows[0],\n-        timer_data.fire_timestamp)\n+        timer_data.fire_timestamp,\n+        timer_data.pane_info)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMxNDgzNQ=="}, "originalCommit": {"oid": "9961394d4e25c8c3dd1ed5e59983b9a238664957"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NTA4NDc3OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNDowNToxNVrOGLFbFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMTowOTo0N1rOGN6CmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3NjM3NA==", "bodyText": "I don't think we should set timer_buffer.cleared to False here.  There is an assumption around FnApiRunner.ListBuffer that per key the timer is only fired once. It seems like the assumption is broken by setting a new timer when firing the timer. If that's the case, we should consider updating the logic around timer buffer.", "url": "https://github.com/apache/beam/pull/11492#discussion_r414276374", "createdAt": "2020-04-24T04:05:15Z", "author": {"login": "boyuanzz"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -845,10 +845,12 @@ def process_bundle(self,\n           (result_future.is_done() and result_future.get().error)):\n         if isinstance(output, beam_fn_api_pb2.Elements.Timers) and not dry_run:\n           with BundleManager._lock:\n-            self.bundle_context_manager.get_buffer(\n+            timer_buffer = self.bundle_context_manager.get_buffer(\n                 expected_output_timers[(\n                     output.transform_id, output.timer_family_id)],\n-                output.transform_id).append(output.timers)\n+                output.transform_id)\n+            timer_buffer.cleared = False", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10f217fb8adf21e54d5f7b2641bb8d0568372f9e"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUwNDEyMA==", "bodyText": "Where can I find this assumption? Note that the tests are passing.\nI think it makes sense to reset the flag; when the timer is set after firing we should treat it independently from any prior settings of the timer. We may want to leave a comment here why this is necessary. Alternatively, the resetting may be done directly after the timer is fired.", "url": "https://github.com/apache/beam/pull/11492#discussion_r414504120", "createdAt": "2020-04-24T11:30:58Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -845,10 +845,12 @@ def process_bundle(self,\n           (result_future.is_done() and result_future.get().error)):\n         if isinstance(output, beam_fn_api_pb2.Elements.Timers) and not dry_run:\n           with BundleManager._lock:\n-            self.bundle_context_manager.get_buffer(\n+            timer_buffer = self.bundle_context_manager.get_buffer(\n                 expected_output_timers[(\n                     output.transform_id, output.timer_family_id)],\n-                output.transform_id).append(output.timers)\n+                output.transform_id)\n+            timer_buffer.cleared = False", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3NjM3NA=="}, "originalCommit": {"oid": "10f217fb8adf21e54d5f7b2641bb8d0568372f9e"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczNDEzNw==", "bodyText": "@pabloem who is the original author of ListBuffer. I prefer the second way Max mentioned above. What do you think? Other than this part, timer changes look good to me.", "url": "https://github.com/apache/beam/pull/11492#discussion_r414734137", "createdAt": "2020-04-24T17:14:58Z", "author": {"login": "boyuanzz"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -845,10 +845,12 @@ def process_bundle(self,\n           (result_future.is_done() and result_future.get().error)):\n         if isinstance(output, beam_fn_api_pb2.Elements.Timers) and not dry_run:\n           with BundleManager._lock:\n-            self.bundle_context_manager.get_buffer(\n+            timer_buffer = self.bundle_context_manager.get_buffer(\n                 expected_output_timers[(\n                     output.transform_id, output.timer_family_id)],\n-                output.transform_id).append(output.timers)\n+                output.transform_id)\n+            timer_buffer.cleared = False", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3NjM3NA=="}, "originalCommit": {"oid": "10f217fb8adf21e54d5f7b2641bb8d0568372f9e"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyMTk5OQ==", "bodyText": "Did you run into these errors when setting a timer from the timer call, Max? I think it would be good to explicitly reset the buffer, rather than manipulate its flag (e.g. write a timer_buffer.reset function). Or at least check if timer_buffer.cleared: timer_buffer.cleared = False, to confirm that the rest of the internal context in ListBuffer is cleared.", "url": "https://github.com/apache/beam/pull/11492#discussion_r416921999", "createdAt": "2020-04-28T21:05:33Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -845,10 +845,12 @@ def process_bundle(self,\n           (result_future.is_done() and result_future.get().error)):\n         if isinstance(output, beam_fn_api_pb2.Elements.Timers) and not dry_run:\n           with BundleManager._lock:\n-            self.bundle_context_manager.get_buffer(\n+            timer_buffer = self.bundle_context_manager.get_buffer(\n                 expected_output_timers[(\n                     output.transform_id, output.timer_family_id)],\n-                output.transform_id).append(output.timers)\n+                output.transform_id)\n+            timer_buffer.cleared = False", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3NjM3NA=="}, "originalCommit": {"oid": "10f217fb8adf21e54d5f7b2641bb8d0568372f9e"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIxMTc3MQ==", "bodyText": "Did you run into these errors when setting a timer from the timer call, Max?\n\nThat's the point of this PR :) It is simply not possible to set a new timer from a firing timer without resetting the timer buffer.\n\nOr at least check if timer_buffer.cleared: timer_buffer.cleared = False\n\nThat is semantically identical to the current code. It is redundant to have the if check because when timer_buffer.cleared is False, then setting it to False again won't have any effect.\nI can add a reset() method which additionally checks whether the buffer had been cleared before. I think this is what you meant by the check.", "url": "https://github.com/apache/beam/pull/11492#discussion_r417211771", "createdAt": "2020-04-29T10:22:31Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -845,10 +845,12 @@ def process_bundle(self,\n           (result_future.is_done() and result_future.get().error)):\n         if isinstance(output, beam_fn_api_pb2.Elements.Timers) and not dry_run:\n           with BundleManager._lock:\n-            self.bundle_context_manager.get_buffer(\n+            timer_buffer = self.bundle_context_manager.get_buffer(\n                 expected_output_timers[(\n                     output.transform_id, output.timer_family_id)],\n-                output.transform_id).append(output.timers)\n+                output.transform_id)\n+            timer_buffer.cleared = False", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3NjM3NA=="}, "originalCommit": {"oid": "10f217fb8adf21e54d5f7b2641bb8d0568372f9e"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIyMTIwNg==", "bodyText": "Updated. PTAL @pabloem", "url": "https://github.com/apache/beam/pull/11492#discussion_r417221206", "createdAt": "2020-04-29T10:40:51Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -845,10 +845,12 @@ def process_bundle(self,\n           (result_future.is_done() and result_future.get().error)):\n         if isinstance(output, beam_fn_api_pb2.Elements.Timers) and not dry_run:\n           with BundleManager._lock:\n-            self.bundle_context_manager.get_buffer(\n+            timer_buffer = self.bundle_context_manager.get_buffer(\n                 expected_output_timers[(\n                     output.transform_id, output.timer_family_id)],\n-                output.transform_id).append(output.timers)\n+                output.transform_id)\n+            timer_buffer.cleared = False", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3NjM3NA=="}, "originalCommit": {"oid": "10f217fb8adf21e54d5f7b2641bb8d0568372f9e"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIzNTI2OQ==", "bodyText": "This made things more complicated because I also have to allow resetting when the buffer has never been used before, i.e. when the timer set for the first time.", "url": "https://github.com/apache/beam/pull/11492#discussion_r417235269", "createdAt": "2020-04-29T11:09:01Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -845,10 +845,12 @@ def process_bundle(self,\n           (result_future.is_done() and result_future.get().error)):\n         if isinstance(output, beam_fn_api_pb2.Elements.Timers) and not dry_run:\n           with BundleManager._lock:\n-            self.bundle_context_manager.get_buffer(\n+            timer_buffer = self.bundle_context_manager.get_buffer(\n                 expected_output_timers[(\n                     output.transform_id, output.timer_family_id)],\n-                output.transform_id).append(output.timers)\n+                output.transform_id)\n+            timer_buffer.cleared = False", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3NjM3NA=="}, "originalCommit": {"oid": "10f217fb8adf21e54d5f7b2641bb8d0568372f9e"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIzNTYwOA==", "bodyText": "PTAL @pabloem", "url": "https://github.com/apache/beam/pull/11492#discussion_r417235608", "createdAt": "2020-04-29T11:09:47Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -845,10 +845,12 @@ def process_bundle(self,\n           (result_future.is_done() and result_future.get().error)):\n         if isinstance(output, beam_fn_api_pb2.Elements.Timers) and not dry_run:\n           with BundleManager._lock:\n-            self.bundle_context_manager.get_buffer(\n+            timer_buffer = self.bundle_context_manager.get_buffer(\n                 expected_output_timers[(\n                     output.transform_id, output.timer_family_id)],\n-                output.transform_id).append(output.timers)\n+                output.transform_id)\n+            timer_buffer.cleared = False", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3NjM3NA=="}, "originalCommit": {"oid": "10f217fb8adf21e54d5f7b2641bb8d0568372f9e"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNTgxODYyOnYy", "diffSide": "RIGHT", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkExecutableStageFunction.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMzozMTo0NFrOGPYOdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxMDo1MjowOFrOGPiSfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3ODc0MA==", "bodyText": "It makes sense to do this in batch as well since the processing timers should get dropped and any newly scheduled event time timers should be continually fired.\nThis would require updating FlinkExecutableStageFunction and SparkExecutableStageFunction", "url": "https://github.com/apache/beam/pull/11492#discussion_r418778740", "createdAt": "2020-05-01T23:31:44Z", "author": {"login": "lukecwik"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkExecutableStageFunction.java", "diffHunk": "@@ -247,25 +247,27 @@ public void reduce(Iterable<WindowedValue<InputT>> iterable, Collector<RawUnionV\n     timerInternals.advanceSynchronizedProcessingTime(BoundedWindow.TIMESTAMP_MAX_VALUE);\n \n     // Now we fire the timers and process elements generated by timers (which may be timers itself)\n-    try (RemoteBundle bundle =\n-        stageBundleFactory.getBundle(\n-            receiverFactory, timerReceiverFactory, stateRequestHandler, progressHandler)) {\n-\n-      PipelineTranslatorUtils.fireEligibleTimers(\n-          timerInternals,\n-          (KV<String, String> transformAndTimerId, Timer<?> timerValue) -> {\n-            FnDataReceiver<Timer> fnTimerReceiver =\n-                bundle.getTimerReceivers().get(transformAndTimerId);\n-            Preconditions.checkNotNull(\n-                fnTimerReceiver, \"No FnDataReceiver found for %s\", transformAndTimerId);\n-            try {\n-              fnTimerReceiver.accept(timerValue);\n-            } catch (Exception e) {\n-              throw new RuntimeException(\n-                  String.format(Locale.ENGLISH, \"Failed to process timer: %s\", timerValue));\n-            }\n-          },\n-          currentTimerKey);\n+    while (timerInternals.hasPendingTimers()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8f17e7b18eab520dd5edff48b7c5c4eb385d31"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3ODgyOA==", "bodyText": "Also, I made this same comment earlier today and it was lost somehow.", "url": "https://github.com/apache/beam/pull/11492#discussion_r418778828", "createdAt": "2020-05-01T23:32:13Z", "author": {"login": "lukecwik"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkExecutableStageFunction.java", "diffHunk": "@@ -247,25 +247,27 @@ public void reduce(Iterable<WindowedValue<InputT>> iterable, Collector<RawUnionV\n     timerInternals.advanceSynchronizedProcessingTime(BoundedWindow.TIMESTAMP_MAX_VALUE);\n \n     // Now we fire the timers and process elements generated by timers (which may be timers itself)\n-    try (RemoteBundle bundle =\n-        stageBundleFactory.getBundle(\n-            receiverFactory, timerReceiverFactory, stateRequestHandler, progressHandler)) {\n-\n-      PipelineTranslatorUtils.fireEligibleTimers(\n-          timerInternals,\n-          (KV<String, String> transformAndTimerId, Timer<?> timerValue) -> {\n-            FnDataReceiver<Timer> fnTimerReceiver =\n-                bundle.getTimerReceivers().get(transformAndTimerId);\n-            Preconditions.checkNotNull(\n-                fnTimerReceiver, \"No FnDataReceiver found for %s\", transformAndTimerId);\n-            try {\n-              fnTimerReceiver.accept(timerValue);\n-            } catch (Exception e) {\n-              throw new RuntimeException(\n-                  String.format(Locale.ENGLISH, \"Failed to process timer: %s\", timerValue));\n-            }\n-          },\n-          currentTimerKey);\n+    while (timerInternals.hasPendingTimers()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3ODc0MA=="}, "originalCommit": {"oid": "dc8f17e7b18eab520dd5edff48b7c5c4eb385d31"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc4MDU3Mw==", "bodyText": "Agree that this should apply to Spark runner too. To clarify, FlinkExecutableStageFunction is for batch only, meaning this change only affected Flink batch. I assume Flink streaming (ExecutableStageDoFnOperator) was working from the start.", "url": "https://github.com/apache/beam/pull/11492#discussion_r418780573", "createdAt": "2020-05-01T23:41:17Z", "author": {"login": "ibzib"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkExecutableStageFunction.java", "diffHunk": "@@ -247,25 +247,27 @@ public void reduce(Iterable<WindowedValue<InputT>> iterable, Collector<RawUnionV\n     timerInternals.advanceSynchronizedProcessingTime(BoundedWindow.TIMESTAMP_MAX_VALUE);\n \n     // Now we fire the timers and process elements generated by timers (which may be timers itself)\n-    try (RemoteBundle bundle =\n-        stageBundleFactory.getBundle(\n-            receiverFactory, timerReceiverFactory, stateRequestHandler, progressHandler)) {\n-\n-      PipelineTranslatorUtils.fireEligibleTimers(\n-          timerInternals,\n-          (KV<String, String> transformAndTimerId, Timer<?> timerValue) -> {\n-            FnDataReceiver<Timer> fnTimerReceiver =\n-                bundle.getTimerReceivers().get(transformAndTimerId);\n-            Preconditions.checkNotNull(\n-                fnTimerReceiver, \"No FnDataReceiver found for %s\", transformAndTimerId);\n-            try {\n-              fnTimerReceiver.accept(timerValue);\n-            } catch (Exception e) {\n-              throw new RuntimeException(\n-                  String.format(Locale.ENGLISH, \"Failed to process timer: %s\", timerValue));\n-            }\n-          },\n-          currentTimerKey);\n+    while (timerInternals.hasPendingTimers()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3ODc0MA=="}, "originalCommit": {"oid": "dc8f17e7b18eab520dd5edff48b7c5c4eb385d31"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgxMzM2OQ==", "bodyText": "Made #11595 to update Spark.", "url": "https://github.com/apache/beam/pull/11492#discussion_r418813369", "createdAt": "2020-05-02T01:23:54Z", "author": {"login": "ibzib"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkExecutableStageFunction.java", "diffHunk": "@@ -247,25 +247,27 @@ public void reduce(Iterable<WindowedValue<InputT>> iterable, Collector<RawUnionV\n     timerInternals.advanceSynchronizedProcessingTime(BoundedWindow.TIMESTAMP_MAX_VALUE);\n \n     // Now we fire the timers and process elements generated by timers (which may be timers itself)\n-    try (RemoteBundle bundle =\n-        stageBundleFactory.getBundle(\n-            receiverFactory, timerReceiverFactory, stateRequestHandler, progressHandler)) {\n-\n-      PipelineTranslatorUtils.fireEligibleTimers(\n-          timerInternals,\n-          (KV<String, String> transformAndTimerId, Timer<?> timerValue) -> {\n-            FnDataReceiver<Timer> fnTimerReceiver =\n-                bundle.getTimerReceivers().get(transformAndTimerId);\n-            Preconditions.checkNotNull(\n-                fnTimerReceiver, \"No FnDataReceiver found for %s\", transformAndTimerId);\n-            try {\n-              fnTimerReceiver.accept(timerValue);\n-            } catch (Exception e) {\n-              throw new RuntimeException(\n-                  String.format(Locale.ENGLISH, \"Failed to process timer: %s\", timerValue));\n-            }\n-          },\n-          currentTimerKey);\n+    while (timerInternals.hasPendingTimers()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3ODc0MA=="}, "originalCommit": {"oid": "dc8f17e7b18eab520dd5edff48b7c5c4eb385d31"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0MzYxMg==", "bodyText": "Yes, this is a batch-only change (also evident in the commit message). The streaming operator already does that.\n\nprocessing timers should get dropped and any newly scheduled event time timers should be continually fired.\n\nWe do not drop processing timers. We fire all timers, including new ones, until there are none left.", "url": "https://github.com/apache/beam/pull/11492#discussion_r418943612", "createdAt": "2020-05-02T10:52:08Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkExecutableStageFunction.java", "diffHunk": "@@ -247,25 +247,27 @@ public void reduce(Iterable<WindowedValue<InputT>> iterable, Collector<RawUnionV\n     timerInternals.advanceSynchronizedProcessingTime(BoundedWindow.TIMESTAMP_MAX_VALUE);\n \n     // Now we fire the timers and process elements generated by timers (which may be timers itself)\n-    try (RemoteBundle bundle =\n-        stageBundleFactory.getBundle(\n-            receiverFactory, timerReceiverFactory, stateRequestHandler, progressHandler)) {\n-\n-      PipelineTranslatorUtils.fireEligibleTimers(\n-          timerInternals,\n-          (KV<String, String> transformAndTimerId, Timer<?> timerValue) -> {\n-            FnDataReceiver<Timer> fnTimerReceiver =\n-                bundle.getTimerReceivers().get(transformAndTimerId);\n-            Preconditions.checkNotNull(\n-                fnTimerReceiver, \"No FnDataReceiver found for %s\", transformAndTimerId);\n-            try {\n-              fnTimerReceiver.accept(timerValue);\n-            } catch (Exception e) {\n-              throw new RuntimeException(\n-                  String.format(Locale.ENGLISH, \"Failed to process timer: %s\", timerValue));\n-            }\n-          },\n-          currentTimerKey);\n+    while (timerInternals.hasPendingTimers()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3ODc0MA=="}, "originalCommit": {"oid": "dc8f17e7b18eab520dd5edff48b7c5c4eb385d31"}, "originalPosition": 23}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1359, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}