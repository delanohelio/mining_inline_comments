{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwMjg4NDMy", "number": 12093, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMToyOToyM1rOEJRViA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMjo1MTowNlrOEJTtpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MTU2NjgwOnYy", "diffSide": "RIGHT", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMToyOToyM1rOGpvN3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMzoxMzozMlrOGpxApg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQxODM5OQ==", "bodyText": "I noticed currentWindow isn't set to null here, where it was before. Same with processElementForWindowObservingPairWithRestriction. Why is that?", "url": "https://github.com/apache/beam/pull/12093#discussion_r446418399", "createdAt": "2020-06-26T21:29:23Z", "author": {"login": "ibzib"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -637,6 +737,28 @@ private void processElementForParDo(WindowedValue<InputT> elem) {\n   }\n \n   private void processElementForPairWithRestriction(WindowedValue<InputT> elem) {\n+    currentElement = elem;\n+    try {\n+      currentRestriction = doFnInvoker.invokeGetInitialRestriction(processContext);\n+      outputTo(\n+          mainOutputConsumers,\n+          (WindowedValue)\n+              elem.withValue(\n+                  KV.of(\n+                      elem.getValue(),\n+                      KV.of(\n+                          currentRestriction,\n+                          doFnInvoker.invokeGetInitialWatermarkEstimatorState(processContext)))));\n+    } finally {\n+      currentElement = null;\n+      currentRestriction = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39292acb90443e9e643b656380e7fd62ed7a3020"}, "originalPosition": 378}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0Nzc4Mg==", "bodyText": "It is never set/utilized in these methods and just remains null. All output is produced using the entire set of windows for the current element instead.\nThe window observing versions of these methods do set it and clear it.", "url": "https://github.com/apache/beam/pull/12093#discussion_r446447782", "createdAt": "2020-06-26T23:13:32Z", "author": {"login": "lukecwik"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -637,6 +737,28 @@ private void processElementForParDo(WindowedValue<InputT> elem) {\n   }\n \n   private void processElementForPairWithRestriction(WindowedValue<InputT> elem) {\n+    currentElement = elem;\n+    try {\n+      currentRestriction = doFnInvoker.invokeGetInitialRestriction(processContext);\n+      outputTo(\n+          mainOutputConsumers,\n+          (WindowedValue)\n+              elem.withValue(\n+                  KV.of(\n+                      elem.getValue(),\n+                      KV.of(\n+                          currentRestriction,\n+                          doFnInvoker.invokeGetInitialWatermarkEstimatorState(processContext)))));\n+    } finally {\n+      currentElement = null;\n+      currentRestriction = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQxODM5OQ=="}, "originalCommit": {"oid": "39292acb90443e9e643b656380e7fd62ed7a3020"}, "originalPosition": 378}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MTk1NjIxOnYy", "diffSide": "RIGHT", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMjo1MTowNlrOGpyr_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNzowMDo0OVrOGqaAdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ3NTI2MA==", "bodyText": "It seems like we should remove this duplicate part.", "url": "https://github.com/apache/beam/pull/12093#discussion_r446475260", "createdAt": "2020-06-27T02:51:06Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -488,60 +438,201 @@ public void accept(WindowedValue input) throws Exception {\n     this.doFnInvoker.invokeSetup();\n \n     this.startBundleArgumentProvider = new StartBundleArgumentProvider();\n+    // Register the appropriate handlers.\n+    switch (pTransform.getSpec().getUrn()) {\n+      case PTransformTranslation.PAR_DO_TRANSFORM_URN:\n+      case PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN:\n+        startFunctionRegistry.register(pTransformId, this::startBundle);\n+        break;\n+      case PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN:\n+        // startBundle should not be invoked\n+      case PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN:\n+        // startBundle should not be invoked\n+      default:\n+        // no-op\n+    }\n+\n+    String mainInput;\n+    try {\n+      mainInput = ParDoTranslation.getMainInputName(pTransform);\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+    final FnDataReceiver<WindowedValue> mainInputConsumer;\n+    switch (pTransform.getSpec().getUrn()) {\n+      case PTransformTranslation.PAR_DO_TRANSFORM_URN:\n+        if (doFnSignature.processElement().observesWindow() || !sideInputMapping.isEmpty()) {\n+          mainInputConsumer = this::processElementForWindowObservingParDo;\n+          this.processContext = new WindowObservingProcessBundleContext();\n+        } else {\n+          mainInputConsumer = this::processElementForParDo;\n+          this.processContext = new NonWindowObservingProcessBundleContext();\n+        }\n+        break;\n+      case PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN:\n+        if (doFnSignature.getInitialRestriction().observesWindow()\n+            || (doFnSignature.getInitialWatermarkEstimatorState() != null\n+                && doFnSignature.getInitialWatermarkEstimatorState().observesWindow())\n+            || !sideInputMapping.isEmpty()) {\n+          mainInputConsumer = this::processElementForWindowObservingPairWithRestriction;\n+          this.processContext = new WindowObservingProcessBundleContext();\n+        } else {\n+          mainInputConsumer = this::processElementForPairWithRestriction;\n+          this.processContext = new NonWindowObservingProcessBundleContext();\n+        }\n+        break;\n+      case PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN:\n+        if ((doFnSignature.splitRestriction() != null\n+                && doFnSignature.splitRestriction().observesWindow())\n+            || (doFnSignature.newTracker() != null && doFnSignature.newTracker().observesWindow())\n+            || (doFnSignature.getSize() != null && doFnSignature.getSize().observesWindow())\n+            || !sideInputMapping.isEmpty()) {\n+          mainInputConsumer = this::processElementForWindowObservingSplitRestriction;\n+          // OutputT == RestrictionT\n+          this.processContext =\n+              new WindowObservingProcessBundleContext() {\n+                @Override\n+                public void outputWithTimestamp(OutputT output, Instant timestamp) {\n+                  double size =\n+                      doFnInvoker.invokeGetSize(\n+                          new DelegatingArgumentProvider<InputT, OutputT>(\n+                              this,\n+                              PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN\n+                                  + \"/GetSize\") {\n+                            @Override\n+                            public Object restriction() {\n+                              return output;\n+                            }\n+\n+                            @Override\n+                            public Instant timestamp(DoFn<InputT, OutputT> doFn) {\n+                              return timestamp;\n+                            }\n+\n+                            @Override\n+                            public RestrictionTracker<?, ?> restrictionTracker() {\n+                              return doFnInvoker.invokeNewTracker(this);\n+                            }\n+                          });\n+\n+                  outputTo(\n+                      mainOutputConsumers,\n+                      (WindowedValue<OutputT>)\n+                          WindowedValue.of(\n+                              KV.of(\n+                                  KV.of(\n+                                      currentElement.getValue(),\n+                                      KV.of(output, currentWatermarkEstimatorState)),\n+                                  size),\n+                              timestamp,\n+                              currentWindow,\n+                              currentElement.getPane()));\n+                }\n+              };\n+        } else {\n+          mainInputConsumer = this::processElementForSplitRestriction;\n+          // OutputT == RestrictionT\n+          this.processContext =\n+              new NonWindowObservingProcessBundleContext() {\n+                @Override\n+                public void outputWithTimestamp(OutputT output, Instant timestamp) {\n+                  double size =\n+                      doFnInvoker.invokeGetSize(\n+                          new DelegatingArgumentProvider<InputT, OutputT>(\n+                              this,\n+                              PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN\n+                                  + \"/GetSize\") {\n+                            @Override\n+                            public Object restriction() {\n+                              return output;\n+                            }\n+\n+                            @Override\n+                            public Instant timestamp(DoFn<InputT, OutputT> doFn) {\n+                              return timestamp;\n+                            }\n+\n+                            @Override\n+                            public RestrictionTracker<?, ?> restrictionTracker() {\n+                              return doFnInvoker.invokeNewTracker(this);\n+                            }\n+                          });\n+\n+                  outputTo(\n+                      mainOutputConsumers,\n+                      (WindowedValue<OutputT>)\n+                          WindowedValue.of(\n+                              KV.of(\n+                                  KV.of(\n+                                      currentElement.getValue(),\n+                                      KV.of(output, currentWatermarkEstimatorState)),\n+                                  size),\n+                              timestamp,\n+                              currentElement.getWindows(),\n+                              currentElement.getPane()));\n+                }\n+              };\n+        }\n+        break;\n+      case PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN:\n+        if (doFnSignature.processElement().observesWindow()\n+            || (doFnSignature.newTracker() != null && doFnSignature.newTracker().observesWindow())\n+            || (doFnSignature.getSize() != null && doFnSignature.getSize().observesWindow())\n+            || (doFnSignature.newWatermarkEstimator() != null\n+                && doFnSignature.newWatermarkEstimator().observesWindow())\n+            || !sideInputMapping.isEmpty()) {\n+          mainInputConsumer =\n+              new SplittableFnDataReceiver() {\n+                @Override\n+                public void accept(WindowedValue input) throws Exception {\n+                  processElementForWindowObservingSizedElementAndRestriction(input);\n+                }\n+              };\n+          this.processContext = new WindowObservingProcessBundleContext();\n+        } else {\n+          mainInputConsumer =\n+              new SplittableFnDataReceiver() {\n+                @Override\n+                public void accept(WindowedValue input) throws Exception {\n+                  // TODO(BEAM-10303): Create a variant which is optimized to not observe the\n+                  // windows.\n+                  processElementForWindowObservingSizedElementAndRestriction(input);\n+                }\n+              };\n+          this.processContext = new WindowObservingProcessBundleContext();\n+        }\n+        break;\n+      default:\n+        throw new IllegalStateException(\"Unknown urn: \" + pTransform.getSpec().getUrn());\n+    }\n+    pCollectionConsumerRegistry.register(\n+        pTransform.getInputsOrThrow(mainInput), pTransformId, (FnDataReceiver) mainInputConsumer);\n+\n     switch (pTransform.getSpec().getUrn()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39292acb90443e9e643b656380e7fd62ed7a3020"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExOTQ3Nw==", "bodyText": "Thanks, I'll remove it in a follow-up.", "url": "https://github.com/apache/beam/pull/12093#discussion_r447119477", "createdAt": "2020-06-29T17:00:49Z", "author": {"login": "lukecwik"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -488,60 +438,201 @@ public void accept(WindowedValue input) throws Exception {\n     this.doFnInvoker.invokeSetup();\n \n     this.startBundleArgumentProvider = new StartBundleArgumentProvider();\n+    // Register the appropriate handlers.\n+    switch (pTransform.getSpec().getUrn()) {\n+      case PTransformTranslation.PAR_DO_TRANSFORM_URN:\n+      case PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN:\n+        startFunctionRegistry.register(pTransformId, this::startBundle);\n+        break;\n+      case PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN:\n+        // startBundle should not be invoked\n+      case PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN:\n+        // startBundle should not be invoked\n+      default:\n+        // no-op\n+    }\n+\n+    String mainInput;\n+    try {\n+      mainInput = ParDoTranslation.getMainInputName(pTransform);\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+    final FnDataReceiver<WindowedValue> mainInputConsumer;\n+    switch (pTransform.getSpec().getUrn()) {\n+      case PTransformTranslation.PAR_DO_TRANSFORM_URN:\n+        if (doFnSignature.processElement().observesWindow() || !sideInputMapping.isEmpty()) {\n+          mainInputConsumer = this::processElementForWindowObservingParDo;\n+          this.processContext = new WindowObservingProcessBundleContext();\n+        } else {\n+          mainInputConsumer = this::processElementForParDo;\n+          this.processContext = new NonWindowObservingProcessBundleContext();\n+        }\n+        break;\n+      case PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN:\n+        if (doFnSignature.getInitialRestriction().observesWindow()\n+            || (doFnSignature.getInitialWatermarkEstimatorState() != null\n+                && doFnSignature.getInitialWatermarkEstimatorState().observesWindow())\n+            || !sideInputMapping.isEmpty()) {\n+          mainInputConsumer = this::processElementForWindowObservingPairWithRestriction;\n+          this.processContext = new WindowObservingProcessBundleContext();\n+        } else {\n+          mainInputConsumer = this::processElementForPairWithRestriction;\n+          this.processContext = new NonWindowObservingProcessBundleContext();\n+        }\n+        break;\n+      case PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN:\n+        if ((doFnSignature.splitRestriction() != null\n+                && doFnSignature.splitRestriction().observesWindow())\n+            || (doFnSignature.newTracker() != null && doFnSignature.newTracker().observesWindow())\n+            || (doFnSignature.getSize() != null && doFnSignature.getSize().observesWindow())\n+            || !sideInputMapping.isEmpty()) {\n+          mainInputConsumer = this::processElementForWindowObservingSplitRestriction;\n+          // OutputT == RestrictionT\n+          this.processContext =\n+              new WindowObservingProcessBundleContext() {\n+                @Override\n+                public void outputWithTimestamp(OutputT output, Instant timestamp) {\n+                  double size =\n+                      doFnInvoker.invokeGetSize(\n+                          new DelegatingArgumentProvider<InputT, OutputT>(\n+                              this,\n+                              PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN\n+                                  + \"/GetSize\") {\n+                            @Override\n+                            public Object restriction() {\n+                              return output;\n+                            }\n+\n+                            @Override\n+                            public Instant timestamp(DoFn<InputT, OutputT> doFn) {\n+                              return timestamp;\n+                            }\n+\n+                            @Override\n+                            public RestrictionTracker<?, ?> restrictionTracker() {\n+                              return doFnInvoker.invokeNewTracker(this);\n+                            }\n+                          });\n+\n+                  outputTo(\n+                      mainOutputConsumers,\n+                      (WindowedValue<OutputT>)\n+                          WindowedValue.of(\n+                              KV.of(\n+                                  KV.of(\n+                                      currentElement.getValue(),\n+                                      KV.of(output, currentWatermarkEstimatorState)),\n+                                  size),\n+                              timestamp,\n+                              currentWindow,\n+                              currentElement.getPane()));\n+                }\n+              };\n+        } else {\n+          mainInputConsumer = this::processElementForSplitRestriction;\n+          // OutputT == RestrictionT\n+          this.processContext =\n+              new NonWindowObservingProcessBundleContext() {\n+                @Override\n+                public void outputWithTimestamp(OutputT output, Instant timestamp) {\n+                  double size =\n+                      doFnInvoker.invokeGetSize(\n+                          new DelegatingArgumentProvider<InputT, OutputT>(\n+                              this,\n+                              PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN\n+                                  + \"/GetSize\") {\n+                            @Override\n+                            public Object restriction() {\n+                              return output;\n+                            }\n+\n+                            @Override\n+                            public Instant timestamp(DoFn<InputT, OutputT> doFn) {\n+                              return timestamp;\n+                            }\n+\n+                            @Override\n+                            public RestrictionTracker<?, ?> restrictionTracker() {\n+                              return doFnInvoker.invokeNewTracker(this);\n+                            }\n+                          });\n+\n+                  outputTo(\n+                      mainOutputConsumers,\n+                      (WindowedValue<OutputT>)\n+                          WindowedValue.of(\n+                              KV.of(\n+                                  KV.of(\n+                                      currentElement.getValue(),\n+                                      KV.of(output, currentWatermarkEstimatorState)),\n+                                  size),\n+                              timestamp,\n+                              currentElement.getWindows(),\n+                              currentElement.getPane()));\n+                }\n+              };\n+        }\n+        break;\n+      case PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN:\n+        if (doFnSignature.processElement().observesWindow()\n+            || (doFnSignature.newTracker() != null && doFnSignature.newTracker().observesWindow())\n+            || (doFnSignature.getSize() != null && doFnSignature.getSize().observesWindow())\n+            || (doFnSignature.newWatermarkEstimator() != null\n+                && doFnSignature.newWatermarkEstimator().observesWindow())\n+            || !sideInputMapping.isEmpty()) {\n+          mainInputConsumer =\n+              new SplittableFnDataReceiver() {\n+                @Override\n+                public void accept(WindowedValue input) throws Exception {\n+                  processElementForWindowObservingSizedElementAndRestriction(input);\n+                }\n+              };\n+          this.processContext = new WindowObservingProcessBundleContext();\n+        } else {\n+          mainInputConsumer =\n+              new SplittableFnDataReceiver() {\n+                @Override\n+                public void accept(WindowedValue input) throws Exception {\n+                  // TODO(BEAM-10303): Create a variant which is optimized to not observe the\n+                  // windows.\n+                  processElementForWindowObservingSizedElementAndRestriction(input);\n+                }\n+              };\n+          this.processContext = new WindowObservingProcessBundleContext();\n+        }\n+        break;\n+      default:\n+        throw new IllegalStateException(\"Unknown urn: \" + pTransform.getSpec().getUrn());\n+    }\n+    pCollectionConsumerRegistry.register(\n+        pTransform.getInputsOrThrow(mainInput), pTransformId, (FnDataReceiver) mainInputConsumer);\n+\n     switch (pTransform.getSpec().getUrn()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ3NTI2MA=="}, "originalCommit": {"oid": "39292acb90443e9e643b656380e7fd62ed7a3020"}, "originalPosition": 274}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3338, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}