{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIyODczNjkw", "number": 13370, "title": "[BEAM-11188] Adding unit test for mergeExpandedWithPipeline", "bodyText": "This is meant to be part of a larger change adding unit tests for the various pipeline transformations in graphx/xlang.go.\nAfter how long it took to figure out how to implement this, and the realization that each other transformation is going to be similarly difficult and they're already somewhat tested by the xlang examples (and soon-to-be integration tests), I think I'd rather not implement the rest anymore. But I already implemented most of this test so I just finished it up and am sending it out in a PR.\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nDataflow\nFlink\nSamza\nSpark\nTwister2\n\n\n\n\nGo\n\n---\n\n---\n\n---\n\n\nJava\n\n\n\n\n\n\n\n\nPython\n\n\n\n---\n\n---\n\n\nXLang\n\n\n\n---\n\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\nWhitespace\nTypescript\n\n\n\n\nNon-portable\n\n \n\n\n\n\n\n\nPortable\n---\n\n---\n---\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.\nGitHub Actions Tests Status (on master branch)\n\n\n\nSee CI.md for more information about GitHub Actions CI.", "createdAt": "2020-11-18T02:54:46Z", "url": "https://github.com/apache/beam/pull/13370", "merged": true, "mergeCommit": {"oid": "70ddf84d4e089ded10d2932a08029e852e433f16"}, "closed": true, "closedAt": "2020-11-19T01:42:06Z", "author": {"login": "youngoli"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABddlEP5AH2gAyNTIyODczNjkwOmMwZmRlMWI2M2E3MDhiNjYwNmU3MjQwNGQ5ZTA0NWY4YzJiM2YwOWY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdd4j-YgH2gAyNTIyODczNjkwOmJlYTUwZWMyMDM1YWY2MTFhMWViMTVlOTQwZDE1ZWY0ZDU2OWU0MjQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c0fde1b63a708b6606e72404d9e045f8c2b3f09f", "author": {"user": {"login": "youngoli", "name": "Daniel Oliveira"}}, "url": "https://github.com/apache/beam/commit/c0fde1b63a708b6606e72404d9e045f8c2b3f09f", "committedDate": "2020-11-18T02:52:10Z", "message": "[BEAM-11188] Adding unit test for mergeExpandedWithPipeline\n\nThis is meant to be part of a larger change adding unit tests for the various pipeline transformations in graphx/xlang.go."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzNzIyNjEy", "url": "https://github.com/apache/beam/pull/13370#pullrequestreview-533722612", "createdAt": "2020-11-18T17:50:17Z", "commit": {"oid": "c0fde1b63a708b6606e72404d9e045f8c2b3f09f"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNzo1MDoxN1rOH16w4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNzo1MzozM1rOH165wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI5OTM2Mw==", "bodyText": "In this case, you probably just want cmp.Equal instead of cmp.Diff, since we never use the diff result.\nhttps://pkg.go.dev/github.com/google/go-cmp/cmp#Equal", "url": "https://github.com/apache/beam/pull/13370#discussion_r526299363", "createdAt": "2020-11-18T17:50:17Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang_test.go", "diffHunk": "@@ -203,3 +203,214 @@ func TestExpandedComponents(t *testing.T) {\n \n \t})\n }\n+\n+var testExternal = graph.ExternalTransform{\n+\tUrn:           \"test_urn\",\n+\tPayload:       nil,\n+\tExpansionAddr: \"test_addr\",\n+\tExpanded:      &testExpanded,\n+}\n+\n+var testComponents = pipepb.Components{\n+\tTransforms:          map[string]*pipepb.PTransform{\"transform_id1\": {UniqueName: \"test_components_transform\"}},\n+\tPcollections:        map[string]*pipepb.PCollection{\"pcollection_id1\": {UniqueName: \"test_components_pcollection\"}},\n+\tWindowingStrategies: map[string]*pipepb.WindowingStrategy{\"windowing_id1\": {WindowCoderId: \"test_components_windowing\"}},\n+\tCoders:              map[string]*pipepb.Coder{\"coder_id1\": {Spec: &pipepb.FunctionSpec{Urn: \"test_components_coder\"}}},\n+\tEnvironments:        map[string]*pipepb.Environment{\"environment_id1\": {Urn: \"test_components_environment\"}},\n+}\n+\n+var testRequirements = []string{\"test_requirement1\", \"test_requirement2\"}\n+\n+var testTransform = pipepb.PTransform{\n+\tUniqueName: \"test_transform\",\n+}\n+\n+var testExpanded = graph.ExpandedTransform{\n+\tComponents:   &testComponents,\n+\tTransform:    &testTransform,\n+\tRequirements: testRequirements,\n+}\n+\n+var testExternal2 = graph.ExternalTransform{\n+\tUrn:           \"test_urn2\",\n+\tPayload:       nil,\n+\tExpansionAddr: \"test_addr2\",\n+\tExpanded:      &testExpanded2,\n+}\n+\n+var testComponents2 = pipepb.Components{\n+\tTransforms:          map[string]*pipepb.PTransform{\"transform_id2\": {UniqueName: \"test_components2_transform\"}},\n+\tPcollections:        map[string]*pipepb.PCollection{\"pcollection_id2\": {UniqueName: \"test_components2_pcollection\"}},\n+\tWindowingStrategies: map[string]*pipepb.WindowingStrategy{\"windowing_id2\": {WindowCoderId: \"test_components2_windowing\"}},\n+\tCoders:              map[string]*pipepb.Coder{\"coder_id2\": {Spec: &pipepb.FunctionSpec{Urn: \"test_components2_coder\"}}},\n+\tEnvironments:        map[string]*pipepb.Environment{\"environment_id2\": {Urn: \"test_components2_environment\"}},\n+}\n+\n+var testRequirements2 = []string{\"test_requirement2\", \"test_requirement3\"}\n+\n+var testTransform2 = pipepb.PTransform{\n+\tUniqueName: \"test_transform2\",\n+}\n+\n+var testExpanded2 = graph.ExpandedTransform{\n+\tComponents:   &testComponents2,\n+\tTransform:    &testTransform2,\n+\tRequirements: testRequirements2,\n+}\n+\n+// TestMergeExpandedWithPipeline tests that mergeExpandedWithPipeline properly\n+// adds data from external transforms to a pipeline.\n+func TestMergeExpandedWithPipeline(t *testing.T) {\n+\t// Create slices of MultiEdges containing external edges, and make sure all\n+\t// relevant data from the external edges is properly added to an empty\n+\t// pipeline.\n+\ttests := []struct {\n+\t\tname          string\n+\t\tmakeEdges     func(g *graph.Graph) []*graph.MultiEdge\n+\t\twantExpandeds []graph.ExpandedTransform\n+\t}{\n+\t\t{\n+\t\t\tname: \"SingleTransform\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"MultiTransforms\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\t\t\t\tedge2 := g.NewEdge(s)\n+\t\t\t\tedge2.Op = graph.External\n+\t\t\t\tedge2.External = &testExternal2\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge, edge2}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded, testExpanded2},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"NonExternalTransforms\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\t\t\t\tedge2 := g.NewEdge(s)\n+\t\t\t\tedge2.Op = graph.External\n+\t\t\t\tedge2.External = &testExternal2\n+\t\t\t\timpulse := graph.NewImpulse(g, s, []byte{1})\n+\t\t\t\timpulse2 := graph.NewImpulse(g, s, []byte{2})\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge, edge2, impulse, impulse2}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded, testExpanded2},\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\ttest := test\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tg := graph.New()\n+\t\t\tedges := test.makeEdges(g)\n+\t\t\tvar p pipepb.Pipeline\n+\t\t\tp.Components = &pipepb.Components{\n+\t\t\t\tTransforms:          make(map[string]*pipepb.PTransform),\n+\t\t\t\tPcollections:        make(map[string]*pipepb.PCollection),\n+\t\t\t\tWindowingStrategies: make(map[string]*pipepb.WindowingStrategy),\n+\t\t\t\tCoders:              make(map[string]*pipepb.Coder),\n+\t\t\t\tEnvironments:        make(map[string]*pipepb.Environment),\n+\t\t\t}\n+\t\t\tmergeExpandedWithPipeline(edges, &p)\n+\n+\t\t\t// Check that all wanted expanded components have been added to\n+\t\t\t// pipeline components.\n+\t\t\tfor _, exp := range test.wantExpandeds {\n+\t\t\t\twantComps := exp.Components.(*pipepb.Components)\n+\t\t\t\tgotComps := p.GetComponents()\n+\t\t\t\tvalidateComponents(t, wantComps, gotComps)\n+\n+\t\t\t\t// Check that expanded transform is present. Need to search.\n+\t\t\t\twantTransform := exp.Transform.(*pipepb.PTransform)\n+\t\t\t\tvar found bool\n+\t\t\t\tfor _, gotTransform := range gotComps.GetTransforms() {\n+\t\t\t\t\tif d := cmp.Diff(wantTransform, gotTransform, protocmp.Transform()); d == \"\" {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0fde1b63a708b6606e72404d9e045f8c2b3f09f"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMwMTYzMw==", "bodyText": "I'm confused why this is broken out rather than simply using a single cmp.Diff(wantComps, gotComps, protocmp.Transform()) ?\nI'm assuming that you wanted additional granularity on the parts that were missing/extra for each component, and the full diff was less clear than this output?\nConsider adding a comment documenting that reasoning.", "url": "https://github.com/apache/beam/pull/13370#discussion_r526301633", "createdAt": "2020-11-18T17:53:33Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang_test.go", "diffHunk": "@@ -203,3 +203,214 @@ func TestExpandedComponents(t *testing.T) {\n \n \t})\n }\n+\n+var testExternal = graph.ExternalTransform{\n+\tUrn:           \"test_urn\",\n+\tPayload:       nil,\n+\tExpansionAddr: \"test_addr\",\n+\tExpanded:      &testExpanded,\n+}\n+\n+var testComponents = pipepb.Components{\n+\tTransforms:          map[string]*pipepb.PTransform{\"transform_id1\": {UniqueName: \"test_components_transform\"}},\n+\tPcollections:        map[string]*pipepb.PCollection{\"pcollection_id1\": {UniqueName: \"test_components_pcollection\"}},\n+\tWindowingStrategies: map[string]*pipepb.WindowingStrategy{\"windowing_id1\": {WindowCoderId: \"test_components_windowing\"}},\n+\tCoders:              map[string]*pipepb.Coder{\"coder_id1\": {Spec: &pipepb.FunctionSpec{Urn: \"test_components_coder\"}}},\n+\tEnvironments:        map[string]*pipepb.Environment{\"environment_id1\": {Urn: \"test_components_environment\"}},\n+}\n+\n+var testRequirements = []string{\"test_requirement1\", \"test_requirement2\"}\n+\n+var testTransform = pipepb.PTransform{\n+\tUniqueName: \"test_transform\",\n+}\n+\n+var testExpanded = graph.ExpandedTransform{\n+\tComponents:   &testComponents,\n+\tTransform:    &testTransform,\n+\tRequirements: testRequirements,\n+}\n+\n+var testExternal2 = graph.ExternalTransform{\n+\tUrn:           \"test_urn2\",\n+\tPayload:       nil,\n+\tExpansionAddr: \"test_addr2\",\n+\tExpanded:      &testExpanded2,\n+}\n+\n+var testComponents2 = pipepb.Components{\n+\tTransforms:          map[string]*pipepb.PTransform{\"transform_id2\": {UniqueName: \"test_components2_transform\"}},\n+\tPcollections:        map[string]*pipepb.PCollection{\"pcollection_id2\": {UniqueName: \"test_components2_pcollection\"}},\n+\tWindowingStrategies: map[string]*pipepb.WindowingStrategy{\"windowing_id2\": {WindowCoderId: \"test_components2_windowing\"}},\n+\tCoders:              map[string]*pipepb.Coder{\"coder_id2\": {Spec: &pipepb.FunctionSpec{Urn: \"test_components2_coder\"}}},\n+\tEnvironments:        map[string]*pipepb.Environment{\"environment_id2\": {Urn: \"test_components2_environment\"}},\n+}\n+\n+var testRequirements2 = []string{\"test_requirement2\", \"test_requirement3\"}\n+\n+var testTransform2 = pipepb.PTransform{\n+\tUniqueName: \"test_transform2\",\n+}\n+\n+var testExpanded2 = graph.ExpandedTransform{\n+\tComponents:   &testComponents2,\n+\tTransform:    &testTransform2,\n+\tRequirements: testRequirements2,\n+}\n+\n+// TestMergeExpandedWithPipeline tests that mergeExpandedWithPipeline properly\n+// adds data from external transforms to a pipeline.\n+func TestMergeExpandedWithPipeline(t *testing.T) {\n+\t// Create slices of MultiEdges containing external edges, and make sure all\n+\t// relevant data from the external edges is properly added to an empty\n+\t// pipeline.\n+\ttests := []struct {\n+\t\tname          string\n+\t\tmakeEdges     func(g *graph.Graph) []*graph.MultiEdge\n+\t\twantExpandeds []graph.ExpandedTransform\n+\t}{\n+\t\t{\n+\t\t\tname: \"SingleTransform\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"MultiTransforms\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\t\t\t\tedge2 := g.NewEdge(s)\n+\t\t\t\tedge2.Op = graph.External\n+\t\t\t\tedge2.External = &testExternal2\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge, edge2}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded, testExpanded2},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"NonExternalTransforms\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\t\t\t\tedge2 := g.NewEdge(s)\n+\t\t\t\tedge2.Op = graph.External\n+\t\t\t\tedge2.External = &testExternal2\n+\t\t\t\timpulse := graph.NewImpulse(g, s, []byte{1})\n+\t\t\t\timpulse2 := graph.NewImpulse(g, s, []byte{2})\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge, edge2, impulse, impulse2}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded, testExpanded2},\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\ttest := test\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tg := graph.New()\n+\t\t\tedges := test.makeEdges(g)\n+\t\t\tvar p pipepb.Pipeline\n+\t\t\tp.Components = &pipepb.Components{\n+\t\t\t\tTransforms:          make(map[string]*pipepb.PTransform),\n+\t\t\t\tPcollections:        make(map[string]*pipepb.PCollection),\n+\t\t\t\tWindowingStrategies: make(map[string]*pipepb.WindowingStrategy),\n+\t\t\t\tCoders:              make(map[string]*pipepb.Coder),\n+\t\t\t\tEnvironments:        make(map[string]*pipepb.Environment),\n+\t\t\t}\n+\t\t\tmergeExpandedWithPipeline(edges, &p)\n+\n+\t\t\t// Check that all wanted expanded components have been added to\n+\t\t\t// pipeline components.\n+\t\t\tfor _, exp := range test.wantExpandeds {\n+\t\t\t\twantComps := exp.Components.(*pipepb.Components)\n+\t\t\t\tgotComps := p.GetComponents()\n+\t\t\t\tvalidateComponents(t, wantComps, gotComps)\n+\n+\t\t\t\t// Check that expanded transform is present. Need to search.\n+\t\t\t\twantTransform := exp.Transform.(*pipepb.PTransform)\n+\t\t\t\tvar found bool\n+\t\t\t\tfor _, gotTransform := range gotComps.GetTransforms() {\n+\t\t\t\t\tif d := cmp.Diff(wantTransform, gotTransform, protocmp.Transform()); d == \"\" {\n+\t\t\t\t\t\tfound = true\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif !found {\n+\t\t\t\t\tt.Errorf(\"Pipeline components missing expected expanded transform: %v\", wantTransform)\n+\t\t\t\t}\n+\n+\t\t\t\t// Check that requirements are present.\n+\t\t\t\tfor _, wantReq := range exp.Requirements {\n+\t\t\t\t\tvar found bool\n+\t\t\t\t\tfor _, gotReq := range p.GetRequirements() {\n+\t\t\t\t\t\tif wantReq == gotReq {\n+\t\t\t\t\t\t\tfound = true\n+\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif !found {\n+\t\t\t\t\t\tt.Errorf(\"Pipeline missing expected requirement: %v\", wantReq)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func validateComponents(t *testing.T, wantComps, gotComps *pipepb.Components) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0fde1b63a708b6606e72404d9e045f8c2b3f09f"}, "originalPosition": 168}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bea50ec2035af611a1eb15e940d15ef4d569e424", "author": {"user": {"login": "youngoli", "name": "Daniel Oliveira"}}, "url": "https://github.com/apache/beam/commit/bea50ec2035af611a1eb15e940d15ef4d569e424", "committedDate": "2020-11-19T01:35:01Z", "message": "[BEAM-11188] Fixup"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4466, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}