{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzNTkzNzcx", "number": 12473, "title": "[BEAM-10601] DICOM API Beam IO connector e2e test", "bodyText": "Add integration test for DICOM Beam IO connector\n\nR:@pabloem,\nCC:@dranderson1117,@DanKotowski\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nDataflow\nFlink\nSamza\nSpark\nTwister2\n\n\n\n\nGo\n\n---\n\n---\n\n---\n\n\nJava\n\n\n\n\n\n\n\n\nPython\n\n\n\n---\n\n---\n\n\nXLang\n\n---\n\n---\n\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.\nGitHub Actions Tests Status (on master branch)\n\nSee CI.md for more information about GitHub Actions CI.", "createdAt": "2020-08-05T19:22:35Z", "url": "https://github.com/apache/beam/pull/12473", "merged": true, "mergeCommit": {"oid": "9303f651f951fe130db43a239d60016c18f9cc49"}, "closed": true, "closedAt": "2020-08-07T20:57:03Z", "author": {"login": "George-Wu"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc8AOiYgH2gAyNDYzNTkzNzcxOmY2ZWM1YzQ0NTk1MGNjNGRlYzBlNTVhMWZkMTg1YTFhYWI2NjU1MjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc8ovYxAH2gAyNDYzNTkzNzcxOjkxMmExZjYwZDNjZDQwYThhN2UzYzcyMTg0YzQ1MTA4NmVmMzk1YmI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f6ec5c445950cc4dec0e55a1fd185a1aab665526", "author": {"user": {"login": "George-Wu", "name": "JIahao wu"}}, "url": "https://github.com/apache/beam/commit/f6ec5c445950cc4dec0e55a1fd185a1aab665526", "committedDate": "2020-08-05T19:17:25Z", "message": "add integration test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b4f46dc2309499872500c8b8b408d47dc845de4", "author": {"user": {"login": "George-Wu", "name": "JIahao wu"}}, "url": "https://github.com/apache/beam/commit/8b4f46dc2309499872500c8b8b408d47dc845de4", "committedDate": "2020-08-05T19:21:51Z", "message": "fix lint"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f6bc77555aea24d02722f33951f5a02d708d9ce", "author": {"user": {"login": "George-Wu", "name": "JIahao wu"}}, "url": "https://github.com/apache/beam/commit/2f6bc77555aea24d02722f33951f5a02d708d9ce", "committedDate": "2020-08-05T19:51:16Z", "message": "fix style and update changes.md"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxOTg4ODcw", "url": "https://github.com/apache/beam/pull/12473#pullrequestreview-461988870", "createdAt": "2020-08-05T20:12:19Z", "commit": {"oid": "2f6bc77555aea24d02722f33951f5a02d708d9ce"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoxMjoxOVrOG8Y74w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDozMjo1OFrOG8ZlqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk3NjI5MQ==", "bodyText": "If tests are run in parallel potentially the 2 stores could have the same name because you are using time. It may be best to generate a random string.", "url": "https://github.com/apache/beam/pull/12473#discussion_r465976291", "createdAt": "2020-08-05T20:12:19Z", "author": {"login": "DanKotowski"}, "path": "sdks/python/apache_beam/io/gcp/dicomio_integration_test.py", "diffHunk": "@@ -0,0 +1,155 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Integration test for Google Cloud DICOM IO connector.\n+\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import json\n+import time\n+import unittest\n+\n+from google.auth import default\n+from google.auth.transport import requests\n+from google.cloud import storage\n+from nose.plugins.attrib import attr\n+\n+import apache_beam as beam\n+from apache_beam.io import fileio\n+from apache_beam.io.gcp.dicomio import DicomSearch\n+from apache_beam.io.gcp.dicomio import UploadToDicomStore\n+from apache_beam.testing.test_pipeline import TestPipeline\n+from apache_beam.testing.util import assert_that\n+from apache_beam.testing.util import equal_to\n+\n+REGION = 'us-central1'\n+DATA_SET_ID = 'apache-beam-integration-testing'\n+HEALTHCARE_BASE_URL = 'https://healthcare.googleapis.com/v1'\n+PERSISTENT_DICOM_STORE_NAME = \"dicom_it_persistent_store\"\n+DICOM_FILES_PATH = \"gs://temp-storage-for-dicom-io-tests/dicom_files\"\n+NUM_INSTANCE = 18\n+\n+\n+def create_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Create a an empty DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores\".format(api_endpoint, dataset_id)\n+\n+  response = session.post(\n+      dicomweb_path, params={\"dicomStoreId\": dicom_store_id})\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+def delete_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Delete an existing DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores/{}\".format(\n+      api_endpoint, dataset_id, dicom_store_id)\n+\n+  response = session.delete(dicomweb_path)\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+class DICOMIoIntegrationTest(unittest.TestCase):\n+  expected_output_metadata = None\n+\n+  def setUp(self):\n+    self.test_pipeline = TestPipeline(is_integration_test=True)\n+    self.project = self.test_pipeline.get_option('project')\n+\n+    # create a temp Dicom store based on the time stamp\n+    self.temp_dicom_store = \"DICOM_store_\" + str(time.time())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f6bc77555aea24d02722f33951f5a02d708d9ce"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk3OTM4MA==", "bodyText": "the name of the test should describe the behaviour you are testing, could you update all your tests names.", "url": "https://github.com/apache/beam/pull/12473#discussion_r465979380", "createdAt": "2020-08-05T20:18:18Z", "author": {"login": "DanKotowski"}, "path": "sdks/python/apache_beam/io/gcp/dicomio_integration_test.py", "diffHunk": "@@ -0,0 +1,155 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Integration test for Google Cloud DICOM IO connector.\n+\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import json\n+import time\n+import unittest\n+\n+from google.auth import default\n+from google.auth.transport import requests\n+from google.cloud import storage\n+from nose.plugins.attrib import attr\n+\n+import apache_beam as beam\n+from apache_beam.io import fileio\n+from apache_beam.io.gcp.dicomio import DicomSearch\n+from apache_beam.io.gcp.dicomio import UploadToDicomStore\n+from apache_beam.testing.test_pipeline import TestPipeline\n+from apache_beam.testing.util import assert_that\n+from apache_beam.testing.util import equal_to\n+\n+REGION = 'us-central1'\n+DATA_SET_ID = 'apache-beam-integration-testing'\n+HEALTHCARE_BASE_URL = 'https://healthcare.googleapis.com/v1'\n+PERSISTENT_DICOM_STORE_NAME = \"dicom_it_persistent_store\"\n+DICOM_FILES_PATH = \"gs://temp-storage-for-dicom-io-tests/dicom_files\"\n+NUM_INSTANCE = 18\n+\n+\n+def create_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Create a an empty DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores\".format(api_endpoint, dataset_id)\n+\n+  response = session.post(\n+      dicomweb_path, params={\"dicomStoreId\": dicom_store_id})\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+def delete_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Delete an existing DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores/{}\".format(\n+      api_endpoint, dataset_id, dicom_store_id)\n+\n+  response = session.delete(dicomweb_path)\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+class DICOMIoIntegrationTest(unittest.TestCase):\n+  expected_output_metadata = None\n+\n+  def setUp(self):\n+    self.test_pipeline = TestPipeline(is_integration_test=True)\n+    self.project = self.test_pipeline.get_option('project')\n+\n+    # create a temp Dicom store based on the time stamp\n+    self.temp_dicom_store = \"DICOM_store_\" + str(time.time())\n+    create_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+    client = storage.Client()\n+    bucket = client.get_bucket('temp-storage-for-dicom-io-tests')\n+    blob = bucket.blob('meta_data_json/Dicom_io_it_test_data.json')\n+    data = json.loads(blob.download_as_string())\n+    self.expected_output_metadata = data\n+\n+  def tearDown(self):\n+    # clean up the temp Dicom store\n+    delete_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+\n+  @attr('IT')\n+  def test_dicom_search(self):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f6bc77555aea24d02722f33951f5a02d708d9ce"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4MDI5Mg==", "bodyText": "I think it would also make sense to add  a test where there is an additional which does a bit more of a complex search .", "url": "https://github.com/apache/beam/pull/12473#discussion_r465980292", "createdAt": "2020-08-05T20:20:01Z", "author": {"login": "DanKotowski"}, "path": "sdks/python/apache_beam/io/gcp/dicomio_integration_test.py", "diffHunk": "@@ -0,0 +1,155 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Integration test for Google Cloud DICOM IO connector.\n+\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import json\n+import time\n+import unittest\n+\n+from google.auth import default\n+from google.auth.transport import requests\n+from google.cloud import storage\n+from nose.plugins.attrib import attr\n+\n+import apache_beam as beam\n+from apache_beam.io import fileio\n+from apache_beam.io.gcp.dicomio import DicomSearch\n+from apache_beam.io.gcp.dicomio import UploadToDicomStore\n+from apache_beam.testing.test_pipeline import TestPipeline\n+from apache_beam.testing.util import assert_that\n+from apache_beam.testing.util import equal_to\n+\n+REGION = 'us-central1'\n+DATA_SET_ID = 'apache-beam-integration-testing'\n+HEALTHCARE_BASE_URL = 'https://healthcare.googleapis.com/v1'\n+PERSISTENT_DICOM_STORE_NAME = \"dicom_it_persistent_store\"\n+DICOM_FILES_PATH = \"gs://temp-storage-for-dicom-io-tests/dicom_files\"\n+NUM_INSTANCE = 18\n+\n+\n+def create_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Create a an empty DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores\".format(api_endpoint, dataset_id)\n+\n+  response = session.post(\n+      dicomweb_path, params={\"dicomStoreId\": dicom_store_id})\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+def delete_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Delete an existing DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores/{}\".format(\n+      api_endpoint, dataset_id, dicom_store_id)\n+\n+  response = session.delete(dicomweb_path)\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+class DICOMIoIntegrationTest(unittest.TestCase):\n+  expected_output_metadata = None\n+\n+  def setUp(self):\n+    self.test_pipeline = TestPipeline(is_integration_test=True)\n+    self.project = self.test_pipeline.get_option('project')\n+\n+    # create a temp Dicom store based on the time stamp\n+    self.temp_dicom_store = \"DICOM_store_\" + str(time.time())\n+    create_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+    client = storage.Client()\n+    bucket = client.get_bucket('temp-storage-for-dicom-io-tests')\n+    blob = bucket.blob('meta_data_json/Dicom_io_it_test_data.json')\n+    data = json.loads(blob.download_as_string())\n+    self.expected_output_metadata = data\n+\n+  def tearDown(self):\n+    # clean up the temp Dicom store\n+    delete_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+\n+  @attr('IT')\n+  def test_dicom_search(self):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk3OTM4MA=="}, "originalCommit": {"oid": "2f6bc77555aea24d02722f33951f5a02d708d9ce"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4Mzc2OA==", "bodyText": "We should define the expected value above and not inline.", "url": "https://github.com/apache/beam/pull/12473#discussion_r465983768", "createdAt": "2020-08-05T20:26:39Z", "author": {"login": "DanKotowski"}, "path": "sdks/python/apache_beam/io/gcp/dicomio_integration_test.py", "diffHunk": "@@ -0,0 +1,155 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Integration test for Google Cloud DICOM IO connector.\n+\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import json\n+import time\n+import unittest\n+\n+from google.auth import default\n+from google.auth.transport import requests\n+from google.cloud import storage\n+from nose.plugins.attrib import attr\n+\n+import apache_beam as beam\n+from apache_beam.io import fileio\n+from apache_beam.io.gcp.dicomio import DicomSearch\n+from apache_beam.io.gcp.dicomio import UploadToDicomStore\n+from apache_beam.testing.test_pipeline import TestPipeline\n+from apache_beam.testing.util import assert_that\n+from apache_beam.testing.util import equal_to\n+\n+REGION = 'us-central1'\n+DATA_SET_ID = 'apache-beam-integration-testing'\n+HEALTHCARE_BASE_URL = 'https://healthcare.googleapis.com/v1'\n+PERSISTENT_DICOM_STORE_NAME = \"dicom_it_persistent_store\"\n+DICOM_FILES_PATH = \"gs://temp-storage-for-dicom-io-tests/dicom_files\"\n+NUM_INSTANCE = 18\n+\n+\n+def create_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Create a an empty DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores\".format(api_endpoint, dataset_id)\n+\n+  response = session.post(\n+      dicomweb_path, params={\"dicomStoreId\": dicom_store_id})\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+def delete_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Delete an existing DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores/{}\".format(\n+      api_endpoint, dataset_id, dicom_store_id)\n+\n+  response = session.delete(dicomweb_path)\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+class DICOMIoIntegrationTest(unittest.TestCase):\n+  expected_output_metadata = None\n+\n+  def setUp(self):\n+    self.test_pipeline = TestPipeline(is_integration_test=True)\n+    self.project = self.test_pipeline.get_option('project')\n+\n+    # create a temp Dicom store based on the time stamp\n+    self.temp_dicom_store = \"DICOM_store_\" + str(time.time())\n+    create_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+    client = storage.Client()\n+    bucket = client.get_bucket('temp-storage-for-dicom-io-tests')\n+    blob = bucket.blob('meta_data_json/Dicom_io_it_test_data.json')\n+    data = json.loads(blob.download_as_string())\n+    self.expected_output_metadata = data\n+\n+  def tearDown(self):\n+    # clean up the temp Dicom store\n+    delete_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+\n+  @attr('IT')\n+  def test_dicom_search(self):\n+    # Search and compare the metadata of a persistent DICOM store.\n+    input_dict = {}\n+    input_dict['project_id'] = self.project\n+    input_dict['region'] = REGION\n+    input_dict['dataset_id'] = DATA_SET_ID\n+    input_dict['dicom_store_id'] = PERSISTENT_DICOM_STORE_NAME\n+    input_dict['search_type'] = \"instances\"\n+\n+    expected_dict = {}\n+    expected_dict['result'] = self.expected_output_metadata\n+    expected_dict['status'] = 200\n+    expected_dict['input'] = input_dict\n+    expected_dict['success'] = True\n+\n+    with TestPipeline() as p:\n+      results = (p | beam.Create([input_dict]) | DicomSearch())\n+      assert_that(results, equal_to([expected_dict]))\n+\n+  @attr('IT')\n+  def test_dicom_store_instance(self):\n+    # Store DICOM files to a empty DICOM store from a GCS bucket,\n+    # then check if the store metadata match.\n+    input_dict = {}\n+    input_dict['project_id'] = self.project\n+    input_dict['region'] = REGION\n+    input_dict['dataset_id'] = DATA_SET_ID\n+    input_dict['dicom_store_id'] = self.temp_dicom_store\n+    input_dict['search_type'] = \"instances\"\n+\n+    expected_dict = {}\n+    expected_dict['result'] = self.expected_output_metadata\n+    expected_dict['status'] = 200\n+    expected_dict['input'] = input_dict\n+    expected_dict['success'] = True\n+\n+    with TestPipeline() as p:\n+      gcs_path = DICOM_FILES_PATH + \"/*\"\n+      results = (\n+          p\n+          | fileio.MatchFiles(gcs_path)\n+          | fileio.ReadMatches()\n+          | UploadToDicomStore(input_dict, 'fileio')\n+          | beam.Map(lambda x: x['success']))\n+      assert_that(results, equal_to([True] * NUM_INSTANCE))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f6bc77555aea24d02722f33951f5a02d708d9ce"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NTI5Ng==", "bodyText": "could we separate the input_dict between,  the store operation and the QIDO operation.", "url": "https://github.com/apache/beam/pull/12473#discussion_r465985296", "createdAt": "2020-08-05T20:29:43Z", "author": {"login": "DanKotowski"}, "path": "sdks/python/apache_beam/io/gcp/dicomio_integration_test.py", "diffHunk": "@@ -0,0 +1,155 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Integration test for Google Cloud DICOM IO connector.\n+\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import json\n+import time\n+import unittest\n+\n+from google.auth import default\n+from google.auth.transport import requests\n+from google.cloud import storage\n+from nose.plugins.attrib import attr\n+\n+import apache_beam as beam\n+from apache_beam.io import fileio\n+from apache_beam.io.gcp.dicomio import DicomSearch\n+from apache_beam.io.gcp.dicomio import UploadToDicomStore\n+from apache_beam.testing.test_pipeline import TestPipeline\n+from apache_beam.testing.util import assert_that\n+from apache_beam.testing.util import equal_to\n+\n+REGION = 'us-central1'\n+DATA_SET_ID = 'apache-beam-integration-testing'\n+HEALTHCARE_BASE_URL = 'https://healthcare.googleapis.com/v1'\n+PERSISTENT_DICOM_STORE_NAME = \"dicom_it_persistent_store\"\n+DICOM_FILES_PATH = \"gs://temp-storage-for-dicom-io-tests/dicom_files\"\n+NUM_INSTANCE = 18\n+\n+\n+def create_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Create a an empty DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores\".format(api_endpoint, dataset_id)\n+\n+  response = session.post(\n+      dicomweb_path, params={\"dicomStoreId\": dicom_store_id})\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+def delete_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Delete an existing DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores/{}\".format(\n+      api_endpoint, dataset_id, dicom_store_id)\n+\n+  response = session.delete(dicomweb_path)\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+class DICOMIoIntegrationTest(unittest.TestCase):\n+  expected_output_metadata = None\n+\n+  def setUp(self):\n+    self.test_pipeline = TestPipeline(is_integration_test=True)\n+    self.project = self.test_pipeline.get_option('project')\n+\n+    # create a temp Dicom store based on the time stamp\n+    self.temp_dicom_store = \"DICOM_store_\" + str(time.time())\n+    create_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+    client = storage.Client()\n+    bucket = client.get_bucket('temp-storage-for-dicom-io-tests')\n+    blob = bucket.blob('meta_data_json/Dicom_io_it_test_data.json')\n+    data = json.loads(blob.download_as_string())\n+    self.expected_output_metadata = data\n+\n+  def tearDown(self):\n+    # clean up the temp Dicom store\n+    delete_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+\n+  @attr('IT')\n+  def test_dicom_search(self):\n+    # Search and compare the metadata of a persistent DICOM store.\n+    input_dict = {}\n+    input_dict['project_id'] = self.project\n+    input_dict['region'] = REGION\n+    input_dict['dataset_id'] = DATA_SET_ID\n+    input_dict['dicom_store_id'] = PERSISTENT_DICOM_STORE_NAME\n+    input_dict['search_type'] = \"instances\"\n+\n+    expected_dict = {}\n+    expected_dict['result'] = self.expected_output_metadata\n+    expected_dict['status'] = 200\n+    expected_dict['input'] = input_dict\n+    expected_dict['success'] = True\n+\n+    with TestPipeline() as p:\n+      results = (p | beam.Create([input_dict]) | DicomSearch())\n+      assert_that(results, equal_to([expected_dict]))\n+\n+  @attr('IT')\n+  def test_dicom_store_instance(self):\n+    # Store DICOM files to a empty DICOM store from a GCS bucket,\n+    # then check if the store metadata match.\n+    input_dict = {}\n+    input_dict['project_id'] = self.project\n+    input_dict['region'] = REGION\n+    input_dict['dataset_id'] = DATA_SET_ID\n+    input_dict['dicom_store_id'] = self.temp_dicom_store\n+    input_dict['search_type'] = \"instances\"\n+\n+    expected_dict = {}\n+    expected_dict['result'] = self.expected_output_metadata\n+    expected_dict['status'] = 200\n+    expected_dict['input'] = input_dict\n+    expected_dict['success'] = True\n+\n+    with TestPipeline() as p:\n+      gcs_path = DICOM_FILES_PATH + \"/*\"\n+      results = (\n+          p\n+          | fileio.MatchFiles(gcs_path)\n+          | fileio.ReadMatches()\n+          | UploadToDicomStore(input_dict, 'fileio')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f6bc77555aea24d02722f33951f5a02d708d9ce"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4Njk4NQ==", "bodyText": "Is it possible to add a pub/sub test, potentially we could run an UploadToDicomStore, and then check that we  are receiving the correct messages.", "url": "https://github.com/apache/beam/pull/12473#discussion_r465986985", "createdAt": "2020-08-05T20:32:58Z", "author": {"login": "DanKotowski"}, "path": "sdks/python/apache_beam/io/gcp/dicomio_integration_test.py", "diffHunk": "@@ -0,0 +1,155 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Integration test for Google Cloud DICOM IO connector.\n+\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import json\n+import time\n+import unittest\n+\n+from google.auth import default\n+from google.auth.transport import requests\n+from google.cloud import storage\n+from nose.plugins.attrib import attr\n+\n+import apache_beam as beam\n+from apache_beam.io import fileio\n+from apache_beam.io.gcp.dicomio import DicomSearch\n+from apache_beam.io.gcp.dicomio import UploadToDicomStore\n+from apache_beam.testing.test_pipeline import TestPipeline\n+from apache_beam.testing.util import assert_that\n+from apache_beam.testing.util import equal_to\n+\n+REGION = 'us-central1'\n+DATA_SET_ID = 'apache-beam-integration-testing'\n+HEALTHCARE_BASE_URL = 'https://healthcare.googleapis.com/v1'\n+PERSISTENT_DICOM_STORE_NAME = \"dicom_it_persistent_store\"\n+DICOM_FILES_PATH = \"gs://temp-storage-for-dicom-io-tests/dicom_files\"\n+NUM_INSTANCE = 18\n+\n+\n+def create_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Create a an empty DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores\".format(api_endpoint, dataset_id)\n+\n+  response = session.post(\n+      dicomweb_path, params={\"dicomStoreId\": dicom_store_id})\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+def delete_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Delete an existing DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores/{}\".format(\n+      api_endpoint, dataset_id, dicom_store_id)\n+\n+  response = session.delete(dicomweb_path)\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+class DICOMIoIntegrationTest(unittest.TestCase):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f6bc77555aea24d02722f33951f5a02d708d9ce"}, "originalPosition": 82}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44177490f12302b8ebbe66a45c7bd943942d7975", "author": {"user": {"login": "George-Wu", "name": "JIahao wu"}}, "url": "https://github.com/apache/beam/commit/44177490f12302b8ebbe66a45c7bd943942d7975", "committedDate": "2020-08-06T05:29:56Z", "message": "resolved comments and fix dependency bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd2ed5d1009eea14fca9e10d79b38fb88306e8df", "author": {"user": {"login": "George-Wu", "name": "JIahao wu"}}, "url": "https://github.com/apache/beam/commit/bd2ed5d1009eea14fca9e10d79b38fb88306e8df", "committedDate": "2020-08-06T13:55:50Z", "message": "fix dependency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d44a2e776f0140139c893817622a63b1dcf22cf", "author": {"user": {"login": "George-Wu", "name": "JIahao wu"}}, "url": "https://github.com/apache/beam/commit/6d44a2e776f0140139c893817622a63b1dcf22cf", "committedDate": "2020-08-06T13:56:46Z", "message": "fix dependency"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNzA5Njgy", "url": "https://github.com/apache/beam/pull/12473#pullrequestreview-462709682", "createdAt": "2020-08-06T17:07:51Z", "commit": {"oid": "6d44a2e776f0140139c893817622a63b1dcf22cf"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzowNzo1MlrOG88ecg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzoyMDozOVrOG889qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU1ODU3OA==", "bodyText": "Can you please add detailed documentation on how the test works? for example, are there any instances of Dicom stores expected to be running? What files are used for the test?  (I see it all gets created, so that's great. just please document all of that here).", "url": "https://github.com/apache/beam/pull/12473#discussion_r466558578", "createdAt": "2020-08-06T17:07:52Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/io/gcp/dicomio_integration_test.py", "diffHunk": "@@ -0,0 +1,215 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Integration test for Google Cloud DICOM IO connector.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d44a2e776f0140139c893817622a63b1dcf22cf"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU1OTcyNA==", "bodyText": "please make sure that this bucket has lifecycle policies to ensure any left over files will be erased automatically (or feel free to use any of the other temp-storage-* in Beam which do have lifecycle policies", "url": "https://github.com/apache/beam/pull/12473#discussion_r466559724", "createdAt": "2020-08-06T17:09:56Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/io/gcp/dicomio_integration_test.py", "diffHunk": "@@ -0,0 +1,215 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Integration test for Google Cloud DICOM IO connector.\n+\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import random\n+import string\n+import unittest\n+\n+from nose.plugins.attrib import attr\n+\n+import apache_beam as beam\n+from apache_beam.io import fileio\n+from apache_beam.testing.test_pipeline import TestPipeline\n+from apache_beam.testing.util import assert_that\n+from apache_beam.testing.util import equal_to\n+\n+# pylint: disable=wrong-import-order, wrong-import-position\n+try:\n+  from apache_beam.io.gcp.dicomio import DicomSearch\n+  from apache_beam.io.gcp.dicomio import UploadToDicomStore\n+  from google.auth import default\n+  from google.auth.transport import requests\n+except ImportError:\n+  DicomSearch = None\n+# pylint: enable=wrong-import-order, wrong-import-position\n+\n+REGION = 'us-central1'\n+DATA_SET_ID = 'apache-beam-integration-testing'\n+HEALTHCARE_BASE_URL = 'https://healthcare.googleapis.com/v1'\n+GCS_BASE_URL = 'https://storage.googleapis.com/storage/v1'\n+PERSISTENT_DICOM_STORE_NAME = \"dicom_it_persistent_store\"\n+TEMP_BUCKET_NAME = 'temp-storage-for-dicom-io-tests'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d44a2e776f0140139c893817622a63b1dcf22cf"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2NDgyNg==", "bodyText": "as you realized, each test takes 5 minutes to run. With that in mind, would it be possible to consolidate the all_instance and refined_instance searches into a single test case?\nSomething roughly like this:\nwith p:\n  refined = p | searchrefined\n  all = p | searchall\n  assert_that(exp_ref, refined)\n  assert_that(exp_all, all, \"allmatch\")", "url": "https://github.com/apache/beam/pull/12473#discussion_r466564826", "createdAt": "2020-08-06T17:18:33Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/io/gcp/dicomio_integration_test.py", "diffHunk": "@@ -0,0 +1,215 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Integration test for Google Cloud DICOM IO connector.\n+\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import random\n+import string\n+import unittest\n+\n+from nose.plugins.attrib import attr\n+\n+import apache_beam as beam\n+from apache_beam.io import fileio\n+from apache_beam.testing.test_pipeline import TestPipeline\n+from apache_beam.testing.util import assert_that\n+from apache_beam.testing.util import equal_to\n+\n+# pylint: disable=wrong-import-order, wrong-import-position\n+try:\n+  from apache_beam.io.gcp.dicomio import DicomSearch\n+  from apache_beam.io.gcp.dicomio import UploadToDicomStore\n+  from google.auth import default\n+  from google.auth.transport import requests\n+except ImportError:\n+  DicomSearch = None\n+# pylint: enable=wrong-import-order, wrong-import-position\n+\n+REGION = 'us-central1'\n+DATA_SET_ID = 'apache-beam-integration-testing'\n+HEALTHCARE_BASE_URL = 'https://healthcare.googleapis.com/v1'\n+GCS_BASE_URL = 'https://storage.googleapis.com/storage/v1'\n+PERSISTENT_DICOM_STORE_NAME = \"dicom_it_persistent_store\"\n+TEMP_BUCKET_NAME = 'temp-storage-for-dicom-io-tests'\n+TEMP_FILES_PATH = 'gs://' + TEMP_BUCKET_NAME\n+META_DATA_ALL_NAME = 'Dicom_io_it_test_data.json'\n+META_DATA_REFINED_NAME = 'Dicom_io_it_test_refined_data.json'\n+NUM_INSTANCE = 18\n+RAND_LEN = 15\n+\n+\n+def random_string_generator(length):\n+  letters_and_digits = string.ascii_letters + string.digits\n+  result = ''.join((random.choice(letters_and_digits) for i in range(length)))\n+  return result\n+\n+\n+def create_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Create a an empty DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores\".format(api_endpoint, dataset_id)\n+\n+  response = session.post(\n+      dicomweb_path, params={\"dicomStoreId\": dicom_store_id})\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+def delete_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Delete an existing DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores/{}\".format(\n+      api_endpoint, dataset_id, dicom_store_id)\n+\n+  response = session.delete(dicomweb_path)\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+def get_gcs_file_http(file_name):\n+  # Get gcs file from REST Api\n+  api_endpoint = \"{}/b/{}/o/{}?alt=media\".format(\n+      GCS_BASE_URL, TEMP_BUCKET_NAME, file_name)\n+\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+\n+  response = session.get(api_endpoint)\n+  response.raise_for_status()\n+  return response.json()\n+\n+\n+@unittest.skipIf(DicomSearch is None, 'GCP dependencies are not installed')\n+class DICOMIoIntegrationTest(unittest.TestCase):\n+  def setUp(self):\n+    self.test_pipeline = TestPipeline(is_integration_test=True)\n+    self.project = self.test_pipeline.get_option('project')\n+    self.expected_output_all_metadata = get_gcs_file_http(META_DATA_ALL_NAME)\n+    self.expected_output_refined_metadata = get_gcs_file_http(\n+        META_DATA_REFINED_NAME)\n+\n+    # create a temp Dicom store based on the time stamp\n+    self.temp_dicom_store = \"DICOM_store_\" + random_string_generator(RAND_LEN)\n+    create_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+\n+  def tearDown(self):\n+    # clean up the temp Dicom store\n+    delete_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+\n+  @attr('IT')\n+  def test_dicom_search_all_instances(self):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d44a2e776f0140139c893817622a63b1dcf22cf"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2NjU3MQ==", "bodyText": "in this test case you're running two pipelines. This will therefore take 10 minutes to run. Perhaps it's worth making this the single test case that tests upload and search (or perhaps remove the search pipeline from this case to avoid the super long runtime?)", "url": "https://github.com/apache/beam/pull/12473#discussion_r466566571", "createdAt": "2020-08-06T17:20:39Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/io/gcp/dicomio_integration_test.py", "diffHunk": "@@ -0,0 +1,215 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Integration test for Google Cloud DICOM IO connector.\n+\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import random\n+import string\n+import unittest\n+\n+from nose.plugins.attrib import attr\n+\n+import apache_beam as beam\n+from apache_beam.io import fileio\n+from apache_beam.testing.test_pipeline import TestPipeline\n+from apache_beam.testing.util import assert_that\n+from apache_beam.testing.util import equal_to\n+\n+# pylint: disable=wrong-import-order, wrong-import-position\n+try:\n+  from apache_beam.io.gcp.dicomio import DicomSearch\n+  from apache_beam.io.gcp.dicomio import UploadToDicomStore\n+  from google.auth import default\n+  from google.auth.transport import requests\n+except ImportError:\n+  DicomSearch = None\n+# pylint: enable=wrong-import-order, wrong-import-position\n+\n+REGION = 'us-central1'\n+DATA_SET_ID = 'apache-beam-integration-testing'\n+HEALTHCARE_BASE_URL = 'https://healthcare.googleapis.com/v1'\n+GCS_BASE_URL = 'https://storage.googleapis.com/storage/v1'\n+PERSISTENT_DICOM_STORE_NAME = \"dicom_it_persistent_store\"\n+TEMP_BUCKET_NAME = 'temp-storage-for-dicom-io-tests'\n+TEMP_FILES_PATH = 'gs://' + TEMP_BUCKET_NAME\n+META_DATA_ALL_NAME = 'Dicom_io_it_test_data.json'\n+META_DATA_REFINED_NAME = 'Dicom_io_it_test_refined_data.json'\n+NUM_INSTANCE = 18\n+RAND_LEN = 15\n+\n+\n+def random_string_generator(length):\n+  letters_and_digits = string.ascii_letters + string.digits\n+  result = ''.join((random.choice(letters_and_digits) for i in range(length)))\n+  return result\n+\n+\n+def create_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Create a an empty DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores\".format(api_endpoint, dataset_id)\n+\n+  response = session.post(\n+      dicomweb_path, params={\"dicomStoreId\": dicom_store_id})\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+def delete_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Delete an existing DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores/{}\".format(\n+      api_endpoint, dataset_id, dicom_store_id)\n+\n+  response = session.delete(dicomweb_path)\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+def get_gcs_file_http(file_name):\n+  # Get gcs file from REST Api\n+  api_endpoint = \"{}/b/{}/o/{}?alt=media\".format(\n+      GCS_BASE_URL, TEMP_BUCKET_NAME, file_name)\n+\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+\n+  response = session.get(api_endpoint)\n+  response.raise_for_status()\n+  return response.json()\n+\n+\n+@unittest.skipIf(DicomSearch is None, 'GCP dependencies are not installed')\n+class DICOMIoIntegrationTest(unittest.TestCase):\n+  def setUp(self):\n+    self.test_pipeline = TestPipeline(is_integration_test=True)\n+    self.project = self.test_pipeline.get_option('project')\n+    self.expected_output_all_metadata = get_gcs_file_http(META_DATA_ALL_NAME)\n+    self.expected_output_refined_metadata = get_gcs_file_http(\n+        META_DATA_REFINED_NAME)\n+\n+    # create a temp Dicom store based on the time stamp\n+    self.temp_dicom_store = \"DICOM_store_\" + random_string_generator(RAND_LEN)\n+    create_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+\n+  def tearDown(self):\n+    # clean up the temp Dicom store\n+    delete_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+\n+  @attr('IT')\n+  def test_dicom_search_all_instances(self):\n+    # Search and compare the metadata of a persistent DICOM store.\n+    input_dict = {}\n+    input_dict['project_id'] = self.project\n+    input_dict['region'] = REGION\n+    input_dict['dataset_id'] = DATA_SET_ID\n+    input_dict['dicom_store_id'] = PERSISTENT_DICOM_STORE_NAME\n+    input_dict['search_type'] = \"instances\"\n+\n+    expected_dict = {}\n+    expected_dict['result'] = self.expected_output_all_metadata\n+    expected_dict['status'] = 200\n+    expected_dict['input'] = input_dict\n+    expected_dict['success'] = True\n+\n+    with self.test_pipeline as p:\n+      results = (p | beam.Create([input_dict]) | DicomSearch())\n+      assert_that(results, equal_to([expected_dict]), label='all search assert')\n+\n+  @attr('IT')\n+  def test_dicom_search_refined_instances(self):\n+    # Refine search and compare the metadata of a persistent DICOM store.\n+    input_dict = {}\n+    input_dict['project_id'] = self.project\n+    input_dict['region'] = REGION\n+    input_dict['dataset_id'] = DATA_SET_ID\n+    input_dict['dicom_store_id'] = PERSISTENT_DICOM_STORE_NAME\n+    input_dict['search_type'] = \"instances\"\n+    input_dict['params'] = {\n+        'StudyInstanceUID': 'study_000000001', 'limit': 500, 'offset': 0\n+    }\n+\n+    expected_dict = {}\n+    expected_dict['result'] = self.expected_output_refined_metadata\n+    expected_dict['status'] = 200\n+    expected_dict['input'] = input_dict\n+    expected_dict['success'] = True\n+\n+    with self.test_pipeline as p:\n+      results = (p | beam.Create([input_dict]) | DicomSearch())\n+      assert_that(\n+          results, equal_to([expected_dict]), label='refine search assert')\n+\n+  @attr('IT')\n+  def test_dicom_store_instance_from_gcs(self):\n+    # Store DICOM files to a empty DICOM store from a GCS bucket,\n+    # then check if the store metadata match.\n+    input_dict_store = {}\n+    input_dict_store['project_id'] = self.project\n+    input_dict_store['region'] = REGION\n+    input_dict_store['dataset_id'] = DATA_SET_ID\n+    input_dict_store['dicom_store_id'] = self.temp_dicom_store\n+\n+    expected_output = [True] * NUM_INSTANCE\n+\n+    with self.test_pipeline as p:\n+      gcs_path = TEMP_FILES_PATH + \"/dicom_files/*\"\n+      results = (\n+          p\n+          | fileio.MatchFiles(gcs_path)\n+          | fileio.ReadMatches()\n+          | UploadToDicomStore(input_dict_store, 'fileio')\n+          | beam.Map(lambda x: x['success']))\n+      assert_that(\n+          results, equal_to(expected_output), label='store first assert')\n+\n+    input_dict_search = {}\n+    input_dict_search['project_id'] = self.project\n+    input_dict_search['region'] = REGION\n+    input_dict_search['dataset_id'] = DATA_SET_ID\n+    input_dict_search['dicom_store_id'] = self.temp_dicom_store\n+    input_dict_search['search_type'] = \"instances\"\n+\n+    expected_dict = {}\n+    expected_dict['result'] = self.expected_output_all_metadata\n+    expected_dict['status'] = 200\n+    expected_dict['input'] = input_dict_search\n+    expected_dict['success'] = True\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d44a2e776f0140139c893817622a63b1dcf22cf"}, "originalPosition": 207}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15db728a5a7ea16c6535c41a19e8b6949f807e11", "author": {"user": {"login": "George-Wu", "name": "JIahao wu"}}, "url": "https://github.com/apache/beam/commit/15db728a5a7ea16c6535c41a19e8b6949f807e11", "committedDate": "2020-08-06T23:19:22Z", "message": "add documentation, use the right storage  and reduce number of pipelines."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab749d0b6d61dab91c14d0b7c29b63a70a26c8eb", "author": {"user": {"login": "George-Wu", "name": "JIahao wu"}}, "url": "https://github.com/apache/beam/commit/ab749d0b6d61dab91c14d0b7c29b63a70a26c8eb", "committedDate": "2020-08-07T00:04:09Z", "message": "add comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "912a1f60d3cd40a8a7e3c72184c451086ef395bb", "author": {"user": {"login": "George-Wu", "name": "JIahao wu"}}, "url": "https://github.com/apache/beam/commit/912a1f60d3cd40a8a7e3c72184c451086ef395bb", "committedDate": "2020-08-07T18:29:30Z", "message": "modify client a little"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3735, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}