{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2MzQxOTg1", "number": 13144, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDo1MzowMFrOEwevFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMDo0MzozMlrOEw_maw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjcwNjc5OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/transforms/util.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDo1MzowMFrOHmE4AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxODowNDo0MFrOHmtwmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY4NzgwOQ==", "bodyText": "You can use parenthesis to avoid using \\ as line continuation.", "url": "https://github.com/apache/beam/pull/13144#discussion_r509687809", "createdAt": "2020-10-21T20:53:00Z", "author": {"login": "boyuanzz"}, "path": "sdks/python/apache_beam/transforms/util.py", "diffHunk": "@@ -751,24 +751,42 @@ class GroupIntoBatches(PTransform):\n   GroupIntoBatches is experimental. Its use case will depend on the runner if\n   it has support of States and Timers.\n   \"\"\"\n-  def __init__(self, batch_size):\n+  def __init__(\n+      self, batch_size, max_buffering_duration_secs=None, clock=time.time):\n     \"\"\"Create a new GroupIntoBatches with batch size.\n \n     Arguments:\n       batch_size: (required) How many elements should be in a batch\n+      max_buffering_duration_secs: (optional) How long in seconds at most an\n+        incomplete batch of elements is allowed to be buffered in the states.\n+        The duration must be a positive second duration and should be given as\n+        an int or float.\n+      clock: (optional) an alternative to time.time (mostly for testing)\n     \"\"\"\n     self.batch_size = batch_size\n \n+    if max_buffering_duration_secs is not None:\n+      assert max_buffering_duration_secs > 0, \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e86a50bc48c18573b7afe2f63edda1dfe7c1ffcf"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM1NzY1Ng==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/13144#discussion_r510357656", "createdAt": "2020-10-22T18:04:40Z", "author": {"login": "nehsyc"}, "path": "sdks/python/apache_beam/transforms/util.py", "diffHunk": "@@ -751,24 +751,42 @@ class GroupIntoBatches(PTransform):\n   GroupIntoBatches is experimental. Its use case will depend on the runner if\n   it has support of States and Timers.\n   \"\"\"\n-  def __init__(self, batch_size):\n+  def __init__(\n+      self, batch_size, max_buffering_duration_secs=None, clock=time.time):\n     \"\"\"Create a new GroupIntoBatches with batch size.\n \n     Arguments:\n       batch_size: (required) How many elements should be in a batch\n+      max_buffering_duration_secs: (optional) How long in seconds at most an\n+        incomplete batch of elements is allowed to be buffered in the states.\n+        The duration must be a positive second duration and should be given as\n+        an int or float.\n+      clock: (optional) an alternative to time.time (mostly for testing)\n     \"\"\"\n     self.batch_size = batch_size\n \n+    if max_buffering_duration_secs is not None:\n+      assert max_buffering_duration_secs > 0, \\", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY4NzgwOQ=="}, "originalCommit": {"oid": "e86a50bc48c18573b7afe2f63edda1dfe7c1ffcf"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzQxOTcwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/transforms/util.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMDoxNDozOVrOHmMIag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNDo1OToxMlrOHmQn6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwNjY5OA==", "bodyText": "Pull this (and the exact same logic above and below) into common helper method.", "url": "https://github.com/apache/beam/pull/13144#discussion_r509806698", "createdAt": "2020-10-22T00:14:39Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/transforms/util.py", "diffHunk": "@@ -777,33 +795,56 @@ def process(\n         window=DoFn.WindowParam,\n         element_state=DoFn.StateParam(ELEMENT_STATE),\n         count_state=DoFn.StateParam(COUNT_STATE),\n-        expiry_timer=DoFn.TimerParam(EXPIRY_TIMER)):\n+        window_timer=DoFn.TimerParam(WINDOW_TIMER),\n+        buffering_timer=DoFn.TimerParam(BUFFERING_TIMER)):\n       # Allowed lateness not supported in Python SDK\n       # https://beam.apache.org/documentation/programming-guide/#watermarks-and-late-data\n-      expiry_timer.set(window.end)\n+      window_timer.set(window.end)\n       element_state.add(element)\n       count_state.add(1)\n       count = count_state.read()\n+      if count == 1 and max_buffering_duration_secs is not None:\n+        # This is the first element in batch. Start counting buffering time if a\n+        # limit was set.\n+        buffering_timer.set(clock() + max_buffering_duration_secs)\n       if count >= batch_size:\n         batch = [element for element in element_state.read()]\n         key, _ = batch[0]\n         batch_values = [v for (k, v) in batch]\n-        yield (key, batch_values)\n+        yield key, batch_values\n         element_state.clear()\n         count_state.clear()\n+        buffering_timer.clear()\n \n-    @on_timer(EXPIRY_TIMER)\n-    def expiry(\n+    @on_timer(WINDOW_TIMER)\n+    def on_window_timer(\n         self,\n         element_state=DoFn.StateParam(ELEMENT_STATE),\n-        count_state=DoFn.StateParam(COUNT_STATE)):\n+        count_state=DoFn.StateParam(COUNT_STATE),\n+        buffering_timer=DoFn.TimerParam(BUFFERING_TIMER)):\n+      batch = [element for element in element_state.read()]\n+      if batch:\n+        key, _ = batch[0]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e86a50bc48c18573b7afe2f63edda1dfe7c1ffcf"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg4MDI5OA==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/13144#discussion_r509880298", "createdAt": "2020-10-22T04:59:12Z", "author": {"login": "nehsyc"}, "path": "sdks/python/apache_beam/transforms/util.py", "diffHunk": "@@ -777,33 +795,56 @@ def process(\n         window=DoFn.WindowParam,\n         element_state=DoFn.StateParam(ELEMENT_STATE),\n         count_state=DoFn.StateParam(COUNT_STATE),\n-        expiry_timer=DoFn.TimerParam(EXPIRY_TIMER)):\n+        window_timer=DoFn.TimerParam(WINDOW_TIMER),\n+        buffering_timer=DoFn.TimerParam(BUFFERING_TIMER)):\n       # Allowed lateness not supported in Python SDK\n       # https://beam.apache.org/documentation/programming-guide/#watermarks-and-late-data\n-      expiry_timer.set(window.end)\n+      window_timer.set(window.end)\n       element_state.add(element)\n       count_state.add(1)\n       count = count_state.read()\n+      if count == 1 and max_buffering_duration_secs is not None:\n+        # This is the first element in batch. Start counting buffering time if a\n+        # limit was set.\n+        buffering_timer.set(clock() + max_buffering_duration_secs)\n       if count >= batch_size:\n         batch = [element for element in element_state.read()]\n         key, _ = batch[0]\n         batch_values = [v for (k, v) in batch]\n-        yield (key, batch_values)\n+        yield key, batch_values\n         element_state.clear()\n         count_state.clear()\n+        buffering_timer.clear()\n \n-    @on_timer(EXPIRY_TIMER)\n-    def expiry(\n+    @on_timer(WINDOW_TIMER)\n+    def on_window_timer(\n         self,\n         element_state=DoFn.StateParam(ELEMENT_STATE),\n-        count_state=DoFn.StateParam(COUNT_STATE)):\n+        count_state=DoFn.StateParam(COUNT_STATE),\n+        buffering_timer=DoFn.TimerParam(BUFFERING_TIMER)):\n+      batch = [element for element in element_state.read()]\n+      if batch:\n+        key, _ = batch[0]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwNjY5OA=="}, "originalCommit": {"oid": "e86a50bc48c18573b7afe2f63edda1dfe7c1ffcf"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzQyNDM1OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/transforms/util.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMDoxNjo1MFrOHmMLAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNDo1OToxN1rOHmQn_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwNzM2MQ==", "bodyText": "Was this wrong?", "url": "https://github.com/apache/beam/pull/13144#discussion_r509807361", "createdAt": "2020-10-22T00:16:50Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/transforms/util.py", "diffHunk": "@@ -1009,7 +1050,7 @@ def _process(element):\n \n   @staticmethod\n   @typehints.with_input_types(str)\n-  @typehints.with_output_types(Union[List[str], List[Tuple[str, str]]])\n+  @typehints.with_output_types(Union[List[str], Tuple[str, str]])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e86a50bc48c18573b7afe2f63edda1dfe7c1ffcf"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg4MDMxOA==", "bodyText": "oops. It was correct. Reverted.", "url": "https://github.com/apache/beam/pull/13144#discussion_r509880318", "createdAt": "2020-10-22T04:59:17Z", "author": {"login": "nehsyc"}, "path": "sdks/python/apache_beam/transforms/util.py", "diffHunk": "@@ -1009,7 +1050,7 @@ def _process(element):\n \n   @staticmethod\n   @typehints.with_input_types(str)\n-  @typehints.with_output_types(Union[List[str], List[Tuple[str, str]]])\n+  @typehints.with_output_types(Union[List[str], Tuple[str, str]])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwNzM2MQ=="}, "originalCommit": {"oid": "e86a50bc48c18573b7afe2f63edda1dfe7c1ffcf"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzQyNjE4OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/transforms/util_test.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMDoxNzo1NVrOHmMMEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNDo1OToyMVrOHmQoDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwNzYzMg==", "bodyText": "Nit: I prefer the previous formatting (as the comment applies to the whole set of elements).", "url": "https://github.com/apache/beam/pull/13144#discussion_r509807632", "createdAt": "2020-10-22T00:17:55Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/transforms/util_test.py", "diffHunk": "@@ -110,10 +117,16 @@ def test_windowed_batches(self):\n           | util.BatchElements(\n               min_batch_size=5, max_batch_size=10, clock=FakeClock())\n           | beam.Map(len))\n-      assert_that(res, equal_to([\n-          5, 5, 10, 10,  # elements in [0, 30)\n-          10, 7,         # elements in [30, 47)\n-      ]))\n+      assert_that(\n+          res,\n+          equal_to([\n+              5,\n+              5,\n+              10,\n+              10,  # elements in [0, 30)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e86a50bc48c18573b7afe2f63edda1dfe7c1ffcf"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg4MDMzMw==", "bodyText": "Reverted.", "url": "https://github.com/apache/beam/pull/13144#discussion_r509880333", "createdAt": "2020-10-22T04:59:21Z", "author": {"login": "nehsyc"}, "path": "sdks/python/apache_beam/transforms/util_test.py", "diffHunk": "@@ -110,10 +117,16 @@ def test_windowed_batches(self):\n           | util.BatchElements(\n               min_batch_size=5, max_batch_size=10, clock=FakeClock())\n           | beam.Map(len))\n-      assert_that(res, equal_to([\n-          5, 5, 10, 10,  # elements in [0, 30)\n-          10, 7,         # elements in [30, 47)\n-      ]))\n+      assert_that(\n+          res,\n+          equal_to([\n+              5,\n+              5,\n+              10,\n+              10,  # elements in [0, 30)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwNzYzMg=="}, "originalCommit": {"oid": "e86a50bc48c18573b7afe2f63edda1dfe7c1ffcf"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzQyNzQ1OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/transforms/util_test.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMDoxODo0M1rOHmMMzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNDo1OToyNVrOHmQoHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwNzgyMQ==", "bodyText": "_ExpandValuesIterable?\nThis could also be FlatMapTuple(lambda k, vs: vs)", "url": "https://github.com/apache/beam/pull/13144#discussion_r509807821", "createdAt": "2020-10-22T00:18:43Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/transforms/util_test.py", "diffHunk": "@@ -644,6 +657,12 @@ def _create_test_data():\n       data.append((\"key\", scientists[index]))\n     return data\n \n+  class _ExpandIterable(DoFn):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e86a50bc48c18573b7afe2f63edda1dfe7c1ffcf"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg4MDM1MA==", "bodyText": "Good to know! Replaced with FlatMapTuple :D", "url": "https://github.com/apache/beam/pull/13144#discussion_r509880350", "createdAt": "2020-10-22T04:59:25Z", "author": {"login": "nehsyc"}, "path": "sdks/python/apache_beam/transforms/util_test.py", "diffHunk": "@@ -644,6 +657,12 @@ def _create_test_data():\n       data.append((\"key\", scientists[index]))\n     return data\n \n+  class _ExpandIterable(DoFn):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwNzgyMQ=="}, "originalCommit": {"oid": "e86a50bc48c18573b7afe2f63edda1dfe7c1ffcf"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODA4NTg1OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/transforms/util.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMDo0MDoxMVrOHm4kIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNDozNzo0N1rOHm73DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUzNDY4OQ==", "bodyText": "None is a valid key, so this is not quite safe. Instead, you could make flush_batch an iterable, and just do return self.flush_batch() everywhere.", "url": "https://github.com/apache/beam/pull/13144#discussion_r510534689", "createdAt": "2020-10-23T00:40:11Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/transforms/util.py", "diffHunk": "@@ -777,33 +795,56 @@ def process(\n         window=DoFn.WindowParam,\n         element_state=DoFn.StateParam(ELEMENT_STATE),\n         count_state=DoFn.StateParam(COUNT_STATE),\n-        expiry_timer=DoFn.TimerParam(EXPIRY_TIMER)):\n+        window_timer=DoFn.TimerParam(WINDOW_TIMER),\n+        buffering_timer=DoFn.TimerParam(BUFFERING_TIMER)):\n       # Allowed lateness not supported in Python SDK\n       # https://beam.apache.org/documentation/programming-guide/#watermarks-and-late-data\n-      expiry_timer.set(window.end)\n+      window_timer.set(window.end)\n       element_state.add(element)\n       count_state.add(1)\n       count = count_state.read()\n+      if count == 1 and max_buffering_duration_secs is not None:\n+        # This is the first element in batch. Start counting buffering time if a\n+        # limit was set.\n+        buffering_timer.set(clock() + max_buffering_duration_secs)\n       if count >= batch_size:\n-        batch = [element for element in element_state.read()]\n-        key, _ = batch[0]\n-        batch_values = [v for (k, v) in batch]\n-        yield (key, batch_values)\n-        element_state.clear()\n-        count_state.clear()\n-\n-    @on_timer(EXPIRY_TIMER)\n-    def expiry(\n+        key, batch_values = self.flush_batch(\n+            element_state, count_state, buffering_timer)\n+        if key is not None:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c4b66bd54735e75df0e9e1c7151aefd86b9ba91"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4ODY4NA==", "bodyText": "Done", "url": "https://github.com/apache/beam/pull/13144#discussion_r510588684", "createdAt": "2020-10-23T04:37:47Z", "author": {"login": "nehsyc"}, "path": "sdks/python/apache_beam/transforms/util.py", "diffHunk": "@@ -777,33 +795,56 @@ def process(\n         window=DoFn.WindowParam,\n         element_state=DoFn.StateParam(ELEMENT_STATE),\n         count_state=DoFn.StateParam(COUNT_STATE),\n-        expiry_timer=DoFn.TimerParam(EXPIRY_TIMER)):\n+        window_timer=DoFn.TimerParam(WINDOW_TIMER),\n+        buffering_timer=DoFn.TimerParam(BUFFERING_TIMER)):\n       # Allowed lateness not supported in Python SDK\n       # https://beam.apache.org/documentation/programming-guide/#watermarks-and-late-data\n-      expiry_timer.set(window.end)\n+      window_timer.set(window.end)\n       element_state.add(element)\n       count_state.add(1)\n       count = count_state.read()\n+      if count == 1 and max_buffering_duration_secs is not None:\n+        # This is the first element in batch. Start counting buffering time if a\n+        # limit was set.\n+        buffering_timer.set(clock() + max_buffering_duration_secs)\n       if count >= batch_size:\n-        batch = [element for element in element_state.read()]\n-        key, _ = batch[0]\n-        batch_values = [v for (k, v) in batch]\n-        yield (key, batch_values)\n-        element_state.clear()\n-        count_state.clear()\n-\n-    @on_timer(EXPIRY_TIMER)\n-    def expiry(\n+        key, batch_values = self.flush_batch(\n+            element_state, count_state, buffering_timer)\n+        if key is not None:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUzNDY4OQ=="}, "originalCommit": {"oid": "2c4b66bd54735e75df0e9e1c7151aefd86b9ba91"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODA5MTMxOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/transforms/util.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMDo0MzozMlrOHm4nOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNDozNzo1MFrOHm73GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUzNTQ4Mw==", "bodyText": "Specifically, here you would just return and below you would yield key, batch_values.", "url": "https://github.com/apache/beam/pull/13144#discussion_r510535483", "createdAt": "2020-10-23T00:43:32Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/transforms/util.py", "diffHunk": "@@ -777,33 +795,56 @@ def process(\n         window=DoFn.WindowParam,\n         element_state=DoFn.StateParam(ELEMENT_STATE),\n         count_state=DoFn.StateParam(COUNT_STATE),\n-        expiry_timer=DoFn.TimerParam(EXPIRY_TIMER)):\n+        window_timer=DoFn.TimerParam(WINDOW_TIMER),\n+        buffering_timer=DoFn.TimerParam(BUFFERING_TIMER)):\n       # Allowed lateness not supported in Python SDK\n       # https://beam.apache.org/documentation/programming-guide/#watermarks-and-late-data\n-      expiry_timer.set(window.end)\n+      window_timer.set(window.end)\n       element_state.add(element)\n       count_state.add(1)\n       count = count_state.read()\n+      if count == 1 and max_buffering_duration_secs is not None:\n+        # This is the first element in batch. Start counting buffering time if a\n+        # limit was set.\n+        buffering_timer.set(clock() + max_buffering_duration_secs)\n       if count >= batch_size:\n-        batch = [element for element in element_state.read()]\n-        key, _ = batch[0]\n-        batch_values = [v for (k, v) in batch]\n-        yield (key, batch_values)\n-        element_state.clear()\n-        count_state.clear()\n-\n-    @on_timer(EXPIRY_TIMER)\n-    def expiry(\n+        key, batch_values = self.flush_batch(\n+            element_state, count_state, buffering_timer)\n+        if key is not None:\n+          yield key, batch_values\n+\n+    @on_timer(WINDOW_TIMER)\n+    def on_window_timer(\n         self,\n         element_state=DoFn.StateParam(ELEMENT_STATE),\n-        count_state=DoFn.StateParam(COUNT_STATE)):\n+        count_state=DoFn.StateParam(COUNT_STATE),\n+        buffering_timer=DoFn.TimerParam(BUFFERING_TIMER)):\n+      key, batch_values = self.flush_batch(\n+          element_state, count_state, buffering_timer)\n+      if key is not None:\n+        yield key, batch_values\n+\n+    @on_timer(BUFFERING_TIMER)\n+    def on_buffering_timer(\n+        self,\n+        element_state=DoFn.StateParam(ELEMENT_STATE),\n+        count_state=DoFn.StateParam(COUNT_STATE),\n+        buffering_timer=DoFn.TimerParam(BUFFERING_TIMER)):\n+      key, batch_values = self.flush_batch(\n+          element_state, count_state, buffering_timer)\n+      if key is not None:\n+        yield key, batch_values\n+\n+    def flush_batch(self, element_state, count_state, buffering_timer):\n       batch = [element for element in element_state.read()]\n-      if batch:\n-        key, _ = batch[0]\n-        batch_values = [v for (k, v) in batch]\n-        yield (key, batch_values)\n-        element_state.clear()\n-        count_state.clear()\n+      if not batch:\n+        return None, None", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c4b66bd54735e75df0e9e1c7151aefd86b9ba91"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4ODY5Ng==", "bodyText": "Gotcha. I missed the return case previously so it didn't work correctly. Thanks for the suggestion!", "url": "https://github.com/apache/beam/pull/13144#discussion_r510588696", "createdAt": "2020-10-23T04:37:50Z", "author": {"login": "nehsyc"}, "path": "sdks/python/apache_beam/transforms/util.py", "diffHunk": "@@ -777,33 +795,56 @@ def process(\n         window=DoFn.WindowParam,\n         element_state=DoFn.StateParam(ELEMENT_STATE),\n         count_state=DoFn.StateParam(COUNT_STATE),\n-        expiry_timer=DoFn.TimerParam(EXPIRY_TIMER)):\n+        window_timer=DoFn.TimerParam(WINDOW_TIMER),\n+        buffering_timer=DoFn.TimerParam(BUFFERING_TIMER)):\n       # Allowed lateness not supported in Python SDK\n       # https://beam.apache.org/documentation/programming-guide/#watermarks-and-late-data\n-      expiry_timer.set(window.end)\n+      window_timer.set(window.end)\n       element_state.add(element)\n       count_state.add(1)\n       count = count_state.read()\n+      if count == 1 and max_buffering_duration_secs is not None:\n+        # This is the first element in batch. Start counting buffering time if a\n+        # limit was set.\n+        buffering_timer.set(clock() + max_buffering_duration_secs)\n       if count >= batch_size:\n-        batch = [element for element in element_state.read()]\n-        key, _ = batch[0]\n-        batch_values = [v for (k, v) in batch]\n-        yield (key, batch_values)\n-        element_state.clear()\n-        count_state.clear()\n-\n-    @on_timer(EXPIRY_TIMER)\n-    def expiry(\n+        key, batch_values = self.flush_batch(\n+            element_state, count_state, buffering_timer)\n+        if key is not None:\n+          yield key, batch_values\n+\n+    @on_timer(WINDOW_TIMER)\n+    def on_window_timer(\n         self,\n         element_state=DoFn.StateParam(ELEMENT_STATE),\n-        count_state=DoFn.StateParam(COUNT_STATE)):\n+        count_state=DoFn.StateParam(COUNT_STATE),\n+        buffering_timer=DoFn.TimerParam(BUFFERING_TIMER)):\n+      key, batch_values = self.flush_batch(\n+          element_state, count_state, buffering_timer)\n+      if key is not None:\n+        yield key, batch_values\n+\n+    @on_timer(BUFFERING_TIMER)\n+    def on_buffering_timer(\n+        self,\n+        element_state=DoFn.StateParam(ELEMENT_STATE),\n+        count_state=DoFn.StateParam(COUNT_STATE),\n+        buffering_timer=DoFn.TimerParam(BUFFERING_TIMER)):\n+      key, batch_values = self.flush_batch(\n+          element_state, count_state, buffering_timer)\n+      if key is not None:\n+        yield key, batch_values\n+\n+    def flush_batch(self, element_state, count_state, buffering_timer):\n       batch = [element for element in element_state.read()]\n-      if batch:\n-        key, _ = batch[0]\n-        batch_values = [v for (k, v) in batch]\n-        yield (key, batch_values)\n-        element_state.clear()\n-        count_state.clear()\n+      if not batch:\n+        return None, None", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUzNTQ4Mw=="}, "originalCommit": {"oid": "2c4b66bd54735e75df0e9e1c7151aefd86b9ba91"}, "originalPosition": 112}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3038, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}