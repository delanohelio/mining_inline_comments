{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1NTUzNzY0", "number": 11653, "title": "[BEAM-9935] Respect allowed split points in Python.", "bodyText": "Thank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nApex\nDataflow\nFlink\nGearpump\nSamza\nSpark\n\n\n\n\nGo\n\n---\n---\n\n---\n---\n\n\n\nJava\n\n\n\n\n\n\n\n\n\nPython\n\n---\n\n\n---\n---\n\n\n\nXLang\n---\n---\n---\n\n---\n---\n\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-05-09T10:26:24Z", "url": "https://github.com/apache/beam/pull/11653", "merged": true, "mergeCommit": {"oid": "cad0333d6e27a9646fb70289bc8d2dde770b55af"}, "closed": true, "closedAt": "2020-05-11T22:57:29Z", "author": {"login": "robertwb"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcfj4ARgH2gAyNDE1NTUzNzY0OjNkYWQyZTUwMmU1NDczODFiNjMwOTI3MTU1MTA1MWFjNTJiOTQ2ODc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcgYNgcAFqTQwOTU1OTQ2Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3dad2e502e547381b6309271551051ac52b94687", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/3dad2e502e547381b6309271551051ac52b94687", "committedDate": "2020-05-09T10:25:35Z", "message": "[BEAM-9935] Respect allowed split points in Python."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5MzQzNzgz", "url": "https://github.com/apache/beam/pull/11653#pullrequestreview-409343783", "createdAt": "2020-05-11T16:41:48Z", "commit": {"oid": "3dad2e502e547381b6309271551051ac52b94687"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjo0MTo0OVrOGTkaVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNzowMjo0OVrOGTlOYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3MjY5Mg==", "bodyText": "allowed_split_points definition is too vague in the case of multiple active elements and we need to scope it down to mean the set of allowed first_residual_element indices.", "url": "https://github.com/apache/beam/pull/11653#discussion_r423172692", "createdAt": "2020-05-11T16:41:49Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "diffHunk": "@@ -237,30 +235,71 @@ def try_split(self, fraction_of_remainder, total_buffer_size):\n           current_element_progress = (\n               current_element_progress_object.fraction_completed)\n       # Now figure out where to split.\n-      # The units here (except for keep_of_element_remainder) are all in\n-      # terms of number of (possibly fractional) elements.\n-      remainder = total_buffer_size - self.index - current_element_progress\n-      keep = remainder * fraction_of_remainder\n-      if current_element_progress < 1:\n-        keep_of_element_remainder = keep / (1 - current_element_progress)\n-        # If it's less than what's left of the current element,\n-        # try splitting at the current element.\n-        if keep_of_element_remainder < 1:\n-          split = self.receivers[0].try_split(\n-              keep_of_element_remainder\n-          )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n-          if split:\n-            element_primary, element_residual = split\n-            self.stop = self.index + 1\n-            return self.index - 1, element_primary, element_residual, self.stop\n-      # Otherwise, split at the closest element boundary.\n-      # pylint: disable=round-builtin\n-      stop_index = (\n-          self.index + max(1, int(round(current_element_progress + keep))))\n-      if stop_index < self.stop:\n-        self.stop = stop_index\n-        return self.stop - 1, None, None, self.stop\n-    return None\n+      split = self._compute_split(\n+          self.index,\n+          current_element_progress,\n+          self.stop,\n+          fraction_of_remainder,\n+          total_buffer_size,\n+          allowed_split_points,\n+          self.receivers[0].try_split)\n+      if split:\n+        self.stop = split[-1]\n+      return split\n+\n+  @staticmethod\n+  def _compute_split(\n+      index,\n+      current_element_progress,\n+      stop,\n+      fraction_of_remainder,\n+      total_buffer_size,\n+      allowed_split_points=(),\n+      try_split=lambda fraction: None):\n+    def is_valid_split_point(index):\n+      return not allowed_split_points or index in allowed_split_points\n+\n+    if total_buffer_size < index + 1:\n+      total_buffer_size = index + 1\n+    elif total_buffer_size > stop:\n+      total_buffer_size = stop\n+    # The units here (except for keep_of_element_remainder) are all in\n+    # terms of number of (possibly fractional) elements.\n+    remainder = total_buffer_size - index - current_element_progress\n+    keep = remainder * fraction_of_remainder\n+    if current_element_progress < 1:\n+      keep_of_element_remainder = keep / (1 - current_element_progress)\n+      # If it's less than what's left of the current element,\n+      # try splitting at the current element.\n+      if (keep_of_element_remainder < 1 and is_valid_split_point(index) and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dad2e502e547381b6309271551051ac52b94687"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3OTAyNg==", "bodyText": "We should make it an error to have duplicate split points in allowed_split_points.", "url": "https://github.com/apache/beam/pull/11653#discussion_r423179026", "createdAt": "2020-05-11T16:52:01Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "diffHunk": "@@ -237,30 +235,71 @@ def try_split(self, fraction_of_remainder, total_buffer_size):\n           current_element_progress = (\n               current_element_progress_object.fraction_completed)\n       # Now figure out where to split.\n-      # The units here (except for keep_of_element_remainder) are all in\n-      # terms of number of (possibly fractional) elements.\n-      remainder = total_buffer_size - self.index - current_element_progress\n-      keep = remainder * fraction_of_remainder\n-      if current_element_progress < 1:\n-        keep_of_element_remainder = keep / (1 - current_element_progress)\n-        # If it's less than what's left of the current element,\n-        # try splitting at the current element.\n-        if keep_of_element_remainder < 1:\n-          split = self.receivers[0].try_split(\n-              keep_of_element_remainder\n-          )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n-          if split:\n-            element_primary, element_residual = split\n-            self.stop = self.index + 1\n-            return self.index - 1, element_primary, element_residual, self.stop\n-      # Otherwise, split at the closest element boundary.\n-      # pylint: disable=round-builtin\n-      stop_index = (\n-          self.index + max(1, int(round(current_element_progress + keep))))\n-      if stop_index < self.stop:\n-        self.stop = stop_index\n-        return self.stop - 1, None, None, self.stop\n-    return None\n+      split = self._compute_split(\n+          self.index,\n+          current_element_progress,\n+          self.stop,\n+          fraction_of_remainder,\n+          total_buffer_size,\n+          allowed_split_points,\n+          self.receivers[0].try_split)\n+      if split:\n+        self.stop = split[-1]\n+      return split\n+\n+  @staticmethod\n+  def _compute_split(\n+      index,\n+      current_element_progress,\n+      stop,\n+      fraction_of_remainder,\n+      total_buffer_size,\n+      allowed_split_points=(),\n+      try_split=lambda fraction: None):\n+    def is_valid_split_point(index):\n+      return not allowed_split_points or index in allowed_split_points\n+\n+    if total_buffer_size < index + 1:\n+      total_buffer_size = index + 1\n+    elif total_buffer_size > stop:\n+      total_buffer_size = stop\n+    # The units here (except for keep_of_element_remainder) are all in\n+    # terms of number of (possibly fractional) elements.\n+    remainder = total_buffer_size - index - current_element_progress\n+    keep = remainder * fraction_of_remainder\n+    if current_element_progress < 1:\n+      keep_of_element_remainder = keep / (1 - current_element_progress)\n+      # If it's less than what's left of the current element,\n+      # try splitting at the current element.\n+      if (keep_of_element_remainder < 1 and is_valid_split_point(index) and\n+          is_valid_split_point(index + 1)):\n+        split = try_split(\n+            keep_of_element_remainder\n+        )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n+        if split:\n+          element_primary, element_residual = split\n+          return index - 1, element_primary, element_residual, index + 1\n+    # Otherwise, split at the closest element boundary.\n+    # pylint: disable=round-builtin\n+    stop_index = index + max(1, int(round(current_element_progress + keep)))\n+    if allowed_split_points and stop_index not in allowed_split_points:\n+      allowed_split_points = sorted(allowed_split_points)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dad2e502e547381b6309271551051ac52b94687"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4MjE5MA==", "bodyText": "I think you should comment that your choosing the closer of the two points here.", "url": "https://github.com/apache/beam/pull/11653#discussion_r423182190", "createdAt": "2020-05-11T16:56:52Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "diffHunk": "@@ -237,30 +235,71 @@ def try_split(self, fraction_of_remainder, total_buffer_size):\n           current_element_progress = (\n               current_element_progress_object.fraction_completed)\n       # Now figure out where to split.\n-      # The units here (except for keep_of_element_remainder) are all in\n-      # terms of number of (possibly fractional) elements.\n-      remainder = total_buffer_size - self.index - current_element_progress\n-      keep = remainder * fraction_of_remainder\n-      if current_element_progress < 1:\n-        keep_of_element_remainder = keep / (1 - current_element_progress)\n-        # If it's less than what's left of the current element,\n-        # try splitting at the current element.\n-        if keep_of_element_remainder < 1:\n-          split = self.receivers[0].try_split(\n-              keep_of_element_remainder\n-          )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n-          if split:\n-            element_primary, element_residual = split\n-            self.stop = self.index + 1\n-            return self.index - 1, element_primary, element_residual, self.stop\n-      # Otherwise, split at the closest element boundary.\n-      # pylint: disable=round-builtin\n-      stop_index = (\n-          self.index + max(1, int(round(current_element_progress + keep))))\n-      if stop_index < self.stop:\n-        self.stop = stop_index\n-        return self.stop - 1, None, None, self.stop\n-    return None\n+      split = self._compute_split(\n+          self.index,\n+          current_element_progress,\n+          self.stop,\n+          fraction_of_remainder,\n+          total_buffer_size,\n+          allowed_split_points,\n+          self.receivers[0].try_split)\n+      if split:\n+        self.stop = split[-1]\n+      return split\n+\n+  @staticmethod\n+  def _compute_split(\n+      index,\n+      current_element_progress,\n+      stop,\n+      fraction_of_remainder,\n+      total_buffer_size,\n+      allowed_split_points=(),\n+      try_split=lambda fraction: None):\n+    def is_valid_split_point(index):\n+      return not allowed_split_points or index in allowed_split_points\n+\n+    if total_buffer_size < index + 1:\n+      total_buffer_size = index + 1\n+    elif total_buffer_size > stop:\n+      total_buffer_size = stop\n+    # The units here (except for keep_of_element_remainder) are all in\n+    # terms of number of (possibly fractional) elements.\n+    remainder = total_buffer_size - index - current_element_progress\n+    keep = remainder * fraction_of_remainder\n+    if current_element_progress < 1:\n+      keep_of_element_remainder = keep / (1 - current_element_progress)\n+      # If it's less than what's left of the current element,\n+      # try splitting at the current element.\n+      if (keep_of_element_remainder < 1 and is_valid_split_point(index) and\n+          is_valid_split_point(index + 1)):\n+        split = try_split(\n+            keep_of_element_remainder\n+        )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n+        if split:\n+          element_primary, element_residual = split\n+          return index - 1, element_primary, element_residual, index + 1\n+    # Otherwise, split at the closest element boundary.\n+    # pylint: disable=round-builtin\n+    stop_index = index + max(1, int(round(current_element_progress + keep)))\n+    if allowed_split_points and stop_index not in allowed_split_points:\n+      allowed_split_points = sorted(allowed_split_points)\n+      closest = bisect.bisect(allowed_split_points, stop_index)\n+      if closest == 0:\n+        stop_index = allowed_split_points[0]\n+      elif closest == len(allowed_split_points):\n+        stop_index = allowed_split_points[-1]\n+      else:\n+        prev = allowed_split_points[closest - 1]\n+        next = allowed_split_points[closest]\n+        if index < prev and stop_index - prev < next - stop_index:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dad2e502e547381b6309271551051ac52b94687"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4Mjg5Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              def test_split_with_element_progres(self):\n          \n          \n            \n              def test_split_with_element_progress(self):", "url": "https://github.com/apache/beam/pull/11653#discussion_r423182892", "createdAt": "2020-05-11T16:57:55Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor_test.py", "diffHunk": "@@ -0,0 +1,118 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Unit tests for bundle processing.\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import unittest\n+\n+from apache_beam.runners.worker.bundle_processor import DataInputOperation\n+\n+\n+def simple_split(first_residual_index):\n+  return first_residual_index - 1, None, None, first_residual_index\n+\n+\n+def element_split(frac, index):\n+  return (\n+      index - 1,\n+      'Primary(%0.1f)' % frac,\n+      'Residual(%0.1f)' % (1 - frac),\n+      index + 1)\n+\n+\n+class SplitTest(unittest.TestCase):\n+  def split(\n+      self,\n+      index,\n+      current_element_progress,\n+      fraction_of_remainder,\n+      buffer_size,\n+      allowed=(),\n+      sdf=False):\n+    return DataInputOperation._compute_split(\n+        index,\n+        current_element_progress,\n+        float('inf'),\n+        fraction_of_remainder,\n+        buffer_size,\n+        allowed_split_points=allowed,\n+        try_split=lambda frac: element_split(frac, 0)[1:3] if sdf else None)\n+\n+  def sdf_split(self, *args, **kwargs):\n+    return self.split(*args, sdf=True, **kwargs)\n+\n+  def test_simple_split(self):\n+    self.assertEqual(self.split(0, 0, 0, 16), simple_split(1))\n+    self.assertEqual(self.split(0, 0, 0.24, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.25, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.26, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.5, 16), simple_split(8))\n+    self.assertEqual(self.split(2, 0, 0.5, 16), simple_split(9))\n+    self.assertEqual(self.split(6, 0, 0.5, 16), simple_split(11))\n+\n+  def test_split_with_element_progres(self):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dad2e502e547381b6309271551051ac52b94687"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NTQ0NQ==", "bodyText": "It would be good to either add comments or break out the tests to separate methods to describe the different scenarios such as round to closest.", "url": "https://github.com/apache/beam/pull/11653#discussion_r423185445", "createdAt": "2020-05-11T17:01:54Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor_test.py", "diffHunk": "@@ -0,0 +1,118 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Unit tests for bundle processing.\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import unittest\n+\n+from apache_beam.runners.worker.bundle_processor import DataInputOperation\n+\n+\n+def simple_split(first_residual_index):\n+  return first_residual_index - 1, None, None, first_residual_index\n+\n+\n+def element_split(frac, index):\n+  return (\n+      index - 1,\n+      'Primary(%0.1f)' % frac,\n+      'Residual(%0.1f)' % (1 - frac),\n+      index + 1)\n+\n+\n+class SplitTest(unittest.TestCase):\n+  def split(\n+      self,\n+      index,\n+      current_element_progress,\n+      fraction_of_remainder,\n+      buffer_size,\n+      allowed=(),\n+      sdf=False):\n+    return DataInputOperation._compute_split(\n+        index,\n+        current_element_progress,\n+        float('inf'),\n+        fraction_of_remainder,\n+        buffer_size,\n+        allowed_split_points=allowed,\n+        try_split=lambda frac: element_split(frac, 0)[1:3] if sdf else None)\n+\n+  def sdf_split(self, *args, **kwargs):\n+    return self.split(*args, sdf=True, **kwargs)\n+\n+  def test_simple_split(self):\n+    self.assertEqual(self.split(0, 0, 0, 16), simple_split(1))\n+    self.assertEqual(self.split(0, 0, 0.24, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.25, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.26, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.5, 16), simple_split(8))\n+    self.assertEqual(self.split(2, 0, 0.5, 16), simple_split(9))\n+    self.assertEqual(self.split(6, 0, 0.5, 16), simple_split(11))\n+\n+  def test_split_with_element_progres(self):\n+    self.assertEqual(self.split(0, 0.5, 0.25, 4), simple_split(1))\n+    self.assertEqual(self.split(0, 0.9, 0.25, 4), simple_split(2))\n+    self.assertEqual(self.split(1, 0.0, 0.25, 4), simple_split(2))\n+    self.assertEqual(self.split(1, 0.1, 0.25, 4), simple_split(2))\n+\n+  def test_split_with_element_allowed_splits(self):\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 4, 5)), simple_split(4))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 5)), simple_split(5))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 6)), simple_split(3))\n+\n+    self.assertEqual(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dad2e502e547381b6309271551051ac52b94687"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NjAxOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                self.assertEqual(\n          \n          \n            \n                    self.sdf_split(0, 0, 0.12, 4), (-1, 'Primary(0.5)', 'Residual(0.5)', 1))\n          \n          \n            \n                self.assertEqual(\n          \n          \n            \n                    self.sdf_split(0, 0, 0.125, 4), (-1, 'Primary(0.5)', 'Residual(0.5)', 1))", "url": "https://github.com/apache/beam/pull/11653#discussion_r423186018", "createdAt": "2020-05-11T17:02:49Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor_test.py", "diffHunk": "@@ -0,0 +1,118 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Unit tests for bundle processing.\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import unittest\n+\n+from apache_beam.runners.worker.bundle_processor import DataInputOperation\n+\n+\n+def simple_split(first_residual_index):\n+  return first_residual_index - 1, None, None, first_residual_index\n+\n+\n+def element_split(frac, index):\n+  return (\n+      index - 1,\n+      'Primary(%0.1f)' % frac,\n+      'Residual(%0.1f)' % (1 - frac),\n+      index + 1)\n+\n+\n+class SplitTest(unittest.TestCase):\n+  def split(\n+      self,\n+      index,\n+      current_element_progress,\n+      fraction_of_remainder,\n+      buffer_size,\n+      allowed=(),\n+      sdf=False):\n+    return DataInputOperation._compute_split(\n+        index,\n+        current_element_progress,\n+        float('inf'),\n+        fraction_of_remainder,\n+        buffer_size,\n+        allowed_split_points=allowed,\n+        try_split=lambda frac: element_split(frac, 0)[1:3] if sdf else None)\n+\n+  def sdf_split(self, *args, **kwargs):\n+    return self.split(*args, sdf=True, **kwargs)\n+\n+  def test_simple_split(self):\n+    self.assertEqual(self.split(0, 0, 0, 16), simple_split(1))\n+    self.assertEqual(self.split(0, 0, 0.24, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.25, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.26, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.5, 16), simple_split(8))\n+    self.assertEqual(self.split(2, 0, 0.5, 16), simple_split(9))\n+    self.assertEqual(self.split(6, 0, 0.5, 16), simple_split(11))\n+\n+  def test_split_with_element_progres(self):\n+    self.assertEqual(self.split(0, 0.5, 0.25, 4), simple_split(1))\n+    self.assertEqual(self.split(0, 0.9, 0.25, 4), simple_split(2))\n+    self.assertEqual(self.split(1, 0.0, 0.25, 4), simple_split(2))\n+    self.assertEqual(self.split(1, 0.1, 0.25, 4), simple_split(2))\n+\n+  def test_split_with_element_allowed_splits(self):\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 4, 5)), simple_split(4))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 5)), simple_split(5))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 6)), simple_split(3))\n+\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(5, 6, 7)), simple_split(5))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(1, 2, 3)), simple_split(3))\n+\n+    self.assertEqual(self.split(5, 0, 0.25, 16, allowed=(1, 2, 3)), None)\n+\n+  def test_sdf_split(self):\n+    self.assertEqual(self.sdf_split(0, 0, 0.51, 4), simple_split(2))\n+    self.assertEqual(self.sdf_split(0, 0, 0.49, 4), simple_split(2))\n+    self.assertEqual(self.sdf_split(0, 0, 0.26, 4), simple_split(1))\n+    self.assertEqual(self.sdf_split(0, 0, 0.25, 4), simple_split(1))\n+    self.assertEqual(\n+        self.sdf_split(0, 0, 0.20, 4), (-1, 'Primary(0.8)', 'Residual(0.2)', 1))\n+    self.assertEqual(\n+        self.sdf_split(0, 0, 0.12, 4), (-1, 'Primary(0.5)', 'Residual(0.5)', 1))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dad2e502e547381b6309271551051ac52b94687"}, "originalPosition": 99}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "773854cd6a7e2429f5c5e704f875aef89233879b", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/773854cd6a7e2429f5c5e704f875aef89233879b", "committedDate": "2020-05-11T18:02:18Z", "message": "More comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NDUwMDI5", "url": "https://github.com/apache/beam/pull/11653#pullrequestreview-409450029", "createdAt": "2020-05-11T19:05:08Z", "commit": {"oid": "773854cd6a7e2429f5c5e704f875aef89233879b"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxOTowNTowOFrOGTpfQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxOTowNTowOFrOGTpfQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI1NTg3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // preceded an allowed split point.\n          \n          \n            \n                // precede an allowed split point.", "url": "https://github.com/apache/beam/pull/11653#discussion_r423255873", "createdAt": "2020-05-11T19:05:08Z", "author": {"login": "lukecwik"}, "path": "model/fn-execution/src/main/proto/beam_fn_api.proto", "diffHunk": "@@ -375,6 +375,9 @@ message ProcessBundleSplitRequest {\n \n     // A set of allowed element indices where the SDK may split. When this is\n     // empty, there are no constraints on where to split.\n+    // Specifically, the first_residual_element of a split result must be an\n+    // allowed split point, and the last_primary_element must immediately\n+    // preceded an allowed split point.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "773854cd6a7e2429f5c5e704f875aef89233879b"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NTU5NDY3", "url": "https://github.com/apache/beam/pull/11653#pullrequestreview-409559467", "createdAt": "2020-05-11T21:55:15Z", "commit": {"oid": "773854cd6a7e2429f5c5e704f875aef89233879b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMTo1NToxNVrOGTuykQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMTo1NToxNVrOGTuykQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0MjczNw==", "bodyText": "Is total_buffer_size the current outstanding buffer of data? Eg. The elements sent to the SDK, but as yet unprocessed?", "url": "https://github.com/apache/beam/pull/11653#discussion_r423342737", "createdAt": "2020-05-11T21:55:15Z", "author": {"login": "lostluck"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "diffHunk": "@@ -237,30 +235,72 @@ def try_split(self, fraction_of_remainder, total_buffer_size):\n           current_element_progress = (\n               current_element_progress_object.fraction_completed)\n       # Now figure out where to split.\n-      # The units here (except for keep_of_element_remainder) are all in\n-      # terms of number of (possibly fractional) elements.\n-      remainder = total_buffer_size - self.index - current_element_progress\n-      keep = remainder * fraction_of_remainder\n-      if current_element_progress < 1:\n-        keep_of_element_remainder = keep / (1 - current_element_progress)\n-        # If it's less than what's left of the current element,\n-        # try splitting at the current element.\n-        if keep_of_element_remainder < 1:\n-          split = self.receivers[0].try_split(\n-              keep_of_element_remainder\n-          )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n-          if split:\n-            element_primary, element_residual = split\n-            self.stop = self.index + 1\n-            return self.index - 1, element_primary, element_residual, self.stop\n-      # Otherwise, split at the closest element boundary.\n-      # pylint: disable=round-builtin\n-      stop_index = (\n-          self.index + max(1, int(round(current_element_progress + keep))))\n-      if stop_index < self.stop:\n-        self.stop = stop_index\n-        return self.stop - 1, None, None, self.stop\n-    return None\n+      split = self._compute_split(\n+          self.index,\n+          current_element_progress,\n+          self.stop,\n+          fraction_of_remainder,\n+          total_buffer_size,\n+          allowed_split_points,\n+          self.receivers[0].try_split)\n+      if split:\n+        self.stop = split[-1]\n+      return split\n+\n+  @staticmethod\n+  def _compute_split(\n+      index,\n+      current_element_progress,\n+      stop,\n+      fraction_of_remainder,\n+      total_buffer_size,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "773854cd6a7e2429f5c5e704f875aef89233879b"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4924, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}