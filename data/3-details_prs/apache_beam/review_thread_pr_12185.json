{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1MDE1NzQy", "number": 12185, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxNzo1NjozN1rOEMmLtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxOTo1OTowNlrOEcOPJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNjQzOTU4OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxNzo1NjozN1rOGuzOng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMjozMDozM1rOG0l3IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcyNzAwNg==", "bodyText": "This transform is not safe to do ubiquitously (due to the possibility of side effects).", "url": "https://github.com/apache/beam/pull/12185#discussion_r451727006", "createdAt": "2020-07-08T17:56:37Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -289,6 +289,8 @@ def create_stages(\n         phases=[\n             translations.annotate_downstream_side_inputs,\n             translations.fix_side_input_pcoll_coders,\n+            translations.eliminate_common_siblings,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg5NDIzNw==", "bodyText": "We could be able to annotate/recognize certain DoFns (e.g. by URN) for which this deduplication would be safe to apply.", "url": "https://github.com/apache/beam/pull/12185#discussion_r451894237", "createdAt": "2020-07-09T00:18:15Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -289,6 +289,8 @@ def create_stages(\n         phases=[\n             translations.annotate_downstream_side_inputs,\n             translations.fix_side_input_pcoll_coders,\n+            translations.eliminate_common_siblings,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcyNzAwNg=="}, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc5OTQ1Nw==", "bodyText": "As we discussed in a separate conversation, we would probably need a design or RFC for annotating DoFns are idempotent. As such, I've removed eliminate_common_siblings from this PR.", "url": "https://github.com/apache/beam/pull/12185#discussion_r457799457", "createdAt": "2020-07-21T02:30:33Z", "author": {"login": "yifanmai"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -289,6 +289,8 @@ def create_stages(\n         phases=[\n             translations.annotate_downstream_side_inputs,\n             translations.fix_side_input_pcoll_coders,\n+            translations.eliminate_common_siblings,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcyNzAwNg=="}, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNjQ0NjY0OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxNzo1ODo0MFrOGuzTRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODoxNDoxNlrOG8VG0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcyODE5Ng==", "bodyText": "One can omit the environment here--if two specs and payloads are identical, they are the same operation.", "url": "https://github.com/apache/beam/pull/12185#discussion_r451728196", "createdAt": "2020-07-08T17:58:40Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -685,6 +687,264 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def eliminate_common_siblings(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterable[Stage]\n+  \"\"\"Runs common subexpression elimination for common siblings.\n+\n+  If stages have common input, an identical transform, and one output each,\n+  then all but one stages will be eliminated, and the output of the remaining\n+  will be connected to the original output PCollections of the eliminated\n+  stages. This elimination runs only once, not recursively, and will only\n+  eliminate the first stage after a common input, rather than a chain of\n+  stages.\n+  \"\"\"\n+\n+  SiblingKey = collections.namedtuple(\n+      'SiblingKey', ['spec_urn', 'spec_payload', 'inputs', 'environment_id'])\n+\n+  def get_sibling_key(transform):\n+    \"\"\"Returns a key that will be identical for common siblings.\"\"\"\n+    transform_output_keys = list(transform.outputs.keys())\n+    # Return None as the sibling key for ineligible transforms.\n+    if len(transform_output_keys\n+          ) != 1 or transform.spec.urn != common_urns.primitives.PAR_DO.urn:\n+      return None\n+    return SiblingKey(\n+        spec_urn=transform.spec.urn,\n+        spec_payload=transform.spec.payload,\n+        inputs=tuple(transform.inputs.items()),\n+        environment_id=transform.environment_id)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMzU1Mw==", "bodyText": "Noted. Deleted code due to removal of eliminate_common_siblings.", "url": "https://github.com/apache/beam/pull/12185#discussion_r465913553", "createdAt": "2020-08-05T18:14:16Z", "author": {"login": "yifanmai"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -685,6 +687,264 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def eliminate_common_siblings(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterable[Stage]\n+  \"\"\"Runs common subexpression elimination for common siblings.\n+\n+  If stages have common input, an identical transform, and one output each,\n+  then all but one stages will be eliminated, and the output of the remaining\n+  will be connected to the original output PCollections of the eliminated\n+  stages. This elimination runs only once, not recursively, and will only\n+  eliminate the first stage after a common input, rather than a chain of\n+  stages.\n+  \"\"\"\n+\n+  SiblingKey = collections.namedtuple(\n+      'SiblingKey', ['spec_urn', 'spec_payload', 'inputs', 'environment_id'])\n+\n+  def get_sibling_key(transform):\n+    \"\"\"Returns a key that will be identical for common siblings.\"\"\"\n+    transform_output_keys = list(transform.outputs.keys())\n+    # Return None as the sibling key for ineligible transforms.\n+    if len(transform_output_keys\n+          ) != 1 or transform.spec.urn != common_urns.primitives.PAR_DO.urn:\n+      return None\n+    return SiblingKey(\n+        spec_urn=transform.spec.urn,\n+        spec_payload=transform.spec.payload,\n+        inputs=tuple(transform.inputs.items()),\n+        environment_id=transform.environment_id)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcyODE5Ng=="}, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNjQ1MzI2OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxODowMDozNVrOGuzXqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODoxNTo1M1rOG8VKNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcyOTMyMA==", "bodyText": "(Just a thought) I wonder if this should be a global tracked in the context for being able to properly reconstruct composites.", "url": "https://github.com/apache/beam/pull/12185#discussion_r451729320", "createdAt": "2020-07-08T18:00:35Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -685,6 +687,264 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def eliminate_common_siblings(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterable[Stage]\n+  \"\"\"Runs common subexpression elimination for common siblings.\n+\n+  If stages have common input, an identical transform, and one output each,\n+  then all but one stages will be eliminated, and the output of the remaining\n+  will be connected to the original output PCollections of the eliminated\n+  stages. This elimination runs only once, not recursively, and will only\n+  eliminate the first stage after a common input, rather than a chain of\n+  stages.\n+  \"\"\"\n+\n+  SiblingKey = collections.namedtuple(\n+      'SiblingKey', ['spec_urn', 'spec_payload', 'inputs', 'environment_id'])\n+\n+  def get_sibling_key(transform):\n+    \"\"\"Returns a key that will be identical for common siblings.\"\"\"\n+    transform_output_keys = list(transform.outputs.keys())\n+    # Return None as the sibling key for ineligible transforms.\n+    if len(transform_output_keys\n+          ) != 1 or transform.spec.urn != common_urns.primitives.PAR_DO.urn:\n+      return None\n+    return SiblingKey(\n+        spec_urn=transform.spec.urn,\n+        spec_payload=transform.spec.payload,\n+        inputs=tuple(transform.inputs.items()),\n+        environment_id=transform.environment_id)\n+\n+  # Group stages by keys.\n+  stages_by_sibling_key = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    stages_by_sibling_key[get_sibling_key(transform)].append(stage)\n+\n+  # Eliminate stages and build the output PCollection remapping dictionary.\n+  pcoll_id_remap = {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNDQyMg==", "bodyText": "Noted. I'm not currently aware of any requirement to keeping this around beyond inside this optimizer.", "url": "https://github.com/apache/beam/pull/12185#discussion_r465914422", "createdAt": "2020-08-05T18:15:53Z", "author": {"login": "yifanmai"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -685,6 +687,264 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def eliminate_common_siblings(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterable[Stage]\n+  \"\"\"Runs common subexpression elimination for common siblings.\n+\n+  If stages have common input, an identical transform, and one output each,\n+  then all but one stages will be eliminated, and the output of the remaining\n+  will be connected to the original output PCollections of the eliminated\n+  stages. This elimination runs only once, not recursively, and will only\n+  eliminate the first stage after a common input, rather than a chain of\n+  stages.\n+  \"\"\"\n+\n+  SiblingKey = collections.namedtuple(\n+      'SiblingKey', ['spec_urn', 'spec_payload', 'inputs', 'environment_id'])\n+\n+  def get_sibling_key(transform):\n+    \"\"\"Returns a key that will be identical for common siblings.\"\"\"\n+    transform_output_keys = list(transform.outputs.keys())\n+    # Return None as the sibling key for ineligible transforms.\n+    if len(transform_output_keys\n+          ) != 1 or transform.spec.urn != common_urns.primitives.PAR_DO.urn:\n+      return None\n+    return SiblingKey(\n+        spec_urn=transform.spec.urn,\n+        spec_payload=transform.spec.payload,\n+        inputs=tuple(transform.inputs.items()),\n+        environment_id=transform.environment_id)\n+\n+  # Group stages by keys.\n+  stages_by_sibling_key = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    stages_by_sibling_key[get_sibling_key(transform)].append(stage)\n+\n+  # Eliminate stages and build the output PCollection remapping dictionary.\n+  pcoll_id_remap = {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcyOTMyMA=="}, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNjYzNDEzOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxODo1NDoyMFrOGu1Klg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODoxODoxMFrOG8VO0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc1ODc0Mg==", "bodyText": "Was this copied from above? If needed, perhaps refactor? (Similarly for try_fuse_stages.)", "url": "https://github.com/apache/beam/pull/12185#discussion_r451758742", "createdAt": "2020-07-08T18:54:20Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -685,6 +687,264 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def eliminate_common_siblings(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterable[Stage]\n+  \"\"\"Runs common subexpression elimination for common siblings.\n+\n+  If stages have common input, an identical transform, and one output each,\n+  then all but one stages will be eliminated, and the output of the remaining\n+  will be connected to the original output PCollections of the eliminated\n+  stages. This elimination runs only once, not recursively, and will only\n+  eliminate the first stage after a common input, rather than a chain of\n+  stages.\n+  \"\"\"\n+\n+  SiblingKey = collections.namedtuple(\n+      'SiblingKey', ['spec_urn', 'spec_payload', 'inputs', 'environment_id'])\n+\n+  def get_sibling_key(transform):\n+    \"\"\"Returns a key that will be identical for common siblings.\"\"\"\n+    transform_output_keys = list(transform.outputs.keys())\n+    # Return None as the sibling key for ineligible transforms.\n+    if len(transform_output_keys\n+          ) != 1 or transform.spec.urn != common_urns.primitives.PAR_DO.urn:\n+      return None\n+    return SiblingKey(\n+        spec_urn=transform.spec.urn,\n+        spec_payload=transform.spec.payload,\n+        inputs=tuple(transform.inputs.items()),\n+        environment_id=transform.environment_id)\n+\n+  # Group stages by keys.\n+  stages_by_sibling_key = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    stages_by_sibling_key[get_sibling_key(transform)].append(stage)\n+\n+  # Eliminate stages and build the output PCollection remapping dictionary.\n+  pcoll_id_remap = {}\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    if sibling_key is None or len(sibling_stages) == 1:\n+      continue\n+    output_pcoll_ids = [\n+        only_element(stage.transforms[0].outputs.values())\n+        for stage in sibling_stages\n+    ]\n+    to_delete_pcoll_ids = output_pcoll_ids[1:]\n+    for to_delete_pcoll_id in to_delete_pcoll_ids:\n+      pcoll_id_remap[to_delete_pcoll_id] = output_pcoll_ids[0]\n+      del context.components.pcollections[to_delete_pcoll_id]\n+    del sibling_stages[1:]\n+\n+  # Yield stages while remapping output PCollections if needed.\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    for stage in sibling_stages:\n+      input_keys_to_remap = []\n+      for input_key, input_pcoll_id in stage.transforms[0].inputs.items():\n+        if input_pcoll_id in pcoll_id_remap:\n+          input_keys_to_remap.append(input_key)\n+      for input_key_to_remap in input_keys_to_remap:\n+        stage.transforms[0].inputs[input_key_to_remap] = pcoll_id_remap[\n+            stage.transforms[0].inputs[input_key_to_remap]]\n+      yield stage\n+\n+\n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  def _try_merge_environments(env1, env2):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNTYwMw==", "bodyText": "Yup, replaced with Stage._merge_environments instead.", "url": "https://github.com/apache/beam/pull/12185#discussion_r465915603", "createdAt": "2020-08-05T18:18:10Z", "author": {"login": "yifanmai"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -685,6 +687,264 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def eliminate_common_siblings(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterable[Stage]\n+  \"\"\"Runs common subexpression elimination for common siblings.\n+\n+  If stages have common input, an identical transform, and one output each,\n+  then all but one stages will be eliminated, and the output of the remaining\n+  will be connected to the original output PCollections of the eliminated\n+  stages. This elimination runs only once, not recursively, and will only\n+  eliminate the first stage after a common input, rather than a chain of\n+  stages.\n+  \"\"\"\n+\n+  SiblingKey = collections.namedtuple(\n+      'SiblingKey', ['spec_urn', 'spec_payload', 'inputs', 'environment_id'])\n+\n+  def get_sibling_key(transform):\n+    \"\"\"Returns a key that will be identical for common siblings.\"\"\"\n+    transform_output_keys = list(transform.outputs.keys())\n+    # Return None as the sibling key for ineligible transforms.\n+    if len(transform_output_keys\n+          ) != 1 or transform.spec.urn != common_urns.primitives.PAR_DO.urn:\n+      return None\n+    return SiblingKey(\n+        spec_urn=transform.spec.urn,\n+        spec_payload=transform.spec.payload,\n+        inputs=tuple(transform.inputs.items()),\n+        environment_id=transform.environment_id)\n+\n+  # Group stages by keys.\n+  stages_by_sibling_key = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    stages_by_sibling_key[get_sibling_key(transform)].append(stage)\n+\n+  # Eliminate stages and build the output PCollection remapping dictionary.\n+  pcoll_id_remap = {}\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    if sibling_key is None or len(sibling_stages) == 1:\n+      continue\n+    output_pcoll_ids = [\n+        only_element(stage.transforms[0].outputs.values())\n+        for stage in sibling_stages\n+    ]\n+    to_delete_pcoll_ids = output_pcoll_ids[1:]\n+    for to_delete_pcoll_id in to_delete_pcoll_ids:\n+      pcoll_id_remap[to_delete_pcoll_id] = output_pcoll_ids[0]\n+      del context.components.pcollections[to_delete_pcoll_id]\n+    del sibling_stages[1:]\n+\n+  # Yield stages while remapping output PCollections if needed.\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    for stage in sibling_stages:\n+      input_keys_to_remap = []\n+      for input_key, input_pcoll_id in stage.transforms[0].inputs.items():\n+        if input_pcoll_id in pcoll_id_remap:\n+          input_keys_to_remap.append(input_key)\n+      for input_key_to_remap in input_keys_to_remap:\n+        stage.transforms[0].inputs[input_key_to_remap] = pcoll_id_remap[\n+            stage.transforms[0].inputs[input_key_to_remap]]\n+      yield stage\n+\n+\n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  def _try_merge_environments(env1, env2):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc1ODc0Mg=="}, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNjY0NTc2OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxODo1Nzo1OFrOGu1SJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODoxMjowNFrOG8VCbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MDY3OQ==", "bodyText": "This will only work for Python combine fns (and should be guarded against that).", "url": "https://github.com/apache/beam/pull/12185#discussion_r451760679", "createdAt": "2020-07-08T18:57:58Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -685,6 +687,264 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def eliminate_common_siblings(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterable[Stage]\n+  \"\"\"Runs common subexpression elimination for common siblings.\n+\n+  If stages have common input, an identical transform, and one output each,\n+  then all but one stages will be eliminated, and the output of the remaining\n+  will be connected to the original output PCollections of the eliminated\n+  stages. This elimination runs only once, not recursively, and will only\n+  eliminate the first stage after a common input, rather than a chain of\n+  stages.\n+  \"\"\"\n+\n+  SiblingKey = collections.namedtuple(\n+      'SiblingKey', ['spec_urn', 'spec_payload', 'inputs', 'environment_id'])\n+\n+  def get_sibling_key(transform):\n+    \"\"\"Returns a key that will be identical for common siblings.\"\"\"\n+    transform_output_keys = list(transform.outputs.keys())\n+    # Return None as the sibling key for ineligible transforms.\n+    if len(transform_output_keys\n+          ) != 1 or transform.spec.urn != common_urns.primitives.PAR_DO.urn:\n+      return None\n+    return SiblingKey(\n+        spec_urn=transform.spec.urn,\n+        spec_payload=transform.spec.payload,\n+        inputs=tuple(transform.inputs.items()),\n+        environment_id=transform.environment_id)\n+\n+  # Group stages by keys.\n+  stages_by_sibling_key = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    stages_by_sibling_key[get_sibling_key(transform)].append(stage)\n+\n+  # Eliminate stages and build the output PCollection remapping dictionary.\n+  pcoll_id_remap = {}\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    if sibling_key is None or len(sibling_stages) == 1:\n+      continue\n+    output_pcoll_ids = [\n+        only_element(stage.transforms[0].outputs.values())\n+        for stage in sibling_stages\n+    ]\n+    to_delete_pcoll_ids = output_pcoll_ids[1:]\n+    for to_delete_pcoll_id in to_delete_pcoll_ids:\n+      pcoll_id_remap[to_delete_pcoll_id] = output_pcoll_ids[0]\n+      del context.components.pcollections[to_delete_pcoll_id]\n+    del sibling_stages[1:]\n+\n+  # Yield stages while remapping output PCollections if needed.\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    for stage in sibling_stages:\n+      input_keys_to_remap = []\n+      for input_key, input_pcoll_id in stage.transforms[0].inputs.items():\n+        if input_pcoll_id in pcoll_id_remap:\n+          input_keys_to_remap.append(input_key)\n+      for input_key_to_remap in input_keys_to_remap:\n+        stage.transforms[0].inputs[input_key_to_remap] = pcoll_id_remap[\n+            stage.transforms[0].inputs[input_key_to_remap]]\n+      yield stage\n+\n+\n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  def _try_merge_environments(env1, env2):\n+    if env1 is None:\n+      return env2\n+    elif env2 is None:\n+      return env1\n+    else:\n+      if env1 != env2:\n+        raise ValueError\n+      return env1\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(\n+          _try_merge_environments,\n+          [transform.environment_id or None for transform in transforms])\n+    except ValueError:\n+      for stage in packable_stages:\n+        yield stage\n+      continue\n+\n+    output_pcoll_ids = [\n+        only_element(transform.outputs.values()) for transform in transforms\n+    ]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Build accumulator coder for (acc1, acc2, ...)\n+    accumulator_coder_ids = [\n+        combine_payload.accumulator_coder_id\n+        for combine_payload in combine_payloads\n+    ]\n+    tuple_accumulator_coder_id = context.add_or_get_coder_id(\n+        beam_runner_api_pb2.Coder(\n+            spec=beam_runner_api_pb2.FunctionSpec(\n+                urn=common_urns.coders.KV.urn),\n+            component_coder_ids=accumulator_coder_ids))\n+\n+    # Build packed output coder for (key, (out1, out2, ...))\n+    input_kv_coder_id = context.components.pcollections[input_pcoll_id].coder_id\n+    key_coder_id = _get_key_coder_id_from_kv_coder(\n+        context.components.coders[input_kv_coder_id])\n+    output_kv_coder_ids = [\n+        context.components.pcollections[output_pcoll_id].coder_id\n+        for output_pcoll_id in output_pcoll_ids\n+    ]\n+    output_value_coder_ids = [\n+        _get_value_coder_id_from_kv_coder(\n+            context.components.coders[output_kv_coder_id])\n+        for output_kv_coder_id in output_kv_coder_ids\n+    ]\n+    pack_output_value_coder = beam_runner_api_pb2.Coder(\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        component_coder_ids=output_value_coder_ids)\n+    pack_output_value_coder_id = context.add_or_get_coder_id(\n+        pack_output_value_coder)\n+    pack_output_kv_coder = beam_runner_api_pb2.Coder(\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        component_coder_ids=[key_coder_id, pack_output_value_coder_id])\n+    pack_output_kv_coder_id = context.add_or_get_coder_id(pack_output_kv_coder)\n+\n+    # Set up packed PCollection\n+    pack_combine_name = fused_stage.name\n+    pack_pcoll_id = unique_name(context.components.pcollections, 'pcollection')\n+    input_pcoll = context.components.pcollections[input_pcoll_id]\n+    context.components.pcollections[pack_pcoll_id].CopyFrom(\n+        beam_runner_api_pb2.PCollection(\n+            unique_name=pack_combine_name + '.out',\n+            coder_id=pack_output_kv_coder_id,\n+            windowing_strategy_id=input_pcoll.windowing_strategy_id,\n+            is_bounded=input_pcoll.is_bounded))\n+\n+    # Set up Pack stage.\n+    pack_combine_fn = combiners.SingleInputTupleCombineFn(*[\n+        core.CombineFn.from_runner_api(combine_payload.combine_fn, context)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc5Nzk0MQ==", "bodyText": "How do I check that we're in a Python environment?", "url": "https://github.com/apache/beam/pull/12185#discussion_r457797941", "createdAt": "2020-07-21T02:25:14Z", "author": {"login": "yifanmai"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -685,6 +687,264 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def eliminate_common_siblings(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterable[Stage]\n+  \"\"\"Runs common subexpression elimination for common siblings.\n+\n+  If stages have common input, an identical transform, and one output each,\n+  then all but one stages will be eliminated, and the output of the remaining\n+  will be connected to the original output PCollections of the eliminated\n+  stages. This elimination runs only once, not recursively, and will only\n+  eliminate the first stage after a common input, rather than a chain of\n+  stages.\n+  \"\"\"\n+\n+  SiblingKey = collections.namedtuple(\n+      'SiblingKey', ['spec_urn', 'spec_payload', 'inputs', 'environment_id'])\n+\n+  def get_sibling_key(transform):\n+    \"\"\"Returns a key that will be identical for common siblings.\"\"\"\n+    transform_output_keys = list(transform.outputs.keys())\n+    # Return None as the sibling key for ineligible transforms.\n+    if len(transform_output_keys\n+          ) != 1 or transform.spec.urn != common_urns.primitives.PAR_DO.urn:\n+      return None\n+    return SiblingKey(\n+        spec_urn=transform.spec.urn,\n+        spec_payload=transform.spec.payload,\n+        inputs=tuple(transform.inputs.items()),\n+        environment_id=transform.environment_id)\n+\n+  # Group stages by keys.\n+  stages_by_sibling_key = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    stages_by_sibling_key[get_sibling_key(transform)].append(stage)\n+\n+  # Eliminate stages and build the output PCollection remapping dictionary.\n+  pcoll_id_remap = {}\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    if sibling_key is None or len(sibling_stages) == 1:\n+      continue\n+    output_pcoll_ids = [\n+        only_element(stage.transforms[0].outputs.values())\n+        for stage in sibling_stages\n+    ]\n+    to_delete_pcoll_ids = output_pcoll_ids[1:]\n+    for to_delete_pcoll_id in to_delete_pcoll_ids:\n+      pcoll_id_remap[to_delete_pcoll_id] = output_pcoll_ids[0]\n+      del context.components.pcollections[to_delete_pcoll_id]\n+    del sibling_stages[1:]\n+\n+  # Yield stages while remapping output PCollections if needed.\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    for stage in sibling_stages:\n+      input_keys_to_remap = []\n+      for input_key, input_pcoll_id in stage.transforms[0].inputs.items():\n+        if input_pcoll_id in pcoll_id_remap:\n+          input_keys_to_remap.append(input_key)\n+      for input_key_to_remap in input_keys_to_remap:\n+        stage.transforms[0].inputs[input_key_to_remap] = pcoll_id_remap[\n+            stage.transforms[0].inputs[input_key_to_remap]]\n+      yield stage\n+\n+\n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  def _try_merge_environments(env1, env2):\n+    if env1 is None:\n+      return env2\n+    elif env2 is None:\n+      return env1\n+    else:\n+      if env1 != env2:\n+        raise ValueError\n+      return env1\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(\n+          _try_merge_environments,\n+          [transform.environment_id or None for transform in transforms])\n+    except ValueError:\n+      for stage in packable_stages:\n+        yield stage\n+      continue\n+\n+    output_pcoll_ids = [\n+        only_element(transform.outputs.values()) for transform in transforms\n+    ]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Build accumulator coder for (acc1, acc2, ...)\n+    accumulator_coder_ids = [\n+        combine_payload.accumulator_coder_id\n+        for combine_payload in combine_payloads\n+    ]\n+    tuple_accumulator_coder_id = context.add_or_get_coder_id(\n+        beam_runner_api_pb2.Coder(\n+            spec=beam_runner_api_pb2.FunctionSpec(\n+                urn=common_urns.coders.KV.urn),\n+            component_coder_ids=accumulator_coder_ids))\n+\n+    # Build packed output coder for (key, (out1, out2, ...))\n+    input_kv_coder_id = context.components.pcollections[input_pcoll_id].coder_id\n+    key_coder_id = _get_key_coder_id_from_kv_coder(\n+        context.components.coders[input_kv_coder_id])\n+    output_kv_coder_ids = [\n+        context.components.pcollections[output_pcoll_id].coder_id\n+        for output_pcoll_id in output_pcoll_ids\n+    ]\n+    output_value_coder_ids = [\n+        _get_value_coder_id_from_kv_coder(\n+            context.components.coders[output_kv_coder_id])\n+        for output_kv_coder_id in output_kv_coder_ids\n+    ]\n+    pack_output_value_coder = beam_runner_api_pb2.Coder(\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        component_coder_ids=output_value_coder_ids)\n+    pack_output_value_coder_id = context.add_or_get_coder_id(\n+        pack_output_value_coder)\n+    pack_output_kv_coder = beam_runner_api_pb2.Coder(\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        component_coder_ids=[key_coder_id, pack_output_value_coder_id])\n+    pack_output_kv_coder_id = context.add_or_get_coder_id(pack_output_kv_coder)\n+\n+    # Set up packed PCollection\n+    pack_combine_name = fused_stage.name\n+    pack_pcoll_id = unique_name(context.components.pcollections, 'pcollection')\n+    input_pcoll = context.components.pcollections[input_pcoll_id]\n+    context.components.pcollections[pack_pcoll_id].CopyFrom(\n+        beam_runner_api_pb2.PCollection(\n+            unique_name=pack_combine_name + '.out',\n+            coder_id=pack_output_kv_coder_id,\n+            windowing_strategy_id=input_pcoll.windowing_strategy_id,\n+            is_bounded=input_pcoll.is_bounded))\n+\n+    # Set up Pack stage.\n+    pack_combine_fn = combiners.SingleInputTupleCombineFn(*[\n+        core.CombineFn.from_runner_api(combine_payload.combine_fn, context)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MDY3OQ=="}, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMjQzMQ==", "bodyText": "Added check that combine_payload.combine_fn.urn == python_urns.PICKLED_COMBINE_FN before attempting to pack.", "url": "https://github.com/apache/beam/pull/12185#discussion_r465912431", "createdAt": "2020-08-05T18:12:04Z", "author": {"login": "yifanmai"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -685,6 +687,264 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def eliminate_common_siblings(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterable[Stage]\n+  \"\"\"Runs common subexpression elimination for common siblings.\n+\n+  If stages have common input, an identical transform, and one output each,\n+  then all but one stages will be eliminated, and the output of the remaining\n+  will be connected to the original output PCollections of the eliminated\n+  stages. This elimination runs only once, not recursively, and will only\n+  eliminate the first stage after a common input, rather than a chain of\n+  stages.\n+  \"\"\"\n+\n+  SiblingKey = collections.namedtuple(\n+      'SiblingKey', ['spec_urn', 'spec_payload', 'inputs', 'environment_id'])\n+\n+  def get_sibling_key(transform):\n+    \"\"\"Returns a key that will be identical for common siblings.\"\"\"\n+    transform_output_keys = list(transform.outputs.keys())\n+    # Return None as the sibling key for ineligible transforms.\n+    if len(transform_output_keys\n+          ) != 1 or transform.spec.urn != common_urns.primitives.PAR_DO.urn:\n+      return None\n+    return SiblingKey(\n+        spec_urn=transform.spec.urn,\n+        spec_payload=transform.spec.payload,\n+        inputs=tuple(transform.inputs.items()),\n+        environment_id=transform.environment_id)\n+\n+  # Group stages by keys.\n+  stages_by_sibling_key = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    stages_by_sibling_key[get_sibling_key(transform)].append(stage)\n+\n+  # Eliminate stages and build the output PCollection remapping dictionary.\n+  pcoll_id_remap = {}\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    if sibling_key is None or len(sibling_stages) == 1:\n+      continue\n+    output_pcoll_ids = [\n+        only_element(stage.transforms[0].outputs.values())\n+        for stage in sibling_stages\n+    ]\n+    to_delete_pcoll_ids = output_pcoll_ids[1:]\n+    for to_delete_pcoll_id in to_delete_pcoll_ids:\n+      pcoll_id_remap[to_delete_pcoll_id] = output_pcoll_ids[0]\n+      del context.components.pcollections[to_delete_pcoll_id]\n+    del sibling_stages[1:]\n+\n+  # Yield stages while remapping output PCollections if needed.\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    for stage in sibling_stages:\n+      input_keys_to_remap = []\n+      for input_key, input_pcoll_id in stage.transforms[0].inputs.items():\n+        if input_pcoll_id in pcoll_id_remap:\n+          input_keys_to_remap.append(input_key)\n+      for input_key_to_remap in input_keys_to_remap:\n+        stage.transforms[0].inputs[input_key_to_remap] = pcoll_id_remap[\n+            stage.transforms[0].inputs[input_key_to_remap]]\n+      yield stage\n+\n+\n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  def _try_merge_environments(env1, env2):\n+    if env1 is None:\n+      return env2\n+    elif env2 is None:\n+      return env1\n+    else:\n+      if env1 != env2:\n+        raise ValueError\n+      return env1\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(\n+          _try_merge_environments,\n+          [transform.environment_id or None for transform in transforms])\n+    except ValueError:\n+      for stage in packable_stages:\n+        yield stage\n+      continue\n+\n+    output_pcoll_ids = [\n+        only_element(transform.outputs.values()) for transform in transforms\n+    ]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Build accumulator coder for (acc1, acc2, ...)\n+    accumulator_coder_ids = [\n+        combine_payload.accumulator_coder_id\n+        for combine_payload in combine_payloads\n+    ]\n+    tuple_accumulator_coder_id = context.add_or_get_coder_id(\n+        beam_runner_api_pb2.Coder(\n+            spec=beam_runner_api_pb2.FunctionSpec(\n+                urn=common_urns.coders.KV.urn),\n+            component_coder_ids=accumulator_coder_ids))\n+\n+    # Build packed output coder for (key, (out1, out2, ...))\n+    input_kv_coder_id = context.components.pcollections[input_pcoll_id].coder_id\n+    key_coder_id = _get_key_coder_id_from_kv_coder(\n+        context.components.coders[input_kv_coder_id])\n+    output_kv_coder_ids = [\n+        context.components.pcollections[output_pcoll_id].coder_id\n+        for output_pcoll_id in output_pcoll_ids\n+    ]\n+    output_value_coder_ids = [\n+        _get_value_coder_id_from_kv_coder(\n+            context.components.coders[output_kv_coder_id])\n+        for output_kv_coder_id in output_kv_coder_ids\n+    ]\n+    pack_output_value_coder = beam_runner_api_pb2.Coder(\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        component_coder_ids=output_value_coder_ids)\n+    pack_output_value_coder_id = context.add_or_get_coder_id(\n+        pack_output_value_coder)\n+    pack_output_kv_coder = beam_runner_api_pb2.Coder(\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        component_coder_ids=[key_coder_id, pack_output_value_coder_id])\n+    pack_output_kv_coder_id = context.add_or_get_coder_id(pack_output_kv_coder)\n+\n+    # Set up packed PCollection\n+    pack_combine_name = fused_stage.name\n+    pack_pcoll_id = unique_name(context.components.pcollections, 'pcollection')\n+    input_pcoll = context.components.pcollections[input_pcoll_id]\n+    context.components.pcollections[pack_pcoll_id].CopyFrom(\n+        beam_runner_api_pb2.PCollection(\n+            unique_name=pack_combine_name + '.out',\n+            coder_id=pack_output_kv_coder_id,\n+            windowing_strategy_id=input_pcoll.windowing_strategy_id,\n+            is_bounded=input_pcoll.is_bounded))\n+\n+    # Set up Pack stage.\n+    pack_combine_fn = combiners.SingleInputTupleCombineFn(*[\n+        core.CombineFn.from_runner_api(combine_payload.combine_fn, context)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MDY3OQ=="}, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 248}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNjY0ODc4OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxODo1ODo1NFrOGu1ULA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODo0OToxOVrOG-bCQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTE5Ng==", "bodyText": "Similarly, this environment must be a Python environment for this to work.", "url": "https://github.com/apache/beam/pull/12185#discussion_r451761196", "createdAt": "2020-07-08T18:58:54Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -685,6 +687,264 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def eliminate_common_siblings(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterable[Stage]\n+  \"\"\"Runs common subexpression elimination for common siblings.\n+\n+  If stages have common input, an identical transform, and one output each,\n+  then all but one stages will be eliminated, and the output of the remaining\n+  will be connected to the original output PCollections of the eliminated\n+  stages. This elimination runs only once, not recursively, and will only\n+  eliminate the first stage after a common input, rather than a chain of\n+  stages.\n+  \"\"\"\n+\n+  SiblingKey = collections.namedtuple(\n+      'SiblingKey', ['spec_urn', 'spec_payload', 'inputs', 'environment_id'])\n+\n+  def get_sibling_key(transform):\n+    \"\"\"Returns a key that will be identical for common siblings.\"\"\"\n+    transform_output_keys = list(transform.outputs.keys())\n+    # Return None as the sibling key for ineligible transforms.\n+    if len(transform_output_keys\n+          ) != 1 or transform.spec.urn != common_urns.primitives.PAR_DO.urn:\n+      return None\n+    return SiblingKey(\n+        spec_urn=transform.spec.urn,\n+        spec_payload=transform.spec.payload,\n+        inputs=tuple(transform.inputs.items()),\n+        environment_id=transform.environment_id)\n+\n+  # Group stages by keys.\n+  stages_by_sibling_key = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    stages_by_sibling_key[get_sibling_key(transform)].append(stage)\n+\n+  # Eliminate stages and build the output PCollection remapping dictionary.\n+  pcoll_id_remap = {}\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    if sibling_key is None or len(sibling_stages) == 1:\n+      continue\n+    output_pcoll_ids = [\n+        only_element(stage.transforms[0].outputs.values())\n+        for stage in sibling_stages\n+    ]\n+    to_delete_pcoll_ids = output_pcoll_ids[1:]\n+    for to_delete_pcoll_id in to_delete_pcoll_ids:\n+      pcoll_id_remap[to_delete_pcoll_id] = output_pcoll_ids[0]\n+      del context.components.pcollections[to_delete_pcoll_id]\n+    del sibling_stages[1:]\n+\n+  # Yield stages while remapping output PCollections if needed.\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    for stage in sibling_stages:\n+      input_keys_to_remap = []\n+      for input_key, input_pcoll_id in stage.transforms[0].inputs.items():\n+        if input_pcoll_id in pcoll_id_remap:\n+          input_keys_to_remap.append(input_key)\n+      for input_key_to_remap in input_keys_to_remap:\n+        stage.transforms[0].inputs[input_key_to_remap] = pcoll_id_remap[\n+            stage.transforms[0].inputs[input_key_to_remap]]\n+      yield stage\n+\n+\n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  def _try_merge_environments(env1, env2):\n+    if env1 is None:\n+      return env2\n+    elif env2 is None:\n+      return env1\n+    else:\n+      if env1 != env2:\n+        raise ValueError\n+      return env1\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(\n+          _try_merge_environments,\n+          [transform.environment_id or None for transform in transforms])\n+    except ValueError:\n+      for stage in packable_stages:\n+        yield stage\n+      continue\n+\n+    output_pcoll_ids = [\n+        only_element(transform.outputs.values()) for transform in transforms\n+    ]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Build accumulator coder for (acc1, acc2, ...)\n+    accumulator_coder_ids = [\n+        combine_payload.accumulator_coder_id\n+        for combine_payload in combine_payloads\n+    ]\n+    tuple_accumulator_coder_id = context.add_or_get_coder_id(\n+        beam_runner_api_pb2.Coder(\n+            spec=beam_runner_api_pb2.FunctionSpec(\n+                urn=common_urns.coders.KV.urn),\n+            component_coder_ids=accumulator_coder_ids))\n+\n+    # Build packed output coder for (key, (out1, out2, ...))\n+    input_kv_coder_id = context.components.pcollections[input_pcoll_id].coder_id\n+    key_coder_id = _get_key_coder_id_from_kv_coder(\n+        context.components.coders[input_kv_coder_id])\n+    output_kv_coder_ids = [\n+        context.components.pcollections[output_pcoll_id].coder_id\n+        for output_pcoll_id in output_pcoll_ids\n+    ]\n+    output_value_coder_ids = [\n+        _get_value_coder_id_from_kv_coder(\n+            context.components.coders[output_kv_coder_id])\n+        for output_kv_coder_id in output_kv_coder_ids\n+    ]\n+    pack_output_value_coder = beam_runner_api_pb2.Coder(\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        component_coder_ids=output_value_coder_ids)\n+    pack_output_value_coder_id = context.add_or_get_coder_id(\n+        pack_output_value_coder)\n+    pack_output_kv_coder = beam_runner_api_pb2.Coder(\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        component_coder_ids=[key_coder_id, pack_output_value_coder_id])\n+    pack_output_kv_coder_id = context.add_or_get_coder_id(pack_output_kv_coder)\n+\n+    # Set up packed PCollection\n+    pack_combine_name = fused_stage.name\n+    pack_pcoll_id = unique_name(context.components.pcollections, 'pcollection')\n+    input_pcoll = context.components.pcollections[input_pcoll_id]\n+    context.components.pcollections[pack_pcoll_id].CopyFrom(\n+        beam_runner_api_pb2.PCollection(\n+            unique_name=pack_combine_name + '.out',\n+            coder_id=pack_output_kv_coder_id,\n+            windowing_strategy_id=input_pcoll.windowing_strategy_id,\n+            is_bounded=input_pcoll.is_bounded))\n+\n+    # Set up Pack stage.\n+    pack_combine_fn = combiners.SingleInputTupleCombineFn(*[\n+        core.CombineFn.from_runner_api(combine_payload.combine_fn, context)\n+        for combine_payload in combine_payloads\n+    ]).to_runner_api(context)\n+    pack_transform = beam_runner_api_pb2.PTransform(\n+        unique_name=pack_combine_name + '/Pack',\n+        spec=beam_runner_api_pb2.FunctionSpec(\n+            urn=common_urns.composites.COMBINE_PER_KEY.urn,\n+            payload=beam_runner_api_pb2.CombinePayload(\n+                combine_fn=pack_combine_fn,\n+                accumulator_coder_id=tuple_accumulator_coder_id)\n+            .SerializeToString()),\n+        inputs={'in': input_pcoll_id},\n+        outputs={'out': pack_pcoll_id},\n+        environment_id=merged_transform_environment_id)\n+    pack_stage = Stage(\n+        pack_combine_name + '/Pack', [pack_transform],\n+        downstream_side_inputs=fused_stage.downstream_side_inputs,\n+        must_follow=fused_stage.must_follow,\n+        parent=fused_stage,\n+        environment=fused_stage.environment)\n+    yield pack_stage\n+\n+    # Set up Unpack stage\n+    tags = [str(i) for i in range(len(output_pcoll_ids))]\n+    pickled_do_fn_data = pickler.dumps((_UnpackFn(tags), (), {}, [], None))\n+    unpack_transform = beam_runner_api_pb2.PTransform(\n+        unique_name=pack_combine_name + '/Unpack',\n+        spec=beam_runner_api_pb2.FunctionSpec(\n+            urn=common_urns.primitives.PAR_DO.urn,\n+            payload=beam_runner_api_pb2.ParDoPayload(\n+                do_fn=beam_runner_api_pb2.FunctionSpec(\n+                    urn=python_urns.PICKLED_DOFN_INFO,\n+                    payload=pickled_do_fn_data)).SerializeToString()),\n+        inputs={'in': pack_pcoll_id},\n+        outputs=dict(zip(tags, output_pcoll_ids)),\n+        environment_id=merged_transform_environment_id)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNzQ4OA==", "bodyText": "How do I do this? Should I just check that environment_id is None in the original Transforms and Stages?", "url": "https://github.com/apache/beam/pull/12185#discussion_r465917488", "createdAt": "2020-08-05T18:21:37Z", "author": {"login": "yifanmai"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -685,6 +687,264 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def eliminate_common_siblings(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterable[Stage]\n+  \"\"\"Runs common subexpression elimination for common siblings.\n+\n+  If stages have common input, an identical transform, and one output each,\n+  then all but one stages will be eliminated, and the output of the remaining\n+  will be connected to the original output PCollections of the eliminated\n+  stages. This elimination runs only once, not recursively, and will only\n+  eliminate the first stage after a common input, rather than a chain of\n+  stages.\n+  \"\"\"\n+\n+  SiblingKey = collections.namedtuple(\n+      'SiblingKey', ['spec_urn', 'spec_payload', 'inputs', 'environment_id'])\n+\n+  def get_sibling_key(transform):\n+    \"\"\"Returns a key that will be identical for common siblings.\"\"\"\n+    transform_output_keys = list(transform.outputs.keys())\n+    # Return None as the sibling key for ineligible transforms.\n+    if len(transform_output_keys\n+          ) != 1 or transform.spec.urn != common_urns.primitives.PAR_DO.urn:\n+      return None\n+    return SiblingKey(\n+        spec_urn=transform.spec.urn,\n+        spec_payload=transform.spec.payload,\n+        inputs=tuple(transform.inputs.items()),\n+        environment_id=transform.environment_id)\n+\n+  # Group stages by keys.\n+  stages_by_sibling_key = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    stages_by_sibling_key[get_sibling_key(transform)].append(stage)\n+\n+  # Eliminate stages and build the output PCollection remapping dictionary.\n+  pcoll_id_remap = {}\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    if sibling_key is None or len(sibling_stages) == 1:\n+      continue\n+    output_pcoll_ids = [\n+        only_element(stage.transforms[0].outputs.values())\n+        for stage in sibling_stages\n+    ]\n+    to_delete_pcoll_ids = output_pcoll_ids[1:]\n+    for to_delete_pcoll_id in to_delete_pcoll_ids:\n+      pcoll_id_remap[to_delete_pcoll_id] = output_pcoll_ids[0]\n+      del context.components.pcollections[to_delete_pcoll_id]\n+    del sibling_stages[1:]\n+\n+  # Yield stages while remapping output PCollections if needed.\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    for stage in sibling_stages:\n+      input_keys_to_remap = []\n+      for input_key, input_pcoll_id in stage.transforms[0].inputs.items():\n+        if input_pcoll_id in pcoll_id_remap:\n+          input_keys_to_remap.append(input_key)\n+      for input_key_to_remap in input_keys_to_remap:\n+        stage.transforms[0].inputs[input_key_to_remap] = pcoll_id_remap[\n+            stage.transforms[0].inputs[input_key_to_remap]]\n+      yield stage\n+\n+\n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  def _try_merge_environments(env1, env2):\n+    if env1 is None:\n+      return env2\n+    elif env2 is None:\n+      return env1\n+    else:\n+      if env1 != env2:\n+        raise ValueError\n+      return env1\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(\n+          _try_merge_environments,\n+          [transform.environment_id or None for transform in transforms])\n+    except ValueError:\n+      for stage in packable_stages:\n+        yield stage\n+      continue\n+\n+    output_pcoll_ids = [\n+        only_element(transform.outputs.values()) for transform in transforms\n+    ]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Build accumulator coder for (acc1, acc2, ...)\n+    accumulator_coder_ids = [\n+        combine_payload.accumulator_coder_id\n+        for combine_payload in combine_payloads\n+    ]\n+    tuple_accumulator_coder_id = context.add_or_get_coder_id(\n+        beam_runner_api_pb2.Coder(\n+            spec=beam_runner_api_pb2.FunctionSpec(\n+                urn=common_urns.coders.KV.urn),\n+            component_coder_ids=accumulator_coder_ids))\n+\n+    # Build packed output coder for (key, (out1, out2, ...))\n+    input_kv_coder_id = context.components.pcollections[input_pcoll_id].coder_id\n+    key_coder_id = _get_key_coder_id_from_kv_coder(\n+        context.components.coders[input_kv_coder_id])\n+    output_kv_coder_ids = [\n+        context.components.pcollections[output_pcoll_id].coder_id\n+        for output_pcoll_id in output_pcoll_ids\n+    ]\n+    output_value_coder_ids = [\n+        _get_value_coder_id_from_kv_coder(\n+            context.components.coders[output_kv_coder_id])\n+        for output_kv_coder_id in output_kv_coder_ids\n+    ]\n+    pack_output_value_coder = beam_runner_api_pb2.Coder(\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        component_coder_ids=output_value_coder_ids)\n+    pack_output_value_coder_id = context.add_or_get_coder_id(\n+        pack_output_value_coder)\n+    pack_output_kv_coder = beam_runner_api_pb2.Coder(\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        component_coder_ids=[key_coder_id, pack_output_value_coder_id])\n+    pack_output_kv_coder_id = context.add_or_get_coder_id(pack_output_kv_coder)\n+\n+    # Set up packed PCollection\n+    pack_combine_name = fused_stage.name\n+    pack_pcoll_id = unique_name(context.components.pcollections, 'pcollection')\n+    input_pcoll = context.components.pcollections[input_pcoll_id]\n+    context.components.pcollections[pack_pcoll_id].CopyFrom(\n+        beam_runner_api_pb2.PCollection(\n+            unique_name=pack_combine_name + '.out',\n+            coder_id=pack_output_kv_coder_id,\n+            windowing_strategy_id=input_pcoll.windowing_strategy_id,\n+            is_bounded=input_pcoll.is_bounded))\n+\n+    # Set up Pack stage.\n+    pack_combine_fn = combiners.SingleInputTupleCombineFn(*[\n+        core.CombineFn.from_runner_api(combine_payload.combine_fn, context)\n+        for combine_payload in combine_payloads\n+    ]).to_runner_api(context)\n+    pack_transform = beam_runner_api_pb2.PTransform(\n+        unique_name=pack_combine_name + '/Pack',\n+        spec=beam_runner_api_pb2.FunctionSpec(\n+            urn=common_urns.composites.COMBINE_PER_KEY.urn,\n+            payload=beam_runner_api_pb2.CombinePayload(\n+                combine_fn=pack_combine_fn,\n+                accumulator_coder_id=tuple_accumulator_coder_id)\n+            .SerializeToString()),\n+        inputs={'in': input_pcoll_id},\n+        outputs={'out': pack_pcoll_id},\n+        environment_id=merged_transform_environment_id)\n+    pack_stage = Stage(\n+        pack_combine_name + '/Pack', [pack_transform],\n+        downstream_side_inputs=fused_stage.downstream_side_inputs,\n+        must_follow=fused_stage.must_follow,\n+        parent=fused_stage,\n+        environment=fused_stage.environment)\n+    yield pack_stage\n+\n+    # Set up Unpack stage\n+    tags = [str(i) for i in range(len(output_pcoll_ids))]\n+    pickled_do_fn_data = pickler.dumps((_UnpackFn(tags), (), {}, [], None))\n+    unpack_transform = beam_runner_api_pb2.PTransform(\n+        unique_name=pack_combine_name + '/Unpack',\n+        spec=beam_runner_api_pb2.FunctionSpec(\n+            urn=common_urns.primitives.PAR_DO.urn,\n+            payload=beam_runner_api_pb2.ParDoPayload(\n+                do_fn=beam_runner_api_pb2.FunctionSpec(\n+                    urn=python_urns.PICKLED_DOFN_INFO,\n+                    payload=pickled_do_fn_data)).SerializeToString()),\n+        inputs={'in': pack_pcoll_id},\n+        outputs=dict(zip(tags, output_pcoll_ids)),\n+        environment_id=merged_transform_environment_id)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTE5Ng=="}, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNzg0MQ==", "bodyText": "Commented above.", "url": "https://github.com/apache/beam/pull/12185#discussion_r468107841", "createdAt": "2020-08-10T18:49:19Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -685,6 +687,264 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def eliminate_common_siblings(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterable[Stage]\n+  \"\"\"Runs common subexpression elimination for common siblings.\n+\n+  If stages have common input, an identical transform, and one output each,\n+  then all but one stages will be eliminated, and the output of the remaining\n+  will be connected to the original output PCollections of the eliminated\n+  stages. This elimination runs only once, not recursively, and will only\n+  eliminate the first stage after a common input, rather than a chain of\n+  stages.\n+  \"\"\"\n+\n+  SiblingKey = collections.namedtuple(\n+      'SiblingKey', ['spec_urn', 'spec_payload', 'inputs', 'environment_id'])\n+\n+  def get_sibling_key(transform):\n+    \"\"\"Returns a key that will be identical for common siblings.\"\"\"\n+    transform_output_keys = list(transform.outputs.keys())\n+    # Return None as the sibling key for ineligible transforms.\n+    if len(transform_output_keys\n+          ) != 1 or transform.spec.urn != common_urns.primitives.PAR_DO.urn:\n+      return None\n+    return SiblingKey(\n+        spec_urn=transform.spec.urn,\n+        spec_payload=transform.spec.payload,\n+        inputs=tuple(transform.inputs.items()),\n+        environment_id=transform.environment_id)\n+\n+  # Group stages by keys.\n+  stages_by_sibling_key = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    stages_by_sibling_key[get_sibling_key(transform)].append(stage)\n+\n+  # Eliminate stages and build the output PCollection remapping dictionary.\n+  pcoll_id_remap = {}\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    if sibling_key is None or len(sibling_stages) == 1:\n+      continue\n+    output_pcoll_ids = [\n+        only_element(stage.transforms[0].outputs.values())\n+        for stage in sibling_stages\n+    ]\n+    to_delete_pcoll_ids = output_pcoll_ids[1:]\n+    for to_delete_pcoll_id in to_delete_pcoll_ids:\n+      pcoll_id_remap[to_delete_pcoll_id] = output_pcoll_ids[0]\n+      del context.components.pcollections[to_delete_pcoll_id]\n+    del sibling_stages[1:]\n+\n+  # Yield stages while remapping output PCollections if needed.\n+  for sibling_key, sibling_stages in stages_by_sibling_key.items():\n+    for stage in sibling_stages:\n+      input_keys_to_remap = []\n+      for input_key, input_pcoll_id in stage.transforms[0].inputs.items():\n+        if input_pcoll_id in pcoll_id_remap:\n+          input_keys_to_remap.append(input_key)\n+      for input_key_to_remap in input_keys_to_remap:\n+        stage.transforms[0].inputs[input_key_to_remap] = pcoll_id_remap[\n+            stage.transforms[0].inputs[input_key_to_remap]]\n+      yield stage\n+\n+\n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  def _try_merge_environments(env1, env2):\n+    if env1 is None:\n+      return env2\n+    elif env2 is None:\n+      return env1\n+    else:\n+      if env1 != env2:\n+        raise ValueError\n+      return env1\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(\n+          _try_merge_environments,\n+          [transform.environment_id or None for transform in transforms])\n+    except ValueError:\n+      for stage in packable_stages:\n+        yield stage\n+      continue\n+\n+    output_pcoll_ids = [\n+        only_element(transform.outputs.values()) for transform in transforms\n+    ]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Build accumulator coder for (acc1, acc2, ...)\n+    accumulator_coder_ids = [\n+        combine_payload.accumulator_coder_id\n+        for combine_payload in combine_payloads\n+    ]\n+    tuple_accumulator_coder_id = context.add_or_get_coder_id(\n+        beam_runner_api_pb2.Coder(\n+            spec=beam_runner_api_pb2.FunctionSpec(\n+                urn=common_urns.coders.KV.urn),\n+            component_coder_ids=accumulator_coder_ids))\n+\n+    # Build packed output coder for (key, (out1, out2, ...))\n+    input_kv_coder_id = context.components.pcollections[input_pcoll_id].coder_id\n+    key_coder_id = _get_key_coder_id_from_kv_coder(\n+        context.components.coders[input_kv_coder_id])\n+    output_kv_coder_ids = [\n+        context.components.pcollections[output_pcoll_id].coder_id\n+        for output_pcoll_id in output_pcoll_ids\n+    ]\n+    output_value_coder_ids = [\n+        _get_value_coder_id_from_kv_coder(\n+            context.components.coders[output_kv_coder_id])\n+        for output_kv_coder_id in output_kv_coder_ids\n+    ]\n+    pack_output_value_coder = beam_runner_api_pb2.Coder(\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        component_coder_ids=output_value_coder_ids)\n+    pack_output_value_coder_id = context.add_or_get_coder_id(\n+        pack_output_value_coder)\n+    pack_output_kv_coder = beam_runner_api_pb2.Coder(\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        component_coder_ids=[key_coder_id, pack_output_value_coder_id])\n+    pack_output_kv_coder_id = context.add_or_get_coder_id(pack_output_kv_coder)\n+\n+    # Set up packed PCollection\n+    pack_combine_name = fused_stage.name\n+    pack_pcoll_id = unique_name(context.components.pcollections, 'pcollection')\n+    input_pcoll = context.components.pcollections[input_pcoll_id]\n+    context.components.pcollections[pack_pcoll_id].CopyFrom(\n+        beam_runner_api_pb2.PCollection(\n+            unique_name=pack_combine_name + '.out',\n+            coder_id=pack_output_kv_coder_id,\n+            windowing_strategy_id=input_pcoll.windowing_strategy_id,\n+            is_bounded=input_pcoll.is_bounded))\n+\n+    # Set up Pack stage.\n+    pack_combine_fn = combiners.SingleInputTupleCombineFn(*[\n+        core.CombineFn.from_runner_api(combine_payload.combine_fn, context)\n+        for combine_payload in combine_payloads\n+    ]).to_runner_api(context)\n+    pack_transform = beam_runner_api_pb2.PTransform(\n+        unique_name=pack_combine_name + '/Pack',\n+        spec=beam_runner_api_pb2.FunctionSpec(\n+            urn=common_urns.composites.COMBINE_PER_KEY.urn,\n+            payload=beam_runner_api_pb2.CombinePayload(\n+                combine_fn=pack_combine_fn,\n+                accumulator_coder_id=tuple_accumulator_coder_id)\n+            .SerializeToString()),\n+        inputs={'in': input_pcoll_id},\n+        outputs={'out': pack_pcoll_id},\n+        environment_id=merged_transform_environment_id)\n+    pack_stage = Stage(\n+        pack_combine_name + '/Pack', [pack_transform],\n+        downstream_side_inputs=fused_stage.downstream_side_inputs,\n+        must_follow=fused_stage.must_follow,\n+        parent=fused_stage,\n+        environment=fused_stage.environment)\n+    yield pack_stage\n+\n+    # Set up Unpack stage\n+    tags = [str(i) for i in range(len(output_pcoll_ids))]\n+    pickled_do_fn_data = pickler.dumps((_UnpackFn(tags), (), {}, [], None))\n+    unpack_transform = beam_runner_api_pb2.PTransform(\n+        unique_name=pack_combine_name + '/Unpack',\n+        spec=beam_runner_api_pb2.FunctionSpec(\n+            urn=common_urns.primitives.PAR_DO.urn,\n+            payload=beam_runner_api_pb2.ParDoPayload(\n+                do_fn=beam_runner_api_pb2.FunctionSpec(\n+                    urn=python_urns.PICKLED_DOFN_INFO,\n+                    payload=pickled_do_fn_data)).SerializeToString()),\n+        inputs={'in': pack_pcoll_id},\n+        outputs=dict(zip(tags, output_pcoll_ids)),\n+        environment_id=merged_transform_environment_id)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTE5Ng=="}, "originalCommit": {"oid": "4ee39657810cd184377268da9a73dadc6f5549bf"}, "originalPosition": 283}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDYwNDc1OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODozNDozN1rOG-ajog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMzo1Mzo0NlrOHAhdPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwMDAwMg==", "bodyText": "We need to group and filter on the environment of the transform as well, lest we try to pack Java or Go combiners here.\nThe easiest way to do that would be to add a \"beam:combinefn:packed_python:v1\" URN at https://github.com/apache/beam/blob/master/sdks/python/apache_beam/portability/python_urns.py , inject it into the list at https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/environments.py#L587 , and then here you can look up the environment attached to the transform, and whether that URN shows up in its capabilities, so see if this is OK.\nI'd be glad to explain more if this doesn't make sense.", "url": "https://github.com/apache/beam/pull/12185#discussion_r468100002", "createdAt": "2020-08-10T18:34:37Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,196 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNDQzNQ==", "bodyText": "Oh, I see you are checking for PICKLED_COMBINE_FN below. We should keep this, but the reason it may be insufficient is that one might use PICKLED_COMBINE_FN across different environments. (People using Python 2 transforms of an old version of Beam in Python 3 pipelines is an actual scenario that may come up soon as we're dropping Python 2 support.)", "url": "https://github.com/apache/beam/pull/12185#discussion_r468104435", "createdAt": "2020-08-10T18:42:49Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,196 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwMDAwMg=="}, "originalCommit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMwOTkyMg==", "bodyText": "OK. Keeping the check, but moving it further up.", "url": "https://github.com/apache/beam/pull/12185#discussion_r470309922", "createdAt": "2020-08-13T23:52:43Z", "author": {"login": "yifanmai"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,196 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwMDAwMg=="}, "originalCommit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMxMDIwNw==", "bodyText": "Also added a new test to make sure that we don't run combiner packing without the capability.", "url": "https://github.com/apache/beam/pull/12185#discussion_r470310207", "createdAt": "2020-08-13T23:53:46Z", "author": {"login": "yifanmai"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,196 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwMDAwMg=="}, "originalCommit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDYxNzQyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODozODoxOVrOG-ardA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMzo1MjoyOFrOHAhbwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwMjAwNA==", "bodyText": "Can't we pull this off of the fused_stage?", "url": "https://github.com/apache/beam/pull/12185#discussion_r468102004", "createdAt": "2020-08-10T18:38:19Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,196 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMwOTgyNg==", "bodyText": "OK, I'm now using the fused_stage environment everywhere.", "url": "https://github.com/apache/beam/pull/12185#discussion_r470309826", "createdAt": "2020-08-13T23:52:28Z", "author": {"login": "yifanmai"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,196 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwMjAwNA=="}, "originalCommit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDY1Mzg0OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODo0ODo0NFrOG-bBEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMzo1MjowOVrOHAhbXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNzUzNg==", "bodyText": "OK, so this continue breaks goes back to the next set of packable stages. Just a suggestion: it might be easier to follow if you did all the checking of whether it's OK (e.g. can_fuse, the payload type) above when building these lists, rather than here.", "url": "https://github.com/apache/beam/pull/12185#discussion_r468107536", "createdAt": "2020-08-10T18:48:44Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,196 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(\n+          Stage._merge_environments,\n+          [transform.environment_id or None for transform in transforms])\n+      # Combiner packing only supports Python CombineFns.\n+      for combine_payload in combine_payloads:\n+        if combine_payload.combine_fn.urn != python_urns.PICKLED_COMBINE_FN:\n+          raise ValueError('Combiner packing only supports Python CombineFns')\n+    except ValueError:\n+      for stage in packable_stages:\n+        yield stage\n+      continue", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMwOTcyNQ==", "bodyText": "Moved most of the checks to the earlier part, and cleaned up the logic for this part (which we still need, because we need to make sure the whole group is fuseable).", "url": "https://github.com/apache/beam/pull/12185#discussion_r470309725", "createdAt": "2020-08-13T23:52:09Z", "author": {"login": "yifanmai"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,196 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(\n+          Stage._merge_environments,\n+          [transform.environment_id or None for transform in transforms])\n+      # Combiner packing only supports Python CombineFns.\n+      for combine_payload in combine_payloads:\n+        if combine_payload.combine_fn.urn != python_urns.PICKLED_COMBINE_FN:\n+          raise ValueError('Combiner packing only supports Python CombineFns')\n+    except ValueError:\n+      for stage in packable_stages:\n+        yield stage\n+      continue", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNzUzNg=="}, "originalCommit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDY2NzYzOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODo1Mjo0MlrOG-bJiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMDoyNDo1MlrOHESDiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwOTcwNQ==", "bodyText": "KV?", "url": "https://github.com/apache/beam/pull/12185#discussion_r468109705", "createdAt": "2020-08-10T18:52:42Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,196 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(\n+          Stage._merge_environments,\n+          [transform.environment_id or None for transform in transforms])\n+      # Combiner packing only supports Python CombineFns.\n+      for combine_payload in combine_payloads:\n+        if combine_payload.combine_fn.urn != python_urns.PICKLED_COMBINE_FN:\n+          raise ValueError('Combiner packing only supports Python CombineFns')\n+    except ValueError:\n+      for stage in packable_stages:\n+        yield stage\n+      continue\n+\n+    output_pcoll_ids = [\n+        only_element(transform.outputs.values()) for transform in transforms\n+    ]\n+\n+    # Build accumulator coder for (acc1, acc2, ...)\n+    accumulator_coder_ids = [\n+        combine_payload.accumulator_coder_id\n+        for combine_payload in combine_payloads\n+    ]\n+    tuple_accumulator_coder_id = context.add_or_get_coder_id(\n+        beam_runner_api_pb2.Coder(\n+            spec=beam_runner_api_pb2.FunctionSpec(\n+                urn=common_urns.coders.KV.urn),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMxMDA0MQ==", "bodyText": "I didn't understand this comment; could you clarify?", "url": "https://github.com/apache/beam/pull/12185#discussion_r470310041", "createdAt": "2020-08-13T23:53:11Z", "author": {"login": "yifanmai"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,196 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(\n+          Stage._merge_environments,\n+          [transform.environment_id or None for transform in transforms])\n+      # Combiner packing only supports Python CombineFns.\n+      for combine_payload in combine_payloads:\n+        if combine_payload.combine_fn.urn != python_urns.PICKLED_COMBINE_FN:\n+          raise ValueError('Combiner packing only supports Python CombineFns')\n+    except ValueError:\n+      for stage in packable_stages:\n+        yield stage\n+      continue\n+\n+    output_pcoll_ids = [\n+        only_element(transform.outputs.values()) for transform in transforms\n+    ]\n+\n+    # Build accumulator coder for (acc1, acc2, ...)\n+    accumulator_coder_ids = [\n+        combine_payload.accumulator_coder_id\n+        for combine_payload in combine_payloads\n+    ]\n+    tuple_accumulator_coder_id = context.add_or_get_coder_id(\n+        beam_runner_api_pb2.Coder(\n+            spec=beam_runner_api_pb2.FunctionSpec(\n+                urn=common_urns.coders.KV.urn),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwOTcwNQ=="}, "originalCommit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkzNjQ5NQ==", "bodyText": "Technically, a KV coder can only have two components. You may have to make an actual Tuple coder here with a new (again, feel free to do Python-only for now) URN.\nYou should be able to add another Coder.register_urn decorator to https://github.com/apache/beam/blob/release-2.23.0/sdks/python/apache_beam/coders/coders.py#L1029 and it'll just work.", "url": "https://github.com/apache/beam/pull/12185#discussion_r470936495", "createdAt": "2020-08-15T04:32:15Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,196 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(\n+          Stage._merge_environments,\n+          [transform.environment_id or None for transform in transforms])\n+      # Combiner packing only supports Python CombineFns.\n+      for combine_payload in combine_payloads:\n+        if combine_payload.combine_fn.urn != python_urns.PICKLED_COMBINE_FN:\n+          raise ValueError('Combiner packing only supports Python CombineFns')\n+    except ValueError:\n+      for stage in packable_stages:\n+        yield stage\n+      continue\n+\n+    output_pcoll_ids = [\n+        only_element(transform.outputs.values()) for transform in transforms\n+    ]\n+\n+    # Build accumulator coder for (acc1, acc2, ...)\n+    accumulator_coder_ids = [\n+        combine_payload.accumulator_coder_id\n+        for combine_payload in combine_payloads\n+    ]\n+    tuple_accumulator_coder_id = context.add_or_get_coder_id(\n+        beam_runner_api_pb2.Coder(\n+            spec=beam_runner_api_pb2.FunctionSpec(\n+                urn=common_urns.coders.KV.urn),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwOTcwNQ=="}, "originalCommit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI1MjE2OQ==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/12185#discussion_r474252169", "createdAt": "2020-08-20T20:24:52Z", "author": {"login": "yifanmai"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,196 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    transform = only_transform(stage.transforms)\n+    if transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and len(\n+        transform.inputs) == 1 and len(transform.outputs) == 1:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)\n+    else:\n+      yield stage\n+\n+  for input_pcoll_id, packable_stages in combine_stages_by_input_pcoll_id.items(\n+  ):\n+    # Yield stage and continue if it has no siblings.\n+    if len(packable_stages) == 1:\n+      yield packable_stages[0]\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+\n+    # Yield stages and continue if they cannot be packed.\n+    try:\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+      merged_transform_environment_id = functools.reduce(\n+          Stage._merge_environments,\n+          [transform.environment_id or None for transform in transforms])\n+      # Combiner packing only supports Python CombineFns.\n+      for combine_payload in combine_payloads:\n+        if combine_payload.combine_fn.urn != python_urns.PICKLED_COMBINE_FN:\n+          raise ValueError('Combiner packing only supports Python CombineFns')\n+    except ValueError:\n+      for stage in packable_stages:\n+        yield stage\n+      continue\n+\n+    output_pcoll_ids = [\n+        only_element(transform.outputs.values()) for transform in transforms\n+    ]\n+\n+    # Build accumulator coder for (acc1, acc2, ...)\n+    accumulator_coder_ids = [\n+        combine_payload.accumulator_coder_id\n+        for combine_payload in combine_payloads\n+    ]\n+    tuple_accumulator_coder_id = context.add_or_get_coder_id(\n+        beam_runner_api_pb2.Coder(\n+            spec=beam_runner_api_pb2.FunctionSpec(\n+                urn=common_urns.coders.KV.urn),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwOTcwNQ=="}, "originalCommit": {"oid": "734ce02a824ee44aab69f11484575c013a1faf9d"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Mjk5MjQ3OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwNDoyNTo0NlrOHBHqAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMDozMjo1M1rOHESSvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkzNjA2Ng==", "bodyText": "Perhaps key by environment and input pcollection (to not even attempt to fuse across environments).", "url": "https://github.com/apache/beam/pull/12185#discussion_r470936066", "createdAt": "2020-08-15T04:25:46Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,199 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    is_packable_combine = False\n+\n+    if (len(stage.transforms) == 1 and \n+        stage.environment is not None and\n+        python_urns.PACKED_COMBINE_FN in\n+        context.components.environments[stage.environment].capabilities):\n+      transform = only_transform(stage.transforms)\n+      if (transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and\n+          len(transform.inputs) == 1 and\n+          len(transform.outputs) == 1):\n+        combine_payload = proto_utils.parse_Bytes(\n+            transform.spec.payload, beam_runner_api_pb2.CombinePayload)\n+        if combine_payload.combine_fn.urn == python_urns.PICKLED_COMBINE_FN:\n+          is_packable_combine = True\n+\n+    if is_packable_combine:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a65c0c4afa7b792fde3e256b7337e4003e6b84c"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI1NjA2Mw==", "bodyText": "OK, we key by environment now.", "url": "https://github.com/apache/beam/pull/12185#discussion_r474256063", "createdAt": "2020-08-20T20:32:53Z", "author": {"login": "yifanmai"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,199 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    is_packable_combine = False\n+\n+    if (len(stage.transforms) == 1 and \n+        stage.environment is not None and\n+        python_urns.PACKED_COMBINE_FN in\n+        context.components.environments[stage.environment].capabilities):\n+      transform = only_transform(stage.transforms)\n+      if (transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and\n+          len(transform.inputs) == 1 and\n+          len(transform.outputs) == 1):\n+        combine_payload = proto_utils.parse_Bytes(\n+            transform.spec.payload, beam_runner_api_pb2.CombinePayload)\n+        if combine_payload.combine_fn.urn == python_urns.PICKLED_COMBINE_FN:\n+          is_packable_combine = True\n+\n+    if is_packable_combine:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      combine_stages_by_input_pcoll_id[input_pcoll_id].append(stage)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkzNjA2Ng=="}, "originalCommit": {"oid": "4a65c0c4afa7b792fde3e256b7337e4003e6b84c"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MDI4MDU3OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxOTo1Njo1NlrOHGnjeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxODozNDo1NFrOHHYp9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcwMTU2MQ==", "bodyText": "Shouldn't this be python_urns.TUPLE_CODER?", "url": "https://github.com/apache/beam/pull/12185#discussion_r476701561", "createdAt": "2020-08-25T19:56:56Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -818,7 +819,7 @@ def _try_fuse_stages(a, b):\n         for output_kv_coder_id in output_kv_coder_ids\n     ]\n     pack_output_value_coder = beam_runner_api_pb2.Coder(\n-        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=python_urns.tuple.KV.urn),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff2d4a3983d94ba42afd5b3a6a37549ec293646a"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwNjAzNg==", "bodyText": "Thanks for catching that. Fixed.", "url": "https://github.com/apache/beam/pull/12185#discussion_r477506036", "createdAt": "2020-08-26T18:34:54Z", "author": {"login": "yifanmai"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -818,7 +819,7 @@ def _try_fuse_stages(a, b):\n         for output_kv_coder_id in output_kv_coder_ids\n     ]\n     pack_output_value_coder = beam_runner_api_pb2.Coder(\n-        spec=beam_runner_api_pb2.FunctionSpec(urn=common_urns.coders.KV.urn),\n+        spec=beam_runner_api_pb2.FunctionSpec(urn=python_urns.tuple.KV.urn),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcwMTU2MQ=="}, "originalCommit": {"oid": "ff2d4a3983d94ba42afd5b3a6a37549ec293646a"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MDI4ODM4OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxOTo1OTowNlrOHGnoQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxODozNDo1OVrOHHYqNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcwMjc4NQ==", "bodyText": "Now use python_urns.TUPLE_CODER here rather than the KV one.", "url": "https://github.com/apache/beam/pull/12185#discussion_r476702785", "createdAt": "2020-08-25T19:59:06Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,200 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent and environment, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    is_packable_combine = False\n+\n+    if (len(stage.transforms) == 1 and\n+        stage.environment is not None and\n+        python_urns.PACKED_COMBINE_FN in\n+        context.components.environments[stage.environment].capabilities):\n+      transform = only_transform(stage.transforms)\n+      if (transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and\n+          len(transform.inputs) == 1 and\n+          len(transform.outputs) == 1):\n+        combine_payload = proto_utils.parse_Bytes(\n+            transform.spec.payload, beam_runner_api_pb2.CombinePayload)\n+        if combine_payload.combine_fn.urn == python_urns.PICKLED_COMBINE_FN:\n+          is_packable_combine = True\n+\n+    if is_packable_combine:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      stage_key = (input_pcoll_id, stage.environment)\n+      combine_stages_by_input_pcoll_id[stage_key].append(stage)\n+    else:\n+      yield stage\n+\n+  for stage_key, packable_stages in combine_stages_by_input_pcoll_id.items():\n+    input_pcoll_id, _ = stage_key\n+    try:\n+      if not len(packable_stages) > 1:\n+        raise ValueError('Only one stage in this group: Skipping stage packing')\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+    except ValueError:\n+      # Skip packing stages in this group.\n+      # Yield the stages unmodified, and then continue to the next group.\n+      for stage in packable_stages:\n+        yield stage\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+    output_pcoll_ids = [\n+        only_element(transform.outputs.values()) for transform in transforms\n+    ]\n+\n+    # Build accumulator coder for (acc1, acc2, ...)\n+    accumulator_coder_ids = [\n+        combine_payload.accumulator_coder_id\n+        for combine_payload in combine_payloads\n+    ]\n+    tuple_accumulator_coder_id = context.add_or_get_coder_id(\n+        beam_runner_api_pb2.Coder(\n+            spec=beam_runner_api_pb2.FunctionSpec(\n+                urn=common_urns.coders.KV.urn),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff2d4a3983d94ba42afd5b3a6a37549ec293646a"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwNjEwMA==", "bodyText": "Fixed.", "url": "https://github.com/apache/beam/pull/12185#discussion_r477506100", "createdAt": "2020-08-26T18:34:59Z", "author": {"login": "yifanmai"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -690,6 +692,200 @@ def fix_side_input_pcoll_coders(stages, pipeline_context):\n   return stages\n \n \n+def pack_combiners(stages, context):\n+  # type: (Iterable[Stage], TransformContext) -> Iterator[Stage]\n+  \"\"\"Packs sibling CombinePerKey stages into a single CombinePerKey.\n+\n+  If CombinePerKey stages have a common input, one input each, and one output\n+  each, pack the stages into a single stage that runs all CombinePerKeys and\n+  outputs resulting tuples to a new PCollection. A subsequent stage unpacks\n+  tuples from this PCollection and sends them to the original output\n+  PCollections.\n+  \"\"\"\n+\n+  class _UnpackFn(core.DoFn):\n+    \"\"\"A DoFn that unpacks a packed to multiple tagged outputs.\n+\n+    Example:\n+      tags = (T1, T2, ...)\n+      input = (K, (V1, V2, ...))\n+      output = TaggedOutput(T1, (K, V1)), TaggedOutput(T2, (K, V1)), ...\n+    \"\"\"\n+\n+    def __init__(self, tags):\n+      self._tags = tags\n+\n+    def process(self, element):\n+      key, values = element\n+      return [\n+          core.pvalue.TaggedOutput(tag, (key, value))\n+          for tag, value in zip(self._tags, values)\n+      ]\n+\n+  def _get_fallback_coder_id():\n+    return context.add_or_get_coder_id(\n+        coders.registry.get_coder(object).to_runner_api(None))\n+\n+  def _get_component_coder_id_from_kv_coder(coder, index):\n+    assert index < 2\n+    if coder.spec.urn == common_urns.coders.KV.urn and len(\n+        coder.component_coder_ids) == 2:\n+      return coder.component_coder_ids[index]\n+    return _get_fallback_coder_id()\n+\n+  def _get_key_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 0)\n+\n+  def _get_value_coder_id_from_kv_coder(coder):\n+    return _get_component_coder_id_from_kv_coder(coder, 1)\n+\n+  def _try_fuse_stages(a, b):\n+    if a.can_fuse(b, context):\n+      return a.fuse(b)\n+    else:\n+      raise ValueError\n+\n+  # Group stages by parent and environment, yielding ineligible stages.\n+  combine_stages_by_input_pcoll_id = collections.defaultdict(list)\n+  for stage in stages:\n+    is_packable_combine = False\n+\n+    if (len(stage.transforms) == 1 and\n+        stage.environment is not None and\n+        python_urns.PACKED_COMBINE_FN in\n+        context.components.environments[stage.environment].capabilities):\n+      transform = only_transform(stage.transforms)\n+      if (transform.spec.urn == common_urns.composites.COMBINE_PER_KEY.urn and\n+          len(transform.inputs) == 1 and\n+          len(transform.outputs) == 1):\n+        combine_payload = proto_utils.parse_Bytes(\n+            transform.spec.payload, beam_runner_api_pb2.CombinePayload)\n+        if combine_payload.combine_fn.urn == python_urns.PICKLED_COMBINE_FN:\n+          is_packable_combine = True\n+\n+    if is_packable_combine:\n+      input_pcoll_id = only_element(transform.inputs.values())\n+      stage_key = (input_pcoll_id, stage.environment)\n+      combine_stages_by_input_pcoll_id[stage_key].append(stage)\n+    else:\n+      yield stage\n+\n+  for stage_key, packable_stages in combine_stages_by_input_pcoll_id.items():\n+    input_pcoll_id, _ = stage_key\n+    try:\n+      if not len(packable_stages) > 1:\n+        raise ValueError('Only one stage in this group: Skipping stage packing')\n+      # Fused stage is used as template and is not yielded.\n+      fused_stage = functools.reduce(_try_fuse_stages, packable_stages)\n+    except ValueError:\n+      # Skip packing stages in this group.\n+      # Yield the stages unmodified, and then continue to the next group.\n+      for stage in packable_stages:\n+        yield stage\n+      continue\n+\n+    transforms = [only_transform(stage.transforms) for stage in packable_stages]\n+    combine_payloads = [\n+        proto_utils.parse_Bytes(transform.spec.payload,\n+                                beam_runner_api_pb2.CombinePayload)\n+        for transform in transforms\n+    ]\n+    output_pcoll_ids = [\n+        only_element(transform.outputs.values()) for transform in transforms\n+    ]\n+\n+    # Build accumulator coder for (acc1, acc2, ...)\n+    accumulator_coder_ids = [\n+        combine_payload.accumulator_coder_id\n+        for combine_payload in combine_payloads\n+    ]\n+    tuple_accumulator_coder_id = context.add_or_get_coder_id(\n+        beam_runner_api_pb2.Coder(\n+            spec=beam_runner_api_pb2.FunctionSpec(\n+                urn=common_urns.coders.KV.urn),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcwMjc4NQ=="}, "originalCommit": {"oid": "ff2d4a3983d94ba42afd5b3a6a37549ec293646a"}, "originalPosition": 145}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3493, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}