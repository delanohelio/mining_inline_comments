{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUwNzIyODg5", "number": 12292, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNDowODo0MlrOEPY2ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNTo1OTo1M1rOEQ5pUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTcxMzMxOnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNDowODo0MlrOGzErfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODoxMjo0OFrOGzcnBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIwNzIzMQ==", "bodyText": "How about just check val == Double.POSITIVE_INFINITY here? (similar below)", "url": "https://github.com/apache/beam/pull/12292#discussion_r456207231", "createdAt": "2020-07-17T04:08:42Z", "author": {"login": "robinyqiu"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -786,15 +786,39 @@ private RexNode convertSimpleValueToRexNode(TypeKind kind, Value value) {\n                     ZetaSqlCalciteTranslationUtils.toSimpleRelDataType(kind, rexBuilder()));\n         break;\n       case TYPE_DOUBLE:\n+        // Cannot simply call makeApproxLiteral() for ZetaSQL DOUBLE type because positive infinity,\n+        // negative infinity and Nan cannot be directly converted to BigDecimal. So we create three\n+        // wrapper functions here for these three cases such that we can later recognize it and\n+        // customize its unparsing in BeamBigQuerySqlDialect.\n         double val = value.getDoubleValue();\n-        if (Double.isInfinite(val) || Double.isNaN(val)) {\n-          throw new UnsupportedOperationException(\"Does not support Infinite or NaN literals.\");\n+        if (Double.isInfinite(val) && val > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4ea922d4a9dff9f945af491048e2d2658bde950"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5OTMwMw==", "bodyText": "Thanks. Done.", "url": "https://github.com/apache/beam/pull/12292#discussion_r456599303", "createdAt": "2020-07-17T18:12:48Z", "author": {"login": "ZijieSong946"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -786,15 +786,39 @@ private RexNode convertSimpleValueToRexNode(TypeKind kind, Value value) {\n                     ZetaSqlCalciteTranslationUtils.toSimpleRelDataType(kind, rexBuilder()));\n         break;\n       case TYPE_DOUBLE:\n+        // Cannot simply call makeApproxLiteral() for ZetaSQL DOUBLE type because positive infinity,\n+        // negative infinity and Nan cannot be directly converted to BigDecimal. So we create three\n+        // wrapper functions here for these three cases such that we can later recognize it and\n+        // customize its unparsing in BeamBigQuerySqlDialect.\n         double val = value.getDoubleValue();\n-        if (Double.isInfinite(val) || Double.isNaN(val)) {\n-          throw new UnsupportedOperationException(\"Does not support Infinite or NaN literals.\");\n+        if (Double.isInfinite(val) && val > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIwNzIzMQ=="}, "originalCommit": {"oid": "b4ea922d4a9dff9f945af491048e2d2658bde950"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTcxODIxOnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNDoxMjowNlrOGzEucg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODoxMjo1OFrOGzcnVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIwNzk4Ng==", "bodyText": "I could create 2 local parameters: String wrapperFun (null for the last case) and RelDataType returnType to simplify this big if-else block.", "url": "https://github.com/apache/beam/pull/12292#discussion_r456207986", "createdAt": "2020-07-17T04:12:06Z", "author": {"login": "robinyqiu"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -786,15 +786,39 @@ private RexNode convertSimpleValueToRexNode(TypeKind kind, Value value) {\n                     ZetaSqlCalciteTranslationUtils.toSimpleRelDataType(kind, rexBuilder()));\n         break;\n       case TYPE_DOUBLE:\n+        // Cannot simply call makeApproxLiteral() for ZetaSQL DOUBLE type because positive infinity,\n+        // negative infinity and Nan cannot be directly converted to BigDecimal. So we create three\n+        // wrapper functions here for these three cases such that we can later recognize it and\n+        // customize its unparsing in BeamBigQuerySqlDialect.\n         double val = value.getDoubleValue();\n-        if (Double.isInfinite(val) || Double.isNaN(val)) {\n-          throw new UnsupportedOperationException(\"Does not support Infinite or NaN literals.\");\n+        if (Double.isInfinite(val) && val > 0) {\n+          ret =\n+              rexBuilder()\n+                  .makeCall(\n+                      SqlOperators.createOtherKindSqlFunction(\n+                          BeamBigQuerySqlDialect.DOUBLE_POSITIVE_INF_FUNCTION,\n+                          ZetaSqlCalciteTranslationUtils.toCalciteTypeName(kind)));\n+        } else if (Double.isInfinite(val) && val < 0) {\n+          ret =\n+              rexBuilder()\n+                  .makeCall(\n+                      SqlOperators.createOtherKindSqlFunction(\n+                          BeamBigQuerySqlDialect.DOUBLE_NEGATIVE_INF_FUNCTION,\n+                          ZetaSqlCalciteTranslationUtils.toCalciteTypeName(kind)));\n+        } else if (Double.isNaN(val)) {\n+          ret =\n+              rexBuilder()\n+                  .makeCall(\n+                      SqlOperators.createOtherKindSqlFunction(\n+                          BeamBigQuerySqlDialect.DOUBLE_NAN_FUNCTION,\n+                          ZetaSqlCalciteTranslationUtils.toCalciteTypeName(kind)));\n+        } else {\n+          ret =\n+              rexBuilder()\n+                  .makeApproxLiteral(\n+                      new BigDecimal(val),\n+                      ZetaSqlCalciteTranslationUtils.toSimpleRelDataType(kind, rexBuilder()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4ea922d4a9dff9f945af491048e2d2658bde950"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU0NTg0MQ==", "bodyText": "I am not quiet sure how to merge the first three blocks with the last one, because the first three use resBuilder().makeCall() while the last one uses rexBuilder().makeApproxLiteral(). Also, returnType seems can only be used in the last block.", "url": "https://github.com/apache/beam/pull/12292#discussion_r456545841", "createdAt": "2020-07-17T16:25:55Z", "author": {"login": "ZijieSong946"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -786,15 +786,39 @@ private RexNode convertSimpleValueToRexNode(TypeKind kind, Value value) {\n                     ZetaSqlCalciteTranslationUtils.toSimpleRelDataType(kind, rexBuilder()));\n         break;\n       case TYPE_DOUBLE:\n+        // Cannot simply call makeApproxLiteral() for ZetaSQL DOUBLE type because positive infinity,\n+        // negative infinity and Nan cannot be directly converted to BigDecimal. So we create three\n+        // wrapper functions here for these three cases such that we can later recognize it and\n+        // customize its unparsing in BeamBigQuerySqlDialect.\n         double val = value.getDoubleValue();\n-        if (Double.isInfinite(val) || Double.isNaN(val)) {\n-          throw new UnsupportedOperationException(\"Does not support Infinite or NaN literals.\");\n+        if (Double.isInfinite(val) && val > 0) {\n+          ret =\n+              rexBuilder()\n+                  .makeCall(\n+                      SqlOperators.createOtherKindSqlFunction(\n+                          BeamBigQuerySqlDialect.DOUBLE_POSITIVE_INF_FUNCTION,\n+                          ZetaSqlCalciteTranslationUtils.toCalciteTypeName(kind)));\n+        } else if (Double.isInfinite(val) && val < 0) {\n+          ret =\n+              rexBuilder()\n+                  .makeCall(\n+                      SqlOperators.createOtherKindSqlFunction(\n+                          BeamBigQuerySqlDialect.DOUBLE_NEGATIVE_INF_FUNCTION,\n+                          ZetaSqlCalciteTranslationUtils.toCalciteTypeName(kind)));\n+        } else if (Double.isNaN(val)) {\n+          ret =\n+              rexBuilder()\n+                  .makeCall(\n+                      SqlOperators.createOtherKindSqlFunction(\n+                          BeamBigQuerySqlDialect.DOUBLE_NAN_FUNCTION,\n+                          ZetaSqlCalciteTranslationUtils.toCalciteTypeName(kind)));\n+        } else {\n+          ret =\n+              rexBuilder()\n+                  .makeApproxLiteral(\n+                      new BigDecimal(val),\n+                      ZetaSqlCalciteTranslationUtils.toSimpleRelDataType(kind, rexBuilder()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIwNzk4Ng=="}, "originalCommit": {"oid": "b4ea922d4a9dff9f945af491048e2d2658bde950"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU3Mjc2OA==", "bodyText": "I meant\nString wrapperFun = null;\nif (val == Double.POSITIVE_INFINITY) {\n  wrapperFun = BeamBigQuerySqlDialect.DOUBLE_POSITIVE_INF_FUNCTION;\n} else if (val == Double.NEGATIVE_INFINITY) {\n  wrapperFun = BeamBigQuerySqlDialect.DOUBLE_NEGATIVE_INF_FUNCTION;\n} else if (Double.isNan(val)) {\n  wrapperFun = BeamBigQuerySqlDialect.DOUBLE_NAN_FUNCTION;\n}\nRelDataType returnType = ZetaSqlCalciteTranslationUtils.toSimpleRelDataType(kind, rexBuilder());\nif (wrapperFun == null) {\n  ret = rexBuilder().makeApproxLiteral(new BigDecimal(val), returnType);\n} else {\n  ret = rexBuilder().makeCall(SqlOperators.createOtherKindSqlFunction(wrapperFun, returnType.getSqlTypeName()));\n}\n\nIsn't this simpler :)", "url": "https://github.com/apache/beam/pull/12292#discussion_r456572768", "createdAt": "2020-07-17T17:19:35Z", "author": {"login": "robinyqiu"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -786,15 +786,39 @@ private RexNode convertSimpleValueToRexNode(TypeKind kind, Value value) {\n                     ZetaSqlCalciteTranslationUtils.toSimpleRelDataType(kind, rexBuilder()));\n         break;\n       case TYPE_DOUBLE:\n+        // Cannot simply call makeApproxLiteral() for ZetaSQL DOUBLE type because positive infinity,\n+        // negative infinity and Nan cannot be directly converted to BigDecimal. So we create three\n+        // wrapper functions here for these three cases such that we can later recognize it and\n+        // customize its unparsing in BeamBigQuerySqlDialect.\n         double val = value.getDoubleValue();\n-        if (Double.isInfinite(val) || Double.isNaN(val)) {\n-          throw new UnsupportedOperationException(\"Does not support Infinite or NaN literals.\");\n+        if (Double.isInfinite(val) && val > 0) {\n+          ret =\n+              rexBuilder()\n+                  .makeCall(\n+                      SqlOperators.createOtherKindSqlFunction(\n+                          BeamBigQuerySqlDialect.DOUBLE_POSITIVE_INF_FUNCTION,\n+                          ZetaSqlCalciteTranslationUtils.toCalciteTypeName(kind)));\n+        } else if (Double.isInfinite(val) && val < 0) {\n+          ret =\n+              rexBuilder()\n+                  .makeCall(\n+                      SqlOperators.createOtherKindSqlFunction(\n+                          BeamBigQuerySqlDialect.DOUBLE_NEGATIVE_INF_FUNCTION,\n+                          ZetaSqlCalciteTranslationUtils.toCalciteTypeName(kind)));\n+        } else if (Double.isNaN(val)) {\n+          ret =\n+              rexBuilder()\n+                  .makeCall(\n+                      SqlOperators.createOtherKindSqlFunction(\n+                          BeamBigQuerySqlDialect.DOUBLE_NAN_FUNCTION,\n+                          ZetaSqlCalciteTranslationUtils.toCalciteTypeName(kind)));\n+        } else {\n+          ret =\n+              rexBuilder()\n+                  .makeApproxLiteral(\n+                      new BigDecimal(val),\n+                      ZetaSqlCalciteTranslationUtils.toSimpleRelDataType(kind, rexBuilder()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIwNzk4Ng=="}, "originalCommit": {"oid": "b4ea922d4a9dff9f945af491048e2d2658bde950"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5Mzk5NQ==", "bodyText": "That's seems good idea. Got it.", "url": "https://github.com/apache/beam/pull/12292#discussion_r456593995", "createdAt": "2020-07-17T18:01:20Z", "author": {"login": "ZijieSong946"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -786,15 +786,39 @@ private RexNode convertSimpleValueToRexNode(TypeKind kind, Value value) {\n                     ZetaSqlCalciteTranslationUtils.toSimpleRelDataType(kind, rexBuilder()));\n         break;\n       case TYPE_DOUBLE:\n+        // Cannot simply call makeApproxLiteral() for ZetaSQL DOUBLE type because positive infinity,\n+        // negative infinity and Nan cannot be directly converted to BigDecimal. So we create three\n+        // wrapper functions here for these three cases such that we can later recognize it and\n+        // customize its unparsing in BeamBigQuerySqlDialect.\n         double val = value.getDoubleValue();\n-        if (Double.isInfinite(val) || Double.isNaN(val)) {\n-          throw new UnsupportedOperationException(\"Does not support Infinite or NaN literals.\");\n+        if (Double.isInfinite(val) && val > 0) {\n+          ret =\n+              rexBuilder()\n+                  .makeCall(\n+                      SqlOperators.createOtherKindSqlFunction(\n+                          BeamBigQuerySqlDialect.DOUBLE_POSITIVE_INF_FUNCTION,\n+                          ZetaSqlCalciteTranslationUtils.toCalciteTypeName(kind)));\n+        } else if (Double.isInfinite(val) && val < 0) {\n+          ret =\n+              rexBuilder()\n+                  .makeCall(\n+                      SqlOperators.createOtherKindSqlFunction(\n+                          BeamBigQuerySqlDialect.DOUBLE_NEGATIVE_INF_FUNCTION,\n+                          ZetaSqlCalciteTranslationUtils.toCalciteTypeName(kind)));\n+        } else if (Double.isNaN(val)) {\n+          ret =\n+              rexBuilder()\n+                  .makeCall(\n+                      SqlOperators.createOtherKindSqlFunction(\n+                          BeamBigQuerySqlDialect.DOUBLE_NAN_FUNCTION,\n+                          ZetaSqlCalciteTranslationUtils.toCalciteTypeName(kind)));\n+        } else {\n+          ret =\n+              rexBuilder()\n+                  .makeApproxLiteral(\n+                      new BigDecimal(val),\n+                      ZetaSqlCalciteTranslationUtils.toSimpleRelDataType(kind, rexBuilder()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIwNzk4Ng=="}, "originalCommit": {"oid": "b4ea922d4a9dff9f945af491048e2d2658bde950"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5OTM4MQ==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/12292#discussion_r456599381", "createdAt": "2020-07-17T18:12:58Z", "author": {"login": "ZijieSong946"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -786,15 +786,39 @@ private RexNode convertSimpleValueToRexNode(TypeKind kind, Value value) {\n                     ZetaSqlCalciteTranslationUtils.toSimpleRelDataType(kind, rexBuilder()));\n         break;\n       case TYPE_DOUBLE:\n+        // Cannot simply call makeApproxLiteral() for ZetaSQL DOUBLE type because positive infinity,\n+        // negative infinity and Nan cannot be directly converted to BigDecimal. So we create three\n+        // wrapper functions here for these three cases such that we can later recognize it and\n+        // customize its unparsing in BeamBigQuerySqlDialect.\n         double val = value.getDoubleValue();\n-        if (Double.isInfinite(val) || Double.isNaN(val)) {\n-          throw new UnsupportedOperationException(\"Does not support Infinite or NaN literals.\");\n+        if (Double.isInfinite(val) && val > 0) {\n+          ret =\n+              rexBuilder()\n+                  .makeCall(\n+                      SqlOperators.createOtherKindSqlFunction(\n+                          BeamBigQuerySqlDialect.DOUBLE_POSITIVE_INF_FUNCTION,\n+                          ZetaSqlCalciteTranslationUtils.toCalciteTypeName(kind)));\n+        } else if (Double.isInfinite(val) && val < 0) {\n+          ret =\n+              rexBuilder()\n+                  .makeCall(\n+                      SqlOperators.createOtherKindSqlFunction(\n+                          BeamBigQuerySqlDialect.DOUBLE_NEGATIVE_INF_FUNCTION,\n+                          ZetaSqlCalciteTranslationUtils.toCalciteTypeName(kind)));\n+        } else if (Double.isNaN(val)) {\n+          ret =\n+              rexBuilder()\n+                  .makeCall(\n+                      SqlOperators.createOtherKindSqlFunction(\n+                          BeamBigQuerySqlDialect.DOUBLE_NAN_FUNCTION,\n+                          ZetaSqlCalciteTranslationUtils.toCalciteTypeName(kind)));\n+        } else {\n+          ret =\n+              rexBuilder()\n+                  .makeApproxLiteral(\n+                      new BigDecimal(val),\n+                      ZetaSqlCalciteTranslationUtils.toSimpleRelDataType(kind, rexBuilder()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIwNzk4Ng=="}, "originalCommit": {"oid": "b4ea922d4a9dff9f945af491048e2d2658bde950"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTcyNDE4OnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/bigquery/BeamBigQuerySqlDialect.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNDoxNjowM1rOGzExzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODoxMzozOVrOGzcohg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIwODg0NQ==", "bodyText": "If you create a map DOUBLE_LITERAL_FUNCTIONS, you can merge the 3 branches here and the 3 functions below. (Similar to what I did with EXTRACT_FUNCTIONS)", "url": "https://github.com/apache/beam/pull/12292#discussion_r456208845", "createdAt": "2020-07-17T04:16:03Z", "author": {"login": "robinyqiu"}, "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/bigquery/BeamBigQuerySqlDialect.java", "diffHunk": "@@ -157,8 +160,20 @@ public void unparseCall(\n         break;\n       case OTHER_FUNCTION:\n         String funName = call.getOperator().getName();\n-        if (NUMERIC_LITERAL_FUNCTION.equals(funName)) {\n-          // self-designed function dealing with the unparsing of ZetaSQL numeric literal\n+        if (DOUBLE_POSITIVE_INF_FUNCTION.equals(funName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4ea922d4a9dff9f945af491048e2d2658bde950"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5OTY4Ng==", "bodyText": "Done. Thanks for pointing it out.", "url": "https://github.com/apache/beam/pull/12292#discussion_r456599686", "createdAt": "2020-07-17T18:13:39Z", "author": {"login": "ZijieSong946"}, "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/bigquery/BeamBigQuerySqlDialect.java", "diffHunk": "@@ -157,8 +160,20 @@ public void unparseCall(\n         break;\n       case OTHER_FUNCTION:\n         String funName = call.getOperator().getName();\n-        if (NUMERIC_LITERAL_FUNCTION.equals(funName)) {\n-          // self-designed function dealing with the unparsing of ZetaSQL numeric literal\n+        if (DOUBLE_POSITIVE_INF_FUNCTION.equals(funName)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIwODg0NQ=="}, "originalCommit": {"oid": "b4ea922d4a9dff9f945af491048e2d2658bde950"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTcyNjkxOnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/bigquery/BeamBigQuerySqlDialect.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNDoxNzo1NVrOGzEzPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODoxNDowMFrOGzcpHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIwOTIxNQ==", "bodyText": "Maybe comment here: \"There is no direct ZetaSQL literal representation of NaN or infinity\"?", "url": "https://github.com/apache/beam/pull/12292#discussion_r456209215", "createdAt": "2020-07-17T04:17:55Z", "author": {"login": "robinyqiu"}, "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/bigquery/BeamBigQuerySqlDialect.java", "diffHunk": "@@ -239,6 +254,18 @@ private void unparseTrim(SqlWriter writer, SqlCall call, int leftPrec, int right\n     writer.endFunCall(trimFrame);\n   }\n \n+  private void unparseDoublePositiveINFWrapperFunction(SqlWriter writer) {\n+    writer.literal(\"CAST('+inf' AS FLOAT64)\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4ea922d4a9dff9f945af491048e2d2658bde950"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5OTgzOA==", "bodyText": "Comment Added.", "url": "https://github.com/apache/beam/pull/12292#discussion_r456599838", "createdAt": "2020-07-17T18:14:00Z", "author": {"login": "ZijieSong946"}, "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/bigquery/BeamBigQuerySqlDialect.java", "diffHunk": "@@ -239,6 +254,18 @@ private void unparseTrim(SqlWriter writer, SqlCall call, int leftPrec, int right\n     writer.endFunCall(trimFrame);\n   }\n \n+  private void unparseDoublePositiveINFWrapperFunction(SqlWriter writer) {\n+    writer.literal(\"CAST('+inf' AS FLOAT64)\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIwOTIxNQ=="}, "originalCommit": {"oid": "b4ea922d4a9dff9f945af491048e2d2658bde950"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODI2Nzk1OnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/bigquery/BeamBigQuerySqlDialect.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODoxOToyNFrOGzczKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODoyMjoyOFrOGzc4pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYwMjQxMQ==", "bodyText": "Actually you can just pass funName to it.", "url": "https://github.com/apache/beam/pull/12292#discussion_r456602411", "createdAt": "2020-07-17T18:19:24Z", "author": {"login": "robinyqiu"}, "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/bigquery/BeamBigQuerySqlDialect.java", "diffHunk": "@@ -157,8 +166,13 @@ public void unparseCall(\n         break;\n       case OTHER_FUNCTION:\n         String funName = call.getOperator().getName();\n-        if (NUMERIC_LITERAL_FUNCTION.equals(funName)) {\n-          // self-designed function dealing with the unparsing of ZetaSQL numeric literal\n+        if (DOUBLE_FUNCTIONS.containsKey(funName)) {\n+          // self-designed function dealing with the unparsing of ZetaSQL DOUBLE positive\n+          // infinity, negative infinity and NaN\n+          unparseDoubleWrapperFunction(writer, call);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa169f4b47ab3484bc02e174543ed30598d2ca71"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYwMzA4MA==", "bodyText": "And after you change this, could you please do a rebase again?", "url": "https://github.com/apache/beam/pull/12292#discussion_r456603080", "createdAt": "2020-07-17T18:20:52Z", "author": {"login": "robinyqiu"}, "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/bigquery/BeamBigQuerySqlDialect.java", "diffHunk": "@@ -157,8 +166,13 @@ public void unparseCall(\n         break;\n       case OTHER_FUNCTION:\n         String funName = call.getOperator().getName();\n-        if (NUMERIC_LITERAL_FUNCTION.equals(funName)) {\n-          // self-designed function dealing with the unparsing of ZetaSQL numeric literal\n+        if (DOUBLE_FUNCTIONS.containsKey(funName)) {\n+          // self-designed function dealing with the unparsing of ZetaSQL DOUBLE positive\n+          // infinity, negative infinity and NaN\n+          unparseDoubleWrapperFunction(writer, call);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYwMjQxMQ=="}, "originalCommit": {"oid": "fa169f4b47ab3484bc02e174543ed30598d2ca71"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYwMzgxMg==", "bodyText": "Acknowledged.", "url": "https://github.com/apache/beam/pull/12292#discussion_r456603812", "createdAt": "2020-07-17T18:22:28Z", "author": {"login": "ZijieSong946"}, "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/bigquery/BeamBigQuerySqlDialect.java", "diffHunk": "@@ -157,8 +166,13 @@ public void unparseCall(\n         break;\n       case OTHER_FUNCTION:\n         String funName = call.getOperator().getName();\n-        if (NUMERIC_LITERAL_FUNCTION.equals(funName)) {\n-          // self-designed function dealing with the unparsing of ZetaSQL numeric literal\n+        if (DOUBLE_FUNCTIONS.containsKey(funName)) {\n+          // self-designed function dealing with the unparsing of ZetaSQL DOUBLE positive\n+          // infinity, negative infinity and NaN\n+          unparseDoubleWrapperFunction(writer, call);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYwMjQxMQ=="}, "originalCommit": {"oid": "fa169f4b47ab3484bc02e174543ed30598d2ca71"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MTU3MTM2OnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNTo1OTo1M1rOG1T2GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMTowMTozMlrOG10EVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1Mjg1Nw==", "bodyText": "Usually I will make a TODO here (such that you can easily find it in the IntelliJ TODO tab), like:\n// TODO[BEAM-10550]: Update the temporary workaround below after vendored Calcite version >= 1.23.0", "url": "https://github.com/apache/beam/pull/12292#discussion_r458552857", "createdAt": "2020-07-22T05:59:53Z", "author": {"login": "robinyqiu"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -805,6 +805,9 @@ private RexNode convertSimpleValueToRexNode(TypeKind kind, Value value) {\n         if (wrapperFun == null) {\n           ret = rexBuilder().makeApproxLiteral(new BigDecimal(val), returnType);\n         } else if (BeamBigQuerySqlDialect.DOUBLE_NAN_FUNCTION.equals(wrapperFun)) {\n+          // 'https://issues.apache.org/jira/browse/BEAM-10550'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "585939d4cd2451c5c94b0ac9a7bc138e477d85e8"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA4MDc4OA==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/12292#discussion_r459080788", "createdAt": "2020-07-22T21:01:32Z", "author": {"login": "ZijieSong946"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -805,6 +805,9 @@ private RexNode convertSimpleValueToRexNode(TypeKind kind, Value value) {\n         if (wrapperFun == null) {\n           ret = rexBuilder().makeApproxLiteral(new BigDecimal(val), returnType);\n         } else if (BeamBigQuerySqlDialect.DOUBLE_NAN_FUNCTION.equals(wrapperFun)) {\n+          // 'https://issues.apache.org/jira/browse/BEAM-10550'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1Mjg1Nw=="}, "originalCommit": {"oid": "585939d4cd2451c5c94b0ac9a7bc138e477d85e8"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1081, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}