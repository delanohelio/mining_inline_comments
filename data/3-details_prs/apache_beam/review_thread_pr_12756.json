{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3NTI2NDQy", "number": 12756, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzo1ODozOVrOEfkYOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMzo1NTozOVrOEh5dQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTM3MzM4OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/transforms/stats_test.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzo1ODozOVrOHL65Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxODowNzo1OVrOHL7OUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MTI4Ng==", "bodyText": "nit: you could call this: test_approximate_unique_combine_fn_adds_values_correctly instead of adding a comment.", "url": "https://github.com/apache/beam/pull/12756#discussion_r482261286", "createdAt": "2020-09-02T17:58:39Z", "author": {"login": "tvalentyn"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -496,6 +483,51 @@ def test_approximate_unique_globally_by_error_with_skewed_data(self):\n           equal_to([True]),\n           label='assert:globally_by_error_with_skewed_data')\n \n+  def test_approximate_unique_combine_fn_by_nondeterministic_coder(self):\n+    # test if the combiner throws an error with a nondeterministic coder.\n+    sample_size = 30\n+    coder = coders.Base64PickleCoder()\n+\n+    with self.assertRaises(ValueError) as e:\n+      _ = ApproximateUniqueCombineFn(sample_size, coder)\n+\n+    self.assertRegex(\n+        e.exception.args[0],\n+        'The key coder \"Base64PickleCoder\" '\n+        'for ApproximateUniqueCombineFn is not deterministic.')\n+\n+  def test_approximate_unique_combine_fn_add_values(self):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32f6319fb2c7dc9be112b4c866cb02aee79e545d"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2NjcwNQ==", "bodyText": "done.", "url": "https://github.com/apache/beam/pull/12756#discussion_r482266705", "createdAt": "2020-09-02T18:07:59Z", "author": {"login": "monicadsong"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -496,6 +483,51 @@ def test_approximate_unique_globally_by_error_with_skewed_data(self):\n           equal_to([True]),\n           label='assert:globally_by_error_with_skewed_data')\n \n+  def test_approximate_unique_combine_fn_by_nondeterministic_coder(self):\n+    # test if the combiner throws an error with a nondeterministic coder.\n+    sample_size = 30\n+    coder = coders.Base64PickleCoder()\n+\n+    with self.assertRaises(ValueError) as e:\n+      _ = ApproximateUniqueCombineFn(sample_size, coder)\n+\n+    self.assertRegex(\n+        e.exception.args[0],\n+        'The key coder \"Base64PickleCoder\" '\n+        'for ApproximateUniqueCombineFn is not deterministic.')\n+\n+  def test_approximate_unique_combine_fn_add_values(self):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MTI4Ng=="}, "originalCommit": {"oid": "32f6319fb2c7dc9be112b4c866cb02aee79e545d"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMDY1MTkxOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/transforms/stats.py", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNjozNzo1MVrOHMu4Lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOTo0NzozNVrOHM1JEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExMzAwNg==", "bodyText": "I think we need to update the initialization of self._min_hash.\n@Hannah-Jiang do you by chance remember what was the logic behind setting\n  _HASH_SPACE_SIZE = 2.0 * sys.maxsize\nself._min_hash = sys.maxsize ?\nShouldn't we initialize self._min_hash with self._HASH_SPACE_SIZE?", "url": "https://github.com/apache/beam/pull/12756#discussion_r483113006", "createdAt": "2020-09-03T16:37:51Z", "author": {"login": "tvalentyn"}, "path": "sdks/python/apache_beam/transforms/stats.py", "diffHunk": "@@ -192,7 +193,7 @@ def get_estimate(self):\n     if len(self._sample_heap) < self._sample_size:\n       return len(self._sample_heap)\n     else:\n-      sample_space_size = sys.maxsize - 1.0 * self._min_hash\n+      sample_space_size = self._HASH_SPACE_SIZE - 1.0 * self._min_hash", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70c1b75cb59a745bd8b927f1bac19a114a4e0632"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE1ODA2NQ==", "bodyText": "Ah, that was because python's  hash() can return negative values. So yes, I think we need to set self._min_hash = 2**64 given that now all hash values are positive.", "url": "https://github.com/apache/beam/pull/12756#discussion_r483158065", "createdAt": "2020-09-03T17:57:50Z", "author": {"login": "tvalentyn"}, "path": "sdks/python/apache_beam/transforms/stats.py", "diffHunk": "@@ -192,7 +193,7 @@ def get_estimate(self):\n     if len(self._sample_heap) < self._sample_size:\n       return len(self._sample_heap)\n     else:\n-      sample_space_size = sys.maxsize - 1.0 * self._min_hash\n+      sample_space_size = self._HASH_SPACE_SIZE - 1.0 * self._min_hash", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExMzAwNg=="}, "originalCommit": {"oid": "70c1b75cb59a745bd8b927f1bac19a114a4e0632"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE1OTI2Mg==", "bodyText": "Valentyn-- you're right, forgot to update self._HASH_SPACE_SIZE. I think originally pythons hash() can return negative value, so the total hash space ranges from (- sys.maxsize,  sys.maxsize).", "url": "https://github.com/apache/beam/pull/12756#discussion_r483159262", "createdAt": "2020-09-03T18:00:01Z", "author": {"login": "monicadsong"}, "path": "sdks/python/apache_beam/transforms/stats.py", "diffHunk": "@@ -192,7 +193,7 @@ def get_estimate(self):\n     if len(self._sample_heap) < self._sample_size:\n       return len(self._sample_heap)\n     else:\n-      sample_space_size = sys.maxsize - 1.0 * self._min_hash\n+      sample_space_size = self._HASH_SPACE_SIZE - 1.0 * self._min_hash", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExMzAwNg=="}, "originalCommit": {"oid": "70c1b75cb59a745bd8b927f1bac19a114a4e0632"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIxNTYzMg==", "bodyText": "Modified it to 2^63 - 1 (which is also equivalent to sys.maxsize... which is why my tests were passing.)", "url": "https://github.com/apache/beam/pull/12756#discussion_r483215632", "createdAt": "2020-09-03T19:47:35Z", "author": {"login": "monicadsong"}, "path": "sdks/python/apache_beam/transforms/stats.py", "diffHunk": "@@ -192,7 +193,7 @@ def get_estimate(self):\n     if len(self._sample_heap) < self._sample_size:\n       return len(self._sample_heap)\n     else:\n-      sample_space_size = sys.maxsize - 1.0 * self._min_hash\n+      sample_space_size = self._HASH_SPACE_SIZE - 1.0 * self._min_hash", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExMzAwNg=="}, "originalCommit": {"oid": "70c1b75cb59a745bd8b927f1bac19a114a4e0632"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMDk4NjU1OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/transforms/stats_test.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxODoxNToxMFrOHMyMTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOTo0Njo0M1rOHM1HXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE2NzMwOA==", "bodyText": "naming suggestion:\ntest_approximate_unique_combine_fn_requires_compatible_coder", "url": "https://github.com/apache/beam/pull/12756#discussion_r483167308", "createdAt": "2020-09-03T18:15:10Z", "author": {"login": "tvalentyn"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -496,6 +483,62 @@ def test_approximate_unique_globally_by_error_with_skewed_data(self):\n           equal_to([True]),\n           label='assert:globally_by_error_with_skewed_data')\n \n+  def test_approximate_unique_combine_fn_by_nondeterministic_coder(self):\n+    # test if the combiner throws an error with a nondeterministic coder.\n+    sample_size = 30\n+    coder = coders.Base64PickleCoder()\n+\n+    with self.assertRaises(ValueError) as e:\n+      _ = ApproximateUniqueCombineFn(sample_size, coder)\n+\n+    self.assertRegex(\n+        e.exception.args[0],\n+        'The key coder \"Base64PickleCoder\" '\n+        'for ApproximateUniqueCombineFn is not deterministic.')\n+\n+  def test_approximate_unique_combine_fn_by_wrong_coder(self):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70c1b75cb59a745bd8b927f1bac19a114a4e0632"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIxNTE5Ng==", "bodyText": "done.", "url": "https://github.com/apache/beam/pull/12756#discussion_r483215196", "createdAt": "2020-09-03T19:46:43Z", "author": {"login": "monicadsong"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -496,6 +483,62 @@ def test_approximate_unique_globally_by_error_with_skewed_data(self):\n           equal_to([True]),\n           label='assert:globally_by_error_with_skewed_data')\n \n+  def test_approximate_unique_combine_fn_by_nondeterministic_coder(self):\n+    # test if the combiner throws an error with a nondeterministic coder.\n+    sample_size = 30\n+    coder = coders.Base64PickleCoder()\n+\n+    with self.assertRaises(ValueError) as e:\n+      _ = ApproximateUniqueCombineFn(sample_size, coder)\n+\n+    self.assertRegex(\n+        e.exception.args[0],\n+        'The key coder \"Base64PickleCoder\" '\n+        'for ApproximateUniqueCombineFn is not deterministic.')\n+\n+  def test_approximate_unique_combine_fn_by_wrong_coder(self):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE2NzMwOA=="}, "originalCommit": {"oid": "70c1b75cb59a745bd8b927f1bac19a114a4e0632"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMDk5MTU5OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/transforms/stats_test.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxODoxNjozNFrOHMyPWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOTo0Njo1NFrOHM1HyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE2ODA5MQ==", "bodyText": "naming suggestion:\ntest_approximate_unique_combine_fn_requires_deterministic_coder", "url": "https://github.com/apache/beam/pull/12756#discussion_r483168091", "createdAt": "2020-09-03T18:16:34Z", "author": {"login": "tvalentyn"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -496,6 +483,62 @@ def test_approximate_unique_globally_by_error_with_skewed_data(self):\n           equal_to([True]),\n           label='assert:globally_by_error_with_skewed_data')\n \n+  def test_approximate_unique_combine_fn_by_nondeterministic_coder(self):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70c1b75cb59a745bd8b927f1bac19a114a4e0632"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIxNTMwNA==", "bodyText": "done.", "url": "https://github.com/apache/beam/pull/12756#discussion_r483215304", "createdAt": "2020-09-03T19:46:54Z", "author": {"login": "monicadsong"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -496,6 +483,62 @@ def test_approximate_unique_globally_by_error_with_skewed_data(self):\n           equal_to([True]),\n           label='assert:globally_by_error_with_skewed_data')\n \n+  def test_approximate_unique_combine_fn_by_nondeterministic_coder(self):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE2ODA5MQ=="}, "originalCommit": {"oid": "70c1b75cb59a745bd8b927f1bac19a114a4e0632"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjM0MTc4OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/transforms/stats_test.py", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNDoxMTo0NlrOHM-3Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTo1MToyNlrOHOjm-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3NDg4Nw==", "bodyText": "A fixed dataset was used because random dataset cannot always pass the test even with retries and introduces flakiness. Does it always pass now?", "url": "https://github.com/apache/beam/pull/12756#discussion_r483374887", "createdAt": "2020-09-04T04:11:46Z", "author": {"login": "Hannah-Jiang"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -160,57 +159,13 @@ def test_get_sample_size_from_est_error(self):\n     assert beam.ApproximateUnique._get_sample_size_from_est_error(0.05) == 1600\n     assert beam.ApproximateUnique._get_sample_size_from_est_error(0.01) == 40000\n \n-  @unittest.skip(\n-      'Skip it because hash function is not good enough. '\n-      'TODO: BEAM-7654')\n   def test_approximate_unique_global_by_sample_size(self):\n     # test if estimation error with a given sample size is not greater than\n     # expected max error.\n     sample_size = 16\n     max_err = 2 / math.sqrt(sample_size)\n-    test_input = [\n-        4,\n-        34,\n-        29,\n-        46,\n-        80,\n-        66,\n-        51,\n-        81,\n-        31,\n-        9,\n-        26,\n-        36,\n-        10,\n-        41,\n-        90,\n-        35,\n-        33,\n-        19,\n-        88,\n-        86,\n-        28,\n-        93,\n-        38,\n-        76,\n-        15,\n-        87,\n-        12,\n-        39,\n-        84,\n-        13,\n-        32,\n-        49,\n-        65,\n-        100,\n-        16,\n-        27,\n-        23,\n-        30,\n-        96,\n-        54\n-    ]\n-\n+    test_input = list(range(100))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee3de100f240631b46ac2ff0a8a9a856ca12db6"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM4NDk0Mw==", "bodyText": "yes, all tests pass in a single run, always", "url": "https://github.com/apache/beam/pull/12756#discussion_r483384943", "createdAt": "2020-09-04T04:52:10Z", "author": {"login": "monicadsong"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -160,57 +159,13 @@ def test_get_sample_size_from_est_error(self):\n     assert beam.ApproximateUnique._get_sample_size_from_est_error(0.05) == 1600\n     assert beam.ApproximateUnique._get_sample_size_from_est_error(0.01) == 40000\n \n-  @unittest.skip(\n-      'Skip it because hash function is not good enough. '\n-      'TODO: BEAM-7654')\n   def test_approximate_unique_global_by_sample_size(self):\n     # test if estimation error with a given sample size is not greater than\n     # expected max error.\n     sample_size = 16\n     max_err = 2 / math.sqrt(sample_size)\n-    test_input = [\n-        4,\n-        34,\n-        29,\n-        46,\n-        80,\n-        66,\n-        51,\n-        81,\n-        31,\n-        9,\n-        26,\n-        36,\n-        10,\n-        41,\n-        90,\n-        35,\n-        33,\n-        19,\n-        88,\n-        86,\n-        28,\n-        93,\n-        38,\n-        76,\n-        15,\n-        87,\n-        12,\n-        39,\n-        84,\n-        13,\n-        32,\n-        49,\n-        65,\n-        100,\n-        16,\n-        27,\n-        23,\n-        30,\n-        96,\n-        54\n-    ]\n-\n+    test_input = list(range(100))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3NDg4Nw=="}, "originalCommit": {"oid": "3ee3de100f240631b46ac2ff0a8a9a856ca12db6"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM4NTUxMA==", "bodyText": "but I will add a seed to account for randomness in the shuffling of the test data.", "url": "https://github.com/apache/beam/pull/12756#discussion_r483385510", "createdAt": "2020-09-04T04:54:24Z", "author": {"login": "monicadsong"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -160,57 +159,13 @@ def test_get_sample_size_from_est_error(self):\n     assert beam.ApproximateUnique._get_sample_size_from_est_error(0.05) == 1600\n     assert beam.ApproximateUnique._get_sample_size_from_est_error(0.01) == 40000\n \n-  @unittest.skip(\n-      'Skip it because hash function is not good enough. '\n-      'TODO: BEAM-7654')\n   def test_approximate_unique_global_by_sample_size(self):\n     # test if estimation error with a given sample size is not greater than\n     # expected max error.\n     sample_size = 16\n     max_err = 2 / math.sqrt(sample_size)\n-    test_input = [\n-        4,\n-        34,\n-        29,\n-        46,\n-        80,\n-        66,\n-        51,\n-        81,\n-        31,\n-        9,\n-        26,\n-        36,\n-        10,\n-        41,\n-        90,\n-        35,\n-        33,\n-        19,\n-        88,\n-        86,\n-        28,\n-        93,\n-        38,\n-        76,\n-        15,\n-        87,\n-        12,\n-        39,\n-        84,\n-        13,\n-        32,\n-        49,\n-        65,\n-        100,\n-        16,\n-        27,\n-        23,\n-        30,\n-        96,\n-        54\n-    ]\n-\n+    test_input = list(range(100))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3NDg4Nw=="}, "originalCommit": {"oid": "3ee3de100f240631b46ac2ff0a8a9a856ca12db6"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ1Mjk3NQ==", "bodyText": "It\u2019s better to run at least 100 times to test flakiness. I\u2019d recommend to run 1000 times.", "url": "https://github.com/apache/beam/pull/12756#discussion_r483452975", "createdAt": "2020-09-04T07:57:52Z", "author": {"login": "Hannah-Jiang"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -160,57 +159,13 @@ def test_get_sample_size_from_est_error(self):\n     assert beam.ApproximateUnique._get_sample_size_from_est_error(0.05) == 1600\n     assert beam.ApproximateUnique._get_sample_size_from_est_error(0.01) == 40000\n \n-  @unittest.skip(\n-      'Skip it because hash function is not good enough. '\n-      'TODO: BEAM-7654')\n   def test_approximate_unique_global_by_sample_size(self):\n     # test if estimation error with a given sample size is not greater than\n     # expected max error.\n     sample_size = 16\n     max_err = 2 / math.sqrt(sample_size)\n-    test_input = [\n-        4,\n-        34,\n-        29,\n-        46,\n-        80,\n-        66,\n-        51,\n-        81,\n-        31,\n-        9,\n-        26,\n-        36,\n-        10,\n-        41,\n-        90,\n-        35,\n-        33,\n-        19,\n-        88,\n-        86,\n-        28,\n-        93,\n-        38,\n-        76,\n-        15,\n-        87,\n-        12,\n-        39,\n-        84,\n-        13,\n-        32,\n-        49,\n-        65,\n-        100,\n-        16,\n-        27,\n-        23,\n-        30,\n-        96,\n-        54\n-    ]\n-\n+    test_input = list(range(100))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3NDg4Nw=="}, "originalCommit": {"oid": "3ee3de100f240631b46ac2ff0a8a9a856ca12db6"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4MTM4Nw==", "bodyText": "hmm not sure I understand... i believe that adding a random seed should eliminate all randomness in the generation and shuffling of the test data, such that every test run uses the same data?", "url": "https://github.com/apache/beam/pull/12756#discussion_r484681387", "createdAt": "2020-09-08T06:34:39Z", "author": {"login": "monicadsong"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -160,57 +159,13 @@ def test_get_sample_size_from_est_error(self):\n     assert beam.ApproximateUnique._get_sample_size_from_est_error(0.05) == 1600\n     assert beam.ApproximateUnique._get_sample_size_from_est_error(0.01) == 40000\n \n-  @unittest.skip(\n-      'Skip it because hash function is not good enough. '\n-      'TODO: BEAM-7654')\n   def test_approximate_unique_global_by_sample_size(self):\n     # test if estimation error with a given sample size is not greater than\n     # expected max error.\n     sample_size = 16\n     max_err = 2 / math.sqrt(sample_size)\n-    test_input = [\n-        4,\n-        34,\n-        29,\n-        46,\n-        80,\n-        66,\n-        51,\n-        81,\n-        31,\n-        9,\n-        26,\n-        36,\n-        10,\n-        41,\n-        90,\n-        35,\n-        33,\n-        19,\n-        88,\n-        86,\n-        28,\n-        93,\n-        38,\n-        76,\n-        15,\n-        87,\n-        12,\n-        39,\n-        84,\n-        13,\n-        32,\n-        49,\n-        65,\n-        100,\n-        16,\n-        27,\n-        23,\n-        30,\n-        96,\n-        54\n-    ]\n-\n+    test_input = list(range(100))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3NDg4Nw=="}, "originalCommit": {"oid": "3ee3de100f240631b46ac2ff0a8a9a856ca12db6"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAyNTUyOA==", "bodyText": "Ah, I miss understood your above comment. Adding the seed looks good to me.", "url": "https://github.com/apache/beam/pull/12756#discussion_r485025528", "createdAt": "2020-09-08T15:51:26Z", "author": {"login": "Hannah-Jiang"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -160,57 +159,13 @@ def test_get_sample_size_from_est_error(self):\n     assert beam.ApproximateUnique._get_sample_size_from_est_error(0.05) == 1600\n     assert beam.ApproximateUnique._get_sample_size_from_est_error(0.01) == 40000\n \n-  @unittest.skip(\n-      'Skip it because hash function is not good enough. '\n-      'TODO: BEAM-7654')\n   def test_approximate_unique_global_by_sample_size(self):\n     # test if estimation error with a given sample size is not greater than\n     # expected max error.\n     sample_size = 16\n     max_err = 2 / math.sqrt(sample_size)\n-    test_input = [\n-        4,\n-        34,\n-        29,\n-        46,\n-        80,\n-        66,\n-        51,\n-        81,\n-        31,\n-        9,\n-        26,\n-        36,\n-        10,\n-        41,\n-        90,\n-        35,\n-        33,\n-        19,\n-        88,\n-        86,\n-        28,\n-        93,\n-        38,\n-        76,\n-        15,\n-        87,\n-        12,\n-        39,\n-        84,\n-        13,\n-        32,\n-        49,\n-        65,\n-        100,\n-        16,\n-        27,\n-        23,\n-        30,\n-        96,\n-        54\n-    ]\n-\n+    test_input = list(range(100))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3NDg4Nw=="}, "originalCommit": {"oid": "3ee3de100f240631b46ac2ff0a8a9a856ca12db6"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDg4NTEyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/transforms/stats.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMTo1ODoxNFrOHOvaLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMTo1ODoxNFrOHOvaLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIxODg2Mg==", "bodyText": "Couldn't find murmurhash. Install mmh3 for a faster implementation of ApproximateUnique.", "url": "https://github.com/apache/beam/pull/12756#discussion_r485218862", "createdAt": "2020-09-08T21:58:14Z", "author": {"login": "tvalentyn"}, "path": "sdks/python/apache_beam/transforms/stats.py", "diffHunk": "@@ -46,6 +57,35 @@\n V = typing.TypeVar('V')\n \n \n+def _default_hash_fn(value):\n+  \"\"\"Hash value using either murmurhash or md5 based on installation.\"\"\"\n+  if not _default_hash_fn.fn:\n+    try:\n+      import mmh3  # pylint: disable=import-error\n+\n+      def _mmh3_hash(value):\n+        # mmh3.hash64 returns 2 64-bit unsigned integers\n+        return mmh3.hash64(value, seed=0, signed=False)[0]\n+\n+      _default_hash_fn.fn = _mmh3_hash\n+    except ImportError:\n+      logging.warning(\n+          'Couldn\\'t find murmurhash so the implementation of '\n+          'ApproximateUnique is not as fast as it could be.')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a83c0db039aa4784a0cca3cd8fff9ad7eac17327"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDkxODcwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/transforms/stats_test.py", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjoxMTo1NVrOHOvuMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxOTo0Njo1M1rOHPXfIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMzk4Ng==", "bodyText": "Can we parameterize the test to exercise both md5/mmh3 codepaths. We could force md5 by a patch for test purposes if mmh3 is installed.", "url": "https://github.com/apache/beam/pull/12756#discussion_r485223986", "createdAt": "2020-09-08T22:11:55Z", "author": {"login": "tvalentyn"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -41,13 +40,15 @@\n from apache_beam.transforms.display import DisplayData\n from apache_beam.transforms.display_test import DisplayDataItemMatcher\n from apache_beam.transforms.stats import ApproximateQuantilesCombineFn\n+from apache_beam.transforms.stats import ApproximateUniqueCombineFn\n \n \n class ApproximateUniqueTest(unittest.TestCase):\n-  \"\"\"Unit tests for ApproximateUnique.Globally and ApproximateUnique.PerKey.\n-  Hash() with Python3 is nondeterministic, so Approximation algorithm generates\n-  different result each time and sometimes error rate is out of range, so add\n-  retries for all tests who actually running approximation algorithm.\"\"\"\n+  \"\"\"Unit tests for ApproximateUnique.Globally, ApproximateUnique.PerKey,\n+  and ApproximateUniqueCombineFn.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a83c0db039aa4784a0cca3cd8fff9ad7eac17327"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3NjMyNw==", "bodyText": "Here is a background of mmh3 in case it helps for decision making. I used mmh3 at first but decided to use default hash function. mmh3 has better prediction performance, but it introduces much more complexity for dataflow import, and users should use HLL if they really care about the accuracy. In addition, the default hash function improved for Py3 and the performance diff was not big enough to use mmh3 and introduce the complexity. This is the reason mmh3 was not used, and it is just for reference.\nI think it\u2019s better to mention that HLL is supported by Beam.", "url": "https://github.com/apache/beam/pull/12756#discussion_r485276327", "createdAt": "2020-09-09T01:02:57Z", "author": {"login": "Hannah-Jiang"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -41,13 +40,15 @@\n from apache_beam.transforms.display import DisplayData\n from apache_beam.transforms.display_test import DisplayDataItemMatcher\n from apache_beam.transforms.stats import ApproximateQuantilesCombineFn\n+from apache_beam.transforms.stats import ApproximateUniqueCombineFn\n \n \n class ApproximateUniqueTest(unittest.TestCase):\n-  \"\"\"Unit tests for ApproximateUnique.Globally and ApproximateUnique.PerKey.\n-  Hash() with Python3 is nondeterministic, so Approximation algorithm generates\n-  different result each time and sometimes error rate is out of range, so add\n-  retries for all tests who actually running approximation algorithm.\"\"\"\n+  \"\"\"Unit tests for ApproximateUnique.Globally, ApproximateUnique.PerKey,\n+  and ApproximateUniqueCombineFn.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMzk4Ng=="}, "originalCommit": {"oid": "a83c0db039aa4784a0cca3cd8fff9ad7eac17327"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1NTA5MA==", "bodyText": "We can still do Dataflow import with a new dependency, AFAIK we noticed that Google internal-only tests for Beam on Windows were failing, so we thought that adding mmh3 would be a concern for all Beam Windows users. I no longer see  failures in Windows precommit tests running on the PR.", "url": "https://github.com/apache/beam/pull/12756#discussion_r485855090", "createdAt": "2020-09-09T19:19:48Z", "author": {"login": "tvalentyn"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -41,13 +40,15 @@\n from apache_beam.transforms.display import DisplayData\n from apache_beam.transforms.display_test import DisplayDataItemMatcher\n from apache_beam.transforms.stats import ApproximateQuantilesCombineFn\n+from apache_beam.transforms.stats import ApproximateUniqueCombineFn\n \n \n class ApproximateUniqueTest(unittest.TestCase):\n-  \"\"\"Unit tests for ApproximateUnique.Globally and ApproximateUnique.PerKey.\n-  Hash() with Python3 is nondeterministic, so Approximation algorithm generates\n-  different result each time and sometimes error rate is out of range, so add\n-  retries for all tests who actually running approximation algorithm.\"\"\"\n+  \"\"\"Unit tests for ApproximateUnique.Globally, ApproximateUnique.PerKey,\n+  and ApproximateUniqueCombineFn.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMzk4Ng=="}, "originalCommit": {"oid": "a83c0db039aa4784a0cca3cd8fff9ad7eac17327"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1ODc3MQ==", "bodyText": "I agree with Hannah. HLL would be the right solution and given that py3 has a better hash function adding this dependency could be avoided.\nWhat is the specific issue we are addressing by this change?", "url": "https://github.com/apache/beam/pull/12756#discussion_r485858771", "createdAt": "2020-09-09T19:25:56Z", "author": {"login": "aaltay"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -41,13 +40,15 @@\n from apache_beam.transforms.display import DisplayData\n from apache_beam.transforms.display_test import DisplayDataItemMatcher\n from apache_beam.transforms.stats import ApproximateQuantilesCombineFn\n+from apache_beam.transforms.stats import ApproximateUniqueCombineFn\n \n \n class ApproximateUniqueTest(unittest.TestCase):\n-  \"\"\"Unit tests for ApproximateUnique.Globally and ApproximateUnique.PerKey.\n-  Hash() with Python3 is nondeterministic, so Approximation algorithm generates\n-  different result each time and sometimes error rate is out of range, so add\n-  retries for all tests who actually running approximation algorithm.\"\"\"\n+  \"\"\"Unit tests for ApproximateUnique.Globally, ApproximateUnique.PerKey,\n+  and ApproximateUniqueCombineFn.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMzk4Ng=="}, "originalCommit": {"oid": "a83c0db039aa4784a0cca3cd8fff9ad7eac17327"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2MDM4Mw==", "bodyText": "hash is non deterministic, so if the computation is distributed over different machines, the estimates are overly inaccurate", "url": "https://github.com/apache/beam/pull/12756#discussion_r485860383", "createdAt": "2020-09-09T19:28:15Z", "author": {"login": "monicadsong"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -41,13 +40,15 @@\n from apache_beam.transforms.display import DisplayData\n from apache_beam.transforms.display_test import DisplayDataItemMatcher\n from apache_beam.transforms.stats import ApproximateQuantilesCombineFn\n+from apache_beam.transforms.stats import ApproximateUniqueCombineFn\n \n \n class ApproximateUniqueTest(unittest.TestCase):\n-  \"\"\"Unit tests for ApproximateUnique.Globally and ApproximateUnique.PerKey.\n-  Hash() with Python3 is nondeterministic, so Approximation algorithm generates\n-  different result each time and sometimes error rate is out of range, so add\n-  retries for all tests who actually running approximation algorithm.\"\"\"\n+  \"\"\"Unit tests for ApproximateUnique.Globally, ApproximateUnique.PerKey,\n+  and ApproximateUniqueCombineFn.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMzk4Ng=="}, "originalCommit": {"oid": "a83c0db039aa4784a0cca3cd8fff9ad7eac17327"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2MjU2OQ==", "bodyText": "py3 hash is non-deterministic, see BEAM-10824 and internal issue b/166646014 which has a bit more details.\nWe should not be using py3 hash function, and I support this change. Current change supports both md5 and mmh3, but we have a remanining question whether mmh3 should be a default dep (better performance than md5, but extra dependency), or optional (default to md5, give a warning recommendation to install mmh3, similar to snappy).\nHLL is not available for Beam Python yet, is it?", "url": "https://github.com/apache/beam/pull/12756#discussion_r485862569", "createdAt": "2020-09-09T19:31:03Z", "author": {"login": "tvalentyn"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -41,13 +40,15 @@\n from apache_beam.transforms.display import DisplayData\n from apache_beam.transforms.display_test import DisplayDataItemMatcher\n from apache_beam.transforms.stats import ApproximateQuantilesCombineFn\n+from apache_beam.transforms.stats import ApproximateUniqueCombineFn\n \n \n class ApproximateUniqueTest(unittest.TestCase):\n-  \"\"\"Unit tests for ApproximateUnique.Globally and ApproximateUnique.PerKey.\n-  Hash() with Python3 is nondeterministic, so Approximation algorithm generates\n-  different result each time and sometimes error rate is out of range, so add\n-  retries for all tests who actually running approximation algorithm.\"\"\"\n+  \"\"\"Unit tests for ApproximateUnique.Globally, ApproximateUnique.PerKey,\n+  and ApproximateUniqueCombineFn.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMzk4Ng=="}, "originalCommit": {"oid": "a83c0db039aa4784a0cca3cd8fff9ad7eac17327"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3MDI3OA==", "bodyText": "I did not know about py3 hash being non deterministic. That is strange.\nIn that case I agree with this change. Let's make it optional so that the getting started experience does not change and any actual execution environment could install it as needed. (i.e. add it here : https://github.com/apache/beam/blob/master/sdks/python/container/base_image_requirements.txt in this PR.)", "url": "https://github.com/apache/beam/pull/12756#discussion_r485870278", "createdAt": "2020-09-09T19:40:44Z", "author": {"login": "aaltay"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -41,13 +40,15 @@\n from apache_beam.transforms.display import DisplayData\n from apache_beam.transforms.display_test import DisplayDataItemMatcher\n from apache_beam.transforms.stats import ApproximateQuantilesCombineFn\n+from apache_beam.transforms.stats import ApproximateUniqueCombineFn\n \n \n class ApproximateUniqueTest(unittest.TestCase):\n-  \"\"\"Unit tests for ApproximateUnique.Globally and ApproximateUnique.PerKey.\n-  Hash() with Python3 is nondeterministic, so Approximation algorithm generates\n-  different result each time and sometimes error rate is out of range, so add\n-  retries for all tests who actually running approximation algorithm.\"\"\"\n+  \"\"\"Unit tests for ApproximateUnique.Globally, ApproximateUnique.PerKey,\n+  and ApproximateUniqueCombineFn.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMzk4Ng=="}, "originalCommit": {"oid": "a83c0db039aa4784a0cca3cd8fff9ad7eac17327"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3NTQ5MQ==", "bodyText": "sounds good thanks! more info on py3 hash here: https://stackoverflow.com/questions/27522626/hash-function-in-python-3-3-returns-different-results-between-sessions", "url": "https://github.com/apache/beam/pull/12756#discussion_r485875491", "createdAt": "2020-09-09T19:46:53Z", "author": {"login": "monicadsong"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -41,13 +40,15 @@\n from apache_beam.transforms.display import DisplayData\n from apache_beam.transforms.display_test import DisplayDataItemMatcher\n from apache_beam.transforms.stats import ApproximateQuantilesCombineFn\n+from apache_beam.transforms.stats import ApproximateUniqueCombineFn\n \n \n class ApproximateUniqueTest(unittest.TestCase):\n-  \"\"\"Unit tests for ApproximateUnique.Globally and ApproximateUnique.PerKey.\n-  Hash() with Python3 is nondeterministic, so Approximation algorithm generates\n-  different result each time and sometimes error rate is out of range, so add\n-  retries for all tests who actually running approximation algorithm.\"\"\"\n+  \"\"\"Unit tests for ApproximateUnique.Globally, ApproximateUnique.PerKey,\n+  and ApproximateUniqueCombineFn.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMzk4Ng=="}, "originalCommit": {"oid": "a83c0db039aa4784a0cca3cd8fff9ad7eac17327"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODk2MTkyOnYy", "diffSide": "RIGHT", "path": "sdks/python/setup.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxOToxNjoxMlrOHPWITA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxOToyODoyNlrOHPWkyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MzI2MA==", "bodyText": "(I thought I already added this comment here but for some reason I don't see it...)\nLet's make the upper bound more flexible mmh3>=2.5.1,<3.0, or remove the obligatory dependency on mmh3 as we do for snappy.  @aaltay do you have a preference on this?\nFor the record, Windows tests on the PR are passing. AFAIK, previously we didn't add a dep on mmh3 we observed installation errors on Google internal Windows test.", "url": "https://github.com/apache/beam/pull/12756#discussion_r485853260", "createdAt": "2020-09-09T19:16:12Z", "author": {"login": "tvalentyn"}, "path": "sdks/python/setup.py", "diffHunk": "@@ -165,6 +165,7 @@ def get_version():\n     'requests>=2.24.0,<3.0.0',\n     'typing>=3.7.0,<3.8.0; python_full_version < \"3.5.3\"',\n     'typing-extensions>=3.7.0,<3.8.0',\n+    'mmh3>=2.5.1,<2.5.2',", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a83c0db039aa4784a0cca3cd8fff9ad7eac17327"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2MDU1NA==", "bodyText": "It is better to avoid adding a new dependency if possible especially a one with platform specific differences. If we need to add it, it is better to make it optional similar to snappy.", "url": "https://github.com/apache/beam/pull/12756#discussion_r485860554", "createdAt": "2020-09-09T19:28:26Z", "author": {"login": "aaltay"}, "path": "sdks/python/setup.py", "diffHunk": "@@ -165,6 +165,7 @@ def get_version():\n     'requests>=2.24.0,<3.0.0',\n     'typing>=3.7.0,<3.8.0; python_full_version < \"3.5.3\"',\n     'typing-extensions>=3.7.0,<3.8.0',\n+    'mmh3>=2.5.1,<2.5.2',", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MzI2MA=="}, "originalCommit": {"oid": "a83c0db039aa4784a0cca3cd8fff9ad7eac17327"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzOTc1MDA5OnYy", "diffSide": "RIGHT", "path": "sdks/python/container/base_image_requirements.txt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMzozMTowMlrOHPdrmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMzozMTowMlrOHPdrmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk3Njk4Nw==", "bodyText": "For this file, you can pick a specific version instead of a range.", "url": "https://github.com/apache/beam/pull/12756#discussion_r485976987", "createdAt": "2020-09-09T23:31:02Z", "author": {"login": "aaltay"}, "path": "sdks/python/container/base_image_requirements.txt", "diffHunk": "@@ -57,6 +57,7 @@ google-cloud-datastore==1.7.4\n cython==0.29.13\n guppy==0.1.11;python_version<=\"2.7\"\n guppy3==3.0.9;python_version>=\"3.5\"\n+mmh3>=2.5.1,<3.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25bc7b40446679ec57133bcde9a2f1f4eed9ad81"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzOTc5MDAwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/transforms/stats_test.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMzo1MDo1NlrOHPeCQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNTozNjoyNVrOHPjvzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4Mjc4NQ==", "bodyText": "Is this line a left-over?", "url": "https://github.com/apache/beam/pull/12756#discussion_r485982785", "createdAt": "2020-09-09T23:50:56Z", "author": {"login": "tvalentyn"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -41,355 +41,88 @@\n from apache_beam.transforms.display import DisplayData\n from apache_beam.transforms.display_test import DisplayDataItemMatcher\n from apache_beam.transforms.stats import ApproximateQuantilesCombineFn\n+from apache_beam.transforms.stats import ApproximateUniqueCombineFn\n \n+try:\n+  import mmh3\n+  mmh3_options = [(mmh3, ), (None, )]\n+except ImportError:\n+  mmh3_options = [(None, )]\n \n-class ApproximateUniqueTest(unittest.TestCase):\n-  \"\"\"Unit tests for ApproximateUnique.Globally and ApproximateUnique.PerKey.\n-  Hash() with Python3 is nondeterministic, so Approximation algorithm generates\n-  different result each time and sometimes error rate is out of range, so add\n-  retries for all tests who actually running approximation algorithm.\"\"\"\n-  def test_approximate_unique_global_by_invalid_size(self):\n-    # test if the transformation throws an error as expected with an invalid\n-    # small input size (< 16).\n-    sample_size = 10\n-    test_input = [random.randint(0, 1000) for _ in range(100)]\n-\n-    with self.assertRaises(ValueError) as e:\n-      with TestPipeline() as pipeline:\n-        _ = (\n-            pipeline\n-            | 'create' >> beam.Create(test_input)\n-            |\n-            'get_estimate' >> beam.ApproximateUnique.Globally(size=sample_size))\n-\n-    expected_msg = beam.ApproximateUnique._INPUT_SIZE_ERR_MSG % (sample_size)\n-\n-    assert e.exception.args[0] == expected_msg\n-\n-  def test_approximate_unique_global_by_invalid_type_size(self):\n-    # test if the transformation throws an error as expected with an invalid\n-    # type of input size (not int).\n-    sample_size = 100.0\n-    test_input = [random.randint(0, 1000) for _ in range(100)]\n-\n-    with self.assertRaises(ValueError) as e:\n-      with TestPipeline() as pipeline:\n-        _ = (\n-            pipeline\n-            | 'create' >> beam.Create(test_input)\n-            |\n-            'get_estimate' >> beam.ApproximateUnique.Globally(size=sample_size))\n-\n-    expected_msg = beam.ApproximateUnique._INPUT_SIZE_ERR_MSG % (sample_size)\n-\n-    assert e.exception.args[0] == expected_msg\n-\n-  def test_approximate_unique_global_by_invalid_small_error(self):\n-    # test if the transformation throws an error as expected with an invalid\n-    # small input error (< 0.01).\n-    est_err = 0.0\n-    test_input = [random.randint(0, 1000) for _ in range(100)]\n-\n-    with self.assertRaises(ValueError) as e:\n-      with TestPipeline() as pipeline:\n-        _ = (\n-            pipeline\n-            | 'create' >> beam.Create(test_input)\n-            | 'get_estimate' >> beam.ApproximateUnique.Globally(error=est_err))\n-\n-    expected_msg = beam.ApproximateUnique._INPUT_ERROR_ERR_MSG % (est_err)\n-\n-    assert e.exception.args[0] == expected_msg\n-\n-  def test_approximate_unique_global_by_invalid_big_error(self):\n-    # test if the transformation throws an error as expected with an invalid\n-    # big input error (> 0.50).\n-    est_err = 0.6\n-    test_input = [random.randint(0, 1000) for _ in range(100)]\n-\n-    with self.assertRaises(ValueError) as e:\n-      with TestPipeline() as pipeline:\n-        _ = (\n-            pipeline\n-            | 'create' >> beam.Create(test_input)\n-            | 'get_estimate' >> beam.ApproximateUnique.Globally(error=est_err))\n-\n-    expected_msg = beam.ApproximateUnique._INPUT_ERROR_ERR_MSG % (est_err)\n-\n-    assert e.exception.args[0] == expected_msg\n-\n-  def test_approximate_unique_global_by_invalid_no_input(self):\n-    # test if the transformation throws an error as expected with no input.\n-    test_input = [random.randint(0, 1000) for _ in range(100)]\n-\n-    with self.assertRaises(ValueError) as e:\n-      with TestPipeline() as pipeline:\n-        _ = (\n-            pipeline\n-            | 'create' >> beam.Create(test_input)\n-            | 'get_estimate' >> beam.ApproximateUnique.Globally())\n-\n-    expected_msg = beam.ApproximateUnique._NO_VALUE_ERR_MSG\n-    assert e.exception.args[0] == expected_msg\n-\n-  def test_approximate_unique_global_by_invalid_both_input(self):\n-    # test if the transformation throws an error as expected with multi input.\n-    test_input = [random.randint(0, 1000) for _ in range(100)]\n-    est_err = 0.2\n-    sample_size = 30\n-\n-    with self.assertRaises(ValueError) as e:\n-      with TestPipeline() as pipeline:\n-        _ = (\n-            pipeline\n-            | 'create' >> beam.Create(test_input)\n-            | 'get_estimate' >> beam.ApproximateUnique.Globally(\n-                size=sample_size, error=est_err))\n-\n-    expected_msg = beam.ApproximateUnique._MULTI_VALUE_ERR_MSG % (\n-        sample_size, est_err)\n-\n-    assert e.exception.args[0] == expected_msg\n-\n-  def test_get_sample_size_from_est_error(self):\n-    # test if get correct sample size from input error.\n-    assert beam.ApproximateUnique._get_sample_size_from_est_error(0.5) == 16\n-    assert beam.ApproximateUnique._get_sample_size_from_est_error(0.4) == 25\n-    assert beam.ApproximateUnique._get_sample_size_from_est_error(0.2) == 100\n-    assert beam.ApproximateUnique._get_sample_size_from_est_error(0.1) == 400\n-    assert beam.ApproximateUnique._get_sample_size_from_est_error(0.05) == 1600\n-    assert beam.ApproximateUnique._get_sample_size_from_est_error(0.01) == 40000\n-\n-  @unittest.skip(\n-      'Skip it because hash function is not good enough. '\n-      'TODO: BEAM-7654')\n-  def test_approximate_unique_global_by_sample_size(self):\n-    # test if estimation error with a given sample size is not greater than\n-    # expected max error.\n-    sample_size = 16\n-    max_err = 2 / math.sqrt(sample_size)\n-    test_input = [\n-        4,\n-        34,\n-        29,\n-        46,\n-        80,\n-        66,\n-        51,\n-        81,\n-        31,\n-        9,\n-        26,\n-        36,\n-        10,\n-        41,\n-        90,\n-        35,\n-        33,\n-        19,\n-        88,\n-        86,\n-        28,\n-        93,\n-        38,\n-        76,\n-        15,\n-        87,\n-        12,\n-        39,\n-        84,\n-        13,\n-        32,\n-        49,\n-        65,\n-        100,\n-        16,\n-        27,\n-        23,\n-        30,\n-        96,\n-        54\n-    ]\n-\n-    actual_count = len(set(test_input))\n-\n-    with TestPipeline() as pipeline:\n-      result = (\n-          pipeline\n-          | 'create' >> beam.Create(test_input)\n-          | 'get_estimate' >> beam.ApproximateUnique.Globally(size=sample_size)\n-          | 'compare' >> beam.FlatMap(\n-              lambda x: [abs(x - actual_count) * 1.0 / actual_count <= max_err])\n-      )\n-\n-      assert_that(result, equal_to([True]), label='assert:global_by_size')\n-\n-  @retry(reraise=True, stop=stop_after_attempt(5))\n-  def test_approximate_unique_global_by_sample_size_with_duplicates(self):\n-    # test if estimation error with a given sample size is not greater than\n-    # expected max error with duplicated input.\n-    sample_size = 30\n-    max_err = 2 / math.sqrt(sample_size)\n-    test_input = [10] * 50 + [20] * 50\n-    actual_count = len(set(test_input))\n-\n-    with TestPipeline() as pipeline:\n-      result = (\n-          pipeline\n-          | 'create' >> beam.Create(test_input)\n-          | 'get_estimate' >> beam.ApproximateUnique.Globally(size=sample_size)\n-          | 'compare' >> beam.FlatMap(\n-              lambda x: [abs(x - actual_count) * 1.0 / actual_count <= max_err])\n-      )\n-\n-      assert_that(\n-          result,\n-          equal_to([True]),\n-          label='assert:global_by_size_with_duplicates')\n-\n-  @retry(reraise=True, stop=stop_after_attempt(5))\n-  def test_approximate_unique_global_by_sample_size_with_small_population(self):\n-    # test if estimation is exactly same to actual value when sample size is\n-    # not smaller than population size (sample size > 100% of population).\n-    sample_size = 31\n-    test_input = [\n-        144,\n-        160,\n-        229,\n-        923,\n-        390,\n-        756,\n-        674,\n-        769,\n-        145,\n-        888,\n-        809,\n-        159,\n-        222,\n-        101,\n-        943,\n-        901,\n-        876,\n-        194,\n-        232,\n-        631,\n-        221,\n-        829,\n-        965,\n-        729,\n-        35,\n-        33,\n-        115,\n-        894,\n-        827,\n-        364\n-    ]\n-    actual_count = len(set(test_input))\n \n-    with TestPipeline() as pipeline:\n-      result = (\n-          pipeline\n-          | 'create' >> beam.Create(test_input)\n-          | 'get_estimate' >> beam.ApproximateUnique.Globally(size=sample_size))\n-\n-      assert_that(\n-          result,\n-          equal_to([actual_count]),\n-          label='assert:global_by_sample_size_with_small_population')\n-\n-  @unittest.skip(\n-      'Skip because hash function is not good enough. '\n-      'TODO: BEAM-7654')\n-  def test_approximate_unique_global_by_error(self):\n-    # test if estimation error from input error is not greater than input error.\n-    est_err = 0.3\n-    test_input = [\n-        291,\n-        371,\n-        271,\n-        126,\n-        762,\n-        391,\n-        222,\n-        565,\n-        428,\n-        786,\n-        801,\n-        867,\n-        337,\n-        690,\n-        261,\n-        436,\n-        311,\n-        568,\n-        946,\n-        722,\n-        973,\n-        386,\n-        506,\n-        546,\n-        991,\n-        450,\n-        226,\n-        889,\n-        514,\n-        693\n-    ]\n+@parameterized_class(('sys.modules[\\'mmh3\\']', ), mmh3_options)\n+class ApproximateUniqueTest(unittest.TestCase):\n+  \"\"\"Unit tests for ApproximateUnique.Globally, ApproximateUnique.PerKey,\n+  and ApproximateUniqueCombineFn.\n+  \"\"\"\n+  random.seed(0)\n+  sys.modules['mmh3'] = None", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc30e8a7cbb12e3894c880acd749904dc5e56764"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA3NjM2Ng==", "bodyText": "that was deliberate, but it bothered me as well. done.", "url": "https://github.com/apache/beam/pull/12756#discussion_r486076366", "createdAt": "2020-09-10T05:36:25Z", "author": {"login": "monicadsong"}, "path": "sdks/python/apache_beam/transforms/stats_test.py", "diffHunk": "@@ -41,355 +41,88 @@\n from apache_beam.transforms.display import DisplayData\n from apache_beam.transforms.display_test import DisplayDataItemMatcher\n from apache_beam.transforms.stats import ApproximateQuantilesCombineFn\n+from apache_beam.transforms.stats import ApproximateUniqueCombineFn\n \n+try:\n+  import mmh3\n+  mmh3_options = [(mmh3, ), (None, )]\n+except ImportError:\n+  mmh3_options = [(None, )]\n \n-class ApproximateUniqueTest(unittest.TestCase):\n-  \"\"\"Unit tests for ApproximateUnique.Globally and ApproximateUnique.PerKey.\n-  Hash() with Python3 is nondeterministic, so Approximation algorithm generates\n-  different result each time and sometimes error rate is out of range, so add\n-  retries for all tests who actually running approximation algorithm.\"\"\"\n-  def test_approximate_unique_global_by_invalid_size(self):\n-    # test if the transformation throws an error as expected with an invalid\n-    # small input size (< 16).\n-    sample_size = 10\n-    test_input = [random.randint(0, 1000) for _ in range(100)]\n-\n-    with self.assertRaises(ValueError) as e:\n-      with TestPipeline() as pipeline:\n-        _ = (\n-            pipeline\n-            | 'create' >> beam.Create(test_input)\n-            |\n-            'get_estimate' >> beam.ApproximateUnique.Globally(size=sample_size))\n-\n-    expected_msg = beam.ApproximateUnique._INPUT_SIZE_ERR_MSG % (sample_size)\n-\n-    assert e.exception.args[0] == expected_msg\n-\n-  def test_approximate_unique_global_by_invalid_type_size(self):\n-    # test if the transformation throws an error as expected with an invalid\n-    # type of input size (not int).\n-    sample_size = 100.0\n-    test_input = [random.randint(0, 1000) for _ in range(100)]\n-\n-    with self.assertRaises(ValueError) as e:\n-      with TestPipeline() as pipeline:\n-        _ = (\n-            pipeline\n-            | 'create' >> beam.Create(test_input)\n-            |\n-            'get_estimate' >> beam.ApproximateUnique.Globally(size=sample_size))\n-\n-    expected_msg = beam.ApproximateUnique._INPUT_SIZE_ERR_MSG % (sample_size)\n-\n-    assert e.exception.args[0] == expected_msg\n-\n-  def test_approximate_unique_global_by_invalid_small_error(self):\n-    # test if the transformation throws an error as expected with an invalid\n-    # small input error (< 0.01).\n-    est_err = 0.0\n-    test_input = [random.randint(0, 1000) for _ in range(100)]\n-\n-    with self.assertRaises(ValueError) as e:\n-      with TestPipeline() as pipeline:\n-        _ = (\n-            pipeline\n-            | 'create' >> beam.Create(test_input)\n-            | 'get_estimate' >> beam.ApproximateUnique.Globally(error=est_err))\n-\n-    expected_msg = beam.ApproximateUnique._INPUT_ERROR_ERR_MSG % (est_err)\n-\n-    assert e.exception.args[0] == expected_msg\n-\n-  def test_approximate_unique_global_by_invalid_big_error(self):\n-    # test if the transformation throws an error as expected with an invalid\n-    # big input error (> 0.50).\n-    est_err = 0.6\n-    test_input = [random.randint(0, 1000) for _ in range(100)]\n-\n-    with self.assertRaises(ValueError) as e:\n-      with TestPipeline() as pipeline:\n-        _ = (\n-            pipeline\n-            | 'create' >> beam.Create(test_input)\n-            | 'get_estimate' >> beam.ApproximateUnique.Globally(error=est_err))\n-\n-    expected_msg = beam.ApproximateUnique._INPUT_ERROR_ERR_MSG % (est_err)\n-\n-    assert e.exception.args[0] == expected_msg\n-\n-  def test_approximate_unique_global_by_invalid_no_input(self):\n-    # test if the transformation throws an error as expected with no input.\n-    test_input = [random.randint(0, 1000) for _ in range(100)]\n-\n-    with self.assertRaises(ValueError) as e:\n-      with TestPipeline() as pipeline:\n-        _ = (\n-            pipeline\n-            | 'create' >> beam.Create(test_input)\n-            | 'get_estimate' >> beam.ApproximateUnique.Globally())\n-\n-    expected_msg = beam.ApproximateUnique._NO_VALUE_ERR_MSG\n-    assert e.exception.args[0] == expected_msg\n-\n-  def test_approximate_unique_global_by_invalid_both_input(self):\n-    # test if the transformation throws an error as expected with multi input.\n-    test_input = [random.randint(0, 1000) for _ in range(100)]\n-    est_err = 0.2\n-    sample_size = 30\n-\n-    with self.assertRaises(ValueError) as e:\n-      with TestPipeline() as pipeline:\n-        _ = (\n-            pipeline\n-            | 'create' >> beam.Create(test_input)\n-            | 'get_estimate' >> beam.ApproximateUnique.Globally(\n-                size=sample_size, error=est_err))\n-\n-    expected_msg = beam.ApproximateUnique._MULTI_VALUE_ERR_MSG % (\n-        sample_size, est_err)\n-\n-    assert e.exception.args[0] == expected_msg\n-\n-  def test_get_sample_size_from_est_error(self):\n-    # test if get correct sample size from input error.\n-    assert beam.ApproximateUnique._get_sample_size_from_est_error(0.5) == 16\n-    assert beam.ApproximateUnique._get_sample_size_from_est_error(0.4) == 25\n-    assert beam.ApproximateUnique._get_sample_size_from_est_error(0.2) == 100\n-    assert beam.ApproximateUnique._get_sample_size_from_est_error(0.1) == 400\n-    assert beam.ApproximateUnique._get_sample_size_from_est_error(0.05) == 1600\n-    assert beam.ApproximateUnique._get_sample_size_from_est_error(0.01) == 40000\n-\n-  @unittest.skip(\n-      'Skip it because hash function is not good enough. '\n-      'TODO: BEAM-7654')\n-  def test_approximate_unique_global_by_sample_size(self):\n-    # test if estimation error with a given sample size is not greater than\n-    # expected max error.\n-    sample_size = 16\n-    max_err = 2 / math.sqrt(sample_size)\n-    test_input = [\n-        4,\n-        34,\n-        29,\n-        46,\n-        80,\n-        66,\n-        51,\n-        81,\n-        31,\n-        9,\n-        26,\n-        36,\n-        10,\n-        41,\n-        90,\n-        35,\n-        33,\n-        19,\n-        88,\n-        86,\n-        28,\n-        93,\n-        38,\n-        76,\n-        15,\n-        87,\n-        12,\n-        39,\n-        84,\n-        13,\n-        32,\n-        49,\n-        65,\n-        100,\n-        16,\n-        27,\n-        23,\n-        30,\n-        96,\n-        54\n-    ]\n-\n-    actual_count = len(set(test_input))\n-\n-    with TestPipeline() as pipeline:\n-      result = (\n-          pipeline\n-          | 'create' >> beam.Create(test_input)\n-          | 'get_estimate' >> beam.ApproximateUnique.Globally(size=sample_size)\n-          | 'compare' >> beam.FlatMap(\n-              lambda x: [abs(x - actual_count) * 1.0 / actual_count <= max_err])\n-      )\n-\n-      assert_that(result, equal_to([True]), label='assert:global_by_size')\n-\n-  @retry(reraise=True, stop=stop_after_attempt(5))\n-  def test_approximate_unique_global_by_sample_size_with_duplicates(self):\n-    # test if estimation error with a given sample size is not greater than\n-    # expected max error with duplicated input.\n-    sample_size = 30\n-    max_err = 2 / math.sqrt(sample_size)\n-    test_input = [10] * 50 + [20] * 50\n-    actual_count = len(set(test_input))\n-\n-    with TestPipeline() as pipeline:\n-      result = (\n-          pipeline\n-          | 'create' >> beam.Create(test_input)\n-          | 'get_estimate' >> beam.ApproximateUnique.Globally(size=sample_size)\n-          | 'compare' >> beam.FlatMap(\n-              lambda x: [abs(x - actual_count) * 1.0 / actual_count <= max_err])\n-      )\n-\n-      assert_that(\n-          result,\n-          equal_to([True]),\n-          label='assert:global_by_size_with_duplicates')\n-\n-  @retry(reraise=True, stop=stop_after_attempt(5))\n-  def test_approximate_unique_global_by_sample_size_with_small_population(self):\n-    # test if estimation is exactly same to actual value when sample size is\n-    # not smaller than population size (sample size > 100% of population).\n-    sample_size = 31\n-    test_input = [\n-        144,\n-        160,\n-        229,\n-        923,\n-        390,\n-        756,\n-        674,\n-        769,\n-        145,\n-        888,\n-        809,\n-        159,\n-        222,\n-        101,\n-        943,\n-        901,\n-        876,\n-        194,\n-        232,\n-        631,\n-        221,\n-        829,\n-        965,\n-        729,\n-        35,\n-        33,\n-        115,\n-        894,\n-        827,\n-        364\n-    ]\n-    actual_count = len(set(test_input))\n \n-    with TestPipeline() as pipeline:\n-      result = (\n-          pipeline\n-          | 'create' >> beam.Create(test_input)\n-          | 'get_estimate' >> beam.ApproximateUnique.Globally(size=sample_size))\n-\n-      assert_that(\n-          result,\n-          equal_to([actual_count]),\n-          label='assert:global_by_sample_size_with_small_population')\n-\n-  @unittest.skip(\n-      'Skip because hash function is not good enough. '\n-      'TODO: BEAM-7654')\n-  def test_approximate_unique_global_by_error(self):\n-    # test if estimation error from input error is not greater than input error.\n-    est_err = 0.3\n-    test_input = [\n-        291,\n-        371,\n-        271,\n-        126,\n-        762,\n-        391,\n-        222,\n-        565,\n-        428,\n-        786,\n-        801,\n-        867,\n-        337,\n-        690,\n-        261,\n-        436,\n-        311,\n-        568,\n-        946,\n-        722,\n-        973,\n-        386,\n-        506,\n-        546,\n-        991,\n-        450,\n-        226,\n-        889,\n-        514,\n-        693\n-    ]\n+@parameterized_class(('sys.modules[\\'mmh3\\']', ), mmh3_options)\n+class ApproximateUniqueTest(unittest.TestCase):\n+  \"\"\"Unit tests for ApproximateUnique.Globally, ApproximateUnique.PerKey,\n+  and ApproximateUniqueCombineFn.\n+  \"\"\"\n+  random.seed(0)\n+  sys.modules['mmh3'] = None", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4Mjc4NQ=="}, "originalCommit": {"oid": "cc30e8a7cbb12e3894c880acd749904dc5e56764"}, "originalPosition": 330}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzOTc5Njk3OnYy", "diffSide": "LEFT", "path": "sdks/python/container/license_scripts/dep_urls_py.yaml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMzo1NDo1N1rOHPeGdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwMDowMDozM1rOHPeNLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4Mzg2MA==", "bodyText": "so pip-licences tool is able to automatically fetch the license for mmh3? If so, great! If not, we will need this line, since we will ship mmh3 in our containers.", "url": "https://github.com/apache/beam/pull/12756#discussion_r485983860", "createdAt": "2020-09-09T23:54:57Z", "author": {"login": "tvalentyn"}, "path": "sdks/python/container/license_scripts/dep_urls_py.yaml", "diffHunk": "@@ -77,8 +77,6 @@ pip_dependencies:\n     license: \"https://raw.githubusercontent.com/mtth/hdfs/master/LICENSE\"\n   httplib2:\n     license: \"https://raw.githubusercontent.com/httplib2/httplib2/master/LICENSE\"\n-  mmh3:\n-    license: \"https://raw.githubusercontent.com/hajimes/mmh3/master/LICENSE\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea1231a514bf05716f2565ba35de79586d69ccce"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4NTU4MA==", "bodyText": "hmm probably not-- will add it back in", "url": "https://github.com/apache/beam/pull/12756#discussion_r485985580", "createdAt": "2020-09-10T00:00:33Z", "author": {"login": "monicadsong"}, "path": "sdks/python/container/license_scripts/dep_urls_py.yaml", "diffHunk": "@@ -77,8 +77,6 @@ pip_dependencies:\n     license: \"https://raw.githubusercontent.com/mtth/hdfs/master/LICENSE\"\n   httplib2:\n     license: \"https://raw.githubusercontent.com/httplib2/httplib2/master/LICENSE\"\n-  mmh3:\n-    license: \"https://raw.githubusercontent.com/hajimes/mmh3/master/LICENSE\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4Mzg2MA=="}, "originalCommit": {"oid": "ea1231a514bf05716f2565ba35de79586d69ccce"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzOTc5ODQwOnYy", "diffSide": "LEFT", "path": "sdks/python/container/license_scripts/dep_urls_py.yaml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMzo1NTo0MFrOHPeHTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwMDowMDowMFrOHPeMkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4NDA3Nw==", "bodyText": "Actually should we keep this since it will be in the container?", "url": "https://github.com/apache/beam/pull/12756#discussion_r485984077", "createdAt": "2020-09-09T23:55:40Z", "author": {"login": "aaltay"}, "path": "sdks/python/container/license_scripts/dep_urls_py.yaml", "diffHunk": "@@ -77,8 +77,6 @@ pip_dependencies:\n     license: \"https://raw.githubusercontent.com/mtth/hdfs/master/LICENSE\"\n   httplib2:\n     license: \"https://raw.githubusercontent.com/httplib2/httplib2/master/LICENSE\"\n-  mmh3:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea1231a514bf05716f2565ba35de79586d69ccce"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4NTQyNg==", "bodyText": "oh whoops, will add that back in", "url": "https://github.com/apache/beam/pull/12756#discussion_r485985426", "createdAt": "2020-09-10T00:00:00Z", "author": {"login": "monicadsong"}, "path": "sdks/python/container/license_scripts/dep_urls_py.yaml", "diffHunk": "@@ -77,8 +77,6 @@ pip_dependencies:\n     license: \"https://raw.githubusercontent.com/mtth/hdfs/master/LICENSE\"\n   httplib2:\n     license: \"https://raw.githubusercontent.com/httplib2/httplib2/master/LICENSE\"\n-  mmh3:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4NDA3Nw=="}, "originalCommit": {"oid": "ea1231a514bf05716f2565ba35de79586d69ccce"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 433, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}