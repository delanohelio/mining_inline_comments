{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5MTUzMDI1", "number": 10501, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMVQwMDoyNjoyMVrODXTRaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMVQwMTozNTowOVrODXTnRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1NzU5NTk1OnYy", "diffSide": "RIGHT", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMVQwMDoyNjoyMVrOFcjIGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMVQwMDoyNjoyMVrOFcjIGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3OTk2MQ==", "bodyText": "0 based index of the current element being processed(?).", "url": "https://github.com/apache/beam/pull/10501#discussion_r365479961", "createdAt": "2020-01-11T00:26:21Z", "author": {"login": "robertwb"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -131,6 +137,11 @@\n   private final BeamFnDataClient beamFnDataClient;\n   private final Coder<WindowedValue<OutputT>> coder;\n \n+  private final Object splittingLock = new Object();\n+  // 0-based count of the number of elements", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4f0a05889450257ccabfe78a171bb0a4e3b3d19"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1NzU5NjcyOnYy", "diffSide": "RIGHT", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMVQwMDoyNjo1NVrOFcjIfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzo1NDoxMFrOFc_W8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MDA2Mg==", "bodyText": "0-based index of the first element to not process. (Or is this the last element to process?)", "url": "https://github.com/apache/beam/pull/10501#discussion_r365480062", "createdAt": "2020-01-11T00:26:55Z", "author": {"login": "robertwb"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -131,6 +137,11 @@\n   private final BeamFnDataClient beamFnDataClient;\n   private final Coder<WindowedValue<OutputT>> coder;\n \n+  private final Object splittingLock = new Object();\n+  // 0-based count of the number of elements\n+  private long index = -1;\n+  // 0-based count of the number of elements", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4f0a05889450257ccabfe78a171bb0a4e3b3d19"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0MjUxMg==", "bodyText": "first element to not process.", "url": "https://github.com/apache/beam/pull/10501#discussion_r365942512", "createdAt": "2020-01-13T17:54:10Z", "author": {"login": "lukecwik"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -131,6 +137,11 @@\n   private final BeamFnDataClient beamFnDataClient;\n   private final Coder<WindowedValue<OutputT>> coder;\n \n+  private final Object splittingLock = new Object();\n+  // 0-based count of the number of elements\n+  private long index = -1;\n+  // 0-based count of the number of elements", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MDA2Mg=="}, "originalCommit": {"oid": "a4f0a05889450257ccabfe78a171bb0a4e3b3d19"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1NzYxOTE3OnYy", "diffSide": "RIGHT", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMVQwMDo0ODo1MVrOFcjViw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzozMjo1NFrOFc-uyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MzQwMw==", "bodyText": "Should this be an else clause below?", "url": "https://github.com/apache/beam/pull/10501#discussion_r365483403", "createdAt": "2020-01-11T00:48:51Z", "author": {"login": "robertwb"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -170,7 +181,109 @@ public void registerInputLocation() {\n             apiServiceDescriptor,\n             LogicalEndpoint.of(processBundleInstructionIdSupplier.get(), pTransformId),\n             coder,\n-            consumer);\n+            this::forwardElementToConsumer);\n+  }\n+\n+  public void forwardElementToConsumer(WindowedValue<OutputT> element) throws Exception {\n+    synchronized (splittingLock) {\n+      if (index == stopIndex - 1) {\n+        return;\n+      }\n+      index += 1;\n+    }\n+    consumer.accept(element);\n+  }\n+\n+  public void split(\n+      ProcessBundleSplitRequest request, ProcessBundleSplitResponse.Builder response) {\n+    DesiredSplit desiredSplit = request.getDesiredSplitsMap().get(pTransformId);\n+    if (desiredSplit == null) {\n+      return;\n+    }\n+\n+    long totalBufferSize = desiredSplit.getEstimatedInputElements();\n+\n+    HandlesSplits splittingConsumer = null;\n+    if (consumer instanceof HandlesSplits) {\n+      splittingConsumer = ((HandlesSplits) consumer);\n+    }\n+\n+    synchronized (splittingLock) {\n+      // Since we hold the splittingLock, we guarantee that we will not pass the next element\n+      // to the downstream consumer. We still have a race where the downstream consumer may\n+      // have yet to see the element or has completed processing the element by the time\n+      // we ask it to split (even after we have asked for its progress).\n+\n+      // If the split request we received was delayed and is less then the known number of elements\n+      // then use \"index + 1\" as the total size. Similarly, if we have already split and the\n+      // split request is bounded incorrectly, use the stop index as the upper bound.\n+      if (totalBufferSize < index + 1) {\n+        totalBufferSize = index + 1;\n+      } else if (totalBufferSize > stopIndex) {\n+        totalBufferSize = stopIndex;\n+      }\n+\n+      // In the case where we have yet to process an element, set the current element progress to 1.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4f0a05889450257ccabfe78a171bb0a4e3b3d19"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzMjIzNQ==", "bodyText": "Its logically the same where the else clause is the default based upon what we initialize.", "url": "https://github.com/apache/beam/pull/10501#discussion_r365932235", "createdAt": "2020-01-13T17:32:54Z", "author": {"login": "lukecwik"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -170,7 +181,109 @@ public void registerInputLocation() {\n             apiServiceDescriptor,\n             LogicalEndpoint.of(processBundleInstructionIdSupplier.get(), pTransformId),\n             coder,\n-            consumer);\n+            this::forwardElementToConsumer);\n+  }\n+\n+  public void forwardElementToConsumer(WindowedValue<OutputT> element) throws Exception {\n+    synchronized (splittingLock) {\n+      if (index == stopIndex - 1) {\n+        return;\n+      }\n+      index += 1;\n+    }\n+    consumer.accept(element);\n+  }\n+\n+  public void split(\n+      ProcessBundleSplitRequest request, ProcessBundleSplitResponse.Builder response) {\n+    DesiredSplit desiredSplit = request.getDesiredSplitsMap().get(pTransformId);\n+    if (desiredSplit == null) {\n+      return;\n+    }\n+\n+    long totalBufferSize = desiredSplit.getEstimatedInputElements();\n+\n+    HandlesSplits splittingConsumer = null;\n+    if (consumer instanceof HandlesSplits) {\n+      splittingConsumer = ((HandlesSplits) consumer);\n+    }\n+\n+    synchronized (splittingLock) {\n+      // Since we hold the splittingLock, we guarantee that we will not pass the next element\n+      // to the downstream consumer. We still have a race where the downstream consumer may\n+      // have yet to see the element or has completed processing the element by the time\n+      // we ask it to split (even after we have asked for its progress).\n+\n+      // If the split request we received was delayed and is less then the known number of elements\n+      // then use \"index + 1\" as the total size. Similarly, if we have already split and the\n+      // split request is bounded incorrectly, use the stop index as the upper bound.\n+      if (totalBufferSize < index + 1) {\n+        totalBufferSize = index + 1;\n+      } else if (totalBufferSize > stopIndex) {\n+        totalBufferSize = stopIndex;\n+      }\n+\n+      // In the case where we have yet to process an element, set the current element progress to 1.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MzQwMw=="}, "originalCommit": {"oid": "a4f0a05889450257ccabfe78a171bb0a4e3b3d19"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1NzY1MTg4OnYy", "diffSide": "RIGHT", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMVQwMTozNTowOVrOFcjo1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzo1NTowNFrOFc_Y4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4ODM0Mw==", "bodyText": "Compute the number of elements that we should \"keep.\"", "url": "https://github.com/apache/beam/pull/10501#discussion_r365488343", "createdAt": "2020-01-11T01:35:09Z", "author": {"login": "robertwb"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -170,7 +181,109 @@ public void registerInputLocation() {\n             apiServiceDescriptor,\n             LogicalEndpoint.of(processBundleInstructionIdSupplier.get(), pTransformId),\n             coder,\n-            consumer);\n+            this::forwardElementToConsumer);\n+  }\n+\n+  public void forwardElementToConsumer(WindowedValue<OutputT> element) throws Exception {\n+    synchronized (splittingLock) {\n+      if (index == stopIndex - 1) {\n+        return;\n+      }\n+      index += 1;\n+    }\n+    consumer.accept(element);\n+  }\n+\n+  public void split(\n+      ProcessBundleSplitRequest request, ProcessBundleSplitResponse.Builder response) {\n+    DesiredSplit desiredSplit = request.getDesiredSplitsMap().get(pTransformId);\n+    if (desiredSplit == null) {\n+      return;\n+    }\n+\n+    long totalBufferSize = desiredSplit.getEstimatedInputElements();\n+\n+    HandlesSplits splittingConsumer = null;\n+    if (consumer instanceof HandlesSplits) {\n+      splittingConsumer = ((HandlesSplits) consumer);\n+    }\n+\n+    synchronized (splittingLock) {\n+      // Since we hold the splittingLock, we guarantee that we will not pass the next element\n+      // to the downstream consumer. We still have a race where the downstream consumer may\n+      // have yet to see the element or has completed processing the element by the time\n+      // we ask it to split (even after we have asked for its progress).\n+\n+      // If the split request we received was delayed and is less then the known number of elements\n+      // then use \"index + 1\" as the total size. Similarly, if we have already split and the\n+      // split request is bounded incorrectly, use the stop index as the upper bound.\n+      if (totalBufferSize < index + 1) {\n+        totalBufferSize = index + 1;\n+      } else if (totalBufferSize > stopIndex) {\n+        totalBufferSize = stopIndex;\n+      }\n+\n+      // In the case where we have yet to process an element, set the current element progress to 1.\n+      double currentElementProgress = 1;\n+\n+      // If we have started processing at least one element, attempt to get the downstream\n+      // progress defaulting to 0.5 if no progress was able to get fetched.\n+      if (index >= 0) {\n+        if (splittingConsumer != null) {\n+          currentElementProgress = splittingConsumer.getProgress();\n+        } else {\n+          currentElementProgress = 0.5;\n+        }\n+      }\n+\n+      checkArgument(\n+          desiredSplit.getAllowedSplitPointsList().isEmpty(),\n+          \"TODO: BEAM-3836, support split point restrictions.\");\n+\n+      // Now figure out where to split.\n+      //\n+      // The units here (except for keepOfElementRemainder) are all in terms of number or\n+      // (possibly fractional) elements.\n+\n+      // Compute the amount of \"remaining\" work that we know of.\n+      double remainder = totalBufferSize - index - currentElementProgress;\n+      // Compute the fraction of work that we should \"keep\".", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4f0a05889450257ccabfe78a171bb0a4e3b3d19"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0MzAwOQ==", "bodyText": "Done", "url": "https://github.com/apache/beam/pull/10501#discussion_r365943009", "createdAt": "2020-01-13T17:55:04Z", "author": {"login": "lukecwik"}, "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -170,7 +181,109 @@ public void registerInputLocation() {\n             apiServiceDescriptor,\n             LogicalEndpoint.of(processBundleInstructionIdSupplier.get(), pTransformId),\n             coder,\n-            consumer);\n+            this::forwardElementToConsumer);\n+  }\n+\n+  public void forwardElementToConsumer(WindowedValue<OutputT> element) throws Exception {\n+    synchronized (splittingLock) {\n+      if (index == stopIndex - 1) {\n+        return;\n+      }\n+      index += 1;\n+    }\n+    consumer.accept(element);\n+  }\n+\n+  public void split(\n+      ProcessBundleSplitRequest request, ProcessBundleSplitResponse.Builder response) {\n+    DesiredSplit desiredSplit = request.getDesiredSplitsMap().get(pTransformId);\n+    if (desiredSplit == null) {\n+      return;\n+    }\n+\n+    long totalBufferSize = desiredSplit.getEstimatedInputElements();\n+\n+    HandlesSplits splittingConsumer = null;\n+    if (consumer instanceof HandlesSplits) {\n+      splittingConsumer = ((HandlesSplits) consumer);\n+    }\n+\n+    synchronized (splittingLock) {\n+      // Since we hold the splittingLock, we guarantee that we will not pass the next element\n+      // to the downstream consumer. We still have a race where the downstream consumer may\n+      // have yet to see the element or has completed processing the element by the time\n+      // we ask it to split (even after we have asked for its progress).\n+\n+      // If the split request we received was delayed and is less then the known number of elements\n+      // then use \"index + 1\" as the total size. Similarly, if we have already split and the\n+      // split request is bounded incorrectly, use the stop index as the upper bound.\n+      if (totalBufferSize < index + 1) {\n+        totalBufferSize = index + 1;\n+      } else if (totalBufferSize > stopIndex) {\n+        totalBufferSize = stopIndex;\n+      }\n+\n+      // In the case where we have yet to process an element, set the current element progress to 1.\n+      double currentElementProgress = 1;\n+\n+      // If we have started processing at least one element, attempt to get the downstream\n+      // progress defaulting to 0.5 if no progress was able to get fetched.\n+      if (index >= 0) {\n+        if (splittingConsumer != null) {\n+          currentElementProgress = splittingConsumer.getProgress();\n+        } else {\n+          currentElementProgress = 0.5;\n+        }\n+      }\n+\n+      checkArgument(\n+          desiredSplit.getAllowedSplitPointsList().isEmpty(),\n+          \"TODO: BEAM-3836, support split point restrictions.\");\n+\n+      // Now figure out where to split.\n+      //\n+      // The units here (except for keepOfElementRemainder) are all in terms of number or\n+      // (possibly fractional) elements.\n+\n+      // Compute the amount of \"remaining\" work that we know of.\n+      double remainder = totalBufferSize - index - currentElementProgress;\n+      // Compute the fraction of work that we should \"keep\".", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4ODM0Mw=="}, "originalCommit": {"oid": "a4f0a05889450257ccabfe78a171bb0a4e3b3d19"}, "originalPosition": 116}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2392, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}