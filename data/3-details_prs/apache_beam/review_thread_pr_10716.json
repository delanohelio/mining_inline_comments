{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4Nzg4MzI0", "number": 10716, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMTozMTo0OFrODcHPFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwNTowMzo0OFrODcIr_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwODA1MjY4OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/metrics/dumper.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMTozMTo0OFrOFj_NXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQyMjoxMjo1NVrOFkZX2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4MDA5NQ==", "bodyText": "I don't see this metricDumper struct used anywhere. Was this accidentally left in?", "url": "https://github.com/apache/beam/pull/10716#discussion_r373280095", "createdAt": "2020-01-31T01:31:48Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/metrics/dumper.go", "diffHunk": "@@ -0,0 +1,130 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metrics\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"sort\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/log\"\n+)\n+\n+// DumpToLog is a debugging function that outputs all metrics available locally\n+// to beam.Log.\n+func DumpToLog(ctx context.Context) {\n+\tstore := GetStore(ctx)\n+\tif store == nil {\n+\t\tlog.Errorf(ctx, \"Unable to dump metrics: provided context doesn't contain metrics Store.\")\n+\t\treturn\n+\t}\n+\tDumpToLogFromStore(ctx, store)\n+}\n+\n+// DumpToLogFromStore dumps the metrics in the provided Store to beam.Log.\n+func DumpToLogFromStore(ctx context.Context, store *Store) {\n+\tdumperExtractor(store, func(format string, args ...interface{}) {\n+\t\tlog.Errorf(ctx, format, args...)\n+\t})\n+}\n+\n+// DumpToOutFromContext is a debugging function that outputs all metrics\n+// available locally to std out,\n+// extracting the metric store from the context.\n+func DumpToOutFromContext(ctx context.Context) {\n+\tstore := GetStore(ctx)\n+\tif store == nil {\n+\t\tfmt.Printf(\"Unable to dump metrics: provided context doesn't contain metrics Store.\")\n+\t\treturn\n+\t}\n+\tDumpToOutFromStore(store)\n+}\n+\n+// DumpToOutFromStore is a debugging function that outputs all metrics\n+// available locally to std out directly from the store.\n+func DumpToOutFromStore(store *Store) {\n+\tdumperExtractor(store, func(format string, args ...interface{}) {\n+\t\tfmt.Printf(format+\"\\n\", args...)\n+\t})\n+}\n+\n+func dumperExtractor(store *Store, p func(format string, args ...interface{})) {\n+\tm := make(map[Labels]interface{})\n+\te := &Extractor{\n+\t\tSumInt64: func(l Labels, v int64) {\n+\t\t\tm[l] = &counter{value: v}\n+\t\t},\n+\t\tDistributionInt64: func(l Labels, count, sum, min, max int64) {\n+\t\t\tm[l] = &distribution{count: count, sum: sum, min: min, max: max}\n+\t\t},\n+\t\tGaugeInt64: func(l Labels, v int64, t time.Time) {\n+\t\t\tm[l] = &gauge{v: v, t: t}\n+\t\t},\n+\t}\n+\te.ExtractFrom(store)\n+\tdumpTo(m, p)\n+}\n+\n+type metricDumper struct {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b48bc529dbb95fcd371f45ea96b05bfd8c15c21"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcwODc2MQ==", "bodyText": "Good catch. Oversight from a previous prototype.", "url": "https://github.com/apache/beam/pull/10716#discussion_r373708761", "createdAt": "2020-01-31T22:12:55Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/metrics/dumper.go", "diffHunk": "@@ -0,0 +1,130 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metrics\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"sort\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/log\"\n+)\n+\n+// DumpToLog is a debugging function that outputs all metrics available locally\n+// to beam.Log.\n+func DumpToLog(ctx context.Context) {\n+\tstore := GetStore(ctx)\n+\tif store == nil {\n+\t\tlog.Errorf(ctx, \"Unable to dump metrics: provided context doesn't contain metrics Store.\")\n+\t\treturn\n+\t}\n+\tDumpToLogFromStore(ctx, store)\n+}\n+\n+// DumpToLogFromStore dumps the metrics in the provided Store to beam.Log.\n+func DumpToLogFromStore(ctx context.Context, store *Store) {\n+\tdumperExtractor(store, func(format string, args ...interface{}) {\n+\t\tlog.Errorf(ctx, format, args...)\n+\t})\n+}\n+\n+// DumpToOutFromContext is a debugging function that outputs all metrics\n+// available locally to std out,\n+// extracting the metric store from the context.\n+func DumpToOutFromContext(ctx context.Context) {\n+\tstore := GetStore(ctx)\n+\tif store == nil {\n+\t\tfmt.Printf(\"Unable to dump metrics: provided context doesn't contain metrics Store.\")\n+\t\treturn\n+\t}\n+\tDumpToOutFromStore(store)\n+}\n+\n+// DumpToOutFromStore is a debugging function that outputs all metrics\n+// available locally to std out directly from the store.\n+func DumpToOutFromStore(store *Store) {\n+\tdumperExtractor(store, func(format string, args ...interface{}) {\n+\t\tfmt.Printf(format+\"\\n\", args...)\n+\t})\n+}\n+\n+func dumperExtractor(store *Store, p func(format string, args ...interface{})) {\n+\tm := make(map[Labels]interface{})\n+\te := &Extractor{\n+\t\tSumInt64: func(l Labels, v int64) {\n+\t\t\tm[l] = &counter{value: v}\n+\t\t},\n+\t\tDistributionInt64: func(l Labels, count, sum, min, max int64) {\n+\t\t\tm[l] = &distribution{count: count, sum: sum, min: min, max: max}\n+\t\t},\n+\t\tGaugeInt64: func(l Labels, v int64, t time.Time) {\n+\t\t\tm[l] = &gauge{v: v, t: t}\n+\t\t},\n+\t}\n+\te.ExtractFrom(store)\n+\tdumpTo(m, p)\n+}\n+\n+type metricDumper struct {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4MDA5NQ=="}, "originalCommit": {"oid": "5b48bc529dbb95fcd371f45ea96b05bfd8c15c21"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwODE1MzUxOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/metrics/metrics.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMjo1MTozOVrOFkAKwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQyMjoxNjoxN1rOFkZb0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5NTgwOQ==", "bodyText": "This seems like a misplaced comment, since a metric isn't being stored in this method.", "url": "https://github.com/apache/beam/pull/10716#discussion_r373295809", "createdAt": "2020-01-31T02:51:39Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/metrics/metrics.go", "diffHunk": "@@ -144,63 +119,55 @@ func (ctx *beamCtx) String() string {\n \treturn fmt.Sprintf(\"beamCtx[%s;%s]\", ctx.bundleID, ctx.ptransformID)\n }\n \n-// SetBundleID sets the id of the current Bundle.\n+// SetBundleID sets the id of the current Bundle, and populates the store.\n func SetBundleID(ctx context.Context, id string) context.Context {\n \t// Checking for *beamCtx is an optimization, so we don't dig deeply\n \t// for ids if not necessary.\n \tif bctx, ok := ctx.(*beamCtx); ok {\n-\t\treturn &beamCtx{Context: bctx.Context, bundleID: id, bs: &perBundle{}, ptransformID: bctx.ptransformID}\n+\t\treturn &beamCtx{Context: bctx.Context, bundleID: id, store: newStore(), ptransformID: bctx.ptransformID}\n \t}\n-\treturn &beamCtx{Context: ctx, bundleID: id, bs: &perBundle{}}\n+\treturn &beamCtx{Context: ctx, bundleID: id, store: newStore()}\n }\n \n // SetPTransformID sets the id of the current PTransform.\n-// Must only be called on a context returened by SetBundleID.\n+// Must only be called on a context returned by SetBundleID.\n func SetPTransformID(ctx context.Context, id string) context.Context {\n \t// Checking for *beamCtx is an optimization, so we don't dig deeply\n \t// for ids if not necessary.\n \tif bctx, ok := ctx.(*beamCtx); ok {\n-\t\treturn &beamCtx{Context: bctx.Context, bundleID: bctx.bundleID, bs: bctx.bs, ptransformID: id}\n+\t\treturn &beamCtx{Context: bctx.Context, bundleID: bctx.bundleID, store: bctx.store, ptransformID: id}\n+\t}\n+\t// Avoid breaking if the bundle is unset in testing.\n+\treturn &beamCtx{Context: ctx, bundleID: bundleIDUnset, store: newStore(), ptransformID: id}\n+}\n+\n+// GetStore extracts the metrics Store for the given context for a bundle.\n+//\n+// Returns nil if the context doesn't contain a metric Store.\n+func GetStore(ctx context.Context) *Store {\n+\tif bctx, ok := ctx.(*beamCtx); ok {\n+\t\treturn bctx.store\n+\t}\n+\tif v := ctx.Value(storeKey); v != nil {\n+\t\treturn v.(*Store)\n \t}\n-\tpanic(fmt.Sprintf(\"SetPTransformID called before SetBundleID for %v\", id))\n-\treturn nil // never runs.\n+\treturn nil\n }\n \n const (\n \tbundleIDUnset     = \"(bundle id unset)\"\n \tptransformIDUnset = \"(ptransform id unset)\"\n )\n \n-func getContextKey(ctx context.Context, n name) key {\n-\tkey := key{name: n, bundle: bundleIDUnset, ptransform: ptransformIDUnset}\n-\tif id := ctx.Value(bundleKey); id != nil {\n-\t\tkey.bundle = id.(string)\n-\t}\n-\tif id := ctx.Value(ptransformKey); id != nil {\n-\t\tkey.ptransform = id.(string)\n-\t}\n-\treturn key\n-}\n-\n func getCounterSet(ctx context.Context) *ptCounterSet {\n-\tif id := ctx.Value(counterSetKey); id != nil {\n-\t\treturn id.(*ptCounterSet)\n+\tif bctx, ok := ctx.(*beamCtx); ok && bctx.cs != nil {\n+\t\treturn bctx.cs\n \t}\n-\t// It's not set anywhere and wasn't hoisted, so create it.\n-\tif bctx, ok := ctx.(*beamCtx); ok {\n-\t\tbctx.bs.mu.Lock()\n-\t\tcs := &ptCounterSet{\n-\t\t\tcounters:      make(map[nameHash]*counter),\n-\t\t\tdistributions: make(map[nameHash]*distribution),\n-\t\t\tgauges:        make(map[nameHash]*gauge),\n-\t\t}\n-\t\tbctx.bs.css = append(bctx.bs.css, cs)\n-\t\tbctx.cs = cs\n-\t\tbctx.bs.mu.Unlock()\n-\t\treturn cs\n+\tif set := ctx.Value(counterSetKey); set != nil {\n+\t\treturn set.(*ptCounterSet)\n \t}\n-\tpanic(\"counterSet missing, beam isn't set up properly.\")\n-\treturn nil // never runs.\n+\t// This isn't a beam context, so we can't store the metric.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b48bc529dbb95fcd371f45ea96b05bfd8c15c21"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcwOTc3OQ==", "bodyText": "The counterset is what's used to store the metric for bundle access, so it's accurate, but you're right that it's confusing. Rewording.", "url": "https://github.com/apache/beam/pull/10716#discussion_r373709779", "createdAt": "2020-01-31T22:16:17Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/metrics/metrics.go", "diffHunk": "@@ -144,63 +119,55 @@ func (ctx *beamCtx) String() string {\n \treturn fmt.Sprintf(\"beamCtx[%s;%s]\", ctx.bundleID, ctx.ptransformID)\n }\n \n-// SetBundleID sets the id of the current Bundle.\n+// SetBundleID sets the id of the current Bundle, and populates the store.\n func SetBundleID(ctx context.Context, id string) context.Context {\n \t// Checking for *beamCtx is an optimization, so we don't dig deeply\n \t// for ids if not necessary.\n \tif bctx, ok := ctx.(*beamCtx); ok {\n-\t\treturn &beamCtx{Context: bctx.Context, bundleID: id, bs: &perBundle{}, ptransformID: bctx.ptransformID}\n+\t\treturn &beamCtx{Context: bctx.Context, bundleID: id, store: newStore(), ptransformID: bctx.ptransformID}\n \t}\n-\treturn &beamCtx{Context: ctx, bundleID: id, bs: &perBundle{}}\n+\treturn &beamCtx{Context: ctx, bundleID: id, store: newStore()}\n }\n \n // SetPTransformID sets the id of the current PTransform.\n-// Must only be called on a context returened by SetBundleID.\n+// Must only be called on a context returned by SetBundleID.\n func SetPTransformID(ctx context.Context, id string) context.Context {\n \t// Checking for *beamCtx is an optimization, so we don't dig deeply\n \t// for ids if not necessary.\n \tif bctx, ok := ctx.(*beamCtx); ok {\n-\t\treturn &beamCtx{Context: bctx.Context, bundleID: bctx.bundleID, bs: bctx.bs, ptransformID: id}\n+\t\treturn &beamCtx{Context: bctx.Context, bundleID: bctx.bundleID, store: bctx.store, ptransformID: id}\n+\t}\n+\t// Avoid breaking if the bundle is unset in testing.\n+\treturn &beamCtx{Context: ctx, bundleID: bundleIDUnset, store: newStore(), ptransformID: id}\n+}\n+\n+// GetStore extracts the metrics Store for the given context for a bundle.\n+//\n+// Returns nil if the context doesn't contain a metric Store.\n+func GetStore(ctx context.Context) *Store {\n+\tif bctx, ok := ctx.(*beamCtx); ok {\n+\t\treturn bctx.store\n+\t}\n+\tif v := ctx.Value(storeKey); v != nil {\n+\t\treturn v.(*Store)\n \t}\n-\tpanic(fmt.Sprintf(\"SetPTransformID called before SetBundleID for %v\", id))\n-\treturn nil // never runs.\n+\treturn nil\n }\n \n const (\n \tbundleIDUnset     = \"(bundle id unset)\"\n \tptransformIDUnset = \"(ptransform id unset)\"\n )\n \n-func getContextKey(ctx context.Context, n name) key {\n-\tkey := key{name: n, bundle: bundleIDUnset, ptransform: ptransformIDUnset}\n-\tif id := ctx.Value(bundleKey); id != nil {\n-\t\tkey.bundle = id.(string)\n-\t}\n-\tif id := ctx.Value(ptransformKey); id != nil {\n-\t\tkey.ptransform = id.(string)\n-\t}\n-\treturn key\n-}\n-\n func getCounterSet(ctx context.Context) *ptCounterSet {\n-\tif id := ctx.Value(counterSetKey); id != nil {\n-\t\treturn id.(*ptCounterSet)\n+\tif bctx, ok := ctx.(*beamCtx); ok && bctx.cs != nil {\n+\t\treturn bctx.cs\n \t}\n-\t// It's not set anywhere and wasn't hoisted, so create it.\n-\tif bctx, ok := ctx.(*beamCtx); ok {\n-\t\tbctx.bs.mu.Lock()\n-\t\tcs := &ptCounterSet{\n-\t\t\tcounters:      make(map[nameHash]*counter),\n-\t\t\tdistributions: make(map[nameHash]*distribution),\n-\t\t\tgauges:        make(map[nameHash]*gauge),\n-\t\t}\n-\t\tbctx.bs.css = append(bctx.bs.css, cs)\n-\t\tbctx.cs = cs\n-\t\tbctx.bs.mu.Unlock()\n-\t\treturn cs\n+\tif set := ctx.Value(counterSetKey); set != nil {\n+\t\treturn set.(*ptCounterSet)\n \t}\n-\tpanic(\"counterSet missing, beam isn't set up properly.\")\n-\treturn nil // never runs.\n+\t// This isn't a beam context, so we can't store the metric.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5NTgwOQ=="}, "originalCommit": {"oid": "5b48bc529dbb95fcd371f45ea96b05bfd8c15c21"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwODI5MDUyOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/runners/direct/direct.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwNTowMzo0OFrOFkBePA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQyMjoyMTo1OVrOFkZixQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMxNzE4MA==", "bodyText": "To answer the TODO's question: This seems fine to me. What are the concerns you have about exposing the metrics like this?", "url": "https://github.com/apache/beam/pull/10716#discussion_r373317180", "createdAt": "2020-01-31T05:03:48Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/runners/direct/direct.go", "diffHunk": "@@ -72,7 +72,9 @@ func Execute(ctx context.Context, p *beam.Pipeline) error {\n \tif err = plan.Down(ctx); err != nil {\n \t\treturn err\n \t}\n-\tmetrics.DumpToLog(ctx)\n+\t// TODO(lostluck) 2020/01/24: What's the right way to expose the\n+\t// metrics store for the direct runner?\n+\tmetrics.DumpToLogFromStore(ctx, plan.Store)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b48bc529dbb95fcd371f45ea96b05bfd8c15c21"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcxMTU1Nw==", "bodyText": "It's more of a general comment of how do we give users programmatic access to the metrics after pipeline completion. So there's nothing wrong with the way the direct runner dumps the metrics every time. That's fine.\nWe likely need an extractor registration set up, to go along with the runner Execute registration, as in the absence of a reliable job management server, there's no common way for runners to return metrics to the users.", "url": "https://github.com/apache/beam/pull/10716#discussion_r373711557", "createdAt": "2020-01-31T22:21:59Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/runners/direct/direct.go", "diffHunk": "@@ -72,7 +72,9 @@ func Execute(ctx context.Context, p *beam.Pipeline) error {\n \tif err = plan.Down(ctx); err != nil {\n \t\treturn err\n \t}\n-\tmetrics.DumpToLog(ctx)\n+\t// TODO(lostluck) 2020/01/24: What's the right way to expose the\n+\t// metrics store for the direct runner?\n+\tmetrics.DumpToLogFromStore(ctx, plan.Store)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMxNzE4MA=="}, "originalCommit": {"oid": "5b48bc529dbb95fcd371f45ea96b05bfd8c15c21"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2090, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}