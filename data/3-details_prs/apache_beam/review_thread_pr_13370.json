{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIyODczNjkw", "number": 13370, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNzo1MDoxN1rOE6sVXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNzo1MzozM1rOE6sa1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTc5MjMxOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang_test.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNzo1MDoxN1rOH16w4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMToyMzoyMFrOH2I3lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI5OTM2Mw==", "bodyText": "In this case, you probably just want cmp.Equal instead of cmp.Diff, since we never use the diff result.\nhttps://pkg.go.dev/github.com/google/go-cmp/cmp#Equal", "url": "https://github.com/apache/beam/pull/13370#discussion_r526299363", "createdAt": "2020-11-18T17:50:17Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang_test.go", "diffHunk": "@@ -203,3 +203,214 @@ func TestExpandedComponents(t *testing.T) {\n \n \t})\n }\n+\n+var testExternal = graph.ExternalTransform{\n+\tUrn:           \"test_urn\",\n+\tPayload:       nil,\n+\tExpansionAddr: \"test_addr\",\n+\tExpanded:      &testExpanded,\n+}\n+\n+var testComponents = pipepb.Components{\n+\tTransforms:          map[string]*pipepb.PTransform{\"transform_id1\": {UniqueName: \"test_components_transform\"}},\n+\tPcollections:        map[string]*pipepb.PCollection{\"pcollection_id1\": {UniqueName: \"test_components_pcollection\"}},\n+\tWindowingStrategies: map[string]*pipepb.WindowingStrategy{\"windowing_id1\": {WindowCoderId: \"test_components_windowing\"}},\n+\tCoders:              map[string]*pipepb.Coder{\"coder_id1\": {Spec: &pipepb.FunctionSpec{Urn: \"test_components_coder\"}}},\n+\tEnvironments:        map[string]*pipepb.Environment{\"environment_id1\": {Urn: \"test_components_environment\"}},\n+}\n+\n+var testRequirements = []string{\"test_requirement1\", \"test_requirement2\"}\n+\n+var testTransform = pipepb.PTransform{\n+\tUniqueName: \"test_transform\",\n+}\n+\n+var testExpanded = graph.ExpandedTransform{\n+\tComponents:   &testComponents,\n+\tTransform:    &testTransform,\n+\tRequirements: testRequirements,\n+}\n+\n+var testExternal2 = graph.ExternalTransform{\n+\tUrn:           \"test_urn2\",\n+\tPayload:       nil,\n+\tExpansionAddr: \"test_addr2\",\n+\tExpanded:      &testExpanded2,\n+}\n+\n+var testComponents2 = pipepb.Components{\n+\tTransforms:          map[string]*pipepb.PTransform{\"transform_id2\": {UniqueName: \"test_components2_transform\"}},\n+\tPcollections:        map[string]*pipepb.PCollection{\"pcollection_id2\": {UniqueName: \"test_components2_pcollection\"}},\n+\tWindowingStrategies: map[string]*pipepb.WindowingStrategy{\"windowing_id2\": {WindowCoderId: \"test_components2_windowing\"}},\n+\tCoders:              map[string]*pipepb.Coder{\"coder_id2\": {Spec: &pipepb.FunctionSpec{Urn: \"test_components2_coder\"}}},\n+\tEnvironments:        map[string]*pipepb.Environment{\"environment_id2\": {Urn: \"test_components2_environment\"}},\n+}\n+\n+var testRequirements2 = []string{\"test_requirement2\", \"test_requirement3\"}\n+\n+var testTransform2 = pipepb.PTransform{\n+\tUniqueName: \"test_transform2\",\n+}\n+\n+var testExpanded2 = graph.ExpandedTransform{\n+\tComponents:   &testComponents2,\n+\tTransform:    &testTransform2,\n+\tRequirements: testRequirements2,\n+}\n+\n+// TestMergeExpandedWithPipeline tests that mergeExpandedWithPipeline properly\n+// adds data from external transforms to a pipeline.\n+func TestMergeExpandedWithPipeline(t *testing.T) {\n+\t// Create slices of MultiEdges containing external edges, and make sure all\n+\t// relevant data from the external edges is properly added to an empty\n+\t// pipeline.\n+\ttests := []struct {\n+\t\tname          string\n+\t\tmakeEdges     func(g *graph.Graph) []*graph.MultiEdge\n+\t\twantExpandeds []graph.ExpandedTransform\n+\t}{\n+\t\t{\n+\t\t\tname: \"SingleTransform\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"MultiTransforms\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\t\t\t\tedge2 := g.NewEdge(s)\n+\t\t\t\tedge2.Op = graph.External\n+\t\t\t\tedge2.External = &testExternal2\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge, edge2}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded, testExpanded2},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"NonExternalTransforms\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\t\t\t\tedge2 := g.NewEdge(s)\n+\t\t\t\tedge2.Op = graph.External\n+\t\t\t\tedge2.External = &testExternal2\n+\t\t\t\timpulse := graph.NewImpulse(g, s, []byte{1})\n+\t\t\t\timpulse2 := graph.NewImpulse(g, s, []byte{2})\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge, edge2, impulse, impulse2}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded, testExpanded2},\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\ttest := test\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tg := graph.New()\n+\t\t\tedges := test.makeEdges(g)\n+\t\t\tvar p pipepb.Pipeline\n+\t\t\tp.Components = &pipepb.Components{\n+\t\t\t\tTransforms:          make(map[string]*pipepb.PTransform),\n+\t\t\t\tPcollections:        make(map[string]*pipepb.PCollection),\n+\t\t\t\tWindowingStrategies: make(map[string]*pipepb.WindowingStrategy),\n+\t\t\t\tCoders:              make(map[string]*pipepb.Coder),\n+\t\t\t\tEnvironments:        make(map[string]*pipepb.Environment),\n+\t\t\t}\n+\t\t\tmergeExpandedWithPipeline(edges, &p)\n+\n+\t\t\t// Check that all wanted expanded components have been added to\n+\t\t\t// pipeline components.\n+\t\t\tfor _, exp := range test.wantExpandeds {\n+\t\t\t\twantComps := exp.Components.(*pipepb.Components)\n+\t\t\t\tgotComps := p.GetComponents()\n+\t\t\t\tvalidateComponents(t, wantComps, gotComps)\n+\n+\t\t\t\t// Check that expanded transform is present. Need to search.\n+\t\t\t\twantTransform := exp.Transform.(*pipepb.PTransform)\n+\t\t\t\tvar found bool\n+\t\t\t\tfor _, gotTransform := range gotComps.GetTransforms() {\n+\t\t\t\t\tif d := cmp.Diff(wantTransform, gotTransform, protocmp.Transform()); d == \"\" {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0fde1b63a708b6606e72404d9e045f8c2b3f09f"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUzMDQ1NQ==", "bodyText": "Whoops, kinda embarrassed I missed that. Done.", "url": "https://github.com/apache/beam/pull/13370#discussion_r526530455", "createdAt": "2020-11-19T01:23:20Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang_test.go", "diffHunk": "@@ -203,3 +203,214 @@ func TestExpandedComponents(t *testing.T) {\n \n \t})\n }\n+\n+var testExternal = graph.ExternalTransform{\n+\tUrn:           \"test_urn\",\n+\tPayload:       nil,\n+\tExpansionAddr: \"test_addr\",\n+\tExpanded:      &testExpanded,\n+}\n+\n+var testComponents = pipepb.Components{\n+\tTransforms:          map[string]*pipepb.PTransform{\"transform_id1\": {UniqueName: \"test_components_transform\"}},\n+\tPcollections:        map[string]*pipepb.PCollection{\"pcollection_id1\": {UniqueName: \"test_components_pcollection\"}},\n+\tWindowingStrategies: map[string]*pipepb.WindowingStrategy{\"windowing_id1\": {WindowCoderId: \"test_components_windowing\"}},\n+\tCoders:              map[string]*pipepb.Coder{\"coder_id1\": {Spec: &pipepb.FunctionSpec{Urn: \"test_components_coder\"}}},\n+\tEnvironments:        map[string]*pipepb.Environment{\"environment_id1\": {Urn: \"test_components_environment\"}},\n+}\n+\n+var testRequirements = []string{\"test_requirement1\", \"test_requirement2\"}\n+\n+var testTransform = pipepb.PTransform{\n+\tUniqueName: \"test_transform\",\n+}\n+\n+var testExpanded = graph.ExpandedTransform{\n+\tComponents:   &testComponents,\n+\tTransform:    &testTransform,\n+\tRequirements: testRequirements,\n+}\n+\n+var testExternal2 = graph.ExternalTransform{\n+\tUrn:           \"test_urn2\",\n+\tPayload:       nil,\n+\tExpansionAddr: \"test_addr2\",\n+\tExpanded:      &testExpanded2,\n+}\n+\n+var testComponents2 = pipepb.Components{\n+\tTransforms:          map[string]*pipepb.PTransform{\"transform_id2\": {UniqueName: \"test_components2_transform\"}},\n+\tPcollections:        map[string]*pipepb.PCollection{\"pcollection_id2\": {UniqueName: \"test_components2_pcollection\"}},\n+\tWindowingStrategies: map[string]*pipepb.WindowingStrategy{\"windowing_id2\": {WindowCoderId: \"test_components2_windowing\"}},\n+\tCoders:              map[string]*pipepb.Coder{\"coder_id2\": {Spec: &pipepb.FunctionSpec{Urn: \"test_components2_coder\"}}},\n+\tEnvironments:        map[string]*pipepb.Environment{\"environment_id2\": {Urn: \"test_components2_environment\"}},\n+}\n+\n+var testRequirements2 = []string{\"test_requirement2\", \"test_requirement3\"}\n+\n+var testTransform2 = pipepb.PTransform{\n+\tUniqueName: \"test_transform2\",\n+}\n+\n+var testExpanded2 = graph.ExpandedTransform{\n+\tComponents:   &testComponents2,\n+\tTransform:    &testTransform2,\n+\tRequirements: testRequirements2,\n+}\n+\n+// TestMergeExpandedWithPipeline tests that mergeExpandedWithPipeline properly\n+// adds data from external transforms to a pipeline.\n+func TestMergeExpandedWithPipeline(t *testing.T) {\n+\t// Create slices of MultiEdges containing external edges, and make sure all\n+\t// relevant data from the external edges is properly added to an empty\n+\t// pipeline.\n+\ttests := []struct {\n+\t\tname          string\n+\t\tmakeEdges     func(g *graph.Graph) []*graph.MultiEdge\n+\t\twantExpandeds []graph.ExpandedTransform\n+\t}{\n+\t\t{\n+\t\t\tname: \"SingleTransform\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"MultiTransforms\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\t\t\t\tedge2 := g.NewEdge(s)\n+\t\t\t\tedge2.Op = graph.External\n+\t\t\t\tedge2.External = &testExternal2\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge, edge2}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded, testExpanded2},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"NonExternalTransforms\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\t\t\t\tedge2 := g.NewEdge(s)\n+\t\t\t\tedge2.Op = graph.External\n+\t\t\t\tedge2.External = &testExternal2\n+\t\t\t\timpulse := graph.NewImpulse(g, s, []byte{1})\n+\t\t\t\timpulse2 := graph.NewImpulse(g, s, []byte{2})\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge, edge2, impulse, impulse2}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded, testExpanded2},\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\ttest := test\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tg := graph.New()\n+\t\t\tedges := test.makeEdges(g)\n+\t\t\tvar p pipepb.Pipeline\n+\t\t\tp.Components = &pipepb.Components{\n+\t\t\t\tTransforms:          make(map[string]*pipepb.PTransform),\n+\t\t\t\tPcollections:        make(map[string]*pipepb.PCollection),\n+\t\t\t\tWindowingStrategies: make(map[string]*pipepb.WindowingStrategy),\n+\t\t\t\tCoders:              make(map[string]*pipepb.Coder),\n+\t\t\t\tEnvironments:        make(map[string]*pipepb.Environment),\n+\t\t\t}\n+\t\t\tmergeExpandedWithPipeline(edges, &p)\n+\n+\t\t\t// Check that all wanted expanded components have been added to\n+\t\t\t// pipeline components.\n+\t\t\tfor _, exp := range test.wantExpandeds {\n+\t\t\t\twantComps := exp.Components.(*pipepb.Components)\n+\t\t\t\tgotComps := p.GetComponents()\n+\t\t\t\tvalidateComponents(t, wantComps, gotComps)\n+\n+\t\t\t\t// Check that expanded transform is present. Need to search.\n+\t\t\t\twantTransform := exp.Transform.(*pipepb.PTransform)\n+\t\t\t\tvar found bool\n+\t\t\t\tfor _, gotTransform := range gotComps.GetTransforms() {\n+\t\t\t\t\tif d := cmp.Diff(wantTransform, gotTransform, protocmp.Transform()); d == \"\" {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI5OTM2Mw=="}, "originalCommit": {"oid": "c0fde1b63a708b6606e72404d9e045f8c2b3f09f"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTgwNjMxOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang_test.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNzo1MzozM1rOH165wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMToyNzoyOVrOH2I89w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMwMTYzMw==", "bodyText": "I'm confused why this is broken out rather than simply using a single cmp.Diff(wantComps, gotComps, protocmp.Transform()) ?\nI'm assuming that you wanted additional granularity on the parts that were missing/extra for each component, and the full diff was less clear than this output?\nConsider adding a comment documenting that reasoning.", "url": "https://github.com/apache/beam/pull/13370#discussion_r526301633", "createdAt": "2020-11-18T17:53:33Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang_test.go", "diffHunk": "@@ -203,3 +203,214 @@ func TestExpandedComponents(t *testing.T) {\n \n \t})\n }\n+\n+var testExternal = graph.ExternalTransform{\n+\tUrn:           \"test_urn\",\n+\tPayload:       nil,\n+\tExpansionAddr: \"test_addr\",\n+\tExpanded:      &testExpanded,\n+}\n+\n+var testComponents = pipepb.Components{\n+\tTransforms:          map[string]*pipepb.PTransform{\"transform_id1\": {UniqueName: \"test_components_transform\"}},\n+\tPcollections:        map[string]*pipepb.PCollection{\"pcollection_id1\": {UniqueName: \"test_components_pcollection\"}},\n+\tWindowingStrategies: map[string]*pipepb.WindowingStrategy{\"windowing_id1\": {WindowCoderId: \"test_components_windowing\"}},\n+\tCoders:              map[string]*pipepb.Coder{\"coder_id1\": {Spec: &pipepb.FunctionSpec{Urn: \"test_components_coder\"}}},\n+\tEnvironments:        map[string]*pipepb.Environment{\"environment_id1\": {Urn: \"test_components_environment\"}},\n+}\n+\n+var testRequirements = []string{\"test_requirement1\", \"test_requirement2\"}\n+\n+var testTransform = pipepb.PTransform{\n+\tUniqueName: \"test_transform\",\n+}\n+\n+var testExpanded = graph.ExpandedTransform{\n+\tComponents:   &testComponents,\n+\tTransform:    &testTransform,\n+\tRequirements: testRequirements,\n+}\n+\n+var testExternal2 = graph.ExternalTransform{\n+\tUrn:           \"test_urn2\",\n+\tPayload:       nil,\n+\tExpansionAddr: \"test_addr2\",\n+\tExpanded:      &testExpanded2,\n+}\n+\n+var testComponents2 = pipepb.Components{\n+\tTransforms:          map[string]*pipepb.PTransform{\"transform_id2\": {UniqueName: \"test_components2_transform\"}},\n+\tPcollections:        map[string]*pipepb.PCollection{\"pcollection_id2\": {UniqueName: \"test_components2_pcollection\"}},\n+\tWindowingStrategies: map[string]*pipepb.WindowingStrategy{\"windowing_id2\": {WindowCoderId: \"test_components2_windowing\"}},\n+\tCoders:              map[string]*pipepb.Coder{\"coder_id2\": {Spec: &pipepb.FunctionSpec{Urn: \"test_components2_coder\"}}},\n+\tEnvironments:        map[string]*pipepb.Environment{\"environment_id2\": {Urn: \"test_components2_environment\"}},\n+}\n+\n+var testRequirements2 = []string{\"test_requirement2\", \"test_requirement3\"}\n+\n+var testTransform2 = pipepb.PTransform{\n+\tUniqueName: \"test_transform2\",\n+}\n+\n+var testExpanded2 = graph.ExpandedTransform{\n+\tComponents:   &testComponents2,\n+\tTransform:    &testTransform2,\n+\tRequirements: testRequirements2,\n+}\n+\n+// TestMergeExpandedWithPipeline tests that mergeExpandedWithPipeline properly\n+// adds data from external transforms to a pipeline.\n+func TestMergeExpandedWithPipeline(t *testing.T) {\n+\t// Create slices of MultiEdges containing external edges, and make sure all\n+\t// relevant data from the external edges is properly added to an empty\n+\t// pipeline.\n+\ttests := []struct {\n+\t\tname          string\n+\t\tmakeEdges     func(g *graph.Graph) []*graph.MultiEdge\n+\t\twantExpandeds []graph.ExpandedTransform\n+\t}{\n+\t\t{\n+\t\t\tname: \"SingleTransform\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"MultiTransforms\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\t\t\t\tedge2 := g.NewEdge(s)\n+\t\t\t\tedge2.Op = graph.External\n+\t\t\t\tedge2.External = &testExternal2\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge, edge2}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded, testExpanded2},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"NonExternalTransforms\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\t\t\t\tedge2 := g.NewEdge(s)\n+\t\t\t\tedge2.Op = graph.External\n+\t\t\t\tedge2.External = &testExternal2\n+\t\t\t\timpulse := graph.NewImpulse(g, s, []byte{1})\n+\t\t\t\timpulse2 := graph.NewImpulse(g, s, []byte{2})\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge, edge2, impulse, impulse2}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded, testExpanded2},\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\ttest := test\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tg := graph.New()\n+\t\t\tedges := test.makeEdges(g)\n+\t\t\tvar p pipepb.Pipeline\n+\t\t\tp.Components = &pipepb.Components{\n+\t\t\t\tTransforms:          make(map[string]*pipepb.PTransform),\n+\t\t\t\tPcollections:        make(map[string]*pipepb.PCollection),\n+\t\t\t\tWindowingStrategies: make(map[string]*pipepb.WindowingStrategy),\n+\t\t\t\tCoders:              make(map[string]*pipepb.Coder),\n+\t\t\t\tEnvironments:        make(map[string]*pipepb.Environment),\n+\t\t\t}\n+\t\t\tmergeExpandedWithPipeline(edges, &p)\n+\n+\t\t\t// Check that all wanted expanded components have been added to\n+\t\t\t// pipeline components.\n+\t\t\tfor _, exp := range test.wantExpandeds {\n+\t\t\t\twantComps := exp.Components.(*pipepb.Components)\n+\t\t\t\tgotComps := p.GetComponents()\n+\t\t\t\tvalidateComponents(t, wantComps, gotComps)\n+\n+\t\t\t\t// Check that expanded transform is present. Need to search.\n+\t\t\t\twantTransform := exp.Transform.(*pipepb.PTransform)\n+\t\t\t\tvar found bool\n+\t\t\t\tfor _, gotTransform := range gotComps.GetTransforms() {\n+\t\t\t\t\tif d := cmp.Diff(wantTransform, gotTransform, protocmp.Transform()); d == \"\" {\n+\t\t\t\t\t\tfound = true\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif !found {\n+\t\t\t\t\tt.Errorf(\"Pipeline components missing expected expanded transform: %v\", wantTransform)\n+\t\t\t\t}\n+\n+\t\t\t\t// Check that requirements are present.\n+\t\t\t\tfor _, wantReq := range exp.Requirements {\n+\t\t\t\t\tvar found bool\n+\t\t\t\t\tfor _, gotReq := range p.GetRequirements() {\n+\t\t\t\t\t\tif wantReq == gotReq {\n+\t\t\t\t\t\t\tfound = true\n+\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif !found {\n+\t\t\t\t\t\tt.Errorf(\"Pipeline missing expected requirement: %v\", wantReq)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func validateComponents(t *testing.T, wantComps, gotComps *pipepb.Components) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0fde1b63a708b6606e72404d9e045f8c2b3f09f"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUzMTgzMQ==", "bodyText": "Actually, the main reason was because the pipeline object can contain the components from multiple external transforms, so just diffing the components wouldn't work. What I needed to validate is that the components of the external transform are a subset of the pipeline components, not that they're exactly equal.\nI'll add a comment explaining that, because I agree it's not immediately obvious.", "url": "https://github.com/apache/beam/pull/13370#discussion_r526531831", "createdAt": "2020-11-19T01:27:29Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang_test.go", "diffHunk": "@@ -203,3 +203,214 @@ func TestExpandedComponents(t *testing.T) {\n \n \t})\n }\n+\n+var testExternal = graph.ExternalTransform{\n+\tUrn:           \"test_urn\",\n+\tPayload:       nil,\n+\tExpansionAddr: \"test_addr\",\n+\tExpanded:      &testExpanded,\n+}\n+\n+var testComponents = pipepb.Components{\n+\tTransforms:          map[string]*pipepb.PTransform{\"transform_id1\": {UniqueName: \"test_components_transform\"}},\n+\tPcollections:        map[string]*pipepb.PCollection{\"pcollection_id1\": {UniqueName: \"test_components_pcollection\"}},\n+\tWindowingStrategies: map[string]*pipepb.WindowingStrategy{\"windowing_id1\": {WindowCoderId: \"test_components_windowing\"}},\n+\tCoders:              map[string]*pipepb.Coder{\"coder_id1\": {Spec: &pipepb.FunctionSpec{Urn: \"test_components_coder\"}}},\n+\tEnvironments:        map[string]*pipepb.Environment{\"environment_id1\": {Urn: \"test_components_environment\"}},\n+}\n+\n+var testRequirements = []string{\"test_requirement1\", \"test_requirement2\"}\n+\n+var testTransform = pipepb.PTransform{\n+\tUniqueName: \"test_transform\",\n+}\n+\n+var testExpanded = graph.ExpandedTransform{\n+\tComponents:   &testComponents,\n+\tTransform:    &testTransform,\n+\tRequirements: testRequirements,\n+}\n+\n+var testExternal2 = graph.ExternalTransform{\n+\tUrn:           \"test_urn2\",\n+\tPayload:       nil,\n+\tExpansionAddr: \"test_addr2\",\n+\tExpanded:      &testExpanded2,\n+}\n+\n+var testComponents2 = pipepb.Components{\n+\tTransforms:          map[string]*pipepb.PTransform{\"transform_id2\": {UniqueName: \"test_components2_transform\"}},\n+\tPcollections:        map[string]*pipepb.PCollection{\"pcollection_id2\": {UniqueName: \"test_components2_pcollection\"}},\n+\tWindowingStrategies: map[string]*pipepb.WindowingStrategy{\"windowing_id2\": {WindowCoderId: \"test_components2_windowing\"}},\n+\tCoders:              map[string]*pipepb.Coder{\"coder_id2\": {Spec: &pipepb.FunctionSpec{Urn: \"test_components2_coder\"}}},\n+\tEnvironments:        map[string]*pipepb.Environment{\"environment_id2\": {Urn: \"test_components2_environment\"}},\n+}\n+\n+var testRequirements2 = []string{\"test_requirement2\", \"test_requirement3\"}\n+\n+var testTransform2 = pipepb.PTransform{\n+\tUniqueName: \"test_transform2\",\n+}\n+\n+var testExpanded2 = graph.ExpandedTransform{\n+\tComponents:   &testComponents2,\n+\tTransform:    &testTransform2,\n+\tRequirements: testRequirements2,\n+}\n+\n+// TestMergeExpandedWithPipeline tests that mergeExpandedWithPipeline properly\n+// adds data from external transforms to a pipeline.\n+func TestMergeExpandedWithPipeline(t *testing.T) {\n+\t// Create slices of MultiEdges containing external edges, and make sure all\n+\t// relevant data from the external edges is properly added to an empty\n+\t// pipeline.\n+\ttests := []struct {\n+\t\tname          string\n+\t\tmakeEdges     func(g *graph.Graph) []*graph.MultiEdge\n+\t\twantExpandeds []graph.ExpandedTransform\n+\t}{\n+\t\t{\n+\t\t\tname: \"SingleTransform\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"MultiTransforms\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\t\t\t\tedge2 := g.NewEdge(s)\n+\t\t\t\tedge2.Op = graph.External\n+\t\t\t\tedge2.External = &testExternal2\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge, edge2}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded, testExpanded2},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"NonExternalTransforms\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\t\t\t\tedge2 := g.NewEdge(s)\n+\t\t\t\tedge2.Op = graph.External\n+\t\t\t\tedge2.External = &testExternal2\n+\t\t\t\timpulse := graph.NewImpulse(g, s, []byte{1})\n+\t\t\t\timpulse2 := graph.NewImpulse(g, s, []byte{2})\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge, edge2, impulse, impulse2}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded, testExpanded2},\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\ttest := test\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tg := graph.New()\n+\t\t\tedges := test.makeEdges(g)\n+\t\t\tvar p pipepb.Pipeline\n+\t\t\tp.Components = &pipepb.Components{\n+\t\t\t\tTransforms:          make(map[string]*pipepb.PTransform),\n+\t\t\t\tPcollections:        make(map[string]*pipepb.PCollection),\n+\t\t\t\tWindowingStrategies: make(map[string]*pipepb.WindowingStrategy),\n+\t\t\t\tCoders:              make(map[string]*pipepb.Coder),\n+\t\t\t\tEnvironments:        make(map[string]*pipepb.Environment),\n+\t\t\t}\n+\t\t\tmergeExpandedWithPipeline(edges, &p)\n+\n+\t\t\t// Check that all wanted expanded components have been added to\n+\t\t\t// pipeline components.\n+\t\t\tfor _, exp := range test.wantExpandeds {\n+\t\t\t\twantComps := exp.Components.(*pipepb.Components)\n+\t\t\t\tgotComps := p.GetComponents()\n+\t\t\t\tvalidateComponents(t, wantComps, gotComps)\n+\n+\t\t\t\t// Check that expanded transform is present. Need to search.\n+\t\t\t\twantTransform := exp.Transform.(*pipepb.PTransform)\n+\t\t\t\tvar found bool\n+\t\t\t\tfor _, gotTransform := range gotComps.GetTransforms() {\n+\t\t\t\t\tif d := cmp.Diff(wantTransform, gotTransform, protocmp.Transform()); d == \"\" {\n+\t\t\t\t\t\tfound = true\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif !found {\n+\t\t\t\t\tt.Errorf(\"Pipeline components missing expected expanded transform: %v\", wantTransform)\n+\t\t\t\t}\n+\n+\t\t\t\t// Check that requirements are present.\n+\t\t\t\tfor _, wantReq := range exp.Requirements {\n+\t\t\t\t\tvar found bool\n+\t\t\t\t\tfor _, gotReq := range p.GetRequirements() {\n+\t\t\t\t\t\tif wantReq == gotReq {\n+\t\t\t\t\t\t\tfound = true\n+\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif !found {\n+\t\t\t\t\t\tt.Errorf(\"Pipeline missing expected requirement: %v\", wantReq)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func validateComponents(t *testing.T, wantComps, gotComps *pipepb.Components) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMwMTYzMw=="}, "originalCommit": {"oid": "c0fde1b63a708b6606e72404d9e045f8c2b3f09f"}, "originalPosition": 168}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2595, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}