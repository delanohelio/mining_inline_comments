{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczMDEwMTkw", "number": 10815, "title": "[BEAM-9279] Make HBase.ReadAll based on Reads instead of HBaseQuery", "bodyText": "This PR adds an additional commit that is a prerrequisite to improve the serialization of the HBase.Read class, as a consequence the 'business' logic became simpler (because the IO related code does not rely on the Serialization wrappers).\nNotice that I do not add extra Serialization tests because the pipeline Execution with direct runner already enforces Serialization and even the equals contract (that I had to make the tests happy).\nR: @aromanenko-dev", "createdAt": "2020-02-10T08:48:39Z", "url": "https://github.com/apache/beam/pull/10815", "merged": true, "mergeCommit": {"oid": "52419e93ee9fa8c823eb505c472969fc7849e247"}, "closed": true, "closedAt": "2020-03-19T10:55:19Z", "author": {"login": "iemejia"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcC5MctgFqTM1NTc2NjUxNA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcPIm5EABqjMxNDQ3NjMwODM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NzY2NTE0", "url": "https://github.com/apache/beam/pull/10815#pullrequestreview-355766514", "createdAt": "2020-02-10T08:52:06Z", "commit": {"oid": "df531f48a8dbf3e567036e5acbd9bcc4633e9924"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwODo1MjowNlrOFnd6-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwODo1MjowNlrOFnd6-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkyOTAxOA==", "bodyText": "This was required to keep the Read class immutable. This is some kind of magic I did not know before in case you did not too https://lingpipe-blog.com/2009/08/10/serializing-immutable-singletons-serialization-proxy/", "url": "https://github.com/apache/beam/pull/10815#discussion_r376929018", "createdAt": "2020-02-10T08:52:06Z", "author": {"login": "iemejia"}, "path": "sdks/java/io/hbase/src/main/java/org/apache/beam/sdk/io/hbase/HBaseIO.java", "diffHunk": "@@ -240,63 +245,109 @@ private Read(\n     @Override\n     public void populateDisplayData(DisplayData.Builder builder) {\n       super.populateDisplayData(builder);\n-      builder.add(DisplayData.item(\"configuration\", serializableConfiguration.get().toString()));\n+      builder.add(DisplayData.item(\"configuration\", configuration.toString()));\n       builder.add(DisplayData.item(\"tableId\", tableId));\n-      builder.addIfNotNull(DisplayData.item(\"scan\", serializableScan.get().toString()));\n+      builder.addIfNotNull(DisplayData.item(\"scan\", scan.toString()));\n     }\n \n     public Configuration getConfiguration() {\n-      return serializableConfiguration.get();\n+      return configuration;\n     }\n \n     public String getTableId() {\n       return tableId;\n     }\n \n     public Scan getScan() {\n-      return serializableScan.get();\n+      return scan;\n     }\n \n     /** Returns the range of keys that will be read from the table. */\n     public ByteKeyRange getKeyRange() {\n-      byte[] startRow = serializableScan.get().getStartRow();\n-      byte[] stopRow = serializableScan.get().getStopRow();\n+      byte[] startRow = scan.getStartRow();\n+      byte[] stopRow = scan.getStopRow();\n       return ByteKeyRange.of(ByteKey.copyFrom(startRow), ByteKey.copyFrom(stopRow));\n     }\n \n-    private final SerializableConfiguration serializableConfiguration;\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      Read read = (Read) o;\n+      return configuration.toString().equals(read.configuration.toString())\n+          && Objects.equals(tableId, read.tableId)\n+          && scan.toString().equals(read.scan.toString());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(configuration, tableId, scan);\n+    }\n+\n+    private Object writeReplace() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df531f48a8dbf3e567036e5acbd9bcc4633e9924"}, "originalPosition": 182}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NzY4NjI5", "url": "https://github.com/apache/beam/pull/10815#pullrequestreview-355768629", "createdAt": "2020-02-10T08:55:47Z", "commit": {"oid": "df531f48a8dbf3e567036e5acbd9bcc4633e9924"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwODo1NTo0N1rOFneBOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwODo1NTo0N1rOFneBOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzMDYxOQ==", "bodyText": "This creates a connection for each Read element, this is arguable costly because its nature is 1 to many, but it is an acceptable trade-off to support multiple Configurations and have the multi cluster flexibility.\nConnection initialization could be improved in the future via some sort of class based Pool mechanism (as we do for JdbcIO).", "url": "https://github.com/apache/beam/pull/10815#discussion_r376930619", "createdAt": "2020-02-10T08:55:47Z", "author": {"login": "iemejia"}, "path": "sdks/java/io/hbase/src/main/java/org/apache/beam/sdk/io/hbase/HBaseReadSplittableDoFn.java", "diffHunk": "@@ -32,65 +31,50 @@\n import org.apache.hadoop.hbase.client.ConnectionFactory;\n import org.apache.hadoop.hbase.client.Result;\n import org.apache.hadoop.hbase.client.ResultScanner;\n-import org.apache.hadoop.hbase.client.Scan;\n import org.apache.hadoop.hbase.client.Table;\n \n /** A SplittableDoFn to read from HBase. */\n @BoundedPerElement\n-class HBaseReadSplittableDoFn extends DoFn<HBaseQuery, Result> {\n-  private final SerializableConfiguration serializableConfiguration;\n-\n-  private transient Connection connection;\n-\n-  HBaseReadSplittableDoFn(SerializableConfiguration serializableConfiguration) {\n-    this.serializableConfiguration = serializableConfiguration;\n-  }\n-\n-  @Setup\n-  public void setup() throws Exception {\n-    connection = ConnectionFactory.createConnection(serializableConfiguration.get());\n-  }\n-\n-  private static Scan newScanInRange(Scan scan, ByteKeyRange range) throws IOException {\n-    return new Scan(scan)\n-        .setStartRow(range.getStartKey().getBytes())\n-        .setStopRow(range.getEndKey().getBytes());\n-  }\n+class HBaseReadSplittableDoFn extends DoFn<Read, Result> {\n+  HBaseReadSplittableDoFn() {}\n \n   @ProcessElement\n-  public void processElement(ProcessContext c, RestrictionTracker<ByteKeyRange, ByteKey> tracker)\n+  public void processElement(\n+      @Element Read read,\n+      OutputReceiver<Result> out,\n+      RestrictionTracker<ByteKeyRange, ByteKey> tracker)\n       throws Exception {\n-    final HBaseQuery query = c.element();\n-    TableName tableName = TableName.valueOf(query.getTableId());\n+    Connection connection = ConnectionFactory.createConnection(read.getConfiguration());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df531f48a8dbf3e567036e5acbd9bcc4633e9924"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NDMxOTgx", "url": "https://github.com/apache/beam/pull/10815#pullrequestreview-358431981", "createdAt": "2020-02-13T17:59:03Z", "commit": {"oid": "df531f48a8dbf3e567036e5acbd9bcc4633e9924"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNzo1OTowM1rOFpd3hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNzo1OTowM1rOFpd3hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyNTI4Nw==", "bodyText": "Is it a breaking change of users API?", "url": "https://github.com/apache/beam/pull/10815#discussion_r379025287", "createdAt": "2020-02-13T17:59:03Z", "author": {"login": "aromanenko-dev"}, "path": "sdks/java/io/hbase/src/main/java/org/apache/beam/sdk/io/hbase/HBaseIO.java", "diffHunk": "@@ -240,63 +245,109 @@ private Read(\n     @Override\n     public void populateDisplayData(DisplayData.Builder builder) {\n       super.populateDisplayData(builder);\n-      builder.add(DisplayData.item(\"configuration\", serializableConfiguration.get().toString()));\n+      builder.add(DisplayData.item(\"configuration\", configuration.toString()));\n       builder.add(DisplayData.item(\"tableId\", tableId));\n-      builder.addIfNotNull(DisplayData.item(\"scan\", serializableScan.get().toString()));\n+      builder.addIfNotNull(DisplayData.item(\"scan\", scan.toString()));\n     }\n \n     public Configuration getConfiguration() {\n-      return serializableConfiguration.get();\n+      return configuration;\n     }\n \n     public String getTableId() {\n       return tableId;\n     }\n \n     public Scan getScan() {\n-      return serializableScan.get();\n+      return scan;\n     }\n \n     /** Returns the range of keys that will be read from the table. */\n     public ByteKeyRange getKeyRange() {\n-      byte[] startRow = serializableScan.get().getStartRow();\n-      byte[] stopRow = serializableScan.get().getStopRow();\n+      byte[] startRow = scan.getStartRow();\n+      byte[] stopRow = scan.getStopRow();\n       return ByteKeyRange.of(ByteKey.copyFrom(startRow), ByteKey.copyFrom(stopRow));\n     }\n \n-    private final SerializableConfiguration serializableConfiguration;\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      Read read = (Read) o;\n+      return configuration.toString().equals(read.configuration.toString())\n+          && Objects.equals(tableId, read.tableId)\n+          && scan.toString().equals(read.scan.toString());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(configuration, tableId, scan);\n+    }\n+\n+    private Object writeReplace() {\n+      return new SerializationProxy(this);\n+    }\n+\n+    private static class SerializationProxy implements Serializable {\n+      public SerializationProxy() {}\n+\n+      public SerializationProxy(Read read) {\n+        configuration = read.configuration;\n+        tableId = read.tableId;\n+        scan = read.scan;\n+      }\n+\n+      private void writeObject(ObjectOutputStream out) throws IOException {\n+        SerializableCoder.of(SerializableConfiguration.class)\n+            .encode(new SerializableConfiguration(this.configuration), out);\n+        StringUtf8Coder.of().encode(this.tableId, out);\n+        ProtobufUtil.toScan(this.scan).writeDelimitedTo(out);\n+      }\n+\n+      private void readObject(ObjectInputStream in) throws IOException {\n+        this.configuration = SerializableCoder.of(SerializableConfiguration.class).decode(in).get();\n+        this.tableId = StringUtf8Coder.of().decode(in);\n+        this.scan = ProtobufUtil.toScan(ClientProtos.Scan.parseDelimitedFrom(in));\n+      }\n+\n+      Object readResolve() {\n+        return HBaseIO.read().withConfiguration(configuration).withTableId(tableId).withScan(scan);\n+      }\n+\n+      private Configuration configuration;\n+      private String tableId;\n+      private Scan scan;\n+    }\n+\n+    @SuppressFBWarnings(\"SE_BAD_FIELD\")\n+    private final Configuration configuration;\n+\n     private final String tableId;\n-    private final SerializableScan serializableScan;\n+\n+    @SuppressFBWarnings(\"SE_BAD_FIELD\")\n+    private final Scan scan;\n   }\n \n   /**\n    * A {@link PTransform} that works like {@link #read}, but executes read operations coming from a\n-   * {@link PCollection} of {@link HBaseQuery}.\n+   * {@link PCollection} of {@link Read}.\n    */\n   public static ReadAll readAll() {\n-    return new ReadAll(null);\n+    return new ReadAll();\n   }\n \n   /** Implementation of {@link #readAll}. */\n-  public static class ReadAll extends PTransform<PCollection<HBaseQuery>, PCollection<Result>> {\n-\n-    private ReadAll(SerializableConfiguration serializableConfiguration) {\n-      this.serializableConfiguration = serializableConfiguration;\n-    }\n-\n-    /** Reads from the HBase instance indicated by the* given configuration. */\n-    public ReadAll withConfiguration(Configuration configuration) {\n-      checkArgument(configuration != null, \"configuration can not be null\");\n-      return new ReadAll(new SerializableConfiguration(configuration));\n-    }\n+  public static class ReadAll extends PTransform<PCollection<Read>, PCollection<Result>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df531f48a8dbf3e567036e5acbd9bcc4633e9924"}, "originalPosition": 249}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MDc1MjMx", "url": "https://github.com/apache/beam/pull/10815#pullrequestreview-377075231", "createdAt": "2020-03-18T17:16:54Z", "commit": {"oid": "df531f48a8dbf3e567036e5acbd9bcc4633e9924"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNzoxNjo1NFrOF4PHeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNzo1MTowNFrOF4QczQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUxMjI1MA==", "bodyText": "type \"scancan\"", "url": "https://github.com/apache/beam/pull/10815#discussion_r394512250", "createdAt": "2020-03-18T17:16:54Z", "author": {"login": "aromanenko-dev"}, "path": "sdks/java/io/hbase/src/main/java/org/apache/beam/sdk/io/hbase/HBaseIO.java", "diffHunk": "@@ -173,33 +182,33 @@ public static Read read() {\n     /** Reads from the HBase instance indicated by the* given configuration. */\n     public Read withConfiguration(Configuration configuration) {\n       checkArgument(configuration != null, \"configuration can not be null\");\n-      return new Read(new SerializableConfiguration(configuration), tableId, serializableScan);\n+      return new Read(new Configuration(configuration), tableId, scan);\n     }\n \n     /** Reads from the specified table. */\n     public Read withTableId(String tableId) {\n       checkArgument(tableId != null, \"tableIdcan not be null\");\n-      return new Read(serializableConfiguration, tableId, serializableScan);\n+      return new Read(configuration, tableId, scan);\n     }\n \n     /** Filters the rows read from HBase using the given* scan. */\n     public Read withScan(Scan scan) {\n       checkArgument(scan != null, \"scancan not be null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df531f48a8dbf3e567036e5acbd9bcc4633e9924"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUxMjUwNA==", "bodyText": "typo \"tableIdcan\"", "url": "https://github.com/apache/beam/pull/10815#discussion_r394512504", "createdAt": "2020-03-18T17:17:18Z", "author": {"login": "aromanenko-dev"}, "path": "sdks/java/io/hbase/src/main/java/org/apache/beam/sdk/io/hbase/HBaseIO.java", "diffHunk": "@@ -173,33 +182,33 @@ public static Read read() {\n     /** Reads from the HBase instance indicated by the* given configuration. */\n     public Read withConfiguration(Configuration configuration) {\n       checkArgument(configuration != null, \"configuration can not be null\");\n-      return new Read(new SerializableConfiguration(configuration), tableId, serializableScan);\n+      return new Read(new Configuration(configuration), tableId, scan);\n     }\n \n     /** Reads from the specified table. */\n     public Read withTableId(String tableId) {\n       checkArgument(tableId != null, \"tableIdcan not be null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df531f48a8dbf3e567036e5acbd9bcc4633e9924"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUxNTI4Mw==", "bodyText": "Add it into method Javadoc please", "url": "https://github.com/apache/beam/pull/10815#discussion_r394515283", "createdAt": "2020-03-18T17:21:34Z", "author": {"login": "aromanenko-dev"}, "path": "sdks/java/io/hbase/src/main/java/org/apache/beam/sdk/io/hbase/HBaseIO.java", "diffHunk": "@@ -240,63 +245,109 @@ private Read(\n     @Override\n     public void populateDisplayData(DisplayData.Builder builder) {\n       super.populateDisplayData(builder);\n-      builder.add(DisplayData.item(\"configuration\", serializableConfiguration.get().toString()));\n+      builder.add(DisplayData.item(\"configuration\", configuration.toString()));\n       builder.add(DisplayData.item(\"tableId\", tableId));\n-      builder.addIfNotNull(DisplayData.item(\"scan\", serializableScan.get().toString()));\n+      builder.addIfNotNull(DisplayData.item(\"scan\", scan.toString()));\n     }\n \n     public Configuration getConfiguration() {\n-      return serializableConfiguration.get();\n+      return configuration;\n     }\n \n     public String getTableId() {\n       return tableId;\n     }\n \n     public Scan getScan() {\n-      return serializableScan.get();\n+      return scan;\n     }\n \n     /** Returns the range of keys that will be read from the table. */\n     public ByteKeyRange getKeyRange() {\n-      byte[] startRow = serializableScan.get().getStartRow();\n-      byte[] stopRow = serializableScan.get().getStopRow();\n+      byte[] startRow = scan.getStartRow();\n+      byte[] stopRow = scan.getStopRow();\n       return ByteKeyRange.of(ByteKey.copyFrom(startRow), ByteKey.copyFrom(stopRow));\n     }\n \n-    private final SerializableConfiguration serializableConfiguration;\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      Read read = (Read) o;\n+      return configuration.toString().equals(read.configuration.toString())\n+          && Objects.equals(tableId, read.tableId)\n+          && scan.toString().equals(read.scan.toString());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(configuration, tableId, scan);\n+    }\n+\n+    private Object writeReplace() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkyOTAxOA=="}, "originalCommit": {"oid": "df531f48a8dbf3e567036e5acbd9bcc4633e9924"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUzMDQzMA==", "bodyText": "Please, add this warning/note to top class Javadoc", "url": "https://github.com/apache/beam/pull/10815#discussion_r394530430", "createdAt": "2020-03-18T17:45:11Z", "author": {"login": "aromanenko-dev"}, "path": "sdks/java/io/hbase/src/main/java/org/apache/beam/sdk/io/hbase/HBaseIO.java", "diffHunk": "@@ -240,63 +245,109 @@ private Read(\n     @Override\n     public void populateDisplayData(DisplayData.Builder builder) {\n       super.populateDisplayData(builder);\n-      builder.add(DisplayData.item(\"configuration\", serializableConfiguration.get().toString()));\n+      builder.add(DisplayData.item(\"configuration\", configuration.toString()));\n       builder.add(DisplayData.item(\"tableId\", tableId));\n-      builder.addIfNotNull(DisplayData.item(\"scan\", serializableScan.get().toString()));\n+      builder.addIfNotNull(DisplayData.item(\"scan\", scan.toString()));\n     }\n \n     public Configuration getConfiguration() {\n-      return serializableConfiguration.get();\n+      return configuration;\n     }\n \n     public String getTableId() {\n       return tableId;\n     }\n \n     public Scan getScan() {\n-      return serializableScan.get();\n+      return scan;\n     }\n \n     /** Returns the range of keys that will be read from the table. */\n     public ByteKeyRange getKeyRange() {\n-      byte[] startRow = serializableScan.get().getStartRow();\n-      byte[] stopRow = serializableScan.get().getStopRow();\n+      byte[] startRow = scan.getStartRow();\n+      byte[] stopRow = scan.getStopRow();\n       return ByteKeyRange.of(ByteKey.copyFrom(startRow), ByteKey.copyFrom(stopRow));\n     }\n \n-    private final SerializableConfiguration serializableConfiguration;\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      Read read = (Read) o;\n+      return configuration.toString().equals(read.configuration.toString())\n+          && Objects.equals(tableId, read.tableId)\n+          && scan.toString().equals(read.scan.toString());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(configuration, tableId, scan);\n+    }\n+\n+    private Object writeReplace() {\n+      return new SerializationProxy(this);\n+    }\n+\n+    private static class SerializationProxy implements Serializable {\n+      public SerializationProxy() {}\n+\n+      public SerializationProxy(Read read) {\n+        configuration = read.configuration;\n+        tableId = read.tableId;\n+        scan = read.scan;\n+      }\n+\n+      private void writeObject(ObjectOutputStream out) throws IOException {\n+        SerializableCoder.of(SerializableConfiguration.class)\n+            .encode(new SerializableConfiguration(this.configuration), out);\n+        StringUtf8Coder.of().encode(this.tableId, out);\n+        ProtobufUtil.toScan(this.scan).writeDelimitedTo(out);\n+      }\n+\n+      private void readObject(ObjectInputStream in) throws IOException {\n+        this.configuration = SerializableCoder.of(SerializableConfiguration.class).decode(in).get();\n+        this.tableId = StringUtf8Coder.of().decode(in);\n+        this.scan = ProtobufUtil.toScan(ClientProtos.Scan.parseDelimitedFrom(in));\n+      }\n+\n+      Object readResolve() {\n+        return HBaseIO.read().withConfiguration(configuration).withTableId(tableId).withScan(scan);\n+      }\n+\n+      private Configuration configuration;\n+      private String tableId;\n+      private Scan scan;\n+    }\n+\n+    @SuppressFBWarnings(\"SE_BAD_FIELD\")\n+    private final Configuration configuration;\n+\n     private final String tableId;\n-    private final SerializableScan serializableScan;\n+\n+    @SuppressFBWarnings(\"SE_BAD_FIELD\")\n+    private final Scan scan;\n   }\n \n   /**\n    * A {@link PTransform} that works like {@link #read}, but executes read operations coming from a\n-   * {@link PCollection} of {@link HBaseQuery}.\n+   * {@link PCollection} of {@link Read}.\n    */\n   public static ReadAll readAll() {\n-    return new ReadAll(null);\n+    return new ReadAll();\n   }\n \n   /** Implementation of {@link #readAll}. */\n-  public static class ReadAll extends PTransform<PCollection<HBaseQuery>, PCollection<Result>> {\n-\n-    private ReadAll(SerializableConfiguration serializableConfiguration) {\n-      this.serializableConfiguration = serializableConfiguration;\n-    }\n-\n-    /** Reads from the HBase instance indicated by the* given configuration. */\n-    public ReadAll withConfiguration(Configuration configuration) {\n-      checkArgument(configuration != null, \"configuration can not be null\");\n-      return new ReadAll(new SerializableConfiguration(configuration));\n-    }\n+  public static class ReadAll extends PTransform<PCollection<Read>, PCollection<Result>> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyNTI4Nw=="}, "originalCommit": {"oid": "df531f48a8dbf3e567036e5acbd9bcc4633e9924"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUzNDA5Mw==", "bodyText": "Please, add TODO about that.  Did you try to run performance test to see how much it's slower?", "url": "https://github.com/apache/beam/pull/10815#discussion_r394534093", "createdAt": "2020-03-18T17:51:04Z", "author": {"login": "aromanenko-dev"}, "path": "sdks/java/io/hbase/src/main/java/org/apache/beam/sdk/io/hbase/HBaseReadSplittableDoFn.java", "diffHunk": "@@ -32,65 +31,50 @@\n import org.apache.hadoop.hbase.client.ConnectionFactory;\n import org.apache.hadoop.hbase.client.Result;\n import org.apache.hadoop.hbase.client.ResultScanner;\n-import org.apache.hadoop.hbase.client.Scan;\n import org.apache.hadoop.hbase.client.Table;\n \n /** A SplittableDoFn to read from HBase. */\n @BoundedPerElement\n-class HBaseReadSplittableDoFn extends DoFn<HBaseQuery, Result> {\n-  private final SerializableConfiguration serializableConfiguration;\n-\n-  private transient Connection connection;\n-\n-  HBaseReadSplittableDoFn(SerializableConfiguration serializableConfiguration) {\n-    this.serializableConfiguration = serializableConfiguration;\n-  }\n-\n-  @Setup\n-  public void setup() throws Exception {\n-    connection = ConnectionFactory.createConnection(serializableConfiguration.get());\n-  }\n-\n-  private static Scan newScanInRange(Scan scan, ByteKeyRange range) throws IOException {\n-    return new Scan(scan)\n-        .setStartRow(range.getStartKey().getBytes())\n-        .setStopRow(range.getEndKey().getBytes());\n-  }\n+class HBaseReadSplittableDoFn extends DoFn<Read, Result> {\n+  HBaseReadSplittableDoFn() {}\n \n   @ProcessElement\n-  public void processElement(ProcessContext c, RestrictionTracker<ByteKeyRange, ByteKey> tracker)\n+  public void processElement(\n+      @Element Read read,\n+      OutputReceiver<Result> out,\n+      RestrictionTracker<ByteKeyRange, ByteKey> tracker)\n       throws Exception {\n-    final HBaseQuery query = c.element();\n-    TableName tableName = TableName.valueOf(query.getTableId());\n+    Connection connection = ConnectionFactory.createConnection(read.getConfiguration());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzMDYxOQ=="}, "originalCommit": {"oid": "df531f48a8dbf3e567036e5acbd9bcc4633e9924"}, "originalPosition": 51}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4fa842024c4da8db479505b256528f06173f9699", "author": {"user": {"login": "iemejia", "name": "Isma\u00ebl Mej\u00eda"}}, "url": "https://github.com/apache/beam/commit/4fa842024c4da8db479505b256528f06173f9699", "committedDate": "2020-03-19T09:32:30Z", "message": "[BEAM-9279] Refactor HBase to disminish relying on Serializable wrappers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b653b430875a3652dc01c0ba60ecb3f8239c299", "author": {"user": {"login": "iemejia", "name": "Isma\u00ebl Mej\u00eda"}}, "url": "https://github.com/apache/beam/commit/8b653b430875a3652dc01c0ba60ecb3f8239c299", "committedDate": "2020-03-19T09:32:30Z", "message": "[BEAM-9279] Make HBase.ReadAll based on Reads instead of HBaseQuery\n\nThis enable pipelines that can read from multiple configurations\nenabling pipelines to read simultaneously from multiple HBase clusters."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "df531f48a8dbf3e567036e5acbd9bcc4633e9924", "author": {"user": {"login": "iemejia", "name": "Isma\u00ebl Mej\u00eda"}}, "url": "https://github.com/apache/beam/commit/df531f48a8dbf3e567036e5acbd9bcc4633e9924", "committedDate": "2020-02-10T08:43:49Z", "message": "[BEAM-9279] Make HBase.ReadAll based on Reads instead of HBaseQuery\n\nThis enable pipelines that can read from multiple configurations\nenabling pipelines to read simultaneously from multiple HBase clusters."}, "afterCommit": {"oid": "8b653b430875a3652dc01c0ba60ecb3f8239c299", "author": {"user": {"login": "iemejia", "name": "Isma\u00ebl Mej\u00eda"}}, "url": "https://github.com/apache/beam/commit/8b653b430875a3652dc01c0ba60ecb3f8239c299", "committedDate": "2020-03-19T09:32:30Z", "message": "[BEAM-9279] Make HBase.ReadAll based on Reads instead of HBaseQuery\n\nThis enable pipelines that can read from multiple configurations\nenabling pipelines to read simultaneously from multiple HBase clusters."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3029, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}