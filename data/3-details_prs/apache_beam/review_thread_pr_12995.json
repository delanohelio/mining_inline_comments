{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk2NjAxNzk1", "number": 12995, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMjowODoxOVrOFL6rVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOFQyMDoyNjoxOVrOFYCfmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDQwMDIwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMjowODoxOVrOIPXn5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOFQyMTozNDowNFrOIh33hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk4NjU5Nw==", "bodyText": "self._worker_handler -> self._worker_handle?", "url": "https://github.com/apache/beam/pull/12995#discussion_r552986597", "createdAt": "2021-01-06T22:08:19Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "diffHunk": "@@ -298,6 +301,198 @@ def from_runner_api_parameter(window_coder_id, context):\n         context.coders[window_coder_id.decode('utf-8')])\n \n \n+class GenericMergingWindowFn(window.WindowFn):\n+\n+  URN = 'internal-generic-merging'\n+\n+  TO_SDK_TRANSFORM = 'read'\n+  FROM_SDK_TRANSFORM = 'write'\n+\n+  _HANDLES = {}\n+\n+  def __init__(self, execution_context, windowing_strategy_proto):\n+    self._worker_handle = None\n+    self._handle_id = handle_id = uuid.uuid4().hex\n+    self._HANDLES[handle_id] = self\n+    # ExecutionContexts are expensive, we don't want to keep them in the\n+    # static dictionary forever.  Instead we hold a weakref and pop self\n+    # out of the dict once this context goes away.\n+    self._execution_context_ref = weakref.ref(\n+        execution_context, lambda _: self._HANDLES.pop(handle_id, None))\n+    self._windowing_strategy_proto = windowing_strategy_proto\n+    self._process_bundle_descriptor = None\n+    self._counter = 0\n+\n+  def payload(self):\n+    return self._handle_id.encode('utf-8')\n+\n+  @staticmethod\n+  @window.urns.RunnerApiFn.register_urn(URN, bytes)\n+  def from_runner_api_parameter(handle_id, unused_context):\n+    return GenericMergingWindowFn._HANDLES[handle_id.decode('utf-8')]\n+\n+  def assign(self, assign_context):\n+    raise NotImplementedError()\n+\n+  def merge(self, merge_context):\n+    worker_handler = self.worker_handle()\n+\n+    process_bundle_id = self.uid('process')\n+    to_worker = worker_handler.data_conn.output_stream(\n+        process_bundle_id, self.TO_SDK_TRANSFORM)\n+    to_worker.write(\n+        self.windowed_input_coder_impl.encode_nested(\n+            window.GlobalWindows.windowed_value((b'', merge_context.windows))))\n+    to_worker.close()\n+\n+    process_bundle_req = beam_fn_api_pb2.InstructionRequest(\n+        instruction_id=process_bundle_id,\n+        process_bundle=beam_fn_api_pb2.ProcessBundleRequest(\n+            process_bundle_descriptor_id=self._bundle_processor_id))\n+    result_future = worker_handler.control_conn.push(process_bundle_req)\n+    for output in worker_handler.data_conn.input_elements(\n+        process_bundle_id, [self.FROM_SDK_TRANSFORM],\n+        abort_callback=lambda:\n+        (result_future.is_done() and result_future.get().error)):\n+      if isinstance(output, beam_fn_api_pb2.Elements.Data):\n+        windowed_result = self.windowed_output_coder_impl.decode_nested(\n+            output.data)\n+        for merge_result, originals in windowed_result.value[1][1]:\n+          merge_context.merge(originals, merge_result)\n+      else:\n+        raise RuntimeError(\"Unexpected data: %s\" % output)\n+\n+    result = result_future.get()\n+    if result.error:\n+      raise RuntimeError(result.error)\n+    # The result was \"returned\" via the merge callbacks on merge_context above.\n+\n+  def get_window_coder(self):\n+    return self._execution_context_ref().pipeline_context.coders[\n+        self._windowing_strategy_proto.window_coder_id]\n+\n+  def worker_handle(self):\n+    if self._worker_handle is None:\n+      worker_handler_manager = self._execution_context_ref(\n+      ).worker_handler_manager\n+      self._worker_handler = worker_handler_manager.get_worker_handlers(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37986fe315fa8abc719a86eb1ba763157d3368d6"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjM4OTI1NQ==", "bodyText": "Good catch. Fixed.", "url": "https://github.com/apache/beam/pull/12995#discussion_r572389255", "createdAt": "2021-02-08T21:34:04Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "diffHunk": "@@ -298,6 +301,198 @@ def from_runner_api_parameter(window_coder_id, context):\n         context.coders[window_coder_id.decode('utf-8')])\n \n \n+class GenericMergingWindowFn(window.WindowFn):\n+\n+  URN = 'internal-generic-merging'\n+\n+  TO_SDK_TRANSFORM = 'read'\n+  FROM_SDK_TRANSFORM = 'write'\n+\n+  _HANDLES = {}\n+\n+  def __init__(self, execution_context, windowing_strategy_proto):\n+    self._worker_handle = None\n+    self._handle_id = handle_id = uuid.uuid4().hex\n+    self._HANDLES[handle_id] = self\n+    # ExecutionContexts are expensive, we don't want to keep them in the\n+    # static dictionary forever.  Instead we hold a weakref and pop self\n+    # out of the dict once this context goes away.\n+    self._execution_context_ref = weakref.ref(\n+        execution_context, lambda _: self._HANDLES.pop(handle_id, None))\n+    self._windowing_strategy_proto = windowing_strategy_proto\n+    self._process_bundle_descriptor = None\n+    self._counter = 0\n+\n+  def payload(self):\n+    return self._handle_id.encode('utf-8')\n+\n+  @staticmethod\n+  @window.urns.RunnerApiFn.register_urn(URN, bytes)\n+  def from_runner_api_parameter(handle_id, unused_context):\n+    return GenericMergingWindowFn._HANDLES[handle_id.decode('utf-8')]\n+\n+  def assign(self, assign_context):\n+    raise NotImplementedError()\n+\n+  def merge(self, merge_context):\n+    worker_handler = self.worker_handle()\n+\n+    process_bundle_id = self.uid('process')\n+    to_worker = worker_handler.data_conn.output_stream(\n+        process_bundle_id, self.TO_SDK_TRANSFORM)\n+    to_worker.write(\n+        self.windowed_input_coder_impl.encode_nested(\n+            window.GlobalWindows.windowed_value((b'', merge_context.windows))))\n+    to_worker.close()\n+\n+    process_bundle_req = beam_fn_api_pb2.InstructionRequest(\n+        instruction_id=process_bundle_id,\n+        process_bundle=beam_fn_api_pb2.ProcessBundleRequest(\n+            process_bundle_descriptor_id=self._bundle_processor_id))\n+    result_future = worker_handler.control_conn.push(process_bundle_req)\n+    for output in worker_handler.data_conn.input_elements(\n+        process_bundle_id, [self.FROM_SDK_TRANSFORM],\n+        abort_callback=lambda:\n+        (result_future.is_done() and result_future.get().error)):\n+      if isinstance(output, beam_fn_api_pb2.Elements.Data):\n+        windowed_result = self.windowed_output_coder_impl.decode_nested(\n+            output.data)\n+        for merge_result, originals in windowed_result.value[1][1]:\n+          merge_context.merge(originals, merge_result)\n+      else:\n+        raise RuntimeError(\"Unexpected data: %s\" % output)\n+\n+    result = result_future.get()\n+    if result.error:\n+      raise RuntimeError(result.error)\n+    # The result was \"returned\" via the merge callbacks on merge_context above.\n+\n+  def get_window_coder(self):\n+    return self._execution_context_ref().pipeline_context.coders[\n+        self._windowing_strategy_proto.window_coder_id]\n+\n+  def worker_handle(self):\n+    if self._worker_handle is None:\n+      worker_handler_manager = self._execution_context_ref(\n+      ).worker_handler_manager\n+      self._worker_handler = worker_handler_manager.get_worker_handlers(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk4NjU5Nw=="}, "originalCommit": {"oid": "37986fe315fa8abc719a86eb1ba763157d3368d6"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwNzUxMDAyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/flink_runner_test.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOFQyMDoyNjoxOVrOIh1U3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOFQyMTozMzo1N1rOIh33Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjM0NzYxNQ==", "bodyText": "we may need to add this to spark_runner_test.py as well.", "url": "https://github.com/apache/beam/pull/12995#discussion_r572347615", "createdAt": "2021-02-08T20:26:19Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/runners/portability/flink_runner_test.py", "diffHunk": "@@ -400,6 +400,9 @@ def test_callbacks_with_exception(self):\n   def test_register_finalizations(self):\n     raise unittest.SkipTest(\"BEAM-6868\")\n \n+  def test_custom_merging_window(self):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37986fe315fa8abc719a86eb1ba763157d3368d6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjM4OTE5MA==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/12995#discussion_r572389190", "createdAt": "2021-02-08T21:33:57Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/flink_runner_test.py", "diffHunk": "@@ -400,6 +400,9 @@ def test_callbacks_with_exception(self):\n   def test_register_finalizations(self):\n     raise unittest.SkipTest(\"BEAM-6868\")\n \n+  def test_custom_merging_window(self):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjM0NzYxNQ=="}, "originalCommit": {"oid": "37986fe315fa8abc719a86eb1ba763157d3368d6"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3098, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}