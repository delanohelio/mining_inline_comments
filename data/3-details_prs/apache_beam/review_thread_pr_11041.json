{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzNzE5Njkz", "number": 11041, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo1MDoxMlrODy-ToQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo1MDoxMlrODy-ToQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzc2MjI1OnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/transform/BeamJoinTransforms.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo1MDoxMlrOGHVknA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo1MToyNFrOGHVnIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NjY1Mg==", "bodyText": "This actually hardcodes a bad assumption a bit further than it was before: that the join is only on columns. We want to move in the other direction, and allow join conditions to be more general RexNodes, many of which still work for CoGBK and side input lookup joins. This is BEAM-6112.", "url": "https://github.com/apache/beam/pull/11041#discussion_r410346652", "createdAt": "2020-04-17T16:50:12Z", "author": {"login": "kennknowles"}, "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/transform/BeamJoinTransforms.java", "diffHunk": "@@ -45,111 +41,35 @@\n /** Collections of {@code PTransform} and {@code DoFn} used to perform JOIN operation. */\n public class BeamJoinTransforms {\n \n-  /** A {@code SimpleFunction} to extract join fields from the specified row. */\n-  public static class ExtractJoinFields extends SimpleFunction<Row, KV<Row, Row>> {\n-    private final List<SerializableRexNode> joinColumns;\n-    private final Schema schema;\n-    private int leftRowColumnCount;\n-\n-    public ExtractJoinFields(\n-        boolean isLeft,\n-        List<Pair<RexNode, RexNode>> joinColumns,\n-        Schema schema,\n-        int leftRowColumnCount) {\n-      this.joinColumns =\n-          joinColumns.stream()\n-              .map(pair -> SerializableRexNode.builder(isLeft ? pair.left : pair.right).build())\n-              .collect(toList());\n-      this.schema = schema;\n-      this.leftRowColumnCount = leftRowColumnCount;\n-    }\n-\n-    @Override\n-    public KV<Row, Row> apply(Row input) {\n-      Row row =\n-          joinColumns.stream()\n-              .map(v -> getValue(v, input, leftRowColumnCount))\n-              .collect(toRow(schema));\n-      return KV.of(row, input);\n-    }\n-\n-    @SuppressWarnings(\"unused\")\n-    private Schema.Field toField(Schema schema, Integer fieldIndex) {\n-      Schema.Field original = schema.getField(fieldIndex);\n-      return original.withName(\"c\" + fieldIndex);\n-    }\n-\n-    private Object getValue(\n-        SerializableRexNode serializableRexNode, Row input, int leftRowColumnCount) {\n-      if (serializableRexNode instanceof SerializableRexInputRef) {\n-        return input.getValue(\n-            ((SerializableRexInputRef) serializableRexNode).getIndex() - leftRowColumnCount);\n-      } else { // It can only be SerializableFieldAccess.\n-        List<Integer> indexes = ((SerializableRexFieldAccess) serializableRexNode).getIndexes();\n-        // retrieve row based on the first column reference.\n-        Row rowField = input.getValue(indexes.get(0) - leftRowColumnCount);\n-        for (int i = 1; i < indexes.size() - 1; i++) {\n-          rowField = rowField.getRow(indexes.get(i));\n-        }\n-        return rowField.getValue(indexes.get(indexes.size() - 1));\n-      }\n-    }\n+  public static FieldAccessDescriptor getJoinColumns(\n+      boolean isLeft,\n+      List<Pair<RexNode, RexNode>> joinColumns,\n+      int leftRowColumnCount,\n+      Schema schema) {\n+    List<SerializableRexNode> joinColumnsBuilt =\n+        joinColumns.stream()\n+            .map(pair -> SerializableRexNode.builder(isLeft ? pair.left : pair.right).build())\n+            .collect(toList());\n+    return FieldAccessDescriptor.union(\n+        joinColumnsBuilt.stream()\n+            .map(v -> getJoinColumn(v, leftRowColumnCount).resolve(schema))\n+            .collect(Collectors.toList()));\n   }\n \n-  /** A {@code DoFn} which implement the sideInput-JOIN. */\n-  public static class SideInputJoinDoFn extends DoFn<KV<Row, Row>, Row> {\n-    private final PCollectionView<Map<Row, Iterable<Row>>> sideInputView;\n-    private final JoinRelType joinType;\n-    private final Row rightNullRow;\n-    private final boolean swap;\n-    private final Schema schema;\n-\n-    public SideInputJoinDoFn(\n-        JoinRelType joinType,\n-        Row rightNullRow,\n-        PCollectionView<Map<Row, Iterable<Row>>> sideInputView,\n-        boolean swap,\n-        Schema schema) {\n-      this.joinType = joinType;\n-      this.rightNullRow = rightNullRow;\n-      this.sideInputView = sideInputView;\n-      this.swap = swap;\n-      this.schema = schema;\n-    }\n-\n-    @ProcessElement\n-    public void processElement(ProcessContext context) {\n-      Row key = context.element().getKey();\n-      Row leftRow = context.element().getValue();\n-      Map<Row, Iterable<Row>> key2Rows = context.sideInput(sideInputView);\n-      Iterable<Row> rightRowsIterable = key2Rows.get(key);\n-\n-      if (rightRowsIterable != null && rightRowsIterable.iterator().hasNext()) {\n-        for (Row aRightRowsIterable : rightRowsIterable) {\n-          context.output(combineTwoRowsIntoOne(leftRow, aRightRowsIterable, swap, schema));\n-        }\n-      } else {\n-        if (joinType == JoinRelType.LEFT) {\n-          context.output(combineTwoRowsIntoOne(leftRow, rightNullRow, swap, schema));\n-        }\n+  private static FieldAccessDescriptor getJoinColumn(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37b1fbaa7ea1b64303eaacae9e670797a92b1a50"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NzI5Nw==", "bodyText": "I noticed this, because in the current codebase on master we could inline and delete SerializableRexNode entirely. So I went looking for how we encoding a full expression to be joined on. I didn't see rules that precomputed all of them (in which case input refs would suffice).", "url": "https://github.com/apache/beam/pull/11041#discussion_r410347297", "createdAt": "2020-04-17T16:51:24Z", "author": {"login": "kennknowles"}, "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/transform/BeamJoinTransforms.java", "diffHunk": "@@ -45,111 +41,35 @@\n /** Collections of {@code PTransform} and {@code DoFn} used to perform JOIN operation. */\n public class BeamJoinTransforms {\n \n-  /** A {@code SimpleFunction} to extract join fields from the specified row. */\n-  public static class ExtractJoinFields extends SimpleFunction<Row, KV<Row, Row>> {\n-    private final List<SerializableRexNode> joinColumns;\n-    private final Schema schema;\n-    private int leftRowColumnCount;\n-\n-    public ExtractJoinFields(\n-        boolean isLeft,\n-        List<Pair<RexNode, RexNode>> joinColumns,\n-        Schema schema,\n-        int leftRowColumnCount) {\n-      this.joinColumns =\n-          joinColumns.stream()\n-              .map(pair -> SerializableRexNode.builder(isLeft ? pair.left : pair.right).build())\n-              .collect(toList());\n-      this.schema = schema;\n-      this.leftRowColumnCount = leftRowColumnCount;\n-    }\n-\n-    @Override\n-    public KV<Row, Row> apply(Row input) {\n-      Row row =\n-          joinColumns.stream()\n-              .map(v -> getValue(v, input, leftRowColumnCount))\n-              .collect(toRow(schema));\n-      return KV.of(row, input);\n-    }\n-\n-    @SuppressWarnings(\"unused\")\n-    private Schema.Field toField(Schema schema, Integer fieldIndex) {\n-      Schema.Field original = schema.getField(fieldIndex);\n-      return original.withName(\"c\" + fieldIndex);\n-    }\n-\n-    private Object getValue(\n-        SerializableRexNode serializableRexNode, Row input, int leftRowColumnCount) {\n-      if (serializableRexNode instanceof SerializableRexInputRef) {\n-        return input.getValue(\n-            ((SerializableRexInputRef) serializableRexNode).getIndex() - leftRowColumnCount);\n-      } else { // It can only be SerializableFieldAccess.\n-        List<Integer> indexes = ((SerializableRexFieldAccess) serializableRexNode).getIndexes();\n-        // retrieve row based on the first column reference.\n-        Row rowField = input.getValue(indexes.get(0) - leftRowColumnCount);\n-        for (int i = 1; i < indexes.size() - 1; i++) {\n-          rowField = rowField.getRow(indexes.get(i));\n-        }\n-        return rowField.getValue(indexes.get(indexes.size() - 1));\n-      }\n-    }\n+  public static FieldAccessDescriptor getJoinColumns(\n+      boolean isLeft,\n+      List<Pair<RexNode, RexNode>> joinColumns,\n+      int leftRowColumnCount,\n+      Schema schema) {\n+    List<SerializableRexNode> joinColumnsBuilt =\n+        joinColumns.stream()\n+            .map(pair -> SerializableRexNode.builder(isLeft ? pair.left : pair.right).build())\n+            .collect(toList());\n+    return FieldAccessDescriptor.union(\n+        joinColumnsBuilt.stream()\n+            .map(v -> getJoinColumn(v, leftRowColumnCount).resolve(schema))\n+            .collect(Collectors.toList()));\n   }\n \n-  /** A {@code DoFn} which implement the sideInput-JOIN. */\n-  public static class SideInputJoinDoFn extends DoFn<KV<Row, Row>, Row> {\n-    private final PCollectionView<Map<Row, Iterable<Row>>> sideInputView;\n-    private final JoinRelType joinType;\n-    private final Row rightNullRow;\n-    private final boolean swap;\n-    private final Schema schema;\n-\n-    public SideInputJoinDoFn(\n-        JoinRelType joinType,\n-        Row rightNullRow,\n-        PCollectionView<Map<Row, Iterable<Row>>> sideInputView,\n-        boolean swap,\n-        Schema schema) {\n-      this.joinType = joinType;\n-      this.rightNullRow = rightNullRow;\n-      this.sideInputView = sideInputView;\n-      this.swap = swap;\n-      this.schema = schema;\n-    }\n-\n-    @ProcessElement\n-    public void processElement(ProcessContext context) {\n-      Row key = context.element().getKey();\n-      Row leftRow = context.element().getValue();\n-      Map<Row, Iterable<Row>> key2Rows = context.sideInput(sideInputView);\n-      Iterable<Row> rightRowsIterable = key2Rows.get(key);\n-\n-      if (rightRowsIterable != null && rightRowsIterable.iterator().hasNext()) {\n-        for (Row aRightRowsIterable : rightRowsIterable) {\n-          context.output(combineTwoRowsIntoOne(leftRow, aRightRowsIterable, swap, schema));\n-        }\n-      } else {\n-        if (joinType == JoinRelType.LEFT) {\n-          context.output(combineTwoRowsIntoOne(leftRow, rightNullRow, swap, schema));\n-        }\n+  private static FieldAccessDescriptor getJoinColumn(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NjY1Mg=="}, "originalCommit": {"oid": "37b1fbaa7ea1b64303eaacae9e670797a92b1a50"}, "originalPosition": 132}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1780, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}