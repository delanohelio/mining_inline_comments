{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk3MTYxMjA4", "number": 13005, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoyMDowNlrOEqbj6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoyMDowNlrOEqbj6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTI3MjExOnYy", "diffSide": "RIGHT", "path": "website/www/site/content/en/documentation/programming-guide.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoyMDowNlrOHcoiWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMzo0Njo0M1rOHeJU9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4NjMzMA==", "bodyText": "Is it worth calling out Select as well?", "url": "https://github.com/apache/beam/pull/13005#discussion_r499786330", "createdAt": "2020-10-05T18:20:06Z", "author": {"login": "robertwb"}, "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -2546,10 +2611,68 @@ public abstract class TransactionValue {\n }\n {{< /highlight >}}\n \n+{{< paragraph class=\"language-java\" >}}\n This is all that\u2019s needed to generate a simple AutoValue class, and the above `@DefaultSchema` annotation tells Beam to\n infer a schema from it. This also allows AutoValue elements to be used inside of `PCollection`s.\n+{{< /paragraph >}}\n \n+{{< paragraph class=\"language-java\" >}}\n `@SchemaFieldName` and `@SchemaIgnore` can be used to alter the schema inferred.\n+{{< /paragraph >}}\n+\n+{{< paragraph class=\"language-py\" >}}\n+Beam has a few different mechanisms for inferring schemas from Python code.\n+{{< /paragraph >}}\n+\n+{{< paragraph class=\"language-py\" >}}\n+**NamedTuple classes**\n+{{< /paragraph >}}\n+\n+{{< paragraph class=\"language-py\" >}}\n+A [NamedTuple](https://docs.python.org/3/library/typing.html#typing.NamedTuple)\n+class is a Python class that wraps a `tuple`, assigning a name to each element\n+and restricting it to a particular type. Beam will automatically infer the\n+schema for PCollections with `NamedTuple` output types. For example:\n+{{< /paragraph >}}\n+\n+{{< highlight py >}}\n+class Transaction(typing.NamedTuple):\n+  bank: str\n+  purchase_amount: float\n+\n+pc = input | beam.Map(lambda ...).with_output_types(Transaction)\n+{{< /highlight >}}\n+\n+\n+{{< paragraph class=\"language-py\" >}}\n+**beam.Row**\n+{{< /paragraph >}}\n+\n+{{< paragraph class=\"language-py\" >}}\n+It's also possible to create ad-hoc schema declarations with a simple lambda\n+that returns instances of `beam.Row`:\n+{{< /paragraph >}}\n+\n+{{< highlight py >}}\n+input_pc = ... # {\"bank\": ..., \"purchase_amount\": ...}\n+output_pc = input_pc | beam.Map(lambda item: beam.Row(bank=item[\"bank\"],\n+                                                      purchase_amount=item[\"purchase_amount\"])\n+{{< /highlight >}}\n+\n+{{< paragraph class=\"language-py\" >}}\n+Note that this declaration doesn't include any specific information about the\n+types of the `bank` and `purchase_amount` fields. Beam will attempt to infer\n+type information, if it's unable to it will fall back to the generic type\n+`Any`. Sometimes this is not ideal, you can use casts to make sure Beam\n+correctly infers types with `beam.Row`:\n+{{< /paragraph >}}\n+\n+{{< highlight py >}}\n+input_pc = ... # {\"bank\": ..., \"purchase_amount\": ...}\n+output_pc = input_pc | beam.Map(lambda item: beam.Row(bank=str(item[\"bank\"]),\n+                                                      purchase_amount=float(item[\"purchase_amount\"]))\n+{{< /highlight >}}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b370b4c457e91eaa031c6f8edbe8b4a196dd6461"}, "originalPosition": 270}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM3MjE1MQ==", "bodyText": "Good idea! I'll add it in a separate PR and we can merge it once Select is available in 2.25.0", "url": "https://github.com/apache/beam/pull/13005#discussion_r501372151", "createdAt": "2020-10-07T23:46:43Z", "author": {"login": "TheNeuralBit"}, "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -2546,10 +2611,68 @@ public abstract class TransactionValue {\n }\n {{< /highlight >}}\n \n+{{< paragraph class=\"language-java\" >}}\n This is all that\u2019s needed to generate a simple AutoValue class, and the above `@DefaultSchema` annotation tells Beam to\n infer a schema from it. This also allows AutoValue elements to be used inside of `PCollection`s.\n+{{< /paragraph >}}\n \n+{{< paragraph class=\"language-java\" >}}\n `@SchemaFieldName` and `@SchemaIgnore` can be used to alter the schema inferred.\n+{{< /paragraph >}}\n+\n+{{< paragraph class=\"language-py\" >}}\n+Beam has a few different mechanisms for inferring schemas from Python code.\n+{{< /paragraph >}}\n+\n+{{< paragraph class=\"language-py\" >}}\n+**NamedTuple classes**\n+{{< /paragraph >}}\n+\n+{{< paragraph class=\"language-py\" >}}\n+A [NamedTuple](https://docs.python.org/3/library/typing.html#typing.NamedTuple)\n+class is a Python class that wraps a `tuple`, assigning a name to each element\n+and restricting it to a particular type. Beam will automatically infer the\n+schema for PCollections with `NamedTuple` output types. For example:\n+{{< /paragraph >}}\n+\n+{{< highlight py >}}\n+class Transaction(typing.NamedTuple):\n+  bank: str\n+  purchase_amount: float\n+\n+pc = input | beam.Map(lambda ...).with_output_types(Transaction)\n+{{< /highlight >}}\n+\n+\n+{{< paragraph class=\"language-py\" >}}\n+**beam.Row**\n+{{< /paragraph >}}\n+\n+{{< paragraph class=\"language-py\" >}}\n+It's also possible to create ad-hoc schema declarations with a simple lambda\n+that returns instances of `beam.Row`:\n+{{< /paragraph >}}\n+\n+{{< highlight py >}}\n+input_pc = ... # {\"bank\": ..., \"purchase_amount\": ...}\n+output_pc = input_pc | beam.Map(lambda item: beam.Row(bank=item[\"bank\"],\n+                                                      purchase_amount=item[\"purchase_amount\"])\n+{{< /highlight >}}\n+\n+{{< paragraph class=\"language-py\" >}}\n+Note that this declaration doesn't include any specific information about the\n+types of the `bank` and `purchase_amount` fields. Beam will attempt to infer\n+type information, if it's unable to it will fall back to the generic type\n+`Any`. Sometimes this is not ideal, you can use casts to make sure Beam\n+correctly infers types with `beam.Row`:\n+{{< /paragraph >}}\n+\n+{{< highlight py >}}\n+input_pc = ... # {\"bank\": ..., \"purchase_amount\": ...}\n+output_pc = input_pc | beam.Map(lambda item: beam.Row(bank=str(item[\"bank\"]),\n+                                                      purchase_amount=float(item[\"purchase_amount\"]))\n+{{< /highlight >}}\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4NjMzMA=="}, "originalCommit": {"oid": "b370b4c457e91eaa031c6f8edbe8b4a196dd6461"}, "originalPosition": 270}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3108, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}