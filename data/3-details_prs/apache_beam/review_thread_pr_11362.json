{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxMzQ1MTc3", "number": 11362, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNTo0NDowM1rOD1GiNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjowNToxN1rOD1G5Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDA4MTgxOnYy", "diffSide": "RIGHT", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNTo0NDowM1rOGKXj9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNzoyNToxOVrOGKznBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUyNDk4Mw==", "bodyText": "Don't we have to emit pushed back data at this point (up to the side input watermark), even when it is not the final watermark?", "url": "https://github.com/apache/beam/pull/11362#discussion_r413524983", "createdAt": "2020-04-23T05:44:03Z", "author": {"login": "tweise"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -658,46 +671,69 @@ public void processWatermark1(Watermark mark) throws Exception {\n       emitAllPushedBackData();\n     }\n \n-    setCurrentInputWatermark(mark.getTimestamp());\n+    currentInputWatermark = mark.getTimestamp();\n \n-    if (keyCoder == null) {\n-      long potentialOutputWatermark = Math.min(getPushbackWatermarkHold(), currentInputWatermark);\n-      if (potentialOutputWatermark > currentOutputWatermark) {\n-        setCurrentOutputWatermark(potentialOutputWatermark);\n-        emitWatermark(currentOutputWatermark);\n-      }\n-    } else {\n-      // hold back by the pushed back values waiting for side inputs\n-      long pushedBackInputWatermark = Math.min(getPushbackWatermarkHold(), mark.getTimestamp());\n+    long inputWatermarkHold = applyInputWatermarkHold(getEffectiveInputWatermark());\n+    if (keyCoder != null) {\n+      timeServiceManager.advanceWatermark(new Watermark(inputWatermarkHold));\n+    }\n \n-      timeServiceManager.advanceWatermark(new Watermark(pushedBackInputWatermark));\n+    long potentialOutputWatermark =\n+        applyOutputWatermarkHold(\n+            currentOutputWatermark, computeOutputWatermark(inputWatermarkHold));\n+    maybeEmitWatermark(potentialOutputWatermark);\n+  }\n \n-      Instant watermarkHold = keyedStateInternals.watermarkHold();\n+  /**\n+   * Allows to apply a hold to the input watermark. By default, just passes the input watermark\n+   * through.\n+   */\n+  public long applyInputWatermarkHold(long inputWatermark) {\n+    return inputWatermark;\n+  }\n \n-      long combinedWatermarkHold = Math.min(watermarkHold.getMillis(), getPushbackWatermarkHold());\n-      combinedWatermarkHold =\n-          Math.min(combinedWatermarkHold, timerInternals.getMinOutputTimestampMs());\n-      long potentialOutputWatermark = Math.min(pushedBackInputWatermark, combinedWatermarkHold);\n+  /**\n+   * Allows to apply a hold to the output watermark before it is send out. By default, just passes\n+   * the potential output watermark through which will make it the new output watermark.\n+   *\n+   * @param currentOutputWatermark the current output watermark\n+   * @param potentialOutputWatermark The potential new output watermark which can be adjusted, if\n+   *     needed. The input watermark hold has already been applied.\n+   * @return The new output watermark which will be emitted.\n+   */\n+  public long applyOutputWatermarkHold(long currentOutputWatermark, long potentialOutputWatermark) {\n+    return potentialOutputWatermark;\n+  }\n \n-      if (potentialOutputWatermark > currentOutputWatermark) {\n-        setCurrentOutputWatermark(potentialOutputWatermark);\n-        emitWatermark(currentOutputWatermark);\n-      }\n+  private long computeOutputWatermark(long inputWatermarkHold) {\n+    final long potentialOutputWatermark;\n+    if (keyCoder == null) {\n+      potentialOutputWatermark = inputWatermarkHold;\n+    } else {\n+      Instant watermarkHold = keyedStateInternals.watermarkHold();\n+      long combinedWatermarkHold = Math.min(watermarkHold.getMillis(), inputWatermarkHold);\n+      potentialOutputWatermark =\n+          Math.min(combinedWatermarkHold, timerInternals.getMinOutputTimestampMs());\n     }\n+    return potentialOutputWatermark;\n   }\n \n-  private void emitWatermark(long watermark) {\n-    // Must invoke finishBatch before emit the +Inf watermark otherwise there are some late events.\n-    if (watermark >= BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis()) {\n-      invokeFinishBundle();\n+  private void maybeEmitWatermark(long watermark) {\n+    if (watermark > currentOutputWatermark) {\n+      // Must invoke finishBatch before emit the +Inf watermark otherwise there are some late\n+      // events.\n+      if (watermark >= BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis()) {\n+        invokeFinishBundle();\n+      }\n+      LOG.debug(\"Emitting watermark {}\", watermark);\n+      currentOutputWatermark = watermark;\n+      output.emitWatermark(new Watermark(watermark));\n     }\n-    output.emitWatermark(new Watermark(watermark));\n   }\n \n   @Override\n-  public void processWatermark2(Watermark mark) throws Exception {\n-\n-    setCurrentSideInputWatermark(mark.getTimestamp());\n+  public final void processWatermark2(Watermark mark) throws Exception {\n+    currentSideInputWatermark = mark.getTimestamp();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1f566f5139262015f8d801e819a7bbb4d623d49"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcxODcwNg==", "bodyText": "Emitting ready-data side input data is handled when new side input data arrives (see processElement2). This is a safe-guard because no more side input data will arrive after the max watermark. Maybe side input processing could be optimized based on the watermark but I'd tackle this independently of the PR because the logic didn't change here.", "url": "https://github.com/apache/beam/pull/11362#discussion_r413718706", "createdAt": "2020-04-23T10:58:24Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -658,46 +671,69 @@ public void processWatermark1(Watermark mark) throws Exception {\n       emitAllPushedBackData();\n     }\n \n-    setCurrentInputWatermark(mark.getTimestamp());\n+    currentInputWatermark = mark.getTimestamp();\n \n-    if (keyCoder == null) {\n-      long potentialOutputWatermark = Math.min(getPushbackWatermarkHold(), currentInputWatermark);\n-      if (potentialOutputWatermark > currentOutputWatermark) {\n-        setCurrentOutputWatermark(potentialOutputWatermark);\n-        emitWatermark(currentOutputWatermark);\n-      }\n-    } else {\n-      // hold back by the pushed back values waiting for side inputs\n-      long pushedBackInputWatermark = Math.min(getPushbackWatermarkHold(), mark.getTimestamp());\n+    long inputWatermarkHold = applyInputWatermarkHold(getEffectiveInputWatermark());\n+    if (keyCoder != null) {\n+      timeServiceManager.advanceWatermark(new Watermark(inputWatermarkHold));\n+    }\n \n-      timeServiceManager.advanceWatermark(new Watermark(pushedBackInputWatermark));\n+    long potentialOutputWatermark =\n+        applyOutputWatermarkHold(\n+            currentOutputWatermark, computeOutputWatermark(inputWatermarkHold));\n+    maybeEmitWatermark(potentialOutputWatermark);\n+  }\n \n-      Instant watermarkHold = keyedStateInternals.watermarkHold();\n+  /**\n+   * Allows to apply a hold to the input watermark. By default, just passes the input watermark\n+   * through.\n+   */\n+  public long applyInputWatermarkHold(long inputWatermark) {\n+    return inputWatermark;\n+  }\n \n-      long combinedWatermarkHold = Math.min(watermarkHold.getMillis(), getPushbackWatermarkHold());\n-      combinedWatermarkHold =\n-          Math.min(combinedWatermarkHold, timerInternals.getMinOutputTimestampMs());\n-      long potentialOutputWatermark = Math.min(pushedBackInputWatermark, combinedWatermarkHold);\n+  /**\n+   * Allows to apply a hold to the output watermark before it is send out. By default, just passes\n+   * the potential output watermark through which will make it the new output watermark.\n+   *\n+   * @param currentOutputWatermark the current output watermark\n+   * @param potentialOutputWatermark The potential new output watermark which can be adjusted, if\n+   *     needed. The input watermark hold has already been applied.\n+   * @return The new output watermark which will be emitted.\n+   */\n+  public long applyOutputWatermarkHold(long currentOutputWatermark, long potentialOutputWatermark) {\n+    return potentialOutputWatermark;\n+  }\n \n-      if (potentialOutputWatermark > currentOutputWatermark) {\n-        setCurrentOutputWatermark(potentialOutputWatermark);\n-        emitWatermark(currentOutputWatermark);\n-      }\n+  private long computeOutputWatermark(long inputWatermarkHold) {\n+    final long potentialOutputWatermark;\n+    if (keyCoder == null) {\n+      potentialOutputWatermark = inputWatermarkHold;\n+    } else {\n+      Instant watermarkHold = keyedStateInternals.watermarkHold();\n+      long combinedWatermarkHold = Math.min(watermarkHold.getMillis(), inputWatermarkHold);\n+      potentialOutputWatermark =\n+          Math.min(combinedWatermarkHold, timerInternals.getMinOutputTimestampMs());\n     }\n+    return potentialOutputWatermark;\n   }\n \n-  private void emitWatermark(long watermark) {\n-    // Must invoke finishBatch before emit the +Inf watermark otherwise there are some late events.\n-    if (watermark >= BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis()) {\n-      invokeFinishBundle();\n+  private void maybeEmitWatermark(long watermark) {\n+    if (watermark > currentOutputWatermark) {\n+      // Must invoke finishBatch before emit the +Inf watermark otherwise there are some late\n+      // events.\n+      if (watermark >= BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis()) {\n+        invokeFinishBundle();\n+      }\n+      LOG.debug(\"Emitting watermark {}\", watermark);\n+      currentOutputWatermark = watermark;\n+      output.emitWatermark(new Watermark(watermark));\n     }\n-    output.emitWatermark(new Watermark(watermark));\n   }\n \n   @Override\n-  public void processWatermark2(Watermark mark) throws Exception {\n-\n-    setCurrentSideInputWatermark(mark.getTimestamp());\n+  public final void processWatermark2(Watermark mark) throws Exception {\n+    currentSideInputWatermark = mark.getTimestamp();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUyNDk4Mw=="}, "originalCommit": {"oid": "b1f566f5139262015f8d801e819a7bbb4d623d49"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NjYwMQ==", "bodyText": "Yes, it is independent of this PR. The pre-existing side input related issue still exists. When no side input arrives, elements will never be emitted unless the final watermark occurs.", "url": "https://github.com/apache/beam/pull/11362#discussion_r413956601", "createdAt": "2020-04-23T16:45:28Z", "author": {"login": "tweise"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -658,46 +671,69 @@ public void processWatermark1(Watermark mark) throws Exception {\n       emitAllPushedBackData();\n     }\n \n-    setCurrentInputWatermark(mark.getTimestamp());\n+    currentInputWatermark = mark.getTimestamp();\n \n-    if (keyCoder == null) {\n-      long potentialOutputWatermark = Math.min(getPushbackWatermarkHold(), currentInputWatermark);\n-      if (potentialOutputWatermark > currentOutputWatermark) {\n-        setCurrentOutputWatermark(potentialOutputWatermark);\n-        emitWatermark(currentOutputWatermark);\n-      }\n-    } else {\n-      // hold back by the pushed back values waiting for side inputs\n-      long pushedBackInputWatermark = Math.min(getPushbackWatermarkHold(), mark.getTimestamp());\n+    long inputWatermarkHold = applyInputWatermarkHold(getEffectiveInputWatermark());\n+    if (keyCoder != null) {\n+      timeServiceManager.advanceWatermark(new Watermark(inputWatermarkHold));\n+    }\n \n-      timeServiceManager.advanceWatermark(new Watermark(pushedBackInputWatermark));\n+    long potentialOutputWatermark =\n+        applyOutputWatermarkHold(\n+            currentOutputWatermark, computeOutputWatermark(inputWatermarkHold));\n+    maybeEmitWatermark(potentialOutputWatermark);\n+  }\n \n-      Instant watermarkHold = keyedStateInternals.watermarkHold();\n+  /**\n+   * Allows to apply a hold to the input watermark. By default, just passes the input watermark\n+   * through.\n+   */\n+  public long applyInputWatermarkHold(long inputWatermark) {\n+    return inputWatermark;\n+  }\n \n-      long combinedWatermarkHold = Math.min(watermarkHold.getMillis(), getPushbackWatermarkHold());\n-      combinedWatermarkHold =\n-          Math.min(combinedWatermarkHold, timerInternals.getMinOutputTimestampMs());\n-      long potentialOutputWatermark = Math.min(pushedBackInputWatermark, combinedWatermarkHold);\n+  /**\n+   * Allows to apply a hold to the output watermark before it is send out. By default, just passes\n+   * the potential output watermark through which will make it the new output watermark.\n+   *\n+   * @param currentOutputWatermark the current output watermark\n+   * @param potentialOutputWatermark The potential new output watermark which can be adjusted, if\n+   *     needed. The input watermark hold has already been applied.\n+   * @return The new output watermark which will be emitted.\n+   */\n+  public long applyOutputWatermarkHold(long currentOutputWatermark, long potentialOutputWatermark) {\n+    return potentialOutputWatermark;\n+  }\n \n-      if (potentialOutputWatermark > currentOutputWatermark) {\n-        setCurrentOutputWatermark(potentialOutputWatermark);\n-        emitWatermark(currentOutputWatermark);\n-      }\n+  private long computeOutputWatermark(long inputWatermarkHold) {\n+    final long potentialOutputWatermark;\n+    if (keyCoder == null) {\n+      potentialOutputWatermark = inputWatermarkHold;\n+    } else {\n+      Instant watermarkHold = keyedStateInternals.watermarkHold();\n+      long combinedWatermarkHold = Math.min(watermarkHold.getMillis(), inputWatermarkHold);\n+      potentialOutputWatermark =\n+          Math.min(combinedWatermarkHold, timerInternals.getMinOutputTimestampMs());\n     }\n+    return potentialOutputWatermark;\n   }\n \n-  private void emitWatermark(long watermark) {\n-    // Must invoke finishBatch before emit the +Inf watermark otherwise there are some late events.\n-    if (watermark >= BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis()) {\n-      invokeFinishBundle();\n+  private void maybeEmitWatermark(long watermark) {\n+    if (watermark > currentOutputWatermark) {\n+      // Must invoke finishBatch before emit the +Inf watermark otherwise there are some late\n+      // events.\n+      if (watermark >= BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis()) {\n+        invokeFinishBundle();\n+      }\n+      LOG.debug(\"Emitting watermark {}\", watermark);\n+      currentOutputWatermark = watermark;\n+      output.emitWatermark(new Watermark(watermark));\n     }\n-    output.emitWatermark(new Watermark(watermark));\n   }\n \n   @Override\n-  public void processWatermark2(Watermark mark) throws Exception {\n-\n-    setCurrentSideInputWatermark(mark.getTimestamp());\n+  public final void processWatermark2(Watermark mark) throws Exception {\n+    currentSideInputWatermark = mark.getTimestamp();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUyNDk4Mw=="}, "originalCommit": {"oid": "b1f566f5139262015f8d801e819a7bbb4d623d49"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk4NDUxOA==", "bodyText": "I agree, that is something we should address.", "url": "https://github.com/apache/beam/pull/11362#discussion_r413984518", "createdAt": "2020-04-23T17:25:19Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -658,46 +671,69 @@ public void processWatermark1(Watermark mark) throws Exception {\n       emitAllPushedBackData();\n     }\n \n-    setCurrentInputWatermark(mark.getTimestamp());\n+    currentInputWatermark = mark.getTimestamp();\n \n-    if (keyCoder == null) {\n-      long potentialOutputWatermark = Math.min(getPushbackWatermarkHold(), currentInputWatermark);\n-      if (potentialOutputWatermark > currentOutputWatermark) {\n-        setCurrentOutputWatermark(potentialOutputWatermark);\n-        emitWatermark(currentOutputWatermark);\n-      }\n-    } else {\n-      // hold back by the pushed back values waiting for side inputs\n-      long pushedBackInputWatermark = Math.min(getPushbackWatermarkHold(), mark.getTimestamp());\n+    long inputWatermarkHold = applyInputWatermarkHold(getEffectiveInputWatermark());\n+    if (keyCoder != null) {\n+      timeServiceManager.advanceWatermark(new Watermark(inputWatermarkHold));\n+    }\n \n-      timeServiceManager.advanceWatermark(new Watermark(pushedBackInputWatermark));\n+    long potentialOutputWatermark =\n+        applyOutputWatermarkHold(\n+            currentOutputWatermark, computeOutputWatermark(inputWatermarkHold));\n+    maybeEmitWatermark(potentialOutputWatermark);\n+  }\n \n-      Instant watermarkHold = keyedStateInternals.watermarkHold();\n+  /**\n+   * Allows to apply a hold to the input watermark. By default, just passes the input watermark\n+   * through.\n+   */\n+  public long applyInputWatermarkHold(long inputWatermark) {\n+    return inputWatermark;\n+  }\n \n-      long combinedWatermarkHold = Math.min(watermarkHold.getMillis(), getPushbackWatermarkHold());\n-      combinedWatermarkHold =\n-          Math.min(combinedWatermarkHold, timerInternals.getMinOutputTimestampMs());\n-      long potentialOutputWatermark = Math.min(pushedBackInputWatermark, combinedWatermarkHold);\n+  /**\n+   * Allows to apply a hold to the output watermark before it is send out. By default, just passes\n+   * the potential output watermark through which will make it the new output watermark.\n+   *\n+   * @param currentOutputWatermark the current output watermark\n+   * @param potentialOutputWatermark The potential new output watermark which can be adjusted, if\n+   *     needed. The input watermark hold has already been applied.\n+   * @return The new output watermark which will be emitted.\n+   */\n+  public long applyOutputWatermarkHold(long currentOutputWatermark, long potentialOutputWatermark) {\n+    return potentialOutputWatermark;\n+  }\n \n-      if (potentialOutputWatermark > currentOutputWatermark) {\n-        setCurrentOutputWatermark(potentialOutputWatermark);\n-        emitWatermark(currentOutputWatermark);\n-      }\n+  private long computeOutputWatermark(long inputWatermarkHold) {\n+    final long potentialOutputWatermark;\n+    if (keyCoder == null) {\n+      potentialOutputWatermark = inputWatermarkHold;\n+    } else {\n+      Instant watermarkHold = keyedStateInternals.watermarkHold();\n+      long combinedWatermarkHold = Math.min(watermarkHold.getMillis(), inputWatermarkHold);\n+      potentialOutputWatermark =\n+          Math.min(combinedWatermarkHold, timerInternals.getMinOutputTimestampMs());\n     }\n+    return potentialOutputWatermark;\n   }\n \n-  private void emitWatermark(long watermark) {\n-    // Must invoke finishBatch before emit the +Inf watermark otherwise there are some late events.\n-    if (watermark >= BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis()) {\n-      invokeFinishBundle();\n+  private void maybeEmitWatermark(long watermark) {\n+    if (watermark > currentOutputWatermark) {\n+      // Must invoke finishBatch before emit the +Inf watermark otherwise there are some late\n+      // events.\n+      if (watermark >= BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis()) {\n+        invokeFinishBundle();\n+      }\n+      LOG.debug(\"Emitting watermark {}\", watermark);\n+      currentOutputWatermark = watermark;\n+      output.emitWatermark(new Watermark(watermark));\n     }\n-    output.emitWatermark(new Watermark(watermark));\n   }\n \n   @Override\n-  public void processWatermark2(Watermark mark) throws Exception {\n-\n-    setCurrentSideInputWatermark(mark.getTimestamp());\n+  public final void processWatermark2(Watermark mark) throws Exception {\n+    currentSideInputWatermark = mark.getTimestamp();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUyNDk4Mw=="}, "originalCommit": {"oid": "b1f566f5139262015f8d801e819a7bbb4d623d49"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDE0MDE5OnYy", "diffSide": "RIGHT", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjowNToxN1rOGKYD3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMTowNDo1OVrOGKjnzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUzMzE0OA==", "bodyText": "The comment is a bit misleading. How about: \"We are scheduling a timer for advancing the watermark, to not delay finishing the bundle and temporarily release the checkpoint lock. Otherwise, we could potentially loop when a timer keeps scheduling a timer for the same timestamp.\"", "url": "https://github.com/apache/beam/pull/11362#discussion_r413533148", "createdAt": "2020-04-23T06:05:17Z", "author": {"login": "tweise"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java", "diffHunk": "@@ -544,30 +601,49 @@ public void processWatermark(Watermark mark) throws Exception {\n     // every watermark. So we have implemented 2) below.\n     //\n     if (sdkHarnessRunner.isBundleInProgress()) {\n-      if (mark.getTimestamp() >= BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis()) {\n-        invokeFinishBundle();\n-        setPushedBackWatermark(Long.MAX_VALUE);\n+      if (minEventTimeTimerTimestampInLastBundle < Long.MAX_VALUE) {\n+        // We can safely advance the watermark to before the last bundle's minimum event timer\n+        // but not past the potential output watermark which includes holds to the input watermark.\n+        return Math.min(minEventTimeTimerTimestampInLastBundle - 1, potentialOutputWatermark);\n       } else {\n-        // It is not safe to advance the output watermark yet, so add a hold on the current\n-        // output watermark.\n-        backupWatermarkHold = Math.max(backupWatermarkHold, getPushbackWatermarkHold());\n-        setPushedBackWatermark(Math.min(currentOutputWatermark, backupWatermarkHold));\n-        super.setBundleFinishedCallback(\n-            () -> {\n-              try {\n-                LOG.debug(\"processing pushed back watermark: {}\", mark);\n-                // at this point the bundle is finished, allow the watermark to pass\n-                // we are restoring the previous hold in case it was already set for side inputs\n-                setPushedBackWatermark(backupWatermarkHold);\n-                super.processWatermark(mark);\n-              } catch (Exception e) {\n-                throw new RuntimeException(\n-                    \"Failed to process pushed back watermark after finished bundle.\", e);\n-              }\n-            });\n+        // We don't have any information yet, use the current output watermark for now.\n+        return currentOutputWatermark;\n+      }\n+    } else {\n+      // No bundle was started when we advanced the input watermark.\n+      // Thus, we can safely set a new output watermark.\n+      return potentialOutputWatermark;\n+    }\n+  }\n+\n+  private void preBundleStartCallback() {\n+    inputWatermarkBeforeBundleStart = getEffectiveInputWatermark();\n+  }\n+\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void finishBundleCallback() {\n+    minEventTimeTimerTimestampInLastBundle = minEventTimeTimerTimestampInCurrentBundle;\n+    minEventTimeTimerTimestampInCurrentBundle = Long.MAX_VALUE;\n+    try {\n+      if (!closed\n+          && minEventTimeTimerTimestampInLastBundle < Long.MAX_VALUE\n+          && minEventTimeTimerTimestampInLastBundle <= getEffectiveInputWatermark()) {\n+        ProcessingTimeService processingTimeService = getProcessingTimeService();\n+        // We are scheduling a timer for advancing the watermark. Otherwise we\n+        // could potentially loop forever here when a timer keeps scheduling a timer\n+        // for the same timestamp. This in itself would not be an issue. However,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1f566f5139262015f8d801e819a7bbb4d623d49"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMjU3Mw==", "bodyText": "Sure. Changed.", "url": "https://github.com/apache/beam/pull/11362#discussion_r413722573", "createdAt": "2020-04-23T11:04:59Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java", "diffHunk": "@@ -544,30 +601,49 @@ public void processWatermark(Watermark mark) throws Exception {\n     // every watermark. So we have implemented 2) below.\n     //\n     if (sdkHarnessRunner.isBundleInProgress()) {\n-      if (mark.getTimestamp() >= BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis()) {\n-        invokeFinishBundle();\n-        setPushedBackWatermark(Long.MAX_VALUE);\n+      if (minEventTimeTimerTimestampInLastBundle < Long.MAX_VALUE) {\n+        // We can safely advance the watermark to before the last bundle's minimum event timer\n+        // but not past the potential output watermark which includes holds to the input watermark.\n+        return Math.min(minEventTimeTimerTimestampInLastBundle - 1, potentialOutputWatermark);\n       } else {\n-        // It is not safe to advance the output watermark yet, so add a hold on the current\n-        // output watermark.\n-        backupWatermarkHold = Math.max(backupWatermarkHold, getPushbackWatermarkHold());\n-        setPushedBackWatermark(Math.min(currentOutputWatermark, backupWatermarkHold));\n-        super.setBundleFinishedCallback(\n-            () -> {\n-              try {\n-                LOG.debug(\"processing pushed back watermark: {}\", mark);\n-                // at this point the bundle is finished, allow the watermark to pass\n-                // we are restoring the previous hold in case it was already set for side inputs\n-                setPushedBackWatermark(backupWatermarkHold);\n-                super.processWatermark(mark);\n-              } catch (Exception e) {\n-                throw new RuntimeException(\n-                    \"Failed to process pushed back watermark after finished bundle.\", e);\n-              }\n-            });\n+        // We don't have any information yet, use the current output watermark for now.\n+        return currentOutputWatermark;\n+      }\n+    } else {\n+      // No bundle was started when we advanced the input watermark.\n+      // Thus, we can safely set a new output watermark.\n+      return potentialOutputWatermark;\n+    }\n+  }\n+\n+  private void preBundleStartCallback() {\n+    inputWatermarkBeforeBundleStart = getEffectiveInputWatermark();\n+  }\n+\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void finishBundleCallback() {\n+    minEventTimeTimerTimestampInLastBundle = minEventTimeTimerTimestampInCurrentBundle;\n+    minEventTimeTimerTimestampInCurrentBundle = Long.MAX_VALUE;\n+    try {\n+      if (!closed\n+          && minEventTimeTimerTimestampInLastBundle < Long.MAX_VALUE\n+          && minEventTimeTimerTimestampInLastBundle <= getEffectiveInputWatermark()) {\n+        ProcessingTimeService processingTimeService = getProcessingTimeService();\n+        // We are scheduling a timer for advancing the watermark. Otherwise we\n+        // could potentially loop forever here when a timer keeps scheduling a timer\n+        // for the same timestamp. This in itself would not be an issue. However,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUzMzE0OA=="}, "originalCommit": {"oid": "b1f566f5139262015f8d801e819a7bbb4d623d49"}, "originalPosition": 199}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1454, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}