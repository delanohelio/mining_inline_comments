{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4MTk0ODY0", "number": 10705, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMTo0MzoxNlrODbYerA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMDo1MTozN1rODcDm5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDM5MjEyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMTo0MzoxNlrOFi1oDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMTo0MzoxNlrOFi1oDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA3NDUxMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                \"\"\"Materialized the first page of data, concatinated with a lazy iterable\n          \n          \n            \n                \"\"\"Materialized the first page of data, concatenated with a lazy iterable", "url": "https://github.com/apache/beam/pull/10705#discussion_r372074511", "createdAt": "2020-01-28T21:43:16Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -825,43 +833,92 @@ def extend(self,\n \n   def clear(self, state_key, is_cached=False):\n     # type: (beam_fn_api_pb2.StateKey, bool) -> _Future\n-    if self._should_be_cached(is_cached):\n+    cache_token = self._get_cache_token(state_key, is_cached)\n+    if cache_token:\n       cache_key = self._convert_to_cache_key(state_key)\n-      self._state_cache.clear(cache_key, self._context.cache_token)\n+      self._state_cache.clear(cache_key, cache_token)\n     return self._underlying.clear(state_key)\n \n   def done(self):\n     # type: () -> None\n     self._underlying.done()\n \n-  def _materialize_iter(self,\n-                        state_key,  # type: beam_fn_api_pb2.StateKey\n-                        coder  # type: coder_impl.CoderImpl\n-                       ):\n+  def _lazy_iterator(\n+      self,\n+      state_key,  # type: beam_fn_api_pb2.StateKey\n+      coder,  # type: coder_impl.CoderImpl\n+      continuation_token=None  # type: Optional[bytes]\n+    ):\n     # type: (...) -> Iterator[Any]\n     \"\"\"Materializes the state lazily, one element at a time.\n        :return A generator which returns the next element if advanced.\n     \"\"\"\n-    continuation_token = None\n     while True:\n-      data, continuation_token = \\\n-          self._underlying.get_raw(state_key, continuation_token)\n+      data, continuation_token = (\n+          self._underlying.get_raw(state_key, continuation_token))\n       input_stream = coder_impl.create_InputStream(data)\n       while input_stream.size() > 0:\n         yield coder.decode_from_stream(input_stream, True)\n       if not continuation_token:\n         break\n \n-  def _should_be_cached(self, request_is_cached):\n-    return (self._state_cache.is_cache_enabled() and\n-            request_is_cached and\n-            self._context.cache_token)\n+  def _get_cache_token(self, state_key, request_is_cached):\n+    if not self._state_cache.is_cache_enabled():\n+      return None\n+    elif state_key.HasField('bag_user_state'):\n+      if request_is_cached and self._context.user_state_cache_token:\n+        return self._context.user_state_cache_token\n+      else:\n+        return self._context.bundle_cache_token\n+    elif state_key.WhichOneof('type').endswith('_side_input'):\n+      side_input = getattr(state_key, state_key.WhichOneof('type'))\n+      return self._context.side_input_cache_tokens.get(\n+        (side_input.transform_id, side_input.side_input_id),\n+        self._context.bundle_cache_token)\n+\n+  def _partially_cached_iterable(\n+      self,\n+      state_key,  # type: beam_fn_api_pb2.StateKey\n+      coder  # type: coder_impl.CoderImpl\n+    ):\n+    # type: (...) -> Iterable[Any]\n+    \"\"\"Materialized the first page of data, concatinated with a lazy iterable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4929a914fa2f0cc2dd3b690132e3f4a99cde20c"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDQzMTE1OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMTo1NjowMFrOFi2AvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMTo1NjowMFrOFi2AvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA4MDgyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return iter_func()\n          \n          \n            \n                return iter_func", "url": "https://github.com/apache/beam/pull/10705#discussion_r372080828", "createdAt": "2020-01-28T21:56:00Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -825,43 +833,92 @@ def extend(self,\n \n   def clear(self, state_key, is_cached=False):\n     # type: (beam_fn_api_pb2.StateKey, bool) -> _Future\n-    if self._should_be_cached(is_cached):\n+    cache_token = self._get_cache_token(state_key, is_cached)\n+    if cache_token:\n       cache_key = self._convert_to_cache_key(state_key)\n-      self._state_cache.clear(cache_key, self._context.cache_token)\n+      self._state_cache.clear(cache_key, cache_token)\n     return self._underlying.clear(state_key)\n \n   def done(self):\n     # type: () -> None\n     self._underlying.done()\n \n-  def _materialize_iter(self,\n-                        state_key,  # type: beam_fn_api_pb2.StateKey\n-                        coder  # type: coder_impl.CoderImpl\n-                       ):\n+  def _lazy_iterator(\n+      self,\n+      state_key,  # type: beam_fn_api_pb2.StateKey\n+      coder,  # type: coder_impl.CoderImpl\n+      continuation_token=None  # type: Optional[bytes]\n+    ):\n     # type: (...) -> Iterator[Any]\n     \"\"\"Materializes the state lazily, one element at a time.\n        :return A generator which returns the next element if advanced.\n     \"\"\"\n-    continuation_token = None\n     while True:\n-      data, continuation_token = \\\n-          self._underlying.get_raw(state_key, continuation_token)\n+      data, continuation_token = (\n+          self._underlying.get_raw(state_key, continuation_token))\n       input_stream = coder_impl.create_InputStream(data)\n       while input_stream.size() > 0:\n         yield coder.decode_from_stream(input_stream, True)\n       if not continuation_token:\n         break\n \n-  def _should_be_cached(self, request_is_cached):\n-    return (self._state_cache.is_cache_enabled() and\n-            request_is_cached and\n-            self._context.cache_token)\n+  def _get_cache_token(self, state_key, request_is_cached):\n+    if not self._state_cache.is_cache_enabled():\n+      return None\n+    elif state_key.HasField('bag_user_state'):\n+      if request_is_cached and self._context.user_state_cache_token:\n+        return self._context.user_state_cache_token\n+      else:\n+        return self._context.bundle_cache_token\n+    elif state_key.WhichOneof('type').endswith('_side_input'):\n+      side_input = getattr(state_key, state_key.WhichOneof('type'))\n+      return self._context.side_input_cache_tokens.get(\n+        (side_input.transform_id, side_input.side_input_id),\n+        self._context.bundle_cache_token)\n+\n+  def _partially_cached_iterable(\n+      self,\n+      state_key,  # type: beam_fn_api_pb2.StateKey\n+      coder  # type: coder_impl.CoderImpl\n+    ):\n+    # type: (...) -> Iterable[Any]\n+    \"\"\"Materialized the first page of data, concatinated with a lazy iterable\n+    of the rest, if any.\n+    \"\"\"\n+    data, continuation_token = (\n+            self._underlying.get_raw(state_key, None))\n+    head = []\n+    input_stream = coder_impl.create_InputStream(data)\n+    while input_stream.size() > 0:\n+      head.append(coder.decode_from_stream(input_stream, True))\n+\n+    if continuation_token is None:\n+      return head\n+    else:\n+      def iter_func():\n+        for item in head:\n+          yield item\n+        for item in self._lazy_iterator(state_key, coder, continuation_token):\n+          yield item\n+      return _IterableFromIterator(iter_func)\n \n   @staticmethod\n   def _convert_to_cache_key(state_key):\n     return state_key.SerializeToString()\n \n \n+class _IterableFromIterator(object):\n+  \"\"\"Wraps an iterator as an iterable.\"\"\"\n+  def __init__(self, iter_func):\n+    self._iter_func = iter_func\n+  def __iter__(self):\n+    return iter_func()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4929a914fa2f0cc2dd3b690132e3f4a99cde20c"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMTY5MjgwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwOTozNjoyOFrOFjB43Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwOTozNjoyOFrOFjB43Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjI3NTQyMQ==", "bodyText": "Bundle caching for get requests is a good improvement.", "url": "https://github.com/apache/beam/pull/10705#discussion_r372275421", "createdAt": "2020-01-29T09:36:28Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -759,50 +759,57 @@ def __init__(self,\n \n   @contextlib.contextmanager\n   def process_instruction_id(self, bundle_id, cache_tokens):\n-    if getattr(self._context, 'cache_token', None) is not None:\n+    if getattr(self._context, 'user_state_cache_token', None) is not None:\n       raise RuntimeError(\n-          'Cache tokens already set to %s' % self._context.cache_token)\n-    # TODO Also handle cache tokens for side input, if present:\n-    # https://issues.apache.org/jira/browse/BEAM-8298\n+          'Cache tokens already set to %s'\n+          % self._context.user_state_cache_token)\n+    self._context.side_input_cache_tokens = {}\n     user_state_cache_token = None\n     for cache_token_struct in cache_tokens:\n       if cache_token_struct.HasField(\"user_state\"):\n         # There should only be one user state token present\n         assert not user_state_cache_token\n         user_state_cache_token = cache_token_struct.token\n+      elif cache_token_struct.HasField(\"side_input\"):\n+        self._context.side_input_cache_tokens[\n+            cache_token_struct.side_input.transform_id,\n+            cache_token_struct.side_input.side_input_id\n+        ] = cache_token_struct.token\n+    self._context.bundle_cache_token = bundle_id", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e30655bd56da5d885357517c5898663936a0578"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMTY5NjE3OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwOTozNzozNVrOFjB7AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwOTozNzozNVrOFjB7AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjI3NTk2OA==", "bodyText": "AFAIK Continuation tokens are not implemented but it's good we support this now.", "url": "https://github.com/apache/beam/pull/10705#discussion_r372275968", "createdAt": "2020-01-29T09:37:35Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -825,43 +833,92 @@ def extend(self,\n \n   def clear(self, state_key, is_cached=False):\n     # type: (beam_fn_api_pb2.StateKey, bool) -> _Future\n-    if self._should_be_cached(is_cached):\n+    cache_token = self._get_cache_token(state_key, is_cached)\n+    if cache_token:\n       cache_key = self._convert_to_cache_key(state_key)\n-      self._state_cache.clear(cache_key, self._context.cache_token)\n+      self._state_cache.clear(cache_key, cache_token)\n     return self._underlying.clear(state_key)\n \n   def done(self):\n     # type: () -> None\n     self._underlying.done()\n \n-  def _materialize_iter(self,\n-                        state_key,  # type: beam_fn_api_pb2.StateKey\n-                        coder  # type: coder_impl.CoderImpl\n-                       ):\n+  def _lazy_iterator(\n+      self,\n+      state_key,  # type: beam_fn_api_pb2.StateKey\n+      coder,  # type: coder_impl.CoderImpl\n+      continuation_token=None  # type: Optional[bytes]\n+    ):\n     # type: (...) -> Iterator[Any]\n     \"\"\"Materializes the state lazily, one element at a time.\n        :return A generator which returns the next element if advanced.\n     \"\"\"\n-    continuation_token = None\n     while True:\n-      data, continuation_token = \\\n-          self._underlying.get_raw(state_key, continuation_token)\n+      data, continuation_token = (\n+          self._underlying.get_raw(state_key, continuation_token))\n       input_stream = coder_impl.create_InputStream(data)\n       while input_stream.size() > 0:\n         yield coder.decode_from_stream(input_stream, True)\n       if not continuation_token:\n         break\n \n-  def _should_be_cached(self, request_is_cached):\n-    return (self._state_cache.is_cache_enabled() and\n-            request_is_cached and\n-            self._context.cache_token)\n+  def _get_cache_token(self, state_key, request_is_cached):\n+    if not self._state_cache.is_cache_enabled():\n+      return None\n+    elif state_key.HasField('bag_user_state'):\n+      if request_is_cached and self._context.user_state_cache_token:\n+        return self._context.user_state_cache_token\n+      else:\n+        return self._context.bundle_cache_token\n+    elif state_key.WhichOneof('type').endswith('_side_input'):\n+      side_input = getattr(state_key, state_key.WhichOneof('type'))\n+      return self._context.side_input_cache_tokens.get(\n+          (side_input.transform_id, side_input.side_input_id),\n+          self._context.bundle_cache_token)\n+\n+  def _partially_cached_iterable(\n+      self,\n+      state_key,  # type: beam_fn_api_pb2.StateKey\n+      coder  # type: coder_impl.CoderImpl\n+    ):\n+    # type: (...) -> Iterable[Any]\n+    \"\"\"Materialized the first page of data, concatenated with a lazy iterable\n+    of the rest, if any.\n+    \"\"\"\n+    data, continuation_token = self._underlying.get_raw(state_key, None)\n+    head = []\n+    input_stream = coder_impl.create_InputStream(data)\n+    while input_stream.size() > 0:\n+      head.append(coder.decode_from_stream(input_stream, True))\n+\n+    if continuation_token is None:\n+      return head\n+    else:\n+      def iter_func():", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e30655bd56da5d885357517c5898663936a0578"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMTcwMjc3OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/statecache.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwOTozOTo0MFrOFjB_Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwOTozOTo0MFrOFjB_Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjI3NzA0Ng==", "bodyText": "The combined use of (state_key, cache_token) simplifies the lookup. Thanks for fixing this.", "url": "https://github.com/apache/beam/pull/10705#discussion_r372277046", "createdAt": "2020-01-29T09:39:40Z", "author": {"login": "mxm"}, "path": "sdks/python/apache_beam/runners/worker/statecache.py", "diffHunk": "@@ -148,47 +148,43 @@ class StateCache(object):\n \n   def __init__(self, max_entries):\n     _LOGGER.info('Creating state cache with size %s', max_entries)\n-    self._cache = self.LRUCache(max_entries, (None, None))\n+    self._missing = None\n+    self._cache = self.LRUCache(max_entries, self._missing)\n     self._lock = threading.RLock()\n     self._metrics = Metrics()\n \n   @Metrics.counter_hit_miss(\"get\", \"hit\", \"miss\")\n   def get(self, state_key, cache_token):\n     assert cache_token and self.is_cache_enabled()\n     with self._lock:\n-      token, value = self._cache.get(state_key)\n-    return value if token == cache_token else None\n+      return self._cache.get((state_key, cache_token))\n \n   @Metrics.counter(\"put\")\n   def put(self, state_key, cache_token, value):\n     assert cache_token and self.is_cache_enabled()\n     with self._lock:\n-      return self._cache.put(state_key, (cache_token, value))\n+      return self._cache.put((state_key, cache_token), value)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e30655bd56da5d885357517c5898663936a0578"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNzQ1ODMwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/sdk_worker_test.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMDo1MTozN1rOFj5hOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMDo1MTozN1rOFj5hOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE4Njg3NQ==", "bodyText": "Nice.", "url": "https://github.com/apache/beam/pull/10705#discussion_r373186875", "createdAt": "2020-01-30T20:51:37Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/runners/worker/sdk_worker_test.py", "diffHunk": "@@ -115,6 +118,116 @@ def test_fn_registration(self):\n     self._check_fn_registration_multi_request((1, 4), (4, 4))\n \n \n+class CachingStateHandlerTest(unittest.TestCase):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c99c882bd04383e270ce66cb2dc6579b4e40a57"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2275, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}