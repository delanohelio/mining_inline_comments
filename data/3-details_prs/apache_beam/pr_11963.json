{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyMTI2NzY0", "number": 11963, "title": "Add relational GroupBy transform to Python.", "bodyText": "Thank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nApex\nDataflow\nFlink\nGearpump\nSamza\nSpark\n\n\n\n\nGo\n\n---\n---\n\n---\n---\n\n\n\nJava\n\n\n\n\n\n\n\n\n\nPython\n\n---\n\n\n---\n---\n\n\n\nXLang\n---\n---\n---\n\n---\n---\n\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-06-10T00:06:16Z", "url": "https://github.com/apache/beam/pull/11963", "merged": true, "mergeCommit": {"oid": "885cd0b3b96dba2346bde655450f95e732dbd9bd"}, "closed": true, "closedAt": "2020-07-24T00:17:27Z", "author": {"login": "robertwb"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcpuIv9AH2gAyNDMyMTI2NzY0OmZkYzIzZDJjZDlkMTRhNGRjYWRjMDdjMGI1YjRkYTViYjk4NzFmYzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc32s_eAH2gAyNDMyMTI2NzY0OjUxNDEyNTkxZDc0YWMzMGRiMmJkYzhlYjg2MzNjOTljYjk2NGQ5MTc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "fdc23d2cd9d14a4dcadc07c0b5b4da5bb9871fc1", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/fdc23d2cd9d14a4dcadc07c0b5b4da5bb9871fc1", "committedDate": "2020-06-10T00:02:10Z", "message": "Add relational GroupBy transform to Python."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8075568c1b6aa58b3915a8ba3536927e405a1789", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/8075568c1b6aa58b3915a8ba3536927e405a1789", "committedDate": "2020-06-10T01:29:06Z", "message": "Python 2 fixes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3c9a8b4252a70688f78cd5b2993a2d4af9b46ed", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/c3c9a8b4252a70688f78cd5b2993a2d4af9b46ed", "committedDate": "2020-07-07T23:27:52Z", "message": "yapf"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b688262cd77c7fb0d63be99152b8ba51b5ad700b", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/b688262cd77c7fb0d63be99152b8ba51b5ad700b", "committedDate": "2020-07-08T00:00:14Z", "message": "Avoid size-1 tuples."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1291b588164e8d0043c73589b0af303d47e9faa9", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/1291b588164e8d0043c73589b0af303d47e9faa9", "committedDate": "2020-07-08T00:49:15Z", "message": "Docs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NjY5MDQw", "url": "https://github.com/apache/beam/pull/11963#pullrequestreview-446669040", "createdAt": "2020-07-10T20:01:15Z", "commit": {"oid": "1291b588164e8d0043c73589b0af303d47e9faa9"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDowMToxNVrOGwEG3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDoyODo0N1rOGwEwLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA1MjEyNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  beam.Map(lambda v: (expr(v), v)) | GroupByKey()\n          \n          \n            \n                  beam.Map(lambda v: (expr(v), v)) | beam.GroupByKey()", "url": "https://github.com/apache/beam/pull/11963#discussion_r453052127", "createdAt": "2020-07-10T20:01:15Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -2247,6 +2248,154 @@ def runner_api_requires_keyed_input(self):\n     return True\n \n \n+def _expr_to_callable(expr, pos):\n+  if isinstance(expr, str):\n+    return lambda x: getattr(x, expr)\n+  elif callable(expr):\n+    return expr\n+  else:\n+    raise TypeError(\n+        'Field expression %r at %s must be a callable or a string.' %\n+        (expr, pos))\n+\n+\n+class GroupBy(PTransform):\n+  \"\"\"Groups a PCollection by one or more expressions, used to derive the key.\n+\n+  `GroupBy(expr)` is roughly equivalent to\n+\n+      beam.Map(lambda v: (expr(v), v)) | GroupByKey()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1291b588164e8d0043c73589b0af303d47e9faa9"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA1NTE5Nw==", "bodyText": "Is this a fallback for when a Row uses types that we don't support in Python schemas?\nI worry about this since it makes it tricky for a user to tell when a PCollection can be used in an ExternalTransform that uses rows. Are there some specific types that we need to add coverage for?", "url": "https://github.com/apache/beam/pull/11963#discussion_r453055197", "createdAt": "2020-07-10T20:09:02Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/coders/row_coder.py", "diffHunk": "@@ -87,7 +87,10 @@ def from_runner_api_parameter(schema, components, unused_context):\n   @staticmethod\n   def from_type_hint(type_hint, registry):\n     if isinstance(type_hint, row_type.RowTypeConstraint):\n-      schema = named_fields_to_schema(type_hint._fields)\n+      try:\n+        schema = named_fields_to_schema(type_hint._fields)\n+      except ValueError:\n+        return typecoders.registry.get_coder(object)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1291b588164e8d0043c73589b0af303d47e9faa9"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA1ODczNA==", "bodyText": "I had this problem with the NamedTuple used in an external transform's output PCollection, I solved it there by making a custom __reduce__ function that rebuilds from the proto-encoded schema:\n\n  \n    \n      beam/sdks/python/apache_beam/typehints/schemas.py\n    \n    \n        Lines 210 to 225\n      in\n      80de476\n    \n    \n    \n    \n\n        \n          \n           type_name = 'BeamSchema_{}'.format(schema.id.replace('-', '_')) \n        \n\n        \n          \n           user_type = NamedTuple( \n        \n\n        \n          \n               type_name, \n        \n\n        \n          \n               [(field.name, typing_from_runner_api(field.type)) \n        \n\n        \n          \n                for field in schema.fields]) \n        \n\n        \n          \n            \n        \n\n        \n          \n           setattr(user_type, _BEAM_SCHEMA_ID, schema.id) \n        \n\n        \n          \n            \n        \n\n        \n          \n           # Define a reduce function, otherwise these types can't be pickled \n        \n\n        \n          \n           # (See BEAM-9574) \n        \n\n        \n          \n           def __reduce__(self): \n        \n\n        \n          \n             return ( \n        \n\n        \n          \n                 _hydrate_namedtuple_instance, \n        \n\n        \n          \n                 (schema.SerializeToString(), tuple(self))) \n        \n\n        \n          \n            \n        \n\n        \n          \n           setattr(user_type, '__reduce__', __reduce__) \n        \n    \n  \n\n\n(A TODO is fine as well, just wanted to point that out in case it's helpful)", "url": "https://github.com/apache/beam/pull/11963#discussion_r453058734", "createdAt": "2020-07-10T20:18:06Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -2247,6 +2248,154 @@ def runner_api_requires_keyed_input(self):\n     return True\n \n \n+def _expr_to_callable(expr, pos):\n+  if isinstance(expr, str):\n+    return lambda x: getattr(x, expr)\n+  elif callable(expr):\n+    return expr\n+  else:\n+    raise TypeError(\n+        'Field expression %r at %s must be a callable or a string.' %\n+        (expr, pos))\n+\n+\n+class GroupBy(PTransform):\n+  \"\"\"Groups a PCollection by one or more expressions, used to derive the key.\n+\n+  `GroupBy(expr)` is roughly equivalent to\n+\n+      beam.Map(lambda v: (expr(v), v)) | GroupByKey()\n+\n+  but provides several conviniences, e.g.\n+\n+      * Several arguments may be provided, as positional or keyword arguments,\n+        resulting in a tuple-like key. For example `GroupBy(a=expr1, b=expr2)`\n+        groups by a key with attributes `a` and `b` computed by applying\n+        `expr1` and `expr2` to each element.\n+\n+      * Strings can be used as a shorthand for accessing an attribute, e.g.\n+        `GroupBy('some_field')` is equivalent to\n+        `GroupBy(lambda v: getattr(v, 'some_field'))`.\n+\n+  The GroupBy operation can be made into an aggregating operation by invoking\n+  its `aggregate_field` method.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      *fields,  # type: typing.Union[str, callable]\n+      **kwargs  # type: typing.Union[str, callable]\n+    ):\n+    if len(fields) == 1 and not kwargs:\n+      self._force_tuple_keys = False\n+      name = fields[0] if isinstance(fields[0], str) else 'key'\n+      key_fields = [(name, _expr_to_callable(fields[0], 0))]\n+    else:\n+      self._force_tuple_keys = True\n+      key_fields = []\n+      for ix, field in enumerate(fields):\n+        name = field if isinstance(field, str) else 'key%d' % ix\n+        key_fields.append((name, _expr_to_callable(field, ix)))\n+      for name, expr in kwargs.items():\n+        key_fields.append((name, _expr_to_callable(expr, name)))\n+    self._key_fields = key_fields\n+    # TODO(robertwb): Pickling of dynamic named tuples.\n+    # self._key_type = typing.NamedTuple(\n+    #     'Key', [name for name, _ in self._key_fields])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1291b588164e8d0043c73589b0af303d47e9faa9"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA2MTI4Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                # TODO(Py3): Use {**a, **b} syntax once Python 2 is gone.\n          \n          \n            \n                # TODO(BEAM-7372): Use {**a, **b} syntax once Python 2 is gone.", "url": "https://github.com/apache/beam/pull/11963#discussion_r453061283", "createdAt": "2020-07-10T20:25:03Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -2247,6 +2248,154 @@ def runner_api_requires_keyed_input(self):\n     return True\n \n \n+def _expr_to_callable(expr, pos):\n+  if isinstance(expr, str):\n+    return lambda x: getattr(x, expr)\n+  elif callable(expr):\n+    return expr\n+  else:\n+    raise TypeError(\n+        'Field expression %r at %s must be a callable or a string.' %\n+        (expr, pos))\n+\n+\n+class GroupBy(PTransform):\n+  \"\"\"Groups a PCollection by one or more expressions, used to derive the key.\n+\n+  `GroupBy(expr)` is roughly equivalent to\n+\n+      beam.Map(lambda v: (expr(v), v)) | GroupByKey()\n+\n+  but provides several conviniences, e.g.\n+\n+      * Several arguments may be provided, as positional or keyword arguments,\n+        resulting in a tuple-like key. For example `GroupBy(a=expr1, b=expr2)`\n+        groups by a key with attributes `a` and `b` computed by applying\n+        `expr1` and `expr2` to each element.\n+\n+      * Strings can be used as a shorthand for accessing an attribute, e.g.\n+        `GroupBy('some_field')` is equivalent to\n+        `GroupBy(lambda v: getattr(v, 'some_field'))`.\n+\n+  The GroupBy operation can be made into an aggregating operation by invoking\n+  its `aggregate_field` method.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      *fields,  # type: typing.Union[str, callable]\n+      **kwargs  # type: typing.Union[str, callable]\n+    ):\n+    if len(fields) == 1 and not kwargs:\n+      self._force_tuple_keys = False\n+      name = fields[0] if isinstance(fields[0], str) else 'key'\n+      key_fields = [(name, _expr_to_callable(fields[0], 0))]\n+    else:\n+      self._force_tuple_keys = True\n+      key_fields = []\n+      for ix, field in enumerate(fields):\n+        name = field if isinstance(field, str) else 'key%d' % ix\n+        key_fields.append((name, _expr_to_callable(field, ix)))\n+      for name, expr in kwargs.items():\n+        key_fields.append((name, _expr_to_callable(expr, name)))\n+    self._key_fields = key_fields\n+    # TODO(robertwb): Pickling of dynamic named tuples.\n+    # self._key_type = typing.NamedTuple(\n+    #     'Key', [name for name, _ in self._key_fields])\n+    self._key_type = lambda *values: pvalue.Row(\n+        **{name: value\n+           for (name, _), value in zip(self._key_fields, values)})\n+\n+  def aggregate_field(\n+      self,\n+      field,  # type: typing.Union[str, callable]\n+      combine_fn,  # type: typing.Union[callable, CombineFn]\n+      dest,  # type: str\n+    ):\n+    \"\"\"Returns a grouping operation that also aggregates grouped values.\n+\n+    Args:\n+      field: indicates the field to be aggregated\n+      combine_fn: indicates the aggregation function to be used\n+      dest: indicates the name that will be used for the aggregate in the output\n+\n+    May be called repeatedly to aggregate multiple fields, e.g.\n+\n+        GroupBy('key')\n+            .aggregate_field('some_attr', sum, 'sum_attr')\n+            .aggregate_field(lambda v: ..., MeanCombineFn, 'mean')\n+    \"\"\"\n+    return _GroupAndAggregate(self, ()).aggregate_field(field, combine_fn, dest)\n+\n+  def force_tuple_keys(self, value=True):\n+    \"\"\"Forces the keys to always be tuple-like, even if there is only a single\n+    expression.\n+    \"\"\"\n+    res = copy.copy(self)\n+    res._force_tuple_keys = value\n+    return res\n+\n+  def _key_func(self):\n+    if not self._force_tuple_keys and len(self._key_fields) == 1:\n+      return self._key_fields[0][1]\n+    else:\n+      key_type = self._key_type\n+      key_exprs = [expr for _, expr in self._key_fields]\n+      return lambda element: key_type(*(expr(element) for expr in key_exprs))\n+\n+  def default_label(self):\n+    return 'GroupBy(%s)' % ', '.join(name for name, _ in self._key_fields)\n+\n+  def expand(self, pcoll):\n+    return pcoll | Map(lambda x: (self._key_func()(x), x)) | GroupByKey()\n+\n+\n+class _GroupAndAggregate(PTransform):\n+  def __init__(self, grouping, aggregations):\n+    self._grouping = grouping\n+    self._aggregations = aggregations\n+\n+  def aggregate_field(\n+      self,\n+      field,  # type: typing.Union[str, callable]\n+      combine_fn,  # type: typing.Union[callable, CombineFn]\n+      dest,  # type: str\n+      ):\n+    field = _expr_to_callable(field, 0)\n+    return _GroupAndAggregate(\n+        self._grouping, list(self._aggregations) + [(field, combine_fn, dest)])\n+\n+  def expand(self, pcoll):\n+    from apache_beam.transforms.combiners import TupleCombineFn\n+\n+    # TODO(Py3): Use {**a, **b} syntax once Python 2 is gone.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1291b588164e8d0043c73589b0af303d47e9faa9"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA2MjcwMQ==", "bodyText": "Will issubclass actually raise an AttributeError? Curious what causes this", "url": "https://github.com/apache/beam/pull/11963#discussion_r453062701", "createdAt": "2020-07-10T20:28:47Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/typehints/native_type_compatibility.py", "diffHunk": "@@ -85,7 +85,7 @@ def _safe_issubclass(derived, parent):\n   \"\"\"\n   try:\n     return issubclass(derived, parent)\n-  except TypeError:\n+  except (TypeError, AttributeError):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1291b588164e8d0043c73589b0af303d47e9faa9"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b12c53337e6da45deec67b4bb1915da5ebb26bd", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/4b12c53337e6da45deec67b4bb1915da5ebb26bd", "committedDate": "2020-07-11T01:21:18Z", "message": "Update sdks/python/apache_beam/transforms/core.py\n\nCo-authored-by: Brian Hulette <hulettbh@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e903d3777f252e81113f9d606cb930d8226c2af", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/3e903d3777f252e81113f9d606cb930d8226c2af", "committedDate": "2020-07-13T17:23:25Z", "message": "Produce named tuples rather than Rows."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce85297eeb7423a6e8d3dd72cdd4ba6f8a6bbee1", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/ce85297eeb7423a6e8d3dd72cdd4ba6f8a6bbee1", "committedDate": "2020-07-13T19:19:56Z", "message": "lint"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ce1a722e88d9d192488610096985eb10ebe3a34", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/0ce1a722e88d9d192488610096985eb10ebe3a34", "committedDate": "2020-07-14T18:00:12Z", "message": "kwargs ordering"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71c758053be2695a1db66d8797c86042a148970f", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/71c758053be2695a1db66d8797c86042a148970f", "committedDate": "2020-07-14T21:01:34Z", "message": "lint"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNjIwMzU1", "url": "https://github.com/apache/beam/pull/11963#pullrequestreview-453620355", "createdAt": "2020-07-22T19:29:16Z", "commit": {"oid": "71c758053be2695a1db66d8797c86042a148970f"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxOToyOToxNlrOG1xFWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMDowNDozOVrOG1yPyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAzMTg5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              but provides several conviniences, e.g.\n          \n          \n            \n              but provides several conveniences, e.g.", "url": "https://github.com/apache/beam/pull/11963#discussion_r459031897", "createdAt": "2020-07-22T19:29:16Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -2247,6 +2249,166 @@ def runner_api_requires_keyed_input(self):\n     return True\n \n \n+def _expr_to_callable(expr, pos):\n+  if isinstance(expr, str):\n+    return lambda x: getattr(x, expr)\n+  elif callable(expr):\n+    return expr\n+  else:\n+    raise TypeError(\n+        'Field expression %r at %s must be a callable or a string.' %\n+        (expr, pos))\n+\n+\n+class GroupBy(PTransform):\n+  \"\"\"Groups a PCollection by one or more expressions, used to derive the key.\n+\n+  `GroupBy(expr)` is roughly equivalent to\n+\n+      beam.Map(lambda v: (expr(v), v)) | beam.GroupByKey()\n+\n+  but provides several conviniences, e.g.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71c758053be2695a1db66d8797c86042a148970f"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA1MDk1NQ==", "bodyText": "Ah I see. I'd rather not have this escape hatch if we can avoid it, but I can imagine it would be frustrating for users who don't care about using Rows xlang if we just refuse to make a RowCoder for them. Perhaps we should make named_fields_to_schema wrap unknown type hints in a \"pythonsdk\" logical type that uses fast primitives coder. Then we can give a better error message if/when a xlang issue arises. If you just add a TODO here I can take that action.\nWhen running locally I noticed that this is only needed for your tests because we can't infer a type for sign=x // abs(x) if x else 0 and fallback to Any. Just curious - is it possible to fix the inference for that function? It seems like we should be able to.", "url": "https://github.com/apache/beam/pull/11963#discussion_r459050955", "createdAt": "2020-07-22T20:04:39Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/coders/row_coder.py", "diffHunk": "@@ -87,7 +87,10 @@ def from_runner_api_parameter(schema, components, unused_context):\n   @staticmethod\n   def from_type_hint(type_hint, registry):\n     if isinstance(type_hint, row_type.RowTypeConstraint):\n-      schema = named_fields_to_schema(type_hint._fields)\n+      try:\n+        schema = named_fields_to_schema(type_hint._fields)\n+      except ValueError:\n+        return typecoders.registry.get_coder(object)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA1NTE5Nw=="}, "originalCommit": {"oid": "1291b588164e8d0043c73589b0af303d47e9faa9"}, "originalPosition": 8}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f797820a9548f59d6664a272ab9115e0d444c21a", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/f797820a9548f59d6664a272ab9115e0d444c21a", "committedDate": "2020-07-23T21:47:31Z", "message": "Update sdks/python/apache_beam/transforms/core.py\n\nCo-authored-by: Brian Hulette <hulettbh@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51412591d74ac30db2bdc8eb8633c99cb964d917", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/51412591d74ac30db2bdc8eb8633c99cb964d917", "committedDate": "2020-07-23T21:55:56Z", "message": "lint, todo"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4180, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}