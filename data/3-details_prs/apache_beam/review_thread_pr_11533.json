{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5NDA1MjM0", "number": 11533, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMTozMzo1MlrOD2ohNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMTozMzo1MlrOD2ohNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjEzNTU5OnYy", "diffSide": "RIGHT", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMTozMzo1MlrOGMefow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNDoxODowOFrOGMllzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczNTcxNQ==", "bodyText": "To sum up if I understand this correctly\n\nWe only need to keep a single value (the minimum)\nWe can not use scalar value that would hold the minimum, because we need a mutable wrapper\n\nin this case can we only keep the minimum value in order to have O(log N) complexity? eg.:\nvoid insertAndKeepMinimum(PriorityQueue<T> pq, T element) {\n  pq.insert(element)\n  while(pq.size() > 1) {\n    pq.remove();\n  }\n}\n\npq.remove(T ...) has linear time complexity", "url": "https://github.com/apache/beam/pull/11533#discussion_r415735715", "createdAt": "2020-04-27T11:33:52Z", "author": {"login": "dmvk"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "diffHunk": "@@ -76,8 +76,8 @@\n   private final KeyedStateBackend<ByteBuffer> flinkStateBackend;\n   private Coder<K> keyCoder;\n \n-  // Combined watermark holds for all keys of this partition\n-  private final Map<String, Instant> watermarkHolds = new HashMap<>();\n+  // Watermark holds for all keys/windows of this partition\n+  private final PriorityQueue<Long> watermarkHolds = new PriorityQueue<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc00b4b3d47ee3d4e56752673bb0cd6f10432b2d"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc0NjgyMQ==", "bodyText": "Hmm, I see it now, FlinkWatermarkHoldState is per window :/", "url": "https://github.com/apache/beam/pull/11533#discussion_r415746821", "createdAt": "2020-04-27T11:52:13Z", "author": {"login": "dmvk"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "diffHunk": "@@ -76,8 +76,8 @@\n   private final KeyedStateBackend<ByteBuffer> flinkStateBackend;\n   private Coder<K> keyCoder;\n \n-  // Combined watermark holds for all keys of this partition\n-  private final Map<String, Instant> watermarkHolds = new HashMap<>();\n+  // Watermark holds for all keys/windows of this partition\n+  private final PriorityQueue<Long> watermarkHolds = new PriorityQueue<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczNTcxNQ=="}, "originalCommit": {"oid": "fc00b4b3d47ee3d4e56752673bb0cd6f10432b2d"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgwMjUyMg==", "bodyText": "Only keeping the minimum doesn't work. When the minimum hold is cleared, we will have to recompute the minimum by iterating over all the keys in the state backend which will defeat the purpose of having the cache.", "url": "https://github.com/apache/beam/pull/11533#discussion_r415802522", "createdAt": "2020-04-27T13:15:43Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "diffHunk": "@@ -76,8 +76,8 @@\n   private final KeyedStateBackend<ByteBuffer> flinkStateBackend;\n   private Coder<K> keyCoder;\n \n-  // Combined watermark holds for all keys of this partition\n-  private final Map<String, Instant> watermarkHolds = new HashMap<>();\n+  // Watermark holds for all keys/windows of this partition\n+  private final PriorityQueue<Long> watermarkHolds = new PriorityQueue<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczNTcxNQ=="}, "originalCommit": {"oid": "fc00b4b3d47ee3d4e56752673bb0cd6f10432b2d"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgxMjE0NQ==", "bodyText": "\ud83d\udc4d that makes sense\nIt would be nice if we could get rid of pq.remove(...) calls as these are O(n) and number of keys may be fairly large. How about using TreeMap<Long, Integer> instead, where value would be number of references to that particular offset?\nThis should have O(log n) characteristic and may hopefully deduplicate some of the entries.", "url": "https://github.com/apache/beam/pull/11533#discussion_r415812145", "createdAt": "2020-04-27T13:28:06Z", "author": {"login": "dmvk"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "diffHunk": "@@ -76,8 +76,8 @@\n   private final KeyedStateBackend<ByteBuffer> flinkStateBackend;\n   private Coder<K> keyCoder;\n \n-  // Combined watermark holds for all keys of this partition\n-  private final Map<String, Instant> watermarkHolds = new HashMap<>();\n+  // Watermark holds for all keys/windows of this partition\n+  private final PriorityQueue<Long> watermarkHolds = new PriorityQueue<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczNTcxNQ=="}, "originalCommit": {"oid": "fc00b4b3d47ee3d4e56752673bb0cd6f10432b2d"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg1MTk4MA==", "bodyText": "Good idea. I've changed it to use a TreeMap.", "url": "https://github.com/apache/beam/pull/11533#discussion_r415851980", "createdAt": "2020-04-27T14:18:08Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "diffHunk": "@@ -76,8 +76,8 @@\n   private final KeyedStateBackend<ByteBuffer> flinkStateBackend;\n   private Coder<K> keyCoder;\n \n-  // Combined watermark holds for all keys of this partition\n-  private final Map<String, Instant> watermarkHolds = new HashMap<>();\n+  // Watermark holds for all keys/windows of this partition\n+  private final PriorityQueue<Long> watermarkHolds = new PriorityQueue<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczNTcxNQ=="}, "originalCommit": {"oid": "fc00b4b3d47ee3d4e56752673bb0cd6f10432b2d"}, "originalPosition": 18}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1152, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}