{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3ODE0NDA3", "number": 12759, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzo1MDozNlrOEfdtTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDowODo0OFrOEhQ-yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDI4MDQ1OnYy", "diffSide": "RIGHT", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMzo1MDozNlrOHLwGSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxNTo0MTozN1rOHODcSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA4NDQyNg==", "bodyText": "Could we do this using CleanupTimer? Something like\n      StatefulDoFnRunner.CleanupTimer cleanupTimer =\n          new StatefulDoFnRunner.TimeInternalsCleanupTimer(timerInternals, windowingStrategy) {\n            @Override\n            public void setForWindow(Object input, BoundedWindow window) {\n              if (!window.equals(GlobalWindow.INSTANCE)) {\n                super.setForWindow(input, window);\n              }\n            }\n          };\nin DoFnOperator:317", "url": "https://github.com/apache/beam/pull/12759#discussion_r482084426", "createdAt": "2020-09-02T13:50:36Z", "author": {"login": "je-ik"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1330,6 +1338,19 @@ public void setTimer(\n     @Deprecated\n     @Override\n     public void setTimer(TimerData timer) {\n+      if (timer.getTimestamp().isAfter(GlobalWindow.INSTANCE.maxTimestamp())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cce653f6e3da985cceb26666f72559bcd538ef83"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE0MTQ0Mg==", "bodyText": "It was a deliberate decision not to do it using CleanupTimer. Setting the timer is an implementation detail and should be transparent to the CleanupTimer class.", "url": "https://github.com/apache/beam/pull/12759#discussion_r482141442", "createdAt": "2020-09-02T15:03:17Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1330,6 +1338,19 @@ public void setTimer(\n     @Deprecated\n     @Override\n     public void setTimer(TimerData timer) {\n+      if (timer.getTimestamp().isAfter(GlobalWindow.INSTANCE.maxTimestamp())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA4NDQyNg=="}, "originalCommit": {"oid": "cce653f6e3da985cceb26666f72559bcd538ef83"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE1MTE0Ng==", "bodyText": "Also consider this requires to add the code at both implementations of CleanupTimer (portable and classic).", "url": "https://github.com/apache/beam/pull/12759#discussion_r482151146", "createdAt": "2020-09-02T15:13:10Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1330,6 +1338,19 @@ public void setTimer(\n     @Deprecated\n     @Override\n     public void setTimer(TimerData timer) {\n+      if (timer.getTimestamp().isAfter(GlobalWindow.INSTANCE.maxTimestamp())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA4NDQyNg=="}, "originalCommit": {"oid": "cce653f6e3da985cceb26666f72559bcd538ef83"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1NTcxMQ==", "bodyText": "I understand the concerns about code duplication. But the duplication would be really very small. On the other hand - I would say, that the CleanupTimer abstraction is there precisely for the reasons needed here - the StatefulDoFnRunner delegates on CleanupTimer the decision to setup a timer for window. Precisely what we are looking for here. The approach with tweaking setupTimer internally can have unexpected side-effects in the future, because there might (in theory) be another timer set after the end of global window.\nOn the other hand, because the probability of these unwanted side-effects seem to be low and they would be very much likely caught early in development, I think we can leave it as it is, although my personal preference would definitely be the CleanupTimer.", "url": "https://github.com/apache/beam/pull/12759#discussion_r482255711", "createdAt": "2020-09-02T17:49:07Z", "author": {"login": "je-ik"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1330,6 +1338,19 @@ public void setTimer(\n     @Deprecated\n     @Override\n     public void setTimer(TimerData timer) {\n+      if (timer.getTimestamp().isAfter(GlobalWindow.INSTANCE.maxTimestamp())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA4NDQyNg=="}, "originalCommit": {"oid": "cce653f6e3da985cceb26666f72559bcd538ef83"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM5MjQ1Mw==", "bodyText": "The namespace we use for cleanup is based on GlobalWindow and so should be the condition here. I think we can prioritize clarity over the duplication of a single conditional return statement, which should be covered by the unit tests. Or better, make a common setCleanupTimer method that has the Window parameter?", "url": "https://github.com/apache/beam/pull/12759#discussion_r482392453", "createdAt": "2020-09-02T20:08:30Z", "author": {"login": "tweise"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1330,6 +1338,19 @@ public void setTimer(\n     @Deprecated\n     @Override\n     public void setTimer(TimerData timer) {\n+      if (timer.getTimestamp().isAfter(GlobalWindow.INSTANCE.maxTimestamp())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA4NDQyNg=="}, "originalCommit": {"oid": "cce653f6e3da985cceb26666f72559bcd538ef83"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc3OTcyNg==", "bodyText": "We could create a NonGlobalWindowCleanupTimer (or something similar) in runner-core and reuse it in both portability and non-portable runner. If the code duplication would be the biggest concern.", "url": "https://github.com/apache/beam/pull/12759#discussion_r482779726", "createdAt": "2020-09-03T07:53:17Z", "author": {"login": "je-ik"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1330,6 +1338,19 @@ public void setTimer(\n     @Deprecated\n     @Override\n     public void setTimer(TimerData timer) {\n+      if (timer.getTimestamp().isAfter(GlobalWindow.INSTANCE.maxTimestamp())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA4NDQyNg=="}, "originalCommit": {"oid": "cce653f6e3da985cceb26666f72559bcd538ef83"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ5ODUwNA==", "bodyText": "Please have a look, I've adjusted the implementation.", "url": "https://github.com/apache/beam/pull/12759#discussion_r484498504", "createdAt": "2020-09-07T15:41:37Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1330,6 +1338,19 @@ public void setTimer(\n     @Deprecated\n     @Override\n     public void setTimer(TimerData timer) {\n+      if (timer.getTimestamp().isAfter(GlobalWindow.INSTANCE.maxTimestamp())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA4NDQyNg=="}, "originalCommit": {"oid": "cce653f6e3da985cceb26666f72559bcd538ef83"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjE0OTA1OnYy", "diffSide": "RIGHT", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDowODo0MlrOHMC6iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxNTo0MTowOFrOHODbiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM5MjcxMw==", "bodyText": "The existing solution checks that we have not already reached the watermark to avoid repeated execution of the cleanup code. Please carry that over.\nAlso, why check for keyedStateInternals? See #12733 (comment)", "url": "https://github.com/apache/beam/pull/12759#discussion_r482392713", "createdAt": "2020-09-02T20:08:42Z", "author": {"login": "tweise"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -753,6 +754,13 @@ private void maybeEmitWatermark(long watermark) {\n       LOG.debug(\"Emitting watermark {}\", watermark);\n       currentOutputWatermark = watermark;\n       output.emitWatermark(new Watermark(watermark));\n+\n+      // Check if the final watermark was triggered to perform state cleanup for global window\n+      if (keyedStateInternals != null\n+          && currentOutputWatermark", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cce653f6e3da985cceb26666f72559bcd538ef83"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg0MDkxNw==", "bodyText": "Cleanup will only be performed if there is new state which IMHO is the correct thing to do.", "url": "https://github.com/apache/beam/pull/12759#discussion_r482840917", "createdAt": "2020-09-03T09:30:33Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -753,6 +754,13 @@ private void maybeEmitWatermark(long watermark) {\n       LOG.debug(\"Emitting watermark {}\", watermark);\n       currentOutputWatermark = watermark;\n       output.emitWatermark(new Watermark(watermark));\n+\n+      // Check if the final watermark was triggered to perform state cleanup for global window\n+      if (keyedStateInternals != null\n+          && currentOutputWatermark", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM5MjcxMw=="}, "originalCommit": {"oid": "cce653f6e3da985cceb26666f72559bcd538ef83"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ5ODMxNQ==", "bodyText": "Due to all logic now being in keyedStateInternals, we need the null check. The state internals will be null if we do not have keyed input.", "url": "https://github.com/apache/beam/pull/12759#discussion_r484498315", "createdAt": "2020-09-07T15:41:08Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -753,6 +754,13 @@ private void maybeEmitWatermark(long watermark) {\n       LOG.debug(\"Emitting watermark {}\", watermark);\n       currentOutputWatermark = watermark;\n       output.emitWatermark(new Watermark(watermark));\n+\n+      // Check if the final watermark was triggered to perform state cleanup for global window\n+      if (keyedStateInternals != null\n+          && currentOutputWatermark", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM5MjcxMw=="}, "originalCommit": {"oid": "cce653f6e3da985cceb26666f72559bcd538ef83"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjE4MTA2OnYy", "diffSide": "RIGHT", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDoxMjo0NlrOHMDQKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDoxMjo0NlrOHMDQKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM5ODI0OA==", "bodyText": "I would remove \"because we are not guaranteed to ever receive the final watermark\" because that is misleading. The problem is that we accumulate too many timers, depending on the number of keys.", "url": "https://github.com/apache/beam/pull/12759#discussion_r482398248", "createdAt": "2020-09-02T20:12:46Z", "author": {"login": "tweise"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "diffHunk": "@@ -114,16 +127,27 @@ public K getKey() {\n     return address.getSpec().bind(address.getId(), new FlinkStateBinder(namespace, context));\n   }\n \n-  public void clearBagStates(StateNamespace namespace, StateTag<? extends BagState> address)\n-      throws Exception {\n-    CoderTypeSerializer typeSerializer = new CoderTypeSerializer<>(VoidCoder.of());\n-    flinkStateBackend.applyToAllKeys(\n-        namespace.stringKey(),\n-        StringSerializer.INSTANCE,\n-        new ListStateDescriptor<>(address.getId(), typeSerializer),\n-        (key, state) -> {\n-          state.clear();\n-        });\n+  /**\n+   * Allows to clear all state for the global watermark when the maximum watermark arrives. We do\n+   * not clean up the global window state via timers because we are not guranteed to ever receive\n+   * the final watermark which would lead to an unbounded number of keys and cleanup timers.\n+   * Instead, the cleanup code below should be run when we finally receive the max watermark.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cce653f6e3da985cceb26666f72559bcd538ef83"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjE5NDU5OnYy", "diffSide": "RIGHT", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDoxNDozN1rOHMDZsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwOTozMzowMVrOHMeXiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQwMDY4OQ==", "bodyText": "As implemented this contains all state descriptors, regardless of the window?", "url": "https://github.com/apache/beam/pull/12759#discussion_r482400689", "createdAt": "2020-09-02T20:14:37Z", "author": {"login": "tweise"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "diffHunk": "@@ -75,7 +80,14 @@\n public class FlinkStateInternals<K> implements StateInternals {\n \n   private final KeyedStateBackend<ByteBuffer> flinkStateBackend;\n-  private Coder<K> keyCoder;\n+  private final Coder<K> keyCoder;\n+\n+  /**\n+   * A set which contains all state descriptors created in the global window. Used for cleanup on", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cce653f6e3da985cceb26666f72559bcd538ef83"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg0MTg5Mw==", "bodyText": "Yes, that's right but that doesn't matter because all other state should also be cleaned up with the global window.", "url": "https://github.com/apache/beam/pull/12759#discussion_r482841893", "createdAt": "2020-09-03T09:32:04Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "diffHunk": "@@ -75,7 +80,14 @@\n public class FlinkStateInternals<K> implements StateInternals {\n \n   private final KeyedStateBackend<ByteBuffer> flinkStateBackend;\n-  private Coder<K> keyCoder;\n+  private final Coder<K> keyCoder;\n+\n+  /**\n+   * A set which contains all state descriptors created in the global window. Used for cleanup on", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQwMDY4OQ=="}, "originalCommit": {"oid": "cce653f6e3da985cceb26666f72559bcd538ef83"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg0MjUwNA==", "bodyText": "I'll remove \"global window\".", "url": "https://github.com/apache/beam/pull/12759#discussion_r482842504", "createdAt": "2020-09-03T09:33:01Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "diffHunk": "@@ -75,7 +80,14 @@\n public class FlinkStateInternals<K> implements StateInternals {\n \n   private final KeyedStateBackend<ByteBuffer> flinkStateBackend;\n-  private Coder<K> keyCoder;\n+  private final Coder<K> keyCoder;\n+\n+  /**\n+   * A set which contains all state descriptors created in the global window. Used for cleanup on", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQwMDY4OQ=="}, "originalCommit": {"oid": "cce653f6e3da985cceb26666f72559bcd538ef83"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjMwMTg2OnYy", "diffSide": "RIGHT", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDoyOToxNlrOHMElPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxNTo0MjowM1rOHODdIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQyMDAzMA==", "bodyText": "This is executed on every state access in the portable runner. It might be possible to reuse the descriptors. How much could be the net benefit? Probably small compared to the fn api overhead.", "url": "https://github.com/apache/beam/pull/12759#discussion_r482420030", "createdAt": "2020-09-02T20:29:16Z", "author": {"login": "tweise"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "diffHunk": "@@ -139,17 +163,27 @@ private FlinkStateBinder(StateNamespace namespace, StateContext<?> stateContext)\n     @Override\n     public <T2> ValueState<T2> bindValue(\n         String id, StateSpec<ValueState<T2>> spec, Coder<T2> coder) {\n-      return new FlinkValueState<>(flinkStateBackend, id, namespace, coder);\n+      ValueStateDescriptor<T2> valueStateDescriptor =\n+          new ValueStateDescriptor<>(id, new CoderTypeSerializer<>(coder));\n+      globalWindowStateDescriptors.add(valueStateDescriptor);\n+      return new FlinkValueState<>(flinkStateBackend, id, namespace, valueStateDescriptor);\n     }\n \n     @Override\n     public <T2> BagState<T2> bindBag(String id, StateSpec<BagState<T2>> spec, Coder<T2> elemCoder) {\n-      return new FlinkBagState<>(flinkStateBackend, id, namespace, elemCoder);\n+      ListStateDescriptor<T2> listStateDescriptor =\n+          new ListStateDescriptor<>(id, new CoderTypeSerializer<>(elemCoder));\n+      globalWindowStateDescriptors.add(listStateDescriptor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cce653f6e3da985cceb26666f72559bcd538ef83"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg0Mjg4NQ==", "bodyText": "This is unrelated to the changes here. This object was just created a layer down before (FlinkBagState). Let's handle such optimizations in a follow-up.", "url": "https://github.com/apache/beam/pull/12759#discussion_r482842885", "createdAt": "2020-09-03T09:33:32Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "diffHunk": "@@ -139,17 +163,27 @@ private FlinkStateBinder(StateNamespace namespace, StateContext<?> stateContext)\n     @Override\n     public <T2> ValueState<T2> bindValue(\n         String id, StateSpec<ValueState<T2>> spec, Coder<T2> coder) {\n-      return new FlinkValueState<>(flinkStateBackend, id, namespace, coder);\n+      ValueStateDescriptor<T2> valueStateDescriptor =\n+          new ValueStateDescriptor<>(id, new CoderTypeSerializer<>(coder));\n+      globalWindowStateDescriptors.add(valueStateDescriptor);\n+      return new FlinkValueState<>(flinkStateBackend, id, namespace, valueStateDescriptor);\n     }\n \n     @Override\n     public <T2> BagState<T2> bindBag(String id, StateSpec<BagState<T2>> spec, Coder<T2> elemCoder) {\n-      return new FlinkBagState<>(flinkStateBackend, id, namespace, elemCoder);\n+      ListStateDescriptor<T2> listStateDescriptor =\n+          new ListStateDescriptor<>(id, new CoderTypeSerializer<>(elemCoder));\n+      globalWindowStateDescriptors.add(listStateDescriptor);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQyMDAzMA=="}, "originalCommit": {"oid": "cce653f6e3da985cceb26666f72559bcd538ef83"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ5ODcyMw==", "bodyText": "Changed reverted.", "url": "https://github.com/apache/beam/pull/12759#discussion_r484498723", "createdAt": "2020-09-07T15:42:03Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "diffHunk": "@@ -139,17 +163,27 @@ private FlinkStateBinder(StateNamespace namespace, StateContext<?> stateContext)\n     @Override\n     public <T2> ValueState<T2> bindValue(\n         String id, StateSpec<ValueState<T2>> spec, Coder<T2> coder) {\n-      return new FlinkValueState<>(flinkStateBackend, id, namespace, coder);\n+      ValueStateDescriptor<T2> valueStateDescriptor =\n+          new ValueStateDescriptor<>(id, new CoderTypeSerializer<>(coder));\n+      globalWindowStateDescriptors.add(valueStateDescriptor);\n+      return new FlinkValueState<>(flinkStateBackend, id, namespace, valueStateDescriptor);\n     }\n \n     @Override\n     public <T2> BagState<T2> bindBag(String id, StateSpec<BagState<T2>> spec, Coder<T2> elemCoder) {\n-      return new FlinkBagState<>(flinkStateBackend, id, namespace, elemCoder);\n+      ListStateDescriptor<T2> listStateDescriptor =\n+          new ListStateDescriptor<>(id, new CoderTypeSerializer<>(elemCoder));\n+      globalWindowStateDescriptors.add(listStateDescriptor);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQyMDAzMA=="}, "originalCommit": {"oid": "cce653f6e3da985cceb26666f72559bcd538ef83"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjMzMTQ0OnYy", "diffSide": "LEFT", "path": "runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDozMzoyN1rOHME6Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwOTozMDowMFrOHMePvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQyNTQzMQ==", "bodyText": "Keep this to check that the cleanup isn't repeated even when the watermark is repeated.", "url": "https://github.com/apache/beam/pull/12759#discussion_r482425431", "createdAt": "2020-09-02T20:33:27Z", "author": {"login": "tweise"}, "path": "runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java", "diffHunk": "@@ -910,21 +892,16 @@ public void testEnsureStateCleanupOnFinalWatermark() throws Exception {\n         operator.keyedStateInternals.state(\n             stateNamespace, StateTags.bag(stateId, ByteStringCoder.of()));\n     state.add(ByteString.copyFrom(\"userstate\".getBytes(Charsets.UTF_8)));\n+    // No timers have been set for cleanup\n+    assertThat(testHarness.numEventTimeTimers(), is(0));\n+    // State has been created\n     assertThat(testHarness.numKeyedStateEntries(), is(1));\n \n     // Generate final watermark to trigger state cleanup\n     testHarness.processWatermark(\n         new Watermark(BoundedWindow.TIMESTAMP_MAX_VALUE.plus(1).getMillis()));\n \n     assertThat(testHarness.numKeyedStateEntries(), is(0));\n-\n-    // Close should not repeat state cleanup", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cce653f6e3da985cceb26666f72559bcd538ef83"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg0MDUxMQ==", "bodyText": "I believe the cleanup ought to be repeated if there is new state. If there is none, then no cleanup will be performed because we keep track of the state descriptors created and clear that set on clean-up.", "url": "https://github.com/apache/beam/pull/12759#discussion_r482840511", "createdAt": "2020-09-03T09:30:00Z", "author": {"login": "mxm"}, "path": "runners/flink/src/test/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperatorTest.java", "diffHunk": "@@ -910,21 +892,16 @@ public void testEnsureStateCleanupOnFinalWatermark() throws Exception {\n         operator.keyedStateInternals.state(\n             stateNamespace, StateTags.bag(stateId, ByteStringCoder.of()));\n     state.add(ByteString.copyFrom(\"userstate\".getBytes(Charsets.UTF_8)));\n+    // No timers have been set for cleanup\n+    assertThat(testHarness.numEventTimeTimers(), is(0));\n+    // State has been created\n     assertThat(testHarness.numKeyedStateEntries(), is(1));\n \n     // Generate final watermark to trigger state cleanup\n     testHarness.processWatermark(\n         new Watermark(BoundedWindow.TIMESTAMP_MAX_VALUE.plus(1).getMillis()));\n \n     assertThat(testHarness.numKeyedStateEntries(), is(0));\n-\n-    // Close should not repeat state cleanup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQyNTQzMQ=="}, "originalCommit": {"oid": "cce653f6e3da985cceb26666f72559bcd538ef83"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMTAxNTk5OnYy", "diffSide": "RIGHT", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwMjozNjo1NVrOHOKyKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNzo1MTo1MlrOHORAqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYxODc5NQ==", "bodyText": "Is there a good reason to not use applyToAllKeys? A specific state backend may have a better implementation, overriding the naive generic key iteration here: https://github.com/apache/flink/blob/c1a12e925b6ef46ad5cf0e0a5723949572550e9b/flink-runtime/src/main/java/org/apache/flink/runtime/state/AbstractKeyedStateBackend.java#L242", "url": "https://github.com/apache/beam/pull/12759#discussion_r484618795", "createdAt": "2020-09-08T02:36:55Z", "author": {"login": "tweise"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "diffHunk": "@@ -111,19 +128,43 @@ public K getKey() {\n   @Override\n   public <T extends State> T state(\n       StateNamespace namespace, StateTag<T> address, StateContext<?> context) {\n+    if (globalWindowNamespace.equals(namespace)) {\n+      // Take note of state bound to the global window for cleanup in clearGlobalState below.\n+      globalWindowStateTags.add(address);\n+    }\n     return address.getSpec().bind(address.getId(), new FlinkStateBinder(namespace, context));\n   }\n \n-  public void clearBagStates(StateNamespace namespace, StateTag<? extends BagState> address)\n-      throws Exception {\n-    CoderTypeSerializer typeSerializer = new CoderTypeSerializer<>(VoidCoder.of());\n-    flinkStateBackend.applyToAllKeys(\n-        namespace.stringKey(),\n-        StringSerializer.INSTANCE,\n-        new ListStateDescriptor<>(address.getId(), typeSerializer),\n-        (key, state) -> {\n+  /**\n+   * Allows to clear all state for the global watermark when the maximum watermark arrives. We do\n+   * not clean up the global window state via timers which would lead to an unbounded number of keys\n+   * and cleanup timers. Instead, the cleanup code below should be run when we finally receive the\n+   * max watermark.\n+   */\n+  public void clearGlobalState() {\n+    try {\n+      for (StateTag stateTag : globalWindowStateTags) {\n+        State state =\n+            state(\n+                globalWindowNamespace,\n+                stateTag,\n+                StateContexts.windowOnlyContext(GlobalWindow.INSTANCE));\n+        // We collect all keys in the global window for a particular state\n+        // Note that the alternative method applyToAllKeys(..) does the same internally.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81f48209810b8538429e6888fce6a98b377027e1"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcyMDgxMQ==", "bodyText": "Not really, other than using Beam's state descriptors instead of Flink's. Good point on other state backends potentially allowing to iterate over the keys without materializing first. Have reverted this back to the old behavior.", "url": "https://github.com/apache/beam/pull/12759#discussion_r484720811", "createdAt": "2020-09-08T07:51:52Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "diffHunk": "@@ -111,19 +128,43 @@ public K getKey() {\n   @Override\n   public <T extends State> T state(\n       StateNamespace namespace, StateTag<T> address, StateContext<?> context) {\n+    if (globalWindowNamespace.equals(namespace)) {\n+      // Take note of state bound to the global window for cleanup in clearGlobalState below.\n+      globalWindowStateTags.add(address);\n+    }\n     return address.getSpec().bind(address.getId(), new FlinkStateBinder(namespace, context));\n   }\n \n-  public void clearBagStates(StateNamespace namespace, StateTag<? extends BagState> address)\n-      throws Exception {\n-    CoderTypeSerializer typeSerializer = new CoderTypeSerializer<>(VoidCoder.of());\n-    flinkStateBackend.applyToAllKeys(\n-        namespace.stringKey(),\n-        StringSerializer.INSTANCE,\n-        new ListStateDescriptor<>(address.getId(), typeSerializer),\n-        (key, state) -> {\n+  /**\n+   * Allows to clear all state for the global watermark when the maximum watermark arrives. We do\n+   * not clean up the global window state via timers which would lead to an unbounded number of keys\n+   * and cleanup timers. Instead, the cleanup code below should be run when we finally receive the\n+   * max watermark.\n+   */\n+  public void clearGlobalState() {\n+    try {\n+      for (StateTag stateTag : globalWindowStateTags) {\n+        State state =\n+            state(\n+                globalWindowNamespace,\n+                stateTag,\n+                StateContexts.windowOnlyContext(GlobalWindow.INSTANCE));\n+        // We collect all keys in the global window for a particular state\n+        // Note that the alternative method applyToAllKeys(..) does the same internally.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYxODc5NQ=="}, "originalCommit": {"oid": "81f48209810b8538429e6888fce6a98b377027e1"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMjA5ODgyOnYy", "diffSide": "RIGHT", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwOTozNToyNVrOHOU5kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDozMzo1NVrOHOgJ8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4NDUyOA==", "bodyText": "Looks we can keep this private?", "url": "https://github.com/apache/beam/pull/12759#discussion_r484784528", "createdAt": "2020-09-08T09:35:25Z", "author": {"login": "je-ik"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java", "diffHunk": "@@ -899,7 +876,7 @@ public void finishBundle() {\n   }\n \n   static class CleanupTimer<InputT> implements StatefulDoFnRunner.CleanupTimer<InputT> {\n-    private static final String GC_TIMER_ID = \"__user-state-cleanup__\";\n+    public static final String GC_TIMER_ID = \"__user-state-cleanup__\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26b087bcd4770268fbbed0899386573be11796c6"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk1NDQwOQ==", "bodyText": "Yep! Thanks.", "url": "https://github.com/apache/beam/pull/12759#discussion_r484954409", "createdAt": "2020-09-08T14:15:01Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java", "diffHunk": "@@ -899,7 +876,7 @@ public void finishBundle() {\n   }\n \n   static class CleanupTimer<InputT> implements StatefulDoFnRunner.CleanupTimer<InputT> {\n-    private static final String GC_TIMER_ID = \"__user-state-cleanup__\";\n+    public static final String GC_TIMER_ID = \"__user-state-cleanup__\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4NDUyOA=="}, "originalCommit": {"oid": "26b087bcd4770268fbbed0899386573be11796c6"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk2ODk0Nw==", "bodyText": "Addressed in the merge commit.", "url": "https://github.com/apache/beam/pull/12759#discussion_r484968947", "createdAt": "2020-09-08T14:33:55Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java", "diffHunk": "@@ -899,7 +876,7 @@ public void finishBundle() {\n   }\n \n   static class CleanupTimer<InputT> implements StatefulDoFnRunner.CleanupTimer<InputT> {\n-    private static final String GC_TIMER_ID = \"__user-state-cleanup__\";\n+    public static final String GC_TIMER_ID = \"__user-state-cleanup__\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4NDUyOA=="}, "originalCommit": {"oid": "26b087bcd4770268fbbed0899386573be11796c6"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMzE2NjgxOnYy", "diffSide": "RIGHT", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDowODo0OFrOHOe_ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDoxNTo0OFrOHOfTfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk0OTkyMw==", "bodyText": "Doesn't need to be public?", "url": "https://github.com/apache/beam/pull/12759#discussion_r484949923", "createdAt": "2020-09-08T14:08:48Z", "author": {"login": "tweise"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "diffHunk": "@@ -114,16 +129,26 @@ public K getKey() {\n     return address.getSpec().bind(address.getId(), new FlinkStateBinder(namespace, context));\n   }\n \n-  public void clearBagStates(StateNamespace namespace, StateTag<? extends BagState> address)\n-      throws Exception {\n-    CoderTypeSerializer typeSerializer = new CoderTypeSerializer<>(VoidCoder.of());\n-    flinkStateBackend.applyToAllKeys(\n-        namespace.stringKey(),\n-        StringSerializer.INSTANCE,\n-        new ListStateDescriptor<>(address.getId(), typeSerializer),\n-        (key, state) -> {\n-          state.clear();\n-        });\n+  /**\n+   * Allows to clear all state for the global watermark when the maximum watermark arrives. We do\n+   * not clean up the global window state via timers which would lead to an unbounded number of keys\n+   * and cleanup timers. Instead, the cleanup code below should be run when we finally receive the\n+   * max watermark.\n+   */\n+  public void clearGlobalState() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26b087bcd4770268fbbed0899386573be11796c6"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk1NTAwNA==", "bodyText": "I think it has to be because this is called from outside of the state package.", "url": "https://github.com/apache/beam/pull/12759#discussion_r484955004", "createdAt": "2020-09-08T14:15:48Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/state/FlinkStateInternals.java", "diffHunk": "@@ -114,16 +129,26 @@ public K getKey() {\n     return address.getSpec().bind(address.getId(), new FlinkStateBinder(namespace, context));\n   }\n \n-  public void clearBagStates(StateNamespace namespace, StateTag<? extends BagState> address)\n-      throws Exception {\n-    CoderTypeSerializer typeSerializer = new CoderTypeSerializer<>(VoidCoder.of());\n-    flinkStateBackend.applyToAllKeys(\n-        namespace.stringKey(),\n-        StringSerializer.INSTANCE,\n-        new ListStateDescriptor<>(address.getId(), typeSerializer),\n-        (key, state) -> {\n-          state.clear();\n-        });\n+  /**\n+   * Allows to clear all state for the global watermark when the maximum watermark arrives. We do\n+   * not clean up the global window state via timers which would lead to an unbounded number of keys\n+   * and cleanup timers. Instead, the cleanup code below should be run when we finally receive the\n+   * max watermark.\n+   */\n+  public void clearGlobalState() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk0OTkyMw=="}, "originalCommit": {"oid": "26b087bcd4770268fbbed0899386573be11796c6"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 441, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}