{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4Nzg4MzI0", "number": 10716, "title": "[BEAM-9167] Metrics extraction refactoring.", "bodyText": "Changes up how metrics are accessed. Instead of having them globally available, they're exclusively available on a per-bundle metrics store, which reduces the overhead of creating metrics proxies and updating.\nIn particular, this change moves the extraction of metrics to the FnAPI protos to the exec package, so the metrics package becomes proto agnostic. It's also forward looking, in that the metric extractors are typed with int64 to distinguish them for eventual inclusion of the float64 variants.\nAdds additional benchmarking around specific parts of the work of modifying metrics. Benchmark values, as always, are relative to machine, OS, and Go version.\nTwo areas for subsequent work:\nLeft as an open question are parts are how users can get access to the store (or provide an extractor) for metrics after a job. Missing for this is an equivalent \"ingestor\" for accepting metrics from an outside source for use by runners.\nFor a more near term CL, is actually using the v2 metrics MonitoringInfo protos instead of the legacy style. This refactoring makes it easier to support both, without the metrics package needing to be tightly coupled to the protos.\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nApex\nDataflow\nFlink\nGearpump\nSamza\nSpark\n\n\n\n\nGo\n\n---\n---\n\n---\n---\n\n\n\nJava\n\n\n\n\n\n\n\n\n\nPython\n\n---\n\n\n---\n---\n\n\n\nXLang\n---\n---\n---\n\n---\n---\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-01-29T22:01:49Z", "url": "https://github.com/apache/beam/pull/10716", "merged": true, "mergeCommit": {"oid": "c8a937caa49de1b37819873e8377591564dd0288"}, "closed": true, "closedAt": "2020-01-31T22:53:38Z", "author": {"login": "lostluck"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb_NrX9AH2gAyMzY4Nzg4MzI0OjViNDhiYzUyOWRiYjk1ZmNkMzcxZjQ1ZWE5NmIwNWJmZDhjMTVjMjE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb_20XrAFqTM1MTgwODIxNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5b48bc529dbb95fcd371f45ea96b05bfd8c15c21", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/5b48bc529dbb95fcd371f45ea96b05bfd8c15c21", "committedDate": "2020-01-29T22:28:18Z", "message": "[BEAM-9167] Metrics extraction refactoring."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6681647827e9b400d99a4fdfb812100726fcbb67", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/6681647827e9b400d99a4fdfb812100726fcbb67", "committedDate": "2020-01-29T21:50:09Z", "message": "[BEAM-9167] Metrics extraction refactoring."}, "afterCommit": {"oid": "5b48bc529dbb95fcd371f45ea96b05bfd8c15c21", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/5b48bc529dbb95fcd371f45ea96b05bfd8c15c21", "committedDate": "2020-01-29T22:28:18Z", "message": "[BEAM-9167] Metrics extraction refactoring."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMjUwMjI0", "url": "https://github.com/apache/beam/pull/10716#pullrequestreview-351250224", "createdAt": "2020-01-31T01:31:48Z", "commit": {"oid": "5b48bc529dbb95fcd371f45ea96b05bfd8c15c21"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMTozMTo0OFrOFj_NXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwNTowMzo0OFrOFkBePA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4MDA5NQ==", "bodyText": "I don't see this metricDumper struct used anywhere. Was this accidentally left in?", "url": "https://github.com/apache/beam/pull/10716#discussion_r373280095", "createdAt": "2020-01-31T01:31:48Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/metrics/dumper.go", "diffHunk": "@@ -0,0 +1,130 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metrics\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"sort\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/log\"\n+)\n+\n+// DumpToLog is a debugging function that outputs all metrics available locally\n+// to beam.Log.\n+func DumpToLog(ctx context.Context) {\n+\tstore := GetStore(ctx)\n+\tif store == nil {\n+\t\tlog.Errorf(ctx, \"Unable to dump metrics: provided context doesn't contain metrics Store.\")\n+\t\treturn\n+\t}\n+\tDumpToLogFromStore(ctx, store)\n+}\n+\n+// DumpToLogFromStore dumps the metrics in the provided Store to beam.Log.\n+func DumpToLogFromStore(ctx context.Context, store *Store) {\n+\tdumperExtractor(store, func(format string, args ...interface{}) {\n+\t\tlog.Errorf(ctx, format, args...)\n+\t})\n+}\n+\n+// DumpToOutFromContext is a debugging function that outputs all metrics\n+// available locally to std out,\n+// extracting the metric store from the context.\n+func DumpToOutFromContext(ctx context.Context) {\n+\tstore := GetStore(ctx)\n+\tif store == nil {\n+\t\tfmt.Printf(\"Unable to dump metrics: provided context doesn't contain metrics Store.\")\n+\t\treturn\n+\t}\n+\tDumpToOutFromStore(store)\n+}\n+\n+// DumpToOutFromStore is a debugging function that outputs all metrics\n+// available locally to std out directly from the store.\n+func DumpToOutFromStore(store *Store) {\n+\tdumperExtractor(store, func(format string, args ...interface{}) {\n+\t\tfmt.Printf(format+\"\\n\", args...)\n+\t})\n+}\n+\n+func dumperExtractor(store *Store, p func(format string, args ...interface{})) {\n+\tm := make(map[Labels]interface{})\n+\te := &Extractor{\n+\t\tSumInt64: func(l Labels, v int64) {\n+\t\t\tm[l] = &counter{value: v}\n+\t\t},\n+\t\tDistributionInt64: func(l Labels, count, sum, min, max int64) {\n+\t\t\tm[l] = &distribution{count: count, sum: sum, min: min, max: max}\n+\t\t},\n+\t\tGaugeInt64: func(l Labels, v int64, t time.Time) {\n+\t\t\tm[l] = &gauge{v: v, t: t}\n+\t\t},\n+\t}\n+\te.ExtractFrom(store)\n+\tdumpTo(m, p)\n+}\n+\n+type metricDumper struct {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b48bc529dbb95fcd371f45ea96b05bfd8c15c21"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5NTgwOQ==", "bodyText": "This seems like a misplaced comment, since a metric isn't being stored in this method.", "url": "https://github.com/apache/beam/pull/10716#discussion_r373295809", "createdAt": "2020-01-31T02:51:39Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/metrics/metrics.go", "diffHunk": "@@ -144,63 +119,55 @@ func (ctx *beamCtx) String() string {\n \treturn fmt.Sprintf(\"beamCtx[%s;%s]\", ctx.bundleID, ctx.ptransformID)\n }\n \n-// SetBundleID sets the id of the current Bundle.\n+// SetBundleID sets the id of the current Bundle, and populates the store.\n func SetBundleID(ctx context.Context, id string) context.Context {\n \t// Checking for *beamCtx is an optimization, so we don't dig deeply\n \t// for ids if not necessary.\n \tif bctx, ok := ctx.(*beamCtx); ok {\n-\t\treturn &beamCtx{Context: bctx.Context, bundleID: id, bs: &perBundle{}, ptransformID: bctx.ptransformID}\n+\t\treturn &beamCtx{Context: bctx.Context, bundleID: id, store: newStore(), ptransformID: bctx.ptransformID}\n \t}\n-\treturn &beamCtx{Context: ctx, bundleID: id, bs: &perBundle{}}\n+\treturn &beamCtx{Context: ctx, bundleID: id, store: newStore()}\n }\n \n // SetPTransformID sets the id of the current PTransform.\n-// Must only be called on a context returened by SetBundleID.\n+// Must only be called on a context returned by SetBundleID.\n func SetPTransformID(ctx context.Context, id string) context.Context {\n \t// Checking for *beamCtx is an optimization, so we don't dig deeply\n \t// for ids if not necessary.\n \tif bctx, ok := ctx.(*beamCtx); ok {\n-\t\treturn &beamCtx{Context: bctx.Context, bundleID: bctx.bundleID, bs: bctx.bs, ptransformID: id}\n+\t\treturn &beamCtx{Context: bctx.Context, bundleID: bctx.bundleID, store: bctx.store, ptransformID: id}\n+\t}\n+\t// Avoid breaking if the bundle is unset in testing.\n+\treturn &beamCtx{Context: ctx, bundleID: bundleIDUnset, store: newStore(), ptransformID: id}\n+}\n+\n+// GetStore extracts the metrics Store for the given context for a bundle.\n+//\n+// Returns nil if the context doesn't contain a metric Store.\n+func GetStore(ctx context.Context) *Store {\n+\tif bctx, ok := ctx.(*beamCtx); ok {\n+\t\treturn bctx.store\n+\t}\n+\tif v := ctx.Value(storeKey); v != nil {\n+\t\treturn v.(*Store)\n \t}\n-\tpanic(fmt.Sprintf(\"SetPTransformID called before SetBundleID for %v\", id))\n-\treturn nil // never runs.\n+\treturn nil\n }\n \n const (\n \tbundleIDUnset     = \"(bundle id unset)\"\n \tptransformIDUnset = \"(ptransform id unset)\"\n )\n \n-func getContextKey(ctx context.Context, n name) key {\n-\tkey := key{name: n, bundle: bundleIDUnset, ptransform: ptransformIDUnset}\n-\tif id := ctx.Value(bundleKey); id != nil {\n-\t\tkey.bundle = id.(string)\n-\t}\n-\tif id := ctx.Value(ptransformKey); id != nil {\n-\t\tkey.ptransform = id.(string)\n-\t}\n-\treturn key\n-}\n-\n func getCounterSet(ctx context.Context) *ptCounterSet {\n-\tif id := ctx.Value(counterSetKey); id != nil {\n-\t\treturn id.(*ptCounterSet)\n+\tif bctx, ok := ctx.(*beamCtx); ok && bctx.cs != nil {\n+\t\treturn bctx.cs\n \t}\n-\t// It's not set anywhere and wasn't hoisted, so create it.\n-\tif bctx, ok := ctx.(*beamCtx); ok {\n-\t\tbctx.bs.mu.Lock()\n-\t\tcs := &ptCounterSet{\n-\t\t\tcounters:      make(map[nameHash]*counter),\n-\t\t\tdistributions: make(map[nameHash]*distribution),\n-\t\t\tgauges:        make(map[nameHash]*gauge),\n-\t\t}\n-\t\tbctx.bs.css = append(bctx.bs.css, cs)\n-\t\tbctx.cs = cs\n-\t\tbctx.bs.mu.Unlock()\n-\t\treturn cs\n+\tif set := ctx.Value(counterSetKey); set != nil {\n+\t\treturn set.(*ptCounterSet)\n \t}\n-\tpanic(\"counterSet missing, beam isn't set up properly.\")\n-\treturn nil // never runs.\n+\t// This isn't a beam context, so we can't store the metric.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b48bc529dbb95fcd371f45ea96b05bfd8c15c21"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMxNzE4MA==", "bodyText": "To answer the TODO's question: This seems fine to me. What are the concerns you have about exposing the metrics like this?", "url": "https://github.com/apache/beam/pull/10716#discussion_r373317180", "createdAt": "2020-01-31T05:03:48Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/runners/direct/direct.go", "diffHunk": "@@ -72,7 +72,9 @@ func Execute(ctx context.Context, p *beam.Pipeline) error {\n \tif err = plan.Down(ctx); err != nil {\n \t\treturn err\n \t}\n-\tmetrics.DumpToLog(ctx)\n+\t// TODO(lostluck) 2020/01/24: What's the right way to expose the\n+\t// metrics store for the direct runner?\n+\tmetrics.DumpToLogFromStore(ctx, plan.Store)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b48bc529dbb95fcd371f45ea96b05bfd8c15c21"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8150548b90f5d138c3c34e470174bc7da22b156c", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/8150548b90f5d138c3c34e470174bc7da22b156c", "committedDate": "2020-01-31T22:23:01Z", "message": "!fixup address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODA4MjE1", "url": "https://github.com/apache/beam/pull/10716#pullrequestreview-351808215", "createdAt": "2020-01-31T22:12:55Z", "commit": {"oid": "5b48bc529dbb95fcd371f45ea96b05bfd8c15c21"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQyMjoxMjo1NVrOFkZX2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQyMjoyMTo1OVrOFkZixQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcwODc2MQ==", "bodyText": "Good catch. Oversight from a previous prototype.", "url": "https://github.com/apache/beam/pull/10716#discussion_r373708761", "createdAt": "2020-01-31T22:12:55Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/metrics/dumper.go", "diffHunk": "@@ -0,0 +1,130 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metrics\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"sort\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/log\"\n+)\n+\n+// DumpToLog is a debugging function that outputs all metrics available locally\n+// to beam.Log.\n+func DumpToLog(ctx context.Context) {\n+\tstore := GetStore(ctx)\n+\tif store == nil {\n+\t\tlog.Errorf(ctx, \"Unable to dump metrics: provided context doesn't contain metrics Store.\")\n+\t\treturn\n+\t}\n+\tDumpToLogFromStore(ctx, store)\n+}\n+\n+// DumpToLogFromStore dumps the metrics in the provided Store to beam.Log.\n+func DumpToLogFromStore(ctx context.Context, store *Store) {\n+\tdumperExtractor(store, func(format string, args ...interface{}) {\n+\t\tlog.Errorf(ctx, format, args...)\n+\t})\n+}\n+\n+// DumpToOutFromContext is a debugging function that outputs all metrics\n+// available locally to std out,\n+// extracting the metric store from the context.\n+func DumpToOutFromContext(ctx context.Context) {\n+\tstore := GetStore(ctx)\n+\tif store == nil {\n+\t\tfmt.Printf(\"Unable to dump metrics: provided context doesn't contain metrics Store.\")\n+\t\treturn\n+\t}\n+\tDumpToOutFromStore(store)\n+}\n+\n+// DumpToOutFromStore is a debugging function that outputs all metrics\n+// available locally to std out directly from the store.\n+func DumpToOutFromStore(store *Store) {\n+\tdumperExtractor(store, func(format string, args ...interface{}) {\n+\t\tfmt.Printf(format+\"\\n\", args...)\n+\t})\n+}\n+\n+func dumperExtractor(store *Store, p func(format string, args ...interface{})) {\n+\tm := make(map[Labels]interface{})\n+\te := &Extractor{\n+\t\tSumInt64: func(l Labels, v int64) {\n+\t\t\tm[l] = &counter{value: v}\n+\t\t},\n+\t\tDistributionInt64: func(l Labels, count, sum, min, max int64) {\n+\t\t\tm[l] = &distribution{count: count, sum: sum, min: min, max: max}\n+\t\t},\n+\t\tGaugeInt64: func(l Labels, v int64, t time.Time) {\n+\t\t\tm[l] = &gauge{v: v, t: t}\n+\t\t},\n+\t}\n+\te.ExtractFrom(store)\n+\tdumpTo(m, p)\n+}\n+\n+type metricDumper struct {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4MDA5NQ=="}, "originalCommit": {"oid": "5b48bc529dbb95fcd371f45ea96b05bfd8c15c21"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcwOTc3OQ==", "bodyText": "The counterset is what's used to store the metric for bundle access, so it's accurate, but you're right that it's confusing. Rewording.", "url": "https://github.com/apache/beam/pull/10716#discussion_r373709779", "createdAt": "2020-01-31T22:16:17Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/metrics/metrics.go", "diffHunk": "@@ -144,63 +119,55 @@ func (ctx *beamCtx) String() string {\n \treturn fmt.Sprintf(\"beamCtx[%s;%s]\", ctx.bundleID, ctx.ptransformID)\n }\n \n-// SetBundleID sets the id of the current Bundle.\n+// SetBundleID sets the id of the current Bundle, and populates the store.\n func SetBundleID(ctx context.Context, id string) context.Context {\n \t// Checking for *beamCtx is an optimization, so we don't dig deeply\n \t// for ids if not necessary.\n \tif bctx, ok := ctx.(*beamCtx); ok {\n-\t\treturn &beamCtx{Context: bctx.Context, bundleID: id, bs: &perBundle{}, ptransformID: bctx.ptransformID}\n+\t\treturn &beamCtx{Context: bctx.Context, bundleID: id, store: newStore(), ptransformID: bctx.ptransformID}\n \t}\n-\treturn &beamCtx{Context: ctx, bundleID: id, bs: &perBundle{}}\n+\treturn &beamCtx{Context: ctx, bundleID: id, store: newStore()}\n }\n \n // SetPTransformID sets the id of the current PTransform.\n-// Must only be called on a context returened by SetBundleID.\n+// Must only be called on a context returned by SetBundleID.\n func SetPTransformID(ctx context.Context, id string) context.Context {\n \t// Checking for *beamCtx is an optimization, so we don't dig deeply\n \t// for ids if not necessary.\n \tif bctx, ok := ctx.(*beamCtx); ok {\n-\t\treturn &beamCtx{Context: bctx.Context, bundleID: bctx.bundleID, bs: bctx.bs, ptransformID: id}\n+\t\treturn &beamCtx{Context: bctx.Context, bundleID: bctx.bundleID, store: bctx.store, ptransformID: id}\n+\t}\n+\t// Avoid breaking if the bundle is unset in testing.\n+\treturn &beamCtx{Context: ctx, bundleID: bundleIDUnset, store: newStore(), ptransformID: id}\n+}\n+\n+// GetStore extracts the metrics Store for the given context for a bundle.\n+//\n+// Returns nil if the context doesn't contain a metric Store.\n+func GetStore(ctx context.Context) *Store {\n+\tif bctx, ok := ctx.(*beamCtx); ok {\n+\t\treturn bctx.store\n+\t}\n+\tif v := ctx.Value(storeKey); v != nil {\n+\t\treturn v.(*Store)\n \t}\n-\tpanic(fmt.Sprintf(\"SetPTransformID called before SetBundleID for %v\", id))\n-\treturn nil // never runs.\n+\treturn nil\n }\n \n const (\n \tbundleIDUnset     = \"(bundle id unset)\"\n \tptransformIDUnset = \"(ptransform id unset)\"\n )\n \n-func getContextKey(ctx context.Context, n name) key {\n-\tkey := key{name: n, bundle: bundleIDUnset, ptransform: ptransformIDUnset}\n-\tif id := ctx.Value(bundleKey); id != nil {\n-\t\tkey.bundle = id.(string)\n-\t}\n-\tif id := ctx.Value(ptransformKey); id != nil {\n-\t\tkey.ptransform = id.(string)\n-\t}\n-\treturn key\n-}\n-\n func getCounterSet(ctx context.Context) *ptCounterSet {\n-\tif id := ctx.Value(counterSetKey); id != nil {\n-\t\treturn id.(*ptCounterSet)\n+\tif bctx, ok := ctx.(*beamCtx); ok && bctx.cs != nil {\n+\t\treturn bctx.cs\n \t}\n-\t// It's not set anywhere and wasn't hoisted, so create it.\n-\tif bctx, ok := ctx.(*beamCtx); ok {\n-\t\tbctx.bs.mu.Lock()\n-\t\tcs := &ptCounterSet{\n-\t\t\tcounters:      make(map[nameHash]*counter),\n-\t\t\tdistributions: make(map[nameHash]*distribution),\n-\t\t\tgauges:        make(map[nameHash]*gauge),\n-\t\t}\n-\t\tbctx.bs.css = append(bctx.bs.css, cs)\n-\t\tbctx.cs = cs\n-\t\tbctx.bs.mu.Unlock()\n-\t\treturn cs\n+\tif set := ctx.Value(counterSetKey); set != nil {\n+\t\treturn set.(*ptCounterSet)\n \t}\n-\tpanic(\"counterSet missing, beam isn't set up properly.\")\n-\treturn nil // never runs.\n+\t// This isn't a beam context, so we can't store the metric.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5NTgwOQ=="}, "originalCommit": {"oid": "5b48bc529dbb95fcd371f45ea96b05bfd8c15c21"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcxMTU1Nw==", "bodyText": "It's more of a general comment of how do we give users programmatic access to the metrics after pipeline completion. So there's nothing wrong with the way the direct runner dumps the metrics every time. That's fine.\nWe likely need an extractor registration set up, to go along with the runner Execute registration, as in the absence of a reliable job management server, there's no common way for runners to return metrics to the users.", "url": "https://github.com/apache/beam/pull/10716#discussion_r373711557", "createdAt": "2020-01-31T22:21:59Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/runners/direct/direct.go", "diffHunk": "@@ -72,7 +72,9 @@ func Execute(ctx context.Context, p *beam.Pipeline) error {\n \tif err = plan.Down(ctx); err != nil {\n \t\treturn err\n \t}\n-\tmetrics.DumpToLog(ctx)\n+\t// TODO(lostluck) 2020/01/24: What's the right way to expose the\n+\t// metrics store for the direct runner?\n+\tmetrics.DumpToLogFromStore(ctx, plan.Store)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMxNzE4MA=="}, "originalCommit": {"oid": "5b48bc529dbb95fcd371f45ea96b05bfd8c15c21"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3280, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}