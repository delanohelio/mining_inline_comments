{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyNTczMjk5", "number": 10580, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODo0Njo1NVrODYRoSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOToxMjoxMVrODYSEOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzgxMjU2OnYy", "diffSide": "RIGHT", "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/jobsubmission/InMemoryJobService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODo0Njo1NlrOFeCobQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODo0Njo1NlrOFeCobQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0NDcxNw==", "bodyText": "This variable name should be prefixed with DEFAULT to distinguish it from maxInvocationHistory.", "url": "https://github.com/apache/beam/pull/10580#discussion_r367044717", "createdAt": "2020-01-15T18:46:56Z", "author": {"login": "ibzib"}, "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/jobsubmission/InMemoryJobService.java", "diffHunk": "@@ -72,12 +73,16 @@\n public class InMemoryJobService extends JobServiceGrpc.JobServiceImplBase implements FnService {\n   private static final Logger LOG = LoggerFactory.getLogger(InMemoryJobService.class);\n \n+  /** The default maximum number of past invocations to keep. */\n+  public static final int MAX_INVOCATION_HISTORY = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ada94bea6d1b8ee4c4b0a9f88f4c4e991eaaaac"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzgzOTM3OnYy", "diffSide": "RIGHT", "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/jobsubmission/JobServerDriver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODo1NjoyNVrOFeC5rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwODo0ODowMFrOFeR1TQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0OTEzMg==", "bodyText": "The option name should match the variable name.", "url": "https://github.com/apache/beam/pull/10580#discussion_r367049132", "createdAt": "2020-01-15T18:56:25Z", "author": {"login": "ibzib"}, "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/jobsubmission/JobServerDriver.java", "diffHunk": "@@ -97,6 +98,9 @@ protected InMemoryJobService createJobService() throws IOException {\n         handler = ExplicitBooleanOptionHandler.class)\n     private boolean cleanArtifactsPerJob = true;\n \n+    @Option(name = \"--history-size\", usage = \"The maximum number of completed invocations to keep.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ada94bea6d1b8ee4c4b0a9f88f4c4e991eaaaac"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI5Mzc3Mw==", "bodyText": "This name is user-facing and does not have to reflect the internal design decisions. The usage description could be improved:\n\n\"The maximum number of completed jobs to keep.\"", "url": "https://github.com/apache/beam/pull/10580#discussion_r367293773", "createdAt": "2020-01-16T08:48:00Z", "author": {"login": "mxm"}, "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/jobsubmission/JobServerDriver.java", "diffHunk": "@@ -97,6 +98,9 @@ protected InMemoryJobService createJobService() throws IOException {\n         handler = ExplicitBooleanOptionHandler.class)\n     private boolean cleanArtifactsPerJob = true;\n \n+    @Option(name = \"--history-size\", usage = \"The maximum number of completed invocations to keep.\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0OTEzMg=="}, "originalCommit": {"oid": "7ada94bea6d1b8ee4c4b0a9f88f4c4e991eaaaac"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2Nzg2ODIwOnYy", "diffSide": "RIGHT", "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/jobsubmission/InMemoryJobServiceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOTowNjozNVrOFeDLzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOTo0NjozM1rOFeEUMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1Mzc3Mg==", "bodyText": "Why not just i < maxInvocationHistory?", "url": "https://github.com/apache/beam/pull/10580#discussion_r367053772", "createdAt": "2020-01-15T19:06:35Z", "author": {"login": "ibzib"}, "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/jobsubmission/InMemoryJobServiceTest.java", "diffHunk": "@@ -186,7 +193,59 @@ public void testJobSubmissionUsesJobInvokerAndIsSuccess() throws Exception {\n     verify(invocation, times(1)).start();\n   }\n \n+  @Test\n+  public void testInvocationCleanup() {\n+    final JobApi.GetJobsRequest getJobsRequest = JobApi.GetJobsRequest.newBuilder().build();\n+\n+    final int maxRunningJobs = maxInvocationHistory + new Random().nextInt(50);\n+    // Store state listeners to be able to complete the invocations\n+    final List<Consumer<JobApi.JobStateEvent>> stateListeners = new ArrayList<>(maxRunningJobs);\n+\n+    for (int i = 0; i < maxRunningJobs; i++) {\n+      when(invocation.getId()).thenReturn(String.valueOf(i));\n+      prepareAndRunJob();\n+\n+      // Retrieve the state listener for this invocation\n+      ArgumentCaptor<Consumer<JobApi.JobStateEvent>> stateListener =\n+          ArgumentCaptor.forClass(Consumer.class);\n+      verify(invocation, times(i + 1)).addStateListener(stateListener.capture());\n+      stateListeners.add(stateListener.getValue());\n+\n+      // Retrieve current list of jobs\n+      RecordingObserver<JobApi.GetJobsResponse> recorder = new RecordingObserver<>();\n+      service.getJobs(getJobsRequest, recorder);\n+      assertThat(recorder.isSuccessful(), is(true));\n+\n+      // All running invocations must be available and never be discarded\n+      assertThat(recorder.getValue().getJobInfoCount(), is(i + 1));\n+    }\n+\n+    // Complete the invocations one by one and check invocation history\n+    JobApi.JobStateEvent terminalEvent =\n+        JobApi.JobStateEvent.newBuilder().setState(JobApi.JobState.Enum.DONE).build();\n+\n+    for (int i = 0; i < maxRunningJobs; i++) {\n+      // finish invocation\n+      stateListeners.get(i).accept(terminalEvent);\n+\n+      RecordingObserver<JobApi.GetJobsResponse> recorder = new RecordingObserver<>();\n+      service.getJobs(getJobsRequest, recorder);\n+\n+      // All running invocations must never be discarded but we keep a maximum number of completed\n+      // invocations\n+      int jobInfoCount = recorder.getValue().getJobInfoCount();\n+      if (i / maxInvocationHistory == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ada94bea6d1b8ee4c4b0a9f88f4c4e991eaaaac"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3MjMwNA==", "bodyText": "True. I think I was feeling funny when I wrote this.", "url": "https://github.com/apache/beam/pull/10580#discussion_r367072304", "createdAt": "2020-01-15T19:46:33Z", "author": {"login": "mxm"}, "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/jobsubmission/InMemoryJobServiceTest.java", "diffHunk": "@@ -186,7 +193,59 @@ public void testJobSubmissionUsesJobInvokerAndIsSuccess() throws Exception {\n     verify(invocation, times(1)).start();\n   }\n \n+  @Test\n+  public void testInvocationCleanup() {\n+    final JobApi.GetJobsRequest getJobsRequest = JobApi.GetJobsRequest.newBuilder().build();\n+\n+    final int maxRunningJobs = maxInvocationHistory + new Random().nextInt(50);\n+    // Store state listeners to be able to complete the invocations\n+    final List<Consumer<JobApi.JobStateEvent>> stateListeners = new ArrayList<>(maxRunningJobs);\n+\n+    for (int i = 0; i < maxRunningJobs; i++) {\n+      when(invocation.getId()).thenReturn(String.valueOf(i));\n+      prepareAndRunJob();\n+\n+      // Retrieve the state listener for this invocation\n+      ArgumentCaptor<Consumer<JobApi.JobStateEvent>> stateListener =\n+          ArgumentCaptor.forClass(Consumer.class);\n+      verify(invocation, times(i + 1)).addStateListener(stateListener.capture());\n+      stateListeners.add(stateListener.getValue());\n+\n+      // Retrieve current list of jobs\n+      RecordingObserver<JobApi.GetJobsResponse> recorder = new RecordingObserver<>();\n+      service.getJobs(getJobsRequest, recorder);\n+      assertThat(recorder.isSuccessful(), is(true));\n+\n+      // All running invocations must be available and never be discarded\n+      assertThat(recorder.getValue().getJobInfoCount(), is(i + 1));\n+    }\n+\n+    // Complete the invocations one by one and check invocation history\n+    JobApi.JobStateEvent terminalEvent =\n+        JobApi.JobStateEvent.newBuilder().setState(JobApi.JobState.Enum.DONE).build();\n+\n+    for (int i = 0; i < maxRunningJobs; i++) {\n+      // finish invocation\n+      stateListeners.get(i).accept(terminalEvent);\n+\n+      RecordingObserver<JobApi.GetJobsResponse> recorder = new RecordingObserver<>();\n+      service.getJobs(getJobsRequest, recorder);\n+\n+      // All running invocations must never be discarded but we keep a maximum number of completed\n+      // invocations\n+      int jobInfoCount = recorder.getValue().getJobInfoCount();\n+      if (i / maxInvocationHistory == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1Mzc3Mg=="}, "originalCommit": {"oid": "7ada94bea6d1b8ee4c4b0a9f88f4c4e991eaaaac"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2Nzg3OTI1OnYy", "diffSide": "RIGHT", "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/jobsubmission/InMemoryJobServiceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOToxMDozNVrOFeDSxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOTo0NToyNVrOFeESKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1NTU1Ng==", "bodyText": "There are really only two cases to test, maxRunningJobs <= maxInvocationHistory and maxRunningJobs > maxInvocationHistory. The randomness is unnecessary IMO.", "url": "https://github.com/apache/beam/pull/10580#discussion_r367055556", "createdAt": "2020-01-15T19:10:35Z", "author": {"login": "ibzib"}, "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/jobsubmission/InMemoryJobServiceTest.java", "diffHunk": "@@ -186,7 +193,59 @@ public void testJobSubmissionUsesJobInvokerAndIsSuccess() throws Exception {\n     verify(invocation, times(1)).start();\n   }\n \n+  @Test\n+  public void testInvocationCleanup() {\n+    final JobApi.GetJobsRequest getJobsRequest = JobApi.GetJobsRequest.newBuilder().build();\n+\n+    final int maxRunningJobs = maxInvocationHistory + new Random().nextInt(50);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ada94bea6d1b8ee4c4b0a9f88f4c4e991eaaaac"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3MTc4NQ==", "bodyText": "I agree, not really necessary.", "url": "https://github.com/apache/beam/pull/10580#discussion_r367071785", "createdAt": "2020-01-15T19:45:25Z", "author": {"login": "mxm"}, "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/jobsubmission/InMemoryJobServiceTest.java", "diffHunk": "@@ -186,7 +193,59 @@ public void testJobSubmissionUsesJobInvokerAndIsSuccess() throws Exception {\n     verify(invocation, times(1)).start();\n   }\n \n+  @Test\n+  public void testInvocationCleanup() {\n+    final JobApi.GetJobsRequest getJobsRequest = JobApi.GetJobsRequest.newBuilder().build();\n+\n+    final int maxRunningJobs = maxInvocationHistory + new Random().nextInt(50);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1NTU1Ng=="}, "originalCommit": {"oid": "7ada94bea6d1b8ee4c4b0a9f88f4c4e991eaaaac"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2Nzg4NDEwOnYy", "diffSide": "RIGHT", "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/jobsubmission/InMemoryJobServiceTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOToxMjoxMVrOFeDVyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMzoyNDoxN1rOFeZKkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1NjMzMQ==", "bodyText": "I'd prefer if this whole block was declarative, rather than using iteration and branching.", "url": "https://github.com/apache/beam/pull/10580#discussion_r367056331", "createdAt": "2020-01-15T19:12:11Z", "author": {"login": "ibzib"}, "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/jobsubmission/InMemoryJobServiceTest.java", "diffHunk": "@@ -186,7 +193,59 @@ public void testJobSubmissionUsesJobInvokerAndIsSuccess() throws Exception {\n     verify(invocation, times(1)).start();\n   }\n \n+  @Test\n+  public void testInvocationCleanup() {\n+    final JobApi.GetJobsRequest getJobsRequest = JobApi.GetJobsRequest.newBuilder().build();\n+\n+    final int maxRunningJobs = maxInvocationHistory + new Random().nextInt(50);\n+    // Store state listeners to be able to complete the invocations\n+    final List<Consumer<JobApi.JobStateEvent>> stateListeners = new ArrayList<>(maxRunningJobs);\n+\n+    for (int i = 0; i < maxRunningJobs; i++) {\n+      when(invocation.getId()).thenReturn(String.valueOf(i));\n+      prepareAndRunJob();\n+\n+      // Retrieve the state listener for this invocation\n+      ArgumentCaptor<Consumer<JobApi.JobStateEvent>> stateListener =\n+          ArgumentCaptor.forClass(Consumer.class);\n+      verify(invocation, times(i + 1)).addStateListener(stateListener.capture());\n+      stateListeners.add(stateListener.getValue());\n+\n+      // Retrieve current list of jobs\n+      RecordingObserver<JobApi.GetJobsResponse> recorder = new RecordingObserver<>();\n+      service.getJobs(getJobsRequest, recorder);\n+      assertThat(recorder.isSuccessful(), is(true));\n+\n+      // All running invocations must be available and never be discarded\n+      assertThat(recorder.getValue().getJobInfoCount(), is(i + 1));\n+    }\n+\n+    // Complete the invocations one by one and check invocation history\n+    JobApi.JobStateEvent terminalEvent =\n+        JobApi.JobStateEvent.newBuilder().setState(JobApi.JobState.Enum.DONE).build();\n+\n+    for (int i = 0; i < maxRunningJobs; i++) {\n+      // finish invocation\n+      stateListeners.get(i).accept(terminalEvent);\n+\n+      RecordingObserver<JobApi.GetJobsResponse> recorder = new RecordingObserver<>();\n+      service.getJobs(getJobsRequest, recorder);\n+\n+      // All running invocations must never be discarded but we keep a maximum number of completed\n+      // invocations\n+      int jobInfoCount = recorder.getValue().getJobInfoCount();\n+      if (i / maxInvocationHistory == 0) {\n+        // Less than maxInvocationHistory invocations have finished\n+        assertThat(jobInfoCount, is(maxRunningJobs));\n+      } else {\n+        // We must start to discard completed invocations to not exceed maxInvocationHistory\n+        assertThat(jobInfoCount, is(maxInvocationHistory + maxRunningJobs - i - 1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ada94bea6d1b8ee4c4b0a9f88f4c4e991eaaaac"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3MjMzOQ==", "bodyText": "Please enlighten me how to do that :)", "url": "https://github.com/apache/beam/pull/10580#discussion_r367072339", "createdAt": "2020-01-15T19:46:37Z", "author": {"login": "mxm"}, "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/jobsubmission/InMemoryJobServiceTest.java", "diffHunk": "@@ -186,7 +193,59 @@ public void testJobSubmissionUsesJobInvokerAndIsSuccess() throws Exception {\n     verify(invocation, times(1)).start();\n   }\n \n+  @Test\n+  public void testInvocationCleanup() {\n+    final JobApi.GetJobsRequest getJobsRequest = JobApi.GetJobsRequest.newBuilder().build();\n+\n+    final int maxRunningJobs = maxInvocationHistory + new Random().nextInt(50);\n+    // Store state listeners to be able to complete the invocations\n+    final List<Consumer<JobApi.JobStateEvent>> stateListeners = new ArrayList<>(maxRunningJobs);\n+\n+    for (int i = 0; i < maxRunningJobs; i++) {\n+      when(invocation.getId()).thenReturn(String.valueOf(i));\n+      prepareAndRunJob();\n+\n+      // Retrieve the state listener for this invocation\n+      ArgumentCaptor<Consumer<JobApi.JobStateEvent>> stateListener =\n+          ArgumentCaptor.forClass(Consumer.class);\n+      verify(invocation, times(i + 1)).addStateListener(stateListener.capture());\n+      stateListeners.add(stateListener.getValue());\n+\n+      // Retrieve current list of jobs\n+      RecordingObserver<JobApi.GetJobsResponse> recorder = new RecordingObserver<>();\n+      service.getJobs(getJobsRequest, recorder);\n+      assertThat(recorder.isSuccessful(), is(true));\n+\n+      // All running invocations must be available and never be discarded\n+      assertThat(recorder.getValue().getJobInfoCount(), is(i + 1));\n+    }\n+\n+    // Complete the invocations one by one and check invocation history\n+    JobApi.JobStateEvent terminalEvent =\n+        JobApi.JobStateEvent.newBuilder().setState(JobApi.JobState.Enum.DONE).build();\n+\n+    for (int i = 0; i < maxRunningJobs; i++) {\n+      // finish invocation\n+      stateListeners.get(i).accept(terminalEvent);\n+\n+      RecordingObserver<JobApi.GetJobsResponse> recorder = new RecordingObserver<>();\n+      service.getJobs(getJobsRequest, recorder);\n+\n+      // All running invocations must never be discarded but we keep a maximum number of completed\n+      // invocations\n+      int jobInfoCount = recorder.getValue().getJobInfoCount();\n+      if (i / maxInvocationHistory == 0) {\n+        // Less than maxInvocationHistory invocations have finished\n+        assertThat(jobInfoCount, is(maxRunningJobs));\n+      } else {\n+        // We must start to discard completed invocations to not exceed maxInvocationHistory\n+        assertThat(jobInfoCount, is(maxInvocationHistory + maxRunningJobs - i - 1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1NjMzMQ=="}, "originalCommit": {"oid": "7ada94bea6d1b8ee4c4b0a9f88f4c4e991eaaaac"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyMzcwMg==", "bodyText": "I was thinking we could have a small number of jobs, then finish them and check them one by one. Something like this (pseudocode):\njob[0].finish()\nassert(jobInfoCount == 4)\njob[1].finish()\nassert(jobInfoCount == 3)\n...\n\nDoing this instead of a for loop makes the test substantially easier to read. Errors also become easier to locate, because each assertion will be on its own line. If it's too verbose, we can probably factor out redundant/irrelevant code into helper methods. WDYT?", "url": "https://github.com/apache/beam/pull/10580#discussion_r367123702", "createdAt": "2020-01-15T21:45:40Z", "author": {"login": "ibzib"}, "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/jobsubmission/InMemoryJobServiceTest.java", "diffHunk": "@@ -186,7 +193,59 @@ public void testJobSubmissionUsesJobInvokerAndIsSuccess() throws Exception {\n     verify(invocation, times(1)).start();\n   }\n \n+  @Test\n+  public void testInvocationCleanup() {\n+    final JobApi.GetJobsRequest getJobsRequest = JobApi.GetJobsRequest.newBuilder().build();\n+\n+    final int maxRunningJobs = maxInvocationHistory + new Random().nextInt(50);\n+    // Store state listeners to be able to complete the invocations\n+    final List<Consumer<JobApi.JobStateEvent>> stateListeners = new ArrayList<>(maxRunningJobs);\n+\n+    for (int i = 0; i < maxRunningJobs; i++) {\n+      when(invocation.getId()).thenReturn(String.valueOf(i));\n+      prepareAndRunJob();\n+\n+      // Retrieve the state listener for this invocation\n+      ArgumentCaptor<Consumer<JobApi.JobStateEvent>> stateListener =\n+          ArgumentCaptor.forClass(Consumer.class);\n+      verify(invocation, times(i + 1)).addStateListener(stateListener.capture());\n+      stateListeners.add(stateListener.getValue());\n+\n+      // Retrieve current list of jobs\n+      RecordingObserver<JobApi.GetJobsResponse> recorder = new RecordingObserver<>();\n+      service.getJobs(getJobsRequest, recorder);\n+      assertThat(recorder.isSuccessful(), is(true));\n+\n+      // All running invocations must be available and never be discarded\n+      assertThat(recorder.getValue().getJobInfoCount(), is(i + 1));\n+    }\n+\n+    // Complete the invocations one by one and check invocation history\n+    JobApi.JobStateEvent terminalEvent =\n+        JobApi.JobStateEvent.newBuilder().setState(JobApi.JobState.Enum.DONE).build();\n+\n+    for (int i = 0; i < maxRunningJobs; i++) {\n+      // finish invocation\n+      stateListeners.get(i).accept(terminalEvent);\n+\n+      RecordingObserver<JobApi.GetJobsResponse> recorder = new RecordingObserver<>();\n+      service.getJobs(getJobsRequest, recorder);\n+\n+      // All running invocations must never be discarded but we keep a maximum number of completed\n+      // invocations\n+      int jobInfoCount = recorder.getValue().getJobInfoCount();\n+      if (i / maxInvocationHistory == 0) {\n+        // Less than maxInvocationHistory invocations have finished\n+        assertThat(jobInfoCount, is(maxRunningJobs));\n+      } else {\n+        // We must start to discard completed invocations to not exceed maxInvocationHistory\n+        assertThat(jobInfoCount, is(maxInvocationHistory + maxRunningJobs - i - 1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1NjMzMQ=="}, "originalCommit": {"oid": "7ada94bea6d1b8ee4c4b0a9f88f4c4e991eaaaac"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxMzkwNQ==", "bodyText": "Sounds reasonable. Please have a look at the updated PR.", "url": "https://github.com/apache/beam/pull/10580#discussion_r367413905", "createdAt": "2020-01-16T13:24:17Z", "author": {"login": "mxm"}, "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/jobsubmission/InMemoryJobServiceTest.java", "diffHunk": "@@ -186,7 +193,59 @@ public void testJobSubmissionUsesJobInvokerAndIsSuccess() throws Exception {\n     verify(invocation, times(1)).start();\n   }\n \n+  @Test\n+  public void testInvocationCleanup() {\n+    final JobApi.GetJobsRequest getJobsRequest = JobApi.GetJobsRequest.newBuilder().build();\n+\n+    final int maxRunningJobs = maxInvocationHistory + new Random().nextInt(50);\n+    // Store state listeners to be able to complete the invocations\n+    final List<Consumer<JobApi.JobStateEvent>> stateListeners = new ArrayList<>(maxRunningJobs);\n+\n+    for (int i = 0; i < maxRunningJobs; i++) {\n+      when(invocation.getId()).thenReturn(String.valueOf(i));\n+      prepareAndRunJob();\n+\n+      // Retrieve the state listener for this invocation\n+      ArgumentCaptor<Consumer<JobApi.JobStateEvent>> stateListener =\n+          ArgumentCaptor.forClass(Consumer.class);\n+      verify(invocation, times(i + 1)).addStateListener(stateListener.capture());\n+      stateListeners.add(stateListener.getValue());\n+\n+      // Retrieve current list of jobs\n+      RecordingObserver<JobApi.GetJobsResponse> recorder = new RecordingObserver<>();\n+      service.getJobs(getJobsRequest, recorder);\n+      assertThat(recorder.isSuccessful(), is(true));\n+\n+      // All running invocations must be available and never be discarded\n+      assertThat(recorder.getValue().getJobInfoCount(), is(i + 1));\n+    }\n+\n+    // Complete the invocations one by one and check invocation history\n+    JobApi.JobStateEvent terminalEvent =\n+        JobApi.JobStateEvent.newBuilder().setState(JobApi.JobState.Enum.DONE).build();\n+\n+    for (int i = 0; i < maxRunningJobs; i++) {\n+      // finish invocation\n+      stateListeners.get(i).accept(terminalEvent);\n+\n+      RecordingObserver<JobApi.GetJobsResponse> recorder = new RecordingObserver<>();\n+      service.getJobs(getJobsRequest, recorder);\n+\n+      // All running invocations must never be discarded but we keep a maximum number of completed\n+      // invocations\n+      int jobInfoCount = recorder.getValue().getJobInfoCount();\n+      if (i / maxInvocationHistory == 0) {\n+        // Less than maxInvocationHistory invocations have finished\n+        assertThat(jobInfoCount, is(maxRunningJobs));\n+      } else {\n+        // We must start to discard completed invocations to not exceed maxInvocationHistory\n+        assertThat(jobInfoCount, is(maxInvocationHistory + maxRunningJobs - i - 1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1NjMzMQ=="}, "originalCommit": {"oid": "7ada94bea6d1b8ee4c4b0a9f88f4c4e991eaaaac"}, "originalPosition": 106}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2356, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}