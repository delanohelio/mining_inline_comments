{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzMzc4MzI2", "number": 11610, "title": "[BEAM-9825] | Implement Intersect,Union,Except transforms", "bodyText": "Motivation:\n\nGive high level general purpose set relational algebra transforms.\nUtiltize them from BeamSQL code.\n\nImplement new high-level transforms and use them in BeamSQL code.\n\nIntersect: Compute the intersection between elements of two PCollection.\nExcept: Compute the difference between elements of two PCollection.\nUnion: Find the elements that are either of two PCollection.\n\nImplement IntersectAll, ExceptAll and UnionAll variants of transforms.\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nApex\nDataflow\nFlink\nGearpump\nSamza\nSpark\n\n\n\n\nGo\n\n---\n---\n\n---\n---\n\n\n\nJava\n\n\n\n\n\n\n\n\n\nPython\n\n---\n\n\n---\n---\n\n\n\nXLang\n---\n---\n---\n\n---\n---\n\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-05-05T08:33:35Z", "url": "https://github.com/apache/beam/pull/11610", "merged": true, "mergeCommit": {"oid": "01c11e7211937bde3c238fe3639f9dfe7774d093"}, "closed": true, "closedAt": "2020-06-02T03:54:55Z", "author": {"login": "darshanj"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcePi2TgH2gAyNDEzMzc4MzI2OmQ3Njc1ZDU3M2Q2YmYyZWMxZGI3NGZhNGUxZmMxY2UxNDM2YzExZjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcmkfSvAFqTQyMTQ2MTkwMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d7675d573d6bf2ec1db74fa4e1fc1ce1436c11f8", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/d7675d573d6bf2ec1db74fa4e1fc1ce1436c11f8", "committedDate": "2020-05-05T08:10:27Z", "message": "[BEAM-9825] | Implement Intersect,Union,Except transforms"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c39fecc44c0309096d9767c788974cdc30e974d6", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/c39fecc44c0309096d9767c788974cdc30e974d6", "committedDate": "2020-05-05T08:49:08Z", "message": "[BEAM-9825] | fix variable names"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21e83eac027f28eae007a66d031d79c06f32a07b", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/21e83eac027f28eae007a66d031d79c06f32a07b", "committedDate": "2020-05-05T12:16:39Z", "message": "[BEAM-9825] | use SetFn transforms from BeamSQL code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTY0Mjc0", "url": "https://github.com/apache/beam/pull/11610#pullrequestreview-406164274", "createdAt": "2020-05-05T21:20:53Z", "commit": {"oid": "21e83eac027f28eae007a66d031d79c06f32a07b"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMToyMDo1M1rOGQ8BDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMToyOTo1MFrOGQ8SJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxMzcwOQ==", "bodyText": "Is not Math.min(numberOfElementsinLeft, numberOfElementsinRight) sufficient?", "url": "https://github.com/apache/beam/pull/11610#discussion_r420413709", "createdAt": "2020-05-05T21:20:53Z", "author": {"login": "robertwb"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the intersection with provided\n+   * {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersect(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> intersect(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImpl<>(rightCollection, intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the intersection all with\n+   * provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection<T>}\n+   * (left) and n elements on in provided {@link PCollection<T>} (right): - it will output MIN(m -\n+   * n, 0) elements of left for all elements which are present in both left and right.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? Math.min(numberOfElementsinLeft, numberOfElementsinRight) : 0L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21e83eac027f28eae007a66d031d79c06f32a07b"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxNTU4Mw==", "bodyText": "Isn't this expression always sufficient?", "url": "https://github.com/apache/beam/pull/11610#discussion_r420415583", "createdAt": "2020-05-05T21:24:49Z", "author": {"login": "robertwb"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the intersection with provided\n+   * {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersect(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> intersect(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImpl<>(rightCollection, intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the intersection all with\n+   * provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection<T>}\n+   * (left) and n elements on in provided {@link PCollection<T>} (right): - it will output MIN(m -\n+   * n, 0) elements of left for all elements which are present in both left and right.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? Math.min(numberOfElementsinLeft, numberOfElementsinRight) : 0L;\n+    return new SetImpl<>(rightCollection, intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the difference (except) with\n+   * provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * pipeline is constructed {@link PCollection<T>} but not present in provided {@link\n+   * PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.except(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> except(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImpl<>(rightCollection, exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the difference all (exceptAll)\n+   * with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection<T>}\n+   * (left) and n elements on in provided {@link PCollection<T>} (right): - it will output m\n+   * elements of left for all elements which are present in left but not in right. - it will output\n+   * MAX(m - n, 0) elements of left for all elements which are present in both left and right.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> {\n+          if (numberOfElementsinLeft > 0 && numberOfElementsinRight == 0) {\n+            return numberOfElementsinLeft;\n+          } else if (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) {\n+            return Math.max(numberOfElementsinLeft - numberOfElementsinRight, 0L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21e83eac027f28eae007a66d031d79c06f32a07b"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxNTg4Nw==", "bodyText": "For all of these, it'd be useful to document what the expected output is.", "url": "https://github.com/apache/beam/pull/11610#discussion_r420415887", "createdAt": "2020-05-05T21:25:27Z", "author": {"login": "robertwb"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the intersection with provided\n+   * {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersect(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> intersect(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImpl<>(rightCollection, intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the intersection all with\n+   * provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection<T>}\n+   * (left) and n elements on in provided {@link PCollection<T>} (right): - it will output MIN(m -\n+   * n, 0) elements of left for all elements which are present in both left and right.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? Math.min(numberOfElementsinLeft, numberOfElementsinRight) : 0L;\n+    return new SetImpl<>(rightCollection, intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the difference (except) with\n+   * provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * pipeline is constructed {@link PCollection<T>} but not present in provided {@link\n+   * PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.except(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> except(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImpl<>(rightCollection, exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the difference all (exceptAll)\n+   * with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection<T>}\n+   * (left) and n elements on in provided {@link PCollection<T>} (right): - it will output m\n+   * elements of left for all elements which are present in left but not in right. - it will output\n+   * MAX(m - n, 0) elements of left for all elements which are present in both left and right.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> {\n+          if (numberOfElementsinLeft > 0 && numberOfElementsinRight == 0) {\n+            return numberOfElementsinLeft;\n+          } else if (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) {\n+            return Math.max(numberOfElementsinLeft - numberOfElementsinRight, 0L);\n+          }\n+          return 0L;\n+        };\n+    return new SetImpl<>(rightCollection, exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the union with provided {@code\n+   * PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * pipeline is constructed {@link PCollection<T>} and {@link PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.union(right));\n+   * }</pre>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21e83eac027f28eae007a66d031d79c06f32a07b"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxNjYwMw==", "bodyText": "Isn't this just Flatten.pcollections? (Also, isn't that more efficient?)", "url": "https://github.com/apache/beam/pull/11610#discussion_r420416603", "createdAt": "2020-05-05T21:26:50Z", "author": {"login": "robertwb"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the intersection with provided\n+   * {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersect(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> intersect(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImpl<>(rightCollection, intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the intersection all with\n+   * provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection<T>}\n+   * (left) and n elements on in provided {@link PCollection<T>} (right): - it will output MIN(m -\n+   * n, 0) elements of left for all elements which are present in both left and right.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? Math.min(numberOfElementsinLeft, numberOfElementsinRight) : 0L;\n+    return new SetImpl<>(rightCollection, intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the difference (except) with\n+   * provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * pipeline is constructed {@link PCollection<T>} but not present in provided {@link\n+   * PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.except(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> except(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImpl<>(rightCollection, exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the difference all (exceptAll)\n+   * with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection<T>}\n+   * (left) and n elements on in provided {@link PCollection<T>} (right): - it will output m\n+   * elements of left for all elements which are present in left but not in right. - it will output\n+   * MAX(m - n, 0) elements of left for all elements which are present in both left and right.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> {\n+          if (numberOfElementsinLeft > 0 && numberOfElementsinRight == 0) {\n+            return numberOfElementsinLeft;\n+          } else if (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) {\n+            return Math.max(numberOfElementsinLeft - numberOfElementsinRight, 0L);\n+          }\n+          return 0L;\n+        };\n+    return new SetImpl<>(rightCollection, exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the union with provided {@code\n+   * PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * pipeline is constructed {@link PCollection<T>} and {@link PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.union(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> union(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> unionFn = (numberOfElementsinLeft, numberOfElementsinRight) -> 1L;\n+    return new SetImpl<>(rightCollection, unionFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the unionAll with provided", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21e83eac027f28eae007a66d031d79c06f32a07b"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxNzM4NA==", "bodyText": "Though not as chain-able, a PTransform<PCollectionList<T>, PCollection<T>> feels more natural for many of these operations.", "url": "https://github.com/apache/beam/pull/11610#discussion_r420417384", "createdAt": "2020-05-05T21:28:29Z", "author": {"login": "robertwb"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21e83eac027f28eae007a66d031d79c06f32a07b"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxODA4Nw==", "bodyText": "I wonder if it's worth dropping at TODO here to lift combiners through the CoGBK.", "url": "https://github.com/apache/beam/pull/11610#discussion_r420418087", "createdAt": "2020-05-05T21:29:50Z", "author": {"login": "robertwb"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the intersection with provided\n+   * {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersect(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> intersect(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImpl<>(rightCollection, intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the intersection all with\n+   * provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection<T>}\n+   * (left) and n elements on in provided {@link PCollection<T>} (right): - it will output MIN(m -\n+   * n, 0) elements of left for all elements which are present in both left and right.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? Math.min(numberOfElementsinLeft, numberOfElementsinRight) : 0L;\n+    return new SetImpl<>(rightCollection, intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the difference (except) with\n+   * provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * pipeline is constructed {@link PCollection<T>} but not present in provided {@link\n+   * PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.except(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> except(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImpl<>(rightCollection, exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the difference all (exceptAll)\n+   * with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection<T>}\n+   * (left) and n elements on in provided {@link PCollection<T>} (right): - it will output m\n+   * elements of left for all elements which are present in left but not in right. - it will output\n+   * MAX(m - n, 0) elements of left for all elements which are present in both left and right.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> {\n+          if (numberOfElementsinLeft > 0 && numberOfElementsinRight == 0) {\n+            return numberOfElementsinLeft;\n+          } else if (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) {\n+            return Math.max(numberOfElementsinLeft - numberOfElementsinRight, 0L);\n+          }\n+          return 0L;\n+        };\n+    return new SetImpl<>(rightCollection, exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the union with provided {@code\n+   * PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * pipeline is constructed {@link PCollection<T>} and {@link PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.union(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> union(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> unionFn = (numberOfElementsinLeft, numberOfElementsinRight) -> 1L;\n+    return new SetImpl<>(rightCollection, unionFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the unionAll with provided\n+   * {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} which will follow UNION_ALL semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection<T>}\n+   * (left) and n elements on in provided {@link PCollection<T>} (right): - it will output m\n+   * elements of left and m elements of right.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.unionAll(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> unionAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> unionFn = Long::sum;\n+    return new SetImpl<>(rightCollection, unionFn);\n+  }\n+\n+  private static <T> PCollection<T> performSetOperation(\n+      PCollection<T> leftCollection,\n+      PCollection<T> rightCollection,\n+      SerializableBiFunction<Long, Long, Long> fn) {\n+\n+    TupleTag<Void> leftCollectionTag = new TupleTag<>();\n+    TupleTag<Void> rightCollectionTag = new TupleTag<>();\n+\n+    MapElements<T, KV<T, Void>> elementToVoid =\n+        MapElements.via(\n+            new SimpleFunction<T, KV<T, Void>>() {\n+              @Override\n+              public KV<T, Void> apply(T element) {\n+                return KV.of(element, null);\n+              }\n+            });\n+\n+    PCollection<KV<T, Void>> left = leftCollection.apply(\"PrepareLeftKV\", elementToVoid);\n+    PCollection<KV<T, Void>> right = rightCollection.apply(\"PrepareRightKV\", elementToVoid);\n+\n+    PCollection<KV<T, CoGbkResult>> coGbkResults =\n+        KeyedPCollectionTuple.of(leftCollectionTag, left)\n+            .and(rightCollectionTag, right)\n+            .apply(CoGroupByKey.create());\n+\n+    return coGbkResults.apply(\n+        ParDo.of(\n+            new DoFn<KV<T, CoGbkResult>, T>() {\n+\n+              @ProcessElement\n+              public void processElement(ProcessContext c) {\n+                KV<T, CoGbkResult> elementGroups = c.element();\n+\n+                CoGbkResult value = elementGroups.getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21e83eac027f28eae007a66d031d79c06f32a07b"}, "originalPosition": 234}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d96c3db06686ef543b8551b728676db190ec03d", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/6d96c3db06686ef543b8551b728676db190ec03d", "committedDate": "2020-05-06T05:42:07Z", "message": "[BEAM-9825] | fix style checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55d3fb12097fd76709b8a811dad4c8405c023008", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/55d3fb12097fd76709b8a811dad4c8405c023008", "committedDate": "2020-05-06T07:04:28Z", "message": "[BEAM-9825] | simplify conditions, output in examples"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4413b71a921016430893005b401d427d094f37e", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/c4413b71a921016430893005b401d427d094f37e", "committedDate": "2020-05-06T07:23:08Z", "message": "[BEAM-9825] | use flatten.pcollections for unionall"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a41ad545c1b48762c24adde2cedfa7264d4229b6", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/a41ad545c1b48762c24adde2cedfa7264d4229b6", "committedDate": "2020-05-08T04:10:53Z", "message": "[BEAM-9825] | rename union to unionDistinct"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56e0d63bfac4998258b6d4bc73abfd1dde435dd4", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/56e0d63bfac4998258b6d4bc73abfd1dde435dd4", "committedDate": "2020-05-08T14:49:16Z", "message": "[BEAM-9825] | both apis -WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be1d37c74d34fa01228f0bc791c2d42c634668c3", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/be1d37c74d34fa01228f0bc791c2d42c634668c3", "committedDate": "2020-05-08T16:22:55Z", "message": "[BEAM-9825] | fix spotbugs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7202a8387baeefd4def3052b27c219f75531d420", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/7202a8387baeefd4def3052b27c219f75531d420", "committedDate": "2020-05-08T17:02:14Z", "message": "[BEAM-9825] | add comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NTY0MjU2", "url": "https://github.com/apache/beam/pull/11610#pullrequestreview-408564256", "createdAt": "2020-05-08T22:36:19Z", "commit": {"oid": "56e0d63bfac4998258b6d4bc73abfd1dde435dd4"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMjozNjoxOVrOGS1ovA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMjozNjozMlrOGS1o8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNjMzMg==", "bodyText": "It'd be better to implement the binary operations in terms of n-ary operations, so that one only need to so a single [Co]GBK. The operations are the same (e.g. union -> sum or 1, intersection = min or max(min(...), 1) for all/distinct variants respectively.", "url": "https://github.com/apache/beam/pull/11610#discussion_r422406332", "createdAt": "2020-05-08T22:36:19Z", "author": {"login": "robertwb"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -187,83 +237,112 @@\n    *     left.apply(SetFns.unionAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"1\",\"2\",\"3\",\"4\",\"4\"\n    * }</pre>\n    */\n-  public static <T> SetUnionAllImpl<T> unionAll(PCollection<T> rightCollection) {\n+  public static <T> SetImpl<T> unionAll(PCollection<T> rightCollection) {\n     checkNotNull(rightCollection, \"rightCollection argument is null\");\n-\n-    return new SetUnionAllImpl<T>(rightCollection);\n+    return new SetImpl<>(rightCollection, unionAll());\n   }\n \n-  private static <T> PCollection<T> performSetOperation(\n-      PCollection<T> leftCollection,\n-      PCollection<T> rightCollection,\n-      SerializableBiFunction<Long, Long, Long> fn) {\n-\n-    TupleTag<Void> leftCollectionTag = new TupleTag<>();\n-    TupleTag<Void> rightCollectionTag = new TupleTag<>();\n-\n-    MapElements<T, KV<T, Void>> elementToVoid =\n-        MapElements.via(\n-            new SimpleFunction<T, KV<T, Void>>() {\n-              @Override\n-              public KV<T, Void> apply(T element) {\n-                return KV.of(element, null);\n-              }\n-            });\n-\n-    PCollection<KV<T, Void>> left = leftCollection.apply(\"PrepareLeftKV\", elementToVoid);\n-    PCollection<KV<T, Void>> right = rightCollection.apply(\"PrepareRightKV\", elementToVoid);\n-\n-    PCollection<KV<T, CoGbkResult>> coGbkResults =\n-        KeyedPCollectionTuple.of(leftCollectionTag, left)\n-            .and(rightCollectionTag, right)\n-            .apply(CoGroupByKey.create());\n-    // TODO: lift combiners through the CoGBK.\n-    return coGbkResults.apply(\n-        ParDo.of(\n-            new DoFn<KV<T, CoGbkResult>, T>() {\n-\n-              @ProcessElement\n-              public void processElement(ProcessContext c) {\n-                KV<T, CoGbkResult> elementGroups = c.element();\n-\n-                CoGbkResult value = elementGroups.getValue();\n-                long inFirstSize = Iterables.size(value.getAll(leftCollectionTag));\n-                long inSecondSize = Iterables.size(value.getAll(rightCollectionTag));\n-\n-                T element = elementGroups.getKey();\n-                for (long i = 0L; i < fn.apply(inFirstSize, inSecondSize); i++) {\n-                  c.output(element);\n-                }\n-              }\n-            }));\n+  public static <T> Flatten.PCollections<T> unionAll() {\n+    return Flatten.pCollections();\n   }\n \n   public static class SetImpl<T> extends PTransform<PCollection<T>, PCollection<T>> {\n-    private final PCollection<T> rightCollection;\n-    private final SerializableBiFunction<Long, Long, Long> fn;\n \n-    private SetImpl(PCollection<T> rightCollection, SerializableBiFunction<Long, Long, Long> fn) {\n-      this.rightCollection = rightCollection;\n-      this.fn = fn;\n+    private final transient PCollection<T> right;\n+    private final PTransform<PCollectionList<T>, PCollection<T>> listTransformFn;\n+\n+    private SetImpl(\n+        PCollection<T> rightCollection,\n+        PTransform<PCollectionList<T>, PCollection<T>> listTransformFn) {\n+      this.right = rightCollection;\n+      this.listTransformFn = listTransformFn;\n     }\n \n     @Override\n     public PCollection<T> expand(PCollection<T> leftCollection) {\n-      return performSetOperation(leftCollection, rightCollection, fn)\n-          .setCoder(leftCollection.getCoder());\n+      return PCollectionList.of(leftCollection).and(right).apply(listTransformFn);\n     }\n   }\n \n-  public static class SetUnionAllImpl<T> extends PTransform<PCollection<T>, PCollection<T>> {\n-    private final PCollection<T> rightCollection;\n+  public static class SetImplCollections<T> extends PTransform<PCollectionList<T>, PCollection<T>> {\n+\n+    private final transient SerializableBiFunction<Long, Long, Long> fn;\n+\n+    private SetImplCollections(SerializableBiFunction<Long, Long, Long> fn) {\n+      this.fn = fn;\n+    }\n+\n+    private static <T> PCollection<T> performSetOperationCollectionList(\n+            PCollectionList<T> inputs, SerializableBiFunction<Long, Long, Long> fn) {\n+      List<PCollection<T>> all = inputs.getAll();\n+      int size = all.size();\n+      if (size == 1) {\n+        return inputs.get(0); // Handle only one PCollection in list. Coder is already specified\n+      } else {\n+        PCollection<T> accum = inputs.get(0);\n+        List<PCollection<T>> tail = all.subList(1, size);\n \n-    private SetUnionAllImpl(PCollection<T> rightCollection) {\n-      this.rightCollection = rightCollection;\n+        for (PCollection<T> second : tail) {\n+          accum = performSetOperation(accum, second, fn);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56e0d63bfac4998258b6d4bc73abfd1dde435dd4"}, "originalPosition": 320}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNjM4NA==", "bodyText": "This is only true for the all variants, right?", "url": "https://github.com/apache/beam/pull/11610#discussion_r422406384", "createdAt": "2020-05-08T22:36:32Z", "author": {"login": "robertwb"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -187,83 +237,112 @@\n    *     left.apply(SetFns.unionAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"1\",\"2\",\"3\",\"4\",\"4\"\n    * }</pre>\n    */\n-  public static <T> SetUnionAllImpl<T> unionAll(PCollection<T> rightCollection) {\n+  public static <T> SetImpl<T> unionAll(PCollection<T> rightCollection) {\n     checkNotNull(rightCollection, \"rightCollection argument is null\");\n-\n-    return new SetUnionAllImpl<T>(rightCollection);\n+    return new SetImpl<>(rightCollection, unionAll());\n   }\n \n-  private static <T> PCollection<T> performSetOperation(\n-      PCollection<T> leftCollection,\n-      PCollection<T> rightCollection,\n-      SerializableBiFunction<Long, Long, Long> fn) {\n-\n-    TupleTag<Void> leftCollectionTag = new TupleTag<>();\n-    TupleTag<Void> rightCollectionTag = new TupleTag<>();\n-\n-    MapElements<T, KV<T, Void>> elementToVoid =\n-        MapElements.via(\n-            new SimpleFunction<T, KV<T, Void>>() {\n-              @Override\n-              public KV<T, Void> apply(T element) {\n-                return KV.of(element, null);\n-              }\n-            });\n-\n-    PCollection<KV<T, Void>> left = leftCollection.apply(\"PrepareLeftKV\", elementToVoid);\n-    PCollection<KV<T, Void>> right = rightCollection.apply(\"PrepareRightKV\", elementToVoid);\n-\n-    PCollection<KV<T, CoGbkResult>> coGbkResults =\n-        KeyedPCollectionTuple.of(leftCollectionTag, left)\n-            .and(rightCollectionTag, right)\n-            .apply(CoGroupByKey.create());\n-    // TODO: lift combiners through the CoGBK.\n-    return coGbkResults.apply(\n-        ParDo.of(\n-            new DoFn<KV<T, CoGbkResult>, T>() {\n-\n-              @ProcessElement\n-              public void processElement(ProcessContext c) {\n-                KV<T, CoGbkResult> elementGroups = c.element();\n-\n-                CoGbkResult value = elementGroups.getValue();\n-                long inFirstSize = Iterables.size(value.getAll(leftCollectionTag));\n-                long inSecondSize = Iterables.size(value.getAll(rightCollectionTag));\n-\n-                T element = elementGroups.getKey();\n-                for (long i = 0L; i < fn.apply(inFirstSize, inSecondSize); i++) {\n-                  c.output(element);\n-                }\n-              }\n-            }));\n+  public static <T> Flatten.PCollections<T> unionAll() {\n+    return Flatten.pCollections();\n   }\n \n   public static class SetImpl<T> extends PTransform<PCollection<T>, PCollection<T>> {\n-    private final PCollection<T> rightCollection;\n-    private final SerializableBiFunction<Long, Long, Long> fn;\n \n-    private SetImpl(PCollection<T> rightCollection, SerializableBiFunction<Long, Long, Long> fn) {\n-      this.rightCollection = rightCollection;\n-      this.fn = fn;\n+    private final transient PCollection<T> right;\n+    private final PTransform<PCollectionList<T>, PCollection<T>> listTransformFn;\n+\n+    private SetImpl(\n+        PCollection<T> rightCollection,\n+        PTransform<PCollectionList<T>, PCollection<T>> listTransformFn) {\n+      this.right = rightCollection;\n+      this.listTransformFn = listTransformFn;\n     }\n \n     @Override\n     public PCollection<T> expand(PCollection<T> leftCollection) {\n-      return performSetOperation(leftCollection, rightCollection, fn)\n-          .setCoder(leftCollection.getCoder());\n+      return PCollectionList.of(leftCollection).and(right).apply(listTransformFn);\n     }\n   }\n \n-  public static class SetUnionAllImpl<T> extends PTransform<PCollection<T>, PCollection<T>> {\n-    private final PCollection<T> rightCollection;\n+  public static class SetImplCollections<T> extends PTransform<PCollectionList<T>, PCollection<T>> {\n+\n+    private final transient SerializableBiFunction<Long, Long, Long> fn;\n+\n+    private SetImplCollections(SerializableBiFunction<Long, Long, Long> fn) {\n+      this.fn = fn;\n+    }\n+\n+    private static <T> PCollection<T> performSetOperationCollectionList(\n+            PCollectionList<T> inputs, SerializableBiFunction<Long, Long, Long> fn) {\n+      List<PCollection<T>> all = inputs.getAll();\n+      int size = all.size();\n+      if (size == 1) {\n+        return inputs.get(0); // Handle only one PCollection in list. Coder is already specified", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56e0d63bfac4998258b6d4bc73abfd1dde435dd4"}, "originalPosition": 312}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f9ed6fcd6fa1d07199aa02cba941f75a46bf7d3", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/3f9ed6fcd6fa1d07199aa02cba941f75a46bf7d3", "committedDate": "2020-05-09T07:37:38Z", "message": "[BEAM-9825] | use only one CBK,rename methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50042831557075d2287d033fba8ab0f94625a469", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/50042831557075d2287d033fba8ab0f94625a469", "committedDate": "2020-05-09T07:45:50Z", "message": "[BEAM-9825] | inline method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0f23e450f94756ad3a4052ff675f8f9d212b033", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/b0f23e450f94756ad3a4052ff675f8f9d212b033", "committedDate": "2020-05-09T12:00:41Z", "message": "[BEAM-9825] | added remaining tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c608a0b2445f6656ae755f54ce517b365c3cda5", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/1c608a0b2445f6656ae755f54ce517b365c3cda5", "committedDate": "2020-05-09T14:53:35Z", "message": "[BEAM-9825] | remove size check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98951f47f43951286706ef22938b94376cf61065", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/98951f47f43951286706ef22938b94376cf61065", "committedDate": "2020-05-09T15:31:43Z", "message": "[BEAM-9825] | corrected some comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMjI5ODA4", "url": "https://github.com/apache/beam/pull/11610#pullrequestreview-411229808", "createdAt": "2020-05-13T19:22:48Z", "commit": {"oid": "98951f47f43951286706ef22938b94376cf61065"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyMTg2NjY5", "url": "https://github.com/apache/beam/pull/11610#pullrequestreview-412186669", "createdAt": "2020-05-14T21:09:35Z", "commit": {"oid": "98951f47f43951286706ef22938b94376cf61065"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQyMTowOTozNlrOGVuURw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQyMTowOTozNlrOGVuURw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzMjEzNQ==", "bodyText": "We should mention in the comments that we rely on the deterministic encoding of the coder similar to how we do GroupByKey.\nAlso, this implementation assumes that there will only be a single firing of the trigger. If there are multiple then the results are likely undefined.", "url": "https://github.com/apache/beam/pull/11610#discussion_r425432135", "createdAt": "2020-05-14T21:09:36Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98951f47f43951286706ef22938b94376cf61065"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "committedDate": "2020-05-15T02:19:18Z", "message": "[BEAM-9825] | some comments, added size > 0 check"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyMzI1Njcx", "url": "https://github.com/apache/beam/pull/11610#pullrequestreview-412325671", "createdAt": "2020-05-15T03:37:23Z", "commit": {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5"}, "state": "COMMENTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzozNzoyM1rOGV1ZjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwNDoxMDoxMFrOGV12pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODE3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of {@code PCollection<T>}\n          \n          \n            \n               * Coder} as that of the input {@code PCollection<T>}.", "url": "https://github.com/apache/beam/pull/11610#discussion_r425548173", "createdAt": "2020-05-15T03:37:23Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODMxOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of first in {@code PCollectionList<T>}\n          \n          \n            \n               * Coder} as that of the first {@code PCollection<T>} in {@code PCollectionList<T>}.", "url": "https://github.com/apache/beam/pull/11610#discussion_r425548318", "createdAt": "2020-05-15T03:38:05Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODM0MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n          \n          \n            \n               * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing the", "url": "https://github.com/apache/beam/pull/11610#discussion_r425548341", "createdAt": "2020-05-15T03:38:12Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODU4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of first in {@code PCollectionList<T>}\n          \n          \n            \n               * Coder} as that of the first {@code PCollection<T>} in {@code PCollectionList<T>}.", "url": "https://github.com/apache/beam/pull/11610#discussion_r425548587", "createdAt": "2020-05-15T03:39:34Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODY1Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of first in {@code PCollectionList<T>}\n          \n          \n            \n               * Coder} as that of the first {@code PCollection<T>} in {@code PCollectionList<T>}.", "url": "https://github.com/apache/beam/pull/11610#discussion_r425548653", "createdAt": "2020-05-15T03:39:54Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectAll()); // results will be PCollection<String> containing: \"1\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectAll() {\n+    return new SetImplCollections<>(Math::min);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * difference (except) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed but not present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptDistinct(right)); // results will be PCollection<String> containing: \"2\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing difference (except) of collections done in order for all\n+   * collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * difference (except) of collections done in order for all collections in {@code\n+   * PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed but not present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5"}, "originalPosition": 261}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODgzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of {@code PCollection<T>}\n          \n          \n            \n               * Coder} as that of the input {@code PCollection<T>}.", "url": "https://github.com/apache/beam/pull/11610#discussion_r425548837", "createdAt": "2020-05-15T03:40:41Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODg3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of {@code PCollection<T>}\n          \n          \n            \n               * Coder} as that of the input {@code PCollection<T>}.", "url": "https://github.com/apache/beam/pull/11610#discussion_r425548873", "createdAt": "2020-05-15T03:40:53Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectAll()); // results will be PCollection<String> containing: \"1\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectAll() {\n+    return new SetImplCollections<>(Math::min);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * difference (except) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed but not present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODkxNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of {@code PCollection<T>}\n          \n          \n            \n               * Coder} as that of the input {@code PCollection<T>}.", "url": "https://github.com/apache/beam/pull/11610#discussion_r425548915", "createdAt": "2020-05-15T03:41:05Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectAll()); // results will be PCollection<String> containing: \"1\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectAll() {\n+    return new SetImplCollections<>(Math::min);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * difference (except) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed but not present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptDistinct(right)); // results will be PCollection<String> containing: \"2\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing difference (except) of collections done in order for all\n+   * collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * difference (except) of collections done in order for all collections in {@code\n+   * PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed but not present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"2\",\"2\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptDistinct()); // results will be PCollection<String> containing: \"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptDistinct() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * difference all (exceptAll) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * for all elements which are present in left but not in right. - it will output MAX(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODk1Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of {@code PCollection<T>}\n          \n          \n            \n               * Coder} as that of the input {@code PCollection<T>}.", "url": "https://github.com/apache/beam/pull/11610#discussion_r425548953", "createdAt": "2020-05-15T03:41:18Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectAll()); // results will be PCollection<String> containing: \"1\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectAll() {\n+    return new SetImplCollections<>(Math::min);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * difference (except) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed but not present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptDistinct(right)); // results will be PCollection<String> containing: \"2\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing difference (except) of collections done in order for all\n+   * collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * difference (except) of collections done in order for all collections in {@code\n+   * PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed but not present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"2\",\"2\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptDistinct()); // results will be PCollection<String> containing: \"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptDistinct() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * difference all (exceptAll) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * for all elements which are present in left but not in right. - it will output MAX(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"2\",\"3\",\"3\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing difference all\n+   * (exceptAll) of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output m elements of left for all elements which are present in left but not in right. - it\n+   * will output MAX(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptAll()); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"3\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptAll() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            Math.max(numberOfElementsinLeft - numberOfElementsinRight, 0L);\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * union with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed or present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODk4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of {@code PCollection<T>}\n          \n          \n            \n               * Coder} as that of the input {@code PCollection<T>}.", "url": "https://github.com/apache/beam/pull/11610#discussion_r425548985", "createdAt": "2020-05-15T03:41:31Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectAll()); // results will be PCollection<String> containing: \"1\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectAll() {\n+    return new SetImplCollections<>(Math::min);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * difference (except) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed but not present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptDistinct(right)); // results will be PCollection<String> containing: \"2\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing difference (except) of collections done in order for all\n+   * collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * difference (except) of collections done in order for all collections in {@code\n+   * PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed but not present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"2\",\"2\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptDistinct()); // results will be PCollection<String> containing: \"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptDistinct() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * difference all (exceptAll) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * for all elements which are present in left but not in right. - it will output MAX(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"2\",\"3\",\"3\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing difference all\n+   * (exceptAll) of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output m elements of left for all elements which are present in left but not in right. - it\n+   * will output MAX(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptAll()); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"3\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptAll() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            Math.max(numberOfElementsinLeft - numberOfElementsinRight, 0L);\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * union with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed or present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"2\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.unionDistinct(right)); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> unionDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, unionDistinct());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing union\n+   * of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed or present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"2\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.unionDistinct()); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"4\",\"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> unionDistinct() {\n+    SerializableBiFunction<Long, Long, Long> unionFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> 1L;\n+    return new SetImplCollections<>(unionFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * unionAll with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow UNION_ALL semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * and m elements of right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5"}, "originalPosition": 468}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0OTI1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of first in {@code PCollectionList<T>}\n          \n          \n            \n               * Coder} as that of the first {@code PCollection<T>} in {@code PCollectionList<T>}.", "url": "https://github.com/apache/beam/pull/11610#discussion_r425549254", "createdAt": "2020-05-15T03:42:32Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectAll()); // results will be PCollection<String> containing: \"1\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectAll() {\n+    return new SetImplCollections<>(Math::min);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * difference (except) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed but not present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptDistinct(right)); // results will be PCollection<String> containing: \"2\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing difference (except) of collections done in order for all\n+   * collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * difference (except) of collections done in order for all collections in {@code\n+   * PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed but not present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"2\",\"2\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptDistinct()); // results will be PCollection<String> containing: \"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptDistinct() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * difference all (exceptAll) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * for all elements which are present in left but not in right. - it will output MAX(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"2\",\"3\",\"3\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing difference all\n+   * (exceptAll) of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output m elements of left for all elements which are present in left but not in right. - it\n+   * will output MAX(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5"}, "originalPosition": 346}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0OTMxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of first in {@code PCollectionList<T>}\n          \n          \n            \n               * Coder} as that of the first {@code PCollection<T>} in {@code PCollectionList<T>}.", "url": "https://github.com/apache/beam/pull/11610#discussion_r425549316", "createdAt": "2020-05-15T03:42:44Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectAll()); // results will be PCollection<String> containing: \"1\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectAll() {\n+    return new SetImplCollections<>(Math::min);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * difference (except) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed but not present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptDistinct(right)); // results will be PCollection<String> containing: \"2\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing difference (except) of collections done in order for all\n+   * collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * difference (except) of collections done in order for all collections in {@code\n+   * PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed but not present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"2\",\"2\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptDistinct()); // results will be PCollection<String> containing: \"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptDistinct() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * difference all (exceptAll) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * for all elements which are present in left but not in right. - it will output MAX(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"2\",\"3\",\"3\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing difference all\n+   * (exceptAll) of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output m elements of left for all elements which are present in left but not in right. - it\n+   * will output MAX(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptAll()); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"3\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptAll() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            Math.max(numberOfElementsinLeft - numberOfElementsinRight, 0L);\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * union with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed or present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"2\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.unionDistinct(right)); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> unionDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, unionDistinct());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing union\n+   * of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed or present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5"}, "originalPosition": 424}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0OTQwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of first in {@code PCollectionList<T>}\n          \n          \n            \n               * Coder} as that of the first {@code PCollection<T>} in {@code PCollectionList<T>}.", "url": "https://github.com/apache/beam/pull/11610#discussion_r425549406", "createdAt": "2020-05-15T03:42:56Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectAll()); // results will be PCollection<String> containing: \"1\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectAll() {\n+    return new SetImplCollections<>(Math::min);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * difference (except) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed but not present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptDistinct(right)); // results will be PCollection<String> containing: \"2\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing difference (except) of collections done in order for all\n+   * collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * difference (except) of collections done in order for all collections in {@code\n+   * PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed but not present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"2\",\"2\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptDistinct()); // results will be PCollection<String> containing: \"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptDistinct() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * difference all (exceptAll) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * for all elements which are present in left but not in right. - it will output MAX(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"2\",\"3\",\"3\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing difference all\n+   * (exceptAll) of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output m elements of left for all elements which are present in left but not in right. - it\n+   * will output MAX(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptAll()); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"3\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptAll() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            Math.max(numberOfElementsinLeft - numberOfElementsinRight, 0L);\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * union with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed or present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"2\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.unionDistinct(right)); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> unionDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, unionDistinct());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing union\n+   * of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed or present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"2\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.unionDistinct()); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"4\",\"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> unionDistinct() {\n+    SerializableBiFunction<Long, Long, Long> unionFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> 1L;\n+    return new SetImplCollections<>(unionFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * unionAll with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow UNION_ALL semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * and m elements of right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"2\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.unionAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"1\",\"2\",\"3\",\"4\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> unionAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, unionAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing unionAll of\n+   * collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow UNION_ALL semantics. Output\n+   * is calculated as follows: Given there are m elements on pipeline which is constructed {@link\n+   * PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will output\n+   * m elements of left and m elements of right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all inputs {@code\n+   * PCollection<T>} to be deterministic (see {@link Coder#verifyDeterministic()}). If the\n+   * collection {@code Coder} is not deterministic, an exception is thrown at pipeline construction\n+   * time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5"}, "originalPosition": 506}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1MDc1MA==", "bodyText": "How about we rename the class to be Sets", "url": "https://github.com/apache/beam/pull/11610#discussion_r425550750", "createdAt": "2020-05-15T03:48:59Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1MTUzNw==", "bodyText": "nit: spacing here and elsewhere in the examples.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"2\"));\n          \n          \n            \n               * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n          \n          \n            \n               * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n          \n          \n            \n               * PCollection<String> first = p.apply(Create.of(\"1\", \"1\", \"2\"));\n          \n          \n            \n               * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\", \"4\"));\n          \n          \n            \n               * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));", "url": "https://github.com/apache/beam/pull/11610#discussion_r425551537", "createdAt": "2020-05-15T03:52:09Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectAll()); // results will be PCollection<String> containing: \"1\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectAll() {\n+    return new SetImplCollections<>(Math::min);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * difference (except) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed but not present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptDistinct(right)); // results will be PCollection<String> containing: \"2\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing difference (except) of collections done in order for all\n+   * collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * difference (except) of collections done in order for all collections in {@code\n+   * PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed but not present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"2\",\"2\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptDistinct()); // results will be PCollection<String> containing: \"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptDistinct() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * difference all (exceptAll) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * for all elements which are present in left but not in right. - it will output MAX(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"2\",\"3\",\"3\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing difference all\n+   * (exceptAll) of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output m elements of left for all elements which are present in left but not in right. - it\n+   * will output MAX(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptAll()); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"3\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptAll() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            Math.max(numberOfElementsinLeft - numberOfElementsinRight, 0L);\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * union with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed or present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"2\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.unionDistinct(right)); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> unionDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, unionDistinct());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing union\n+   * of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed or present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"2\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.unionDistinct()); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"4\",\"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> unionDistinct() {\n+    SerializableBiFunction<Long, Long, Long> unionFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> 1L;\n+    return new SetImplCollections<>(unionFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * unionAll with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow UNION_ALL semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * and m elements of right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"2\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.unionAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"1\",\"2\",\"3\",\"4\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> unionAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, unionAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing unionAll of\n+   * collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow UNION_ALL semantics. Output\n+   * is calculated as follows: Given there are m elements on pipeline which is constructed {@link\n+   * PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will output\n+   * m elements of left and m elements of right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all inputs {@code\n+   * PCollection<T>} to be deterministic (see {@link Coder#verifyDeterministic()}). If the\n+   * collection {@code Coder} is not deterministic, an exception is thrown at pipeline construction\n+   * time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"2\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5"}, "originalPosition": 512}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1NDkwMw==", "bodyText": "Since SetImpl and SetImplCollection are private classes, users won't be able to assign them to a local variable without converting it to a PTransform which most IDEs won't do for you automatically. Was this your intent?\nIn other transforms we have made these kinds of classes public but they are usually specific to what they do, so in this case we would have a UnionAll/Intersect/IntersectAll/Distinct/DistinctAll/... PTransform that was public that had whatever internal implementation you want. The alternative would be to return PTransform<PCollection, PCollection> which seems ok.", "url": "https://github.com/apache/beam/pull/11610#discussion_r425554903", "createdAt": "2020-05-15T04:06:38Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectAll()); // results will be PCollection<String> containing: \"1\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectAll() {\n+    return new SetImplCollections<>(Math::min);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * difference (except) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed but not present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptDistinct(right)); // results will be PCollection<String> containing: \"2\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing difference (except) of collections done in order for all\n+   * collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * difference (except) of collections done in order for all collections in {@code\n+   * PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed but not present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"2\",\"2\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptDistinct()); // results will be PCollection<String> containing: \"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptDistinct() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * difference all (exceptAll) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * for all elements which are present in left but not in right. - it will output MAX(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"2\",\"3\",\"3\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5"}, "originalPosition": 321}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1NTQ5OA==", "bodyText": "Note, we already have a Distinct transform with some additional capabilities over what we have here but it currently requires users to flatten/merge their PCollections into a single PCollection already.\n@robertwb any suggestions on what to do here? (having very similar but duplicated functionality seems like bloat)", "url": "https://github.com/apache/beam/pull/11610#discussion_r425555498", "createdAt": "2020-05-15T04:09:39Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1NTYyMw==", "bodyText": "A simple class comment would help people reading the javadoc as to what kinds of transforms are contained in this class.", "url": "https://github.com/apache/beam/pull/11610#discussion_r425555623", "createdAt": "2020-05-15T04:10:10Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "910ba2f551abc8e12d48253230cfe9bd597173fc", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/910ba2f551abc8e12d48253230cfe9bd597173fc", "committedDate": "2020-05-15T09:43:54Z", "message": "[BEAM-9825] | rename to sets, some comments, check size > 1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e68e81a7d58e59e4f7fbb051deb0b1efac41ce8", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/9e68e81a7d58e59e4f7fbb051deb0b1efac41ce8", "committedDate": "2020-05-18T12:35:37Z", "message": "[BEAM-9825] | change return value to PTransform"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNDYxOTAy", "url": "https://github.com/apache/beam/pull/11610#pullrequestreview-421461902", "createdAt": "2020-05-31T05:05:58Z", "commit": {"oid": "9e68e81a7d58e59e4f7fbb051deb0b1efac41ce8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4856, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}