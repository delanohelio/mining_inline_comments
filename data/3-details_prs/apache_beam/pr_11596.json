{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyMzg2NDMz", "number": 11596, "title": "[BEAM-9856] Optimization/hl7v2 io list messages", "bodyText": "This PR is an experiment to illustrate a potential strategy for implementing HL7v2IO.ListMessages as a splittable DoFn that carves the sendTime dimension up into time ranges and uses the Messages.List API with filter on sendTime and orderBy sendTime (to make lists monotonically increasing).\nCurrently this initial split is daily and the hope is to leave dynamic splits are left up to the existing implementaion in OffsetRangeTracker\nDISCLAIMER\nThis PR is currently a discussion piece to help drive the decision of the future of HL7v2IO.ListMessages.\nIt has excessive logging for demonstrating behavior / debugging and is currently broken.\nCC: @pabloem, @lukecwik\nQuestions\n\nWhat are the prototypical tests for validating splitable DoFn's various methods (e.g. SplitRestriction) stability?\nAre there best practices in optimizing inital split? In this case it's impossible to know a head of time how many messages.\nIs there a max recommended initial splitting? For example 100s or 1000s of splits preferrable? For IO connectors I imagine it depends what the QPS limits are of your source/target system are.\nShould I add adaptive throttling similar to DatastoreIO as we are introducing much more parallelism? Are there other methods in splitable dofns for rate limiting requests or indicating that runner can split until you have n currently active splits?\n\nCurrent Status: Working\nStole a lot from OffsetRangetTracker to implement OrderedTimeRageTracker a restriction tracker that assumes that local results sets are ordered by timestamp.\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nApex\nDataflow\nFlink\nGearpump\nSamza\nSpark\n\n\n\n\nGo\n\n---\n---\n\n---\n---\n\n\n\nJava\n\n\n\n\n\n\n\n\n\nPython\n\n---\n\n\n---\n---\n\n\n\nXLang\n---\n---\n---\n\n---\n---\n\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-05-02T02:22:19Z", "url": "https://github.com/apache/beam/pull/11596", "merged": true, "mergeCommit": {"oid": "ef2136b6727e3c0d1f67dd0aee957e54f852ee00"}, "closed": true, "closedAt": "2020-05-20T18:58:36Z", "author": {"login": "jaketf"}, "timelineItems": {"totalCount": 37, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcc1LaqAH2gAyNDEyMzg2NDMzOjAxMTE1NGQ1MTY4ZjFiNmU4YzhjMzhiNzk2ODBhNThmYWRkMmU2NTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcjLbT0gH2gAyNDEyMzg2NDMzOmFkNTcxMTFlNGZmNTlmMTIxNzUyMDU2NmQ5OGRhMDFjYTNkOGUzOTA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "011154d5168f1b6e8c8c38b79680a58fadd2e657", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/011154d5168f1b6e8c8c38b79680a58fadd2e657", "committedDate": "2020-04-30T22:53:24Z", "message": "pre-work send time bound convenience functions for\n\nBEAM-9856"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "209b6191b6d1e64c15e0a3c9d2f67cb1a3c51ee8", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/209b6191b6d1e64c15e0a3c9d2f67cb1a3c51ee8", "committedDate": "2020-05-02T01:44:15Z", "message": "WIP splitable DoFn for message listing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2051f24d92601c5bcfbcc23e7f8b1ec8e554880", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/b2051f24d92601c5bcfbcc23e7f8b1ec8e554880", "committedDate": "2020-05-02T02:20:31Z", "message": "wip HL7v2IO.ListMessages splittable dofn POC"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3289835d2c841e18a92c898da9fa8f3401bbf006", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/3289835d2c841e18a92c898da9fa8f3401bbf006", "committedDate": "2020-05-04T23:29:40Z", "message": "slow but working"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "810c84bb3759cf9813615376c1c4c4e4593c3357", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/810c84bb3759cf9813615376c1c4c4e4593c3357", "committedDate": "2020-05-05T01:26:19Z", "message": "handle corner cases, improve javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a340017097a5443fc11d64865f8b3aaff1e6719e", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/a340017097a5443fc11d64865f8b3aaff1e6719e", "committedDate": "2020-05-05T01:28:19Z", "message": "remove OffsetRangeTracker changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "889129284b41eec6027f12fcb1ecae0e82bbd034", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/889129284b41eec6027f12fcb1ecae0e82bbd034", "committedDate": "2020-05-05T01:34:03Z", "message": "add null check on lastAttemptedOffset in checkDone"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2a094d5a133132d015fc7ed335e5b430a19f183", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/d2a094d5a133132d015fc7ed335e5b430a19f183", "committedDate": "2020-05-06T18:51:19Z", "message": "clean up"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3Nzg5Njc3", "url": "https://github.com/apache/beam/pull/11596#pullrequestreview-407789677", "createdAt": "2020-05-07T19:55:06Z", "commit": {"oid": "d2a094d5a133132d015fc7ed335e5b430a19f183"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxOTo1NTowNlrOGSN-HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMDowNTo0MFrOGSOVEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1NjQ0NQ==", "bodyText": "why not use the offset range tracker and convert time to long?", "url": "https://github.com/apache/beam/pull/11596#discussion_r421756445", "createdAt": "2020-05-07T19:55:06Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/OrderedTimeRange.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms.splittabledofn;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.CoderException;\n+import org.apache.beam.sdk.coders.InstantCoder;\n+import org.apache.beam.sdk.util.VarInt;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Objects;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+\n+/** A restriction represented by a range of Instants [from, to). */\n+public class OrderedTimeRange", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a094d5a133132d015fc7ed335e5b430a19f183"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1NzgxNQ==", "bodyText": "Please make this a seperate PR and add a test that covers this case to the OffsetRangeTrackerTest\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (lastAttemptedOffset == null) {\n          \n          \n            \n                  throw new IllegalStateException(\"lastAttemptedOffset should not be null\");\n          \n          \n            \n                }\n          \n          \n            \n                checkState(\n          \n          \n            \n                    lastAttemptedOffset >= range.getTo() - 1,\n          \n          \n            \n                    \"Last attempted offset was %s in range %s, claiming work in [%s, %s) was not attempted\",\n          \n          \n            \n                checkState(\n          \n          \n            \n                    lastAttemptedOffset != null && lastAttemptedOffset >= range.getTo() - 1,\n          \n          \n            \n                    \"Last attempted offset was %s in range %s, claiming work in [%s, %s) was not attempted\",", "url": "https://github.com/apache/beam/pull/11596#discussion_r421757815", "createdAt": "2020-05-07T19:57:27Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/OffsetRangeTracker.java", "diffHunk": "@@ -94,6 +94,9 @@ public void checkDone() throws IllegalStateException {\n     if (range.getFrom() == range.getTo()) {\n       return;\n     }\n+    if (lastAttemptedOffset == null) {\n+      throw new IllegalStateException(\"lastAttemptedOffset should not be null\");\n+    }\n     checkState(\n         lastAttemptedOffset >= range.getTo() - 1,\n         \"Last attempted offset was %s in range %s, claiming work in [%s, %s) was not attempted\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a094d5a133132d015fc7ed335e5b430a19f183"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2MjMyMw==", "bodyText": "Typically, doing one split for every 64mbs of output has been our guidance here in the past.\nDynamic splitting is meant to fill in the gap if there is too little splitting or a specific restriction has a lot more data then other restrictions.", "url": "https://github.com/apache/beam/pull/11596#discussion_r421762323", "createdAt": "2020-05-07T20:05:40Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -472,24 +548,120 @@ public void initClient() throws IOException {\n       this.client = new HttpHealthcareApiClient();\n     }\n \n+    @GetInitialRestriction\n+    public OrderedTimeRange getEarliestToLatestRestriction(@Element String hl7v2Store)\n+        throws IOException {\n+      from = this.client.getEarliestHL7v2SendTime(hl7v2Store, this.filter);\n+      // filters are [from, to) to match logic of OffsetRangeTracker but need latest element to be\n+      // included in results set to add an extra ms to the upper bound.\n+      to = this.client.getLatestHL7v2SendTime(hl7v2Store, this.filter).plus(1);\n+      return new OrderedTimeRange(from, to);\n+    }\n+\n+    @NewTracker\n+    public OrderedTimeRangeTracker newTracker(@Restriction OrderedTimeRange timeRange) {\n+      return timeRange.newTracker();\n+    }\n+\n+    @SplitRestriction\n+    public void split(\n+        @Restriction OrderedTimeRange timeRange, OutputReceiver<OrderedTimeRange> out) {\n+      // TODO(jaketf) How to pick optimal values for desiredNumOffsetsPerSplit ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a094d5a133132d015fc7ed335e5b430a19f183"}, "originalPosition": 173}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f08f0d790500552068f7ca922b2ccde5bcd03f3", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/3f08f0d790500552068f7ca922b2ccde5bcd03f3", "committedDate": "2020-05-09T00:15:19Z", "message": "remove OrderedTimeRangeTracker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33a6f895de1374028239845ad9fe3d2cbf6369e3", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/33a6f895de1374028239845ad9fe3d2cbf6369e3", "committedDate": "2020-05-12T03:19:18Z", "message": "Revert changes that were moved to #11648"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8859e7ff7770c5965e3eea18e0b0da5e4fe3d9c", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/e8859e7ff7770c5965e3eea18e0b0da5e4fe3d9c", "committedDate": "2020-05-12T18:07:03Z", "message": "remove todo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NzA3MDc1", "url": "https://github.com/apache/beam/pull/11596#pullrequestreview-414707075", "createdAt": "2020-05-19T18:17:56Z", "commit": {"oid": "e8859e7ff7770c5965e3eea18e0b0da5e4fe3d9c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODoxNzo1NlrOGXs6vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODoxNzo1NlrOGXs6vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwNjM2Ng==", "bodyText": "ValueProvider arguments are usually not known at pipeline construction time, so it is not useful to call get on them when you create the PCollection. The usual method is to have ValueProvider attributes for the class - when you get String arguments, you would wrap them with StaticValueProvider - and in the execution-time methods (e.g. processelement, finish/startbundle), you would call get on the valueproviders. I seem to have missed this point earlier. sorry about that.", "url": "https://github.com/apache/beam/pull/11596#discussion_r427506366", "createdAt": "2020-05-19T18:17:56Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -431,25 +455,70 @@ private Message fetchMessage(HealthcareApiClient client, String msgId)\n       this.filter = filter.get();\n     }\n \n+    /**\n+     * Instantiates a new List hl 7 v 2 messages.\n+     *\n+     * @param hl7v2Stores the hl 7 v 2 stores\n+     * @param filter the filter\n+     * @param initialSplitDuration the initial split duration for sendTime dimension splits\n+     */\n+    ListHL7v2Messages(\n+        ValueProvider<List<String>> hl7v2Stores,\n+        ValueProvider<String> filter,\n+        Duration initialSplitDuration) {\n+      this.hl7v2Stores = hl7v2Stores.get();\n+      this.filter = filter.get();\n+      this.initialSplitDuration = initialSplitDuration;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8859e7ff7770c5965e3eea18e0b0da5e4fe3d9c"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NzMwNzg2", "url": "https://github.com/apache/beam/pull/11596#pullrequestreview-414730786", "createdAt": "2020-05-19T18:49:52Z", "commit": {"oid": "e8859e7ff7770c5965e3eea18e0b0da5e4fe3d9c"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODo0OTo1M1rOGXuFNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODo1NDoxOFrOGXuO7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyNTQyOQ==", "bodyText": "Would we output the first message twice?\nin the first iteration, msg = page.get(0), from line 616\nin the second iteration, msg = page.get(i++) - which is still 0, and then i is incremented?\nYou could use ++i, but then you would have to adjust the condition in the while loop, right?", "url": "https://github.com/apache/beam/pull/11596#discussion_r427525429", "createdAt": "2020-05-19T18:49:53Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -472,24 +547,118 @@ public void initClient() throws IOException {\n       this.client = new HttpHealthcareApiClient();\n     }\n \n+    @GetInitialRestriction\n+    public OffsetRange getEarliestToLatestRestriction(@Element String hl7v2Store)\n+        throws IOException {\n+      from = this.client.getEarliestHL7v2SendTime(hl7v2Store, this.filter);\n+      // filters are [from, to) to match logic of OffsetRangeTracker but need latest element to be\n+      // included in results set to add an extra ms to the upper bound.\n+      to = this.client.getLatestHL7v2SendTime(hl7v2Store, this.filter).plus(1);\n+      return new OffsetRange(from.getMillis(), to.getMillis());\n+    }\n+\n+    @NewTracker\n+    public OffsetRangeTracker newTracker(@Restriction OffsetRange timeRange) {\n+      return timeRange.newTracker();\n+    }\n+\n+    @SplitRestriction\n+    public void split(@Restriction OffsetRange timeRange, OutputReceiver<OffsetRange> out) {\n+      List<OffsetRange> splits =\n+          timeRange.split(initialSplitDuration.getMillis(), DEFAULT_MIN_SPLIT_DURATION.getMillis());\n+      Instant from = Instant.ofEpochMilli(timeRange.getFrom());\n+      Instant to = Instant.ofEpochMilli(timeRange.getTo());\n+      Duration totalDuration = new Duration(from, to);\n+      LOG.info(\n+          String.format(\n+              \"splitting initial sendTime restriction of [minSendTime, now): [%s,%s), \"\n+                  + \"or [%s, %s). \\n\"\n+                  + \"total days: %s \\n\"\n+                  + \"into %s splits. \\n\"\n+                  + \"Last split: %s\",\n+              from,\n+              to,\n+              timeRange.getFrom(),\n+              timeRange.getTo(),\n+              totalDuration.getStandardDays(),\n+              splits.size(),\n+              splits.get(splits.size() - 1).toString()));\n+\n+      for (OffsetRange s : splits) {\n+        out.output(s);\n+      }\n+    }\n+\n     /**\n      * List messages.\n      *\n-     * @param context the context\n+     * @param hl7v2Store the HL7v2 store to list messages from\n      * @throws IOException the io exception\n      */\n     @ProcessElement\n-    public void listMessages(ProcessContext context) throws IOException {\n-      String hl7v2Store = context.element();\n-      // Output all elements of all pages.\n+    public void listMessages(\n+        @Element String hl7v2Store,\n+        RestrictionTracker tracker,\n+        OutputReceiver<HL7v2Message> outputReceiver)\n+        throws IOException {\n+      OffsetRange currentRestriction = (OffsetRange) tracker.currentRestriction();\n+      Instant startRestriction = Instant.ofEpochMilli(currentRestriction.getFrom());\n+      Instant endRestriction = Instant.ofEpochMilli(currentRestriction.getTo());\n       HttpHealthcareApiClient.HL7v2MessagePages pages =\n-          new HttpHealthcareApiClient.HL7v2MessagePages(client, hl7v2Store, this.filter);\n+          new HttpHealthcareApiClient.HL7v2MessagePages(\n+              client, hl7v2Store, startRestriction, endRestriction, filter, \"sendTime\");\n       long reqestTime = Instant.now().getMillis();\n-      for (Stream<HL7v2Message> page : pages) {\n+      long lastClaimedMilliSecond;\n+      Instant cursor;\n+      boolean hangingClaim = false; // flag if the claimed ms spans spills over to the next page.\n+      for (List<HL7v2Message> page : pages) { // loop over pages.\n+        int i = 0;\n+        HL7v2Message msg = page.get(i);\n+        while (i < page.size()) { // loop over messages in page\n+          cursor = Instant.parse(msg.getSendTime());\n+          lastClaimedMilliSecond = cursor.getMillis();\n+          LOG.info(\n+              String.format(\n+                  \"initial claim for page %s lastClaimedMilliSecond = %s\",\n+                  i, lastClaimedMilliSecond));\n+          if (hangingClaim || tracker.tryClaim(lastClaimedMilliSecond)) {\n+            // This means we have claimed an entire millisecond we need to make sure that we\n+            // process all messages for this millisecond because sendTime is allegedly nano second\n+            // resolution.\n+            // https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.hl7V2Stores.messages#Message\n+            while (cursor.getMillis() == lastClaimedMilliSecond\n+                && i < page.size()) { // loop over messages in millisecond.\n+              outputReceiver.output(msg);\n+              msg = page.get(i++);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8859e7ff7770c5965e3eea18e0b0da5e4fe3d9c"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyNzkxOA==", "bodyText": "I don't know the API requirements, but you would be calling tryClaim twice on a milliSecond? Once in line 645, and once more here?", "url": "https://github.com/apache/beam/pull/11596#discussion_r427527918", "createdAt": "2020-05-19T18:54:18Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -472,24 +547,118 @@ public void initClient() throws IOException {\n       this.client = new HttpHealthcareApiClient();\n     }\n \n+    @GetInitialRestriction\n+    public OffsetRange getEarliestToLatestRestriction(@Element String hl7v2Store)\n+        throws IOException {\n+      from = this.client.getEarliestHL7v2SendTime(hl7v2Store, this.filter);\n+      // filters are [from, to) to match logic of OffsetRangeTracker but need latest element to be\n+      // included in results set to add an extra ms to the upper bound.\n+      to = this.client.getLatestHL7v2SendTime(hl7v2Store, this.filter).plus(1);\n+      return new OffsetRange(from.getMillis(), to.getMillis());\n+    }\n+\n+    @NewTracker\n+    public OffsetRangeTracker newTracker(@Restriction OffsetRange timeRange) {\n+      return timeRange.newTracker();\n+    }\n+\n+    @SplitRestriction\n+    public void split(@Restriction OffsetRange timeRange, OutputReceiver<OffsetRange> out) {\n+      List<OffsetRange> splits =\n+          timeRange.split(initialSplitDuration.getMillis(), DEFAULT_MIN_SPLIT_DURATION.getMillis());\n+      Instant from = Instant.ofEpochMilli(timeRange.getFrom());\n+      Instant to = Instant.ofEpochMilli(timeRange.getTo());\n+      Duration totalDuration = new Duration(from, to);\n+      LOG.info(\n+          String.format(\n+              \"splitting initial sendTime restriction of [minSendTime, now): [%s,%s), \"\n+                  + \"or [%s, %s). \\n\"\n+                  + \"total days: %s \\n\"\n+                  + \"into %s splits. \\n\"\n+                  + \"Last split: %s\",\n+              from,\n+              to,\n+              timeRange.getFrom(),\n+              timeRange.getTo(),\n+              totalDuration.getStandardDays(),\n+              splits.size(),\n+              splits.get(splits.size() - 1).toString()));\n+\n+      for (OffsetRange s : splits) {\n+        out.output(s);\n+      }\n+    }\n+\n     /**\n      * List messages.\n      *\n-     * @param context the context\n+     * @param hl7v2Store the HL7v2 store to list messages from\n      * @throws IOException the io exception\n      */\n     @ProcessElement\n-    public void listMessages(ProcessContext context) throws IOException {\n-      String hl7v2Store = context.element();\n-      // Output all elements of all pages.\n+    public void listMessages(\n+        @Element String hl7v2Store,\n+        RestrictionTracker tracker,\n+        OutputReceiver<HL7v2Message> outputReceiver)\n+        throws IOException {\n+      OffsetRange currentRestriction = (OffsetRange) tracker.currentRestriction();\n+      Instant startRestriction = Instant.ofEpochMilli(currentRestriction.getFrom());\n+      Instant endRestriction = Instant.ofEpochMilli(currentRestriction.getTo());\n       HttpHealthcareApiClient.HL7v2MessagePages pages =\n-          new HttpHealthcareApiClient.HL7v2MessagePages(client, hl7v2Store, this.filter);\n+          new HttpHealthcareApiClient.HL7v2MessagePages(\n+              client, hl7v2Store, startRestriction, endRestriction, filter, \"sendTime\");\n       long reqestTime = Instant.now().getMillis();\n-      for (Stream<HL7v2Message> page : pages) {\n+      long lastClaimedMilliSecond;\n+      Instant cursor;\n+      boolean hangingClaim = false; // flag if the claimed ms spans spills over to the next page.\n+      for (List<HL7v2Message> page : pages) { // loop over pages.\n+        int i = 0;\n+        HL7v2Message msg = page.get(i);\n+        while (i < page.size()) { // loop over messages in page\n+          cursor = Instant.parse(msg.getSendTime());\n+          lastClaimedMilliSecond = cursor.getMillis();\n+          LOG.info(\n+              String.format(\n+                  \"initial claim for page %s lastClaimedMilliSecond = %s\",\n+                  i, lastClaimedMilliSecond));\n+          if (hangingClaim || tracker.tryClaim(lastClaimedMilliSecond)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8859e7ff7770c5965e3eea18e0b0da5e4fe3d9c"}, "originalPosition": 237}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4cb7a5c81456779138615f35a06226f2ed24b3b5", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/4cb7a5c81456779138615f35a06226f2ed24b3b5", "committedDate": "2020-05-19T19:29:02Z", "message": "fix handling of ValueProvider interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a9b535c7e5d81b65c297e6af7c6875c77293c0a", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/2a9b535c7e5d81b65c297e6af7c6875c77293c0a", "committedDate": "2020-05-19T19:30:28Z", "message": "fix IT healthcare dataset reference"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32d0bf08188aaadb36ea7efcb944a1ed5ec23898", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/32d0bf08188aaadb36ea7efcb944a1ed5ec23898", "committedDate": "2020-05-19T19:50:56Z", "message": "fix value provider for read and write"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODQzOTk4", "url": "https://github.com/apache/beam/pull/11596#pullrequestreview-414843998", "createdAt": "2020-05-19T21:41:05Z", "commit": {"oid": "32d0bf08188aaadb36ea7efcb944a1ed5ec23898"}, "state": "COMMENTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMTo0MTowNVrOGXzqWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMjoxOTo0MFrOGX0qWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNjg1Ng==", "bodyText": "wouldn' this just be a small amount of waste since we would effectively get an empty response?", "url": "https://github.com/apache/beam/pull/11596#discussion_r427616856", "createdAt": "2020-05-19T21:41:05Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -415,10 +423,29 @@ private Message fetchMessage(HealthcareApiClient client, String msgId)\n     }\n   }\n \n-  /** List HL7v2 messages in HL7v2 Stores with optional filter. */\n+  /**\n+   * List HL7v2 messages in HL7v2 Stores with optional filter.\n+   *\n+   * <p>This transform is optimized for dynamic splitting of message.list calls for large batches of\n+   * historical data and assumes rather continuous stream of sendTimes. It will dynamically\n+   * rebalance resources to handle \"peak traffic times\" but will waste resources if there are large\n+   * durations (days) of the sendTime dimension without data.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32d0bf08188aaadb36ea7efcb944a1ed5ec23898"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNzI4Ng==", "bodyText": "consider using <ol> and <li> tags in the javadoc for your ordered list", "url": "https://github.com/apache/beam/pull/11596#discussion_r427617286", "createdAt": "2020-05-19T21:42:09Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -415,10 +423,29 @@ private Message fetchMessage(HealthcareApiClient client, String msgId)\n     }\n   }\n \n-  /** List HL7v2 messages in HL7v2 Stores with optional filter. */\n+  /**\n+   * List HL7v2 messages in HL7v2 Stores with optional filter.\n+   *\n+   * <p>This transform is optimized for dynamic splitting of message.list calls for large batches of\n+   * historical data and assumes rather continuous stream of sendTimes. It will dynamically\n+   * rebalance resources to handle \"peak traffic times\" but will waste resources if there are large\n+   * durations (days) of the sendTime dimension without data.\n+   *\n+   * <p>Implementation includes overhead for: 1. two api calls to determine the min/max sendTime of", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32d0bf08188aaadb36ea7efcb944a1ed5ec23898"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxODA3MQ==", "bodyText": "Consider using {@code ...} when referring to code and {@link ...} for things you can directly link against.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * <p>This transform is optimized for dynamic splitting of message.list calls for large batches of\n          \n          \n            \n               * <p>This transform is optimized for dynamic splitting of {@code message.list} calls for large batches of", "url": "https://github.com/apache/beam/pull/11596#discussion_r427618071", "createdAt": "2020-05-19T21:43:54Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -415,10 +423,29 @@ private Message fetchMessage(HealthcareApiClient client, String msgId)\n     }\n   }\n \n-  /** List HL7v2 messages in HL7v2 Stores with optional filter. */\n+  /**\n+   * List HL7v2 messages in HL7v2 Stores with optional filter.\n+   *\n+   * <p>This transform is optimized for dynamic splitting of message.list calls for large batches of", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32d0bf08188aaadb36ea7efcb944a1ed5ec23898"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxODYwMA==", "bodyText": "I'm not sure if the users need to know the exact implementation details as this may lock future maintainers into meeting these goals even when they can produce a more efficient solution in the future.", "url": "https://github.com/apache/beam/pull/11596#discussion_r427618600", "createdAt": "2020-05-19T21:45:05Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -415,10 +423,29 @@ private Message fetchMessage(HealthcareApiClient client, String msgId)\n     }\n   }\n \n-  /** List HL7v2 messages in HL7v2 Stores with optional filter. */\n+  /**\n+   * List HL7v2 messages in HL7v2 Stores with optional filter.\n+   *\n+   * <p>This transform is optimized for dynamic splitting of message.list calls for large batches of\n+   * historical data and assumes rather continuous stream of sendTimes. It will dynamically\n+   * rebalance resources to handle \"peak traffic times\" but will waste resources if there are large\n+   * durations (days) of the sendTime dimension without data.\n+   *\n+   * <p>Implementation includes overhead for: 1. two api calls to determine the min/max sendTime of\n+   * the HL7v2 store at invocation time. 2. initial splitting into non-overlapping time ranges\n+   * (default daily) to achieve parallelization in separate messages.list calls.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32d0bf08188aaadb36ea7efcb944a1ed5ec23898"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxODc0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * sparse data sets in the sendTime dimension).\n          \n          \n            \n               * sparse data sets in the {@code sendTime} dimension).", "url": "https://github.com/apache/beam/pull/11596#discussion_r427618746", "createdAt": "2020-05-19T21:45:25Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -415,10 +423,29 @@ private Message fetchMessage(HealthcareApiClient client, String msgId)\n     }\n   }\n \n-  /** List HL7v2 messages in HL7v2 Stores with optional filter. */\n+  /**\n+   * List HL7v2 messages in HL7v2 Stores with optional filter.\n+   *\n+   * <p>This transform is optimized for dynamic splitting of message.list calls for large batches of\n+   * historical data and assumes rather continuous stream of sendTimes. It will dynamically\n+   * rebalance resources to handle \"peak traffic times\" but will waste resources if there are large\n+   * durations (days) of the sendTime dimension without data.\n+   *\n+   * <p>Implementation includes overhead for: 1. two api calls to determine the min/max sendTime of\n+   * the HL7v2 store at invocation time. 2. initial splitting into non-overlapping time ranges\n+   * (default daily) to achieve parallelization in separate messages.list calls.\n+   *\n+   * <p>This will make more queries than necessary when used with very small data sets. (or very\n+   * sparse data sets in the sendTime dimension).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32d0bf08188aaadb36ea7efcb944a1ed5ec23898"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxOTEyNg==", "bodyText": "I don't think we want people to do this since empty splits are not that expensive and will quickly clear out a block of work.", "url": "https://github.com/apache/beam/pull/11596#discussion_r427619126", "createdAt": "2020-05-19T21:46:16Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -415,10 +423,29 @@ private Message fetchMessage(HealthcareApiClient client, String msgId)\n     }\n   }\n \n-  /** List HL7v2 messages in HL7v2 Stores with optional filter. */\n+  /**\n+   * List HL7v2 messages in HL7v2 Stores with optional filter.\n+   *\n+   * <p>This transform is optimized for dynamic splitting of message.list calls for large batches of\n+   * historical data and assumes rather continuous stream of sendTimes. It will dynamically\n+   * rebalance resources to handle \"peak traffic times\" but will waste resources if there are large\n+   * durations (days) of the sendTime dimension without data.\n+   *\n+   * <p>Implementation includes overhead for: 1. two api calls to determine the min/max sendTime of\n+   * the HL7v2 store at invocation time. 2. initial splitting into non-overlapping time ranges\n+   * (default daily) to achieve parallelization in separate messages.list calls.\n+   *\n+   * <p>This will make more queries than necessary when used with very small data sets. (or very\n+   * sparse data sets in the sendTime dimension).\n+   *\n+   * <p>If you have large but sparse data (e.g. hours between consecutive message sendTimes) and\n+   * know something about the time ranges where you have no data, consider using multiple instances\n+   * of this transform specifying sendTime filters to omit the ranges where there is no data.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32d0bf08188aaadb36ea7efcb944a1ed5ec23898"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyMDQwOA==", "bodyText": "even if a member variable is null, it should still be final since it doesn't look like we mutate it locally. Same reason for other places I suggest to change this.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private ValueProvider<String> filter;\n          \n          \n            \n                private Duration initialSplitDuration;\n          \n          \n            \n                private final ValueProvider<String> filter;\n          \n          \n            \n                private final Duration initialSplitDuration;", "url": "https://github.com/apache/beam/pull/11596#discussion_r427620408", "createdAt": "2020-05-19T21:49:04Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -415,10 +423,29 @@ private Message fetchMessage(HealthcareApiClient client, String msgId)\n     }\n   }\n \n-  /** List HL7v2 messages in HL7v2 Stores with optional filter. */\n+  /**\n+   * List HL7v2 messages in HL7v2 Stores with optional filter.\n+   *\n+   * <p>This transform is optimized for dynamic splitting of message.list calls for large batches of\n+   * historical data and assumes rather continuous stream of sendTimes. It will dynamically\n+   * rebalance resources to handle \"peak traffic times\" but will waste resources if there are large\n+   * durations (days) of the sendTime dimension without data.\n+   *\n+   * <p>Implementation includes overhead for: 1. two api calls to determine the min/max sendTime of\n+   * the HL7v2 store at invocation time. 2. initial splitting into non-overlapping time ranges\n+   * (default daily) to achieve parallelization in separate messages.list calls.\n+   *\n+   * <p>This will make more queries than necessary when used with very small data sets. (or very\n+   * sparse data sets in the sendTime dimension).\n+   *\n+   * <p>If you have large but sparse data (e.g. hours between consecutive message sendTimes) and\n+   * know something about the time ranges where you have no data, consider using multiple instances\n+   * of this transform specifying sendTime filters to omit the ranges where there is no data.\n+   */\n   public static class ListHL7v2Messages extends PTransform<PBegin, PCollection<HL7v2Message>> {\n-    private final List<String> hl7v2Stores;\n-    private final String filter;\n+    private final ValueProvider<List<String>> hl7v2Stores;\n+    private ValueProvider<String> filter;\n+    private Duration initialSplitDuration;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32d0bf08188aaadb36ea7efcb944a1ed5ec23898"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyMDk4Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              static class ListHL7v2MessagesFn extends DoFn<String, HL7v2Message> {\n          \n          \n            \n              @VisibleForTesting\n          \n          \n            \n              static class ListHL7v2MessagesFn extends DoFn<String, HL7v2Message> {", "url": "https://github.com/apache/beam/pull/11596#discussion_r427620983", "createdAt": "2020-05-19T21:50:19Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -427,29 +454,75 @@ private Message fetchMessage(HealthcareApiClient client, String msgId)\n      * @param filter the filter\n      */\n     ListHL7v2Messages(ValueProvider<List<String>> hl7v2Stores, ValueProvider<String> filter) {\n-      this.hl7v2Stores = hl7v2Stores.get();\n-      this.filter = filter.get();\n+      this.hl7v2Stores = hl7v2Stores;\n+      this.filter = filter;\n+    }\n+\n+    /**\n+     * Instantiates a new List hl 7 v 2 messages.\n+     *\n+     * @param hl7v2Stores the hl 7 v 2 stores\n+     * @param filter the filter\n+     * @param initialSplitDuration the initial split duration for sendTime dimension splits\n+     */\n+    ListHL7v2Messages(\n+        ValueProvider<List<String>> hl7v2Stores,\n+        ValueProvider<String> filter,\n+        Duration initialSplitDuration) {\n+      this.hl7v2Stores = hl7v2Stores;\n+      this.filter = filter;\n+      this.initialSplitDuration = initialSplitDuration;\n     }\n \n+    /**\n+     * Instantiates a new List hl7v2 messages.\n+     *\n+     * @param hl7v2Stores the hl7v2 stores\n+     */\n     ListHL7v2Messages(ValueProvider<List<String>> hl7v2Stores) {\n-      this.hl7v2Stores = hl7v2Stores.get();\n+      this.hl7v2Stores = hl7v2Stores;\n       this.filter = null;\n     }\n \n+    /**\n+     * Instantiates a new List hl7v2 messages.\n+     *\n+     * @param hl7v2Stores the hl7v2 stores\n+     * @param initialSplitDuration the initial split duration\n+     */\n+    ListHL7v2Messages(ValueProvider<List<String>> hl7v2Stores, Duration initialSplitDuration) {\n+      this.hl7v2Stores = hl7v2Stores;\n+      this.initialSplitDuration = initialSplitDuration;\n+    }\n+\n     @Override\n     public PCollection<HL7v2Message> expand(PBegin input) {\n       return input\n-          .apply(Create.of(this.hl7v2Stores))\n-          .apply(ParDo.of(new ListHL7v2MessagesFn(this.filter)))\n+          .apply(Create.ofProvider(this.hl7v2Stores, ListCoder.of(StringUtf8Coder.of())))\n+          .apply(FlatMapElements.into(TypeDescriptors.strings()).via((x) -> x))\n+          .apply(ParDo.of(new ListHL7v2MessagesFn(this.filter, initialSplitDuration)))\n           .setCoder(new HL7v2MessageCoder())\n           // Break fusion to encourage parallelization of downstream processing.\n           .apply(Reshuffle.viaRandomKey());\n     }\n   }\n \n+  /**\n+   * Implemented as Splitable DoFn that claims millisecond resolutions of offset restrictions in the\n+   * Message.sendTime dimension.\n+   */\n+  @BoundedPerElement\n   static class ListHL7v2MessagesFn extends DoFn<String, HL7v2Message> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32d0bf08188aaadb36ea7efcb944a1ed5ec23898"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyMjQzOA==", "bodyText": "Can any of these be final?", "url": "https://github.com/apache/beam/pull/11596#discussion_r427622438", "createdAt": "2020-05-19T21:53:36Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -427,29 +454,75 @@ private Message fetchMessage(HealthcareApiClient client, String msgId)\n      * @param filter the filter\n      */\n     ListHL7v2Messages(ValueProvider<List<String>> hl7v2Stores, ValueProvider<String> filter) {\n-      this.hl7v2Stores = hl7v2Stores.get();\n-      this.filter = filter.get();\n+      this.hl7v2Stores = hl7v2Stores;\n+      this.filter = filter;\n+    }\n+\n+    /**\n+     * Instantiates a new List hl 7 v 2 messages.\n+     *\n+     * @param hl7v2Stores the hl 7 v 2 stores\n+     * @param filter the filter\n+     * @param initialSplitDuration the initial split duration for sendTime dimension splits\n+     */\n+    ListHL7v2Messages(\n+        ValueProvider<List<String>> hl7v2Stores,\n+        ValueProvider<String> filter,\n+        Duration initialSplitDuration) {\n+      this.hl7v2Stores = hl7v2Stores;\n+      this.filter = filter;\n+      this.initialSplitDuration = initialSplitDuration;\n     }\n \n+    /**\n+     * Instantiates a new List hl7v2 messages.\n+     *\n+     * @param hl7v2Stores the hl7v2 stores\n+     */\n     ListHL7v2Messages(ValueProvider<List<String>> hl7v2Stores) {\n-      this.hl7v2Stores = hl7v2Stores.get();\n+      this.hl7v2Stores = hl7v2Stores;\n       this.filter = null;\n     }\n \n+    /**\n+     * Instantiates a new List hl7v2 messages.\n+     *\n+     * @param hl7v2Stores the hl7v2 stores\n+     * @param initialSplitDuration the initial split duration\n+     */\n+    ListHL7v2Messages(ValueProvider<List<String>> hl7v2Stores, Duration initialSplitDuration) {\n+      this.hl7v2Stores = hl7v2Stores;\n+      this.initialSplitDuration = initialSplitDuration;\n+    }\n+\n     @Override\n     public PCollection<HL7v2Message> expand(PBegin input) {\n       return input\n-          .apply(Create.of(this.hl7v2Stores))\n-          .apply(ParDo.of(new ListHL7v2MessagesFn(this.filter)))\n+          .apply(Create.ofProvider(this.hl7v2Stores, ListCoder.of(StringUtf8Coder.of())))\n+          .apply(FlatMapElements.into(TypeDescriptors.strings()).via((x) -> x))\n+          .apply(ParDo.of(new ListHL7v2MessagesFn(this.filter, initialSplitDuration)))\n           .setCoder(new HL7v2MessageCoder())\n           // Break fusion to encourage parallelization of downstream processing.\n           .apply(Reshuffle.viaRandomKey());\n     }\n   }\n \n+  /**\n+   * Implemented as Splitable DoFn that claims millisecond resolutions of offset restrictions in the\n+   * Message.sendTime dimension.\n+   */\n+  @BoundedPerElement\n   static class ListHL7v2MessagesFn extends DoFn<String, HL7v2Message> {\n \n-    private final String filter;\n+    private static final Logger LOG = LoggerFactory.getLogger(ListHL7v2MessagesFn.class);\n+    private ValueProvider<String> filter;\n+    // These control the initial restriction split which means that the list of integer pairs\n+    // must comfortably fit in memory.\n+    private static final Duration DEFAULT_DESIRED_SPLIT_DURATION = Duration.standardDays(1);\n+    private static final Duration DEFAULT_MIN_SPLIT_DURATION = Duration.standardHours(1);\n+    private Duration initialSplitDuration;\n+    private Instant from;\n+    private Instant to;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32d0bf08188aaadb36ea7efcb944a1ed5ec23898"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyMjYwNA==", "bodyText": "nit: Might want to group your statics at the top together separate from the member variables.", "url": "https://github.com/apache/beam/pull/11596#discussion_r427622604", "createdAt": "2020-05-19T21:54:02Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -427,29 +454,75 @@ private Message fetchMessage(HealthcareApiClient client, String msgId)\n      * @param filter the filter\n      */\n     ListHL7v2Messages(ValueProvider<List<String>> hl7v2Stores, ValueProvider<String> filter) {\n-      this.hl7v2Stores = hl7v2Stores.get();\n-      this.filter = filter.get();\n+      this.hl7v2Stores = hl7v2Stores;\n+      this.filter = filter;\n+    }\n+\n+    /**\n+     * Instantiates a new List hl 7 v 2 messages.\n+     *\n+     * @param hl7v2Stores the hl 7 v 2 stores\n+     * @param filter the filter\n+     * @param initialSplitDuration the initial split duration for sendTime dimension splits\n+     */\n+    ListHL7v2Messages(\n+        ValueProvider<List<String>> hl7v2Stores,\n+        ValueProvider<String> filter,\n+        Duration initialSplitDuration) {\n+      this.hl7v2Stores = hl7v2Stores;\n+      this.filter = filter;\n+      this.initialSplitDuration = initialSplitDuration;\n     }\n \n+    /**\n+     * Instantiates a new List hl7v2 messages.\n+     *\n+     * @param hl7v2Stores the hl7v2 stores\n+     */\n     ListHL7v2Messages(ValueProvider<List<String>> hl7v2Stores) {\n-      this.hl7v2Stores = hl7v2Stores.get();\n+      this.hl7v2Stores = hl7v2Stores;\n       this.filter = null;\n     }\n \n+    /**\n+     * Instantiates a new List hl7v2 messages.\n+     *\n+     * @param hl7v2Stores the hl7v2 stores\n+     * @param initialSplitDuration the initial split duration\n+     */\n+    ListHL7v2Messages(ValueProvider<List<String>> hl7v2Stores, Duration initialSplitDuration) {\n+      this.hl7v2Stores = hl7v2Stores;\n+      this.initialSplitDuration = initialSplitDuration;\n+    }\n+\n     @Override\n     public PCollection<HL7v2Message> expand(PBegin input) {\n       return input\n-          .apply(Create.of(this.hl7v2Stores))\n-          .apply(ParDo.of(new ListHL7v2MessagesFn(this.filter)))\n+          .apply(Create.ofProvider(this.hl7v2Stores, ListCoder.of(StringUtf8Coder.of())))\n+          .apply(FlatMapElements.into(TypeDescriptors.strings()).via((x) -> x))\n+          .apply(ParDo.of(new ListHL7v2MessagesFn(this.filter, initialSplitDuration)))\n           .setCoder(new HL7v2MessageCoder())\n           // Break fusion to encourage parallelization of downstream processing.\n           .apply(Reshuffle.viaRandomKey());\n     }\n   }\n \n+  /**\n+   * Implemented as Splitable DoFn that claims millisecond resolutions of offset restrictions in the\n+   * Message.sendTime dimension.\n+   */\n+  @BoundedPerElement\n   static class ListHL7v2MessagesFn extends DoFn<String, HL7v2Message> {\n \n-    private final String filter;\n+    private static final Logger LOG = LoggerFactory.getLogger(ListHL7v2MessagesFn.class);\n+    private ValueProvider<String> filter;\n+    // These control the initial restriction split which means that the list of integer pairs\n+    // must comfortably fit in memory.\n+    private static final Duration DEFAULT_DESIRED_SPLIT_DURATION = Duration.standardDays(1);\n+    private static final Duration DEFAULT_MIN_SPLIT_DURATION = Duration.standardHours(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32d0bf08188aaadb36ea7efcb944a1ed5ec23898"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyMzExMA==", "bodyText": "https://stackoverflow.com/questions/285177/how-do-i-call-one-constructor-from-another-in-java\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  new ListHL7v2MessagesFn(StaticValueProvider.of(filter), null);\n          \n          \n            \n                  this(StaticValueProvider.of(filter), null);", "url": "https://github.com/apache/beam/pull/11596#discussion_r427623110", "createdAt": "2020-05-19T21:55:11Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -459,7 +532,13 @@ private Message fetchMessage(HealthcareApiClient client, String msgId)\n      * @param filter the filter\n      */\n     ListHL7v2MessagesFn(String filter) {\n+      new ListHL7v2MessagesFn(StaticValueProvider.of(filter), null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32d0bf08188aaadb36ea7efcb944a1ed5ec23898"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyNDIzOA==", "bodyText": "This method is not necessary since OffsetRange supports HasDefaultTracker which your effectively invoking yourself.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @NewTracker\n          \n          \n            \n                public OffsetRangeTracker newTracker(@Restriction OffsetRange timeRange) {\n          \n          \n            \n                  return timeRange.newTracker();\n          \n          \n            \n                }", "url": "https://github.com/apache/beam/pull/11596#discussion_r427624238", "createdAt": "2020-05-19T21:57:39Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -472,24 +551,118 @@ public void initClient() throws IOException {\n       this.client = new HttpHealthcareApiClient();\n     }\n \n+    @GetInitialRestriction\n+    public OffsetRange getEarliestToLatestRestriction(@Element String hl7v2Store)\n+        throws IOException {\n+      from = this.client.getEarliestHL7v2SendTime(hl7v2Store, this.filter.get());\n+      // filters are [from, to) to match logic of OffsetRangeTracker but need latest element to be\n+      // included in results set to add an extra ms to the upper bound.\n+      to = this.client.getLatestHL7v2SendTime(hl7v2Store, this.filter.get()).plus(1);\n+      return new OffsetRange(from.getMillis(), to.getMillis());\n+    }\n+\n+    @NewTracker\n+    public OffsetRangeTracker newTracker(@Restriction OffsetRange timeRange) {\n+      return timeRange.newTracker();\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32d0bf08188aaadb36ea7efcb944a1ed5ec23898"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyNTE2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    RestrictionTracker tracker,\n          \n          \n            \n                    RestrictionTracker<OffsetRange, Long> tracker,", "url": "https://github.com/apache/beam/pull/11596#discussion_r427625167", "createdAt": "2020-05-19T21:59:51Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -472,24 +551,118 @@ public void initClient() throws IOException {\n       this.client = new HttpHealthcareApiClient();\n     }\n \n+    @GetInitialRestriction\n+    public OffsetRange getEarliestToLatestRestriction(@Element String hl7v2Store)\n+        throws IOException {\n+      from = this.client.getEarliestHL7v2SendTime(hl7v2Store, this.filter.get());\n+      // filters are [from, to) to match logic of OffsetRangeTracker but need latest element to be\n+      // included in results set to add an extra ms to the upper bound.\n+      to = this.client.getLatestHL7v2SendTime(hl7v2Store, this.filter.get()).plus(1);\n+      return new OffsetRange(from.getMillis(), to.getMillis());\n+    }\n+\n+    @NewTracker\n+    public OffsetRangeTracker newTracker(@Restriction OffsetRange timeRange) {\n+      return timeRange.newTracker();\n+    }\n+\n+    @SplitRestriction\n+    public void split(@Restriction OffsetRange timeRange, OutputReceiver<OffsetRange> out) {\n+      List<OffsetRange> splits =\n+          timeRange.split(initialSplitDuration.getMillis(), DEFAULT_MIN_SPLIT_DURATION.getMillis());\n+      Instant from = Instant.ofEpochMilli(timeRange.getFrom());\n+      Instant to = Instant.ofEpochMilli(timeRange.getTo());\n+      Duration totalDuration = new Duration(from, to);\n+      LOG.info(\n+          String.format(\n+              \"splitting initial sendTime restriction of [minSendTime, now): [%s,%s), \"\n+                  + \"or [%s, %s). \\n\"\n+                  + \"total days: %s \\n\"\n+                  + \"into %s splits. \\n\"\n+                  + \"Last split: %s\",\n+              from,\n+              to,\n+              timeRange.getFrom(),\n+              timeRange.getTo(),\n+              totalDuration.getStandardDays(),\n+              splits.size(),\n+              splits.get(splits.size() - 1).toString()));\n+\n+      for (OffsetRange s : splits) {\n+        out.output(s);\n+      }\n+    }\n+\n     /**\n      * List messages.\n      *\n-     * @param context the context\n+     * @param hl7v2Store the HL7v2 store to list messages from\n      * @throws IOException the io exception\n      */\n     @ProcessElement\n-    public void listMessages(ProcessContext context) throws IOException {\n-      String hl7v2Store = context.element();\n-      // Output all elements of all pages.\n+    public void listMessages(\n+        @Element String hl7v2Store,\n+        RestrictionTracker tracker,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32d0bf08188aaadb36ea7efcb944a1ed5ec23898"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyOTMxMw==", "bodyText": "It would sense to move this into wherever we do the list call.", "url": "https://github.com/apache/beam/pull/11596#discussion_r427629313", "createdAt": "2020-05-19T22:09:50Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -472,24 +551,118 @@ public void initClient() throws IOException {\n       this.client = new HttpHealthcareApiClient();\n     }\n \n+    @GetInitialRestriction\n+    public OffsetRange getEarliestToLatestRestriction(@Element String hl7v2Store)\n+        throws IOException {\n+      from = this.client.getEarliestHL7v2SendTime(hl7v2Store, this.filter.get());\n+      // filters are [from, to) to match logic of OffsetRangeTracker but need latest element to be\n+      // included in results set to add an extra ms to the upper bound.\n+      to = this.client.getLatestHL7v2SendTime(hl7v2Store, this.filter.get()).plus(1);\n+      return new OffsetRange(from.getMillis(), to.getMillis());\n+    }\n+\n+    @NewTracker\n+    public OffsetRangeTracker newTracker(@Restriction OffsetRange timeRange) {\n+      return timeRange.newTracker();\n+    }\n+\n+    @SplitRestriction\n+    public void split(@Restriction OffsetRange timeRange, OutputReceiver<OffsetRange> out) {\n+      List<OffsetRange> splits =\n+          timeRange.split(initialSplitDuration.getMillis(), DEFAULT_MIN_SPLIT_DURATION.getMillis());\n+      Instant from = Instant.ofEpochMilli(timeRange.getFrom());\n+      Instant to = Instant.ofEpochMilli(timeRange.getTo());\n+      Duration totalDuration = new Duration(from, to);\n+      LOG.info(\n+          String.format(\n+              \"splitting initial sendTime restriction of [minSendTime, now): [%s,%s), \"\n+                  + \"or [%s, %s). \\n\"\n+                  + \"total days: %s \\n\"\n+                  + \"into %s splits. \\n\"\n+                  + \"Last split: %s\",\n+              from,\n+              to,\n+              timeRange.getFrom(),\n+              timeRange.getTo(),\n+              totalDuration.getStandardDays(),\n+              splits.size(),\n+              splits.get(splits.size() - 1).toString()));\n+\n+      for (OffsetRange s : splits) {\n+        out.output(s);\n+      }\n+    }\n+\n     /**\n      * List messages.\n      *\n-     * @param context the context\n+     * @param hl7v2Store the HL7v2 store to list messages from\n      * @throws IOException the io exception\n      */\n     @ProcessElement\n-    public void listMessages(ProcessContext context) throws IOException {\n-      String hl7v2Store = context.element();\n-      // Output all elements of all pages.\n+    public void listMessages(\n+        @Element String hl7v2Store,\n+        RestrictionTracker tracker,\n+        OutputReceiver<HL7v2Message> outputReceiver)\n+        throws IOException {\n+      OffsetRange currentRestriction = (OffsetRange) tracker.currentRestriction();\n+      Instant startRestriction = Instant.ofEpochMilli(currentRestriction.getFrom());\n+      Instant endRestriction = Instant.ofEpochMilli(currentRestriction.getTo());\n       HttpHealthcareApiClient.HL7v2MessagePages pages =\n-          new HttpHealthcareApiClient.HL7v2MessagePages(client, hl7v2Store, this.filter);\n+          new HttpHealthcareApiClient.HL7v2MessagePages(\n+              client, hl7v2Store, startRestriction, endRestriction, filter.get(), \"sendTime\");\n       long reqestTime = Instant.now().getMillis();\n-      for (Stream<HL7v2Message> page : pages) {\n+      long lastClaimedMilliSecond;\n+      Instant cursor;\n+      boolean hangingClaim = false; // flag if the claimed ms spans spills over to the next page.\n+      for (List<HL7v2Message> page : pages) { // loop over pages.\n+        int i = 0;\n+        HL7v2Message msg = page.get(i);\n+        while (i < page.size()) { // loop over messages in page\n+          cursor = Instant.parse(msg.getSendTime());\n+          lastClaimedMilliSecond = cursor.getMillis();\n+          LOG.info(\n+              String.format(\n+                  \"initial claim for page %s lastClaimedMilliSecond = %s\",\n+                  i, lastClaimedMilliSecond));\n+          if (hangingClaim || tracker.tryClaim(lastClaimedMilliSecond)) {\n+            // This means we have claimed an entire millisecond we need to make sure that we\n+            // process all messages for this millisecond because sendTime is allegedly nano second\n+            // resolution.\n+            // https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.hl7V2Stores.messages#Message\n+            while (cursor.getMillis() == lastClaimedMilliSecond\n+                && i < page.size()) { // loop over messages in millisecond.\n+              outputReceiver.output(msg);\n+              msg = page.get(i++);\n+              cursor = Instant.parse(msg.getSendTime());\n+            }\n+\n+            if (i == page.size() && cursor.getMillis() == lastClaimedMilliSecond) {\n+              // reached the end of the page and timestamp still in the claimed ms.\n+              hangingClaim = true;\n+              continue;\n+            }\n+\n+            // If reached this point, msg.sendTime is outside the current claim.\n+            // Need to claim time range up to (and including) the cursor to properly advance the\n+            // tracker.\n+            tracker.tryClaim(cursor.getMillis());\n+            lastClaimedMilliSecond = cursor.getMillis();\n+            LOG.info(\n+                String.format(\n+                    \"After claiming between messages lastClaimedMilliSecond = %s\",\n+                    lastClaimedMilliSecond));\n+          }\n+        }\n         messageListingLatencyMs.update(Instant.now().getMillis() - reqestTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32d0bf08188aaadb36ea7efcb944a1ed5ec23898"}, "originalPosition": 296}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYzMDYwMA==", "bodyText": "I agree with @pabloem that this logic is not simple to follow and I think you could really simplify your code if you used https://guava.dev/releases/21.0/api/docs/com/google/common/collect/FluentIterable.html#concat-java.lang.Iterable-\nsince it would convert Iterable<List<HL7v2Message>> into Iterable<HL7v2Message> and only accesses the elements lazily so it wouldn't prefetch everything.\nThis would allow you to not worry that messages are in a page and your processing multiple pages.", "url": "https://github.com/apache/beam/pull/11596#discussion_r427630600", "createdAt": "2020-05-19T22:12:51Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -472,24 +547,118 @@ public void initClient() throws IOException {\n       this.client = new HttpHealthcareApiClient();\n     }\n \n+    @GetInitialRestriction\n+    public OffsetRange getEarliestToLatestRestriction(@Element String hl7v2Store)\n+        throws IOException {\n+      from = this.client.getEarliestHL7v2SendTime(hl7v2Store, this.filter);\n+      // filters are [from, to) to match logic of OffsetRangeTracker but need latest element to be\n+      // included in results set to add an extra ms to the upper bound.\n+      to = this.client.getLatestHL7v2SendTime(hl7v2Store, this.filter).plus(1);\n+      return new OffsetRange(from.getMillis(), to.getMillis());\n+    }\n+\n+    @NewTracker\n+    public OffsetRangeTracker newTracker(@Restriction OffsetRange timeRange) {\n+      return timeRange.newTracker();\n+    }\n+\n+    @SplitRestriction\n+    public void split(@Restriction OffsetRange timeRange, OutputReceiver<OffsetRange> out) {\n+      List<OffsetRange> splits =\n+          timeRange.split(initialSplitDuration.getMillis(), DEFAULT_MIN_SPLIT_DURATION.getMillis());\n+      Instant from = Instant.ofEpochMilli(timeRange.getFrom());\n+      Instant to = Instant.ofEpochMilli(timeRange.getTo());\n+      Duration totalDuration = new Duration(from, to);\n+      LOG.info(\n+          String.format(\n+              \"splitting initial sendTime restriction of [minSendTime, now): [%s,%s), \"\n+                  + \"or [%s, %s). \\n\"\n+                  + \"total days: %s \\n\"\n+                  + \"into %s splits. \\n\"\n+                  + \"Last split: %s\",\n+              from,\n+              to,\n+              timeRange.getFrom(),\n+              timeRange.getTo(),\n+              totalDuration.getStandardDays(),\n+              splits.size(),\n+              splits.get(splits.size() - 1).toString()));\n+\n+      for (OffsetRange s : splits) {\n+        out.output(s);\n+      }\n+    }\n+\n     /**\n      * List messages.\n      *\n-     * @param context the context\n+     * @param hl7v2Store the HL7v2 store to list messages from\n      * @throws IOException the io exception\n      */\n     @ProcessElement\n-    public void listMessages(ProcessContext context) throws IOException {\n-      String hl7v2Store = context.element();\n-      // Output all elements of all pages.\n+    public void listMessages(\n+        @Element String hl7v2Store,\n+        RestrictionTracker tracker,\n+        OutputReceiver<HL7v2Message> outputReceiver)\n+        throws IOException {\n+      OffsetRange currentRestriction = (OffsetRange) tracker.currentRestriction();\n+      Instant startRestriction = Instant.ofEpochMilli(currentRestriction.getFrom());\n+      Instant endRestriction = Instant.ofEpochMilli(currentRestriction.getTo());\n       HttpHealthcareApiClient.HL7v2MessagePages pages =\n-          new HttpHealthcareApiClient.HL7v2MessagePages(client, hl7v2Store, this.filter);\n+          new HttpHealthcareApiClient.HL7v2MessagePages(\n+              client, hl7v2Store, startRestriction, endRestriction, filter, \"sendTime\");\n       long reqestTime = Instant.now().getMillis();\n-      for (Stream<HL7v2Message> page : pages) {\n+      long lastClaimedMilliSecond;\n+      Instant cursor;\n+      boolean hangingClaim = false; // flag if the claimed ms spans spills over to the next page.\n+      for (List<HL7v2Message> page : pages) { // loop over pages.\n+        int i = 0;\n+        HL7v2Message msg = page.get(i);\n+        while (i < page.size()) { // loop over messages in page\n+          cursor = Instant.parse(msg.getSendTime());\n+          lastClaimedMilliSecond = cursor.getMillis();\n+          LOG.info(\n+              String.format(\n+                  \"initial claim for page %s lastClaimedMilliSecond = %s\",\n+                  i, lastClaimedMilliSecond));\n+          if (hangingClaim || tracker.tryClaim(lastClaimedMilliSecond)) {\n+            // This means we have claimed an entire millisecond we need to make sure that we\n+            // process all messages for this millisecond because sendTime is allegedly nano second\n+            // resolution.\n+            // https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.hl7V2Stores.messages#Message\n+            while (cursor.getMillis() == lastClaimedMilliSecond\n+                && i < page.size()) { // loop over messages in millisecond.\n+              outputReceiver.output(msg);\n+              msg = page.get(i++);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyNTQyOQ=="}, "originalCommit": {"oid": "e8859e7ff7770c5965e3eea18e0b0da5e4fe3d9c"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYzMzI0MA==", "bodyText": "Should we be outputting elements with the timestamp of the message and should we be reporting a watermark?\nEven though you have a bounded SDF, it could be useful to report the watermark incase it is used in a streaming pipeline or users wanted to assign windows and perform grouping per window.\nThe current logic will assign the input's timestamp to all outputs which won't allow users to use windowing to effectively window the elements being output without assigning timestamps themselves. If we do want to go down this path it is simple right now because this transform always starts with PBegin but what would you want to do it the timestamp of the record is before the timestamp of the input element to the SDF (since it is illegal to output messages with timestamps before the input elements timestamp)?\nTo add watermark tracking based on timestamp of elements output, you would need to add the implementation for @GetInitialWatermarkEstimatorState and @NewWatermarkEstimator as seen in \n  \n    \n      beam/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Watch.java\n    \n    \n         Line 763\n      in\n      27656d7\n    \n    \n    \n    \n\n        \n          \n           @GetInitialWatermarkEstimatorState", "url": "https://github.com/apache/beam/pull/11596#discussion_r427633240", "createdAt": "2020-05-19T22:19:40Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -472,24 +551,118 @@ public void initClient() throws IOException {\n       this.client = new HttpHealthcareApiClient();\n     }\n \n+    @GetInitialRestriction\n+    public OffsetRange getEarliestToLatestRestriction(@Element String hl7v2Store)\n+        throws IOException {\n+      from = this.client.getEarliestHL7v2SendTime(hl7v2Store, this.filter.get());\n+      // filters are [from, to) to match logic of OffsetRangeTracker but need latest element to be\n+      // included in results set to add an extra ms to the upper bound.\n+      to = this.client.getLatestHL7v2SendTime(hl7v2Store, this.filter.get()).plus(1);\n+      return new OffsetRange(from.getMillis(), to.getMillis());\n+    }\n+\n+    @NewTracker\n+    public OffsetRangeTracker newTracker(@Restriction OffsetRange timeRange) {\n+      return timeRange.newTracker();\n+    }\n+\n+    @SplitRestriction\n+    public void split(@Restriction OffsetRange timeRange, OutputReceiver<OffsetRange> out) {\n+      List<OffsetRange> splits =\n+          timeRange.split(initialSplitDuration.getMillis(), DEFAULT_MIN_SPLIT_DURATION.getMillis());\n+      Instant from = Instant.ofEpochMilli(timeRange.getFrom());\n+      Instant to = Instant.ofEpochMilli(timeRange.getTo());\n+      Duration totalDuration = new Duration(from, to);\n+      LOG.info(\n+          String.format(\n+              \"splitting initial sendTime restriction of [minSendTime, now): [%s,%s), \"\n+                  + \"or [%s, %s). \\n\"\n+                  + \"total days: %s \\n\"\n+                  + \"into %s splits. \\n\"\n+                  + \"Last split: %s\",\n+              from,\n+              to,\n+              timeRange.getFrom(),\n+              timeRange.getTo(),\n+              totalDuration.getStandardDays(),\n+              splits.size(),\n+              splits.get(splits.size() - 1).toString()));\n+\n+      for (OffsetRange s : splits) {\n+        out.output(s);\n+      }\n+    }\n+\n     /**\n      * List messages.\n      *\n-     * @param context the context\n+     * @param hl7v2Store the HL7v2 store to list messages from\n      * @throws IOException the io exception\n      */\n     @ProcessElement\n-    public void listMessages(ProcessContext context) throws IOException {\n-      String hl7v2Store = context.element();\n-      // Output all elements of all pages.\n+    public void listMessages(\n+        @Element String hl7v2Store,\n+        RestrictionTracker tracker,\n+        OutputReceiver<HL7v2Message> outputReceiver)\n+        throws IOException {\n+      OffsetRange currentRestriction = (OffsetRange) tracker.currentRestriction();\n+      Instant startRestriction = Instant.ofEpochMilli(currentRestriction.getFrom());\n+      Instant endRestriction = Instant.ofEpochMilli(currentRestriction.getTo());\n       HttpHealthcareApiClient.HL7v2MessagePages pages =\n-          new HttpHealthcareApiClient.HL7v2MessagePages(client, hl7v2Store, this.filter);\n+          new HttpHealthcareApiClient.HL7v2MessagePages(\n+              client, hl7v2Store, startRestriction, endRestriction, filter.get(), \"sendTime\");\n       long reqestTime = Instant.now().getMillis();\n-      for (Stream<HL7v2Message> page : pages) {\n+      long lastClaimedMilliSecond;\n+      Instant cursor;\n+      boolean hangingClaim = false; // flag if the claimed ms spans spills over to the next page.\n+      for (List<HL7v2Message> page : pages) { // loop over pages.\n+        int i = 0;\n+        HL7v2Message msg = page.get(i);\n+        while (i < page.size()) { // loop over messages in page\n+          cursor = Instant.parse(msg.getSendTime());\n+          lastClaimedMilliSecond = cursor.getMillis();\n+          LOG.info(\n+              String.format(\n+                  \"initial claim for page %s lastClaimedMilliSecond = %s\",\n+                  i, lastClaimedMilliSecond));\n+          if (hangingClaim || tracker.tryClaim(lastClaimedMilliSecond)) {\n+            // This means we have claimed an entire millisecond we need to make sure that we\n+            // process all messages for this millisecond because sendTime is allegedly nano second\n+            // resolution.\n+            // https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.hl7V2Stores.messages#Message\n+            while (cursor.getMillis() == lastClaimedMilliSecond\n+                && i < page.size()) { // loop over messages in millisecond.\n+              outputReceiver.output(msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32d0bf08188aaadb36ea7efcb944a1ed5ec23898"}, "originalPosition": 274}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5642b3198b30ac6318ba431a3db079e551f86b80", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/5642b3198b30ac6318ba431a3db079e551f86b80", "committedDate": "2020-05-19T22:38:09Z", "message": "Update sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java\n\nCo-authored-by: Lukasz Cwik <lcwik@google.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b34a0a141acf58e3975017f7234ad08926d8fc9a", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/b34a0a141acf58e3975017f7234ad08926d8fc9a", "committedDate": "2020-05-19T22:41:09Z", "message": "Update sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java\n\nCo-authored-by: Lukasz Cwik <lcwik@google.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fe405a0734322ad75860f1d9b6141423dd2790f", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/0fe405a0734322ad75860f1d9b6141423dd2790f", "committedDate": "2020-05-19T22:43:01Z", "message": "Update sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java\n\nCo-authored-by: Lukasz Cwik <lcwik@google.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87e47a351a317a84cf76348d17d0287a675c7337", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/87e47a351a317a84cf76348d17d0287a675c7337", "committedDate": "2020-05-19T22:43:26Z", "message": "Update sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java\n\nCo-authored-by: Lukasz Cwik <lcwik@google.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43b97bb2f2822e37c52882f19a9583de5271209a", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/43b97bb2f2822e37c52882f19a9583de5271209a", "committedDate": "2020-05-19T22:44:03Z", "message": "Update sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java\n\nCo-authored-by: Lukasz Cwik <lcwik@google.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c74a0fe1da1478b3751327c7f2f81f5b383a1d5", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/3c74a0fe1da1478b3751327c7f2f81f5b383a1d5", "committedDate": "2020-05-19T22:44:29Z", "message": "Update sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java\n\nCo-authored-by: Lukasz Cwik <lcwik@google.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODc2MjMw", "url": "https://github.com/apache/beam/pull/11596#pullrequestreview-414876230", "createdAt": "2020-05-19T22:48:23Z", "commit": {"oid": "32d0bf08188aaadb36ea7efcb944a1ed5ec23898"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMjo0ODoyM1rOGX1R-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMjo0ODoyM1rOGX1R-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MzM4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * <p>This transform is optimized for dynamic splitting of message.list calls for large batches of\n          \n          \n            \n               * <p>This transform is optimized for splitting of message.list calls for large batches of", "url": "https://github.com/apache/beam/pull/11596#discussion_r427643387", "createdAt": "2020-05-19T22:48:23Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -415,10 +423,29 @@ private Message fetchMessage(HealthcareApiClient client, String msgId)\n     }\n   }\n \n-  /** List HL7v2 messages in HL7v2 Stores with optional filter. */\n+  /**\n+   * List HL7v2 messages in HL7v2 Stores with optional filter.\n+   *\n+   * <p>This transform is optimized for dynamic splitting of message.list calls for large batches of", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32d0bf08188aaadb36ea7efcb944a1ed5ec23898"}, "originalPosition": 62}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5033f23d087d9d910f10a4749d53e2eb6628d9c0", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/5033f23d087d9d910f10a4749d53e2eb6628d9c0", "committedDate": "2020-05-19T22:56:17Z", "message": "Update sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java\n\nCo-authored-by: Lukasz Cwik <lcwik@google.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c47fe42b355f603e6066c9f37db2e27420a6347b", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/c47fe42b355f603e6066c9f37db2e27420a6347b", "committedDate": "2020-05-20T01:00:01Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2af9ae6674f654aa34bb9234b2513f668fd62eee", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/2af9ae6674f654aa34bb9234b2513f668fd62eee", "committedDate": "2020-05-20T01:09:59Z", "message": "Merge branch 'optimization/HL7v2IOListMessages' of github.com:jaketf/beam into optimization/HL7v2IOListMessages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b39ce7c7347732ce514296f53aefd0422501226", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/0b39ce7c7347732ce514296f53aefd0422501226", "committedDate": "2020-05-20T01:18:59Z", "message": "address review feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1502824158e87c35b7615287cd40237add4eb378", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/1502824158e87c35b7615287cd40237add4eb378", "committedDate": "2020-05-20T06:59:01Z", "message": "fix mocked method in test and checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efe64bef8fd3cfa91ad8ebbce25492c209f8bdc4", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/efe64bef8fd3cfa91ad8ebbce25492c209f8bdc4", "committedDate": "2020-05-20T07:27:47Z", "message": "remove unused metric"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NDQ0MDc1", "url": "https://github.com/apache/beam/pull/11596#pullrequestreview-415444075", "createdAt": "2020-05-20T15:15:44Z", "commit": {"oid": "efe64bef8fd3cfa91ad8ebbce25492c209f8bdc4"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNToxNTo0NFrOGYQ3ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNToyODozMFrOGYRczg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA5NTM5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (cursor.getMillis() > lastClaimedMilliSecond && tracker.tryClaim(cursor.getMillis())) {\n          \n          \n            \n                      lastClaimedMilliSecond = cursor.getMillis();\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    if (cursor.getMillis() == lastClaimedMilliSecond) { // loop over messages in millisecond.\n          \n          \n            \n                      outputReceiver.output(msg);\n          \n          \n            \n                    }\n          \n          \n            \n                    if (cursor.getMillis() > lastClaimedMilliSecond) {\n          \n          \n            \n                      // Return early after the first claim failure preventing us from iterating\n          \n          \n            \n                      // through the remaining messages.\n          \n          \n            \n                      if (!tracker.tryClaim(cursor.getMillis())) {\n          \n          \n            \n                        return;\n          \n          \n            \n                      }\n          \n          \n            \n                      lastClaimedMilliSecond = cursor.getMillis();\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    outputReceiver.output(msg);", "url": "https://github.com/apache/beam/pull/11596#discussion_r428095390", "createdAt": "2020-05-20T15:15:44Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -472,24 +523,77 @@ public void initClient() throws IOException {\n       this.client = new HttpHealthcareApiClient();\n     }\n \n+    @GetInitialRestriction\n+    public OffsetRange getEarliestToLatestRestriction(@Element String hl7v2Store)\n+        throws IOException {\n+      from = this.client.getEarliestHL7v2SendTime(hl7v2Store, this.filter.get());\n+      // filters are [from, to) to match logic of OffsetRangeTracker but need latest element to be\n+      // included in results set to add an extra ms to the upper bound.\n+      to = this.client.getLatestHL7v2SendTime(hl7v2Store, this.filter.get()).plus(1);\n+      return new OffsetRange(from.getMillis(), to.getMillis());\n+    }\n+\n+    @SplitRestriction\n+    public void split(@Restriction OffsetRange timeRange, OutputReceiver<OffsetRange> out) {\n+      List<OffsetRange> splits =\n+          timeRange.split(initialSplitDuration.getMillis(), DEFAULT_MIN_SPLIT_DURATION.getMillis());\n+      Instant from = Instant.ofEpochMilli(timeRange.getFrom());\n+      Instant to = Instant.ofEpochMilli(timeRange.getTo());\n+      Duration totalDuration = new Duration(from, to);\n+      LOG.info(\n+          String.format(\n+              \"splitting initial sendTime restriction of [minSendTime, now): [%s,%s), \"\n+                  + \"or [%s, %s). \\n\"\n+                  + \"total days: %s \\n\"\n+                  + \"into %s splits. \\n\"\n+                  + \"Last split: %s\",\n+              from,\n+              to,\n+              timeRange.getFrom(),\n+              timeRange.getTo(),\n+              totalDuration.getStandardDays(),\n+              splits.size(),\n+              splits.get(splits.size() - 1).toString()));\n+\n+      for (OffsetRange s : splits) {\n+        out.output(s);\n+      }\n+    }\n+\n     /**\n      * List messages.\n      *\n-     * @param context the context\n+     * @param hl7v2Store the HL7v2 store to list messages from\n      * @throws IOException the io exception\n      */\n     @ProcessElement\n-    public void listMessages(ProcessContext context) throws IOException {\n-      String hl7v2Store = context.element();\n-      // Output all elements of all pages.\n+    public void listMessages(\n+        @Element String hl7v2Store,\n+        RestrictionTracker<OffsetRange, Long> tracker,\n+        OutputReceiver<HL7v2Message> outputReceiver)\n+        throws IOException {\n+      OffsetRange currentRestriction = (OffsetRange) tracker.currentRestriction();\n+      Instant startRestriction = Instant.ofEpochMilli(currentRestriction.getFrom());\n+      Instant endRestriction = Instant.ofEpochMilli(currentRestriction.getTo());\n       HttpHealthcareApiClient.HL7v2MessagePages pages =\n-          new HttpHealthcareApiClient.HL7v2MessagePages(client, hl7v2Store, this.filter);\n-      long reqestTime = Instant.now().getMillis();\n-      for (Stream<HL7v2Message> page : pages) {\n-        messageListingLatencyMs.update(Instant.now().getMillis() - reqestTime);\n-        page.forEach(context::output);\n-        reqestTime = Instant.now().getMillis();\n+          new HttpHealthcareApiClient.HL7v2MessagePages(\n+              client, hl7v2Store, startRestriction, endRestriction, filter.get(), \"sendTime\");\n+      Instant cursor;\n+      long lastClaimedMilliSecond = startRestriction.getMillis() - 1;\n+      for (HL7v2Message msg : FluentIterable.concat(pages)) {\n+        cursor = Instant.parse(msg.getSendTime());\n+        if (cursor.getMillis() > lastClaimedMilliSecond && tracker.tryClaim(cursor.getMillis())) {\n+          lastClaimedMilliSecond = cursor.getMillis();\n+        }\n+\n+        if (cursor.getMillis() == lastClaimedMilliSecond) { // loop over messages in millisecond.\n+          outputReceiver.output(msg);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe64bef8fd3cfa91ad8ebbce25492c209f8bdc4"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEwNDkxMA==", "bodyText": "Yes we can defer since this would change what people are getting from the existing implementation and would likely require opt in to not break any existing users.\nIf nobody depends on this transform yet then it would be wise to address it before adoption since a lot of users typically expect the output timestamp to match the record's source timestamp. This may not apply to this specific source and is dependent on what users expect so itis your judgement call.\nIf you do go with changing the output timestamp, the watermark tracking would help for streaming pipelines since it would allow them to perform better. The current implementation would still produce correct results with or without and adding it later would be very safe (it may expose problems in pipelines that were already broken for other reasons).", "url": "https://github.com/apache/beam/pull/11596#discussion_r428104910", "createdAt": "2020-05-20T15:28:30Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -472,24 +551,118 @@ public void initClient() throws IOException {\n       this.client = new HttpHealthcareApiClient();\n     }\n \n+    @GetInitialRestriction\n+    public OffsetRange getEarliestToLatestRestriction(@Element String hl7v2Store)\n+        throws IOException {\n+      from = this.client.getEarliestHL7v2SendTime(hl7v2Store, this.filter.get());\n+      // filters are [from, to) to match logic of OffsetRangeTracker but need latest element to be\n+      // included in results set to add an extra ms to the upper bound.\n+      to = this.client.getLatestHL7v2SendTime(hl7v2Store, this.filter.get()).plus(1);\n+      return new OffsetRange(from.getMillis(), to.getMillis());\n+    }\n+\n+    @NewTracker\n+    public OffsetRangeTracker newTracker(@Restriction OffsetRange timeRange) {\n+      return timeRange.newTracker();\n+    }\n+\n+    @SplitRestriction\n+    public void split(@Restriction OffsetRange timeRange, OutputReceiver<OffsetRange> out) {\n+      List<OffsetRange> splits =\n+          timeRange.split(initialSplitDuration.getMillis(), DEFAULT_MIN_SPLIT_DURATION.getMillis());\n+      Instant from = Instant.ofEpochMilli(timeRange.getFrom());\n+      Instant to = Instant.ofEpochMilli(timeRange.getTo());\n+      Duration totalDuration = new Duration(from, to);\n+      LOG.info(\n+          String.format(\n+              \"splitting initial sendTime restriction of [minSendTime, now): [%s,%s), \"\n+                  + \"or [%s, %s). \\n\"\n+                  + \"total days: %s \\n\"\n+                  + \"into %s splits. \\n\"\n+                  + \"Last split: %s\",\n+              from,\n+              to,\n+              timeRange.getFrom(),\n+              timeRange.getTo(),\n+              totalDuration.getStandardDays(),\n+              splits.size(),\n+              splits.get(splits.size() - 1).toString()));\n+\n+      for (OffsetRange s : splits) {\n+        out.output(s);\n+      }\n+    }\n+\n     /**\n      * List messages.\n      *\n-     * @param context the context\n+     * @param hl7v2Store the HL7v2 store to list messages from\n      * @throws IOException the io exception\n      */\n     @ProcessElement\n-    public void listMessages(ProcessContext context) throws IOException {\n-      String hl7v2Store = context.element();\n-      // Output all elements of all pages.\n+    public void listMessages(\n+        @Element String hl7v2Store,\n+        RestrictionTracker tracker,\n+        OutputReceiver<HL7v2Message> outputReceiver)\n+        throws IOException {\n+      OffsetRange currentRestriction = (OffsetRange) tracker.currentRestriction();\n+      Instant startRestriction = Instant.ofEpochMilli(currentRestriction.getFrom());\n+      Instant endRestriction = Instant.ofEpochMilli(currentRestriction.getTo());\n       HttpHealthcareApiClient.HL7v2MessagePages pages =\n-          new HttpHealthcareApiClient.HL7v2MessagePages(client, hl7v2Store, this.filter);\n+          new HttpHealthcareApiClient.HL7v2MessagePages(\n+              client, hl7v2Store, startRestriction, endRestriction, filter.get(), \"sendTime\");\n       long reqestTime = Instant.now().getMillis();\n-      for (Stream<HL7v2Message> page : pages) {\n+      long lastClaimedMilliSecond;\n+      Instant cursor;\n+      boolean hangingClaim = false; // flag if the claimed ms spans spills over to the next page.\n+      for (List<HL7v2Message> page : pages) { // loop over pages.\n+        int i = 0;\n+        HL7v2Message msg = page.get(i);\n+        while (i < page.size()) { // loop over messages in page\n+          cursor = Instant.parse(msg.getSendTime());\n+          lastClaimedMilliSecond = cursor.getMillis();\n+          LOG.info(\n+              String.format(\n+                  \"initial claim for page %s lastClaimedMilliSecond = %s\",\n+                  i, lastClaimedMilliSecond));\n+          if (hangingClaim || tracker.tryClaim(lastClaimedMilliSecond)) {\n+            // This means we have claimed an entire millisecond we need to make sure that we\n+            // process all messages for this millisecond because sendTime is allegedly nano second\n+            // resolution.\n+            // https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.hl7V2Stores.messages#Message\n+            while (cursor.getMillis() == lastClaimedMilliSecond\n+                && i < page.size()) { // loop over messages in millisecond.\n+              outputReceiver.output(msg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYzMzI0MA=="}, "originalCommit": {"oid": "32d0bf08188aaadb36ea7efcb944a1ed5ec23898"}, "originalPosition": 274}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NDYwMDEz", "url": "https://github.com/apache/beam/pull/11596#pullrequestreview-415460013", "createdAt": "2020-05-20T15:32:03Z", "commit": {"oid": "efe64bef8fd3cfa91ad8ebbce25492c209f8bdc4"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNTozMjowM1rOGYRndA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNTozMzoyMVrOGYRrBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEwNzYzNg==", "bodyText": "from and to seem to only be used within @GetInitialRestriction, can we make them local variables there?", "url": "https://github.com/apache/beam/pull/11596#discussion_r428107636", "createdAt": "2020-05-20T15:32:03Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -427,39 +458,59 @@ private Message fetchMessage(HealthcareApiClient client, String msgId)\n      * @param filter the filter\n      */\n     ListHL7v2Messages(ValueProvider<List<String>> hl7v2Stores, ValueProvider<String> filter) {\n-      this.hl7v2Stores = hl7v2Stores.get();\n-      this.filter = filter.get();\n+      this.hl7v2Stores = hl7v2Stores;\n+      this.filter = filter;\n+      this.initialSplitDuration = null;\n     }\n \n-    ListHL7v2Messages(ValueProvider<List<String>> hl7v2Stores) {\n-      this.hl7v2Stores = hl7v2Stores.get();\n-      this.filter = null;\n+    public ListHL7v2Messages withInitialSplitDuration(Duration initialSplitDuration) {\n+      this.initialSplitDuration = initialSplitDuration;\n+      return this;\n     }\n \n     @Override\n     public PCollection<HL7v2Message> expand(PBegin input) {\n       return input\n-          .apply(Create.of(this.hl7v2Stores))\n-          .apply(ParDo.of(new ListHL7v2MessagesFn(this.filter)))\n-          .setCoder(new HL7v2MessageCoder())\n+          .apply(Create.ofProvider(this.hl7v2Stores, ListCoder.of(StringUtf8Coder.of())))\n+          .apply(FlatMapElements.into(TypeDescriptors.strings()).via((x) -> x))\n+          .apply(ParDo.of(new ListHL7v2MessagesFn(filter, initialSplitDuration)))\n+          .setCoder(HL7v2MessageCoder.of())\n           // Break fusion to encourage parallelization of downstream processing.\n           .apply(Reshuffle.viaRandomKey());\n     }\n   }\n \n+  /**\n+   * Implemented as Splitable DoFn that claims millisecond resolutions of offset restrictions in the\n+   * Message.sendTime dimension.\n+   */\n+  @BoundedPerElement\n+  @VisibleForTesting\n   static class ListHL7v2MessagesFn extends DoFn<String, HL7v2Message> {\n-\n-    private final String filter;\n+    // These control the initial restriction split which means that the list of integer pairs\n+    // must comfortably fit in memory.\n+    private static final Duration DEFAULT_DESIRED_SPLIT_DURATION = Duration.standardDays(1);\n+    private static final Duration DEFAULT_MIN_SPLIT_DURATION = Duration.standardHours(1);\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(ListHL7v2MessagesFn.class);\n+    private ValueProvider<String> filter;\n+    private Duration initialSplitDuration;\n+    private Instant from;\n+    private Instant to;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe64bef8fd3cfa91ad8ebbce25492c209f8bdc4"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEwODU0OQ==", "bodyText": "Benchmarking By?\nAwkward sentence and capitalization.", "url": "https://github.com/apache/beam/pull/11596#discussion_r428108549", "createdAt": "2020-05-20T15:33:21Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java", "diffHunk": "@@ -415,10 +424,32 @@ private Message fetchMessage(HealthcareApiClient client, String msgId)\n     }\n   }\n \n-  /** List HL7v2 messages in HL7v2 Stores with optional filter. */\n+  /**\n+   * List HL7v2 messages in HL7v2 Stores with optional filter.\n+   *\n+   * <p>This transform is optimized for splitting of message.list calls for large batches of\n+   * historical data and assumes rather continuous stream of sendTimes.\n+   *\n+   * <p>Note on Benchmarking By default, this will make more queries than necessary when used with", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe64bef8fd3cfa91ad8ebbce25492c209f8bdc4"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NDYzMzMx", "url": "https://github.com/apache/beam/pull/11596#pullrequestreview-415463331", "createdAt": "2020-05-20T15:35:27Z", "commit": {"oid": "efe64bef8fd3cfa91ad8ebbce25492c209f8bdc4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d94b4b67a8fba7ef8dd2425ce7d7a683b568fce", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/1d94b4b67a8fba7ef8dd2425ce7d7a683b568fce", "committedDate": "2020-05-20T16:01:52Z", "message": "Update sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2IO.java\n\nCo-authored-by: Lukasz Cwik <lcwik@google.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "495865628421d75952269537a303dfd765b09bc2", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/495865628421d75952269537a303dfd765b09bc2", "committedDate": "2020-05-20T16:11:25Z", "message": "incorporate review feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad57111e4ff59f1217520566d98da01ca3d8e390", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/ad57111e4ff59f1217520566d98da01ca3d8e390", "committedDate": "2020-05-20T16:12:13Z", "message": "Merge branch 'optimization/HL7v2IOListMessages' of github.com:jaketf/beam into optimization/HL7v2IOListMessages"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4167, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}