{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY4MTg2MTU5", "number": 12588, "title": "[BEAM-7009] Add Go SDK Standard Coders yaml tests.", "bodyText": "This PR has the Go SDK join Java and Python in having its coders tested against the standard_coder.yaml suite.\n\nIt adds representation markers for standard types that previously didn't have representation (such as iterables, rows, length prefixes, etc) in the graph/coder package.\nIt adds execution wrappers for encoding, decoding those values in the exec package.\nIt adds serialization support for these representations in the graphx package.\nAdds hashing support for row coded values.\n\nTesting of the code here is largely through the newly introduced fromyaml test harness which reads standard_coder.yaml and helps it along a touch, in particular in how to interpret the yaml versions of expected structures, which don't map to go types exactly.\nWhile this PR plumbs in Timers and ParamWindowCoders, these coders are not implemented in the SDK at this time, and those tests are skipped.  At best, the implementation is vestigial, but leaving them wholely unimplemented caused certain difficulties with the standard yaml test.\nSimilarly, while Windows are now fully plumbed through the stack, this is largely for convenience when testing those codings vs the standard_coders.yaml file.\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nDataflow\nFlink\nSamza\nSpark\nTwister2\n\n\n\n\nGo\n\n---\n\n---\n\n---\n\n\nJava\n\n\n\n\n\n\n\n\nPython\n\n\n\n---\n\n---\n\n\nXLang\n\n---\n\n---\n\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.\nGitHub Actions Tests Status (on master branch)\n\nSee CI.md for more information about GitHub Actions CI.", "createdAt": "2020-08-14T21:15:29Z", "url": "https://github.com/apache/beam/pull/12588", "merged": true, "mergeCommit": {"oid": "0a1ab6941e5a9ce67dfcf1d0a27317fdcaf34c27"}, "closed": true, "closedAt": "2020-09-16T20:50:36Z", "author": {"login": "lostluck"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc_4Y9-ABqjM2NjM0ODYzNTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJiDq0AH2gAyNDY4MTg2MTU5OjRkNWVhYTJmYTdiNDE2ZTU0ZjE0YjM3MTM1MDBmYzIwZDNhZmRlYTg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "af653dd5063f5b1536f50ba11f84709c48ab6cbc", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/af653dd5063f5b1536f50ba11f84709c48ab6cbc", "committedDate": "2020-08-14T20:55:07Z", "message": "[BEAM-7009] Add Go SDK Standard Coders yaml tests."}, "afterCommit": {"oid": "3681911c4dd3f222060024a4ed4e0bb64ee98bbc", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/3681911c4dd3f222060024a4ed4e0bb64ee98bbc", "committedDate": "2020-08-17T20:24:37Z", "message": "[BEAM-7009] Add Go SDK Standard Coders yaml tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a3715c97452a85d6b2c60719ce6cf0326affdb1", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/1a3715c97452a85d6b2c60719ce6cf0326affdb1", "committedDate": "2020-09-09T17:45:26Z", "message": "[BEAM-7009] Add Go SDK Standard Coders yaml tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/01095f0d676d93c83a0c48e043bcbf3deb914f45", "committedDate": "2020-09-09T19:40:29Z", "message": "[BEAM-7009] Update gogradle.lock"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3681911c4dd3f222060024a4ed4e0bb64ee98bbc", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/3681911c4dd3f222060024a4ed4e0bb64ee98bbc", "committedDate": "2020-08-17T20:24:37Z", "message": "[BEAM-7009] Add Go SDK Standard Coders yaml tests."}, "afterCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/01095f0d676d93c83a0c48e043bcbf3deb914f45", "committedDate": "2020-09-09T19:40:29Z", "message": "[BEAM-7009] Update gogradle.lock"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2NDQyNzc1", "url": "https://github.com/apache/beam/pull/12588#pullrequestreview-486442775", "createdAt": "2020-09-11T03:05:52Z", "commit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMzowNTo1MlrOHQMpdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDo0MjowNFrOHQxKyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0NjQ4Nw==", "bodyText": "Looks like a debug Println left in.", "url": "https://github.com/apache/beam/pull/12588#discussion_r486746487", "createdAt": "2020-09-11T03:05:52Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/graphx/coder.go", "diffHunk": "@@ -249,31 +256,35 @@ func (b *CoderUnmarshaller) makeCoder(c *pipepb.Coder) (*coder.Coder, error) {\n \t\t\treturn nil, err\n \t\t}\n \n-\t\t// No payload means this coder was length prefixed by the runner\n-\t\t// but is likely self describing - AKA a beam coder.\n-\t\tif len(sub.GetSpec().GetPayload()) == 0 {\n-\t\t\treturn b.makeCoder(sub)\n-\t\t}\n \t\t// TODO(lostluck) 2018/10/17: Make this strict again, once dataflow can use\n \t\t// the portable pipeline model directly (BEAM-2885)\n-\t\tif sub.GetSpec().GetUrn() != \"\" && sub.GetSpec().GetUrn() != urnCustomCoder {\n-\t\t\t// TODO(herohde) 11/17/2017: revisit this restriction\n-\t\t\treturn nil, errors.Errorf(\"could not unmarshal length prefix coder from %v, want a custom coder as a sub component but got %v\", c, sub)\n-\t\t}\n-\n-\t\tvar ref v1pb.CustomCoder\n-\t\tif err := protox.DecodeBase64(string(sub.GetSpec().GetPayload()), &ref); err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tcustom, err := decodeCustomCoder(&ref)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n+\t\tswitch u := sub.GetSpec().GetUrn(); u {\n+\t\tcase \"\", urnCustomCoder:\n+\t\t\tvar ref v1pb.CustomCoder\n+\t\t\tif err := protox.DecodeBase64(string(sub.GetSpec().GetPayload()), &ref); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tcustom, err := decodeCustomCoder(&ref)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tcustom.ID = components[0]\n+\t\t\tt := typex.New(custom.Type)\n+\t\t\tcc := &coder.Coder{Kind: coder.Custom, T: t, Custom: custom}\n+\t\t\tfmt.Println(\"decoded customcoder\", cc)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2NzcwNA==", "bodyText": "I don't really understand this comment, or how it relates to the check below.", "url": "https://github.com/apache/beam/pull/12588#discussion_r486767704", "createdAt": "2020-09-11T04:34:08Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -81,24 +82,82 @@ func MakeElementEncoder(c *coder.Coder) ElementEncoder {\n \t\treturn &stringEncoder{}\n \n \tcase coder.Custom:\n-\t\treturn &customEncoder{\n+\t\tenc := &customEncoder{\n \t\t\tt:   c.Custom.Type,\n \t\t\tenc: makeEncoder(c.Custom.Enc.Fn),\n \t\t}\n+\t\tif c.Custom.Name != \"schema\" {\n+\t\t\treturn enc\n+\t\t}\n+\t\t// Custom schema coding is shorthand for using beam infrastructure\n+\t\t// wrapped in a custom coder.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc3NTU2NA==", "bodyText": "Looks like another debug println.", "url": "https://github.com/apache/beam/pull/12588#discussion_r486775564", "createdAt": "2020-09-11T05:05:17Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -117,17 +176,88 @@ func MakeElementDecoder(c *coder.Coder) ElementDecoder {\n \t\treturn &stringDecoder{}\n \n \tcase coder.Custom:\n-\t\treturn &customDecoder{\n+\t\tdec := &customDecoder{\n \t\t\tt:   c.Custom.Type,\n \t\t\tdec: makeDecoder(c.Custom.Dec.Fn),\n \t\t}\n \n+\t\tfmt.Println(\"getting decoder\", c.Custom)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc3ODE1NQ==", "bodyText": "Just to confirm, using an arrayDecoder without an arrayEncoder specifically works because the format that iterableEncoder encodes to is also decodable as an array, right? That might be worth mentioning as a comment, because I was wondering why you can decode arrays with an arrayDecoder if they were encoded with an iterableEncoder.", "url": "https://github.com/apache/beam/pull/12588#discussion_r486778155", "createdAt": "2020-09-11T05:14:58Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -117,17 +176,88 @@ func MakeElementDecoder(c *coder.Coder) ElementDecoder {\n \t\treturn &stringDecoder{}\n \n \tcase coder.Custom:\n-\t\treturn &customDecoder{\n+\t\tdec := &customDecoder{\n \t\t\tt:   c.Custom.Type,\n \t\t\tdec: makeDecoder(c.Custom.Dec.Fn),\n \t\t}\n \n+\t\tfmt.Println(\"getting decoder\", c.Custom)\n+\t\tif c.Custom.Name != \"schema\" {\n+\t\t\treturn dec\n+\t\t}\n+\t\t// Custom schema coding is shorthand for using beam infrastructure\n+\t\t// wrapped in a custom coder.\n+\t\tswitch c.T.Type().Kind() {\n+\t\tcase reflect.Slice:\n+\t\t\treturn &lpDecoder{\n+\t\t\t\tdec: &iterableDecoder{\n+\t\t\t\t\tt:   c.Custom.Type,\n+\t\t\t\t\tdec: dec,\n+\t\t\t\t},\n+\t\t\t}\n+\t\tcase reflect.Array:\n+\t\t\treturn &lpDecoder{\n+\t\t\t\tdec: &arrayDecoder{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc4MTc0Ng==", "bodyText": "Is it necessary to cast n to an int here? Isn't it already an int from line 638?", "url": "https://github.com/apache/beam/pull/12588#discussion_r486781746", "createdAt": "2020-09-11T05:28:19Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -434,6 +600,267 @@ func convertIfNeeded(v interface{}, allocated *FullValue) *FullValue {\n \treturn allocated\n }\n \n+type iterableEncoder struct {\n+\tt   reflect.Type\n+\tenc ElementEncoder\n+}\n+\n+func (c *iterableEncoder) Encode(val *FullValue, w io.Writer) error {\n+\t// Do a reflect, get the length.\n+\trv := reflect.ValueOf(val.Elm)\n+\tsize := rv.Len()\n+\tif err := coder.EncodeInt32((int32)(size), w); err != nil {\n+\t\treturn err\n+\t}\n+\tvar e FullValue\n+\tfor i := 0; i < size; i++ {\n+\t\te.Elm = rv.Index(i).Interface()\n+\t\terr := c.enc.Encode(&e, w)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+type iterableDecoder struct {\n+\tt   reflect.Type\n+\tdec ElementDecoder\n+}\n+\n+func (c *iterableDecoder) DecodeTo(r io.Reader, fv *FullValue) error {\n+\t// (1) Read count prefixed encoded data\n+\n+\tsize, err := coder.DecodeInt32(r)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tn := int(size)\n+\tswitch {\n+\tcase n >= 0:\n+\t\trv, err := c.decodeToSlice(int(n), r)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 337}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc4MjM1OA==", "bodyText": "Likewise, is it necessary to cast n here too?", "url": "https://github.com/apache/beam/pull/12588#discussion_r486782358", "createdAt": "2020-09-11T05:30:35Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -434,6 +600,267 @@ func convertIfNeeded(v interface{}, allocated *FullValue) *FullValue {\n \treturn allocated\n }\n \n+type iterableEncoder struct {\n+\tt   reflect.Type\n+\tenc ElementEncoder\n+}\n+\n+func (c *iterableEncoder) Encode(val *FullValue, w io.Writer) error {\n+\t// Do a reflect, get the length.\n+\trv := reflect.ValueOf(val.Elm)\n+\tsize := rv.Len()\n+\tif err := coder.EncodeInt32((int32)(size), w); err != nil {\n+\t\treturn err\n+\t}\n+\tvar e FullValue\n+\tfor i := 0; i < size; i++ {\n+\t\te.Elm = rv.Index(i).Interface()\n+\t\terr := c.enc.Encode(&e, w)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+type iterableDecoder struct {\n+\tt   reflect.Type\n+\tdec ElementDecoder\n+}\n+\n+func (c *iterableDecoder) DecodeTo(r io.Reader, fv *FullValue) error {\n+\t// (1) Read count prefixed encoded data\n+\n+\tsize, err := coder.DecodeInt32(r)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tn := int(size)\n+\tswitch {\n+\tcase n >= 0:\n+\t\trv, err := c.decodeToSlice(int(n), r)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*fv = FullValue{Elm: rv.Interface()}\n+\t\treturn nil\n+\tcase n == -1:\n+\t\trv := reflect.MakeSlice(c.t, 0, 0)\n+\t\tchunk, err := coder.DecodeVarInt(r)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tfor chunk != 0 {\n+\t\t\trvi, err := c.decodeToSlice(int(chunk), r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\trv = reflect.AppendSlice(rv, rvi)\n+\t\t\tchunk, err = coder.DecodeVarInt(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t\t*fv = FullValue{Elm: rv.Interface()}\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (c *iterableDecoder) decodeToSlice(n int, r io.Reader) (reflect.Value, error) {\n+\tvar e FullValue\n+\trv := reflect.MakeSlice(c.t, n, n)\n+\tfor i := 0; i < int(n); i++ {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 369}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc4MzE2NQ==", "bodyText": "I don't get why it's setting the value of the element to e.Windows[0]. Is it a way to pass in nil?", "url": "https://github.com/apache/beam/pull/12588#discussion_r486783165", "createdAt": "2020-09-11T05:33:36Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -434,6 +600,267 @@ func convertIfNeeded(v interface{}, allocated *FullValue) *FullValue {\n \treturn allocated\n }\n \n+type iterableEncoder struct {\n+\tt   reflect.Type\n+\tenc ElementEncoder\n+}\n+\n+func (c *iterableEncoder) Encode(val *FullValue, w io.Writer) error {\n+\t// Do a reflect, get the length.\n+\trv := reflect.ValueOf(val.Elm)\n+\tsize := rv.Len()\n+\tif err := coder.EncodeInt32((int32)(size), w); err != nil {\n+\t\treturn err\n+\t}\n+\tvar e FullValue\n+\tfor i := 0; i < size; i++ {\n+\t\te.Elm = rv.Index(i).Interface()\n+\t\terr := c.enc.Encode(&e, w)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+type iterableDecoder struct {\n+\tt   reflect.Type\n+\tdec ElementDecoder\n+}\n+\n+func (c *iterableDecoder) DecodeTo(r io.Reader, fv *FullValue) error {\n+\t// (1) Read count prefixed encoded data\n+\n+\tsize, err := coder.DecodeInt32(r)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tn := int(size)\n+\tswitch {\n+\tcase n >= 0:\n+\t\trv, err := c.decodeToSlice(int(n), r)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*fv = FullValue{Elm: rv.Interface()}\n+\t\treturn nil\n+\tcase n == -1:\n+\t\trv := reflect.MakeSlice(c.t, 0, 0)\n+\t\tchunk, err := coder.DecodeVarInt(r)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tfor chunk != 0 {\n+\t\t\trvi, err := c.decodeToSlice(int(chunk), r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\trv = reflect.AppendSlice(rv, rvi)\n+\t\t\tchunk, err = coder.DecodeVarInt(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t\t*fv = FullValue{Elm: rv.Interface()}\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (c *iterableDecoder) decodeToSlice(n int, r io.Reader) (reflect.Value, error) {\n+\tvar e FullValue\n+\trv := reflect.MakeSlice(c.t, n, n)\n+\tfor i := 0; i < int(n); i++ {\n+\t\terr := c.dec.DecodeTo(r, &e)\n+\t\tif err != nil {\n+\t\t\treturn reflect.Value{}, err\n+\t\t}\n+\t\tif e.Elm != nil {\n+\t\t\trv.Index(i).Set(reflect.ValueOf(e.Elm))\n+\t\t} else {\n+\t\t\trv.Index(i).Set(reflect.ValueOf(e.Windows[0]))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 377}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMzMDI0Ng==", "bodyText": "What's the reason to switch from DecodeVarUint64 to DecodeVarInt here?", "url": "https://github.com/apache/beam/pull/12588#discussion_r487330246", "createdAt": "2020-09-11T23:21:29Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -534,26 +1038,34 @@ func (*intervalWindowEncoder) EncodeSingle(elm typex.Window, w io.Writer) error\n \n type intervalWindowDecoder struct{}\n \n-func (*intervalWindowDecoder) Decode(r io.Reader) ([]typex.Window, error) {\n+func (d *intervalWindowDecoder) Decode(r io.Reader) ([]typex.Window, error) {\n \t// Encoding: upper bound and duration\n \n \tn, err := coder.DecodeInt32(r) // #windows\n \n \tret := make([]typex.Window, n, n)\n \tfor i := int32(0); i < n; i++ {\n-\t\tend, err := coder.DecodeEventTime(r)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tduration, err := coder.DecodeVarUint64(r)\n+\t\tw, err := d.DecodeSingle(r)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tret[i] = window.IntervalWindow{Start: mtime.FromMilliseconds(end.Milliseconds() - int64(duration)), End: end}\n+\t\tret[i] = w\n \t}\n \treturn ret, err\n }\n \n+func (*intervalWindowDecoder) DecodeSingle(r io.Reader) (typex.Window, error) {\n+\tend, err := coder.DecodeEventTime(r)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tduration, err := coder.DecodeVarInt(r)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 709}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDg0Mg==", "bodyText": "Is this assumption made specifically based on the yaml file this is meant to be used with? Or is this based on something in the schema spec I'm forgetting?", "url": "https://github.com/apache/beam/pull/12588#discussion_r487344842", "createdAt": "2020-09-12T00:42:04Z", "author": {"login": "youngoli"}, "path": "sdks/go/test/regression/coders/fromyaml/fromyaml.go", "diffHunk": "@@ -0,0 +1,415 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// fromyaml generates a resource file from the standard_coders.yaml\n+// file for use in these coder regression tests.\n+//\n+// It expects to be run in it's test directory, or via it's go test.\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"math\"\n+\t\"reflect\"\n+\t\"runtime/debug\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/mtime\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/window\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/exec\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/graphx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/reflectx\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+\t\"github.com/google/go-cmp/cmp\"\n+\t\"golang.org/x/text/encoding/charmap\"\n+\tyaml \"gopkg.in/yaml.v2\"\n+)\n+\n+var unimplementedCoders = map[string]bool{\n+\t\"beam:coder:param_windowed_value:v1\": true,\n+\t\"beam:coder:timer:v1\":                true,\n+}\n+\n+// Coder is a representation a serialized beam coder.\n+type Coder struct {\n+\tUrn              string  `yaml:\"urn,omitempty\"`\n+\tPayload          string  `yaml:\"payload,omitempty\"`\n+\tComponents       []Coder `yaml:\"components,omitempty\"`\n+\tNonDeterministic bool    `yaml:\"non_deterministic,omitempty\"`\n+}\n+\n+type logger interface {\n+\tErrorf(string, ...interface{})\n+\tLogf(string, ...interface{})\n+}\n+\n+// Spec is a set of conditions that a coder must pass.\n+type Spec struct {\n+\tCoder    Coder         `yaml:\"coder,omitempty\"`\n+\tNested   *bool         `yaml:\"nested,omitempty\"`\n+\tExamples yaml.MapSlice `yaml:\"examples,omitempty\"`\n+\tLog      logger\n+\n+\tid       int // for generating coder ids.\n+\tcoderPBs map[string]*pipepb.Coder\n+}\n+\n+func (s *Spec) nextID() string {\n+\tret := fmt.Sprintf(\"%d\", s.id)\n+\ts.id++\n+\treturn ret\n+}\n+\n+func (s *Spec) testStandardCoder() (err error) {\n+\tif unimplementedCoders[s.Coder.Urn] {\n+\t\tlog.Printf(\"skipping unimplemented coder urn: %v\", s.Coder.Urn)\n+\t\treturn nil\n+\t}\n+\t// Construct the coder proto equivalents.\n+\n+\t// Only nested tests need to be run, since nestedness is a pre-portability\n+\t// concept.\n+\t// For legacy Java reasons, the row coder examples are all marked nested: false\n+\t// so we need to check that before skipping unnested tests.\n+\tif s.Coder.Urn != \"beam:coder:row:v1\" && s.Nested != nil && !*s.Nested {\n+\t\tlog.Printf(\"skipping unnested coder spec: %v\\n\", s.Coder)\n+\t\treturn nil\n+\t}\n+\n+\ts.coderPBs = make(map[string]*pipepb.Coder)\n+\tid := s.parseCoder(s.Coder)\n+\tb := graphx.NewCoderUnmarshaller(s.coderPBs)\n+\tunderTest, err := b.Coder(id)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"unable to create coder: %v\", err)\n+\t}\n+\n+\tdefer func() {\n+\t\tif e := recover(); e != nil {\n+\t\t\terr = fmt.Errorf(\"panicked on coder %v || %v:\\n\\t%v :\\n%s\", underTest, s.Coder, e, debug.Stack())\n+\t\t}\n+\t}()\n+\n+\tvar decFails, encFails int\n+\tfor _, eg := range s.Examples {\n+\n+\t\t// Test Decoding\n+\t\t// Ideally we'd use the beam package coders, but KVs make that complicated.\n+\t\t// This can be cleaned up once a type parametered beam.KV type exists.\n+\t\tdec := exec.MakeElementDecoder(underTest)\n+\t\tencoded := eg.Key.(string)\n+\t\tvar elem exec.FullValue\n+\n+\t\t// What I would have expected.\n+\t\t//\t\tr := charmap.ISO8859_1.NewDecoder().Reader(strings.NewReader(encoded))\n+\t\trecoded, err := charmap.ISO8859_1.NewEncoder().String(encoded)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tr := strings.NewReader(recoded)\n+\t\tif err := dec.DecodeTo(r, &elem); err != nil {\n+\t\t\treturn fmt.Errorf(\"err decoding %q: %v\", encoded, err)\n+\t\t}\n+\t\tif !diff(s.Coder, &elem, eg) {\n+\t\t\tdecFails++\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Test Encoding\n+\t\tif s.Coder.NonDeterministic {\n+\t\t\t// Skip verifying nondeterministic encodings.\n+\t\t\tcontinue\n+\t\t}\n+\t\tenc := exec.MakeElementEncoder(underTest)\n+\t\tvar out bytes.Buffer\n+\t\tif err := enc.Encode(&elem, &out); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif d := cmp.Diff(recoded, string(out.Bytes())); d != \"\" {\n+\t\t\tlog.Printf(\"Encoding error: diff(-want,+got): %v\\n\", d)\n+\t\t}\n+\t}\n+\tif decFails+encFails > 0 {\n+\t\treturn fmt.Errorf(\"failed to decode %v times, and encode %v times\", decFails, encFails)\n+\t}\n+\n+\treturn nil\n+}\n+\n+var cmpOpts = []cmp.Option{\n+\tcmp.Transformer(\"bytes2string\", func(in []byte) (out string) {\n+\t\treturn string(in)\n+\t}),\n+}\n+\n+func diff(c Coder, elem *exec.FullValue, eg yaml.MapItem) bool {\n+\tvar got, want interface{}\n+\tswitch c.Urn {\n+\tcase \"beam:coder:bytes:v1\":\n+\t\tgot = string(elem.Elm.([]byte))\n+\t\tswitch egv := eg.Value.(type) {\n+\t\tcase string:\n+\t\t\twant = egv\n+\t\tcase []byte:\n+\t\t\twant = string(egv)\n+\t\t}\n+\tcase \"beam:coder:varint:v1\":\n+\t\tgot, want = elem.Elm.(int64), int64(eg.Value.(int))\n+\tcase \"beam:coder:double:v1\":\n+\t\tgot = elem.Elm.(float64)\n+\t\tswitch v := eg.Value.(string); v {\n+\t\tcase \"NaN\":\n+\t\t\t// Do the NaN comparison here since NaN by definition != NaN.\n+\t\t\tif math.IsNaN(got.(float64)) {\n+\t\t\t\twant, got = 1, 1\n+\t\t\t} else {\n+\t\t\t\twant = math.NaN()\n+\t\t\t}\n+\t\tcase \"-Infinity\":\n+\t\t\twant = math.Inf(-1)\n+\t\tcase \"Infinity\":\n+\t\t\twant = math.Inf(1)\n+\t\tdefault:\n+\t\t\twant, _ = strconv.ParseFloat(v, 64)\n+\t\t}\n+\n+\tcase \"beam:coder:kv:v1\":\n+\t\tv := eg.Value.(yaml.MapSlice)\n+\t\tpass := true\n+\t\tif !diff(c.Components[0], &exec.FullValue{Elm: elem.Elm}, v[0]) {\n+\t\t\tpass = false\n+\t\t}\n+\t\tif !diff(c.Components[1], &exec.FullValue{Elm: elem.Elm2}, v[1]) {\n+\t\t\tpass = false\n+\t\t}\n+\t\treturn pass\n+\n+\tcase \"beam:coder:iterable:v1\":\n+\t\tpass := true\n+\t\tgotrv := reflect.ValueOf(elem.Elm)\n+\t\twantrv := reflect.ValueOf(eg.Value)\n+\t\tif gotrv.Len() != wantrv.Len() {\n+\t\t\tlog.Printf(\"Lengths don't match. got %v, want %v;  %v, %v\", gotrv.Len(), wantrv.Len(), gotrv, wantrv)\n+\t\t\treturn false\n+\t\t}\n+\t\tfor i := 0; i < wantrv.Len(); i++ {\n+\t\t\tif !diff(c.Components[0],\n+\t\t\t\t&exec.FullValue{Elm: gotrv.Index(i).Interface()},\n+\t\t\t\tyaml.MapItem{Value: wantrv.Index(i).Interface()}) {\n+\t\t\t\tpass = false\n+\t\t\t}\n+\n+\t\t}\n+\t\treturn pass\n+\tcase \"beam:coder:interval_window:v1\":\n+\t\tvar a, b int\n+\t\tval := eg.Value\n+\t\tif is, ok := eg.Value.([]interface{}); ok {\n+\t\t\tval = is[0]\n+\t\t}\n+\t\tv := val.(yaml.MapSlice)\n+\n+\t\ta = v[0].Value.(int)\n+\t\tb = v[1].Value.(int)\n+\t\tend := mtime.FromMilliseconds(int64(a))\n+\t\tstart := end - mtime.Time(int64(b))\n+\t\twant = window.IntervalWindow{Start: start, End: end}\n+\t\t// If this is nested in an iterable, windows won't be populated.\n+\t\tif len(elem.Windows) == 0 {\n+\t\t\tgot = elem.Elm\n+\t\t} else {\n+\t\t\tgot = elem.Windows[0]\n+\t\t}\n+\n+\tcase \"beam:coder:global_window:v1\":\n+\t\twant = window.GlobalWindow{}\n+\t\t// If this is nested in an iterable, windows won't be populated.\n+\t\tif len(elem.Windows) == 0 {\n+\t\t\tgot = window.GlobalWindow(elem.Elm.(struct{}))\n+\t\t} else {\n+\t\t\tgot = elem.Windows[0]\n+\t\t}\n+\tcase \"beam:coder:windowed_value:v1\", \"beam:coder:param_windowed_value:v1\":\n+\t\t// elem contains all the information, but we need to compare the element+timestamp\n+\t\t// separately from the windows, to avoid repeated expected value parsing logic.\n+\t\tpass := true\n+\t\tvs := eg.Value.(yaml.MapSlice)\n+\t\tif !diff(c.Components[0], elem, vs[0]) {\n+\t\t\tpass = false\n+\t\t}\n+\t\tif d := cmp.Diff(\n+\t\t\tmtime.FromMilliseconds(int64(vs[1].Value.(int))),\n+\t\t\telem.Timestamp, cmpOpts...); d != \"\" {\n+\n+\t\t\tpass = false\n+\t\t}\n+\t\tif !diff(c.Components[1], elem, vs[3]) {\n+\t\t\tpass = false\n+\t\t}\n+\t\t// TODO compare pane information.\n+\t\treturn pass\n+\tcase \"beam:coder:row:v1\":\n+\t\tfs := eg.Value.(yaml.MapSlice)\n+\t\tvar rfs []reflect.StructField\n+\t\t// There are only 2 pointer examples, but they reuse field names,\n+\t\t// so we key off the proto hash to know which example we're handling.\n+\t\tptrEg := strings.Contains(c.Payload, \"51ace21c7393\")\n+\t\tfor _, rf := range fs {\n+\t\t\tname := rf.Key.(string)\n+\t\t\tt := nameToType[name]\n+\t\t\tif ptrEg {\n+\t\t\t\tt = reflect.PtrTo(t)\n+\t\t\t}\n+\t\t\trfs = append(rfs, reflect.StructField{\n+\t\t\t\tName: strings.ToUpper(name[:1]) + name[1:],\n+\t\t\t\tType: t,\n+\t\t\t\tTag:  reflect.StructTag(fmt.Sprintf(\"beam:\\\"%v\\\"\", name)),\n+\t\t\t})\n+\t\t}\n+\t\trv := reflect.New(reflect.StructOf(rfs)).Elem()\n+\t\tfor i, rf := range fs {\n+\t\t\tsetField(rv, i, rf.Value)\n+\t\t}\n+\n+\t\tgot, want = elem.Elm, rv.Interface()\n+\tdefault:\n+\t\tgot, want = elem.Elm, eg.Value\n+\t}\n+\tif d := cmp.Diff(want, got, cmpOpts...); d != \"\" {\n+\t\tlog.Printf(\"Decoding error: diff(-want,+got): %v\\n\", d)\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+// standard_coders.yaml uses the name for type indication, except for nullability.\n+var nameToType = map[string]reflect.Type{\n+\t\"str\":     reflectx.String,\n+\t\"i32\":     reflectx.Int32,\n+\t\"f64\":     reflectx.Float64,\n+\t\"arr\":     reflect.SliceOf(reflectx.String),\n+\t\"f_bool\":  reflectx.Bool,\n+\t\"f_bytes\": reflect.PtrTo(reflectx.ByteSlice),\n+\t\"f_map\":   reflect.MapOf(reflectx.String, reflect.PtrTo(reflectx.Int64)),\n+}\n+\n+func setField(rv reflect.Value, i int, v interface{}) {\n+\tif v == nil {\n+\t\treturn\n+\t}\n+\trf := rv.Field(i)\n+\tif rf.Kind() == reflect.Ptr {\n+\t\t// Ensure it's initialized.\n+\t\trf.Set(reflect.New(rf.Type().Elem()))\n+\t\trf = rf.Elem()\n+\t}\n+\tswitch rf.Kind() {\n+\tcase reflect.String:\n+\t\trf.SetString(v.(string))\n+\tcase reflect.Int32:\n+\t\trf.SetInt(int64(v.(int)))\n+\tcase reflect.Float64:\n+\t\tc, err := strconv.ParseFloat(v.(string), 64)\n+\t\tif err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t\trf.SetFloat(c)\n+\tcase reflect.Slice:\n+\t\tif rf.Type() == reflectx.ByteSlice {\n+\t\t\trf.Set(reflect.ValueOf([]byte(v.(string))))\n+\t\t\tbreak\n+\t\t}\n+\t\t// Value is a []interface{} with string values.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01095f0d676d93c83a0c48e043bcbf3deb914f45"}, "originalPosition": 338}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8f2cdfdad1837d5b1f38cbab7b8b56cc34622a5", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/c8f2cdfdad1837d5b1f38cbab7b8b56cc34622a5", "committedDate": "2020-09-16T17:48:42Z", "message": "!fixup review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f4269089975dbfe5952fb3ed505ac6f2861eaad", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/4f4269089975dbfe5952fb3ed505ac6f2861eaad", "committedDate": "2020-09-16T17:51:20Z", "message": "Merge branch 'master' into beam9615a"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5OTUzNjQw", "url": "https://github.com/apache/beam/pull/12588#pullrequestreview-489953640", "createdAt": "2020-09-16T19:24:23Z", "commit": {"oid": "4f4269089975dbfe5952fb3ed505ac6f2861eaad"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d5eaa2fa7b416e54f14b3713500fc20d3afdea8", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/4d5eaa2fa7b416e54f14b3713500fc20d3afdea8", "committedDate": "2020-09-16T20:03:20Z", "message": "!fixup to ignore the logical type test."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3552, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}