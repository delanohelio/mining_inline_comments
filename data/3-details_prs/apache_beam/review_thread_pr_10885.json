{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2Njk5NTk5", "number": 10885, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxODoxMDo0NVrODgzMow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxODo0MTozOFrODhLYGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NzE5ODQzOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/testing/synthetic_pipeline.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxODoxMDo0NVrOFrM_gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxNzozMzo0OFrOFrwu7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg0NTk1NQ==", "bodyText": "Let's use range instead of xrange, and adjust the import accordingly. We try to use idiomatic py3 whenever possible in Beam.", "url": "https://github.com/apache/beam/pull/10885#discussion_r380845955", "createdAt": "2020-02-18T18:10:45Z", "author": {"login": "tvalentyn"}, "path": "sdks/python/apache_beam/testing/synthetic_pipeline.py", "diffHunk": "@@ -415,19 +418,24 @@ def get_range_tracker(self, start_position, stop_position):\n       tracker = range_trackers.UnsplittableRangeTracker(tracker)\n     return tracker\n \n+  @staticmethod\n+  def random_bytes(length):\n+    \"\"\"Return random bytes.\"\"\"\n+    return b''.join(\n+        (struct.pack('B', random.getrandbits(8)) for _ in xrange(length)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f36497ce8469cdcb23e2e62fe9006ccacf7b18b"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE2MDA4NQ==", "bodyText": "Alright. I was a bit concerned about performance of range on Python 2, but the parameter is almost always small so the impact is negligible.", "url": "https://github.com/apache/beam/pull/10885#discussion_r381160085", "createdAt": "2020-02-19T09:11:29Z", "author": {"login": "kamilwu"}, "path": "sdks/python/apache_beam/testing/synthetic_pipeline.py", "diffHunk": "@@ -415,19 +418,24 @@ def get_range_tracker(self, start_position, stop_position):\n       tracker = range_trackers.UnsplittableRangeTracker(tracker)\n     return tracker\n \n+  @staticmethod\n+  def random_bytes(length):\n+    \"\"\"Return random bytes.\"\"\"\n+    return b''.join(\n+        (struct.pack('B', random.getrandbits(8)) for _ in xrange(length)))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg0NTk1NQ=="}, "originalCommit": {"oid": "6f36497ce8469cdcb23e2e62fe9006ccacf7b18b"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQzMTUzMg==", "bodyText": "We can add from builtins import range to use py3 implementation of range on py2.", "url": "https://github.com/apache/beam/pull/10885#discussion_r381431532", "createdAt": "2020-02-19T17:33:48Z", "author": {"login": "tvalentyn"}, "path": "sdks/python/apache_beam/testing/synthetic_pipeline.py", "diffHunk": "@@ -415,19 +418,24 @@ def get_range_tracker(self, start_position, stop_position):\n       tracker = range_trackers.UnsplittableRangeTracker(tracker)\n     return tracker\n \n+  @staticmethod\n+  def random_bytes(length):\n+    \"\"\"Return random bytes.\"\"\"\n+    return b''.join(\n+        (struct.pack('B', random.getrandbits(8)) for _ in xrange(length)))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg0NTk1NQ=="}, "originalCommit": {"oid": "6f36497ce8469cdcb23e2e62fe9006ccacf7b18b"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NzI3MDkzOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/testing/synthetic_pipeline.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxODozMzowOFrOFrNsGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxMzoyMzowNlrOFrn1Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg1NzM3MA==", "bodyText": "How about we instantiate random.Random() instead of modifying the global state? This is important if we execute this generator concurrently. Not sure if we do.", "url": "https://github.com/apache/beam/pull/10885#discussion_r380857370", "createdAt": "2020-02-18T18:33:08Z", "author": {"login": "tvalentyn"}, "path": "sdks/python/apache_beam/testing/synthetic_pipeline.py", "diffHunk": "@@ -415,19 +418,24 @@ def get_range_tracker(self, start_position, stop_position):\n       tracker = range_trackers.UnsplittableRangeTracker(tracker)\n     return tracker\n \n+  @staticmethod\n+  def random_bytes(length):\n+    \"\"\"Return random bytes.\"\"\"\n+    return b''.join(\n+        (struct.pack('B', random.getrandbits(8)) for _ in xrange(length)))\n+\n   def _gen_kv_pair(self, index):\n-    r = np.random.RandomState(index)\n-    rand = r.random_sample()\n+    random.seed(index)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f36497ce8469cdcb23e2e62fe9006ccacf7b18b"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI4NTY3NQ==", "bodyText": "I'm pretty sure it's possible while having multiple range trackers and multiple workers.\nI wrote a fix and ran the benchmark. The performance is a bit worse:\nPython 2: 7.77728295326 (was 6.37386107445)\nPython 3: 6.888783617999998 (was 5.6981477510000005)\n\nHowever, we could create a cache for generators (instances of random.Random). Then we could create a generator for each range tracker, not for each index. This reduces the offset of instantiating multiple generators:\nPython 2: 6.42752218246\nPython 3: 5.789953311999998\n\nWDYT?", "url": "https://github.com/apache/beam/pull/10885#discussion_r381285675", "createdAt": "2020-02-19T13:23:06Z", "author": {"login": "kamilwu"}, "path": "sdks/python/apache_beam/testing/synthetic_pipeline.py", "diffHunk": "@@ -415,19 +418,24 @@ def get_range_tracker(self, start_position, stop_position):\n       tracker = range_trackers.UnsplittableRangeTracker(tracker)\n     return tracker\n \n+  @staticmethod\n+  def random_bytes(length):\n+    \"\"\"Return random bytes.\"\"\"\n+    return b''.join(\n+        (struct.pack('B', random.getrandbits(8)) for _ in xrange(length)))\n+\n   def _gen_kv_pair(self, index):\n-    r = np.random.RandomState(index)\n-    rand = r.random_sample()\n+    random.seed(index)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg1NzM3MA=="}, "originalCommit": {"oid": "6f36497ce8469cdcb23e2e62fe9006ccacf7b18b"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTE1OTk0OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/testing/synthetic_pipeline.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxODo0MTozOFrOFrzDZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMToxNzozNlrOFsPkRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ2OTU0Mg==", "bodyText": "I don't see a difference in performance if we instantiate the generator in read, but don't use the cache. Do we need the cache?", "url": "https://github.com/apache/beam/pull/10885#discussion_r381469542", "createdAt": "2020-02-19T18:41:38Z", "author": {"login": "tvalentyn"}, "path": "sdks/python/apache_beam/testing/synthetic_pipeline.py", "diffHunk": "@@ -418,29 +420,32 @@ def get_range_tracker(self, start_position, stop_position):\n     return tracker\n \n   @staticmethod\n-  def random_bytes(length):\n+  def random_bytes(length, generator):\n     \"\"\"Return random bytes.\"\"\"\n     return b''.join(\n-        (struct.pack('B', random.getrandbits(8)) for _ in range(length)))\n+        (struct.pack('B', generator.getrandbits(8)) for _ in range(length)))\n \n-  def _gen_kv_pair(self, index):\n-    random.seed(index)\n-    rand = random.random()\n+  def _gen_kv_pair(self, generator, index):\n+    generator.seed(index)\n+    rand = generator.random()\n \n     # Determines whether to generate hot key or not.\n     if rand < self._hot_key_fraction:\n       # Generate hot key.\n       # An integer is randomly selected from the range [0, numHotKeys-1]\n       # with equal probability.\n-      random.seed(index % self._num_hot_keys)\n-    return self.random_bytes(self._key_size), self.random_bytes(\n-      self._value_size)\n+      generator.seed(index % self._num_hot_keys)\n+    return self.random_bytes(self._key_size, generator), self.random_bytes(\n+      self._value_size, generator)\n \n   def read(self, range_tracker):\n     index = range_tracker.start_position()\n+    # Get an instance of pseudo-random number generator\n+    generator = self._generators[(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ce7e623360b3a8834d319a02b5f27e6a7df324a"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTkzNjcxMQ==", "bodyText": "My bad, it seems the cache isn't really needed. It could be helpful if read was called many, many times with the same range tracker, but I don't think this is true. Thanks.", "url": "https://github.com/apache/beam/pull/10885#discussion_r381936711", "createdAt": "2020-02-20T11:17:36Z", "author": {"login": "kamilwu"}, "path": "sdks/python/apache_beam/testing/synthetic_pipeline.py", "diffHunk": "@@ -418,29 +420,32 @@ def get_range_tracker(self, start_position, stop_position):\n     return tracker\n \n   @staticmethod\n-  def random_bytes(length):\n+  def random_bytes(length, generator):\n     \"\"\"Return random bytes.\"\"\"\n     return b''.join(\n-        (struct.pack('B', random.getrandbits(8)) for _ in range(length)))\n+        (struct.pack('B', generator.getrandbits(8)) for _ in range(length)))\n \n-  def _gen_kv_pair(self, index):\n-    random.seed(index)\n-    rand = random.random()\n+  def _gen_kv_pair(self, generator, index):\n+    generator.seed(index)\n+    rand = generator.random()\n \n     # Determines whether to generate hot key or not.\n     if rand < self._hot_key_fraction:\n       # Generate hot key.\n       # An integer is randomly selected from the range [0, numHotKeys-1]\n       # with equal probability.\n-      random.seed(index % self._num_hot_keys)\n-    return self.random_bytes(self._key_size), self.random_bytes(\n-      self._value_size)\n+      generator.seed(index % self._num_hot_keys)\n+    return self.random_bytes(self._key_size, generator), self.random_bytes(\n+      self._value_size, generator)\n \n   def read(self, range_tracker):\n     index = range_tracker.start_position()\n+    # Get an instance of pseudo-random number generator\n+    generator = self._generators[(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ2OTU0Mg=="}, "originalCommit": {"oid": "6ce7e623360b3a8834d319a02b5f27e6a7df324a"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2042, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}