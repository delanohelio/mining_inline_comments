{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1MTcxNjk5", "number": 12971, "title": "[BEAM-10988] Partition dataframes according to size estimates.", "bodyText": "Sizes are directly measured in preceeding stages and estimated from there to avoid expensive fusion breaks due to using the global size as a side input.\nA cross-partition re-batching step is added to mitigate the performance penalty of possible over-partitioning.\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nDataflow\nFlink\nSamza\nSpark\nTwister2\n\n\n\n\nGo\n\n---\n\n---\n\n---\n\n\nJava\n\n\n\n\n\n\n\n\nPython\n\n\n\n---\n\n---\n\n\nXLang\n\n---\n\n---\n\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\nWhitespace\nTypescript\n\n\n\n\nNon-portable\n\n \n\n\n\n\n\n\nPortable\n---\n\n---\n---\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.\nGitHub Actions Tests Status (on master branch)\n\n\n\nSee CI.md for more information about GitHub Actions CI.", "createdAt": "2020-09-29T23:38:13Z", "url": "https://github.com/apache/beam/pull/12971", "merged": true, "mergeCommit": {"oid": "f8c65dd7d56f0a5ba23f96a15d29c26081c8dc43"}, "closed": true, "closedAt": "2020-10-09T16:21:43Z", "author": {"login": "robertwb"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdQSl_wgFqTUwNDIwNTQzMg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdQrJulABqjM4NTc5MjE0NzU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MjA1NDMy", "url": "https://github.com/apache/beam/pull/12971#pullrequestreview-504205432", "createdAt": "2020-10-07T19:36:04Z", "commit": {"oid": "e045d92089ebed25a96ba9a5f43cac1a33512231"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxOTozNjowNFrOHeCmlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxOTo1Nzo1NVrOHeDTXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MTk3Mg==", "bodyText": "This is making the assumption that this stage's outputs are equal to the sum of the sizes of the inputs right? Could you document that here?", "url": "https://github.com/apache/beam/pull/12971#discussion_r501261972", "createdAt": "2020-10-07T19:36:04Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/transforms.py", "diffHunk": "@@ -166,16 +173,40 @@ def expand(self, pcolls):\n           partitioned_pcoll = next(pcolls.values()).pipeline | beam.Create([{}])\n \n         elif self.stage.partitioning != partitionings.Nothing():\n+          # Partitioning required for these operations.\n+          # Compute the number of partitions to use based on estimated size.\n+          if self.stage.partitioning == partitionings.Singleton():\n+            # Always a single partition, don't waste time computing sizes.\n+            num_partitions = 1\n+          else:\n+            # Estimate the sizes from the outputs of a *previous* stage such\n+            # that using these estimates will not cause a fusion break.\n+            input_sizes = [\n+                estimate_size(input, same_stage_ok=False)\n+                for input in tabular_inputs\n+            ]\n+            if None in input_sizes:\n+              # We were unable to (cheaply) compute the size of one or more\n+              # inputs.\n+              num_partitions = DEFAULT_PARTITIONS\n+            else:\n+              num_partitions = beam.pvalue.AsSingleton(\n+                  input_sizes\n+                  | 'FlattenSizes' >> beam.Flatten()\n+                  | 'SumSizes' >> beam.CombineGlobally(sum)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e045d92089ebed25a96ba9a5f43cac1a33512231"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MDI5MA==", "bodyText": "Did you do some benchmarks that motivated this?", "url": "https://github.com/apache/beam/pull/12971#discussion_r501270290", "createdAt": "2020-10-07T19:51:56Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/transforms.py", "diffHunk": "@@ -321,17 +352,100 @@ def expr_to_pcoll(expr):\n       else:\n         return stage_to_result(expr_to_stage(expr))[expr._id]\n \n+    @memoize\n+    def estimate_size(expr, same_stage_ok):\n+      # Returns a pcollection of ints whose sum is the estimated size of the\n+      # given expression.\n+      pipeline = next(iter(inputs.values())).pipeline\n+      label = 'Size[%s, %s]' % (expr._id, same_stage_ok)\n+      if is_scalar(expr):\n+        return pipeline | label >> beam.Create([0])\n+      elif same_stage_ok:\n+        return expr_to_pcoll(expr) | label >> beam.Map(_total_memory_usage)\n+      elif expr in inputs:\n+        return None\n+      else:\n+        # This is the stage to avoid.\n+        expr_stage = expr_to_stage(expr)\n+        # If the stage doesn't start with a shuffle, it's not safe to fuse\n+        # the computation into its parent either.\n+        has_shuffle = expr_stage.partitioning != partitionings.Nothing()\n+        # We assume the size of an expression is the sum of the size of its\n+        # inputs, which may be off by quite a bit, but the goal is to get\n+        # within an order of magnitude or two.\n+        arg_sizes = []\n+        for arg in expr.args():\n+          if is_scalar(arg):\n+            continue\n+          elif arg in inputs:\n+            return None\n+          arg_size = estimate_size(\n+              arg,\n+              same_stage_ok=has_shuffle and expr_to_stage(arg) != expr_stage)\n+          if arg_size is None:\n+            return None\n+          arg_sizes.append(arg_size)\n+        return arg_sizes | label >> beam.Flatten(pipeline=pipeline)\n+\n     # Now we can compute and return the result.\n     return {k: expr_to_pcoll(expr) for k, expr in outputs.items()}\n \n \n+def _total_memory_usage(frame):\n+  assert isinstance(frame, (pd.core.generic.NDFrame, pd.Index))\n+  try:\n+    size = frame.memory_usage()\n+    if not isinstance(size, int):\n+      size = size.sum()\n+    return size\n+  except AttributeError:\n+    # Don't know, assume it's really big.\n+    float('inf')\n+\n+\n+class _ReBatch(beam.DoFn):\n+  \"\"\"Groups all the parts from various workers into the same dataframe.\n+\n+  Also groups across partitions, up to a given data size, to recover some\n+  efficiency in the face of over-partitioning.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e045d92089ebed25a96ba9a5f43cac1a33512231"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MDk2Ng==", "bodyText": "Should this actually be TARGET_PARTITION_SIZE*num_partitions (I believe that's possible), since it's the data limit across every partition?", "url": "https://github.com/apache/beam/pull/12971#discussion_r501270966", "createdAt": "2020-10-07T19:53:13Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/transforms.py", "diffHunk": "@@ -321,17 +352,100 @@ def expr_to_pcoll(expr):\n       else:\n         return stage_to_result(expr_to_stage(expr))[expr._id]\n \n+    @memoize\n+    def estimate_size(expr, same_stage_ok):\n+      # Returns a pcollection of ints whose sum is the estimated size of the\n+      # given expression.\n+      pipeline = next(iter(inputs.values())).pipeline\n+      label = 'Size[%s, %s]' % (expr._id, same_stage_ok)\n+      if is_scalar(expr):\n+        return pipeline | label >> beam.Create([0])\n+      elif same_stage_ok:\n+        return expr_to_pcoll(expr) | label >> beam.Map(_total_memory_usage)\n+      elif expr in inputs:\n+        return None\n+      else:\n+        # This is the stage to avoid.\n+        expr_stage = expr_to_stage(expr)\n+        # If the stage doesn't start with a shuffle, it's not safe to fuse\n+        # the computation into its parent either.\n+        has_shuffle = expr_stage.partitioning != partitionings.Nothing()\n+        # We assume the size of an expression is the sum of the size of its\n+        # inputs, which may be off by quite a bit, but the goal is to get\n+        # within an order of magnitude or two.\n+        arg_sizes = []\n+        for arg in expr.args():\n+          if is_scalar(arg):\n+            continue\n+          elif arg in inputs:\n+            return None\n+          arg_size = estimate_size(\n+              arg,\n+              same_stage_ok=has_shuffle and expr_to_stage(arg) != expr_stage)\n+          if arg_size is None:\n+            return None\n+          arg_sizes.append(arg_size)\n+        return arg_sizes | label >> beam.Flatten(pipeline=pipeline)\n+\n     # Now we can compute and return the result.\n     return {k: expr_to_pcoll(expr) for k, expr in outputs.items()}\n \n \n+def _total_memory_usage(frame):\n+  assert isinstance(frame, (pd.core.generic.NDFrame, pd.Index))\n+  try:\n+    size = frame.memory_usage()\n+    if not isinstance(size, int):\n+      size = size.sum()\n+    return size\n+  except AttributeError:\n+    # Don't know, assume it's really big.\n+    float('inf')\n+\n+\n+class _ReBatch(beam.DoFn):\n+  \"\"\"Groups all the parts from various workers into the same dataframe.\n+\n+  Also groups across partitions, up to a given data size, to recover some\n+  efficiency in the face of over-partitioning.\n+  \"\"\"\n+  def __init__(self, target_size=TARGET_PARTITION_SIZE):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e045d92089ebed25a96ba9a5f43cac1a33512231"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MzQzNw==", "bodyText": "I'm curious if it's always beneficial to use pd.concat here. I was under the impression that it copies and re-arranges buffers into columns", "url": "https://github.com/apache/beam/pull/12971#discussion_r501273437", "createdAt": "2020-10-07T19:57:55Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/python/apache_beam/dataframe/transforms.py", "diffHunk": "@@ -321,17 +352,100 @@ def expr_to_pcoll(expr):\n       else:\n         return stage_to_result(expr_to_stage(expr))[expr._id]\n \n+    @memoize\n+    def estimate_size(expr, same_stage_ok):\n+      # Returns a pcollection of ints whose sum is the estimated size of the\n+      # given expression.\n+      pipeline = next(iter(inputs.values())).pipeline\n+      label = 'Size[%s, %s]' % (expr._id, same_stage_ok)\n+      if is_scalar(expr):\n+        return pipeline | label >> beam.Create([0])\n+      elif same_stage_ok:\n+        return expr_to_pcoll(expr) | label >> beam.Map(_total_memory_usage)\n+      elif expr in inputs:\n+        return None\n+      else:\n+        # This is the stage to avoid.\n+        expr_stage = expr_to_stage(expr)\n+        # If the stage doesn't start with a shuffle, it's not safe to fuse\n+        # the computation into its parent either.\n+        has_shuffle = expr_stage.partitioning != partitionings.Nothing()\n+        # We assume the size of an expression is the sum of the size of its\n+        # inputs, which may be off by quite a bit, but the goal is to get\n+        # within an order of magnitude or two.\n+        arg_sizes = []\n+        for arg in expr.args():\n+          if is_scalar(arg):\n+            continue\n+          elif arg in inputs:\n+            return None\n+          arg_size = estimate_size(\n+              arg,\n+              same_stage_ok=has_shuffle and expr_to_stage(arg) != expr_stage)\n+          if arg_size is None:\n+            return None\n+          arg_sizes.append(arg_size)\n+        return arg_sizes | label >> beam.Flatten(pipeline=pipeline)\n+\n     # Now we can compute and return the result.\n     return {k: expr_to_pcoll(expr) for k, expr in outputs.items()}\n \n \n+def _total_memory_usage(frame):\n+  assert isinstance(frame, (pd.core.generic.NDFrame, pd.Index))\n+  try:\n+    size = frame.memory_usage()\n+    if not isinstance(size, int):\n+      size = size.sum()\n+    return size\n+  except AttributeError:\n+    # Don't know, assume it's really big.\n+    float('inf')\n+\n+\n+class _ReBatch(beam.DoFn):\n+  \"\"\"Groups all the parts from various workers into the same dataframe.\n+\n+  Also groups across partitions, up to a given data size, to recover some\n+  efficiency in the face of over-partitioning.\n+  \"\"\"\n+  def __init__(self, target_size=TARGET_PARTITION_SIZE):\n+    self._target_size = target_size\n+\n+  def start_bundle(self):\n+    self._parts = collections.defaultdict(lambda: collections.defaultdict(list))\n+    self._running_size = 0\n+\n+  def process(\n+      self,\n+      element,\n+      window=beam.DoFn.WindowParam,\n+      timestamp=beam.DoFn.TimestampParam):\n+    _, tagged_parts = element\n+    for tag, parts in tagged_parts.items():\n+      for part in parts:\n+        self._running_size += _total_memory_usage(part)\n+      self._parts[window, timestamp][tag].extend(parts)\n+    if self._running_size >= self._target_size:\n+      self.finish_bundle()\n+\n+  def finish_bundle(self):\n+    for (window, timestamp), tagged_parts in self._parts.items():\n+      yield windowed_value.WindowedValue(\n+          {tag: pd.concat(parts)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e045d92089ebed25a96ba9a5f43cac1a33512231"}, "originalPosition": 159}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MjU5OTU1", "url": "https://github.com/apache/beam/pull/12971#pullrequestreview-505259955", "createdAt": "2020-10-09T00:19:05Z", "commit": {"oid": "e045d92089ebed25a96ba9a5f43cac1a33512231"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMDoxOTowNlrOHe1MtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMDoyNzoxM1rOHe1UjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5MDkzMg==", "bodyText": "Not quite. We want the size of the inputs to partition the inputs; we don't care about the output size of this stage at all. Clarified in the comment above.\nNote also that these \"stages\" are not the same as fused executable \"stages.\" In particular, these \"stages\" contain a (Co)GBK along with some operations that proceed it.", "url": "https://github.com/apache/beam/pull/12971#discussion_r502090932", "createdAt": "2020-10-09T00:19:06Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/transforms.py", "diffHunk": "@@ -166,16 +173,40 @@ def expand(self, pcolls):\n           partitioned_pcoll = next(pcolls.values()).pipeline | beam.Create([{}])\n \n         elif self.stage.partitioning != partitionings.Nothing():\n+          # Partitioning required for these operations.\n+          # Compute the number of partitions to use based on estimated size.\n+          if self.stage.partitioning == partitionings.Singleton():\n+            # Always a single partition, don't waste time computing sizes.\n+            num_partitions = 1\n+          else:\n+            # Estimate the sizes from the outputs of a *previous* stage such\n+            # that using these estimates will not cause a fusion break.\n+            input_sizes = [\n+                estimate_size(input, same_stage_ok=False)\n+                for input in tabular_inputs\n+            ]\n+            if None in input_sizes:\n+              # We were unable to (cheaply) compute the size of one or more\n+              # inputs.\n+              num_partitions = DEFAULT_PARTITIONS\n+            else:\n+              num_partitions = beam.pvalue.AsSingleton(\n+                  input_sizes\n+                  | 'FlattenSizes' >> beam.Flatten()\n+                  | 'SumSizes' >> beam.CombineGlobally(sum)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MTk3Mg=="}, "originalCommit": {"oid": "e045d92089ebed25a96ba9a5f43cac1a33512231"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5MTQ4MQ==", "bodyText": "Mostly the observation that there were a plethora of tiny/empty dataframes when debugging, and the realization that this could be worse given the dynamic partitioning choices (which err on the side of overestimation).\nI also ran some simple benchmarks and determined that, for simple operations, things started to become linear in around the MB range.", "url": "https://github.com/apache/beam/pull/12971#discussion_r502091481", "createdAt": "2020-10-09T00:21:19Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/transforms.py", "diffHunk": "@@ -321,17 +352,100 @@ def expr_to_pcoll(expr):\n       else:\n         return stage_to_result(expr_to_stage(expr))[expr._id]\n \n+    @memoize\n+    def estimate_size(expr, same_stage_ok):\n+      # Returns a pcollection of ints whose sum is the estimated size of the\n+      # given expression.\n+      pipeline = next(iter(inputs.values())).pipeline\n+      label = 'Size[%s, %s]' % (expr._id, same_stage_ok)\n+      if is_scalar(expr):\n+        return pipeline | label >> beam.Create([0])\n+      elif same_stage_ok:\n+        return expr_to_pcoll(expr) | label >> beam.Map(_total_memory_usage)\n+      elif expr in inputs:\n+        return None\n+      else:\n+        # This is the stage to avoid.\n+        expr_stage = expr_to_stage(expr)\n+        # If the stage doesn't start with a shuffle, it's not safe to fuse\n+        # the computation into its parent either.\n+        has_shuffle = expr_stage.partitioning != partitionings.Nothing()\n+        # We assume the size of an expression is the sum of the size of its\n+        # inputs, which may be off by quite a bit, but the goal is to get\n+        # within an order of magnitude or two.\n+        arg_sizes = []\n+        for arg in expr.args():\n+          if is_scalar(arg):\n+            continue\n+          elif arg in inputs:\n+            return None\n+          arg_size = estimate_size(\n+              arg,\n+              same_stage_ok=has_shuffle and expr_to_stage(arg) != expr_stage)\n+          if arg_size is None:\n+            return None\n+          arg_sizes.append(arg_size)\n+        return arg_sizes | label >> beam.Flatten(pipeline=pipeline)\n+\n     # Now we can compute and return the result.\n     return {k: expr_to_pcoll(expr) for k, expr in outputs.items()}\n \n \n+def _total_memory_usage(frame):\n+  assert isinstance(frame, (pd.core.generic.NDFrame, pd.Index))\n+  try:\n+    size = frame.memory_usage()\n+    if not isinstance(size, int):\n+      size = size.sum()\n+    return size\n+  except AttributeError:\n+    # Don't know, assume it's really big.\n+    float('inf')\n+\n+\n+class _ReBatch(beam.DoFn):\n+  \"\"\"Groups all the parts from various workers into the same dataframe.\n+\n+  Also groups across partitions, up to a given data size, to recover some\n+  efficiency in the face of over-partitioning.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MDI5MA=="}, "originalCommit": {"oid": "e045d92089ebed25a96ba9a5f43cac1a33512231"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5MjA4Ng==", "bodyText": "Having thought about it, I'm going to leave it for now. The reason to have a bound is to bound the total amount of memory on a worker (and amount of compute to couple in downstream operations), and that makes sense to cap across inputs rather than per-input. We could revisit in the future.", "url": "https://github.com/apache/beam/pull/12971#discussion_r502092086", "createdAt": "2020-10-09T00:23:50Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/transforms.py", "diffHunk": "@@ -321,17 +352,100 @@ def expr_to_pcoll(expr):\n       else:\n         return stage_to_result(expr_to_stage(expr))[expr._id]\n \n+    @memoize\n+    def estimate_size(expr, same_stage_ok):\n+      # Returns a pcollection of ints whose sum is the estimated size of the\n+      # given expression.\n+      pipeline = next(iter(inputs.values())).pipeline\n+      label = 'Size[%s, %s]' % (expr._id, same_stage_ok)\n+      if is_scalar(expr):\n+        return pipeline | label >> beam.Create([0])\n+      elif same_stage_ok:\n+        return expr_to_pcoll(expr) | label >> beam.Map(_total_memory_usage)\n+      elif expr in inputs:\n+        return None\n+      else:\n+        # This is the stage to avoid.\n+        expr_stage = expr_to_stage(expr)\n+        # If the stage doesn't start with a shuffle, it's not safe to fuse\n+        # the computation into its parent either.\n+        has_shuffle = expr_stage.partitioning != partitionings.Nothing()\n+        # We assume the size of an expression is the sum of the size of its\n+        # inputs, which may be off by quite a bit, but the goal is to get\n+        # within an order of magnitude or two.\n+        arg_sizes = []\n+        for arg in expr.args():\n+          if is_scalar(arg):\n+            continue\n+          elif arg in inputs:\n+            return None\n+          arg_size = estimate_size(\n+              arg,\n+              same_stage_ok=has_shuffle and expr_to_stage(arg) != expr_stage)\n+          if arg_size is None:\n+            return None\n+          arg_sizes.append(arg_size)\n+        return arg_sizes | label >> beam.Flatten(pipeline=pipeline)\n+\n     # Now we can compute and return the result.\n     return {k: expr_to_pcoll(expr) for k, expr in outputs.items()}\n \n \n+def _total_memory_usage(frame):\n+  assert isinstance(frame, (pd.core.generic.NDFrame, pd.Index))\n+  try:\n+    size = frame.memory_usage()\n+    if not isinstance(size, int):\n+      size = size.sum()\n+    return size\n+  except AttributeError:\n+    # Don't know, assume it's really big.\n+    float('inf')\n+\n+\n+class _ReBatch(beam.DoFn):\n+  \"\"\"Groups all the parts from various workers into the same dataframe.\n+\n+  Also groups across partitions, up to a given data size, to recover some\n+  efficiency in the face of over-partitioning.\n+  \"\"\"\n+  def __init__(self, target_size=TARGET_PARTITION_SIZE):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MDk2Ng=="}, "originalCommit": {"oid": "e045d92089ebed25a96ba9a5f43cac1a33512231"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5Mjk0MQ==", "bodyText": "How beneficial it is depends on the size of the inputs. For tiny inputs, the cost of copying is easily absorbed in the overhead savings of future operations, but for large inputs it could dominate. It may make sense to try to tune TARGET_PARTITION_SIZE to find the right tradeoff.", "url": "https://github.com/apache/beam/pull/12971#discussion_r502092941", "createdAt": "2020-10-09T00:27:13Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/dataframe/transforms.py", "diffHunk": "@@ -321,17 +352,100 @@ def expr_to_pcoll(expr):\n       else:\n         return stage_to_result(expr_to_stage(expr))[expr._id]\n \n+    @memoize\n+    def estimate_size(expr, same_stage_ok):\n+      # Returns a pcollection of ints whose sum is the estimated size of the\n+      # given expression.\n+      pipeline = next(iter(inputs.values())).pipeline\n+      label = 'Size[%s, %s]' % (expr._id, same_stage_ok)\n+      if is_scalar(expr):\n+        return pipeline | label >> beam.Create([0])\n+      elif same_stage_ok:\n+        return expr_to_pcoll(expr) | label >> beam.Map(_total_memory_usage)\n+      elif expr in inputs:\n+        return None\n+      else:\n+        # This is the stage to avoid.\n+        expr_stage = expr_to_stage(expr)\n+        # If the stage doesn't start with a shuffle, it's not safe to fuse\n+        # the computation into its parent either.\n+        has_shuffle = expr_stage.partitioning != partitionings.Nothing()\n+        # We assume the size of an expression is the sum of the size of its\n+        # inputs, which may be off by quite a bit, but the goal is to get\n+        # within an order of magnitude or two.\n+        arg_sizes = []\n+        for arg in expr.args():\n+          if is_scalar(arg):\n+            continue\n+          elif arg in inputs:\n+            return None\n+          arg_size = estimate_size(\n+              arg,\n+              same_stage_ok=has_shuffle and expr_to_stage(arg) != expr_stage)\n+          if arg_size is None:\n+            return None\n+          arg_sizes.append(arg_size)\n+        return arg_sizes | label >> beam.Flatten(pipeline=pipeline)\n+\n     # Now we can compute and return the result.\n     return {k: expr_to_pcoll(expr) for k, expr in outputs.items()}\n \n \n+def _total_memory_usage(frame):\n+  assert isinstance(frame, (pd.core.generic.NDFrame, pd.Index))\n+  try:\n+    size = frame.memory_usage()\n+    if not isinstance(size, int):\n+      size = size.sum()\n+    return size\n+  except AttributeError:\n+    # Don't know, assume it's really big.\n+    float('inf')\n+\n+\n+class _ReBatch(beam.DoFn):\n+  \"\"\"Groups all the parts from various workers into the same dataframe.\n+\n+  Also groups across partitions, up to a given data size, to recover some\n+  efficiency in the face of over-partitioning.\n+  \"\"\"\n+  def __init__(self, target_size=TARGET_PARTITION_SIZE):\n+    self._target_size = target_size\n+\n+  def start_bundle(self):\n+    self._parts = collections.defaultdict(lambda: collections.defaultdict(list))\n+    self._running_size = 0\n+\n+  def process(\n+      self,\n+      element,\n+      window=beam.DoFn.WindowParam,\n+      timestamp=beam.DoFn.TimestampParam):\n+    _, tagged_parts = element\n+    for tag, parts in tagged_parts.items():\n+      for part in parts:\n+        self._running_size += _total_memory_usage(part)\n+      self._parts[window, timestamp][tag].extend(parts)\n+    if self._running_size >= self._target_size:\n+      self.finish_bundle()\n+\n+  def finish_bundle(self):\n+    for (window, timestamp), tagged_parts in self._parts.items():\n+      yield windowed_value.WindowedValue(\n+          {tag: pd.concat(parts)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MzQzNw=="}, "originalCommit": {"oid": "e045d92089ebed25a96ba9a5f43cac1a33512231"}, "originalPosition": 159}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b231cfc21d58004f753427b99212d957f3ad7d3c", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/b231cfc21d58004f753427b99212d957f3ad7d3c", "committedDate": "2020-10-09T00:32:44Z", "message": "[BEAM-10988] Partition dataframes according to size estimates.\n\nSizes are directly measured in preceeding stages and estimated from\nthere to avoid expensive fusion breaks due to using the global size\nas a side input."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec7c34495a778976883608bcd2a60663e4cf2d7b", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/ec7c34495a778976883608bcd2a60663e4cf2d7b", "committedDate": "2020-10-09T00:32:44Z", "message": "[BEAM-10988] Batch dataframes across partitions on the same worker.\n\nThis greatly reduces the performance penalty of over-partitioning."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3b84ef44f2a962ee75aec8742fad9bf963647030", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/3b84ef44f2a962ee75aec8742fad9bf963647030", "committedDate": "2020-10-09T00:29:00Z", "message": "better comments"}, "afterCommit": {"oid": "ec7c34495a778976883608bcd2a60663e4cf2d7b", "author": {"user": {"login": "robertwb", "name": "Robert Bradshaw"}}, "url": "https://github.com/apache/beam/commit/ec7c34495a778976883608bcd2a60663e4cf2d7b", "committedDate": "2020-10-09T00:32:44Z", "message": "[BEAM-10988] Batch dataframes across partitions on the same worker.\n\nThis greatly reduces the performance penalty of over-partitioning."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2189, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}