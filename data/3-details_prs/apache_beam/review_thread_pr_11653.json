{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1NTUzNzY0", "number": 11653, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjo0MTo0OVrOD7UXrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMTo1NToxNVrOD7avvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNTI2MzE4OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjo0MTo0OVrOGTkaVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNzo0NDo0NlrOGTmvyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3MjY5Mg==", "bodyText": "allowed_split_points definition is too vague in the case of multiple active elements and we need to scope it down to mean the set of allowed first_residual_element indices.", "url": "https://github.com/apache/beam/pull/11653#discussion_r423172692", "createdAt": "2020-05-11T16:41:49Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "diffHunk": "@@ -237,30 +235,71 @@ def try_split(self, fraction_of_remainder, total_buffer_size):\n           current_element_progress = (\n               current_element_progress_object.fraction_completed)\n       # Now figure out where to split.\n-      # The units here (except for keep_of_element_remainder) are all in\n-      # terms of number of (possibly fractional) elements.\n-      remainder = total_buffer_size - self.index - current_element_progress\n-      keep = remainder * fraction_of_remainder\n-      if current_element_progress < 1:\n-        keep_of_element_remainder = keep / (1 - current_element_progress)\n-        # If it's less than what's left of the current element,\n-        # try splitting at the current element.\n-        if keep_of_element_remainder < 1:\n-          split = self.receivers[0].try_split(\n-              keep_of_element_remainder\n-          )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n-          if split:\n-            element_primary, element_residual = split\n-            self.stop = self.index + 1\n-            return self.index - 1, element_primary, element_residual, self.stop\n-      # Otherwise, split at the closest element boundary.\n-      # pylint: disable=round-builtin\n-      stop_index = (\n-          self.index + max(1, int(round(current_element_progress + keep))))\n-      if stop_index < self.stop:\n-        self.stop = stop_index\n-        return self.stop - 1, None, None, self.stop\n-    return None\n+      split = self._compute_split(\n+          self.index,\n+          current_element_progress,\n+          self.stop,\n+          fraction_of_remainder,\n+          total_buffer_size,\n+          allowed_split_points,\n+          self.receivers[0].try_split)\n+      if split:\n+        self.stop = split[-1]\n+      return split\n+\n+  @staticmethod\n+  def _compute_split(\n+      index,\n+      current_element_progress,\n+      stop,\n+      fraction_of_remainder,\n+      total_buffer_size,\n+      allowed_split_points=(),\n+      try_split=lambda fraction: None):\n+    def is_valid_split_point(index):\n+      return not allowed_split_points or index in allowed_split_points\n+\n+    if total_buffer_size < index + 1:\n+      total_buffer_size = index + 1\n+    elif total_buffer_size > stop:\n+      total_buffer_size = stop\n+    # The units here (except for keep_of_element_remainder) are all in\n+    # terms of number of (possibly fractional) elements.\n+    remainder = total_buffer_size - index - current_element_progress\n+    keep = remainder * fraction_of_remainder\n+    if current_element_progress < 1:\n+      keep_of_element_remainder = keep / (1 - current_element_progress)\n+      # If it's less than what's left of the current element,\n+      # try splitting at the current element.\n+      if (keep_of_element_remainder < 1 and is_valid_split_point(index) and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dad2e502e547381b6309271551051ac52b94687"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIxMDk1NQ==", "bodyText": "Agreed. I've added clarification to the proto.", "url": "https://github.com/apache/beam/pull/11653#discussion_r423210955", "createdAt": "2020-05-11T17:44:46Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "diffHunk": "@@ -237,30 +235,71 @@ def try_split(self, fraction_of_remainder, total_buffer_size):\n           current_element_progress = (\n               current_element_progress_object.fraction_completed)\n       # Now figure out where to split.\n-      # The units here (except for keep_of_element_remainder) are all in\n-      # terms of number of (possibly fractional) elements.\n-      remainder = total_buffer_size - self.index - current_element_progress\n-      keep = remainder * fraction_of_remainder\n-      if current_element_progress < 1:\n-        keep_of_element_remainder = keep / (1 - current_element_progress)\n-        # If it's less than what's left of the current element,\n-        # try splitting at the current element.\n-        if keep_of_element_remainder < 1:\n-          split = self.receivers[0].try_split(\n-              keep_of_element_remainder\n-          )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n-          if split:\n-            element_primary, element_residual = split\n-            self.stop = self.index + 1\n-            return self.index - 1, element_primary, element_residual, self.stop\n-      # Otherwise, split at the closest element boundary.\n-      # pylint: disable=round-builtin\n-      stop_index = (\n-          self.index + max(1, int(round(current_element_progress + keep))))\n-      if stop_index < self.stop:\n-        self.stop = stop_index\n-        return self.stop - 1, None, None, self.stop\n-    return None\n+      split = self._compute_split(\n+          self.index,\n+          current_element_progress,\n+          self.stop,\n+          fraction_of_remainder,\n+          total_buffer_size,\n+          allowed_split_points,\n+          self.receivers[0].try_split)\n+      if split:\n+        self.stop = split[-1]\n+      return split\n+\n+  @staticmethod\n+  def _compute_split(\n+      index,\n+      current_element_progress,\n+      stop,\n+      fraction_of_remainder,\n+      total_buffer_size,\n+      allowed_split_points=(),\n+      try_split=lambda fraction: None):\n+    def is_valid_split_point(index):\n+      return not allowed_split_points or index in allowed_split_points\n+\n+    if total_buffer_size < index + 1:\n+      total_buffer_size = index + 1\n+    elif total_buffer_size > stop:\n+      total_buffer_size = stop\n+    # The units here (except for keep_of_element_remainder) are all in\n+    # terms of number of (possibly fractional) elements.\n+    remainder = total_buffer_size - index - current_element_progress\n+    keep = remainder * fraction_of_remainder\n+    if current_element_progress < 1:\n+      keep_of_element_remainder = keep / (1 - current_element_progress)\n+      # If it's less than what's left of the current element,\n+      # try splitting at the current element.\n+      if (keep_of_element_remainder < 1 and is_valid_split_point(index) and", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3MjY5Mg=="}, "originalCommit": {"oid": "3dad2e502e547381b6309271551051ac52b94687"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNTMwMjc5OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjo1MjowMVrOGTkzEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNzo0NTo1N1rOGTmyXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3OTAyNg==", "bodyText": "We should make it an error to have duplicate split points in allowed_split_points.", "url": "https://github.com/apache/beam/pull/11653#discussion_r423179026", "createdAt": "2020-05-11T16:52:01Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "diffHunk": "@@ -237,30 +235,71 @@ def try_split(self, fraction_of_remainder, total_buffer_size):\n           current_element_progress = (\n               current_element_progress_object.fraction_completed)\n       # Now figure out where to split.\n-      # The units here (except for keep_of_element_remainder) are all in\n-      # terms of number of (possibly fractional) elements.\n-      remainder = total_buffer_size - self.index - current_element_progress\n-      keep = remainder * fraction_of_remainder\n-      if current_element_progress < 1:\n-        keep_of_element_remainder = keep / (1 - current_element_progress)\n-        # If it's less than what's left of the current element,\n-        # try splitting at the current element.\n-        if keep_of_element_remainder < 1:\n-          split = self.receivers[0].try_split(\n-              keep_of_element_remainder\n-          )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n-          if split:\n-            element_primary, element_residual = split\n-            self.stop = self.index + 1\n-            return self.index - 1, element_primary, element_residual, self.stop\n-      # Otherwise, split at the closest element boundary.\n-      # pylint: disable=round-builtin\n-      stop_index = (\n-          self.index + max(1, int(round(current_element_progress + keep))))\n-      if stop_index < self.stop:\n-        self.stop = stop_index\n-        return self.stop - 1, None, None, self.stop\n-    return None\n+      split = self._compute_split(\n+          self.index,\n+          current_element_progress,\n+          self.stop,\n+          fraction_of_remainder,\n+          total_buffer_size,\n+          allowed_split_points,\n+          self.receivers[0].try_split)\n+      if split:\n+        self.stop = split[-1]\n+      return split\n+\n+  @staticmethod\n+  def _compute_split(\n+      index,\n+      current_element_progress,\n+      stop,\n+      fraction_of_remainder,\n+      total_buffer_size,\n+      allowed_split_points=(),\n+      try_split=lambda fraction: None):\n+    def is_valid_split_point(index):\n+      return not allowed_split_points or index in allowed_split_points\n+\n+    if total_buffer_size < index + 1:\n+      total_buffer_size = index + 1\n+    elif total_buffer_size > stop:\n+      total_buffer_size = stop\n+    # The units here (except for keep_of_element_remainder) are all in\n+    # terms of number of (possibly fractional) elements.\n+    remainder = total_buffer_size - index - current_element_progress\n+    keep = remainder * fraction_of_remainder\n+    if current_element_progress < 1:\n+      keep_of_element_remainder = keep / (1 - current_element_progress)\n+      # If it's less than what's left of the current element,\n+      # try splitting at the current element.\n+      if (keep_of_element_remainder < 1 and is_valid_split_point(index) and\n+          is_valid_split_point(index + 1)):\n+        split = try_split(\n+            keep_of_element_remainder\n+        )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n+        if split:\n+          element_primary, element_residual = split\n+          return index - 1, element_primary, element_residual, index + 1\n+    # Otherwise, split at the closest element boundary.\n+    # pylint: disable=round-builtin\n+    stop_index = index + max(1, int(round(current_element_progress + keep)))\n+    if allowed_split_points and stop_index not in allowed_split_points:\n+      allowed_split_points = sorted(allowed_split_points)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dad2e502e547381b6309271551051ac52b94687"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIxMTYxMw==", "bodyText": "I agree that there's never a reason to have duplicates, but that wouldn't impact this code here (and I don't think should result in failure).", "url": "https://github.com/apache/beam/pull/11653#discussion_r423211613", "createdAt": "2020-05-11T17:45:57Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "diffHunk": "@@ -237,30 +235,71 @@ def try_split(self, fraction_of_remainder, total_buffer_size):\n           current_element_progress = (\n               current_element_progress_object.fraction_completed)\n       # Now figure out where to split.\n-      # The units here (except for keep_of_element_remainder) are all in\n-      # terms of number of (possibly fractional) elements.\n-      remainder = total_buffer_size - self.index - current_element_progress\n-      keep = remainder * fraction_of_remainder\n-      if current_element_progress < 1:\n-        keep_of_element_remainder = keep / (1 - current_element_progress)\n-        # If it's less than what's left of the current element,\n-        # try splitting at the current element.\n-        if keep_of_element_remainder < 1:\n-          split = self.receivers[0].try_split(\n-              keep_of_element_remainder\n-          )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n-          if split:\n-            element_primary, element_residual = split\n-            self.stop = self.index + 1\n-            return self.index - 1, element_primary, element_residual, self.stop\n-      # Otherwise, split at the closest element boundary.\n-      # pylint: disable=round-builtin\n-      stop_index = (\n-          self.index + max(1, int(round(current_element_progress + keep))))\n-      if stop_index < self.stop:\n-        self.stop = stop_index\n-        return self.stop - 1, None, None, self.stop\n-    return None\n+      split = self._compute_split(\n+          self.index,\n+          current_element_progress,\n+          self.stop,\n+          fraction_of_remainder,\n+          total_buffer_size,\n+          allowed_split_points,\n+          self.receivers[0].try_split)\n+      if split:\n+        self.stop = split[-1]\n+      return split\n+\n+  @staticmethod\n+  def _compute_split(\n+      index,\n+      current_element_progress,\n+      stop,\n+      fraction_of_remainder,\n+      total_buffer_size,\n+      allowed_split_points=(),\n+      try_split=lambda fraction: None):\n+    def is_valid_split_point(index):\n+      return not allowed_split_points or index in allowed_split_points\n+\n+    if total_buffer_size < index + 1:\n+      total_buffer_size = index + 1\n+    elif total_buffer_size > stop:\n+      total_buffer_size = stop\n+    # The units here (except for keep_of_element_remainder) are all in\n+    # terms of number of (possibly fractional) elements.\n+    remainder = total_buffer_size - index - current_element_progress\n+    keep = remainder * fraction_of_remainder\n+    if current_element_progress < 1:\n+      keep_of_element_remainder = keep / (1 - current_element_progress)\n+      # If it's less than what's left of the current element,\n+      # try splitting at the current element.\n+      if (keep_of_element_remainder < 1 and is_valid_split_point(index) and\n+          is_valid_split_point(index + 1)):\n+        split = try_split(\n+            keep_of_element_remainder\n+        )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n+        if split:\n+          element_primary, element_residual = split\n+          return index - 1, element_primary, element_residual, index + 1\n+    # Otherwise, split at the closest element boundary.\n+    # pylint: disable=round-builtin\n+    stop_index = index + max(1, int(round(current_element_progress + keep)))\n+    if allowed_split_points and stop_index not in allowed_split_points:\n+      allowed_split_points = sorted(allowed_split_points)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3OTAyNg=="}, "originalCommit": {"oid": "3dad2e502e547381b6309271551051ac52b94687"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNTMyMjE2OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjo1Njo1MlrOGTk_bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNzo0NjoyN1rOGTmzRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4MjE5MA==", "bodyText": "I think you should comment that your choosing the closer of the two points here.", "url": "https://github.com/apache/beam/pull/11653#discussion_r423182190", "createdAt": "2020-05-11T16:56:52Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "diffHunk": "@@ -237,30 +235,71 @@ def try_split(self, fraction_of_remainder, total_buffer_size):\n           current_element_progress = (\n               current_element_progress_object.fraction_completed)\n       # Now figure out where to split.\n-      # The units here (except for keep_of_element_remainder) are all in\n-      # terms of number of (possibly fractional) elements.\n-      remainder = total_buffer_size - self.index - current_element_progress\n-      keep = remainder * fraction_of_remainder\n-      if current_element_progress < 1:\n-        keep_of_element_remainder = keep / (1 - current_element_progress)\n-        # If it's less than what's left of the current element,\n-        # try splitting at the current element.\n-        if keep_of_element_remainder < 1:\n-          split = self.receivers[0].try_split(\n-              keep_of_element_remainder\n-          )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n-          if split:\n-            element_primary, element_residual = split\n-            self.stop = self.index + 1\n-            return self.index - 1, element_primary, element_residual, self.stop\n-      # Otherwise, split at the closest element boundary.\n-      # pylint: disable=round-builtin\n-      stop_index = (\n-          self.index + max(1, int(round(current_element_progress + keep))))\n-      if stop_index < self.stop:\n-        self.stop = stop_index\n-        return self.stop - 1, None, None, self.stop\n-    return None\n+      split = self._compute_split(\n+          self.index,\n+          current_element_progress,\n+          self.stop,\n+          fraction_of_remainder,\n+          total_buffer_size,\n+          allowed_split_points,\n+          self.receivers[0].try_split)\n+      if split:\n+        self.stop = split[-1]\n+      return split\n+\n+  @staticmethod\n+  def _compute_split(\n+      index,\n+      current_element_progress,\n+      stop,\n+      fraction_of_remainder,\n+      total_buffer_size,\n+      allowed_split_points=(),\n+      try_split=lambda fraction: None):\n+    def is_valid_split_point(index):\n+      return not allowed_split_points or index in allowed_split_points\n+\n+    if total_buffer_size < index + 1:\n+      total_buffer_size = index + 1\n+    elif total_buffer_size > stop:\n+      total_buffer_size = stop\n+    # The units here (except for keep_of_element_remainder) are all in\n+    # terms of number of (possibly fractional) elements.\n+    remainder = total_buffer_size - index - current_element_progress\n+    keep = remainder * fraction_of_remainder\n+    if current_element_progress < 1:\n+      keep_of_element_remainder = keep / (1 - current_element_progress)\n+      # If it's less than what's left of the current element,\n+      # try splitting at the current element.\n+      if (keep_of_element_remainder < 1 and is_valid_split_point(index) and\n+          is_valid_split_point(index + 1)):\n+        split = try_split(\n+            keep_of_element_remainder\n+        )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n+        if split:\n+          element_primary, element_residual = split\n+          return index - 1, element_primary, element_residual, index + 1\n+    # Otherwise, split at the closest element boundary.\n+    # pylint: disable=round-builtin\n+    stop_index = index + max(1, int(round(current_element_progress + keep)))\n+    if allowed_split_points and stop_index not in allowed_split_points:\n+      allowed_split_points = sorted(allowed_split_points)\n+      closest = bisect.bisect(allowed_split_points, stop_index)\n+      if closest == 0:\n+        stop_index = allowed_split_points[0]\n+      elif closest == len(allowed_split_points):\n+        stop_index = allowed_split_points[-1]\n+      else:\n+        prev = allowed_split_points[closest - 1]\n+        next = allowed_split_points[closest]\n+        if index < prev and stop_index - prev < next - stop_index:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dad2e502e547381b6309271551051ac52b94687"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIxMTg0Nw==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/11653#discussion_r423211847", "createdAt": "2020-05-11T17:46:27Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "diffHunk": "@@ -237,30 +235,71 @@ def try_split(self, fraction_of_remainder, total_buffer_size):\n           current_element_progress = (\n               current_element_progress_object.fraction_completed)\n       # Now figure out where to split.\n-      # The units here (except for keep_of_element_remainder) are all in\n-      # terms of number of (possibly fractional) elements.\n-      remainder = total_buffer_size - self.index - current_element_progress\n-      keep = remainder * fraction_of_remainder\n-      if current_element_progress < 1:\n-        keep_of_element_remainder = keep / (1 - current_element_progress)\n-        # If it's less than what's left of the current element,\n-        # try splitting at the current element.\n-        if keep_of_element_remainder < 1:\n-          split = self.receivers[0].try_split(\n-              keep_of_element_remainder\n-          )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n-          if split:\n-            element_primary, element_residual = split\n-            self.stop = self.index + 1\n-            return self.index - 1, element_primary, element_residual, self.stop\n-      # Otherwise, split at the closest element boundary.\n-      # pylint: disable=round-builtin\n-      stop_index = (\n-          self.index + max(1, int(round(current_element_progress + keep))))\n-      if stop_index < self.stop:\n-        self.stop = stop_index\n-        return self.stop - 1, None, None, self.stop\n-    return None\n+      split = self._compute_split(\n+          self.index,\n+          current_element_progress,\n+          self.stop,\n+          fraction_of_remainder,\n+          total_buffer_size,\n+          allowed_split_points,\n+          self.receivers[0].try_split)\n+      if split:\n+        self.stop = split[-1]\n+      return split\n+\n+  @staticmethod\n+  def _compute_split(\n+      index,\n+      current_element_progress,\n+      stop,\n+      fraction_of_remainder,\n+      total_buffer_size,\n+      allowed_split_points=(),\n+      try_split=lambda fraction: None):\n+    def is_valid_split_point(index):\n+      return not allowed_split_points or index in allowed_split_points\n+\n+    if total_buffer_size < index + 1:\n+      total_buffer_size = index + 1\n+    elif total_buffer_size > stop:\n+      total_buffer_size = stop\n+    # The units here (except for keep_of_element_remainder) are all in\n+    # terms of number of (possibly fractional) elements.\n+    remainder = total_buffer_size - index - current_element_progress\n+    keep = remainder * fraction_of_remainder\n+    if current_element_progress < 1:\n+      keep_of_element_remainder = keep / (1 - current_element_progress)\n+      # If it's less than what's left of the current element,\n+      # try splitting at the current element.\n+      if (keep_of_element_remainder < 1 and is_valid_split_point(index) and\n+          is_valid_split_point(index + 1)):\n+        split = try_split(\n+            keep_of_element_remainder\n+        )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n+        if split:\n+          element_primary, element_residual = split\n+          return index - 1, element_primary, element_residual, index + 1\n+    # Otherwise, split at the closest element boundary.\n+    # pylint: disable=round-builtin\n+    stop_index = index + max(1, int(round(current_element_progress + keep)))\n+    if allowed_split_points and stop_index not in allowed_split_points:\n+      allowed_split_points = sorted(allowed_split_points)\n+      closest = bisect.bisect(allowed_split_points, stop_index)\n+      if closest == 0:\n+        stop_index = allowed_split_points[0]\n+      elif closest == len(allowed_split_points):\n+        stop_index = allowed_split_points[-1]\n+      else:\n+        prev = allowed_split_points[closest - 1]\n+        next = allowed_split_points[closest]\n+        if index < prev and stop_index - prev < next - stop_index:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4MjE5MA=="}, "originalCommit": {"oid": "3dad2e502e547381b6309271551051ac52b94687"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNTMyNjYwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/bundle_processor_test.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjo1Nzo1NVrOGTlCLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNzo0NzowMFrOGTm0nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4Mjg5Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              def test_split_with_element_progres(self):\n          \n          \n            \n              def test_split_with_element_progress(self):", "url": "https://github.com/apache/beam/pull/11653#discussion_r423182892", "createdAt": "2020-05-11T16:57:55Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor_test.py", "diffHunk": "@@ -0,0 +1,118 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Unit tests for bundle processing.\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import unittest\n+\n+from apache_beam.runners.worker.bundle_processor import DataInputOperation\n+\n+\n+def simple_split(first_residual_index):\n+  return first_residual_index - 1, None, None, first_residual_index\n+\n+\n+def element_split(frac, index):\n+  return (\n+      index - 1,\n+      'Primary(%0.1f)' % frac,\n+      'Residual(%0.1f)' % (1 - frac),\n+      index + 1)\n+\n+\n+class SplitTest(unittest.TestCase):\n+  def split(\n+      self,\n+      index,\n+      current_element_progress,\n+      fraction_of_remainder,\n+      buffer_size,\n+      allowed=(),\n+      sdf=False):\n+    return DataInputOperation._compute_split(\n+        index,\n+        current_element_progress,\n+        float('inf'),\n+        fraction_of_remainder,\n+        buffer_size,\n+        allowed_split_points=allowed,\n+        try_split=lambda frac: element_split(frac, 0)[1:3] if sdf else None)\n+\n+  def sdf_split(self, *args, **kwargs):\n+    return self.split(*args, sdf=True, **kwargs)\n+\n+  def test_simple_split(self):\n+    self.assertEqual(self.split(0, 0, 0, 16), simple_split(1))\n+    self.assertEqual(self.split(0, 0, 0.24, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.25, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.26, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.5, 16), simple_split(8))\n+    self.assertEqual(self.split(2, 0, 0.5, 16), simple_split(9))\n+    self.assertEqual(self.split(6, 0, 0.5, 16), simple_split(11))\n+\n+  def test_split_with_element_progres(self):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dad2e502e547381b6309271551051ac52b94687"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIxMjE4OA==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/11653#discussion_r423212188", "createdAt": "2020-05-11T17:47:00Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor_test.py", "diffHunk": "@@ -0,0 +1,118 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Unit tests for bundle processing.\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import unittest\n+\n+from apache_beam.runners.worker.bundle_processor import DataInputOperation\n+\n+\n+def simple_split(first_residual_index):\n+  return first_residual_index - 1, None, None, first_residual_index\n+\n+\n+def element_split(frac, index):\n+  return (\n+      index - 1,\n+      'Primary(%0.1f)' % frac,\n+      'Residual(%0.1f)' % (1 - frac),\n+      index + 1)\n+\n+\n+class SplitTest(unittest.TestCase):\n+  def split(\n+      self,\n+      index,\n+      current_element_progress,\n+      fraction_of_remainder,\n+      buffer_size,\n+      allowed=(),\n+      sdf=False):\n+    return DataInputOperation._compute_split(\n+        index,\n+        current_element_progress,\n+        float('inf'),\n+        fraction_of_remainder,\n+        buffer_size,\n+        allowed_split_points=allowed,\n+        try_split=lambda frac: element_split(frac, 0)[1:3] if sdf else None)\n+\n+  def sdf_split(self, *args, **kwargs):\n+    return self.split(*args, sdf=True, **kwargs)\n+\n+  def test_simple_split(self):\n+    self.assertEqual(self.split(0, 0, 0, 16), simple_split(1))\n+    self.assertEqual(self.split(0, 0, 0.24, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.25, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.26, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.5, 16), simple_split(8))\n+    self.assertEqual(self.split(2, 0, 0.5, 16), simple_split(9))\n+    self.assertEqual(self.split(6, 0, 0.5, 16), simple_split(11))\n+\n+  def test_split_with_element_progres(self):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4Mjg5Mg=="}, "originalCommit": {"oid": "3dad2e502e547381b6309271551051ac52b94687"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNTM0MjY2OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/bundle_processor_test.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNzowMTo1NFrOGTlMJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxODowMzowMVrOGTnYYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NTQ0NQ==", "bodyText": "It would be good to either add comments or break out the tests to separate methods to describe the different scenarios such as round to closest.", "url": "https://github.com/apache/beam/pull/11653#discussion_r423185445", "createdAt": "2020-05-11T17:01:54Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor_test.py", "diffHunk": "@@ -0,0 +1,118 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Unit tests for bundle processing.\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import unittest\n+\n+from apache_beam.runners.worker.bundle_processor import DataInputOperation\n+\n+\n+def simple_split(first_residual_index):\n+  return first_residual_index - 1, None, None, first_residual_index\n+\n+\n+def element_split(frac, index):\n+  return (\n+      index - 1,\n+      'Primary(%0.1f)' % frac,\n+      'Residual(%0.1f)' % (1 - frac),\n+      index + 1)\n+\n+\n+class SplitTest(unittest.TestCase):\n+  def split(\n+      self,\n+      index,\n+      current_element_progress,\n+      fraction_of_remainder,\n+      buffer_size,\n+      allowed=(),\n+      sdf=False):\n+    return DataInputOperation._compute_split(\n+        index,\n+        current_element_progress,\n+        float('inf'),\n+        fraction_of_remainder,\n+        buffer_size,\n+        allowed_split_points=allowed,\n+        try_split=lambda frac: element_split(frac, 0)[1:3] if sdf else None)\n+\n+  def sdf_split(self, *args, **kwargs):\n+    return self.split(*args, sdf=True, **kwargs)\n+\n+  def test_simple_split(self):\n+    self.assertEqual(self.split(0, 0, 0, 16), simple_split(1))\n+    self.assertEqual(self.split(0, 0, 0.24, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.25, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.26, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.5, 16), simple_split(8))\n+    self.assertEqual(self.split(2, 0, 0.5, 16), simple_split(9))\n+    self.assertEqual(self.split(6, 0, 0.5, 16), simple_split(11))\n+\n+  def test_split_with_element_progres(self):\n+    self.assertEqual(self.split(0, 0.5, 0.25, 4), simple_split(1))\n+    self.assertEqual(self.split(0, 0.9, 0.25, 4), simple_split(2))\n+    self.assertEqual(self.split(1, 0.0, 0.25, 4), simple_split(2))\n+    self.assertEqual(self.split(1, 0.1, 0.25, 4), simple_split(2))\n+\n+  def test_split_with_element_allowed_splits(self):\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 4, 5)), simple_split(4))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 5)), simple_split(5))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 6)), simple_split(3))\n+\n+    self.assertEqual(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dad2e502e547381b6309271551051ac52b94687"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIyMTM0NA==", "bodyText": "I kept them in the same methods, because it's easier to understand the values relative to the prior examples.", "url": "https://github.com/apache/beam/pull/11653#discussion_r423221344", "createdAt": "2020-05-11T18:03:01Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor_test.py", "diffHunk": "@@ -0,0 +1,118 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Unit tests for bundle processing.\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import unittest\n+\n+from apache_beam.runners.worker.bundle_processor import DataInputOperation\n+\n+\n+def simple_split(first_residual_index):\n+  return first_residual_index - 1, None, None, first_residual_index\n+\n+\n+def element_split(frac, index):\n+  return (\n+      index - 1,\n+      'Primary(%0.1f)' % frac,\n+      'Residual(%0.1f)' % (1 - frac),\n+      index + 1)\n+\n+\n+class SplitTest(unittest.TestCase):\n+  def split(\n+      self,\n+      index,\n+      current_element_progress,\n+      fraction_of_remainder,\n+      buffer_size,\n+      allowed=(),\n+      sdf=False):\n+    return DataInputOperation._compute_split(\n+        index,\n+        current_element_progress,\n+        float('inf'),\n+        fraction_of_remainder,\n+        buffer_size,\n+        allowed_split_points=allowed,\n+        try_split=lambda frac: element_split(frac, 0)[1:3] if sdf else None)\n+\n+  def sdf_split(self, *args, **kwargs):\n+    return self.split(*args, sdf=True, **kwargs)\n+\n+  def test_simple_split(self):\n+    self.assertEqual(self.split(0, 0, 0, 16), simple_split(1))\n+    self.assertEqual(self.split(0, 0, 0.24, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.25, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.26, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.5, 16), simple_split(8))\n+    self.assertEqual(self.split(2, 0, 0.5, 16), simple_split(9))\n+    self.assertEqual(self.split(6, 0, 0.5, 16), simple_split(11))\n+\n+  def test_split_with_element_progres(self):\n+    self.assertEqual(self.split(0, 0.5, 0.25, 4), simple_split(1))\n+    self.assertEqual(self.split(0, 0.9, 0.25, 4), simple_split(2))\n+    self.assertEqual(self.split(1, 0.0, 0.25, 4), simple_split(2))\n+    self.assertEqual(self.split(1, 0.1, 0.25, 4), simple_split(2))\n+\n+  def test_split_with_element_allowed_splits(self):\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 4, 5)), simple_split(4))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 5)), simple_split(5))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 6)), simple_split(3))\n+\n+    self.assertEqual(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NTQ0NQ=="}, "originalCommit": {"oid": "3dad2e502e547381b6309271551051ac52b94687"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNTM0NjI2OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/bundle_processor_test.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNzowMjo0OVrOGTlOYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxODo1NjoxNlrOGTpL6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NjAxOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                self.assertEqual(\n          \n          \n            \n                    self.sdf_split(0, 0, 0.12, 4), (-1, 'Primary(0.5)', 'Residual(0.5)', 1))\n          \n          \n            \n                self.assertEqual(\n          \n          \n            \n                    self.sdf_split(0, 0, 0.125, 4), (-1, 'Primary(0.5)', 'Residual(0.5)', 1))", "url": "https://github.com/apache/beam/pull/11653#discussion_r423186018", "createdAt": "2020-05-11T17:02:49Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor_test.py", "diffHunk": "@@ -0,0 +1,118 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Unit tests for bundle processing.\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import unittest\n+\n+from apache_beam.runners.worker.bundle_processor import DataInputOperation\n+\n+\n+def simple_split(first_residual_index):\n+  return first_residual_index - 1, None, None, first_residual_index\n+\n+\n+def element_split(frac, index):\n+  return (\n+      index - 1,\n+      'Primary(%0.1f)' % frac,\n+      'Residual(%0.1f)' % (1 - frac),\n+      index + 1)\n+\n+\n+class SplitTest(unittest.TestCase):\n+  def split(\n+      self,\n+      index,\n+      current_element_progress,\n+      fraction_of_remainder,\n+      buffer_size,\n+      allowed=(),\n+      sdf=False):\n+    return DataInputOperation._compute_split(\n+        index,\n+        current_element_progress,\n+        float('inf'),\n+        fraction_of_remainder,\n+        buffer_size,\n+        allowed_split_points=allowed,\n+        try_split=lambda frac: element_split(frac, 0)[1:3] if sdf else None)\n+\n+  def sdf_split(self, *args, **kwargs):\n+    return self.split(*args, sdf=True, **kwargs)\n+\n+  def test_simple_split(self):\n+    self.assertEqual(self.split(0, 0, 0, 16), simple_split(1))\n+    self.assertEqual(self.split(0, 0, 0.24, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.25, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.26, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.5, 16), simple_split(8))\n+    self.assertEqual(self.split(2, 0, 0.5, 16), simple_split(9))\n+    self.assertEqual(self.split(6, 0, 0.5, 16), simple_split(11))\n+\n+  def test_split_with_element_progres(self):\n+    self.assertEqual(self.split(0, 0.5, 0.25, 4), simple_split(1))\n+    self.assertEqual(self.split(0, 0.9, 0.25, 4), simple_split(2))\n+    self.assertEqual(self.split(1, 0.0, 0.25, 4), simple_split(2))\n+    self.assertEqual(self.split(1, 0.1, 0.25, 4), simple_split(2))\n+\n+  def test_split_with_element_allowed_splits(self):\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 4, 5)), simple_split(4))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 5)), simple_split(5))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 6)), simple_split(3))\n+\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(5, 6, 7)), simple_split(5))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(1, 2, 3)), simple_split(3))\n+\n+    self.assertEqual(self.split(5, 0, 0.25, 16, allowed=(1, 2, 3)), None)\n+\n+  def test_sdf_split(self):\n+    self.assertEqual(self.sdf_split(0, 0, 0.51, 4), simple_split(2))\n+    self.assertEqual(self.sdf_split(0, 0, 0.49, 4), simple_split(2))\n+    self.assertEqual(self.sdf_split(0, 0, 0.26, 4), simple_split(1))\n+    self.assertEqual(self.sdf_split(0, 0, 0.25, 4), simple_split(1))\n+    self.assertEqual(\n+        self.sdf_split(0, 0, 0.20, 4), (-1, 'Primary(0.8)', 'Residual(0.2)', 1))\n+    self.assertEqual(\n+        self.sdf_split(0, 0, 0.12, 4), (-1, 'Primary(0.5)', 'Residual(0.5)', 1))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dad2e502e547381b6309271551051ac52b94687"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIxMjg1Mg==", "bodyText": "I had this originally, but it bumped the formatting, and .12 was close enough. I can change this back.", "url": "https://github.com/apache/beam/pull/11653#discussion_r423212852", "createdAt": "2020-05-11T17:48:09Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor_test.py", "diffHunk": "@@ -0,0 +1,118 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Unit tests for bundle processing.\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import unittest\n+\n+from apache_beam.runners.worker.bundle_processor import DataInputOperation\n+\n+\n+def simple_split(first_residual_index):\n+  return first_residual_index - 1, None, None, first_residual_index\n+\n+\n+def element_split(frac, index):\n+  return (\n+      index - 1,\n+      'Primary(%0.1f)' % frac,\n+      'Residual(%0.1f)' % (1 - frac),\n+      index + 1)\n+\n+\n+class SplitTest(unittest.TestCase):\n+  def split(\n+      self,\n+      index,\n+      current_element_progress,\n+      fraction_of_remainder,\n+      buffer_size,\n+      allowed=(),\n+      sdf=False):\n+    return DataInputOperation._compute_split(\n+        index,\n+        current_element_progress,\n+        float('inf'),\n+        fraction_of_remainder,\n+        buffer_size,\n+        allowed_split_points=allowed,\n+        try_split=lambda frac: element_split(frac, 0)[1:3] if sdf else None)\n+\n+  def sdf_split(self, *args, **kwargs):\n+    return self.split(*args, sdf=True, **kwargs)\n+\n+  def test_simple_split(self):\n+    self.assertEqual(self.split(0, 0, 0, 16), simple_split(1))\n+    self.assertEqual(self.split(0, 0, 0.24, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.25, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.26, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.5, 16), simple_split(8))\n+    self.assertEqual(self.split(2, 0, 0.5, 16), simple_split(9))\n+    self.assertEqual(self.split(6, 0, 0.5, 16), simple_split(11))\n+\n+  def test_split_with_element_progres(self):\n+    self.assertEqual(self.split(0, 0.5, 0.25, 4), simple_split(1))\n+    self.assertEqual(self.split(0, 0.9, 0.25, 4), simple_split(2))\n+    self.assertEqual(self.split(1, 0.0, 0.25, 4), simple_split(2))\n+    self.assertEqual(self.split(1, 0.1, 0.25, 4), simple_split(2))\n+\n+  def test_split_with_element_allowed_splits(self):\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 4, 5)), simple_split(4))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 5)), simple_split(5))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 6)), simple_split(3))\n+\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(5, 6, 7)), simple_split(5))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(1, 2, 3)), simple_split(3))\n+\n+    self.assertEqual(self.split(5, 0, 0.25, 16, allowed=(1, 2, 3)), None)\n+\n+  def test_sdf_split(self):\n+    self.assertEqual(self.sdf_split(0, 0, 0.51, 4), simple_split(2))\n+    self.assertEqual(self.sdf_split(0, 0, 0.49, 4), simple_split(2))\n+    self.assertEqual(self.sdf_split(0, 0, 0.26, 4), simple_split(1))\n+    self.assertEqual(self.sdf_split(0, 0, 0.25, 4), simple_split(1))\n+    self.assertEqual(\n+        self.sdf_split(0, 0, 0.20, 4), (-1, 'Primary(0.8)', 'Residual(0.2)', 1))\n+    self.assertEqual(\n+        self.sdf_split(0, 0, 0.12, 4), (-1, 'Primary(0.5)', 'Residual(0.5)', 1))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NjAxOA=="}, "originalCommit": {"oid": "3dad2e502e547381b6309271551051ac52b94687"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI1MDkyMg==", "bodyText": "I found it confusing that the rounding dropped the fractional part when I was running through the scenarios.", "url": "https://github.com/apache/beam/pull/11653#discussion_r423250922", "createdAt": "2020-05-11T18:56:16Z", "author": {"login": "lukecwik"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor_test.py", "diffHunk": "@@ -0,0 +1,118 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Unit tests for bundle processing.\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import unittest\n+\n+from apache_beam.runners.worker.bundle_processor import DataInputOperation\n+\n+\n+def simple_split(first_residual_index):\n+  return first_residual_index - 1, None, None, first_residual_index\n+\n+\n+def element_split(frac, index):\n+  return (\n+      index - 1,\n+      'Primary(%0.1f)' % frac,\n+      'Residual(%0.1f)' % (1 - frac),\n+      index + 1)\n+\n+\n+class SplitTest(unittest.TestCase):\n+  def split(\n+      self,\n+      index,\n+      current_element_progress,\n+      fraction_of_remainder,\n+      buffer_size,\n+      allowed=(),\n+      sdf=False):\n+    return DataInputOperation._compute_split(\n+        index,\n+        current_element_progress,\n+        float('inf'),\n+        fraction_of_remainder,\n+        buffer_size,\n+        allowed_split_points=allowed,\n+        try_split=lambda frac: element_split(frac, 0)[1:3] if sdf else None)\n+\n+  def sdf_split(self, *args, **kwargs):\n+    return self.split(*args, sdf=True, **kwargs)\n+\n+  def test_simple_split(self):\n+    self.assertEqual(self.split(0, 0, 0, 16), simple_split(1))\n+    self.assertEqual(self.split(0, 0, 0.24, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.25, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.26, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.5, 16), simple_split(8))\n+    self.assertEqual(self.split(2, 0, 0.5, 16), simple_split(9))\n+    self.assertEqual(self.split(6, 0, 0.5, 16), simple_split(11))\n+\n+  def test_split_with_element_progres(self):\n+    self.assertEqual(self.split(0, 0.5, 0.25, 4), simple_split(1))\n+    self.assertEqual(self.split(0, 0.9, 0.25, 4), simple_split(2))\n+    self.assertEqual(self.split(1, 0.0, 0.25, 4), simple_split(2))\n+    self.assertEqual(self.split(1, 0.1, 0.25, 4), simple_split(2))\n+\n+  def test_split_with_element_allowed_splits(self):\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 4, 5)), simple_split(4))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 5)), simple_split(5))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 6)), simple_split(3))\n+\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(5, 6, 7)), simple_split(5))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(1, 2, 3)), simple_split(3))\n+\n+    self.assertEqual(self.split(5, 0, 0.25, 16, allowed=(1, 2, 3)), None)\n+\n+  def test_sdf_split(self):\n+    self.assertEqual(self.sdf_split(0, 0, 0.51, 4), simple_split(2))\n+    self.assertEqual(self.sdf_split(0, 0, 0.49, 4), simple_split(2))\n+    self.assertEqual(self.sdf_split(0, 0, 0.26, 4), simple_split(1))\n+    self.assertEqual(self.sdf_split(0, 0, 0.25, 4), simple_split(1))\n+    self.assertEqual(\n+        self.sdf_split(0, 0, 0.20, 4), (-1, 'Primary(0.8)', 'Residual(0.2)', 1))\n+    self.assertEqual(\n+        self.sdf_split(0, 0, 0.12, 4), (-1, 'Primary(0.5)', 'Residual(0.5)', 1))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NjAxOA=="}, "originalCommit": {"oid": "3dad2e502e547381b6309271551051ac52b94687"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNTc3MzE1OnYy", "diffSide": "RIGHT", "path": "model/fn-execution/src/main/proto/beam_fn_api.proto", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxOTowNTowOFrOGTpfQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxOTowNTowOFrOGTpfQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI1NTg3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // preceded an allowed split point.\n          \n          \n            \n                // precede an allowed split point.", "url": "https://github.com/apache/beam/pull/11653#discussion_r423255873", "createdAt": "2020-05-11T19:05:08Z", "author": {"login": "lukecwik"}, "path": "model/fn-execution/src/main/proto/beam_fn_api.proto", "diffHunk": "@@ -375,6 +375,9 @@ message ProcessBundleSplitRequest {\n \n     // A set of allowed element indices where the SDK may split. When this is\n     // empty, there are no constraints on where to split.\n+    // Specifically, the first_residual_element of a split result must be an\n+    // allowed split point, and the last_primary_element must immediately\n+    // preceded an allowed split point.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "773854cd6a7e2429f5c5e704f875aef89233879b"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNjMwNzgyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMTo1NToxNVrOGTuykQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMToxNTo1NVrOGVD0Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0MjczNw==", "bodyText": "Is total_buffer_size the current outstanding buffer of data? Eg. The elements sent to the SDK, but as yet unprocessed?", "url": "https://github.com/apache/beam/pull/11653#discussion_r423342737", "createdAt": "2020-05-11T21:55:15Z", "author": {"login": "lostluck"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "diffHunk": "@@ -237,30 +235,72 @@ def try_split(self, fraction_of_remainder, total_buffer_size):\n           current_element_progress = (\n               current_element_progress_object.fraction_completed)\n       # Now figure out where to split.\n-      # The units here (except for keep_of_element_remainder) are all in\n-      # terms of number of (possibly fractional) elements.\n-      remainder = total_buffer_size - self.index - current_element_progress\n-      keep = remainder * fraction_of_remainder\n-      if current_element_progress < 1:\n-        keep_of_element_remainder = keep / (1 - current_element_progress)\n-        # If it's less than what's left of the current element,\n-        # try splitting at the current element.\n-        if keep_of_element_remainder < 1:\n-          split = self.receivers[0].try_split(\n-              keep_of_element_remainder\n-          )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n-          if split:\n-            element_primary, element_residual = split\n-            self.stop = self.index + 1\n-            return self.index - 1, element_primary, element_residual, self.stop\n-      # Otherwise, split at the closest element boundary.\n-      # pylint: disable=round-builtin\n-      stop_index = (\n-          self.index + max(1, int(round(current_element_progress + keep))))\n-      if stop_index < self.stop:\n-        self.stop = stop_index\n-        return self.stop - 1, None, None, self.stop\n-    return None\n+      split = self._compute_split(\n+          self.index,\n+          current_element_progress,\n+          self.stop,\n+          fraction_of_remainder,\n+          total_buffer_size,\n+          allowed_split_points,\n+          self.receivers[0].try_split)\n+      if split:\n+        self.stop = split[-1]\n+      return split\n+\n+  @staticmethod\n+  def _compute_split(\n+      index,\n+      current_element_progress,\n+      stop,\n+      fraction_of_remainder,\n+      total_buffer_size,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "773854cd6a7e2429f5c5e704f875aef89233879b"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQxOTQ0OQ==", "bodyText": "I believe it should be the total number of input element: \n  \n    \n      beam/model/fn-execution/src/main/proto/beam_fn_api.proto\n    \n    \n        Lines 383 to 386\n      in\n      cad0333\n    \n    \n    \n    \n\n        \n          \n           // (Required for GrpcRead operations) Number of total elements expected \n        \n\n        \n          \n           // to be sent to this GrpcRead operation, required to correctly account \n        \n\n        \n          \n           // for unreceived data when determining where to split. \n        \n\n        \n          \n           int64 estimated_input_elements = 2;", "url": "https://github.com/apache/beam/pull/11653#discussion_r423419449", "createdAt": "2020-05-12T02:00:46Z", "author": {"login": "boyuanzz"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "diffHunk": "@@ -237,30 +235,72 @@ def try_split(self, fraction_of_remainder, total_buffer_size):\n           current_element_progress = (\n               current_element_progress_object.fraction_completed)\n       # Now figure out where to split.\n-      # The units here (except for keep_of_element_remainder) are all in\n-      # terms of number of (possibly fractional) elements.\n-      remainder = total_buffer_size - self.index - current_element_progress\n-      keep = remainder * fraction_of_remainder\n-      if current_element_progress < 1:\n-        keep_of_element_remainder = keep / (1 - current_element_progress)\n-        # If it's less than what's left of the current element,\n-        # try splitting at the current element.\n-        if keep_of_element_remainder < 1:\n-          split = self.receivers[0].try_split(\n-              keep_of_element_remainder\n-          )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n-          if split:\n-            element_primary, element_residual = split\n-            self.stop = self.index + 1\n-            return self.index - 1, element_primary, element_residual, self.stop\n-      # Otherwise, split at the closest element boundary.\n-      # pylint: disable=round-builtin\n-      stop_index = (\n-          self.index + max(1, int(round(current_element_progress + keep))))\n-      if stop_index < self.stop:\n-        self.stop = stop_index\n-        return self.stop - 1, None, None, self.stop\n-    return None\n+      split = self._compute_split(\n+          self.index,\n+          current_element_progress,\n+          self.stop,\n+          fraction_of_remainder,\n+          total_buffer_size,\n+          allowed_split_points,\n+          self.receivers[0].try_split)\n+      if split:\n+        self.stop = split[-1]\n+      return split\n+\n+  @staticmethod\n+  def _compute_split(\n+      index,\n+      current_element_progress,\n+      stop,\n+      fraction_of_remainder,\n+      total_buffer_size,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0MjczNw=="}, "originalCommit": {"oid": "773854cd6a7e2429f5c5e704f875aef89233879b"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkxNDc4OA==", "bodyText": "It's the number of known input elements. What really matters is it's the size that fraction of remainder should be computed relative to.", "url": "https://github.com/apache/beam/pull/11653#discussion_r423914788", "createdAt": "2020-05-12T17:38:17Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "diffHunk": "@@ -237,30 +235,72 @@ def try_split(self, fraction_of_remainder, total_buffer_size):\n           current_element_progress = (\n               current_element_progress_object.fraction_completed)\n       # Now figure out where to split.\n-      # The units here (except for keep_of_element_remainder) are all in\n-      # terms of number of (possibly fractional) elements.\n-      remainder = total_buffer_size - self.index - current_element_progress\n-      keep = remainder * fraction_of_remainder\n-      if current_element_progress < 1:\n-        keep_of_element_remainder = keep / (1 - current_element_progress)\n-        # If it's less than what's left of the current element,\n-        # try splitting at the current element.\n-        if keep_of_element_remainder < 1:\n-          split = self.receivers[0].try_split(\n-              keep_of_element_remainder\n-          )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n-          if split:\n-            element_primary, element_residual = split\n-            self.stop = self.index + 1\n-            return self.index - 1, element_primary, element_residual, self.stop\n-      # Otherwise, split at the closest element boundary.\n-      # pylint: disable=round-builtin\n-      stop_index = (\n-          self.index + max(1, int(round(current_element_progress + keep))))\n-      if stop_index < self.stop:\n-        self.stop = stop_index\n-        return self.stop - 1, None, None, self.stop\n-    return None\n+      split = self._compute_split(\n+          self.index,\n+          current_element_progress,\n+          self.stop,\n+          fraction_of_remainder,\n+          total_buffer_size,\n+          allowed_split_points,\n+          self.receivers[0].try_split)\n+      if split:\n+        self.stop = split[-1]\n+      return split\n+\n+  @staticmethod\n+  def _compute_split(\n+      index,\n+      current_element_progress,\n+      stop,\n+      fraction_of_remainder,\n+      total_buffer_size,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0MjczNw=="}, "originalCommit": {"oid": "773854cd6a7e2429f5c5e704f875aef89233879b"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDczNTc0Nw==", "bodyText": "The part I missed was that this is provided by the runner as part of the DesiredSplit, rather than something computed by the SDK itself. I didn't see that change. This all makes sense. Thanks!", "url": "https://github.com/apache/beam/pull/11653#discussion_r424735747", "createdAt": "2020-05-13T21:15:55Z", "author": {"login": "lostluck"}, "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "diffHunk": "@@ -237,30 +235,72 @@ def try_split(self, fraction_of_remainder, total_buffer_size):\n           current_element_progress = (\n               current_element_progress_object.fraction_completed)\n       # Now figure out where to split.\n-      # The units here (except for keep_of_element_remainder) are all in\n-      # terms of number of (possibly fractional) elements.\n-      remainder = total_buffer_size - self.index - current_element_progress\n-      keep = remainder * fraction_of_remainder\n-      if current_element_progress < 1:\n-        keep_of_element_remainder = keep / (1 - current_element_progress)\n-        # If it's less than what's left of the current element,\n-        # try splitting at the current element.\n-        if keep_of_element_remainder < 1:\n-          split = self.receivers[0].try_split(\n-              keep_of_element_remainder\n-          )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n-          if split:\n-            element_primary, element_residual = split\n-            self.stop = self.index + 1\n-            return self.index - 1, element_primary, element_residual, self.stop\n-      # Otherwise, split at the closest element boundary.\n-      # pylint: disable=round-builtin\n-      stop_index = (\n-          self.index + max(1, int(round(current_element_progress + keep))))\n-      if stop_index < self.stop:\n-        self.stop = stop_index\n-        return self.stop - 1, None, None, self.stop\n-    return None\n+      split = self._compute_split(\n+          self.index,\n+          current_element_progress,\n+          self.stop,\n+          fraction_of_remainder,\n+          total_buffer_size,\n+          allowed_split_points,\n+          self.receivers[0].try_split)\n+      if split:\n+        self.stop = split[-1]\n+      return split\n+\n+  @staticmethod\n+  def _compute_split(\n+      index,\n+      current_element_progress,\n+      stop,\n+      fraction_of_remainder,\n+      total_buffer_size,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0MjczNw=="}, "originalCommit": {"oid": "773854cd6a7e2429f5c5e704f875aef89233879b"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3892, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}