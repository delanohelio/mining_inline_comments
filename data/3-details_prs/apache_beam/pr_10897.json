{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2ODk5NTk3", "number": 10897, "title": "[BEAM-2939] Java UnboundedSource SDF wrapper", "bodyText": "Thank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nApex\nDataflow\nFlink\nGearpump\nSamza\nSpark\n\n\n\n\nGo\n\n---\n---\n\n---\n---\n\n\n\nJava\n\n\n\n\n\n\n\n\n\nPython\n\n---\n\n\n---\n---\n\n\n\nXLang\n---\n---\n---\n\n---\n---\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-02-19T00:12:31Z", "url": "https://github.com/apache/beam/pull/10897", "merged": true, "mergeCommit": {"oid": "bd7755f89623ecaedc56e67a44b7b2c443bef5dc"}, "closed": true, "closedAt": "2020-03-03T03:15:19Z", "author": {"login": "lukecwik"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcFr-EYgBqjMwNDk4MjkyNDM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcZmdJWgFqTM5Njg0NDgwNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d74736b1a688704448e1c957a299f9aeaa546814", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/d74736b1a688704448e1c957a299f9aeaa546814", "committedDate": "2020-02-19T00:11:36Z", "message": "fixup!"}, "afterCommit": {"oid": "3a0abcb4e1a17be8e91a8df71a54044e3771c502", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/3a0abcb4e1a17be8e91a8df71a54044e3771c502", "committedDate": "2020-02-19T01:09:12Z", "message": "[BEAM-XXX] Implement UnboundedSource wrapper."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3a0abcb4e1a17be8e91a8df71a54044e3771c502", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/3a0abcb4e1a17be8e91a8df71a54044e3771c502", "committedDate": "2020-02-19T01:09:12Z", "message": "[BEAM-XXX] Implement UnboundedSource wrapper."}, "afterCommit": {"oid": "be048806002c21d086cf729cfbf225d4a1699fd3", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/be048806002c21d086cf729cfbf225d4a1699fd3", "committedDate": "2020-02-19T20:00:13Z", "message": "[BEAM-XXX] Implement UnboundedSource wrapper."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNTc3NTgz", "url": "https://github.com/apache/beam/pull/10897#pullrequestreview-361577583", "createdAt": "2020-02-20T01:23:29Z", "commit": {"oid": "be048806002c21d086cf729cfbf225d4a1699fd3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwMToyMzoyOVrOFr9r0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwMToyMzoyOVrOFr9r0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0MzcyOQ==", "bodyText": "Nice. So looks like we don't have to create new Java transforms to use existing sources ?", "url": "https://github.com/apache/beam/pull/10897#discussion_r381643729", "createdAt": "2020-02-20T01:23:29Z", "author": {"login": "chamikaramj"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -182,6 +198,37 @@ private Unbounded(@Nullable String name, UnboundedSource<T, ?> source) {\n     @Override\n     public final PCollection<T> expand(PBegin input) {\n       source.validate();\n+\n+      if (ExperimentalOptions.hasExperiment(input.getPipeline().getOptions(), \"beam_fn_api\")\n+          && !ExperimentalOptions.hasExperiment(\n+              input.getPipeline().getOptions(), \"beam_fn_api_use_deprecated_read\")) {\n+        // We don't use Create here since Create is defined as a BoundedSource and using it would\n+        // cause an infinite expansion loop. We can reconsider this if Create is implemented\n+        // directly as a SplittableDoFn.\n+        PCollection<ValueWithRecordId<T>> outputWithIds =\n+            input\n+                .getPipeline()\n+                .apply(Impulse.create())\n+                .apply(\n+                    MapElements.into(new TypeDescriptor<UnboundedSource<T, CheckpointMark>>() {})\n+                        .via(element -> (UnboundedSource<T, CheckpointMark>) source))\n+                .setCoder(\n+                    SerializableCoder.of(\n+                        new TypeDescriptor<UnboundedSource<T, CheckpointMark>>() {}))\n+                .apply(\n+                    ParDo.of(\n+                        new UnboundedSourceAsSDFWrapperFn<>(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be048806002c21d086cf729cfbf225d4a1699fd3"}, "originalPosition": 66}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "be048806002c21d086cf729cfbf225d4a1699fd3", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/be048806002c21d086cf729cfbf225d4a1699fd3", "committedDate": "2020-02-19T20:00:13Z", "message": "[BEAM-XXX] Implement UnboundedSource wrapper."}, "afterCommit": {"oid": "228e5844a5022439cc048b19f070e1561b8ec94f", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/228e5844a5022439cc048b19f070e1561b8ec94f", "committedDate": "2020-02-24T19:51:03Z", "message": "[BEAM-2939] Implement UnboundedSource wrapper."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1Mjc1NjIw", "url": "https://github.com/apache/beam/pull/10897#pullrequestreview-365275620", "createdAt": "2020-02-26T22:00:53Z", "commit": {"oid": "228e5844a5022439cc048b19f070e1561b8ec94f"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMjowMDo1M1rOFu97-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMzoxOTo0NFrOFu_9eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc5MzU5Mw==", "bodyText": "It seems the risk is higher setting this too low than too high--maybe 100 or more? (Is there a JIRA for letting the runner pass this in?)", "url": "https://github.com/apache/beam/pull/10897#discussion_r384793593", "createdAt": "2020-02-26T22:00:53Z", "author": {"login": "robertwb"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -375,4 +422,361 @@ public void checkDone() throws IllegalStateException {\n       }\n     }\n   }\n+\n+  /**\n+   * A splittable {@link DoFn} which executes an {@link UnboundedSource}.\n+   *\n+   * <p>We model the element as the original source and the restriction as a pair of the sub-source\n+   * and its {@link CheckpointMark}. This allows us to split the sub-source over and over as long as\n+   * the checkpoint mark is {@code null} or the {@link NoopCheckpointMark} since it does not\n+   * maintain any state.\n+   */\n+  // TODO: Support reporting the watermark, currently the watermark never advances.\n+  @UnboundedPerElement\n+  static class UnboundedSourceAsSDFWrapperFn<OutputT, CheckpointT extends CheckpointMark>\n+      extends DoFn<UnboundedSource<OutputT, CheckpointT>, ValueWithRecordId<OutputT>> {\n+\n+    private static final int DEFAULT_DESIRED_NUM_SPLITS = 20;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "228e5844a5022439cc048b19f070e1561b8ec94f"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyMDM1NA==", "bodyText": "Is \"named tuple\" also java terminology, or should this be a POJO?", "url": "https://github.com/apache/beam/pull/10897#discussion_r384820354", "createdAt": "2020-02-26T23:01:44Z", "author": {"login": "robertwb"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -375,4 +422,361 @@ public void checkDone() throws IllegalStateException {\n       }\n     }\n   }\n+\n+  /**\n+   * A splittable {@link DoFn} which executes an {@link UnboundedSource}.\n+   *\n+   * <p>We model the element as the original source and the restriction as a pair of the sub-source\n+   * and its {@link CheckpointMark}. This allows us to split the sub-source over and over as long as\n+   * the checkpoint mark is {@code null} or the {@link NoopCheckpointMark} since it does not\n+   * maintain any state.\n+   */\n+  // TODO: Support reporting the watermark, currently the watermark never advances.\n+  @UnboundedPerElement\n+  static class UnboundedSourceAsSDFWrapperFn<OutputT, CheckpointT extends CheckpointMark>\n+      extends DoFn<UnboundedSource<OutputT, CheckpointT>, ValueWithRecordId<OutputT>> {\n+\n+    private static final int DEFAULT_DESIRED_NUM_SPLITS = 20;\n+    private static final int DEFAULT_BUNDLE_FINALIZATION_LIMIT_MINS = 10;\n+    private final Coder<CheckpointT> restrictionCoder;\n+\n+    private UnboundedSourceAsSDFWrapperFn(Coder<CheckpointT> restrictionCoder) {\n+      this.restrictionCoder = restrictionCoder;\n+    }\n+\n+    @GetInitialRestriction\n+    public KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> initialRestriction(\n+        @Element UnboundedSource<OutputT, CheckpointT> element) {\n+      return KV.of(element, null);\n+    }\n+\n+    @GetSize\n+    public double getSize(\n+        @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+        PipelineOptions pipelineOptions)\n+        throws Exception {\n+      if (restriction.getKey() instanceof EmptyUnboundedSource) {\n+        return 1;\n+      }\n+\n+      UnboundedReader<OutputT> reader =\n+          restriction.getKey().createReader(pipelineOptions, restriction.getValue());\n+      long size = reader.getSplitBacklogBytes();\n+      if (size != UnboundedReader.BACKLOG_UNKNOWN) {\n+        return size;\n+      }\n+      // TODO: Support \"global\" backlog reporting\n+      // size = reader.getTotalBacklogBytes();\n+      // if (size != UnboundedReader.BACKLOG_UNKNOWN) {\n+      //   return size;\n+      // }\n+      return 1;\n+    }\n+\n+    @SplitRestriction\n+    public void splitRestriction(\n+        @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+        OutputReceiver<KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>> receiver,\n+        PipelineOptions pipelineOptions)\n+        throws Exception {\n+      // The empty unbounded source is trivially done and hence we don't need to output any splits\n+      // for it.\n+      if (restriction.getKey() instanceof EmptyUnboundedSource) {\n+        return;\n+      }\n+\n+      // The UnboundedSource API does not support splitting after a meaningful checkpoint mark has\n+      // been created.\n+      if (restriction.getValue() != null\n+          && !(restriction.getValue()\n+              instanceof UnboundedSource.CheckpointMark.NoopCheckpointMark)) {\n+        receiver.output(restriction);\n+      }\n+\n+      try {\n+        for (UnboundedSource<OutputT, CheckpointT> split :\n+            restriction.getKey().split(DEFAULT_DESIRED_NUM_SPLITS, pipelineOptions)) {\n+          receiver.output(KV.of(split, null));\n+        }\n+      } catch (Exception e) {\n+        receiver.output(restriction);\n+      }\n+    }\n+\n+    @NewTracker\n+    public RestrictionTracker<\n+            KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>, UnboundedSourceValue<OutputT>[]>\n+        restrictionTracker(\n+            @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+            PipelineOptions pipelineOptions) {\n+      return new UnboundedSourceAsSDFRestrictionTracker(restriction, pipelineOptions);\n+    }\n+\n+    @ProcessElement\n+    public ProcessContinuation processElement(\n+        RestrictionTracker<\n+                KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>, UnboundedSourceValue[]>\n+            tracker,\n+        OutputReceiver<ValueWithRecordId<OutputT>> receiver,\n+        BundleFinalizer bundleFinalizer)\n+        throws IOException {\n+      UnboundedSourceValue<OutputT>[] out = new UnboundedSourceValue[1];\n+      while (tracker.tryClaim(out)) {\n+        receiver.outputWithTimestamp(\n+            new ValueWithRecordId<>(out[0].getValue(), out[0].getId()), out[0].getTimestamp());\n+      }\n+\n+      // Add the checkpoint mark to be finalized if the checkpoint mark isn't trivial.\n+      KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> currentRestriction =\n+          tracker.currentRestriction();\n+      if (currentRestriction.getValue() != null\n+          && !(tracker.currentRestriction().getValue() instanceof NoopCheckpointMark)) {\n+        bundleFinalizer.afterBundleCommit(\n+            Instant.now().plus(Duration.standardMinutes(DEFAULT_BUNDLE_FINALIZATION_LIMIT_MINS)),\n+            currentRestriction.getValue()::finalizeCheckpoint);\n+      }\n+\n+      // If we have been split/checkpoint by a runner, the tracker will have been updated to the\n+      // empty source and we will return stop. Otherwise the unbounded source has only temporarily\n+      // run out of work.\n+      if (tracker.currentRestriction().getKey() instanceof EmptyUnboundedSource) {\n+        return ProcessContinuation.stop();\n+      }\n+      return ProcessContinuation.resume();\n+    }\n+\n+    @GetRestrictionCoder\n+    public Coder<KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>> restrictionCoder() {\n+      return KvCoder.of(\n+          SerializableCoder.of(new TypeDescriptor<UnboundedSource<OutputT, CheckpointT>>() {}),\n+          NullableCoder.of(restrictionCoder));\n+    }\n+\n+    /**\n+     * A named tuple representing all the values we need to pass between the {@link UnboundedReader}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "228e5844a5022439cc048b19f070e1561b8ec94f"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyNjc0Ng==", "bodyText": "JIRA for tracking? (Or would this be 10897?) Maybe update the PR/commit description to describe the current capabilities and limitations.", "url": "https://github.com/apache/beam/pull/10897#discussion_r384826746", "createdAt": "2020-02-26T23:19:44Z", "author": {"login": "robertwb"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -375,4 +422,361 @@ public void checkDone() throws IllegalStateException {\n       }\n     }\n   }\n+\n+  /**\n+   * A splittable {@link DoFn} which executes an {@link UnboundedSource}.\n+   *\n+   * <p>We model the element as the original source and the restriction as a pair of the sub-source\n+   * and its {@link CheckpointMark}. This allows us to split the sub-source over and over as long as\n+   * the checkpoint mark is {@code null} or the {@link NoopCheckpointMark} since it does not\n+   * maintain any state.\n+   */\n+  // TODO: Support reporting the watermark, currently the watermark never advances.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "228e5844a5022439cc048b19f070e1561b8ec94f"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzMyMDMz", "url": "https://github.com/apache/beam/pull/10897#pullrequestreview-365332033", "createdAt": "2020-02-27T00:03:00Z", "commit": {"oid": "228e5844a5022439cc048b19f070e1561b8ec94f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDowMzowMFrOFvA0QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDoyMjozNFrOFvBLaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0MDc2OA==", "bodyText": "I'm curious what WindowingStrategy is going to apply here. If it's using GlobalWindow, will it work in streaming mode?", "url": "https://github.com/apache/beam/pull/10897#discussion_r384840768", "createdAt": "2020-02-27T00:03:00Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -185,6 +200,37 @@ private Unbounded(@Nullable String name, UnboundedSource<T, ?> source) {\n     @Override\n     public final PCollection<T> expand(PBegin input) {\n       source.validate();\n+\n+      if (ExperimentalOptions.hasExperiment(input.getPipeline().getOptions(), \"beam_fn_api\")\n+          && !ExperimentalOptions.hasExperiment(\n+              input.getPipeline().getOptions(), \"beam_fn_api_use_deprecated_read\")) {\n+        // We don't use Create here since Create is defined as a BoundedSource and using it would\n+        // cause an infinite expansion loop. We can reconsider this if Create is implemented\n+        // directly as a SplittableDoFn.\n+        PCollection<ValueWithRecordId<T>> outputWithIds =\n+            input\n+                .getPipeline()\n+                .apply(Impulse.create())\n+                .apply(\n+                    MapElements.into(new TypeDescriptor<UnboundedSource<T, CheckpointMark>>() {})\n+                        .via(element -> (UnboundedSource<T, CheckpointMark>) source))\n+                .setCoder(\n+                    SerializableCoder.of(\n+                        new TypeDescriptor<UnboundedSource<T, CheckpointMark>>() {}))\n+                .apply(\n+                    ParDo.of(\n+                        new UnboundedSourceAsSDFWrapperFn<>(\n+                            (Coder<CheckpointMark>) source.getCheckpointMarkCoder())))\n+                .setCoder(ValueWithRecordIdCoder.of(source.getOutputCoder()));\n+        if (source.requiresDeduping()) {\n+          outputWithIds.apply(\n+              Distinct.<ValueWithRecordId<T>, byte[]>withRepresentativeValueFn(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "228e5844a5022439cc048b19f070e1561b8ec94f"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0NjY5OQ==", "bodyText": "Also curious why each output has its own watermark. Will the watermark be different from timestamp for one given record?", "url": "https://github.com/apache/beam/pull/10897#discussion_r384846699", "createdAt": "2020-02-27T00:22:34Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -375,4 +422,361 @@ public void checkDone() throws IllegalStateException {\n       }\n     }\n   }\n+\n+  /**\n+   * A splittable {@link DoFn} which executes an {@link UnboundedSource}.\n+   *\n+   * <p>We model the element as the original source and the restriction as a pair of the sub-source\n+   * and its {@link CheckpointMark}. This allows us to split the sub-source over and over as long as\n+   * the checkpoint mark is {@code null} or the {@link NoopCheckpointMark} since it does not\n+   * maintain any state.\n+   */\n+  // TODO: Support reporting the watermark, currently the watermark never advances.\n+  @UnboundedPerElement\n+  static class UnboundedSourceAsSDFWrapperFn<OutputT, CheckpointT extends CheckpointMark>\n+      extends DoFn<UnboundedSource<OutputT, CheckpointT>, ValueWithRecordId<OutputT>> {\n+\n+    private static final int DEFAULT_DESIRED_NUM_SPLITS = 20;\n+    private static final int DEFAULT_BUNDLE_FINALIZATION_LIMIT_MINS = 10;\n+    private final Coder<CheckpointT> restrictionCoder;\n+\n+    private UnboundedSourceAsSDFWrapperFn(Coder<CheckpointT> restrictionCoder) {\n+      this.restrictionCoder = restrictionCoder;\n+    }\n+\n+    @GetInitialRestriction\n+    public KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> initialRestriction(\n+        @Element UnboundedSource<OutputT, CheckpointT> element) {\n+      return KV.of(element, null);\n+    }\n+\n+    @GetSize\n+    public double getSize(\n+        @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+        PipelineOptions pipelineOptions)\n+        throws Exception {\n+      if (restriction.getKey() instanceof EmptyUnboundedSource) {\n+        return 1;\n+      }\n+\n+      UnboundedReader<OutputT> reader =\n+          restriction.getKey().createReader(pipelineOptions, restriction.getValue());\n+      long size = reader.getSplitBacklogBytes();\n+      if (size != UnboundedReader.BACKLOG_UNKNOWN) {\n+        return size;\n+      }\n+      // TODO: Support \"global\" backlog reporting\n+      // size = reader.getTotalBacklogBytes();\n+      // if (size != UnboundedReader.BACKLOG_UNKNOWN) {\n+      //   return size;\n+      // }\n+      return 1;\n+    }\n+\n+    @SplitRestriction\n+    public void splitRestriction(\n+        @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+        OutputReceiver<KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>> receiver,\n+        PipelineOptions pipelineOptions)\n+        throws Exception {\n+      // The empty unbounded source is trivially done and hence we don't need to output any splits\n+      // for it.\n+      if (restriction.getKey() instanceof EmptyUnboundedSource) {\n+        return;\n+      }\n+\n+      // The UnboundedSource API does not support splitting after a meaningful checkpoint mark has\n+      // been created.\n+      if (restriction.getValue() != null\n+          && !(restriction.getValue()\n+              instanceof UnboundedSource.CheckpointMark.NoopCheckpointMark)) {\n+        receiver.output(restriction);\n+      }\n+\n+      try {\n+        for (UnboundedSource<OutputT, CheckpointT> split :\n+            restriction.getKey().split(DEFAULT_DESIRED_NUM_SPLITS, pipelineOptions)) {\n+          receiver.output(KV.of(split, null));\n+        }\n+      } catch (Exception e) {\n+        receiver.output(restriction);\n+      }\n+    }\n+\n+    @NewTracker\n+    public RestrictionTracker<\n+            KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>, UnboundedSourceValue<OutputT>[]>\n+        restrictionTracker(\n+            @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+            PipelineOptions pipelineOptions) {\n+      return new UnboundedSourceAsSDFRestrictionTracker(restriction, pipelineOptions);\n+    }\n+\n+    @ProcessElement\n+    public ProcessContinuation processElement(\n+        RestrictionTracker<\n+                KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>, UnboundedSourceValue[]>\n+            tracker,\n+        OutputReceiver<ValueWithRecordId<OutputT>> receiver,\n+        BundleFinalizer bundleFinalizer)\n+        throws IOException {\n+      UnboundedSourceValue<OutputT>[] out = new UnboundedSourceValue[1];\n+      while (tracker.tryClaim(out)) {\n+        receiver.outputWithTimestamp(\n+            new ValueWithRecordId<>(out[0].getValue(), out[0].getId()), out[0].getTimestamp());\n+      }\n+\n+      // Add the checkpoint mark to be finalized if the checkpoint mark isn't trivial.\n+      KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> currentRestriction =\n+          tracker.currentRestriction();\n+      if (currentRestriction.getValue() != null\n+          && !(tracker.currentRestriction().getValue() instanceof NoopCheckpointMark)) {\n+        bundleFinalizer.afterBundleCommit(\n+            Instant.now().plus(Duration.standardMinutes(DEFAULT_BUNDLE_FINALIZATION_LIMIT_MINS)),\n+            currentRestriction.getValue()::finalizeCheckpoint);\n+      }\n+\n+      // If we have been split/checkpoint by a runner, the tracker will have been updated to the\n+      // empty source and we will return stop. Otherwise the unbounded source has only temporarily\n+      // run out of work.\n+      if (tracker.currentRestriction().getKey() instanceof EmptyUnboundedSource) {\n+        return ProcessContinuation.stop();\n+      }\n+      return ProcessContinuation.resume();\n+    }\n+\n+    @GetRestrictionCoder\n+    public Coder<KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>> restrictionCoder() {\n+      return KvCoder.of(\n+          SerializableCoder.of(new TypeDescriptor<UnboundedSource<OutputT, CheckpointT>>() {}),\n+          NullableCoder.of(restrictionCoder));\n+    }\n+\n+    /**\n+     * A named tuple representing all the values we need to pass between the {@link UnboundedReader}\n+     * and the {@link org.apache.beam.sdk.transforms.DoFn.ProcessElement @ProcessElement} method of\n+     * the splittable DoFn.\n+     */\n+    @AutoValue\n+    abstract static class UnboundedSourceValue<T> {\n+      public static <T> UnboundedSourceValue<T> create(\n+          byte[] id, T value, Instant timestamp, Instant watermark) {\n+        return new AutoValue_Read_UnboundedSourceAsSDFWrapperFn_UnboundedSourceValue<T>(\n+            id, value, timestamp, watermark);\n+      }\n+\n+      @SuppressWarnings(\"mutable\")\n+      public abstract byte[] getId();\n+\n+      public abstract T getValue();\n+\n+      public abstract Instant getTimestamp();\n+\n+      public abstract Instant getWatermark();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "228e5844a5022439cc048b19f070e1561b8ec94f"}, "originalPosition": 243}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc827bd0ba108b5ee87502011e307e411281481f", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/bc827bd0ba108b5ee87502011e307e411281481f", "committedDate": "2020-03-02T23:35:51Z", "message": "[BEAM-2939] Implement UnboundedSource wrapper."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "228e5844a5022439cc048b19f070e1561b8ec94f", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/228e5844a5022439cc048b19f070e1561b8ec94f", "committedDate": "2020-02-24T19:51:03Z", "message": "[BEAM-2939] Implement UnboundedSource wrapper."}, "afterCommit": {"oid": "8eaf552be6e73a3f636425f7486b8764613fcc33", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/8eaf552be6e73a3f636425f7486b8764613fcc33", "committedDate": "2020-03-03T00:27:56Z", "message": "fixup! Plumb watermark through the ProcessContext and report it on the BundleApplication."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8eaf552be6e73a3f636425f7486b8764613fcc33", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/8eaf552be6e73a3f636425f7486b8764613fcc33", "committedDate": "2020-03-03T00:27:56Z", "message": "fixup! Plumb watermark through the ProcessContext and report it on the BundleApplication."}, "afterCommit": {"oid": "033e8f52bd3b7636d23f6e81cb0cedf1ddc1df4e", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/033e8f52bd3b7636d23f6e81cb0cedf1ddc1df4e", "committedDate": "2020-03-03T00:31:55Z", "message": "fixup! Plumb watermark through the ProcessContext and report it on the BundleApplication."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "033e8f52bd3b7636d23f6e81cb0cedf1ddc1df4e", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/033e8f52bd3b7636d23f6e81cb0cedf1ddc1df4e", "committedDate": "2020-03-03T00:31:55Z", "message": "fixup! Plumb watermark through the ProcessContext and report it on the BundleApplication."}, "afterCommit": {"oid": "26aeea0657369ddf4ed5a917bd10df288087d2bf", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/26aeea0657369ddf4ed5a917bd10df288087d2bf", "committedDate": "2020-03-03T00:36:58Z", "message": "fixup! Plumb watermark through the ProcessContext and report it on the BundleApplication."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01c12c08bc0c4a093533d93d20ecf8f8869e68c7", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/01c12c08bc0c4a093533d93d20ecf8f8869e68c7", "committedDate": "2020-03-03T00:39:11Z", "message": "fixup! Plumb watermark through the ProcessContext and report it on the BundleApplication."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "26aeea0657369ddf4ed5a917bd10df288087d2bf", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/26aeea0657369ddf4ed5a917bd10df288087d2bf", "committedDate": "2020-03-03T00:36:58Z", "message": "fixup! Plumb watermark through the ProcessContext and report it on the BundleApplication."}, "afterCommit": {"oid": "01c12c08bc0c4a093533d93d20ecf8f8869e68c7", "author": {"user": {"login": "lukecwik", "name": "Lukasz Cwik"}}, "url": "https://github.com/apache/beam/commit/01c12c08bc0c4a093533d93d20ecf8f8869e68c7", "committedDate": "2020-03-03T00:39:11Z", "message": "fixup! Plumb watermark through the ProcessContext and report it on the BundleApplication."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODQ0ODA3", "url": "https://github.com/apache/beam/pull/10897#pullrequestreview-396844807", "createdAt": "2020-04-20T22:02:24Z", "commit": {"oid": "01c12c08bc0c4a093533d93d20ecf8f8869e68c7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjowMjoyNFrOGIpheQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjowMjoyNFrOGIpheQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMjEwNQ==", "bodyText": "Do we assume that getSize here is always called for calculating backlog in streaming? It is not correct for calculating  primary size(though primary size doesn't matter for now).", "url": "https://github.com/apache/beam/pull/10897#discussion_r411722105", "createdAt": "2020-04-20T22:02:24Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -375,4 +423,372 @@ public void checkDone() throws IllegalStateException {\n       }\n     }\n   }\n+\n+  /**\n+   * A splittable {@link DoFn} which executes an {@link UnboundedSource}.\n+   *\n+   * <p>We model the element as the original source and the restriction as a pair of the sub-source\n+   * and its {@link CheckpointMark}. This allows us to split the sub-source over and over as long as\n+   * the checkpoint mark is {@code null} or the {@link NoopCheckpointMark} since it does not\n+   * maintain any state.\n+   */\n+  @UnboundedPerElement\n+  static class UnboundedSourceAsSDFWrapperFn<OutputT, CheckpointT extends CheckpointMark>\n+      extends DoFn<UnboundedSource<OutputT, CheckpointT>, ValueWithRecordId<OutputT>> {\n+    private static final Logger LOG = LoggerFactory.getLogger(UnboundedSourceAsSDFWrapperFn.class);\n+    private static final int DEFAULT_DESIRED_NUM_SPLITS = 20;\n+    private static final int DEFAULT_BUNDLE_FINALIZATION_LIMIT_MINS = 10;\n+    private final Coder<CheckpointT> restrictionCoder;\n+\n+    private UnboundedSourceAsSDFWrapperFn(Coder<CheckpointT> restrictionCoder) {\n+      this.restrictionCoder = restrictionCoder;\n+    }\n+\n+    @GetInitialRestriction\n+    public KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> initialRestriction(\n+        @Element UnboundedSource<OutputT, CheckpointT> element) {\n+      return KV.of(element, null);\n+    }\n+\n+    @GetSize\n+    public double getSize(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01c12c08bc0c4a093533d93d20ecf8f8869e68c7"}, "originalPosition": 122}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3235, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}