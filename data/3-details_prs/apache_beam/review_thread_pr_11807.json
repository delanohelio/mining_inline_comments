{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyNTgwNzIy", "number": 11807, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjozNjo0M1rOEATGPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjo0NTowOFrOEATNzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzQ4MzUxOnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/zetasql/src/test/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLDialectSpecTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjozNjo0M1rOGbfjFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjozNjo0M1rOGbfjFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4MTYyMQ==", "bodyText": "Nit: count_start should be field_count.", "url": "https://github.com/apache/beam/pull/11807#discussion_r431481621", "createdAt": "2020-05-27T22:36:43Z", "author": {"login": "robinyqiu"}, "path": "sdks/java/extensions/sql/zetasql/src/test/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLDialectSpecTest.java", "diffHunk": "@@ -4780,6 +4780,31 @@ public void testTumbleAsTVF() {\n     pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n   }\n \n+  @Test\n+  public void testTVFTumbleAggregation() {\n+    String sql =\n+        \"SELECT COUNT(*) as field_count, \"\n+            + \"window_start \"\n+            + \"FROM TUMBLE((select * from KeyValue), descriptor(ts), 'INTERVAL 1 SECOND') \"\n+            + \"GROUP BY window_start\";\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);\n+\n+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);\n+\n+    final Schema schema =\n+        Schema.builder().addInt64Field(\"count_start\").addDateTimeField(\"window_start\").build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efc76268e696c4a4dccba469b8e4d53e5e1b93a9"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzUwMjg3OnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamTableFunctionScanRel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjo0NTowOFrOGbfuxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjo1MTozOVrOGbf3eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4NDYxMw==", "bodyText": "Why not just return upstream.apply(...)?", "url": "https://github.com/apache/beam/pull/11807#discussion_r431484613", "createdAt": "2020-05-27T22:45:08Z", "author": {"login": "robinyqiu"}, "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamTableFunctionScanRel.java", "diffHunk": "@@ -99,14 +102,32 @@ public TableFunctionScan copy(\n       RexInputRef wmCol = (RexInputRef) call.getOperands().get(1);\n       PCollection<Row> upstream = input.get(0);\n       Schema outputSchema = CalciteUtils.toSchema(getRowType());\n-      return upstream\n-          .apply(\n-              ParDo.of(\n-                  new FixedWindowDoFn(\n-                      FixedWindows.of(durationParameter(call.getOperands().get(2))),\n-                      wmCol.getIndex(),\n-                      outputSchema)))\n-          .setRowSchema(outputSchema);\n+      FixedWindows windowFn = FixedWindows.of(durationParameter(call.getOperands().get(2)));\n+      PCollection<Row> streamWithWindowMetadata =\n+          upstream\n+              .apply(ParDo.of(new FixedWindowDoFn(windowFn, wmCol.getIndex(), outputSchema)))\n+              .setRowSchema(outputSchema);\n+\n+      PCollection<Row> windowedStream =\n+          assignTimestampsAndWindow(\n+              streamWithWindowMetadata, wmCol.getIndex(), (WindowFn) windowFn);\n+\n+      return windowedStream;\n+    }\n+\n+    /** Extract timestamps from the windowFieldIndex, then window into windowFns. */\n+    private PCollection<Row> assignTimestampsAndWindow(\n+        PCollection<Row> upstream, int windowFieldIndex, WindowFn<Row, IntervalWindow> windowFn) {\n+      PCollection<Row> windowedStream;\n+      windowedStream =\n+          upstream", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efc76268e696c4a4dccba469b8e4d53e5e1b93a9"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4Njg0MQ==", "bodyText": "Not a big deal. Just want to use the name windowedStream to improve readability. E.g. readers know it's returning a windowed PCollection.", "url": "https://github.com/apache/beam/pull/11807#discussion_r431486841", "createdAt": "2020-05-27T22:51:39Z", "author": {"login": "amaliujia"}, "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamTableFunctionScanRel.java", "diffHunk": "@@ -99,14 +102,32 @@ public TableFunctionScan copy(\n       RexInputRef wmCol = (RexInputRef) call.getOperands().get(1);\n       PCollection<Row> upstream = input.get(0);\n       Schema outputSchema = CalciteUtils.toSchema(getRowType());\n-      return upstream\n-          .apply(\n-              ParDo.of(\n-                  new FixedWindowDoFn(\n-                      FixedWindows.of(durationParameter(call.getOperands().get(2))),\n-                      wmCol.getIndex(),\n-                      outputSchema)))\n-          .setRowSchema(outputSchema);\n+      FixedWindows windowFn = FixedWindows.of(durationParameter(call.getOperands().get(2)));\n+      PCollection<Row> streamWithWindowMetadata =\n+          upstream\n+              .apply(ParDo.of(new FixedWindowDoFn(windowFn, wmCol.getIndex(), outputSchema)))\n+              .setRowSchema(outputSchema);\n+\n+      PCollection<Row> windowedStream =\n+          assignTimestampsAndWindow(\n+              streamWithWindowMetadata, wmCol.getIndex(), (WindowFn) windowFn);\n+\n+      return windowedStream;\n+    }\n+\n+    /** Extract timestamps from the windowFieldIndex, then window into windowFns. */\n+    private PCollection<Row> assignTimestampsAndWindow(\n+        PCollection<Row> upstream, int windowFieldIndex, WindowFn<Row, IntervalWindow> windowFn) {\n+      PCollection<Row> windowedStream;\n+      windowedStream =\n+          upstream", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4NDYxMw=="}, "originalCommit": {"oid": "efc76268e696c4a4dccba469b8e4d53e5e1b93a9"}, "originalPosition": 42}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3697, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}