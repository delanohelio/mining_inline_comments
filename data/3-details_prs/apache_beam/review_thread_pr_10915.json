{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3OTA1MDUz", "number": 10915, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxODozMjoyMFrODhojow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxOToxMTowOFrODkY3Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NTk0MDgzOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxODozMjoyMFrOFsee7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwNDozMjo0M1rOFw4DMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4MTEwMA==", "bodyText": "nit: remove extra space", "url": "https://github.com/apache/beam/pull/10915#discussion_r382181100", "createdAt": "2020-02-20T18:32:20Z", "author": {"login": "KevinGG"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,113 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "302ce72f9bae5969bff837d209b62ca26a9fe5e2"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4NTEzMQ==", "bodyText": "Yapf puts that space there", "url": "https://github.com/apache/beam/pull/10915#discussion_r382185131", "createdAt": "2020-02-20T18:40:21Z", "author": {"login": "rohdesamuel"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,113 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4MTEwMA=="}, "originalCommit": {"oid": "302ce72f9bae5969bff837d209b62ca26a9fe5e2"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5NDI5MA==", "bodyText": "Sorry, I missed this before merging. I think the extra space was \"in[space][space]Interactive\", not the whitespace that yapf inserted.", "url": "https://github.com/apache/beam/pull/10915#discussion_r386794290", "createdAt": "2020-03-03T04:32:43Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,113 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4MTEwMA=="}, "originalCommit": {"oid": "302ce72f9bae5969bff837d209b62ca26a9fe5e2"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NTk0NjUyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxODozNDowM1rOFseigQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxODo0MDoyOVrOFseu-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4MjAxNw==", "bodyText": "nit: can this just be prefix?", "url": "https://github.com/apache/beam/pull/10915#discussion_r382182017", "createdAt": "2020-02-20T18:34:03Z", "author": {"login": "KevinGG"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,113 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)\n+    if fields:\n+      columns = list(fields)\n+      if depth > 0:\n+        columns = ['[{}]'.format(f) for f in fields]\n+      elements = [el._asdict()[f] for f in fields]\n+    else:\n+      elements = [el]\n+  return columns, elements\n+\n+\n+def parse_row(el, element_type, include_window_info=True, prefix=COLUMN_PREFIX):\n+  # Reify the WindowedValue data to the Dataframe if asked.\n+  windowed = None\n+  if isinstance(el, WindowedValue):\n+    if include_window_info:\n+      windowed = el\n+    el = el.value\n+\n+  # Parse the elements with the given type.\n+  columns, elements = parse_row_(el, element_type, 0)\n+\n+  # If there are no columns returned, there is only a single column of a\n+  # primitive data type.\n+  if not columns:\n+    columns = ['']\n+\n+  # Add the prefix to the columns that have an index.\n+  for i in range(len(columns)):\n+    if columns[i] == '' or columns[i][0] == '[':\n+      columns[i] = prefix + columns[i]\n+\n+  # Reify the windowed columns and do a best-effort casting into Pandas DTypes.\n+  if windowed:\n+    columns += ['event_time', 'windows', 'pane_info']\n+    elements += [\n+        windowed.timestamp.micros, windowed.windows, windowed.pane_info\n+    ]\n+  return columns, elements\n+\n+\n+def pcoll_to_df(\n+    elements, element_type, include_window_info=False, prefix=COLUMN_PREFIX):\n+  \"\"\"Parses the given elements into a Dataframe.\n+\n+  Each column name will be prefixed with `prefix` concatenated with the nested\n+  index, e.g. for a Tuple[Tuple[int, str], int], the column names will be:\n+  [prefix[0][0], prefix[0][1], prefix[0]]. This is subject to change.\n+  \"\"\"\n+  rows = []\n+  columns = []\n+\n+  for e in elements:\n+    columns, row = parse_row(e, element_type, include_window_info,\n+                             prefix=prefix)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "302ce72f9bae5969bff837d209b62ca26a9fe5e2"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4NTIwOA==", "bodyText": "Done", "url": "https://github.com/apache/beam/pull/10915#discussion_r382185208", "createdAt": "2020-02-20T18:40:29Z", "author": {"login": "rohdesamuel"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,113 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)\n+    if fields:\n+      columns = list(fields)\n+      if depth > 0:\n+        columns = ['[{}]'.format(f) for f in fields]\n+      elements = [el._asdict()[f] for f in fields]\n+    else:\n+      elements = [el]\n+  return columns, elements\n+\n+\n+def parse_row(el, element_type, include_window_info=True, prefix=COLUMN_PREFIX):\n+  # Reify the WindowedValue data to the Dataframe if asked.\n+  windowed = None\n+  if isinstance(el, WindowedValue):\n+    if include_window_info:\n+      windowed = el\n+    el = el.value\n+\n+  # Parse the elements with the given type.\n+  columns, elements = parse_row_(el, element_type, 0)\n+\n+  # If there are no columns returned, there is only a single column of a\n+  # primitive data type.\n+  if not columns:\n+    columns = ['']\n+\n+  # Add the prefix to the columns that have an index.\n+  for i in range(len(columns)):\n+    if columns[i] == '' or columns[i][0] == '[':\n+      columns[i] = prefix + columns[i]\n+\n+  # Reify the windowed columns and do a best-effort casting into Pandas DTypes.\n+  if windowed:\n+    columns += ['event_time', 'windows', 'pane_info']\n+    elements += [\n+        windowed.timestamp.micros, windowed.windows, windowed.pane_info\n+    ]\n+  return columns, elements\n+\n+\n+def pcoll_to_df(\n+    elements, element_type, include_window_info=False, prefix=COLUMN_PREFIX):\n+  \"\"\"Parses the given elements into a Dataframe.\n+\n+  Each column name will be prefixed with `prefix` concatenated with the nested\n+  index, e.g. for a Tuple[Tuple[int, str], int], the column names will be:\n+  [prefix[0][0], prefix[0][1], prefix[0]]. This is subject to change.\n+  \"\"\"\n+  rows = []\n+  columns = []\n+\n+  for e in elements:\n+    columns, row = parse_row(e, element_type, include_window_info,\n+                             prefix=prefix)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4MjAxNw=="}, "originalCommit": {"oid": "302ce72f9bae5969bff837d209b62ca26a9fe5e2"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NTk1MDY4OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/interactive/utils_test.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxODozNToyNVrOFselLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxODo0MDozNFrOFsevLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4MjcwMA==", "bodyText": "Can the tests be assigned meaningful names? Also test_parse_5 occurred twice.", "url": "https://github.com/apache/beam/pull/10915#discussion_r382182700", "createdAt": "2020-02-20T18:35:25Z", "author": {"login": "KevinGG"}, "path": "sdks/python/apache_beam/runners/interactive/utils_test.py", "diffHunk": "@@ -0,0 +1,138 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from __future__ import absolute_import\n+\n+import unittest\n+\n+import pandas as pd\n+\n+from apache_beam.runners.interactive import utils\n+from apache_beam.typehints.typehints import Any\n+from apache_beam.typehints.typehints import Dict\n+from apache_beam.typehints.typehints import List\n+from apache_beam.typehints.typehints import Tuple\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+\n+class ParseToDataframeTest(unittest.TestCase):\n+  def test_parse_1(self):\n+    el = (1, 'a')\n+    element_type = Tuple[int, str]\n+\n+    columns, elements = utils.parse_row(el, element_type)\n+    self.assertEqual(columns, ['el[0]', 'el[1]'])\n+    self.assertEqual(elements, [1, 'a'])\n+\n+  def test_parse_2(self):\n+    el = ((1, 2.0, 'a'), 'b')\n+    element_type = Tuple[Tuple[int, float, str], str]\n+\n+    columns, elements = utils.parse_row(el, element_type)\n+    self.assertEqual(columns, ['el[0][0]', 'el[0][1]', 'el[0][2]', 'el[1]'])\n+    self.assertEqual(elements, [1, 2.0, 'a', 'b'])\n+\n+  def test_parse_3(self):\n+    el = [1, 2, 3]\n+    element_type = List[int]\n+\n+    columns, elements = utils.parse_row(el, element_type)\n+    self.assertEqual(columns, ['el'])\n+    self.assertEqual(elements, [[1, 2, 3]])\n+\n+  def test_parse_4(self):\n+    el = ('k', [1, 2, 3])\n+    element_type = Tuple[str, List[int]]\n+\n+    columns, elements = utils.parse_row(el, element_type)\n+    self.assertEqual(columns, ['el[0]', 'el[1]'])\n+    self.assertEqual(elements, ['k', [1, 2, 3]])\n+\n+  def test_parse_5(self):\n+    el = (([1, 2, 3], {'b': 1, 'c': 2}), 'a')\n+    element_type = Tuple[Tuple[List[int], Dict[str, int]], str]\n+\n+    columns, elements = utils.parse_row(el, element_type)\n+    self.assertEqual(columns, ['el[0][0]', 'el[0][1]', 'el[1]'])\n+    self.assertEqual(elements, [[1, 2, 3], {'b': 1, 'c': 2}, 'a'])\n+\n+  def test_parse_5(self):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "302ce72f9bae5969bff837d209b62ca26a9fe5e2"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4NTI2Mw==", "bodyText": "Done", "url": "https://github.com/apache/beam/pull/10915#discussion_r382185263", "createdAt": "2020-02-20T18:40:34Z", "author": {"login": "rohdesamuel"}, "path": "sdks/python/apache_beam/runners/interactive/utils_test.py", "diffHunk": "@@ -0,0 +1,138 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from __future__ import absolute_import\n+\n+import unittest\n+\n+import pandas as pd\n+\n+from apache_beam.runners.interactive import utils\n+from apache_beam.typehints.typehints import Any\n+from apache_beam.typehints.typehints import Dict\n+from apache_beam.typehints.typehints import List\n+from apache_beam.typehints.typehints import Tuple\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+\n+class ParseToDataframeTest(unittest.TestCase):\n+  def test_parse_1(self):\n+    el = (1, 'a')\n+    element_type = Tuple[int, str]\n+\n+    columns, elements = utils.parse_row(el, element_type)\n+    self.assertEqual(columns, ['el[0]', 'el[1]'])\n+    self.assertEqual(elements, [1, 'a'])\n+\n+  def test_parse_2(self):\n+    el = ((1, 2.0, 'a'), 'b')\n+    element_type = Tuple[Tuple[int, float, str], str]\n+\n+    columns, elements = utils.parse_row(el, element_type)\n+    self.assertEqual(columns, ['el[0][0]', 'el[0][1]', 'el[0][2]', 'el[1]'])\n+    self.assertEqual(elements, [1, 2.0, 'a', 'b'])\n+\n+  def test_parse_3(self):\n+    el = [1, 2, 3]\n+    element_type = List[int]\n+\n+    columns, elements = utils.parse_row(el, element_type)\n+    self.assertEqual(columns, ['el'])\n+    self.assertEqual(elements, [[1, 2, 3]])\n+\n+  def test_parse_4(self):\n+    el = ('k', [1, 2, 3])\n+    element_type = Tuple[str, List[int]]\n+\n+    columns, elements = utils.parse_row(el, element_type)\n+    self.assertEqual(columns, ['el[0]', 'el[1]'])\n+    self.assertEqual(elements, ['k', [1, 2, 3]])\n+\n+  def test_parse_5(self):\n+    el = (([1, 2, 3], {'b': 1, 'c': 2}), 'a')\n+    element_type = Tuple[Tuple[List[int], Dict[str, int]], str]\n+\n+    columns, elements = utils.parse_row(el, element_type)\n+    self.assertEqual(columns, ['el[0][0]', 'el[0][1]', 'el[1]'])\n+    self.assertEqual(elements, [[1, 2, 3], {'b': 1, 'c': 2}, 'a'])\n+\n+  def test_parse_5(self):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4MjcwMA=="}, "originalCommit": {"oid": "302ce72f9bae5969bff837d209b62ca26a9fe5e2"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODQ2MjUzOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOTo0NToxNlrOFuSxCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMzoxMjowNVrOFvD8Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4NjI4MA==", "bodyText": "The convention in Python is to put the underscore before for a private method. Also, I'd call this \"_parse_row_internal\" or similar to make it easier to read. And at least a one-line docstring explaining what the intent of this function is.", "url": "https://github.com/apache/beam/pull/10915#discussion_r384086280", "createdAt": "2020-02-25T19:45:16Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "083723a5b17fc3b24225d92d2b3e6cb9a9122606"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MTkxOA==", "bodyText": "Ack, I changed the name to just parse_row (because I use it in tests).", "url": "https://github.com/apache/beam/pull/10915#discussion_r384891918", "createdAt": "2020-02-27T03:12:05Z", "author": {"login": "rohdesamuel"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4NjI4MA=="}, "originalCommit": {"oid": "083723a5b17fc3b24225d92d2b3e6cb9a9122606"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODQ4MDUzOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOTo1MDozNFrOFuS8Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMzoxMjoxMVrOFvD8NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4OTExOQ==", "bodyText": "We typically use e or elt for abbreviating element. el evokes either the letter L (making it hard to read aloud/talk about) or the hebrew Deity. This goes for the variable names below as well.", "url": "https://github.com/apache/beam/pull/10915#discussion_r384089119", "createdAt": "2020-02-25T19:50:34Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "083723a5b17fc3b24225d92d2b3e6cb9a9122606"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MTk1Ng==", "bodyText": "Ack, changed to elt", "url": "https://github.com/apache/beam/pull/10915#discussion_r384891956", "createdAt": "2020-02-27T03:12:11Z", "author": {"login": "rohdesamuel"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4OTExOQ=="}, "originalCommit": {"oid": "083723a5b17fc3b24225d92d2b3e6cb9a9122606"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODQ5MTM5OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOTo1MzozN1rOFuTDCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMzoxOTowN1rOFvECZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5MDg4OA==", "bodyText": "https://engdoc.corp.google.com/eng/doc/devguide/py/totw/026.md?cl=head", "url": "https://github.com/apache/beam/pull/10915#discussion_r384090888", "createdAt": "2020-02-25T19:53:37Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)\n+    if fields:\n+      columns = list(fields)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "083723a5b17fc3b24225d92d2b3e6cb9a9122606"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MzU0Mw==", "bodyText": "I still need to take a look in my code to see if anything violates this, I'll let you know.", "url": "https://github.com/apache/beam/pull/10915#discussion_r384893543", "createdAt": "2020-02-27T03:19:07Z", "author": {"login": "rohdesamuel"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)\n+    if fields:\n+      columns = list(fields)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5MDg4OA=="}, "originalCommit": {"oid": "083723a5b17fc3b24225d92d2b3e6cb9a9122606"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODUwNzUzOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOTo1ODoyNFrOFuTNIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMzoxMjo1NVrOFvD8xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5MzQ3Mw==", "bodyText": "Doing an isinstance check would be preferable to checking a private variable.", "url": "https://github.com/apache/beam/pull/10915#discussion_r384093473", "createdAt": "2020-02-25T19:58:24Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "083723a5b17fc3b24225d92d2b3e6cb9a9122606"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MjEwMg==", "bodyText": "Unfortunately this is the way to check if it is a named tuple.", "url": "https://github.com/apache/beam/pull/10915#discussion_r384892102", "createdAt": "2020-02-27T03:12:55Z", "author": {"login": "rohdesamuel"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5MzQ3Mw=="}, "originalCommit": {"oid": "083723a5b17fc3b24225d92d2b3e6cb9a9122606"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODUwODczOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOTo1ODo0N1rOFuTN5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMzoxMzo0MFrOFvD9gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5MzY2OA==", "bodyText": "getattr(el, f) would be more natural. Or just list(elt) as the fields should be in the proper order.", "url": "https://github.com/apache/beam/pull/10915#discussion_r384093668", "createdAt": "2020-02-25T19:58:47Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)\n+    if fields:\n+      columns = list(fields)\n+      if depth > 0:\n+        columns = ['[{}]'.format(f) for f in fields]\n+      elements = [el._asdict()[f] for f in fields]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "083723a5b17fc3b24225d92d2b3e6cb9a9122606"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MjI4OQ==", "bodyText": "This code was removed in a recent commit, but ack on getattr being more natural", "url": "https://github.com/apache/beam/pull/10915#discussion_r384892289", "createdAt": "2020-02-27T03:13:40Z", "author": {"login": "rohdesamuel"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)\n+    if fields:\n+      columns = list(fields)\n+      if depth > 0:\n+        columns = ['[{}]'.format(f) for f in fields]\n+      elements = [el._asdict()[f] for f in fields]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5MzY2OA=="}, "originalCommit": {"oid": "083723a5b17fc3b24225d92d2b3e6cb9a9122606"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODUyNDAwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMDowMzo0MVrOFuTXXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMzoxMzo1M1rOFvD9tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NjA5Mg==", "bodyText": "I would suggest having a format column.field.0.1. I think this could simplify your code quite a bit (e.g. you could only have one parse_row that recursively calls itself with an increasingly longer prefix). (As a bonus, easier on the eyes.)", "url": "https://github.com/apache/beam/pull/10915#discussion_r384096092", "createdAt": "2020-02-25T20:03:41Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)\n+    if fields:\n+      columns = list(fields)\n+      if depth > 0:\n+        columns = ['[{}]'.format(f) for f in fields]\n+      elements = [el._asdict()[f] for f in fields]\n+    else:\n+      elements = [el]\n+  return columns, elements\n+\n+\n+def parse_row(el, element_type, include_window_info=True, prefix=COLUMN_PREFIX):\n+  # Reify the WindowedValue data to the Dataframe if asked.\n+  windowed = None\n+  if isinstance(el, WindowedValue):\n+    if include_window_info:\n+      windowed = el\n+    el = el.value\n+\n+  # Parse the elements with the given type.\n+  columns, elements = parse_row_(el, element_type, 0)\n+\n+  # If there are no columns returned, there is only a single column of a\n+  # primitive data type.\n+  if not columns:\n+    columns = ['']\n+\n+  # Add the prefix to the columns that have an index.\n+  for i in range(len(columns)):\n+    if columns[i] == '' or columns[i][0] == '[':\n+      columns[i] = prefix + columns[i]\n+\n+  # Reify the windowed columns and do a best-effort casting into Pandas DTypes.\n+  if windowed:\n+    columns += ['event_time', 'windows', 'pane_info']\n+    elements += [\n+        windowed.timestamp.micros, windowed.windows, windowed.pane_info\n+    ]\n+  return columns, elements\n+\n+\n+def pcoll_to_df(\n+    elements, element_type, include_window_info=False, prefix=COLUMN_PREFIX):\n+  \"\"\"Parses the given elements into a Dataframe.\n+\n+  Each column name will be prefixed with `prefix` concatenated with the nested\n+  index, e.g. for a Tuple[Tuple[int, str], int], the column names will be:\n+  [prefix[0][0], prefix[0][1], prefix[0]]. This is subject to change.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "083723a5b17fc3b24225d92d2b3e6cb9a9122606"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MjM0Mg==", "bodyText": "ack, changed to dots (much simpler)", "url": "https://github.com/apache/beam/pull/10915#discussion_r384892342", "createdAt": "2020-02-27T03:13:53Z", "author": {"login": "rohdesamuel"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)\n+    if fields:\n+      columns = list(fields)\n+      if depth > 0:\n+        columns = ['[{}]'.format(f) for f in fields]\n+      elements = [el._asdict()[f] for f in fields]\n+    else:\n+      elements = [el]\n+  return columns, elements\n+\n+\n+def parse_row(el, element_type, include_window_info=True, prefix=COLUMN_PREFIX):\n+  # Reify the WindowedValue data to the Dataframe if asked.\n+  windowed = None\n+  if isinstance(el, WindowedValue):\n+    if include_window_info:\n+      windowed = el\n+    el = el.value\n+\n+  # Parse the elements with the given type.\n+  columns, elements = parse_row_(el, element_type, 0)\n+\n+  # If there are no columns returned, there is only a single column of a\n+  # primitive data type.\n+  if not columns:\n+    columns = ['']\n+\n+  # Add the prefix to the columns that have an index.\n+  for i in range(len(columns)):\n+    if columns[i] == '' or columns[i][0] == '[':\n+      columns[i] = prefix + columns[i]\n+\n+  # Reify the windowed columns and do a best-effort casting into Pandas DTypes.\n+  if windowed:\n+    columns += ['event_time', 'windows', 'pane_info']\n+    elements += [\n+        windowed.timestamp.micros, windowed.windows, windowed.pane_info\n+    ]\n+  return columns, elements\n+\n+\n+def pcoll_to_df(\n+    elements, element_type, include_window_info=False, prefix=COLUMN_PREFIX):\n+  \"\"\"Parses the given elements into a Dataframe.\n+\n+  Each column name will be prefixed with `prefix` concatenated with the nested\n+  index, e.g. for a Tuple[Tuple[int, str], int], the column names will be:\n+  [prefix[0][0], prefix[0][1], prefix[0]]. This is subject to change.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NjA5Mg=="}, "originalCommit": {"oid": "083723a5b17fc3b24225d92d2b3e6cb9a9122606"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODUzMzQwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMDowNjo0NVrOFuTdAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMzoxNDowM1rOFvD92Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NzUzNg==", "bodyText": "When can columns[i] be the empty string? Also, when would it not be []. There seems to be an off-by-one to have to handle the base case in both the caller and the callee.", "url": "https://github.com/apache/beam/pull/10915#discussion_r384097536", "createdAt": "2020-02-25T20:06:45Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)\n+    if fields:\n+      columns = list(fields)\n+      if depth > 0:\n+        columns = ['[{}]'.format(f) for f in fields]\n+      elements = [el._asdict()[f] for f in fields]\n+    else:\n+      elements = [el]\n+  return columns, elements\n+\n+\n+def parse_row(el, element_type, include_window_info=True, prefix=COLUMN_PREFIX):\n+  # Reify the WindowedValue data to the Dataframe if asked.\n+  windowed = None\n+  if isinstance(el, WindowedValue):\n+    if include_window_info:\n+      windowed = el\n+    el = el.value\n+\n+  # Parse the elements with the given type.\n+  columns, elements = parse_row_(el, element_type, 0)\n+\n+  # If there are no columns returned, there is only a single column of a\n+  # primitive data type.\n+  if not columns:\n+    columns = ['']\n+\n+  # Add the prefix to the columns that have an index.\n+  for i in range(len(columns)):\n+    if columns[i] == '' or columns[i][0] == '[':", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "083723a5b17fc3b24225d92d2b3e6cb9a9122606"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MjM3Nw==", "bodyText": "This code was removed in a recent commit.", "url": "https://github.com/apache/beam/pull/10915#discussion_r384892377", "createdAt": "2020-02-27T03:14:03Z", "author": {"login": "rohdesamuel"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)\n+    if fields:\n+      columns = list(fields)\n+      if depth > 0:\n+        columns = ['[{}]'.format(f) for f in fields]\n+      elements = [el._asdict()[f] for f in fields]\n+    else:\n+      elements = [el]\n+  return columns, elements\n+\n+\n+def parse_row(el, element_type, include_window_info=True, prefix=COLUMN_PREFIX):\n+  # Reify the WindowedValue data to the Dataframe if asked.\n+  windowed = None\n+  if isinstance(el, WindowedValue):\n+    if include_window_info:\n+      windowed = el\n+    el = el.value\n+\n+  # Parse the elements with the given type.\n+  columns, elements = parse_row_(el, element_type, 0)\n+\n+  # If there are no columns returned, there is only a single column of a\n+  # primitive data type.\n+  if not columns:\n+    columns = ['']\n+\n+  # Add the prefix to the columns that have an index.\n+  for i in range(len(columns)):\n+    if columns[i] == '' or columns[i][0] == '[':", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NzUzNg=="}, "originalCommit": {"oid": "083723a5b17fc3b24225d92d2b3e6cb9a9122606"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODUzNjIwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMDowNzozOVrOFuTeqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMzoxNDoxN1rOFvD-FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5Nzk2MA==", "bodyText": "Would it be better to infer the schema once, then apply all rows, rather than re-parse it for every element? (Also, that way you could correctly detect/handle if the schema is not consistent, e.g. tuples of varying length.)", "url": "https://github.com/apache/beam/pull/10915#discussion_r384097960", "createdAt": "2020-02-25T20:07:39Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)\n+    if fields:\n+      columns = list(fields)\n+      if depth > 0:\n+        columns = ['[{}]'.format(f) for f in fields]\n+      elements = [el._asdict()[f] for f in fields]\n+    else:\n+      elements = [el]\n+  return columns, elements\n+\n+\n+def parse_row(el, element_type, include_window_info=True, prefix=COLUMN_PREFIX):\n+  # Reify the WindowedValue data to the Dataframe if asked.\n+  windowed = None\n+  if isinstance(el, WindowedValue):\n+    if include_window_info:\n+      windowed = el\n+    el = el.value\n+\n+  # Parse the elements with the given type.\n+  columns, elements = parse_row_(el, element_type, 0)\n+\n+  # If there are no columns returned, there is only a single column of a\n+  # primitive data type.\n+  if not columns:\n+    columns = ['']\n+\n+  # Add the prefix to the columns that have an index.\n+  for i in range(len(columns)):\n+    if columns[i] == '' or columns[i][0] == '[':\n+      columns[i] = prefix + columns[i]\n+\n+  # Reify the windowed columns and do a best-effort casting into Pandas DTypes.\n+  if windowed:\n+    columns += ['event_time', 'windows', 'pane_info']\n+    elements += [\n+        windowed.timestamp.micros, windowed.windows, windowed.pane_info\n+    ]\n+  return columns, elements\n+\n+\n+def pcoll_to_df(\n+    elements, element_type, include_window_info=False, prefix=COLUMN_PREFIX):\n+  \"\"\"Parses the given elements into a Dataframe.\n+\n+  Each column name will be prefixed with `prefix` concatenated with the nested\n+  index, e.g. for a Tuple[Tuple[int, str], int], the column names will be:\n+  [prefix[0][0], prefix[0][1], prefix[0]]. This is subject to change.\n+  \"\"\"\n+  rows = []\n+  columns = []\n+\n+  for e in elements:\n+    columns, row = parse_row(e, element_type, include_window_info, prefix)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "083723a5b17fc3b24225d92d2b3e6cb9a9122606"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MjQzNg==", "bodyText": "Changed to inferring the schema once.", "url": "https://github.com/apache/beam/pull/10915#discussion_r384892436", "createdAt": "2020-02-27T03:14:17Z", "author": {"login": "rohdesamuel"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)\n+    if fields:\n+      columns = list(fields)\n+      if depth > 0:\n+        columns = ['[{}]'.format(f) for f in fields]\n+      elements = [el._asdict()[f] for f in fields]\n+    else:\n+      elements = [el]\n+  return columns, elements\n+\n+\n+def parse_row(el, element_type, include_window_info=True, prefix=COLUMN_PREFIX):\n+  # Reify the WindowedValue data to the Dataframe if asked.\n+  windowed = None\n+  if isinstance(el, WindowedValue):\n+    if include_window_info:\n+      windowed = el\n+    el = el.value\n+\n+  # Parse the elements with the given type.\n+  columns, elements = parse_row_(el, element_type, 0)\n+\n+  # If there are no columns returned, there is only a single column of a\n+  # primitive data type.\n+  if not columns:\n+    columns = ['']\n+\n+  # Add the prefix to the columns that have an index.\n+  for i in range(len(columns)):\n+    if columns[i] == '' or columns[i][0] == '[':\n+      columns[i] = prefix + columns[i]\n+\n+  # Reify the windowed columns and do a best-effort casting into Pandas DTypes.\n+  if windowed:\n+    columns += ['event_time', 'windows', 'pane_info']\n+    elements += [\n+        windowed.timestamp.micros, windowed.windows, windowed.pane_info\n+    ]\n+  return columns, elements\n+\n+\n+def pcoll_to_df(\n+    elements, element_type, include_window_info=False, prefix=COLUMN_PREFIX):\n+  \"\"\"Parses the given elements into a Dataframe.\n+\n+  Each column name will be prefixed with `prefix` concatenated with the nested\n+  index, e.g. for a Tuple[Tuple[int, str], int], the column names will be:\n+  [prefix[0][0], prefix[0][1], prefix[0]]. This is subject to change.\n+  \"\"\"\n+  rows = []\n+  columns = []\n+\n+  for e in elements:\n+    columns, row = parse_row(e, element_type, include_window_info, prefix)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5Nzk2MA=="}, "originalCommit": {"oid": "083723a5b17fc3b24225d92d2b3e6cb9a9122606"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDgyMzgyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxOToxMDoyMFrOFwrsSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMDo1OTo0M1rOFwvCog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5MTgxOA==", "bodyText": "Remove this case.", "url": "https://github.com/apache/beam/pull/10915#discussion_r386591818", "createdAt": "2020-03-02T19:10:20Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,55 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+\n+def elements_to_df(elements, include_window_info=False):\n+  \"\"\"Parses the given elements into a Dataframe.\n+\n+  If the elements are a list of `WindowedValue`s, then it will break out the\n+  elements into their own DataFrame and return it. If include_window_info is\n+  True, then it will concatenate the windowing information onto the elements\n+  DataFrame.\n+  \"\"\"\n+\n+  rows = []\n+  windowed_values = []\n+  for e in elements:\n+    if isinstance(e, WindowedValue):\n+      rows.append(e.value)\n+    else:\n+      rows.append(e)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d1803d9349c23e9ec15c86b74c7600e7256851"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY0NjY5MA==", "bodyText": "Done", "url": "https://github.com/apache/beam/pull/10915#discussion_r386646690", "createdAt": "2020-03-02T20:59:43Z", "author": {"login": "rohdesamuel"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,55 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+\n+def elements_to_df(elements, include_window_info=False):\n+  \"\"\"Parses the given elements into a Dataframe.\n+\n+  If the elements are a list of `WindowedValue`s, then it will break out the\n+  elements into their own DataFrame and return it. If include_window_info is\n+  True, then it will concatenate the windowing information onto the elements\n+  DataFrame.\n+  \"\"\"\n+\n+  rows = []\n+  windowed_values = []\n+  for e in elements:\n+    if isinstance(e, WindowedValue):\n+      rows.append(e.value)\n+    else:\n+      rows.append(e)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5MTgxOA=="}, "originalCommit": {"oid": "10d1803d9349c23e9ec15c86b74c7600e7256851"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDgyNDg2OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxOToxMDo0M1rOFwrtBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMDo1OTo1M1rOFwvC5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5MjAwNQ==", "bodyText": "windowing_info? (windowed_values sounds like it has the values themselves).", "url": "https://github.com/apache/beam/pull/10915#discussion_r386592005", "createdAt": "2020-03-02T19:10:43Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,55 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+\n+def elements_to_df(elements, include_window_info=False):\n+  \"\"\"Parses the given elements into a Dataframe.\n+\n+  If the elements are a list of `WindowedValue`s, then it will break out the\n+  elements into their own DataFrame and return it. If include_window_info is\n+  True, then it will concatenate the windowing information onto the elements\n+  DataFrame.\n+  \"\"\"\n+\n+  rows = []\n+  windowed_values = []", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d1803d9349c23e9ec15c86b74c7600e7256851"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY0Njc1Nw==", "bodyText": "Changed to \"windowing_info\"", "url": "https://github.com/apache/beam/pull/10915#discussion_r386646757", "createdAt": "2020-03-02T20:59:53Z", "author": {"login": "rohdesamuel"}, "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,55 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+\n+def elements_to_df(elements, include_window_info=False):\n+  \"\"\"Parses the given elements into a Dataframe.\n+\n+  If the elements are a list of `WindowedValue`s, then it will break out the\n+  elements into their own DataFrame and return it. If include_window_info is\n+  True, then it will concatenate the windowing information onto the elements\n+  DataFrame.\n+  \"\"\"\n+\n+  rows = []\n+  windowed_values = []", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5MjAwNQ=="}, "originalCommit": {"oid": "10d1803d9349c23e9ec15c86b74c7600e7256851"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDgyNjQ3OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/interactive/utils_test.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxOToxMTowOFrOFwruCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMTowMDoxMlrOFwvDag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5MjI2NA==", "bodyText": "Remove tests that don't test our code.", "url": "https://github.com/apache/beam/pull/10915#discussion_r386592264", "createdAt": "2020-03-02T19:11:08Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/interactive/utils_test.py", "diffHunk": "@@ -0,0 +1,182 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from __future__ import absolute_import\n+\n+import unittest\n+\n+import numpy as np\n+import pandas as pd\n+\n+from apache_beam.runners.interactive import utils\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+\n+class ParseToDataframeTest(unittest.TestCase):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d1803d9349c23e9ec15c86b74c7600e7256851"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY0Njg5MA==", "bodyText": "Ack, kept tests that test the WindowValue cases.", "url": "https://github.com/apache/beam/pull/10915#discussion_r386646890", "createdAt": "2020-03-02T21:00:12Z", "author": {"login": "rohdesamuel"}, "path": "sdks/python/apache_beam/runners/interactive/utils_test.py", "diffHunk": "@@ -0,0 +1,182 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from __future__ import absolute_import\n+\n+import unittest\n+\n+import numpy as np\n+import pandas as pd\n+\n+from apache_beam.runners.interactive import utils\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+\n+class ParseToDataframeTest(unittest.TestCase):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5MjI2NA=="}, "originalCommit": {"oid": "10d1803d9349c23e9ec15c86b74c7600e7256851"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1856, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}