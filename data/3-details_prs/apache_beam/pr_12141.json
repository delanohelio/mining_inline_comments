{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyMzI3MDkx", "number": 12141, "title": "[BEAM-9615] Add Row coder functions.", "bodyText": "Adds row encoder and decoder function generators, using reflection. Doesn't provide single element convenience functions for encoding and decoding struct values.\nDoesn't support looking up Logical types, or handling Map types at present, but this is sufficient to pass standard_coders.yaml for now.\nSubsequent PRs will hook this into framework use.\nRemaining work includes:\n\nAdding reference kinds for this coder in the rest of the coder package.\nHooking those into graphx/coder.go\nConverting Go types to Schemas and vice versa.\nValidation and restrictions on such types (eg unexported fields).\nHooking this into the exec package.\nSubmitting the standard_coders.yaml validation for the Go SDK.\nSwapping this to default over JSON encoding.\n\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nDataflow\nFlink\nSamza\nSpark\nTwister2\n\n\n\n\nGo\n\n---\n\n---\n\n---\n\n\nJava\n\n\n\n\n\n\n\n\nPython\n\n\n\n---\n\n---\n\n\nXLang\n---\n---\n\n---\n---\n\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-06-30T22:21:01Z", "url": "https://github.com/apache/beam/pull/12141", "merged": true, "mergeCommit": {"oid": "3f70c0aa2354d7e548565c40d3dc885de1e08137"}, "closed": true, "closedAt": "2020-07-06T20:54:10Z", "author": {"login": "lostluck"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcwdMs3AH2gAyNDQyMzI3MDkxOjk4ODJhZDY2NTgxMTg0MDNmNjA4OTkwOThiMWQ1MTljMTVmNWJkYWI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcwxTlNgFqTQ0MTIxNDg3MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9882ad6658118403f60899098b1d519c15f5bdab", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/9882ad6658118403f60899098b1d519c15f5bdab", "committedDate": "2020-06-30T22:15:34Z", "message": "[BEAM-9615] Add Row coder functions."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "033b1bf4df9dbec27d53d581aa07c186729995ab", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/033b1bf4df9dbec27d53d581aa07c186729995ab", "committedDate": "2020-06-30T22:29:02Z", "message": "!fixup go version restrictions on shift."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNDc0NzA3", "url": "https://github.com/apache/beam/pull/12141#pullrequestreview-440474707", "createdAt": "2020-07-01T00:39:36Z", "commit": {"oid": "033b1bf4df9dbec27d53d581aa07c186729995ab"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDozOTozNlrOGrTCTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMTo1MDozMlrOGrUHIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzgzOQ==", "bodyText": "Should this say \"error decoding bool field\"?", "url": "https://github.com/apache/beam/pull/12141#discussion_r448053839", "createdAt": "2020-07-01T00:39:36Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/graph/coder/row.go", "diffHunk": "@@ -0,0 +1,379 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package coder\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"reflect\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/ioutilx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+)\n+\n+type typeDecoderReflect struct {\n+\ttyp    reflect.Type\n+\tfields []func(reflect.Value, io.Reader) error\n+}\n+\n+// RowEncoderForStruct returns an encoding function that encodes a struct type\n+// or a pointer to a struct type using the beam row encoding.\n+//\n+// Returns an error if the given type is invalid or not encodable to a beam\n+// schema row.\n+func RowEncoderForStruct(rt reflect.Type) (func(interface{}, io.Writer) error, error) {\n+\tif err := rowTypeValidation(rt, true); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn encoderForType(rt), nil\n+}\n+\n+// RowDecoderForStruct returns a decoding function that decodes the beam row encoding\n+// into the given type.\n+//\n+// Returns an error if the given type is invalid or not decodable from a beam\n+// schema row.\n+func RowDecoderForStruct(rt reflect.Type) (func(io.Reader) (interface{}, error), error) {\n+\tif err := rowTypeValidation(rt, true); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn decoderForType(rt), nil\n+}\n+\n+func rowTypeValidation(rt reflect.Type, strictExportedFields bool) error {\n+\tswitch k := rt.Kind(); k {\n+\tcase reflect.Ptr, reflect.Struct:\n+\tdefault:\n+\t\treturn errors.Errorf(\"can't generate row coder for type %v: must be a struct type or pointer to a struct type\", rt)\n+\t}\n+\t// TODO exported field validation.\n+\treturn nil\n+}\n+\n+// decoderForType returns a decoder function for the struct or pointer to struct type.\n+func decoderForType(t reflect.Type) func(io.Reader) (interface{}, error) {\n+\tvar isPtr bool\n+\t// Pointers become the value type for decomposition.\n+\tif t.Kind() == reflect.Ptr {\n+\t\tisPtr = true\n+\t\tt = t.Elem()\n+\t}\n+\tdec := decoderForStructReflect(t)\n+\n+\tif isPtr {\n+\t\treturn func(r io.Reader) (interface{}, error) {\n+\t\t\trv := reflect.New(t)\n+\t\t\terr := dec(rv.Elem(), r)\n+\t\t\treturn rv.Interface(), err\n+\t\t}\n+\t}\n+\treturn func(r io.Reader) (interface{}, error) {\n+\t\trv := reflect.New(t)\n+\t\terr := dec(rv.Elem(), r)\n+\t\treturn rv.Elem().Interface(), err\n+\t}\n+}\n+\n+// decoderForSingleTypeReflect returns a reflection based decoder function for the\n+// given type.\n+func decoderForSingleTypeReflect(t reflect.Type) func(reflect.Value, io.Reader) error {\n+\tswitch t.Kind() {\n+\tcase reflect.Struct:\n+\t\treturn decoderForStructReflect(t)\n+\tcase reflect.Bool:\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\tv, err := DecodeBool(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn errors.Wrap(err, \"error decoding varint field\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "033b1bf4df9dbec27d53d581aa07c186729995ab"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NjA0Ng==", "bodyText": "Is this line supposed to ignore the error?", "url": "https://github.com/apache/beam/pull/12141#discussion_r448056046", "createdAt": "2020-07-01T00:48:05Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/graph/coder/row.go", "diffHunk": "@@ -0,0 +1,379 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package coder\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"reflect\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/ioutilx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+)\n+\n+type typeDecoderReflect struct {\n+\ttyp    reflect.Type\n+\tfields []func(reflect.Value, io.Reader) error\n+}\n+\n+// RowEncoderForStruct returns an encoding function that encodes a struct type\n+// or a pointer to a struct type using the beam row encoding.\n+//\n+// Returns an error if the given type is invalid or not encodable to a beam\n+// schema row.\n+func RowEncoderForStruct(rt reflect.Type) (func(interface{}, io.Writer) error, error) {\n+\tif err := rowTypeValidation(rt, true); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn encoderForType(rt), nil\n+}\n+\n+// RowDecoderForStruct returns a decoding function that decodes the beam row encoding\n+// into the given type.\n+//\n+// Returns an error if the given type is invalid or not decodable from a beam\n+// schema row.\n+func RowDecoderForStruct(rt reflect.Type) (func(io.Reader) (interface{}, error), error) {\n+\tif err := rowTypeValidation(rt, true); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn decoderForType(rt), nil\n+}\n+\n+func rowTypeValidation(rt reflect.Type, strictExportedFields bool) error {\n+\tswitch k := rt.Kind(); k {\n+\tcase reflect.Ptr, reflect.Struct:\n+\tdefault:\n+\t\treturn errors.Errorf(\"can't generate row coder for type %v: must be a struct type or pointer to a struct type\", rt)\n+\t}\n+\t// TODO exported field validation.\n+\treturn nil\n+}\n+\n+// decoderForType returns a decoder function for the struct or pointer to struct type.\n+func decoderForType(t reflect.Type) func(io.Reader) (interface{}, error) {\n+\tvar isPtr bool\n+\t// Pointers become the value type for decomposition.\n+\tif t.Kind() == reflect.Ptr {\n+\t\tisPtr = true\n+\t\tt = t.Elem()\n+\t}\n+\tdec := decoderForStructReflect(t)\n+\n+\tif isPtr {\n+\t\treturn func(r io.Reader) (interface{}, error) {\n+\t\t\trv := reflect.New(t)\n+\t\t\terr := dec(rv.Elem(), r)\n+\t\t\treturn rv.Interface(), err\n+\t\t}\n+\t}\n+\treturn func(r io.Reader) (interface{}, error) {\n+\t\trv := reflect.New(t)\n+\t\terr := dec(rv.Elem(), r)\n+\t\treturn rv.Elem().Interface(), err\n+\t}\n+}\n+\n+// decoderForSingleTypeReflect returns a reflection based decoder function for the\n+// given type.\n+func decoderForSingleTypeReflect(t reflect.Type) func(reflect.Value, io.Reader) error {\n+\tswitch t.Kind() {\n+\tcase reflect.Struct:\n+\t\treturn decoderForStructReflect(t)\n+\tcase reflect.Bool:\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\tv, err := DecodeBool(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn errors.Wrap(err, \"error decoding varint field\")\n+\t\t\t}\n+\t\t\trv.SetBool(v)\n+\t\t\treturn nil\n+\t\t}\n+\tcase reflect.Uint8:\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\tb, err := DecodeByte(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "033b1bf4df9dbec27d53d581aa07c186729995ab"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA2NzY5Mw==", "bodyText": "Nit: Since this is only used in decoderForStructReflect it may be better for legibility to declare it right above that function.", "url": "https://github.com/apache/beam/pull/12141#discussion_r448067693", "createdAt": "2020-07-01T01:34:45Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/graph/coder/row.go", "diffHunk": "@@ -0,0 +1,379 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package coder\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"reflect\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/ioutilx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+)\n+\n+type typeDecoderReflect struct {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "033b1bf4df9dbec27d53d581aa07c186729995ab"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA3MTQ1OQ==", "bodyText": "This seems unnecessary here, i doesn't get added to a closure as far as I can see.", "url": "https://github.com/apache/beam/pull/12141#discussion_r448071459", "createdAt": "2020-07-01T01:50:32Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/graph/coder/row.go", "diffHunk": "@@ -0,0 +1,379 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package coder\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"reflect\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/ioutilx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+)\n+\n+type typeDecoderReflect struct {\n+\ttyp    reflect.Type\n+\tfields []func(reflect.Value, io.Reader) error\n+}\n+\n+// RowEncoderForStruct returns an encoding function that encodes a struct type\n+// or a pointer to a struct type using the beam row encoding.\n+//\n+// Returns an error if the given type is invalid or not encodable to a beam\n+// schema row.\n+func RowEncoderForStruct(rt reflect.Type) (func(interface{}, io.Writer) error, error) {\n+\tif err := rowTypeValidation(rt, true); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn encoderForType(rt), nil\n+}\n+\n+// RowDecoderForStruct returns a decoding function that decodes the beam row encoding\n+// into the given type.\n+//\n+// Returns an error if the given type is invalid or not decodable from a beam\n+// schema row.\n+func RowDecoderForStruct(rt reflect.Type) (func(io.Reader) (interface{}, error), error) {\n+\tif err := rowTypeValidation(rt, true); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn decoderForType(rt), nil\n+}\n+\n+func rowTypeValidation(rt reflect.Type, strictExportedFields bool) error {\n+\tswitch k := rt.Kind(); k {\n+\tcase reflect.Ptr, reflect.Struct:\n+\tdefault:\n+\t\treturn errors.Errorf(\"can't generate row coder for type %v: must be a struct type or pointer to a struct type\", rt)\n+\t}\n+\t// TODO exported field validation.\n+\treturn nil\n+}\n+\n+// decoderForType returns a decoder function for the struct or pointer to struct type.\n+func decoderForType(t reflect.Type) func(io.Reader) (interface{}, error) {\n+\tvar isPtr bool\n+\t// Pointers become the value type for decomposition.\n+\tif t.Kind() == reflect.Ptr {\n+\t\tisPtr = true\n+\t\tt = t.Elem()\n+\t}\n+\tdec := decoderForStructReflect(t)\n+\n+\tif isPtr {\n+\t\treturn func(r io.Reader) (interface{}, error) {\n+\t\t\trv := reflect.New(t)\n+\t\t\terr := dec(rv.Elem(), r)\n+\t\t\treturn rv.Interface(), err\n+\t\t}\n+\t}\n+\treturn func(r io.Reader) (interface{}, error) {\n+\t\trv := reflect.New(t)\n+\t\terr := dec(rv.Elem(), r)\n+\t\treturn rv.Elem().Interface(), err\n+\t}\n+}\n+\n+// decoderForSingleTypeReflect returns a reflection based decoder function for the\n+// given type.\n+func decoderForSingleTypeReflect(t reflect.Type) func(reflect.Value, io.Reader) error {\n+\tswitch t.Kind() {\n+\tcase reflect.Struct:\n+\t\treturn decoderForStructReflect(t)\n+\tcase reflect.Bool:\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\tv, err := DecodeBool(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn errors.Wrap(err, \"error decoding varint field\")\n+\t\t\t}\n+\t\t\trv.SetBool(v)\n+\t\t\treturn nil\n+\t\t}\n+\tcase reflect.Uint8:\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\tb, err := DecodeByte(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\trv.SetUint(uint64(b))\n+\t\t\treturn nil\n+\t\t}\n+\tcase reflect.String:\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\tv, err := DecodeStringUTF8(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn errors.Wrap(err, \"error decoding string field\")\n+\t\t\t}\n+\t\t\trv.SetString(v)\n+\t\t\treturn nil\n+\t\t}\n+\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\tv, err := DecodeVarInt(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn errors.Wrap(err, \"error decoding varint field\")\n+\t\t\t}\n+\t\t\trv.SetInt(v)\n+\t\t\treturn nil\n+\t\t}\n+\tcase reflect.Float32, reflect.Float64:\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\tv, err := DecodeDouble(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn errors.Wrap(err, \"error decoding double field\")\n+\t\t\t}\n+\t\t\trv.SetFloat(v)\n+\t\t\treturn nil\n+\t\t}\n+\tcase reflect.Ptr:\n+\t\tdecf := decoderForSingleTypeReflect(t.Elem())\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\tnv := reflect.New(t.Elem())\n+\t\t\trv.Set(nv)\n+\t\t\treturn decf(nv.Elem(), r)\n+\t\t}\n+\tcase reflect.Slice:\n+\t\t// Special case handling for byte slices.\n+\t\tif t.Elem().Kind() == reflect.Uint8 {\n+\t\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\t\tb, err := DecodeBytes(r)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t\trv.SetBytes(b)\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t}\n+\t\tdecf := decoderForSingleTypeReflect(t.Elem())\n+\t\tsdec := iterableDecoderForSlice(t, decf)\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\treturn sdec(rv, r)\n+\t\t}\n+\tcase reflect.Array:\n+\t\tdecf := decoderForSingleTypeReflect(t.Elem())\n+\t\tsdec := iterableDecoderForArray(t, decf)\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\treturn sdec(rv, r)\n+\t\t}\n+\t}\n+\tpanic(fmt.Sprintf(\"unimplemented type to decode: %v\", t))\n+}\n+\n+// decoderForStructReflect returns a reflection based decoder function for the\n+// given struct type.\n+func decoderForStructReflect(t reflect.Type) func(reflect.Value, io.Reader) error {\n+\tvar coder typeDecoderReflect\n+\tfor i := 0; i < t.NumField(); i++ {\n+\t\ti := i // avoid alias issues in the closures.\n+\t\tdec := decoderForSingleTypeReflect(t.Field(i).Type)\n+\t\tcoder.fields = append(coder.fields, func(rv reflect.Value, r io.Reader) error {\n+\t\t\treturn dec(rv.Field(i), r)\n+\t\t})\n+\t}\n+\n+\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\tnf, nils, err := readRowHeader(rv, r)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif nf != len(coder.fields) {\n+\t\t\treturn errors.Errorf(\"schema[%v] changed: got %d fields, want %d fields\", \"TODO\", nf, len(coder.fields))\n+\t\t}\n+\t\tfor i, f := range coder.fields {\n+\t\t\tif isFieldNil(nils, i) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif err := f(rv, r); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t\treturn nil\n+\t}\n+}\n+\n+// isFieldNil examines the passed in packed bits nils buffer\n+// and returns true if the field at that index wasn't encoded\n+// and can be skipped in decoding.\n+func isFieldNil(nils []byte, f int) bool {\n+\ti, b := f/8, f%8\n+\treturn len(nils) != 0 && (nils[i]>>uint8(b))&0x1 == 1\n+}\n+\n+// encoderForType returns an encoder function for the struct or pointer to struct type.\n+func encoderForType(t reflect.Type) func(interface{}, io.Writer) error {\n+\tvar isPtr bool\n+\t// Pointers become the value type for decomposition.\n+\tif t.Kind() == reflect.Ptr {\n+\t\tisPtr = true\n+\t\tt = t.Elem()\n+\t}\n+\tenc := encoderForStructReflect(t)\n+\n+\tif isPtr {\n+\t\treturn func(v interface{}, w io.Writer) error {\n+\t\t\treturn enc(reflect.ValueOf(v).Elem(), w)\n+\t\t}\n+\t}\n+\treturn func(v interface{}, w io.Writer) error {\n+\t\treturn enc(reflect.ValueOf(v), w)\n+\t}\n+}\n+\n+// Generates coder using reflection for\n+func encoderForSingleTypeReflect(t reflect.Type) func(reflect.Value, io.Writer) error {\n+\tswitch t.Kind() {\n+\tcase reflect.Struct:\n+\t\treturn encoderForStructReflect(t)\n+\tcase reflect.Bool:\n+\t\treturn func(rv reflect.Value, w io.Writer) error {\n+\t\t\treturn EncodeBool(rv.Bool(), w)\n+\t\t}\n+\tcase reflect.Uint8:\n+\t\treturn func(rv reflect.Value, w io.Writer) error {\n+\t\t\treturn EncodeByte(byte(rv.Uint()), w)\n+\t\t}\n+\tcase reflect.String:\n+\t\treturn func(rv reflect.Value, w io.Writer) error {\n+\t\t\treturn EncodeStringUTF8(rv.String(), w)\n+\t\t}\n+\tcase reflect.Int, reflect.Int64, reflect.Int16, reflect.Int32, reflect.Int8:\n+\t\treturn func(rv reflect.Value, w io.Writer) error {\n+\t\t\treturn EncodeVarInt(int64(rv.Int()), w)\n+\t\t}\n+\tcase reflect.Float32, reflect.Float64:\n+\t\treturn func(rv reflect.Value, w io.Writer) error {\n+\t\t\treturn EncodeDouble(float64(rv.Float()), w)\n+\t\t}\n+\tcase reflect.Ptr:\n+\t\t// Nils are handled at the struct field level.\n+\t\tencf := encoderForSingleTypeReflect(t.Elem())\n+\t\treturn func(rv reflect.Value, w io.Writer) error {\n+\t\t\treturn encf(rv.Elem(), w)\n+\t\t}\n+\tcase reflect.Slice:\n+\t\t// Special case handling for byte slices.\n+\t\tif t.Elem().Kind() == reflect.Uint8 {\n+\t\t\treturn func(rv reflect.Value, w io.Writer) error {\n+\t\t\t\treturn EncodeBytes(rv.Bytes(), w)\n+\t\t\t}\n+\t\t}\n+\t\tencf := encoderForSingleTypeReflect(t.Elem())\n+\t\treturn iterableEncoder(t, encf)\n+\tcase reflect.Array:\n+\t\tencf := encoderForSingleTypeReflect(t.Elem())\n+\t\treturn iterableEncoder(t, encf)\n+\t}\n+\tpanic(fmt.Sprintf(\"unimplemented type to encode: %v\", t))\n+}\n+\n+type typeEncoderReflect struct {\n+\tfields []func(reflect.Value, io.Writer) error\n+}\n+\n+// encoderForStructReflect generates reflection field access closures for structs.\n+func encoderForStructReflect(t reflect.Type) func(reflect.Value, io.Writer) error {\n+\tvar coder typeEncoderReflect\n+\tfor i := 0; i < t.NumField(); i++ {\n+\t\ti := i // avoid alias issues in the closures.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "033b1bf4df9dbec27d53d581aa07c186729995ab"}, "originalPosition": 290}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c4aeedf9d56e40834f06b1b41c99a07b22e0c85", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/5c4aeedf9d56e40834f06b1b41c99a07b22e0c85", "committedDate": "2020-07-01T18:13:06Z", "message": "!fixup address comments & go1.12 compiler error"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMDkyNjc4", "url": "https://github.com/apache/beam/pull/12141#pullrequestreview-441092678", "createdAt": "2020-07-01T18:09:56Z", "commit": {"oid": "033b1bf4df9dbec27d53d581aa07c186729995ab"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODowOTo1NlrOGrwXDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODoxMjoyN1rOGrwb4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzNDI4Nw==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/12141#discussion_r448534287", "createdAt": "2020-07-01T18:09:56Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/graph/coder/row.go", "diffHunk": "@@ -0,0 +1,379 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package coder\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"reflect\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/ioutilx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+)\n+\n+type typeDecoderReflect struct {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA2NzY5Mw=="}, "originalCommit": {"oid": "033b1bf4df9dbec27d53d581aa07c186729995ab"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzNDk2OA==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/12141#discussion_r448534968", "createdAt": "2020-07-01T18:11:13Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/graph/coder/row.go", "diffHunk": "@@ -0,0 +1,379 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package coder\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"reflect\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/ioutilx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+)\n+\n+type typeDecoderReflect struct {\n+\ttyp    reflect.Type\n+\tfields []func(reflect.Value, io.Reader) error\n+}\n+\n+// RowEncoderForStruct returns an encoding function that encodes a struct type\n+// or a pointer to a struct type using the beam row encoding.\n+//\n+// Returns an error if the given type is invalid or not encodable to a beam\n+// schema row.\n+func RowEncoderForStruct(rt reflect.Type) (func(interface{}, io.Writer) error, error) {\n+\tif err := rowTypeValidation(rt, true); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn encoderForType(rt), nil\n+}\n+\n+// RowDecoderForStruct returns a decoding function that decodes the beam row encoding\n+// into the given type.\n+//\n+// Returns an error if the given type is invalid or not decodable from a beam\n+// schema row.\n+func RowDecoderForStruct(rt reflect.Type) (func(io.Reader) (interface{}, error), error) {\n+\tif err := rowTypeValidation(rt, true); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn decoderForType(rt), nil\n+}\n+\n+func rowTypeValidation(rt reflect.Type, strictExportedFields bool) error {\n+\tswitch k := rt.Kind(); k {\n+\tcase reflect.Ptr, reflect.Struct:\n+\tdefault:\n+\t\treturn errors.Errorf(\"can't generate row coder for type %v: must be a struct type or pointer to a struct type\", rt)\n+\t}\n+\t// TODO exported field validation.\n+\treturn nil\n+}\n+\n+// decoderForType returns a decoder function for the struct or pointer to struct type.\n+func decoderForType(t reflect.Type) func(io.Reader) (interface{}, error) {\n+\tvar isPtr bool\n+\t// Pointers become the value type for decomposition.\n+\tif t.Kind() == reflect.Ptr {\n+\t\tisPtr = true\n+\t\tt = t.Elem()\n+\t}\n+\tdec := decoderForStructReflect(t)\n+\n+\tif isPtr {\n+\t\treturn func(r io.Reader) (interface{}, error) {\n+\t\t\trv := reflect.New(t)\n+\t\t\terr := dec(rv.Elem(), r)\n+\t\t\treturn rv.Interface(), err\n+\t\t}\n+\t}\n+\treturn func(r io.Reader) (interface{}, error) {\n+\t\trv := reflect.New(t)\n+\t\terr := dec(rv.Elem(), r)\n+\t\treturn rv.Elem().Interface(), err\n+\t}\n+}\n+\n+// decoderForSingleTypeReflect returns a reflection based decoder function for the\n+// given type.\n+func decoderForSingleTypeReflect(t reflect.Type) func(reflect.Value, io.Reader) error {\n+\tswitch t.Kind() {\n+\tcase reflect.Struct:\n+\t\treturn decoderForStructReflect(t)\n+\tcase reflect.Bool:\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\tv, err := DecodeBool(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn errors.Wrap(err, \"error decoding varint field\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzgzOQ=="}, "originalCommit": {"oid": "033b1bf4df9dbec27d53d581aa07c186729995ab"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzNTAzMg==", "bodyText": "Nope. Thanks!", "url": "https://github.com/apache/beam/pull/12141#discussion_r448535032", "createdAt": "2020-07-01T18:11:21Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/graph/coder/row.go", "diffHunk": "@@ -0,0 +1,379 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package coder\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"reflect\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/ioutilx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+)\n+\n+type typeDecoderReflect struct {\n+\ttyp    reflect.Type\n+\tfields []func(reflect.Value, io.Reader) error\n+}\n+\n+// RowEncoderForStruct returns an encoding function that encodes a struct type\n+// or a pointer to a struct type using the beam row encoding.\n+//\n+// Returns an error if the given type is invalid or not encodable to a beam\n+// schema row.\n+func RowEncoderForStruct(rt reflect.Type) (func(interface{}, io.Writer) error, error) {\n+\tif err := rowTypeValidation(rt, true); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn encoderForType(rt), nil\n+}\n+\n+// RowDecoderForStruct returns a decoding function that decodes the beam row encoding\n+// into the given type.\n+//\n+// Returns an error if the given type is invalid or not decodable from a beam\n+// schema row.\n+func RowDecoderForStruct(rt reflect.Type) (func(io.Reader) (interface{}, error), error) {\n+\tif err := rowTypeValidation(rt, true); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn decoderForType(rt), nil\n+}\n+\n+func rowTypeValidation(rt reflect.Type, strictExportedFields bool) error {\n+\tswitch k := rt.Kind(); k {\n+\tcase reflect.Ptr, reflect.Struct:\n+\tdefault:\n+\t\treturn errors.Errorf(\"can't generate row coder for type %v: must be a struct type or pointer to a struct type\", rt)\n+\t}\n+\t// TODO exported field validation.\n+\treturn nil\n+}\n+\n+// decoderForType returns a decoder function for the struct or pointer to struct type.\n+func decoderForType(t reflect.Type) func(io.Reader) (interface{}, error) {\n+\tvar isPtr bool\n+\t// Pointers become the value type for decomposition.\n+\tif t.Kind() == reflect.Ptr {\n+\t\tisPtr = true\n+\t\tt = t.Elem()\n+\t}\n+\tdec := decoderForStructReflect(t)\n+\n+\tif isPtr {\n+\t\treturn func(r io.Reader) (interface{}, error) {\n+\t\t\trv := reflect.New(t)\n+\t\t\terr := dec(rv.Elem(), r)\n+\t\t\treturn rv.Interface(), err\n+\t\t}\n+\t}\n+\treturn func(r io.Reader) (interface{}, error) {\n+\t\trv := reflect.New(t)\n+\t\terr := dec(rv.Elem(), r)\n+\t\treturn rv.Elem().Interface(), err\n+\t}\n+}\n+\n+// decoderForSingleTypeReflect returns a reflection based decoder function for the\n+// given type.\n+func decoderForSingleTypeReflect(t reflect.Type) func(reflect.Value, io.Reader) error {\n+\tswitch t.Kind() {\n+\tcase reflect.Struct:\n+\t\treturn decoderForStructReflect(t)\n+\tcase reflect.Bool:\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\tv, err := DecodeBool(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn errors.Wrap(err, \"error decoding varint field\")\n+\t\t\t}\n+\t\t\trv.SetBool(v)\n+\t\t\treturn nil\n+\t\t}\n+\tcase reflect.Uint8:\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\tb, err := DecodeByte(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NjA0Ng=="}, "originalCommit": {"oid": "033b1bf4df9dbec27d53d581aa07c186729995ab"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzNTUyMg==", "bodyText": "Yup. Leftover from an intermediate state. Thank you!", "url": "https://github.com/apache/beam/pull/12141#discussion_r448535522", "createdAt": "2020-07-01T18:12:27Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/graph/coder/row.go", "diffHunk": "@@ -0,0 +1,379 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package coder\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"reflect\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/ioutilx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+)\n+\n+type typeDecoderReflect struct {\n+\ttyp    reflect.Type\n+\tfields []func(reflect.Value, io.Reader) error\n+}\n+\n+// RowEncoderForStruct returns an encoding function that encodes a struct type\n+// or a pointer to a struct type using the beam row encoding.\n+//\n+// Returns an error if the given type is invalid or not encodable to a beam\n+// schema row.\n+func RowEncoderForStruct(rt reflect.Type) (func(interface{}, io.Writer) error, error) {\n+\tif err := rowTypeValidation(rt, true); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn encoderForType(rt), nil\n+}\n+\n+// RowDecoderForStruct returns a decoding function that decodes the beam row encoding\n+// into the given type.\n+//\n+// Returns an error if the given type is invalid or not decodable from a beam\n+// schema row.\n+func RowDecoderForStruct(rt reflect.Type) (func(io.Reader) (interface{}, error), error) {\n+\tif err := rowTypeValidation(rt, true); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn decoderForType(rt), nil\n+}\n+\n+func rowTypeValidation(rt reflect.Type, strictExportedFields bool) error {\n+\tswitch k := rt.Kind(); k {\n+\tcase reflect.Ptr, reflect.Struct:\n+\tdefault:\n+\t\treturn errors.Errorf(\"can't generate row coder for type %v: must be a struct type or pointer to a struct type\", rt)\n+\t}\n+\t// TODO exported field validation.\n+\treturn nil\n+}\n+\n+// decoderForType returns a decoder function for the struct or pointer to struct type.\n+func decoderForType(t reflect.Type) func(io.Reader) (interface{}, error) {\n+\tvar isPtr bool\n+\t// Pointers become the value type for decomposition.\n+\tif t.Kind() == reflect.Ptr {\n+\t\tisPtr = true\n+\t\tt = t.Elem()\n+\t}\n+\tdec := decoderForStructReflect(t)\n+\n+\tif isPtr {\n+\t\treturn func(r io.Reader) (interface{}, error) {\n+\t\t\trv := reflect.New(t)\n+\t\t\terr := dec(rv.Elem(), r)\n+\t\t\treturn rv.Interface(), err\n+\t\t}\n+\t}\n+\treturn func(r io.Reader) (interface{}, error) {\n+\t\trv := reflect.New(t)\n+\t\terr := dec(rv.Elem(), r)\n+\t\treturn rv.Elem().Interface(), err\n+\t}\n+}\n+\n+// decoderForSingleTypeReflect returns a reflection based decoder function for the\n+// given type.\n+func decoderForSingleTypeReflect(t reflect.Type) func(reflect.Value, io.Reader) error {\n+\tswitch t.Kind() {\n+\tcase reflect.Struct:\n+\t\treturn decoderForStructReflect(t)\n+\tcase reflect.Bool:\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\tv, err := DecodeBool(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn errors.Wrap(err, \"error decoding varint field\")\n+\t\t\t}\n+\t\t\trv.SetBool(v)\n+\t\t\treturn nil\n+\t\t}\n+\tcase reflect.Uint8:\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\tb, err := DecodeByte(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\trv.SetUint(uint64(b))\n+\t\t\treturn nil\n+\t\t}\n+\tcase reflect.String:\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\tv, err := DecodeStringUTF8(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn errors.Wrap(err, \"error decoding string field\")\n+\t\t\t}\n+\t\t\trv.SetString(v)\n+\t\t\treturn nil\n+\t\t}\n+\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\tv, err := DecodeVarInt(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn errors.Wrap(err, \"error decoding varint field\")\n+\t\t\t}\n+\t\t\trv.SetInt(v)\n+\t\t\treturn nil\n+\t\t}\n+\tcase reflect.Float32, reflect.Float64:\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\tv, err := DecodeDouble(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn errors.Wrap(err, \"error decoding double field\")\n+\t\t\t}\n+\t\t\trv.SetFloat(v)\n+\t\t\treturn nil\n+\t\t}\n+\tcase reflect.Ptr:\n+\t\tdecf := decoderForSingleTypeReflect(t.Elem())\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\tnv := reflect.New(t.Elem())\n+\t\t\trv.Set(nv)\n+\t\t\treturn decf(nv.Elem(), r)\n+\t\t}\n+\tcase reflect.Slice:\n+\t\t// Special case handling for byte slices.\n+\t\tif t.Elem().Kind() == reflect.Uint8 {\n+\t\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\t\tb, err := DecodeBytes(r)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t\trv.SetBytes(b)\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t}\n+\t\tdecf := decoderForSingleTypeReflect(t.Elem())\n+\t\tsdec := iterableDecoderForSlice(t, decf)\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\treturn sdec(rv, r)\n+\t\t}\n+\tcase reflect.Array:\n+\t\tdecf := decoderForSingleTypeReflect(t.Elem())\n+\t\tsdec := iterableDecoderForArray(t, decf)\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\treturn sdec(rv, r)\n+\t\t}\n+\t}\n+\tpanic(fmt.Sprintf(\"unimplemented type to decode: %v\", t))\n+}\n+\n+// decoderForStructReflect returns a reflection based decoder function for the\n+// given struct type.\n+func decoderForStructReflect(t reflect.Type) func(reflect.Value, io.Reader) error {\n+\tvar coder typeDecoderReflect\n+\tfor i := 0; i < t.NumField(); i++ {\n+\t\ti := i // avoid alias issues in the closures.\n+\t\tdec := decoderForSingleTypeReflect(t.Field(i).Type)\n+\t\tcoder.fields = append(coder.fields, func(rv reflect.Value, r io.Reader) error {\n+\t\t\treturn dec(rv.Field(i), r)\n+\t\t})\n+\t}\n+\n+\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\tnf, nils, err := readRowHeader(rv, r)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif nf != len(coder.fields) {\n+\t\t\treturn errors.Errorf(\"schema[%v] changed: got %d fields, want %d fields\", \"TODO\", nf, len(coder.fields))\n+\t\t}\n+\t\tfor i, f := range coder.fields {\n+\t\t\tif isFieldNil(nils, i) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif err := f(rv, r); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t\treturn nil\n+\t}\n+}\n+\n+// isFieldNil examines the passed in packed bits nils buffer\n+// and returns true if the field at that index wasn't encoded\n+// and can be skipped in decoding.\n+func isFieldNil(nils []byte, f int) bool {\n+\ti, b := f/8, f%8\n+\treturn len(nils) != 0 && (nils[i]>>uint8(b))&0x1 == 1\n+}\n+\n+// encoderForType returns an encoder function for the struct or pointer to struct type.\n+func encoderForType(t reflect.Type) func(interface{}, io.Writer) error {\n+\tvar isPtr bool\n+\t// Pointers become the value type for decomposition.\n+\tif t.Kind() == reflect.Ptr {\n+\t\tisPtr = true\n+\t\tt = t.Elem()\n+\t}\n+\tenc := encoderForStructReflect(t)\n+\n+\tif isPtr {\n+\t\treturn func(v interface{}, w io.Writer) error {\n+\t\t\treturn enc(reflect.ValueOf(v).Elem(), w)\n+\t\t}\n+\t}\n+\treturn func(v interface{}, w io.Writer) error {\n+\t\treturn enc(reflect.ValueOf(v), w)\n+\t}\n+}\n+\n+// Generates coder using reflection for\n+func encoderForSingleTypeReflect(t reflect.Type) func(reflect.Value, io.Writer) error {\n+\tswitch t.Kind() {\n+\tcase reflect.Struct:\n+\t\treturn encoderForStructReflect(t)\n+\tcase reflect.Bool:\n+\t\treturn func(rv reflect.Value, w io.Writer) error {\n+\t\t\treturn EncodeBool(rv.Bool(), w)\n+\t\t}\n+\tcase reflect.Uint8:\n+\t\treturn func(rv reflect.Value, w io.Writer) error {\n+\t\t\treturn EncodeByte(byte(rv.Uint()), w)\n+\t\t}\n+\tcase reflect.String:\n+\t\treturn func(rv reflect.Value, w io.Writer) error {\n+\t\t\treturn EncodeStringUTF8(rv.String(), w)\n+\t\t}\n+\tcase reflect.Int, reflect.Int64, reflect.Int16, reflect.Int32, reflect.Int8:\n+\t\treturn func(rv reflect.Value, w io.Writer) error {\n+\t\t\treturn EncodeVarInt(int64(rv.Int()), w)\n+\t\t}\n+\tcase reflect.Float32, reflect.Float64:\n+\t\treturn func(rv reflect.Value, w io.Writer) error {\n+\t\t\treturn EncodeDouble(float64(rv.Float()), w)\n+\t\t}\n+\tcase reflect.Ptr:\n+\t\t// Nils are handled at the struct field level.\n+\t\tencf := encoderForSingleTypeReflect(t.Elem())\n+\t\treturn func(rv reflect.Value, w io.Writer) error {\n+\t\t\treturn encf(rv.Elem(), w)\n+\t\t}\n+\tcase reflect.Slice:\n+\t\t// Special case handling for byte slices.\n+\t\tif t.Elem().Kind() == reflect.Uint8 {\n+\t\t\treturn func(rv reflect.Value, w io.Writer) error {\n+\t\t\t\treturn EncodeBytes(rv.Bytes(), w)\n+\t\t\t}\n+\t\t}\n+\t\tencf := encoderForSingleTypeReflect(t.Elem())\n+\t\treturn iterableEncoder(t, encf)\n+\tcase reflect.Array:\n+\t\tencf := encoderForSingleTypeReflect(t.Elem())\n+\t\treturn iterableEncoder(t, encf)\n+\t}\n+\tpanic(fmt.Sprintf(\"unimplemented type to encode: %v\", t))\n+}\n+\n+type typeEncoderReflect struct {\n+\tfields []func(reflect.Value, io.Writer) error\n+}\n+\n+// encoderForStructReflect generates reflection field access closures for structs.\n+func encoderForStructReflect(t reflect.Type) func(reflect.Value, io.Writer) error {\n+\tvar coder typeEncoderReflect\n+\tfor i := 0; i < t.NumField(); i++ {\n+\t\ti := i // avoid alias issues in the closures.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA3MTQ1OQ=="}, "originalCommit": {"oid": "033b1bf4df9dbec27d53d581aa07c186729995ab"}, "originalPosition": 290}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMjE0ODcx", "url": "https://github.com/apache/beam/pull/12141#pullrequestreview-441214871", "createdAt": "2020-07-01T21:41:11Z", "commit": {"oid": "5c4aeedf9d56e40834f06b1b41c99a07b22e0c85"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3258, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}