{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxNjc0MjEz", "number": 12124, "title": "[BEAM-10312] Sub-element progress accounted for during splitting.", "bodyText": "Adding sub-element progress to the splitting logic in DataSource.\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nDataflow\nFlink\nSamza\nSpark\nTwister2\n\n\n\n\nGo\n\n---\n\n---\n\n---\n\n\nJava\n\n\n\n\n\n\n\n\nPython\n\n\n\n---\n\n---\n\n\nXLang\n---\n---\n\n---\n---\n\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-06-29T22:08:12Z", "url": "https://github.com/apache/beam/pull/12124", "merged": true, "mergeCommit": {"oid": "8f2d49bb2dc67a5679fc85ccd638f65ef0610a44"}, "closed": true, "closedAt": "2020-06-30T23:26:16Z", "author": {"login": "youngoli"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcwKOPRgFqTQzOTU2OTkzNA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcwdyGagBqjM0OTk5NTAzODI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NTY5OTM0", "url": "https://github.com/apache/beam/pull/12124#pullrequestreview-439569934", "createdAt": "2020-06-29T23:31:51Z", "commit": {"oid": "35be9ac181bba8099a7e4f9b3a4c3c1ed804ba35"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMzozMTo1MVrOGqmEZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMDowNzo0N1rOGqmypA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxNzA5NA==", "bodyText": "Extremely minor nit: Since the actual value here doesn't matter, just the type, consider var currProg float64  instead to make it clearer that the value is notionally uninitialized.\nThere's an argument to be made that this way it gets it's type from the rt.GetProgress() call then, which is a bit more flexible, but  that benefits the writer more than the reader.", "url": "https://github.com/apache/beam/pull/12124#discussion_r447317094", "createdAt": "2020-06-29T23:31:51Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/datasource.go", "diffHunk": "@@ -302,12 +302,23 @@ func (n *DataSource) Split(splits []int64, frac float64, bufSize int64) (int64,\n \t}\n \n \tn.mu.Lock()\n+\tcurrProg := 0.0  // Current element progress.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35be9ac181bba8099a7e4f9b3a4c3c1ed804ba35"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyNDgyMg==", "bodyText": "idomatic nit: since the previous if returns, we don't need the else clause, remove the else, and unindent.", "url": "https://github.com/apache/beam/pull/12124#discussion_r447324822", "createdAt": "2020-06-29T23:55:20Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/datasource.go", "diffHunk": "@@ -319,39 +330,85 @@ func (n *DataSource) Split(splits []int64, frac float64, bufSize int64) (int64,\n }\n \n // splitHelper is a helper function that finds a split point in a range.\n-// currIdx and splitIdx should match the DataSource's index and splitIdx fields,\n-// and represent the start and end of the splittable range respectively. splits\n-// is an optional slice of valid split indices, and if nil then all indices are\n-// considered valid split points. frac must be between [0, 1], and represents\n-// a fraction of the remaining work that the split point aims to be as close\n-// as possible to.\n-func splitHelper(currIdx, splitIdx int64, splits []int64, frac float64) (int64, error) {\n+//\n+// currIdx and endIdx should match the DataSource's index and splitIdx fields,\n+// and represent the start and end of the splittable range respectively.\n+//\n+// currProg represents the progress through the current element (currIdx).\n+//\n+// splits is an optional slice of valid split indices, and if nil then all\n+// indices are considered valid split points.\n+//\n+// frac must be between [0, 1], and represents a fraction of the remaining work\n+// that the split point aims to be as close as possible to.\n+//\n+// splittable indicates that sub-element splitting is possible (i.e. the next\n+// unit is an SDF).\n+//\n+// Returns the element index to split at (first element of residual), and the\n+// fraction within that element to split, iff the split point is the current\n+// element, the splittable param is set to true, and both the element being\n+// split and the following element are valid split points.\n+func splitHelper(\n+\tcurrIdx, endIdx int64,\n+\tcurrProg float64,\n+\tsplits []int64,\n+\tfrac float64,\n+\tsplittable bool) (int64, float64, error) {\n \t// Get split index from fraction. Find the closest index to the fraction of\n \t// the remainder.\n-\tvar start int64 = 0\n-\tif currIdx > start {\n-\t\tstart = currIdx\n-\t}\n-\t// This is the first valid split index, since we should never split at 0 or\n-\t// at the current element.\n-\tsafeStart := start + 1\n-\t// The remainder starts at our actual progress (i.e. start), but our final\n-\t// split index has to be >= our safeStart.\n-\tfracIdx := start + int64(math.Round(frac*float64(splitIdx-start)))\n-\tif fracIdx < safeStart {\n-\t\tfracIdx = safeStart\n+\tstart := float64(currIdx) + currProg\n+\tsafeStart := currIdx + 1 // safeStart avoids splitting at 0, or <= currIdx\n+\tif safeStart <= 0 {\n+\t\tsafeStart = 1\n \t}\n+\tvar splitFloat = start + frac*(float64(endIdx)-start)\n+\n \tif len(splits) == 0 {\n-\t\t// All split points are valid so just split at fraction.\n-\t\treturn fracIdx, nil\n+\t\tif splittable && int64(splitFloat) == currIdx {\n+\t\t\t// Sub-element splitting is valid here, so return fraction.\n+\t\t\t_, f := math.Modf(splitFloat)\n+\t\t\treturn int64(splitFloat), f, nil\n+\t\t} else {\n+\t\t\t// All split points are valid so just split at safe index closest to\n+\t\t\t// fraction.\n+\t\t\tsplitIdx := int64(math.Round(splitFloat))\n+\t\t\tif splitIdx < safeStart {\n+\t\t\t\tsplitIdx = safeStart\n+\t\t\t}\n+\t\t\treturn splitIdx, 0.0, nil\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35be9ac181bba8099a7e4f9b3a4c3c1ed804ba35"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyNTMwNA==", "bodyText": "By extension, since unindenting the nested else right above here makes clear that enterng that if clause is terminal, remove and unindent this else clause here, which brings the rest of the function back to indent-1", "url": "https://github.com/apache/beam/pull/12124#discussion_r447325304", "createdAt": "2020-06-29T23:56:53Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/datasource.go", "diffHunk": "@@ -319,39 +330,85 @@ func (n *DataSource) Split(splits []int64, frac float64, bufSize int64) (int64,\n }\n \n // splitHelper is a helper function that finds a split point in a range.\n-// currIdx and splitIdx should match the DataSource's index and splitIdx fields,\n-// and represent the start and end of the splittable range respectively. splits\n-// is an optional slice of valid split indices, and if nil then all indices are\n-// considered valid split points. frac must be between [0, 1], and represents\n-// a fraction of the remaining work that the split point aims to be as close\n-// as possible to.\n-func splitHelper(currIdx, splitIdx int64, splits []int64, frac float64) (int64, error) {\n+//\n+// currIdx and endIdx should match the DataSource's index and splitIdx fields,\n+// and represent the start and end of the splittable range respectively.\n+//\n+// currProg represents the progress through the current element (currIdx).\n+//\n+// splits is an optional slice of valid split indices, and if nil then all\n+// indices are considered valid split points.\n+//\n+// frac must be between [0, 1], and represents a fraction of the remaining work\n+// that the split point aims to be as close as possible to.\n+//\n+// splittable indicates that sub-element splitting is possible (i.e. the next\n+// unit is an SDF).\n+//\n+// Returns the element index to split at (first element of residual), and the\n+// fraction within that element to split, iff the split point is the current\n+// element, the splittable param is set to true, and both the element being\n+// split and the following element are valid split points.\n+func splitHelper(\n+\tcurrIdx, endIdx int64,\n+\tcurrProg float64,\n+\tsplits []int64,\n+\tfrac float64,\n+\tsplittable bool) (int64, float64, error) {\n \t// Get split index from fraction. Find the closest index to the fraction of\n \t// the remainder.\n-\tvar start int64 = 0\n-\tif currIdx > start {\n-\t\tstart = currIdx\n-\t}\n-\t// This is the first valid split index, since we should never split at 0 or\n-\t// at the current element.\n-\tsafeStart := start + 1\n-\t// The remainder starts at our actual progress (i.e. start), but our final\n-\t// split index has to be >= our safeStart.\n-\tfracIdx := start + int64(math.Round(frac*float64(splitIdx-start)))\n-\tif fracIdx < safeStart {\n-\t\tfracIdx = safeStart\n+\tstart := float64(currIdx) + currProg\n+\tsafeStart := currIdx + 1 // safeStart avoids splitting at 0, or <= currIdx\n+\tif safeStart <= 0 {\n+\t\tsafeStart = 1\n \t}\n+\tvar splitFloat = start + frac*(float64(endIdx)-start)\n+\n \tif len(splits) == 0 {\n-\t\t// All split points are valid so just split at fraction.\n-\t\treturn fracIdx, nil\n+\t\tif splittable && int64(splitFloat) == currIdx {\n+\t\t\t// Sub-element splitting is valid here, so return fraction.\n+\t\t\t_, f := math.Modf(splitFloat)\n+\t\t\treturn int64(splitFloat), f, nil\n+\t\t} else {\n+\t\t\t// All split points are valid so just split at safe index closest to\n+\t\t\t// fraction.\n+\t\t\tsplitIdx := int64(math.Round(splitFloat))\n+\t\t\tif splitIdx < safeStart {\n+\t\t\t\tsplitIdx = safeStart\n+\t\t\t}\n+\t\t\treturn splitIdx, 0.0, nil\n+\t\t}\n \t} else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35be9ac181bba8099a7e4f9b3a4c3c1ed804ba35"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyNjUyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t//For non-sub-element splitting, find the closest unprocessed split\n          \n          \n            \n            \t\t// For non-sub-element splitting, find the closest unprocessed split", "url": "https://github.com/apache/beam/pull/12124#discussion_r447326523", "createdAt": "2020-06-30T00:00:11Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/datasource.go", "diffHunk": "@@ -319,39 +330,85 @@ func (n *DataSource) Split(splits []int64, frac float64, bufSize int64) (int64,\n }\n \n // splitHelper is a helper function that finds a split point in a range.\n-// currIdx and splitIdx should match the DataSource's index and splitIdx fields,\n-// and represent the start and end of the splittable range respectively. splits\n-// is an optional slice of valid split indices, and if nil then all indices are\n-// considered valid split points. frac must be between [0, 1], and represents\n-// a fraction of the remaining work that the split point aims to be as close\n-// as possible to.\n-func splitHelper(currIdx, splitIdx int64, splits []int64, frac float64) (int64, error) {\n+//\n+// currIdx and endIdx should match the DataSource's index and splitIdx fields,\n+// and represent the start and end of the splittable range respectively.\n+//\n+// currProg represents the progress through the current element (currIdx).\n+//\n+// splits is an optional slice of valid split indices, and if nil then all\n+// indices are considered valid split points.\n+//\n+// frac must be between [0, 1], and represents a fraction of the remaining work\n+// that the split point aims to be as close as possible to.\n+//\n+// splittable indicates that sub-element splitting is possible (i.e. the next\n+// unit is an SDF).\n+//\n+// Returns the element index to split at (first element of residual), and the\n+// fraction within that element to split, iff the split point is the current\n+// element, the splittable param is set to true, and both the element being\n+// split and the following element are valid split points.\n+func splitHelper(\n+\tcurrIdx, endIdx int64,\n+\tcurrProg float64,\n+\tsplits []int64,\n+\tfrac float64,\n+\tsplittable bool) (int64, float64, error) {\n \t// Get split index from fraction. Find the closest index to the fraction of\n \t// the remainder.\n-\tvar start int64 = 0\n-\tif currIdx > start {\n-\t\tstart = currIdx\n-\t}\n-\t// This is the first valid split index, since we should never split at 0 or\n-\t// at the current element.\n-\tsafeStart := start + 1\n-\t// The remainder starts at our actual progress (i.e. start), but our final\n-\t// split index has to be >= our safeStart.\n-\tfracIdx := start + int64(math.Round(frac*float64(splitIdx-start)))\n-\tif fracIdx < safeStart {\n-\t\tfracIdx = safeStart\n+\tstart := float64(currIdx) + currProg\n+\tsafeStart := currIdx + 1 // safeStart avoids splitting at 0, or <= currIdx\n+\tif safeStart <= 0 {\n+\t\tsafeStart = 1\n \t}\n+\tvar splitFloat = start + frac*(float64(endIdx)-start)\n+\n \tif len(splits) == 0 {\n-\t\t// All split points are valid so just split at fraction.\n-\t\treturn fracIdx, nil\n+\t\tif splittable && int64(splitFloat) == currIdx {\n+\t\t\t// Sub-element splitting is valid here, so return fraction.\n+\t\t\t_, f := math.Modf(splitFloat)\n+\t\t\treturn int64(splitFloat), f, nil\n+\t\t} else {\n+\t\t\t// All split points are valid so just split at safe index closest to\n+\t\t\t// fraction.\n+\t\t\tsplitIdx := int64(math.Round(splitFloat))\n+\t\t\tif splitIdx < safeStart {\n+\t\t\t\tsplitIdx = safeStart\n+\t\t\t}\n+\t\t\treturn splitIdx, 0.0, nil\n+\t\t}\n \t} else {\n-\t\t// Find the closest unprocessed split point to our fraction.\n \t\tsort.Slice(splits, func(i, j int) bool { return splits[i] < splits[j] })\n-\t\tvar prevDiff int64 = math.MaxInt64\n+\n+\t\tif splittable && int64(splitFloat) == currIdx {\n+\t\t\t// Check valid split points to see if we can do a sub-element split.\n+\t\t\t// We need to find the currIdx and currIdx + 1 for it to be valid.\n+\t\t\tc, cp1 := false, false\n+\t\t\tfor _, s := range splits {\n+\t\t\t\tif s == currIdx {\n+\t\t\t\t\tc = true\n+\t\t\t\t} else if s == currIdx+1 {\n+\t\t\t\t\tcp1 = true\n+\t\t\t\t\tbreak\n+\t\t\t\t} else if s > currIdx+1 {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif c && cp1 {\n+\t\t\t\t// Sub-element splitting is valid here, so return fraction.\n+\t\t\t\t_, f := math.Modf(splitFloat)\n+\t\t\t\treturn int64(splitFloat), f, nil\n+\t\t\t}\n+\t\t}\n+\n+\t\t//For non-sub-element splitting, find the closest unprocessed split", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35be9ac181bba8099a7e4f9b3a4c3c1ed804ba35"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyODA1MA==", "bodyText": "Same else comment here. In this case, use t.Fatalf in the err != nil case instead of t.Errorf to get the desired behaviour.", "url": "https://github.com/apache/beam/pull/12124#discussion_r447328050", "createdAt": "2020-06-30T00:04:48Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/datasource_test.go", "diffHunk": "@@ -494,11 +501,50 @@ func TestSplitHelper(t *testing.T) {\n \t\tfor _, test := range tests {\n \t\t\ttest := test\n \t\t\tt.Run(fmt.Sprintf(\"(%v of [%v, %v])\", test.frac, test.curr, test.size), func(t *testing.T) {\n-\t\t\t\tgot, err := splitHelper(test.curr, test.size, nil, test.frac)\n+\t\t\t\twantFrac := 0.0\n+\t\t\t\tgot, gotFrac, err := splitHelper(test.curr, test.size, 0.0, nil, test.frac, false)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"error in splitHelper: %v\", err)\n+\t\t\t\t} else {\n+\t\t\t\t\tif got != test.want {\n+\t\t\t\t\t\tt.Errorf(\"incorrect split point: got: %v, want: %v\", got, test.want)\n+\t\t\t\t\t}\n+\t\t\t\t\tif !floatEquals(gotFrac, wantFrac, eps) {\n+\t\t\t\t\t\tt.Errorf(\"incorrect split fraction: got: %v, want: %v\", gotFrac, wantFrac)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n+\n+\tt.Run(\"WithElementProgress\", func(t *testing.T) {\n+\t\ttests := []struct {\n+\t\t\tcurr, size int64\n+\t\t\tcurrProg   float64\n+\t\t\tfrac       float64\n+\t\t\twant       int64\n+\t\t}{\n+\t\t\t// Progress into the active element influences where the split of\n+\t\t\t// the remainder falls.\n+\t\t\t{curr: 0, currProg: 0.5, size: 4, frac: 0.25, want: 1},\n+\t\t\t{curr: 0, currProg: 0.9, size: 4, frac: 0.25, want: 2},\n+\t\t\t{curr: 1, currProg: 0.0, size: 4, frac: 0.25, want: 2},\n+\t\t\t{curr: 1, currProg: 0.1, size: 4, frac: 0.25, want: 2},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tt.Run(fmt.Sprintf(\"(%v of [%v, %v])\", test.frac, float64(test.curr)+test.currProg, test.size), func(t *testing.T) {\n+\t\t\t\twantFrac := 0.0\n+\t\t\t\tgot, gotFrac, err := splitHelper(test.curr, test.size, test.currProg, nil, test.frac, false)\n \t\t\t\tif err != nil {\n \t\t\t\t\tt.Errorf(\"error in splitHelper: %v\", err)\n-\t\t\t\t} else if got != test.want {\n-\t\t\t\t\tt.Errorf(\"incorrect split point: got: %v, want: %v\", got, test.want)\n+\t\t\t\t} else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35be9ac181bba8099a7e4f9b3a4c3c1ed804ba35"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyODkzMg==", "bodyText": "Same comment here, since t.Errorf can become t.Fatalf.", "url": "https://github.com/apache/beam/pull/12124#discussion_r447328932", "createdAt": "2020-06-30T00:07:47Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/core/runtime/exec/datasource_test.go", "diffHunk": "@@ -528,24 +574,109 @@ func TestSplitHelper(t *testing.T) {\n \t\tfor _, test := range tests {\n \t\t\ttest := test\n \t\t\tt.Run(fmt.Sprintf(\"(%v of [%v, %v], splits = %v)\", test.frac, test.curr, test.size, test.splits), func(t *testing.T) {\n-\t\t\t\tgot, err := splitHelper(test.curr, test.size, test.splits, test.frac)\n+\t\t\t\twantFrac := 0.0\n+\t\t\t\tgot, gotFrac, err := splitHelper(test.curr, test.size, 0.0, test.splits, test.frac, false)\n \t\t\t\tif test.err {\n \t\t\t\t\tif err == nil {\n \t\t\t\t\t\tt.Errorf(\"splitHelper should have errored, instead got: %v\", got)\n \t\t\t\t\t}\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"error in splitHelper: %v\", err)\n+\t\t\t\t} else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35be9ac181bba8099a7e4f9b3a4c3c1ed804ba35"}, "originalPosition": 93}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e29b4f06c3849be71467e905788b753de522e52", "author": {"user": {"login": "youngoli", "name": "Daniel Oliveira"}}, "url": "https://github.com/apache/beam/commit/5e29b4f06c3849be71467e905788b753de522e52", "committedDate": "2020-06-30T22:55:47Z", "message": "[BEAM-10312] Sub-element progress accounted for during splitting.\n\nAdding sub-element progress to the splitting logic in DataSource."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "35be9ac181bba8099a7e4f9b3a4c3c1ed804ba35", "author": {"user": {"login": "youngoli", "name": "Daniel Oliveira"}}, "url": "https://github.com/apache/beam/commit/35be9ac181bba8099a7e4f9b3a4c3c1ed804ba35", "committedDate": "2020-06-29T22:02:05Z", "message": "[BEAM-10312] Sub-element progress accounted for during splitting.\n\nAdding sub-element progress to the splitting logic in DataSource."}, "afterCommit": {"oid": "5e29b4f06c3849be71467e905788b753de522e52", "author": {"user": {"login": "youngoli", "name": "Daniel Oliveira"}}, "url": "https://github.com/apache/beam/commit/5e29b4f06c3849be71467e905788b753de522e52", "committedDate": "2020-06-30T22:55:47Z", "message": "[BEAM-10312] Sub-element progress accounted for during splitting.\n\nAdding sub-element progress to the splitting logic in DataSource."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3217, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}