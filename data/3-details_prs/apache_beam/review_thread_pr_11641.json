{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1MjgxMDk1", "number": 11641, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzoyODowN1rOD7hkDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzoyODowN1rOD7hkDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzQyNDc4OnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/AvroSource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzoyODowN1rOGT5i4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoyNjoyMVrOGVCSFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxODk0Nw==", "bodyText": "Nice, avoids the input stream wrapper.", "url": "https://github.com/apache/beam/pull/11641#discussion_r423518947", "createdAt": "2020-05-12T07:28:07Z", "author": {"login": "RyanSkraba"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/AvroSource.java", "diffHunk": "@@ -576,11 +619,16 @@ private static InputStream decodeAsInputStream(byte[] data, String codec) throws\n       Schema readerSchema =\n           internOrParseSchemaString(\n               MoreObjects.firstNonNull(mode.readerSchemaString, writerSchemaString));\n-      this.reader =\n-          (mode.type == GenericRecord.class)\n-              ? new GenericDatumReader<T>(writerSchema, readerSchema)\n-              : new ReflectDatumReader<T>(writerSchema, readerSchema);\n-      this.decoder = DecoderFactory.get().binaryDecoder(decodeAsInputStream(data, codec), null);\n+\n+      this.reader = mode.createReader(writerSchema, readerSchema);\n+\n+      if (codec.equals(DataFileConstants.NULL_CODEC)) {\n+        // Avro can read from a byte[] using a more efficient implementation.  If the input is not\n+        // compressed, pass the data in directly.\n+        this.decoder = DecoderFactory.get().binaryDecoder(data, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2ca19961dc3b4182dc18e3bc160342bdeff2a5a"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxMDY3OA==", "bodyText": "Neat!", "url": "https://github.com/apache/beam/pull/11641#discussion_r424710678", "createdAt": "2020-05-13T20:26:21Z", "author": {"login": "iemejia"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/AvroSource.java", "diffHunk": "@@ -576,11 +619,16 @@ private static InputStream decodeAsInputStream(byte[] data, String codec) throws\n       Schema readerSchema =\n           internOrParseSchemaString(\n               MoreObjects.firstNonNull(mode.readerSchemaString, writerSchemaString));\n-      this.reader =\n-          (mode.type == GenericRecord.class)\n-              ? new GenericDatumReader<T>(writerSchema, readerSchema)\n-              : new ReflectDatumReader<T>(writerSchema, readerSchema);\n-      this.decoder = DecoderFactory.get().binaryDecoder(decodeAsInputStream(data, codec), null);\n+\n+      this.reader = mode.createReader(writerSchema, readerSchema);\n+\n+      if (codec.equals(DataFileConstants.NULL_CODEC)) {\n+        // Avro can read from a byte[] using a more efficient implementation.  If the input is not\n+        // compressed, pass the data in directly.\n+        this.decoder = DecoderFactory.get().binaryDecoder(data, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxODk0Nw=="}, "originalCommit": {"oid": "d2ca19961dc3b4182dc18e3bc160342bdeff2a5a"}, "originalPosition": 181}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3882, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}