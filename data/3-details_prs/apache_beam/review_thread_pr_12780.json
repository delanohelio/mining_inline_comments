{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgxNTU1ODEw", "number": 12780, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxODo0MDo1MlrOEmuvSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxOToxOTo0NFrOEy9x0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDQ3MTEzOnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/DropFields.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxODo0MDo1MlrOHW7stQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMDoxMzoyOFrOHXTd7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwODgyMQ==", "bodyText": "Is this fixing a bug where field order isn't maintained? If so we should break it out into a separate PR", "url": "https://github.com/apache/beam/pull/12780#discussion_r493808821", "createdAt": "2020-09-23T18:40:52Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/DropFields.java", "diffHunk": "@@ -85,9 +85,8 @@ private Inner(FieldAccessDescriptor fieldsToDrop) {\n \n     FieldAccessDescriptor complement(Schema inputSchema, FieldAccessDescriptor input) {\n       // Create a FieldAccessDescriptor that select all fields _not_ selected in the input\n-      // descriptor. Maintain\n-      // the original order of the schema.\n-      Set<String> fieldNamesToSelect = Sets.newHashSet();\n+      // descriptor. Maintain the original order of the schema.\n+      List<String> fieldNamesToSelect = newArrayList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2933bf7ee4423e2ab4fd691884b6534801c162c"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwODk4Ng==", "bodyText": "And add a test", "url": "https://github.com/apache/beam/pull/12780#discussion_r493808986", "createdAt": "2020-09-23T18:41:06Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/DropFields.java", "diffHunk": "@@ -85,9 +85,8 @@ private Inner(FieldAccessDescriptor fieldsToDrop) {\n \n     FieldAccessDescriptor complement(Schema inputSchema, FieldAccessDescriptor input) {\n       // Create a FieldAccessDescriptor that select all fields _not_ selected in the input\n-      // descriptor. Maintain\n-      // the original order of the schema.\n-      Set<String> fieldNamesToSelect = Sets.newHashSet();\n+      // descriptor. Maintain the original order of the schema.\n+      List<String> fieldNamesToSelect = newArrayList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwODgyMQ=="}, "originalCommit": {"oid": "d2933bf7ee4423e2ab4fd691884b6534801c162c"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE5ODI1NQ==", "bodyText": "You're definitely right, I've done it here:  #12928", "url": "https://github.com/apache/beam/pull/12780#discussion_r494198255", "createdAt": "2020-09-24T10:13:28Z", "author": {"login": "piotr-szuberski"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/DropFields.java", "diffHunk": "@@ -85,9 +85,8 @@ private Inner(FieldAccessDescriptor fieldsToDrop) {\n \n     FieldAccessDescriptor complement(Schema inputSchema, FieldAccessDescriptor input) {\n       // Create a FieldAccessDescriptor that select all fields _not_ selected in the input\n-      // descriptor. Maintain\n-      // the original order of the schema.\n-      Set<String> fieldNamesToSelect = Sets.newHashSet();\n+      // descriptor. Maintain the original order of the schema.\n+      List<String> fieldNamesToSelect = newArrayList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwODgyMQ=="}, "originalCommit": {"oid": "d2933bf7ee4423e2ab4fd691884b6534801c162c"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDM3MTkxOnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubAvroIT.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMDo0NDo0MlrOHpQJMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODowMDo0OFrOHp29Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAxODE2MQ==", "bodyText": "These functions should directly verify the Avro data rather than converting to a Row if possible", "url": "https://github.com/apache/beam/pull/12780#discussion_r513018161", "createdAt": "2020-10-27T20:44:42Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubAvroIT.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.meta.provider.pubsub;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasProperty;\n+\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubMessage;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.utils.AvroUtils;\n+import org.apache.beam.sdk.transforms.MapElements;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.sdk.values.TypeDescriptors;\n+import org.hamcrest.Matcher;\n+import org.joda.time.Instant;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Integration tests for querying Pubsub AVRO messages with SQL. */\n+@RunWith(JUnit4.class)\n+public class PubsubAvroIT extends PubsubTableProviderIT {\n+  private static final Schema NAME_HEIGHT_KNOWS_JS_SCHEMA =\n+      Schema.builder()\n+          .addNullableField(\"name\", Schema.FieldType.STRING)\n+          .addNullableField(\"height\", Schema.FieldType.INT32)\n+          .addNullableField(\"knowsJavascript\", Schema.FieldType.BOOLEAN)\n+          .build();\n+\n+  private static final Schema NAME_HEIGHT_SCHEMA =\n+      Schema.builder()\n+          .addNullableField(\"name\", Schema.FieldType.STRING)\n+          .addNullableField(\"height\", Schema.FieldType.INT32)\n+          .build();\n+\n+  @Override\n+  protected String getPayloadFormat() {\n+    return \"avro\";\n+  }\n+\n+  @Override\n+  protected PCollection<String> applyRowsToStrings(PCollection<Row> rows) {\n+    return rows.apply(\n+        MapElements.into(TypeDescriptors.strings())\n+            .via(\n+                (Row row) ->\n+                    new String(\n+                        AvroUtils.getRowToAvroBytesFunction(row.getSchema()).apply(row), UTF_8)));\n+  }\n+\n+  @Override\n+  protected PubsubMessage messageIdName(Instant timestamp, int id, String name) {\n+    Row row = row(PAYLOAD_SCHEMA, id, name);\n+    return message(timestamp, AvroUtils.getRowToAvroBytesFunction(PAYLOAD_SCHEMA).apply(row));\n+  }\n+\n+  @Override\n+  protected Matcher<PubsubMessage> matcherNames(String name) {\n+    Schema schema = Schema.builder().addStringField(\"name\").build();\n+    Row row = row(schema, name);\n+    return hasProperty(\"payload\", equalTo(AvroUtils.getRowToAvroBytesFunction(schema).apply(row)));\n+  }\n+\n+  @Override\n+  protected Matcher<PubsubMessage> matcherNameHeight(String name, int height) {\n+    Row row = row(NAME_HEIGHT_SCHEMA, name, height);\n+    return hasProperty(\n+        \"payload\", equalTo(AvroUtils.getRowToAvroBytesFunction(NAME_HEIGHT_SCHEMA).apply(row)));\n+  }\n+\n+  @Override\n+  protected Matcher<PubsubMessage> matcherNameHeightKnowsJS(\n+      String name, int height, boolean knowsJS) {\n+    Row row = row(NAME_HEIGHT_KNOWS_JS_SCHEMA, name, height, knowsJS);\n+    return hasProperty(\n+        \"payload\",\n+        equalTo(AvroUtils.getRowToAvroBytesFunction(NAME_HEIGHT_KNOWS_JS_SCHEMA).apply(row)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66756ffc8ac9ff7b6496aff69c294dbc704ab346"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI4MTQyMg==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/12780#discussion_r513281422", "createdAt": "2020-10-28T09:07:36Z", "author": {"login": "piotr-szuberski"}, "path": "sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubAvroIT.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.meta.provider.pubsub;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasProperty;\n+\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubMessage;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.utils.AvroUtils;\n+import org.apache.beam.sdk.transforms.MapElements;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.sdk.values.TypeDescriptors;\n+import org.hamcrest.Matcher;\n+import org.joda.time.Instant;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Integration tests for querying Pubsub AVRO messages with SQL. */\n+@RunWith(JUnit4.class)\n+public class PubsubAvroIT extends PubsubTableProviderIT {\n+  private static final Schema NAME_HEIGHT_KNOWS_JS_SCHEMA =\n+      Schema.builder()\n+          .addNullableField(\"name\", Schema.FieldType.STRING)\n+          .addNullableField(\"height\", Schema.FieldType.INT32)\n+          .addNullableField(\"knowsJavascript\", Schema.FieldType.BOOLEAN)\n+          .build();\n+\n+  private static final Schema NAME_HEIGHT_SCHEMA =\n+      Schema.builder()\n+          .addNullableField(\"name\", Schema.FieldType.STRING)\n+          .addNullableField(\"height\", Schema.FieldType.INT32)\n+          .build();\n+\n+  @Override\n+  protected String getPayloadFormat() {\n+    return \"avro\";\n+  }\n+\n+  @Override\n+  protected PCollection<String> applyRowsToStrings(PCollection<Row> rows) {\n+    return rows.apply(\n+        MapElements.into(TypeDescriptors.strings())\n+            .via(\n+                (Row row) ->\n+                    new String(\n+                        AvroUtils.getRowToAvroBytesFunction(row.getSchema()).apply(row), UTF_8)));\n+  }\n+\n+  @Override\n+  protected PubsubMessage messageIdName(Instant timestamp, int id, String name) {\n+    Row row = row(PAYLOAD_SCHEMA, id, name);\n+    return message(timestamp, AvroUtils.getRowToAvroBytesFunction(PAYLOAD_SCHEMA).apply(row));\n+  }\n+\n+  @Override\n+  protected Matcher<PubsubMessage> matcherNames(String name) {\n+    Schema schema = Schema.builder().addStringField(\"name\").build();\n+    Row row = row(schema, name);\n+    return hasProperty(\"payload\", equalTo(AvroUtils.getRowToAvroBytesFunction(schema).apply(row)));\n+  }\n+\n+  @Override\n+  protected Matcher<PubsubMessage> matcherNameHeight(String name, int height) {\n+    Row row = row(NAME_HEIGHT_SCHEMA, name, height);\n+    return hasProperty(\n+        \"payload\", equalTo(AvroUtils.getRowToAvroBytesFunction(NAME_HEIGHT_SCHEMA).apply(row)));\n+  }\n+\n+  @Override\n+  protected Matcher<PubsubMessage> matcherNameHeightKnowsJS(\n+      String name, int height, boolean knowsJS) {\n+    Row row = row(NAME_HEIGHT_KNOWS_JS_SCHEMA, name, height, knowsJS);\n+    return hasProperty(\n+        \"payload\",\n+        equalTo(AvroUtils.getRowToAvroBytesFunction(NAME_HEIGHT_KNOWS_JS_SCHEMA).apply(row)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAxODE2MQ=="}, "originalCommit": {"oid": "66756ffc8ac9ff7b6496aff69c294dbc704ab346"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1NDAxOQ==", "bodyText": "We should do this for the other matcher* methods as well.", "url": "https://github.com/apache/beam/pull/12780#discussion_r513654019", "createdAt": "2020-10-28T18:00:48Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubAvroIT.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.meta.provider.pubsub;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasProperty;\n+\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubMessage;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.utils.AvroUtils;\n+import org.apache.beam.sdk.transforms.MapElements;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.sdk.values.TypeDescriptors;\n+import org.hamcrest.Matcher;\n+import org.joda.time.Instant;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Integration tests for querying Pubsub AVRO messages with SQL. */\n+@RunWith(JUnit4.class)\n+public class PubsubAvroIT extends PubsubTableProviderIT {\n+  private static final Schema NAME_HEIGHT_KNOWS_JS_SCHEMA =\n+      Schema.builder()\n+          .addNullableField(\"name\", Schema.FieldType.STRING)\n+          .addNullableField(\"height\", Schema.FieldType.INT32)\n+          .addNullableField(\"knowsJavascript\", Schema.FieldType.BOOLEAN)\n+          .build();\n+\n+  private static final Schema NAME_HEIGHT_SCHEMA =\n+      Schema.builder()\n+          .addNullableField(\"name\", Schema.FieldType.STRING)\n+          .addNullableField(\"height\", Schema.FieldType.INT32)\n+          .build();\n+\n+  @Override\n+  protected String getPayloadFormat() {\n+    return \"avro\";\n+  }\n+\n+  @Override\n+  protected PCollection<String> applyRowsToStrings(PCollection<Row> rows) {\n+    return rows.apply(\n+        MapElements.into(TypeDescriptors.strings())\n+            .via(\n+                (Row row) ->\n+                    new String(\n+                        AvroUtils.getRowToAvroBytesFunction(row.getSchema()).apply(row), UTF_8)));\n+  }\n+\n+  @Override\n+  protected PubsubMessage messageIdName(Instant timestamp, int id, String name) {\n+    Row row = row(PAYLOAD_SCHEMA, id, name);\n+    return message(timestamp, AvroUtils.getRowToAvroBytesFunction(PAYLOAD_SCHEMA).apply(row));\n+  }\n+\n+  @Override\n+  protected Matcher<PubsubMessage> matcherNames(String name) {\n+    Schema schema = Schema.builder().addStringField(\"name\").build();\n+    Row row = row(schema, name);\n+    return hasProperty(\"payload\", equalTo(AvroUtils.getRowToAvroBytesFunction(schema).apply(row)));\n+  }\n+\n+  @Override\n+  protected Matcher<PubsubMessage> matcherNameHeight(String name, int height) {\n+    Row row = row(NAME_HEIGHT_SCHEMA, name, height);\n+    return hasProperty(\n+        \"payload\", equalTo(AvroUtils.getRowToAvroBytesFunction(NAME_HEIGHT_SCHEMA).apply(row)));\n+  }\n+\n+  @Override\n+  protected Matcher<PubsubMessage> matcherNameHeightKnowsJS(\n+      String name, int height, boolean knowsJS) {\n+    Row row = row(NAME_HEIGHT_KNOWS_JS_SCHEMA, name, height, knowsJS);\n+    return hasProperty(\n+        \"payload\",\n+        equalTo(AvroUtils.getRowToAvroBytesFunction(NAME_HEIGHT_KNOWS_JS_SCHEMA).apply(row)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAxODE2MQ=="}, "originalCommit": {"oid": "66756ffc8ac9ff7b6496aff69c294dbc704ab346"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDM5MzMzOnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PayloadFormat.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMDo1MTowNVrOHpQWZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwNzo0NDo0OVrOHpdZJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAyMTU0Mw==", "bodyText": "Can this be an inner class of PubsubSchemaIOProvider?", "url": "https://github.com/apache/beam/pull/12780#discussion_r513021543", "createdAt": "2020-10-27T20:51:05Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PayloadFormat.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.pubsub;\n+\n+public enum PayloadFormat {\n+  JSON,\n+  AVRO\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66756ffc8ac9ff7b6496aff69c294dbc704ab346"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIzNTIzNg==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/12780#discussion_r513235236", "createdAt": "2020-10-28T07:44:49Z", "author": {"login": "piotr-szuberski"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PayloadFormat.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.pubsub;\n+\n+public enum PayloadFormat {\n+  JSON,\n+  AVRO\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAyMTU0Mw=="}, "originalCommit": {"oid": "66756ffc8ac9ff7b6496aff69c294dbc704ab346"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDQyNDg2OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubMessageToRow.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMDo1OTowM1rOHpQqLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwNzo0NDo0NFrOHpdZCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAyNjYwNQ==", "bodyText": "I think it would be preferable to define our own ParseException that parsePayload throws. Then parsePayload can catch these exceptions specific to the format that is being used, and throw it with the format-specific exception as the cause. That way the calls to parsePayload just need to check for ParseException", "url": "https://github.com/apache/beam/pull/12780#discussion_r513026605", "createdAt": "2020-10-27T20:59:03Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubMessageToRow.java", "diffHunk": "@@ -226,11 +260,11 @@ public void processElement(\n                             field, timestamp, element.getAttributeMap(), payload))\n                 .collect(toList());\n         o.get(MAIN_TAG).output(Row.withSchema(messageSchema).addValues(values).build());\n-      } catch (UnsupportedRowJsonException jsonException) {\n+      } catch (UnsupportedRowJsonException | AvroRuntimeException exception) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66756ffc8ac9ff7b6496aff69c294dbc704ab346"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIzNTIwOA==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/12780#discussion_r513235208", "createdAt": "2020-10-28T07:44:44Z", "author": {"login": "piotr-szuberski"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubMessageToRow.java", "diffHunk": "@@ -226,11 +260,11 @@ public void processElement(\n                             field, timestamp, element.getAttributeMap(), payload))\n                 .collect(toList());\n         o.get(MAIN_TAG).output(Row.withSchema(messageSchema).addValues(values).build());\n-      } catch (UnsupportedRowJsonException jsonException) {\n+      } catch (UnsupportedRowJsonException | AvroRuntimeException exception) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAyNjYwNQ=="}, "originalCommit": {"oid": "66756ffc8ac9ff7b6496aff69c294dbc704ab346"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODU1MDY1OnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubTableProviderIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODoyMToyNFrOHp3whQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwOToyODo1MlrOHqTPlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2NzIwNQ==", "bodyText": "I think it may be better to just get rid of this test. I added it as a stepping stone when I was adding support for writing JSON to PubSub (see #9880). But it's just adding unnecessary complexity to keep it around now, the write path is thoroughly tested end-to-end in the tests below this one.\nIf we get rid of this you won't need applyRowsToStrings", "url": "https://github.com/apache/beam/pull/12780#discussion_r513667205", "createdAt": "2020-10-28T18:21:24Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubTableProviderIT.java", "diffHunk": "@@ -0,0 +1,651 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.meta.provider.pubsub;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasEntry;\n+import static org.hamcrest.Matchers.hasProperty;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.Serializable;\n+import java.nio.charset.StandardCharsets;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.beam.sdk.extensions.gcp.options.GcpOptions;\n+import org.apache.beam.sdk.extensions.sql.SqlTransform;\n+import org.apache.beam.sdk.extensions.sql.impl.BeamSqlEnv;\n+import org.apache.beam.sdk.extensions.sql.impl.JdbcConnection;\n+import org.apache.beam.sdk.extensions.sql.impl.JdbcDriver;\n+import org.apache.beam.sdk.extensions.sql.impl.rel.BeamSqlRelUtils;\n+import org.apache.beam.sdk.extensions.sql.meta.provider.SchemaIOTableProviderWrapper;\n+import org.apache.beam.sdk.extensions.sql.meta.provider.TableProvider;\n+import org.apache.beam.sdk.extensions.sql.meta.store.InMemoryMetaStore;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubMessage;\n+import org.apache.beam.sdk.io.gcp.pubsub.TestPubsub;\n+import org.apache.beam.sdk.io.gcp.pubsub.TestPubsubSignal;\n+import org.apache.beam.sdk.options.PipelineOptions;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.SchemaCoder;\n+import org.apache.beam.sdk.testing.TestPipeline;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.util.common.ReflectHelpers;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.vendor.calcite.v1_20_0.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.calcite.v1_20_0.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.calcite.v1_20_0.com.google.common.collect.ImmutableSet;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.jdbc.CalciteConnection;\n+import org.hamcrest.Matcher;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public abstract class PubsubTableProviderIT implements Serializable {\n+\n+  protected static final Schema PAYLOAD_SCHEMA =\n+      Schema.builder()\n+          .addNullableField(\"id\", Schema.FieldType.INT32)\n+          .addNullableField(\"name\", Schema.FieldType.STRING)\n+          .build();\n+\n+  @Rule public transient TestPubsub eventsTopic = TestPubsub.create();\n+  @Rule public transient TestPubsub filteredEventsTopic = TestPubsub.create();\n+  @Rule public transient TestPubsub dlqTopic = TestPubsub.create();\n+  @Rule public transient TestPubsubSignal resultSignal = TestPubsubSignal.create();\n+  @Rule public transient TestPipeline pipeline = TestPipeline.create();\n+  @Rule public transient TestPipeline filterPipeline = TestPipeline.create();\n+  private final SchemaIOTableProviderWrapper tableProvider = new PubsubTableProvider();\n+  private final String payloadFormatParam =\n+      getPayloadFormat() == null ? \"\" : String.format(\"\\\"format\\\" : \\\"%s\\\", \", getPayloadFormat());\n+\n+  /**\n+   * HACK: we need an objectmapper to turn pipelineoptions back into a map. We need to use\n+   * ReflectHelpers to get the extra PipelineOptions.\n+   */\n+  protected static final ObjectMapper MAPPER =\n+      new ObjectMapper()\n+          .registerModules(ObjectMapper.findModules(ReflectHelpers.findClassLoader()));\n+\n+  @Test\n+  public void testSQLSelectsPayloadContent() throws Exception {\n+    String createTableString =\n+        String.format(\n+            \"CREATE EXTERNAL TABLE message (\\n\"\n+                + \"event_timestamp TIMESTAMP, \\n\"\n+                + \"attributes MAP<VARCHAR, VARCHAR>, \\n\"\n+                + \"payload ROW< \\n\"\n+                + \"             id INTEGER, \\n\"\n+                + \"             name VARCHAR \\n\"\n+                + \"           > \\n\"\n+                + \") \\n\"\n+                + \"TYPE '%s' \\n\"\n+                + \"LOCATION '%s' \\n\"\n+                + \"TBLPROPERTIES '{ \"\n+                + \"%s\"\n+                + \"\\\"timestampAttributeKey\\\" : \\\"ts\\\" }'\",\n+            tableProvider.getTableType(), eventsTopic.topicPath(), payloadFormatParam);\n+\n+    String queryString = \"SELECT message.payload.id, message.payload.name from message\";\n+\n+    // Prepare messages to send later\n+    List<PubsubMessage> messages =\n+        ImmutableList.of(\n+            messageIdName(ts(1), 3, \"foo\"),\n+            messageIdName(ts(2), 5, \"bar\"),\n+            messageIdName(ts(3), 7, \"baz\"));\n+\n+    // Initialize SQL environment and create the pubsub table\n+    BeamSqlEnv sqlEnv = BeamSqlEnv.inMemory(new PubsubTableProvider());\n+    sqlEnv.executeDdl(createTableString);\n+\n+    // Apply the PTransform to query the pubsub topic\n+    PCollection<Row> queryOutput = query(sqlEnv, pipeline, queryString);\n+\n+    // Observe the query results and send success signal after seeing the expected messages\n+    queryOutput.apply(\n+        \"waitForSuccess\",\n+        resultSignal.signalSuccessWhen(\n+            SchemaCoder.of(PAYLOAD_SCHEMA),\n+            observedRows ->\n+                observedRows.equals(\n+                    ImmutableSet.of(\n+                        row(PAYLOAD_SCHEMA, 3, \"foo\"),\n+                        row(PAYLOAD_SCHEMA, 5, \"bar\"),\n+                        row(PAYLOAD_SCHEMA, 7, \"baz\")))));\n+\n+    // Start the pipeline\n+    pipeline.run();\n+\n+    // Block until a subscription for this topic exists\n+    eventsTopic.assertSubscriptionEventuallyCreated(\n+        pipeline.getOptions().as(GcpOptions.class).getProject(), Duration.standardMinutes(5));\n+\n+    // Start publishing the messages when main pipeline is started and signaling topic is ready\n+    eventsTopic.publish(messages);\n+\n+    // Poll the signaling topic for success message\n+    resultSignal.waitForSuccess(Duration.standardMinutes(5));\n+  }\n+\n+  @Test\n+  public void testUsesDlq() throws Exception {\n+    String createTableString =\n+        String.format(\n+            \"CREATE EXTERNAL TABLE message (\\n\"\n+                + \"event_timestamp TIMESTAMP, \\n\"\n+                + \"attributes MAP<VARCHAR, VARCHAR>, \\n\"\n+                + \"payload ROW< \\n\"\n+                + \"             id INTEGER, \\n\"\n+                + \"             name VARCHAR \\n\"\n+                + \"           > \\n\"\n+                + \") \\n\"\n+                + \"TYPE '%s' \\n\"\n+                + \"LOCATION '%s' \\n\"\n+                + \"TBLPROPERTIES \"\n+                + \"    '{ \"\n+                + \"       %s\"\n+                + \"       \\\"timestampAttributeKey\\\" : \\\"ts\\\", \"\n+                + \"       \\\"deadLetterQueue\\\" : \\\"%s\\\"\"\n+                + \"     }'\",\n+            tableProvider.getTableType(),\n+            eventsTopic.topicPath(),\n+            payloadFormatParam,\n+            dlqTopic.topicPath());\n+\n+    String queryString = \"SELECT message.payload.id, message.payload.name from message\";\n+\n+    // Prepare messages to send later\n+    List<PubsubMessage> messages =\n+        ImmutableList.of(\n+            messageIdName(ts(1), 3, \"foo\"),\n+            messageIdName(ts(2), 5, \"bar\"),\n+            messageIdName(ts(3), 7, \"baz\"),\n+            messagePayload(ts(4), \"{ - }\"), // invalid message, will go to DLQ\n+            messagePayload(ts(5), \"{ + }\")); // invalid message, will go to DLQ\n+\n+    // Initialize SQL environment and create the pubsub table\n+    BeamSqlEnv sqlEnv = BeamSqlEnv.inMemory(new PubsubTableProvider());\n+    sqlEnv.executeDdl(createTableString);\n+\n+    // Apply the PTransform to query the pubsub topic\n+    PCollection<Row> queryOutput = query(sqlEnv, pipeline, queryString);\n+\n+    // Observe the query results and send success signal after seeing the expected messages\n+    queryOutput.apply(\n+        \"waitForSuccess\",\n+        resultSignal.signalSuccessWhen(\n+            SchemaCoder.of(PAYLOAD_SCHEMA),\n+            observedRows ->\n+                observedRows.equals(\n+                    ImmutableSet.of(\n+                        row(PAYLOAD_SCHEMA, 3, \"foo\"),\n+                        row(PAYLOAD_SCHEMA, 5, \"bar\"),\n+                        row(PAYLOAD_SCHEMA, 7, \"baz\")))));\n+\n+    // Start the pipeline\n+    pipeline.run();\n+\n+    // Block until a subscription for this topic exists\n+    eventsTopic.assertSubscriptionEventuallyCreated(\n+        pipeline.getOptions().as(GcpOptions.class).getProject(), Duration.standardMinutes(5));\n+\n+    // Start publishing the messages when main pipeline is started and signaling topics are ready\n+    eventsTopic.publish(messages);\n+\n+    // Poll the signaling topic for success message\n+    resultSignal.waitForSuccess(Duration.standardMinutes(4));\n+    dlqTopic\n+        .assertThatTopicEventuallyReceives(\n+            matcherPayload(ts(4), \"{ - }\"), matcherPayload(ts(5), \"{ + }\"))\n+        .waitForUpTo(Duration.standardSeconds(20));\n+  }\n+\n+  @Test\n+  public void testSQLLimit() throws Exception {\n+    String createTableString =\n+        String.format(\n+            \"CREATE EXTERNAL TABLE message (\\n\"\n+                + \"event_timestamp TIMESTAMP, \\n\"\n+                + \"attributes MAP<VARCHAR, VARCHAR>, \\n\"\n+                + \"payload ROW< \\n\"\n+                + \"             id INTEGER, \\n\"\n+                + \"             name VARCHAR \\n\"\n+                + \"           > \\n\"\n+                + \") \\n\"\n+                + \"TYPE '%s' \\n\"\n+                + \"LOCATION '%s' \\n\"\n+                + \"TBLPROPERTIES \"\n+                + \"    '{ \"\n+                + \"       %s\"\n+                + \"       \\\"timestampAttributeKey\\\" : \\\"ts\\\", \"\n+                + \"       \\\"deadLetterQueue\\\" : \\\"%s\\\"\"\n+                + \"     }'\",\n+            tableProvider.getTableType(),\n+            eventsTopic.topicPath(),\n+            payloadFormatParam,\n+            dlqTopic.topicPath());\n+\n+    List<PubsubMessage> messages =\n+        ImmutableList.of(\n+            messageIdName(ts(1), 3, \"foo\"),\n+            messageIdName(ts(2), 5, \"bar\"),\n+            messageIdName(ts(3), 7, \"baz\"),\n+            messageIdName(ts(4), 9, \"ba2\"),\n+            messageIdName(ts(5), 10, \"ba3\"),\n+            messageIdName(ts(6), 13, \"ba4\"),\n+            messageIdName(ts(7), 15, \"ba5\"));\n+\n+    // We need the default options on the schema to include the project passed in for the\n+    // integration test\n+    CalciteConnection connection = connect(pipeline.getOptions(), new PubsubTableProvider());\n+\n+    Statement statement = connection.createStatement();\n+    statement.execute(createTableString);\n+\n+    // Because Pubsub only allow new subscription receives message after the subscription is\n+    // created, eventsTopic.publish(messages) can only be called after statement.executeQuery.\n+    // However, because statement.executeQuery is a blocking call, it has to be put into a\n+    // seperate thread to execute.\n+    ExecutorService pool = Executors.newFixedThreadPool(1);\n+    Future<List<String>> queryResult =\n+        pool.submit(\n+            (Callable)\n+                () -> {\n+                  ResultSet resultSet =\n+                      statement.executeQuery(\"SELECT message.payload.id FROM message LIMIT 3\");\n+                  ImmutableList.Builder<String> result = ImmutableList.builder();\n+                  while (resultSet.next()) {\n+                    result.add(resultSet.getString(1));\n+                  }\n+                  return result.build();\n+                });\n+\n+    eventsTopic.assertSubscriptionEventuallyCreated(\n+        pipeline.getOptions().as(GcpOptions.class).getProject(), Duration.standardMinutes(5));\n+    eventsTopic.publish(messages);\n+    assertThat(queryResult.get(2, TimeUnit.MINUTES).size(), equalTo(3));\n+    pool.shutdown();\n+  }\n+\n+  @Test\n+  public void testWritesRowsToPubsub() throws Exception {\n+    Schema personSchema =\n+        Schema.builder()\n+            .addStringField(\"name\")\n+            .addInt32Field(\"height\")\n+            .addBooleanField(\"knowsJavascript\")\n+            .build();\n+    PCollection<Row> rows =\n+        pipeline\n+            .apply(\n+                Create.of(\n+                    row(personSchema, \"person1\", 80, true),\n+                    row(personSchema, \"person2\", 70, false),\n+                    row(personSchema, \"person3\", 60, true),\n+                    row(personSchema, \"person4\", 50, false),\n+                    row(personSchema, \"person5\", 40, true)))\n+            .setRowSchema(personSchema)\n+            .apply(\n+                SqlTransform.query(\n+                    \"SELECT name FROM PCOLLECTION AS person WHERE person.knowsJavascript\"));\n+    // Convert rows to proper format and write to pubsub\n+    PCollection<String> rowsStrings = applyRowsToStrings(rows);\n+    rowsStrings.apply(PubsubIO.writeStrings().to(eventsTopic.topicPath().getPath()));\n+\n+    pipeline.run().waitUntilFinish(Duration.standardMinutes(5));\n+\n+    eventsTopic\n+        .assertThatTopicEventuallyReceives(\n+            matcherNames(\"person1\"), matcherNames(\"person3\"), matcherNames(\"person5\"))\n+        .waitForUpTo(Duration.standardSeconds(20));\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c98716fc51fd662bfa1dc044d44f7063593d0efd"}, "originalPosition": 333}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDExNzUyNA==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/12780#discussion_r514117524", "createdAt": "2020-10-29T09:28:52Z", "author": {"login": "piotr-szuberski"}, "path": "sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubTableProviderIT.java", "diffHunk": "@@ -0,0 +1,651 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.meta.provider.pubsub;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasEntry;\n+import static org.hamcrest.Matchers.hasProperty;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.Serializable;\n+import java.nio.charset.StandardCharsets;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.beam.sdk.extensions.gcp.options.GcpOptions;\n+import org.apache.beam.sdk.extensions.sql.SqlTransform;\n+import org.apache.beam.sdk.extensions.sql.impl.BeamSqlEnv;\n+import org.apache.beam.sdk.extensions.sql.impl.JdbcConnection;\n+import org.apache.beam.sdk.extensions.sql.impl.JdbcDriver;\n+import org.apache.beam.sdk.extensions.sql.impl.rel.BeamSqlRelUtils;\n+import org.apache.beam.sdk.extensions.sql.meta.provider.SchemaIOTableProviderWrapper;\n+import org.apache.beam.sdk.extensions.sql.meta.provider.TableProvider;\n+import org.apache.beam.sdk.extensions.sql.meta.store.InMemoryMetaStore;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubMessage;\n+import org.apache.beam.sdk.io.gcp.pubsub.TestPubsub;\n+import org.apache.beam.sdk.io.gcp.pubsub.TestPubsubSignal;\n+import org.apache.beam.sdk.options.PipelineOptions;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.SchemaCoder;\n+import org.apache.beam.sdk.testing.TestPipeline;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.util.common.ReflectHelpers;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.vendor.calcite.v1_20_0.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.calcite.v1_20_0.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.calcite.v1_20_0.com.google.common.collect.ImmutableSet;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.jdbc.CalciteConnection;\n+import org.hamcrest.Matcher;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public abstract class PubsubTableProviderIT implements Serializable {\n+\n+  protected static final Schema PAYLOAD_SCHEMA =\n+      Schema.builder()\n+          .addNullableField(\"id\", Schema.FieldType.INT32)\n+          .addNullableField(\"name\", Schema.FieldType.STRING)\n+          .build();\n+\n+  @Rule public transient TestPubsub eventsTopic = TestPubsub.create();\n+  @Rule public transient TestPubsub filteredEventsTopic = TestPubsub.create();\n+  @Rule public transient TestPubsub dlqTopic = TestPubsub.create();\n+  @Rule public transient TestPubsubSignal resultSignal = TestPubsubSignal.create();\n+  @Rule public transient TestPipeline pipeline = TestPipeline.create();\n+  @Rule public transient TestPipeline filterPipeline = TestPipeline.create();\n+  private final SchemaIOTableProviderWrapper tableProvider = new PubsubTableProvider();\n+  private final String payloadFormatParam =\n+      getPayloadFormat() == null ? \"\" : String.format(\"\\\"format\\\" : \\\"%s\\\", \", getPayloadFormat());\n+\n+  /**\n+   * HACK: we need an objectmapper to turn pipelineoptions back into a map. We need to use\n+   * ReflectHelpers to get the extra PipelineOptions.\n+   */\n+  protected static final ObjectMapper MAPPER =\n+      new ObjectMapper()\n+          .registerModules(ObjectMapper.findModules(ReflectHelpers.findClassLoader()));\n+\n+  @Test\n+  public void testSQLSelectsPayloadContent() throws Exception {\n+    String createTableString =\n+        String.format(\n+            \"CREATE EXTERNAL TABLE message (\\n\"\n+                + \"event_timestamp TIMESTAMP, \\n\"\n+                + \"attributes MAP<VARCHAR, VARCHAR>, \\n\"\n+                + \"payload ROW< \\n\"\n+                + \"             id INTEGER, \\n\"\n+                + \"             name VARCHAR \\n\"\n+                + \"           > \\n\"\n+                + \") \\n\"\n+                + \"TYPE '%s' \\n\"\n+                + \"LOCATION '%s' \\n\"\n+                + \"TBLPROPERTIES '{ \"\n+                + \"%s\"\n+                + \"\\\"timestampAttributeKey\\\" : \\\"ts\\\" }'\",\n+            tableProvider.getTableType(), eventsTopic.topicPath(), payloadFormatParam);\n+\n+    String queryString = \"SELECT message.payload.id, message.payload.name from message\";\n+\n+    // Prepare messages to send later\n+    List<PubsubMessage> messages =\n+        ImmutableList.of(\n+            messageIdName(ts(1), 3, \"foo\"),\n+            messageIdName(ts(2), 5, \"bar\"),\n+            messageIdName(ts(3), 7, \"baz\"));\n+\n+    // Initialize SQL environment and create the pubsub table\n+    BeamSqlEnv sqlEnv = BeamSqlEnv.inMemory(new PubsubTableProvider());\n+    sqlEnv.executeDdl(createTableString);\n+\n+    // Apply the PTransform to query the pubsub topic\n+    PCollection<Row> queryOutput = query(sqlEnv, pipeline, queryString);\n+\n+    // Observe the query results and send success signal after seeing the expected messages\n+    queryOutput.apply(\n+        \"waitForSuccess\",\n+        resultSignal.signalSuccessWhen(\n+            SchemaCoder.of(PAYLOAD_SCHEMA),\n+            observedRows ->\n+                observedRows.equals(\n+                    ImmutableSet.of(\n+                        row(PAYLOAD_SCHEMA, 3, \"foo\"),\n+                        row(PAYLOAD_SCHEMA, 5, \"bar\"),\n+                        row(PAYLOAD_SCHEMA, 7, \"baz\")))));\n+\n+    // Start the pipeline\n+    pipeline.run();\n+\n+    // Block until a subscription for this topic exists\n+    eventsTopic.assertSubscriptionEventuallyCreated(\n+        pipeline.getOptions().as(GcpOptions.class).getProject(), Duration.standardMinutes(5));\n+\n+    // Start publishing the messages when main pipeline is started and signaling topic is ready\n+    eventsTopic.publish(messages);\n+\n+    // Poll the signaling topic for success message\n+    resultSignal.waitForSuccess(Duration.standardMinutes(5));\n+  }\n+\n+  @Test\n+  public void testUsesDlq() throws Exception {\n+    String createTableString =\n+        String.format(\n+            \"CREATE EXTERNAL TABLE message (\\n\"\n+                + \"event_timestamp TIMESTAMP, \\n\"\n+                + \"attributes MAP<VARCHAR, VARCHAR>, \\n\"\n+                + \"payload ROW< \\n\"\n+                + \"             id INTEGER, \\n\"\n+                + \"             name VARCHAR \\n\"\n+                + \"           > \\n\"\n+                + \") \\n\"\n+                + \"TYPE '%s' \\n\"\n+                + \"LOCATION '%s' \\n\"\n+                + \"TBLPROPERTIES \"\n+                + \"    '{ \"\n+                + \"       %s\"\n+                + \"       \\\"timestampAttributeKey\\\" : \\\"ts\\\", \"\n+                + \"       \\\"deadLetterQueue\\\" : \\\"%s\\\"\"\n+                + \"     }'\",\n+            tableProvider.getTableType(),\n+            eventsTopic.topicPath(),\n+            payloadFormatParam,\n+            dlqTopic.topicPath());\n+\n+    String queryString = \"SELECT message.payload.id, message.payload.name from message\";\n+\n+    // Prepare messages to send later\n+    List<PubsubMessage> messages =\n+        ImmutableList.of(\n+            messageIdName(ts(1), 3, \"foo\"),\n+            messageIdName(ts(2), 5, \"bar\"),\n+            messageIdName(ts(3), 7, \"baz\"),\n+            messagePayload(ts(4), \"{ - }\"), // invalid message, will go to DLQ\n+            messagePayload(ts(5), \"{ + }\")); // invalid message, will go to DLQ\n+\n+    // Initialize SQL environment and create the pubsub table\n+    BeamSqlEnv sqlEnv = BeamSqlEnv.inMemory(new PubsubTableProvider());\n+    sqlEnv.executeDdl(createTableString);\n+\n+    // Apply the PTransform to query the pubsub topic\n+    PCollection<Row> queryOutput = query(sqlEnv, pipeline, queryString);\n+\n+    // Observe the query results and send success signal after seeing the expected messages\n+    queryOutput.apply(\n+        \"waitForSuccess\",\n+        resultSignal.signalSuccessWhen(\n+            SchemaCoder.of(PAYLOAD_SCHEMA),\n+            observedRows ->\n+                observedRows.equals(\n+                    ImmutableSet.of(\n+                        row(PAYLOAD_SCHEMA, 3, \"foo\"),\n+                        row(PAYLOAD_SCHEMA, 5, \"bar\"),\n+                        row(PAYLOAD_SCHEMA, 7, \"baz\")))));\n+\n+    // Start the pipeline\n+    pipeline.run();\n+\n+    // Block until a subscription for this topic exists\n+    eventsTopic.assertSubscriptionEventuallyCreated(\n+        pipeline.getOptions().as(GcpOptions.class).getProject(), Duration.standardMinutes(5));\n+\n+    // Start publishing the messages when main pipeline is started and signaling topics are ready\n+    eventsTopic.publish(messages);\n+\n+    // Poll the signaling topic for success message\n+    resultSignal.waitForSuccess(Duration.standardMinutes(4));\n+    dlqTopic\n+        .assertThatTopicEventuallyReceives(\n+            matcherPayload(ts(4), \"{ - }\"), matcherPayload(ts(5), \"{ + }\"))\n+        .waitForUpTo(Duration.standardSeconds(20));\n+  }\n+\n+  @Test\n+  public void testSQLLimit() throws Exception {\n+    String createTableString =\n+        String.format(\n+            \"CREATE EXTERNAL TABLE message (\\n\"\n+                + \"event_timestamp TIMESTAMP, \\n\"\n+                + \"attributes MAP<VARCHAR, VARCHAR>, \\n\"\n+                + \"payload ROW< \\n\"\n+                + \"             id INTEGER, \\n\"\n+                + \"             name VARCHAR \\n\"\n+                + \"           > \\n\"\n+                + \") \\n\"\n+                + \"TYPE '%s' \\n\"\n+                + \"LOCATION '%s' \\n\"\n+                + \"TBLPROPERTIES \"\n+                + \"    '{ \"\n+                + \"       %s\"\n+                + \"       \\\"timestampAttributeKey\\\" : \\\"ts\\\", \"\n+                + \"       \\\"deadLetterQueue\\\" : \\\"%s\\\"\"\n+                + \"     }'\",\n+            tableProvider.getTableType(),\n+            eventsTopic.topicPath(),\n+            payloadFormatParam,\n+            dlqTopic.topicPath());\n+\n+    List<PubsubMessage> messages =\n+        ImmutableList.of(\n+            messageIdName(ts(1), 3, \"foo\"),\n+            messageIdName(ts(2), 5, \"bar\"),\n+            messageIdName(ts(3), 7, \"baz\"),\n+            messageIdName(ts(4), 9, \"ba2\"),\n+            messageIdName(ts(5), 10, \"ba3\"),\n+            messageIdName(ts(6), 13, \"ba4\"),\n+            messageIdName(ts(7), 15, \"ba5\"));\n+\n+    // We need the default options on the schema to include the project passed in for the\n+    // integration test\n+    CalciteConnection connection = connect(pipeline.getOptions(), new PubsubTableProvider());\n+\n+    Statement statement = connection.createStatement();\n+    statement.execute(createTableString);\n+\n+    // Because Pubsub only allow new subscription receives message after the subscription is\n+    // created, eventsTopic.publish(messages) can only be called after statement.executeQuery.\n+    // However, because statement.executeQuery is a blocking call, it has to be put into a\n+    // seperate thread to execute.\n+    ExecutorService pool = Executors.newFixedThreadPool(1);\n+    Future<List<String>> queryResult =\n+        pool.submit(\n+            (Callable)\n+                () -> {\n+                  ResultSet resultSet =\n+                      statement.executeQuery(\"SELECT message.payload.id FROM message LIMIT 3\");\n+                  ImmutableList.Builder<String> result = ImmutableList.builder();\n+                  while (resultSet.next()) {\n+                    result.add(resultSet.getString(1));\n+                  }\n+                  return result.build();\n+                });\n+\n+    eventsTopic.assertSubscriptionEventuallyCreated(\n+        pipeline.getOptions().as(GcpOptions.class).getProject(), Duration.standardMinutes(5));\n+    eventsTopic.publish(messages);\n+    assertThat(queryResult.get(2, TimeUnit.MINUTES).size(), equalTo(3));\n+    pool.shutdown();\n+  }\n+\n+  @Test\n+  public void testWritesRowsToPubsub() throws Exception {\n+    Schema personSchema =\n+        Schema.builder()\n+            .addStringField(\"name\")\n+            .addInt32Field(\"height\")\n+            .addBooleanField(\"knowsJavascript\")\n+            .build();\n+    PCollection<Row> rows =\n+        pipeline\n+            .apply(\n+                Create.of(\n+                    row(personSchema, \"person1\", 80, true),\n+                    row(personSchema, \"person2\", 70, false),\n+                    row(personSchema, \"person3\", 60, true),\n+                    row(personSchema, \"person4\", 50, false),\n+                    row(personSchema, \"person5\", 40, true)))\n+            .setRowSchema(personSchema)\n+            .apply(\n+                SqlTransform.query(\n+                    \"SELECT name FROM PCOLLECTION AS person WHERE person.knowsJavascript\"));\n+    // Convert rows to proper format and write to pubsub\n+    PCollection<String> rowsStrings = applyRowsToStrings(rows);\n+    rowsStrings.apply(PubsubIO.writeStrings().to(eventsTopic.topicPath().getPath()));\n+\n+    pipeline.run().waitUntilFinish(Duration.standardMinutes(5));\n+\n+    eventsTopic\n+        .assertThatTopicEventuallyReceives(\n+            matcherNames(\"person1\"), matcherNames(\"person3\"), matcherNames(\"person5\"))\n+        .waitForUpTo(Duration.standardSeconds(20));\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2NzIwNQ=="}, "originalCommit": {"oid": "c98716fc51fd662bfa1dc044d44f7063593d0efd"}, "originalPosition": 333}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODU2MDI2OnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubAvroIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODoyMzo1NVrOHp32kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwODo1MTo0MFrOHqR0jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2ODc1Mg==", "bodyText": "messageIdName, matcherNames, and matcherNameHeight should avoid using AvroUtils.getRowToAvroBytesFunction as well.", "url": "https://github.com/apache/beam/pull/12780#discussion_r513668752", "createdAt": "2020-10-28T18:23:55Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubAvroIT.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.meta.provider.pubsub;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasProperty;\n+\n+import java.io.ByteArrayOutputStream;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.generic.GenericRecordBuilder;\n+import org.apache.beam.sdk.coders.AvroCoder;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubMessage;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.utils.AvroUtils;\n+import org.apache.beam.sdk.transforms.MapElements;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.sdk.values.TypeDescriptors;\n+import org.hamcrest.Matcher;\n+import org.joda.time.Instant;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Integration tests for querying Pubsub AVRO messages with SQL. */\n+@RunWith(JUnit4.class)\n+public class PubsubAvroIT extends PubsubTableProviderIT {\n+  private static final Schema NAME_HEIGHT_KNOWS_JS_SCHEMA =\n+      Schema.builder()\n+          .addNullableField(\"name\", Schema.FieldType.STRING)\n+          .addNullableField(\"height\", Schema.FieldType.INT32)\n+          .addNullableField(\"knowsJavascript\", Schema.FieldType.BOOLEAN)\n+          .build();\n+\n+  private static final Schema NAME_HEIGHT_SCHEMA =\n+      Schema.builder()\n+          .addNullableField(\"name\", Schema.FieldType.STRING)\n+          .addNullableField(\"height\", Schema.FieldType.INT32)\n+          .build();\n+\n+  @Override\n+  protected String getPayloadFormat() {\n+    return \"avro\";\n+  }\n+\n+  @Override\n+  protected PCollection<String> applyRowsToStrings(PCollection<Row> rows) {\n+    return rows.apply(\n+        MapElements.into(TypeDescriptors.strings())\n+            .via(\n+                (Row row) ->\n+                    new String(\n+                        AvroUtils.getRowToAvroBytesFunction(row.getSchema()).apply(row), UTF_8)));\n+  }\n+\n+  @Override\n+  protected PubsubMessage messageIdName(Instant timestamp, int id, String name) {\n+    Row row = row(PAYLOAD_SCHEMA, id, name);\n+    return message(timestamp, AvroUtils.getRowToAvroBytesFunction(PAYLOAD_SCHEMA).apply(row));\n+  }\n+\n+  @Override\n+  protected Matcher<PubsubMessage> matcherNames(String name) {\n+    Schema schema = Schema.builder().addStringField(\"name\").build();\n+    Row row = row(schema, name);\n+    return hasProperty(\"payload\", equalTo(AvroUtils.getRowToAvroBytesFunction(schema).apply(row)));\n+  }\n+\n+  @Override\n+  protected Matcher<PubsubMessage> matcherNameHeight(String name, int height) {\n+    Row row = row(NAME_HEIGHT_SCHEMA, name, height);\n+    return hasProperty(\n+        \"payload\", equalTo(AvroUtils.getRowToAvroBytesFunction(NAME_HEIGHT_SCHEMA).apply(row)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c98716fc51fd662bfa1dc044d44f7063593d0efd"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA5NDIyMw==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/12780#discussion_r514094223", "createdAt": "2020-10-29T08:51:40Z", "author": {"login": "piotr-szuberski"}, "path": "sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubAvroIT.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.meta.provider.pubsub;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasProperty;\n+\n+import java.io.ByteArrayOutputStream;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.generic.GenericRecordBuilder;\n+import org.apache.beam.sdk.coders.AvroCoder;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubMessage;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.utils.AvroUtils;\n+import org.apache.beam.sdk.transforms.MapElements;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.sdk.values.TypeDescriptors;\n+import org.hamcrest.Matcher;\n+import org.joda.time.Instant;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Integration tests for querying Pubsub AVRO messages with SQL. */\n+@RunWith(JUnit4.class)\n+public class PubsubAvroIT extends PubsubTableProviderIT {\n+  private static final Schema NAME_HEIGHT_KNOWS_JS_SCHEMA =\n+      Schema.builder()\n+          .addNullableField(\"name\", Schema.FieldType.STRING)\n+          .addNullableField(\"height\", Schema.FieldType.INT32)\n+          .addNullableField(\"knowsJavascript\", Schema.FieldType.BOOLEAN)\n+          .build();\n+\n+  private static final Schema NAME_HEIGHT_SCHEMA =\n+      Schema.builder()\n+          .addNullableField(\"name\", Schema.FieldType.STRING)\n+          .addNullableField(\"height\", Schema.FieldType.INT32)\n+          .build();\n+\n+  @Override\n+  protected String getPayloadFormat() {\n+    return \"avro\";\n+  }\n+\n+  @Override\n+  protected PCollection<String> applyRowsToStrings(PCollection<Row> rows) {\n+    return rows.apply(\n+        MapElements.into(TypeDescriptors.strings())\n+            .via(\n+                (Row row) ->\n+                    new String(\n+                        AvroUtils.getRowToAvroBytesFunction(row.getSchema()).apply(row), UTF_8)));\n+  }\n+\n+  @Override\n+  protected PubsubMessage messageIdName(Instant timestamp, int id, String name) {\n+    Row row = row(PAYLOAD_SCHEMA, id, name);\n+    return message(timestamp, AvroUtils.getRowToAvroBytesFunction(PAYLOAD_SCHEMA).apply(row));\n+  }\n+\n+  @Override\n+  protected Matcher<PubsubMessage> matcherNames(String name) {\n+    Schema schema = Schema.builder().addStringField(\"name\").build();\n+    Row row = row(schema, name);\n+    return hasProperty(\"payload\", equalTo(AvroUtils.getRowToAvroBytesFunction(schema).apply(row)));\n+  }\n+\n+  @Override\n+  protected Matcher<PubsubMessage> matcherNameHeight(String name, int height) {\n+    Row row = row(NAME_HEIGHT_SCHEMA, name, height);\n+    return hasProperty(\n+        \"payload\", equalTo(AvroUtils.getRowToAvroBytesFunction(NAME_HEIGHT_SCHEMA).apply(row)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2ODc1Mg=="}, "originalCommit": {"oid": "c98716fc51fd662bfa1dc044d44f7063593d0efd"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODY1Mzk1OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubMessageToRow.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODo0OTowOFrOHp4xlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwODoxMDoxN1rOHqQYvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY4Mzg2MQ==", "bodyText": "Instead of eagerly generating the avroBytesToRowFn (even if we won't need it) and then branching on the payloadFormat for every element  in parsePayload, we should instead generate a parsePayload function when it's needed. This could work similarly to what the current version does withobjectMapper, except we would create and store a Function<PubsubMessage, Row>. In the JSON case we'd generate the ObjectMapper and wrap that in a function, and in the Avro case we'd call getAvroBytesToRowFunction and wrap it.", "url": "https://github.com/apache/beam/pull/12780#discussion_r513683861", "createdAt": "2020-10-28T18:49:08Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubMessageToRow.java", "diffHunk": "@@ -175,11 +213,21 @@ public void processElement(\n \n     private final boolean useDlq;\n \n+    private final PayloadFormat payloadFormat;\n+\n     private transient volatile @Nullable ObjectMapper objectMapper;\n \n-    protected NestedSchemaPubsubMessageToRow(Schema messageSchema, boolean useDlq) {\n+    private final SimpleFunction<byte[], Row> avroBytesToRowFn;\n+\n+    private final Schema payloadSchema;\n+\n+    protected NestedSchemaPubsubMessageToRow(\n+        Schema messageSchema, boolean useDlq, PayloadFormat payloadFormat) {\n       this.messageSchema = messageSchema;\n       this.useDlq = useDlq;\n+      this.payloadFormat = payloadFormat;\n+      this.payloadSchema = messageSchema.getField(PAYLOAD_FIELD).getType().getRowSchema();\n+      this.avroBytesToRowFn = AvroUtils.getAvroBytesToRowFunction(payloadSchema);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c98716fc51fd662bfa1dc044d44f7063593d0efd"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA3MDcxNw==", "bodyText": "Done. Indeed it's much clearer now!", "url": "https://github.com/apache/beam/pull/12780#discussion_r514070717", "createdAt": "2020-10-29T08:10:17Z", "author": {"login": "piotr-szuberski"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubMessageToRow.java", "diffHunk": "@@ -175,11 +213,21 @@ public void processElement(\n \n     private final boolean useDlq;\n \n+    private final PayloadFormat payloadFormat;\n+\n     private transient volatile @Nullable ObjectMapper objectMapper;\n \n-    protected NestedSchemaPubsubMessageToRow(Schema messageSchema, boolean useDlq) {\n+    private final SimpleFunction<byte[], Row> avroBytesToRowFn;\n+\n+    private final Schema payloadSchema;\n+\n+    protected NestedSchemaPubsubMessageToRow(\n+        Schema messageSchema, boolean useDlq, PayloadFormat payloadFormat) {\n       this.messageSchema = messageSchema;\n       this.useDlq = useDlq;\n+      this.payloadFormat = payloadFormat;\n+      this.payloadSchema = messageSchema.getField(PAYLOAD_FIELD).getType().getRowSchema();\n+      this.avroBytesToRowFn = AvroUtils.getAvroBytesToRowFunction(payloadSchema);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY4Mzg2MQ=="}, "originalCommit": {"oid": "c98716fc51fd662bfa1dc044d44f7063593d0efd"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODc1MzY2OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/RowToPubsubMessage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxOToxNjo1MVrOHp5v_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwODowOTo1NlrOHqQYEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY5OTgzNw==", "bodyText": "I'm not sure why I opted to get ISO_8859_1 encoded bytes here... Could you change this to use UTF_8?", "url": "https://github.com/apache/beam/pull/12780#discussion_r513699837", "createdAt": "2020-10-28T19:16:51Z", "author": {"login": "TheNeuralBit"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/RowToPubsubMessage.java", "diffHunk": "@@ -57,14 +73,43 @@ public static RowToPubsubMessage withTimestampAttribute(boolean useTimestampAttr\n             ? input.apply(WithTimestamps.of((row) -> row.getDateTime(TIMESTAMP_FIELD).toInstant()))\n             : input;\n \n-    return withTimestamp\n-        .apply(DropFields.fields(TIMESTAMP_FIELD))\n-        .apply(ToJson.of())\n-        .apply(\n-            MapElements.into(TypeDescriptor.of(PubsubMessage.class))\n-                .via(\n-                    (String json) ->\n-                        new PubsubMessage(\n-                            json.getBytes(StandardCharsets.ISO_8859_1), ImmutableMap.of())));\n+    withTimestamp = withTimestamp.apply(DropFields.fields(TIMESTAMP_FIELD));\n+    switch (payloadFormat) {\n+      case JSON:\n+        return withTimestamp\n+            .apply(\"MapRowToJsonString\", ToJson.of())\n+            .apply(\"MapToJsonBytes\", MapElements.via(new StringToBytes()))\n+            .apply(\"MapToPubsubMessage\", MapElements.via(new ToPubsubMessage()));\n+      case AVRO:\n+        return withTimestamp\n+            .apply(\n+                \"MapRowToAvroBytes\",\n+                MapElements.via(AvroUtils.getRowToAvroBytesFunction(payloadSchema)))\n+            .apply(\"MapToPubsubMessage\", MapElements.via(new ToPubsubMessage()));\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported payload format: \" + payloadFormat);\n+    }\n+  }\n+\n+  private static class StringToBytes extends SimpleFunction<String, byte[]> {\n+    @Override\n+    public byte[] apply(String s) {\n+      return s.getBytes(ISO_8859_1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c98716fc51fd662bfa1dc044d44f7063593d0efd"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA3MDU0Nw==", "bodyText": "Sure! Done.", "url": "https://github.com/apache/beam/pull/12780#discussion_r514070547", "createdAt": "2020-10-29T08:09:56Z", "author": {"login": "piotr-szuberski"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/RowToPubsubMessage.java", "diffHunk": "@@ -57,14 +73,43 @@ public static RowToPubsubMessage withTimestampAttribute(boolean useTimestampAttr\n             ? input.apply(WithTimestamps.of((row) -> row.getDateTime(TIMESTAMP_FIELD).toInstant()))\n             : input;\n \n-    return withTimestamp\n-        .apply(DropFields.fields(TIMESTAMP_FIELD))\n-        .apply(ToJson.of())\n-        .apply(\n-            MapElements.into(TypeDescriptor.of(PubsubMessage.class))\n-                .via(\n-                    (String json) ->\n-                        new PubsubMessage(\n-                            json.getBytes(StandardCharsets.ISO_8859_1), ImmutableMap.of())));\n+    withTimestamp = withTimestamp.apply(DropFields.fields(TIMESTAMP_FIELD));\n+    switch (payloadFormat) {\n+      case JSON:\n+        return withTimestamp\n+            .apply(\"MapRowToJsonString\", ToJson.of())\n+            .apply(\"MapToJsonBytes\", MapElements.via(new StringToBytes()))\n+            .apply(\"MapToPubsubMessage\", MapElements.via(new ToPubsubMessage()));\n+      case AVRO:\n+        return withTimestamp\n+            .apply(\n+                \"MapRowToAvroBytes\",\n+                MapElements.via(AvroUtils.getRowToAvroBytesFunction(payloadSchema)))\n+            .apply(\"MapToPubsubMessage\", MapElements.via(new ToPubsubMessage()));\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported payload format: \" + payloadFormat);\n+    }\n+  }\n+\n+  private static class StringToBytes extends SimpleFunction<String, byte[]> {\n+    @Override\n+    public byte[] apply(String s) {\n+      return s.getBytes(ISO_8859_1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY5OTgzNw=="}, "originalCommit": {"oid": "c98716fc51fd662bfa1dc044d44f7063593d0efd"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODc2NDM0OnYy", "diffSide": "RIGHT", "path": "website/www/site/content/en/documentation/dsls/sql/extensions/create-external-table.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxOToxOTo0NFrOHp52SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxOToxOTo0NFrOHp52SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwMTQ0OA==", "bodyText": "\ud83d\udc4d thanks", "url": "https://github.com/apache/beam/pull/12780#discussion_r513701448", "createdAt": "2020-10-28T19:19:44Z", "author": {"login": "TheNeuralBit"}, "path": "website/www/site/content/en/documentation/dsls/sql/extensions/create-external-table.md", "diffHunk": "@@ -251,6 +253,8 @@ TBLPROPERTIES '{\"timestampAttributeKey\": \"key\", \"deadLetterQueue\": \"projects/[PR\n     *   `deadLetterQueue`: The topic into which messages are written if the\n         payload was not parsed. If not specified, an exception is thrown for\n         parsing failures.\n+    *   `format`: Optional. Allows you to specify the Pubsub payload format.\n+        Possible values are {`json`, `avro`}. Defaults to `json`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c98716fc51fd662bfa1dc044d44f7063593d0efd"}, "originalPosition": 43}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 469, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}