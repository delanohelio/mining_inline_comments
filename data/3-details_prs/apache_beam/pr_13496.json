{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMzODg2OTA3", "number": 13496, "title": "[BEAM-11408] Integrate BigQuery sink streaming inserts with GroupIntoBatches", "bodyText": "Use GroupIntoBatches.WithShardedKey API to group and batch write before streaming to BigQuery service. Currently batching is done best-effort on bundle finalization.\nThis PR\n\nadds an option to BigQueryOptions to toggle between the existing and new implementation;\nextracts the shared code between the old and new implementation to a class BatchedStreamingWrite and provides an option to choose the implementation.\n\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nDataflow\nFlink\nSamza\nSpark\nTwister2\n\n\n\n\nGo\n\n---\n\n---\n\n---\n\n\nJava\n\n\n\n\n\n\n\n\nPython\n\n\n\n---\n\n---\n\n\nXLang\n\n\n\n---\n\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\nWhitespace\nTypescript\n\n\n\n\nNon-portable\n\n \n\n\n\n\n\n\nPortable\n---\n\n---\n---\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.\nGitHub Actions Tests Status (on master branch)\n\n\n\nSee CI.md for more information about GitHub Actions CI.", "createdAt": "2020-12-07T19:11:26Z", "url": "https://github.com/apache/beam/pull/13496", "merged": true, "mergeCommit": {"oid": "f0a3f6da1a967285379d0ca8ea2fb80013d8a888"}, "closed": true, "closedAt": "2021-01-28T03:18:33Z", "author": {"login": "nehsyc"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdj8INFgBqjQwODE2Nzk3NTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABd0Z5G3AH2gAyNTMzODg2OTA3OjFiOTdlN2M5MGE5MmY2NWRmOWZhYmE1ZTUzMTcyNmRkYzEyOGM1NWE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "468b4b72ccdce3cca2a8db16eab21b365f92f71e", "author": {"user": {"login": "nehsyc", "name": "Siyuan Chen"}}, "url": "https://github.com/apache/beam/commit/468b4b72ccdce3cca2a8db16eab21b365f92f71e", "committedDate": "2020-12-07T19:11:00Z", "message": "Integrate BQ streaming inserts with GroupIntoBatches"}, "afterCommit": {"oid": "d187951af8fc016fc8e2adf2d10054d94bfe9b63", "author": {"user": {"login": "nehsyc", "name": "Siyuan Chen"}}, "url": "https://github.com/apache/beam/commit/d187951af8fc016fc8e2adf2d10054d94bfe9b63", "committedDate": "2020-12-07T21:07:35Z", "message": "Integrate BQ streaming inserts with GroupIntoBatches"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NTY3ODAy", "url": "https://github.com/apache/beam/pull/13496#pullrequestreview-546567802", "createdAt": "2020-12-07T21:53:12Z", "commit": {"oid": "d187951af8fc016fc8e2adf2d10054d94bfe9b63"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMTo1MzoxMlrOIA8ZCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMTo1MzoxMlrOIA8ZCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg2MDM2Mg==", "bodyText": "Didn't add a global window around here as the existing implementation:\n\n  \n    \n      beam/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/StreamingWriteTables.java\n    \n    \n         Line 281\n      in\n      2462fe9\n    \n    \n    \n    \n\n        \n          \n           \"GlobalWindow\", \n        \n    \n  \n\n\nAccording to the documentation the global window is for correct access to side inputs but it seems to me that up to this point the dynamic destination has been read. @reuvenlax I might be missing something but let me know if I should keep the global window (and if so where?).", "url": "https://github.com/apache/beam/pull/13496#discussion_r537860362", "createdAt": "2020-12-07T21:53:12Z", "author": {"login": "nehsyc"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.standardSeconds(10);\n+\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      BigQueryOptions options = input.getPipeline().getOptions().as(BigQueryOptions.class);\n+      KvCoder<String, TableRowInfo<ElementT>> inputCoder = (KvCoder) input.getCoder();\n+      TableRowInfoCoder<ElementT> valueCoder =\n+          (TableRowInfoCoder) inputCoder.getCoderArguments().get(1);\n+      PCollectionTuple result =\n+          input", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d187951af8fc016fc8e2adf2d10054d94bfe9b63"}, "originalPosition": 286}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d187951af8fc016fc8e2adf2d10054d94bfe9b63", "author": {"user": {"login": "nehsyc", "name": "Siyuan Chen"}}, "url": "https://github.com/apache/beam/commit/d187951af8fc016fc8e2adf2d10054d94bfe9b63", "committedDate": "2020-12-07T21:07:35Z", "message": "Integrate BQ streaming inserts with GroupIntoBatches"}, "afterCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5", "author": {"user": {"login": "nehsyc", "name": "Siyuan Chen"}}, "url": "https://github.com/apache/beam/commit/3b0992c68a0e639bc10d59e83f17739d83bcbbb5", "committedDate": "2020-12-28T18:57:27Z", "message": "Integrate BQ streaming inserts with GroupIntoBatches"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MjY0OTY1", "url": "https://github.com/apache/beam/pull/13496#pullrequestreview-559264965", "createdAt": "2020-12-28T18:58:58Z", "commit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxODo1ODo1OFrOIL__dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxODo1ODo1OFrOIL__dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1MzY4Nw==", "bodyText": "Not sure about this limit. What would be a proper value? Should we make it configurable?", "url": "https://github.com/apache/beam/pull/13496#discussion_r549453687", "createdAt": "2020-12-28T18:58:58Z", "author": {"login": "nehsyc"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.millis(200);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 277}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NjAxMjk1", "url": "https://github.com/apache/beam/pull/13496#pullrequestreview-546601295", "createdAt": "2020-12-07T22:44:08Z", "commit": {"oid": "d187951af8fc016fc8e2adf2d10054d94bfe9b63"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMjo0NDowOVrOIA-NIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNzoxNToyMlrOIO0Phw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5MDA4Mw==", "bodyText": "I would make this specified in the BigQueryIO builder instead.", "url": "https://github.com/apache/beam/pull/13496#discussion_r537890083", "createdAt": "2020-12-07T22:44:09Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/StreamingWriteTables.java", "diffHunk": "@@ -243,61 +243,108 @@ public WriteResult expand(PCollection<KV<TableDestination, ElementT>> input) {\n       AtomicCoder<T> coder,\n       ErrorContainer<T> errorContainer) {\n     BigQueryOptions options = input.getPipeline().getOptions().as(BigQueryOptions.class);\n-    int numShards = options.getNumStreamingKeys();\n \n     // A naive implementation would be to simply stream data directly to BigQuery.\n     // However, this could occasionally lead to duplicated data, e.g., when\n     // a VM that runs this code is restarted and the code is re-run.\n \n     // The above risk is mitigated in this implementation by relying on\n     // BigQuery built-in best effort de-dup mechanism.\n-\n     // To use this mechanism, each input TableRow is tagged with a generated\n-    // unique id, which is then passed to BigQuery and used to ignore duplicates\n-    // We create 50 keys per BigQuery table to generate output on. This is few enough that we\n-    // get good batching into BigQuery's insert calls, and enough that we can max out the\n-    // streaming insert quota.\n-    PCollection<KV<ShardedKey<String>, TableRowInfo<ElementT>>> tagged =\n-        input\n-            .apply(\"ShardTableWrites\", ParDo.of(new GenerateShardedTable<>(numShards)))\n-            .setCoder(KvCoder.of(ShardedKeyCoder.of(StringUtf8Coder.of()), elementCoder))\n-            .apply(\"TagWithUniqueIds\", ParDo.of(new TagWithUniqueIds<>()))\n-            .setCoder(\n-                KvCoder.of(\n-                    ShardedKeyCoder.of(StringUtf8Coder.of()), TableRowInfoCoder.of(elementCoder)));\n-\n-    TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+    // unique id, which is then passed to BigQuery and used to ignore duplicates.\n \n     // To prevent having the same TableRow processed more than once with regenerated\n     // different unique ids, this implementation relies on \"checkpointing\", which is\n-    // achieved as a side effect of having StreamingWriteFn immediately follow a GBK,\n-    // performed by Reshuffle.\n-    PCollectionTuple tuple =\n-        tagged\n-            .apply(Reshuffle.of())\n-            // Put in the global window to ensure that DynamicDestinations side inputs are accessed\n-            // correctly.\n-            .apply(\n-                \"GlobalWindow\",\n-                Window.<KV<ShardedKey<String>, TableRowInfo<ElementT>>>into(new GlobalWindows())\n-                    .triggering(DefaultTrigger.of())\n-                    .discardingFiredPanes())\n-            .apply(\n-                \"StreamingWrite\",\n-                ParDo.of(\n-                        new StreamingWriteFn<>(\n-                            bigQueryServices,\n-                            retryPolicy,\n-                            failedInsertsTag,\n-                            errorContainer,\n-                            skipInvalidRows,\n-                            ignoreUnknownValues,\n-                            ignoreInsertIds,\n-                            toTableRow,\n-                            toFailsafeTableRow))\n-                    .withOutputTags(mainOutputTag, TupleTagList.of(failedInsertsTag)));\n-    PCollection<T> failedInserts = tuple.get(failedInsertsTag);\n-    failedInserts.setCoder(coder);\n-    return failedInserts;\n+    // achieved as a side effect of having BigQuery insertion immediately follow a GBK.\n+\n+    if (options.getEnableStreamingAutoSharding()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d187951af8fc016fc8e2adf2d10054d94bfe9b63"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM3NzM0MA==", "bodyText": "I think this should be an option on BigQueryIO.", "url": "https://github.com/apache/beam/pull/13496#discussion_r552377340", "createdAt": "2021-01-06T05:28:49Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BigQueryOptions.java", "diffHunk": "@@ -78,4 +79,11 @@\n   Integer getLatencyLoggingFrequency();\n \n   void setLatencyLoggingFrequency(Integer value);\n+\n+  @Experimental\n+  @Description(\"Whether dynamic sharding is enabled for writing to BigQuery in streaming.\")\n+  @Default.Boolean(false)\n+  Boolean getEnableStreamingAutoSharding();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NDEwNA==", "bodyText": "add space", "url": "https://github.com/apache/beam/pull/13496#discussion_r552384104", "createdAt": "2021-01-06T05:54:56Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NDk2OA==", "bodyText": "seems more direct to just call tableRows.computeIfAbsent(tableSpec, ...)", "url": "https://github.com/apache/beam/pull/13496#discussion_r552384968", "createdAt": "2021-01-06T05:57:52Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5MDU4OQ==", "bodyText": "instead add an OutputReceiver parameter to finishBundle.", "url": "https://github.com/apache/beam/pull/13496#discussion_r552390589", "createdAt": "2021-01-06T06:18:22Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5MTAyNg==", "bodyText": "Why is this \"stateful\"?", "url": "https://github.com/apache/beam/pull/13496#discussion_r552391026", "createdAt": "2021-01-06T06:19:47Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5NjU3MQ==", "bodyText": "Hmm good question. I wonder if someone refactored the code at some point to change things? I'm not entirely sure about the global window here.", "url": "https://github.com/apache/beam/pull/13496#discussion_r552396571", "createdAt": "2021-01-06T06:39:19Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.standardSeconds(10);\n+\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      BigQueryOptions options = input.getPipeline().getOptions().as(BigQueryOptions.class);\n+      KvCoder<String, TableRowInfo<ElementT>> inputCoder = (KvCoder) input.getCoder();\n+      TableRowInfoCoder<ElementT> valueCoder =\n+          (TableRowInfoCoder) inputCoder.getCoderArguments().get(1);\n+      PCollectionTuple result =\n+          input", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg2MDM2Mg=="}, "originalCommit": {"oid": "d187951af8fc016fc8e2adf2d10054d94bfe9b63"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5Njk4Ng==", "bodyText": "However we probably want to put in global window here anyway as the GroupIntoBatches should logically be in hte global window, right? If the user had tiny windows, we don't want that to result in tiny grouping.", "url": "https://github.com/apache/beam/pull/13496#discussion_r552396986", "createdAt": "2021-01-06T06:40:51Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.standardSeconds(10);\n+\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      BigQueryOptions options = input.getPipeline().getOptions().as(BigQueryOptions.class);\n+      KvCoder<String, TableRowInfo<ElementT>> inputCoder = (KvCoder) input.getCoder();\n+      TableRowInfoCoder<ElementT> valueCoder =\n+          (TableRowInfoCoder) inputCoder.getCoderArguments().get(1);\n+      PCollectionTuple result =\n+          input", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg2MDM2Mg=="}, "originalCommit": {"oid": "d187951af8fc016fc8e2adf2d10054d94bfe9b63"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5NzQ0MQ==", "bodyText": "We are relying on the fact that the GroupIntoBatches produces stable output. Really we should tag this with RequiresStableInput. Can you find out if this is safe to do in Dataflow?", "url": "https://github.com/apache/beam/pull/13496#discussion_r552397441", "createdAt": "2021-01-06T06:42:19Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.millis(200);\n+\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      BigQueryOptions options = input.getPipeline().getOptions().as(BigQueryOptions.class);\n+      KvCoder<String, TableRowInfo<ElementT>> inputCoder = (KvCoder) input.getCoder();\n+      TableRowInfoCoder<ElementT> valueCoder =\n+          (TableRowInfoCoder) inputCoder.getCoderArguments().get(1);\n+      PCollectionTuple result =\n+          input\n+              // Group and batch table rows such that each batch has no more than\n+              // getMaxStreamingRowsToBatch rows. Also set a buffering time limit to avoid being\n+              // stuck at a partial batch forever, especially in a global window.\n+              .apply(\n+                  GroupIntoBatches.<String, TableRowInfo<ElementT>>ofSize(\n+                          options.getMaxStreamingRowsToBatch())\n+                      .withMaxBufferingDuration(BATCH_MAX_BUFFERING_DURATION)\n+                      .withShardedKey())\n+              .setCoder(\n+                  KvCoder.of(\n+                      ShardedKey.Coder.of(StringUtf8Coder.of()), IterableCoder.of(valueCoder)))\n+              .apply(\n+                  ParDo.of(new InsertBatchedElements())\n+                      .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  private class InsertBatchedElements", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQwNjkxOQ==", "bodyText": "use a MultiOutputReceiver instead", "url": "https://github.com/apache/beam/pull/13496#discussion_r552406919", "createdAt": "2021-01-06T07:15:22Z", "author": {"login": "reuvenlax"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.millis(200);\n+\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      BigQueryOptions options = input.getPipeline().getOptions().as(BigQueryOptions.class);\n+      KvCoder<String, TableRowInfo<ElementT>> inputCoder = (KvCoder) input.getCoder();\n+      TableRowInfoCoder<ElementT> valueCoder =\n+          (TableRowInfoCoder) inputCoder.getCoderArguments().get(1);\n+      PCollectionTuple result =\n+          input\n+              // Group and batch table rows such that each batch has no more than\n+              // getMaxStreamingRowsToBatch rows. Also set a buffering time limit to avoid being\n+              // stuck at a partial batch forever, especially in a global window.\n+              .apply(\n+                  GroupIntoBatches.<String, TableRowInfo<ElementT>>ofSize(\n+                          options.getMaxStreamingRowsToBatch())\n+                      .withMaxBufferingDuration(BATCH_MAX_BUFFERING_DURATION)\n+                      .withShardedKey())\n+              .setCoder(\n+                  KvCoder.of(\n+                      ShardedKey.Coder.of(StringUtf8Coder.of()), IterableCoder.of(valueCoder)))\n+              .apply(\n+                  ParDo.of(new InsertBatchedElements())\n+                      .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  private class InsertBatchedElements\n+      extends DoFn<KV<ShardedKey<String>, Iterable<TableRowInfo<ElementT>>>, Void> {\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<ShardedKey<String>, Iterable<TableRowInfo<ElementT>>> input,\n+        BoundedWindow window,\n+        ProcessContext context)\n+        throws InterruptedException {\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> tableRows = new ArrayList<>();\n+      List<String> uniqueIds = new ArrayList<>();\n+      for (TableRowInfo<ElementT> row : input.getValue()) {\n+        TableRow tableRow = toTableRow.apply(row.tableRow);\n+        TableRow failsafeTableRow = toFailsafeTableRow.apply(row.tableRow);\n+        tableRows.add(\n+            FailsafeValueInSingleWindow.of(\n+                tableRow, context.timestamp(), window, context.pane(), failsafeTableRow));\n+        uniqueIds.add(row.uniqueId);\n+      }\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      TableReference tableReference = BigQueryHelpers.parseTableSpec(input.getKey().getKey());\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      flushRows(tableReference, tableRows, uniqueIds, options, failedInserts);\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5"}, "originalPosition": 346}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9fcd093ee9d72c1769ab41a6e5b1fe745cf02093", "author": {"user": {"login": "nehsyc", "name": "Siyuan Chen"}}, "url": "https://github.com/apache/beam/commit/9fcd093ee9d72c1769ab41a6e5b1fe745cf02093", "committedDate": "2021-01-08T01:45:13Z", "message": "Moved autosharding option from BigQueryOption to BigQueryIOBuilder; addressed comments."}, "afterCommit": {"oid": "f8790e344c022b4d299c3f7f71cbabeb398b0c21", "author": {"user": {"login": "nehsyc", "name": "Siyuan Chen"}}, "url": "https://github.com/apache/beam/commit/f8790e344c022b4d299c3f7f71cbabeb398b0c21", "committedDate": "2021-01-08T06:59:29Z", "message": "Moved autosharding option from BigQueryOption to BigQueryIOBuilder; addressed comments."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f8790e344c022b4d299c3f7f71cbabeb398b0c21", "author": {"user": {"login": "nehsyc", "name": "Siyuan Chen"}}, "url": "https://github.com/apache/beam/commit/f8790e344c022b4d299c3f7f71cbabeb398b0c21", "committedDate": "2021-01-08T06:59:29Z", "message": "Moved autosharding option from BigQueryOption to BigQueryIOBuilder; addressed comments."}, "afterCommit": {"oid": "0ab05d9a934a7d4ad22b070c77fb2f3857ea1b10", "author": {"user": {"login": "nehsyc", "name": "Siyuan Chen"}}, "url": "https://github.com/apache/beam/commit/0ab05d9a934a7d4ad22b070c77fb2f3857ea1b10", "committedDate": "2021-01-09T00:52:30Z", "message": "Moved autosharding option from BigQueryOption to BigQueryIOBuilder; addressed comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b16f518d20953b3d373a52a60148e71180ef9fd0", "author": {"user": {"login": "nehsyc", "name": "Siyuan Chen"}}, "url": "https://github.com/apache/beam/commit/b16f518d20953b3d373a52a60148e71180ef9fd0", "committedDate": "2021-01-27T22:27:53Z", "message": "Integrate BQ streaming inserts with GroupIntoBatches"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "129176a8ff1eb1171ebdc950931a670babe690d8", "author": {"user": {"login": "nehsyc", "name": "Siyuan Chen"}}, "url": "https://github.com/apache/beam/commit/129176a8ff1eb1171ebdc950931a670babe690d8", "committedDate": "2021-01-27T22:28:27Z", "message": "Moved autosharding option from BigQueryOption to BigQueryIOBuilder; addressed comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c033215c5cebc923652db018aaf034bcef8376c8", "author": {"user": {"login": "nehsyc", "name": "Siyuan Chen"}}, "url": "https://github.com/apache/beam/commit/c033215c5cebc923652db018aaf034bcef8376c8", "committedDate": "2021-01-27T22:29:21Z", "message": "fix checkstyle error"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0ab05d9a934a7d4ad22b070c77fb2f3857ea1b10", "author": {"user": {"login": "nehsyc", "name": "Siyuan Chen"}}, "url": "https://github.com/apache/beam/commit/0ab05d9a934a7d4ad22b070c77fb2f3857ea1b10", "committedDate": "2021-01-09T00:52:30Z", "message": "Moved autosharding option from BigQueryOption to BigQueryIOBuilder; addressed comments."}, "afterCommit": {"oid": "c033215c5cebc923652db018aaf034bcef8376c8", "author": {"user": {"login": "nehsyc", "name": "Siyuan Chen"}}, "url": "https://github.com/apache/beam/commit/c033215c5cebc923652db018aaf034bcef8376c8", "committedDate": "2021-01-27T22:29:21Z", "message": "fix checkstyle error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3deba1de69098cbf58753831a50bf9583a87af55", "author": {"user": {"login": "nehsyc", "name": "Siyuan Chen"}}, "url": "https://github.com/apache/beam/commit/3deba1de69098cbf58753831a50bf9583a87af55", "committedDate": "2021-01-27T23:29:53Z", "message": "Revert the logic that was dropped during merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b97e7c90a92f65df9faba5e531726ddc128c55a", "author": {"user": {"login": "nehsyc", "name": "Siyuan Chen"}}, "url": "https://github.com/apache/beam/commit/1b97e7c90a92f65df9faba5e531726ddc128c55a", "committedDate": "2021-01-28T00:51:18Z", "message": "Add comments for RequiresStableInput"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4356, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}