{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1OTY4ODg3", "number": 11270, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNzo1NzozOFrODxVAQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODoyMDozNFrOD4J-YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDUwOTQ3OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNzo1NzozOFrOGEvKkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoxMzo0MVrOGFlVzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyMDI0MQ==", "bodyText": "I wonder if\n((consuming_transform_id, tag), (buffer_id, func_spec))\nwould make both yapf and humans happy.", "url": "https://github.com/apache/beam/pull/11270#discussion_r407620241", "createdAt": "2020-04-13T17:57:38Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "diffHunk": "@@ -326,8 +327,8 @@ def commit_side_inputs_to_state(\n       data_side_input,  # type: DataSideInput\n   ):\n     # type: (...) -> None\n-    for (consuming_transform_id, tag), (buffer_id, func_spec) \\\n-        in data_side_input.items():\n+    for (consuming_transform_id, tag), (buffer_id,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82828b301507dd71133088cfd8de8bbe86167df9"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwNzg1NA==", "bodyText": "it did not : ( hehe", "url": "https://github.com/apache/beam/pull/11270#discussion_r408507854", "createdAt": "2020-04-15T00:13:41Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "diffHunk": "@@ -326,8 +327,8 @@ def commit_side_inputs_to_state(\n       data_side_input,  # type: DataSideInput\n   ):\n     # type: (...) -> None\n-    for (consuming_transform_id, tag), (buffer_id, func_spec) \\\n-        in data_side_input.items():\n+    for (consuming_transform_id, tag), (buffer_id,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyMDI0MQ=="}, "originalCommit": {"oid": "82828b301507dd71133088cfd8de8bbe86167df9"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDc3OTU0OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOToxNjo0OVrOGExz8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoxMzozMFrOGFlVhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2MzYwMg==", "bodyText": "extract_bundle_inputs_and_outputs?", "url": "https://github.com/apache/beam/pull/11270#discussion_r407663602", "createdAt": "2020-04-13T19:16:49Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "diffHunk": "@@ -367,6 +413,73 @@ def _build_process_bundle_descriptor(self):\n         state_api_service_descriptor=self.state_api_service_descriptor(),\n         timer_api_service_descriptor=self.data_api_service_descriptor())\n \n+  def commit_output_views_to_state(self):\n+    \"\"\"Commit bundle outputs to state to be consumed as side inputs later.\n+\n+    Only the outputs that should be side inputs are committed to state.\n+    \"\"\"\n+    data_side_input = {}  # type: DataSideInput\n+    for pcoll, si_ids in self.stage.downstream_side_inputs.items():\n+      for (consumer_transform_name, tag), access_pattern in si_ids.items():\n+        data_side_input[consumer_transform_name, tag] = (\n+            translations.create_buffer_id(pcoll), access_pattern)\n+    self.execution_context.commit_side_inputs_to_state(data_side_input)\n+\n+  def extract_bundle_inputs(self):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6253ac725e20c8a3fa2a8978579d6e46bd8edf9b"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwNzc4MA==", "bodyText": "done", "url": "https://github.com/apache/beam/pull/11270#discussion_r408507780", "createdAt": "2020-04-15T00:13:30Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "diffHunk": "@@ -367,6 +413,73 @@ def _build_process_bundle_descriptor(self):\n         state_api_service_descriptor=self.state_api_service_descriptor(),\n         timer_api_service_descriptor=self.data_api_service_descriptor())\n \n+  def commit_output_views_to_state(self):\n+    \"\"\"Commit bundle outputs to state to be consumed as side inputs later.\n+\n+    Only the outputs that should be side inputs are committed to state.\n+    \"\"\"\n+    data_side_input = {}  # type: DataSideInput\n+    for pcoll, si_ids in self.stage.downstream_side_inputs.items():\n+      for (consumer_transform_name, tag), access_pattern in si_ids.items():\n+        data_side_input[consumer_transform_name, tag] = (\n+            translations.create_buffer_id(pcoll), access_pattern)\n+    self.execution_context.commit_side_inputs_to_state(data_side_input)\n+\n+  def extract_bundle_inputs(self):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2MzYwMg=="}, "originalCommit": {"oid": "6253ac725e20c8a3fa2a8978579d6e46bd8edf9b"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDc4MTU3OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOToxNzoyNFrOGEx1LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoxMzoxOVrOGFlVUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2MzkxNg==", "bodyText": "Update docs to match.", "url": "https://github.com/apache/beam/pull/11270#discussion_r407663916", "createdAt": "2020-04-13T19:17:24Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "diffHunk": "@@ -367,6 +413,73 @@ def _build_process_bundle_descriptor(self):\n         state_api_service_descriptor=self.state_api_service_descriptor(),\n         timer_api_service_descriptor=self.data_api_service_descriptor())\n \n+  def commit_output_views_to_state(self):\n+    \"\"\"Commit bundle outputs to state to be consumed as side inputs later.\n+\n+    Only the outputs that should be side inputs are committed to state.\n+    \"\"\"\n+    data_side_input = {}  # type: DataSideInput\n+    for pcoll, si_ids in self.stage.downstream_side_inputs.items():\n+      for (consumer_transform_name, tag), access_pattern in si_ids.items():\n+        data_side_input[consumer_transform_name, tag] = (\n+            translations.create_buffer_id(pcoll), access_pattern)\n+    self.execution_context.commit_side_inputs_to_state(data_side_input)\n+\n+  def extract_bundle_inputs(self):\n+    # type: (...) -> Tuple[Dict[str, PartitionableBuffer], DataOutput]\n+\n+    \"\"\"Returns maps of transform names to PCollection identifiers.\n+\n+    Also mutates IO stages to point to the data ApiServiceDescriptor.\n+\n+    Returns:\n+      A tuple of (data_input, data_output) dictionaries.\n+        `data_input` is a dictionary mapping (transform_name, output_name) to a\n+        PCollection buffer; `data_output` is a dictionary mapping\n+        (transform_name, output_name) to a PCollection ID.\n+    \"\"\"\n+    data_input = {}  # type: Dict[str, PartitionableBuffer]\n+    data_output = {}  # type: DataOutput\n+    # A mapping of {(transform_id, timer_family_id) : buffer_id}\n+    expected_timer_output = {}  # type: Dict[Tuple(str, str), str]\n+    for transform in self.stage.transforms:\n+      if transform.spec.urn in (bundle_processor.DATA_INPUT_URN,\n+                                bundle_processor.DATA_OUTPUT_URN):\n+        pcoll_id = transform.spec.payload\n+        if transform.spec.urn == bundle_processor.DATA_INPUT_URN:\n+          coder_id = self.execution_context.data_channel_coders[only_element(\n+              transform.outputs.values())]\n+          coder = self.execution_context.pipeline_context.coders[\n+              self.execution_context.safe_coders.get(coder_id, coder_id)]\n+          if pcoll_id == translations.IMPULSE_BUFFER:\n+            data_input[transform.unique_name] = ListBuffer(\n+                coder_impl=coder.get_impl())\n+            data_input[transform.unique_name].append(ENCODED_IMPULSE_VALUE)\n+          else:\n+            if pcoll_id not in self.execution_context.pcoll_buffers:\n+              self.execution_context.pcoll_buffers[pcoll_id] = ListBuffer(\n+                  coder_impl=coder.get_impl())\n+            data_input[transform.unique_name] = \\\n+              self.execution_context.pcoll_buffers[pcoll_id]\n+        elif transform.spec.urn == bundle_processor.DATA_OUTPUT_URN:\n+          data_output[transform.unique_name] = pcoll_id\n+          coder_id = self.execution_context.data_channel_coders[only_element(\n+              transform.inputs.values())]\n+        else:\n+          raise NotImplementedError\n+        data_spec = beam_fn_api_pb2.RemoteGrpcPort(coder_id=coder_id)\n+        data_api_service_descriptor = \\\n+          self.data_api_service_descriptor()\n+        if data_api_service_descriptor:\n+          data_spec.api_service_descriptor.url = (\n+              data_api_service_descriptor.url)\n+        transform.spec.payload = data_spec.SerializeToString()\n+      elif transform.spec.urn in translations.PAR_DO_URNS:\n+        for timer_family_id in payload.timer_family_specs.keys():\n+          expected_timer_output[(transform.unique_name, timer_family_id)] = (\n+              create_buffer_id(timer_family_id, 'timers'))\n+    return data_input, data_output, expected_timer_output", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6253ac725e20c8a3fa2a8978579d6e46bd8edf9b"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwNzczMA==", "bodyText": "done", "url": "https://github.com/apache/beam/pull/11270#discussion_r408507730", "createdAt": "2020-04-15T00:13:19Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "diffHunk": "@@ -367,6 +413,73 @@ def _build_process_bundle_descriptor(self):\n         state_api_service_descriptor=self.state_api_service_descriptor(),\n         timer_api_service_descriptor=self.data_api_service_descriptor())\n \n+  def commit_output_views_to_state(self):\n+    \"\"\"Commit bundle outputs to state to be consumed as side inputs later.\n+\n+    Only the outputs that should be side inputs are committed to state.\n+    \"\"\"\n+    data_side_input = {}  # type: DataSideInput\n+    for pcoll, si_ids in self.stage.downstream_side_inputs.items():\n+      for (consumer_transform_name, tag), access_pattern in si_ids.items():\n+        data_side_input[consumer_transform_name, tag] = (\n+            translations.create_buffer_id(pcoll), access_pattern)\n+    self.execution_context.commit_side_inputs_to_state(data_side_input)\n+\n+  def extract_bundle_inputs(self):\n+    # type: (...) -> Tuple[Dict[str, PartitionableBuffer], DataOutput]\n+\n+    \"\"\"Returns maps of transform names to PCollection identifiers.\n+\n+    Also mutates IO stages to point to the data ApiServiceDescriptor.\n+\n+    Returns:\n+      A tuple of (data_input, data_output) dictionaries.\n+        `data_input` is a dictionary mapping (transform_name, output_name) to a\n+        PCollection buffer; `data_output` is a dictionary mapping\n+        (transform_name, output_name) to a PCollection ID.\n+    \"\"\"\n+    data_input = {}  # type: Dict[str, PartitionableBuffer]\n+    data_output = {}  # type: DataOutput\n+    # A mapping of {(transform_id, timer_family_id) : buffer_id}\n+    expected_timer_output = {}  # type: Dict[Tuple(str, str), str]\n+    for transform in self.stage.transforms:\n+      if transform.spec.urn in (bundle_processor.DATA_INPUT_URN,\n+                                bundle_processor.DATA_OUTPUT_URN):\n+        pcoll_id = transform.spec.payload\n+        if transform.spec.urn == bundle_processor.DATA_INPUT_URN:\n+          coder_id = self.execution_context.data_channel_coders[only_element(\n+              transform.outputs.values())]\n+          coder = self.execution_context.pipeline_context.coders[\n+              self.execution_context.safe_coders.get(coder_id, coder_id)]\n+          if pcoll_id == translations.IMPULSE_BUFFER:\n+            data_input[transform.unique_name] = ListBuffer(\n+                coder_impl=coder.get_impl())\n+            data_input[transform.unique_name].append(ENCODED_IMPULSE_VALUE)\n+          else:\n+            if pcoll_id not in self.execution_context.pcoll_buffers:\n+              self.execution_context.pcoll_buffers[pcoll_id] = ListBuffer(\n+                  coder_impl=coder.get_impl())\n+            data_input[transform.unique_name] = \\\n+              self.execution_context.pcoll_buffers[pcoll_id]\n+        elif transform.spec.urn == bundle_processor.DATA_OUTPUT_URN:\n+          data_output[transform.unique_name] = pcoll_id\n+          coder_id = self.execution_context.data_channel_coders[only_element(\n+              transform.inputs.values())]\n+        else:\n+          raise NotImplementedError\n+        data_spec = beam_fn_api_pb2.RemoteGrpcPort(coder_id=coder_id)\n+        data_api_service_descriptor = \\\n+          self.data_api_service_descriptor()\n+        if data_api_service_descriptor:\n+          data_spec.api_service_descriptor.url = (\n+              data_api_service_descriptor.url)\n+        transform.spec.payload = data_spec.SerializeToString()\n+      elif transform.spec.urn in translations.PAR_DO_URNS:\n+        for timer_family_id in payload.timer_family_specs.keys():\n+          expected_timer_output[(transform.unique_name, timer_family_id)] = (\n+              create_buffer_id(timer_family_id, 'timers'))\n+    return data_input, data_output, expected_timer_output", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2MzkxNg=="}, "originalCommit": {"oid": "6253ac725e20c8a3fa2a8978579d6e46bd8edf9b"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDc4NzA1OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOToxODo1N1rOGEx4iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoxMzoxMlrOGFlVLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2NDc3Nw==", "bodyText": "Not sure what \"output views\" means. Maybe call this commit_side_inputs_to_state as well?", "url": "https://github.com/apache/beam/pull/11270#discussion_r407664777", "createdAt": "2020-04-13T19:18:57Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "diffHunk": "@@ -367,6 +413,73 @@ def _build_process_bundle_descriptor(self):\n         state_api_service_descriptor=self.state_api_service_descriptor(),\n         timer_api_service_descriptor=self.data_api_service_descriptor())\n \n+  def commit_output_views_to_state(self):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6253ac725e20c8a3fa2a8978579d6e46bd8edf9b"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwNzY5Mw==", "bodyText": "done", "url": "https://github.com/apache/beam/pull/11270#discussion_r408507693", "createdAt": "2020-04-15T00:13:12Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/execution.py", "diffHunk": "@@ -367,6 +413,73 @@ def _build_process_bundle_descriptor(self):\n         state_api_service_descriptor=self.state_api_service_descriptor(),\n         timer_api_service_descriptor=self.data_api_service_descriptor())\n \n+  def commit_output_views_to_state(self):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2NDc3Nw=="}, "originalCommit": {"oid": "6253ac725e20c8a3fa2a8978579d6e46bd8edf9b"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDgwMDQ0OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOToyMjo0NVrOGEyAvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoxMzowNVrOGFlVFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2Njg3Nw==", "bodyText": "Nit: this sounds like it mutates self.", "url": "https://github.com/apache/beam/pull/11270#discussion_r407666877", "createdAt": "2020-04-13T19:22:45Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -149,15 +155,26 @@ def no_overlap(a, b):\n     return (\n         not consumer.forced_root and not self in consumer.must_follow and\n         not self.is_runner_urn(context) and\n-        not consumer.is_runner_urn(context) and\n-        no_overlap(self.downstream_side_inputs, consumer.side_inputs()))\n+        not consumer.is_runner_urn(context) and no_overlap(\n+            set(self.downstream_side_inputs.keys()),\n+            {i\n+             for i, _, _ in consumer.side_inputs()}))\n+\n+  def _fuse_downstream_side_inputs(self, other):\n+    res = dict(self.downstream_side_inputs)\n+    for si, other_si_ids in other.downstream_side_inputs.items():\n+      if si in res:\n+        res[si] = union(res[si], other_si_ids)\n+      else:\n+        res[si] = other_si_ids\n+    return res\n \n   def fuse(self, other):\n     # type: (Stage) -> Stage\n     return Stage(\n         \"(%s)+(%s)\" % (self.name, other.name),\n         self.transforms + other.transforms,\n-        union(self.downstream_side_inputs, other.downstream_side_inputs),\n+        self._fuse_downstream_side_inputs(other),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6253ac725e20c8a3fa2a8978579d6e46bd8edf9b"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwNzY2OQ==", "bodyText": "renamed to _get_fused_downstream_side_inputs thoughts?", "url": "https://github.com/apache/beam/pull/11270#discussion_r408507669", "createdAt": "2020-04-15T00:13:05Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -149,15 +155,26 @@ def no_overlap(a, b):\n     return (\n         not consumer.forced_root and not self in consumer.must_follow and\n         not self.is_runner_urn(context) and\n-        not consumer.is_runner_urn(context) and\n-        no_overlap(self.downstream_side_inputs, consumer.side_inputs()))\n+        not consumer.is_runner_urn(context) and no_overlap(\n+            set(self.downstream_side_inputs.keys()),\n+            {i\n+             for i, _, _ in consumer.side_inputs()}))\n+\n+  def _fuse_downstream_side_inputs(self, other):\n+    res = dict(self.downstream_side_inputs)\n+    for si, other_si_ids in other.downstream_side_inputs.items():\n+      if si in res:\n+        res[si] = union(res[si], other_si_ids)\n+      else:\n+        res[si] = other_si_ids\n+    return res\n \n   def fuse(self, other):\n     # type: (Stage) -> Stage\n     return Stage(\n         \"(%s)+(%s)\" % (self.name, other.name),\n         self.transforms + other.transforms,\n-        union(self.downstream_side_inputs, other.downstream_side_inputs),\n+        self._fuse_downstream_side_inputs(other),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2Njg3Nw=="}, "originalCommit": {"oid": "6253ac725e20c8a3fa2a8978579d6e46bd8edf9b"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDgwNTgzOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOToyNDoxM1rOGEyD9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoxMjo1MVrOGFlU2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2NzcwMA==", "bodyText": "What does the value represent?", "url": "https://github.com/apache/beam/pull/11270#discussion_r407667700", "createdAt": "2020-04-13T19:24:13Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -75,21 +75,27 @@\n \n IMPULSE_BUFFER = b'impulse'\n \n+# SideInputId is identified by a consumer ParDo + tag.\n+SideInputId = Tuple[str, str]\n+\n+DataSideInput = Dict[SideInputId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6253ac725e20c8a3fa2a8978579d6e46bd8edf9b"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwNzYxMA==", "bodyText": "The value is a tuple with the encoded data. I've moved these to translations.py, and updated the comment", "url": "https://github.com/apache/beam/pull/11270#discussion_r408507610", "createdAt": "2020-04-15T00:12:51Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -75,21 +75,27 @@\n \n IMPULSE_BUFFER = b'impulse'\n \n+# SideInputId is identified by a consumer ParDo + tag.\n+SideInputId = Tuple[str, str]\n+\n+DataSideInput = Dict[SideInputId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2NzcwMA=="}, "originalCommit": {"oid": "6253ac725e20c8a3fa2a8978579d6e46bd8edf9b"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDgwNzgwOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOToyNDo1M1rOGEyFQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoxMjo0NVrOGFlUpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2ODAzMw==", "bodyText": "So this is actually a dict mapping to sets?", "url": "https://github.com/apache/beam/pull/11270#discussion_r407668033", "createdAt": "2020-04-13T19:24:53Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -149,15 +155,26 @@ def no_overlap(a, b):\n     return (\n         not consumer.forced_root and not self in consumer.must_follow and\n         not self.is_runner_urn(context) and\n-        not consumer.is_runner_urn(context) and\n-        no_overlap(self.downstream_side_inputs, consumer.side_inputs()))\n+        not consumer.is_runner_urn(context) and no_overlap(\n+            set(self.downstream_side_inputs.keys()),\n+            {i\n+             for i, _, _ in consumer.side_inputs()}))\n+\n+  def _fuse_downstream_side_inputs(self, other):\n+    res = dict(self.downstream_side_inputs)\n+    for si, other_si_ids in other.downstream_side_inputs.items():\n+      if si in res:\n+        res[si] = union(res[si], other_si_ids)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6253ac725e20c8a3fa2a8978579d6e46bd8edf9b"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwNzU1OA==", "bodyText": "woah this is a bug.\ndownstream side input is a dictionary mapping to dictionaries.\nDict[Output Pcollection, Dict[Side input ID, Access pattern]]\nWhere Side input ID is Tuple[consumer ptransform, input index]. Added appropriate annotations, and fixed the bug.", "url": "https://github.com/apache/beam/pull/11270#discussion_r408507558", "createdAt": "2020-04-15T00:12:45Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -149,15 +155,26 @@ def no_overlap(a, b):\n     return (\n         not consumer.forced_root and not self in consumer.must_follow and\n         not self.is_runner_urn(context) and\n-        not consumer.is_runner_urn(context) and\n-        no_overlap(self.downstream_side_inputs, consumer.side_inputs()))\n+        not consumer.is_runner_urn(context) and no_overlap(\n+            set(self.downstream_side_inputs.keys()),\n+            {i\n+             for i, _, _ in consumer.side_inputs()}))\n+\n+  def _fuse_downstream_side_inputs(self, other):\n+    res = dict(self.downstream_side_inputs)\n+    for si, other_si_ids in other.downstream_side_inputs.items():\n+      if si in res:\n+        res[si] = union(res[si], other_si_ids)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2ODAzMw=="}, "originalCommit": {"oid": "6253ac725e20c8a3fa2a8978579d6e46bd8edf9b"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDgyNDEzOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOToyOTo1M1rOGEyPVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxODoxNTo0NVrOGJR8DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3MDYxMg==", "bodyText": "The goal of this (which, yes, should have been better documented) is to quickly be able to prohibit fusion. But the reason we defined our own union was so that memory didn't grow as O(n^2) in the common case because many stages were able to share this set (rather than have their own copy). These changes seem to break that.\nAlso, could you clarify why this was made into a dict?", "url": "https://github.com/apache/beam/pull/11270#discussion_r407670612", "createdAt": "2020-04-13T19:29:53Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -75,21 +75,27 @@\n \n IMPULSE_BUFFER = b'impulse'\n \n+# SideInputId is identified by a consumer ParDo + tag.\n+SideInputId = Tuple[str, str]\n+\n+DataSideInput = Dict[SideInputId,\n+                     Tuple[bytes, beam_runner_api_pb2.FunctionSpec]]\n+\n \n class Stage(object):\n   \"\"\"A set of Transforms that can be sent to the worker for processing.\"\"\"\n   def __init__(self,\n                name,  # type: str\n                transforms,  # type: List[beam_runner_api_pb2.PTransform]\n-               downstream_side_inputs=None,  # type: Optional[FrozenSet[str]]\n+               downstream_side_inputs=None,  # type: Optional[Dict[str, SideInputId]]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6253ac725e20c8a3fa2a8978579d6e46bd8edf9b"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODk2NA==", "bodyText": "Hm so this change breaks that, so the memory requirements would be larger. I would think that they would not be too bad, since most graphs don't have many side inputs going many places. What do you think? I'm willing to find a better solution for this, but I wonder if it's worth the extra time.\nThe reason that this is made into a dict is to contain more information about downstream side inputs. specifically, it contains which transforms will consume the side inputs. this is used to commit the side inputs to state after they are calculated (rather than before they are consumed). This will be necessary for streaming, because side inputs will need to be added to state as they are computed.", "url": "https://github.com/apache/beam/pull/11270#discussion_r408508964", "createdAt": "2020-04-15T00:17:42Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -75,21 +75,27 @@\n \n IMPULSE_BUFFER = b'impulse'\n \n+# SideInputId is identified by a consumer ParDo + tag.\n+SideInputId = Tuple[str, str]\n+\n+DataSideInput = Dict[SideInputId,\n+                     Tuple[bytes, beam_runner_api_pb2.FunctionSpec]]\n+\n \n class Stage(object):\n   \"\"\"A set of Transforms that can be sent to the worker for processing.\"\"\"\n   def __init__(self,\n                name,  # type: str\n                transforms,  # type: List[beam_runner_api_pb2.PTransform]\n-               downstream_side_inputs=None,  # type: Optional[FrozenSet[str]]\n+               downstream_side_inputs=None,  # type: Optional[Dict[str, SideInputId]]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3MDYxMg=="}, "originalCommit": {"oid": "6253ac725e20c8a3fa2a8978579d6e46bd8edf9b"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM4NDI2OA==", "bodyText": "Discussed offline, but capturing here for the record. These sets contain the transitive collection of everything downstream of any side-input consuming transform, and as such can be large even if the total number of side inputs is small. (The number of distinct such sets is about the same as the number of side inputs, so we keep the total memory use down by re-using them--to give each transform its own copy would easily be O(n^2).)\nYour change of computing the side input mapping after the graph has been fused is good (and arguably better, as you only need the immediate consumers, and don't have to re-compute each time a stage is fused).", "url": "https://github.com/apache/beam/pull/11270#discussion_r412384268", "createdAt": "2020-04-21T18:15:45Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/translations.py", "diffHunk": "@@ -75,21 +75,27 @@\n \n IMPULSE_BUFFER = b'impulse'\n \n+# SideInputId is identified by a consumer ParDo + tag.\n+SideInputId = Tuple[str, str]\n+\n+DataSideInput = Dict[SideInputId,\n+                     Tuple[bytes, beam_runner_api_pb2.FunctionSpec]]\n+\n \n class Stage(object):\n   \"\"\"A set of Transforms that can be sent to the worker for processing.\"\"\"\n   def __init__(self,\n                name,  # type: str\n                transforms,  # type: List[beam_runner_api_pb2.PTransform]\n-               downstream_side_inputs=None,  # type: Optional[FrozenSet[str]]\n+               downstream_side_inputs=None,  # type: Optional[Dict[str, SideInputId]]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3MDYxMg=="}, "originalCommit": {"oid": "6253ac725e20c8a3fa2a8978579d6e46bd8edf9b"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDg0NDc1OnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOTozNjoyMlrOGEycJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoxMzo1MVrOGFlWCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3Mzg5NQ==", "bodyText": "This should be the default, we shouldn't have to pass it.", "url": "https://github.com/apache/beam/pull/11270#discussion_r407673895", "createdAt": "2020-04-13T19:36:22Z", "author": {"login": "robertwb"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -914,14 +898,16 @@ def process_bundle(self,\n                      expected_outputs,  # type: DataOutput\n                      fired_timers,  # type: Mapping[Tuple[str, str], PartitionableBuffer]\n                      expected_output_timers  # type: Dict[str, Dict[str, str]]\n+                     dry_run=False", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b48af3d471b7fc766c3402db65cba880f2d29903"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwNzkxNA==", "bodyText": "Done", "url": "https://github.com/apache/beam/pull/11270#discussion_r408507914", "createdAt": "2020-04-15T00:13:51Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -914,14 +898,16 @@ def process_bundle(self,\n                      expected_outputs,  # type: DataOutput\n                      fired_timers,  # type: Mapping[Tuple[str, str], PartitionableBuffer]\n                      expected_output_timers  # type: Dict[str, Dict[str, str]]\n+                     dry_run=False", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3Mzg5NQ=="}, "originalCommit": {"oid": "b48af3d471b7fc766c3402db65cba880f2d29903"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMjEwMjcyOnYy", "diffSide": "RIGHT", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner_test.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODoyMDozNFrOGO1E8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxOTo0NjoxM1rOGSxekQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIwMjg2NA==", "bodyText": "This test breaks Spark VR test: https://issues.apache.org/jira/browse/BEAM-9862. Please either support the same function for Spark or sickbay it.", "url": "https://github.com/apache/beam/pull/11270#discussion_r418202864", "createdAt": "2020-04-30T18:20:34Z", "author": {"login": "boyuanzz"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner_test.py", "diffHunk": "@@ -240,6 +240,30 @@ def test_multimap_side_input(self):\n               lambda k, d: (k, sorted(d[k])), beam.pvalue.AsMultiMap(side)),\n           equal_to([('a', [1, 3]), ('b', [2])]))\n \n+  def test_multimap_multiside_input(self):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf821e55b43d5b245a4587a6f71061e405594efa"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMzODE5Mw==", "bodyText": "Thanks for reporting Boyuan, this was a flaw with the Spark runner. Fix: #11644", "url": "https://github.com/apache/beam/pull/11270#discussion_r422338193", "createdAt": "2020-05-08T19:46:13Z", "author": {"login": "ibzib"}, "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner_test.py", "diffHunk": "@@ -240,6 +240,30 @@ def test_multimap_side_input(self):\n               lambda k, d: (k, sorted(d[k])), beam.pvalue.AsMultiMap(side)),\n           equal_to([('a', [1, 3]), ('b', [2])]))\n \n+  def test_multimap_multiside_input(self):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIwMjg2NA=="}, "originalCommit": {"oid": "cf821e55b43d5b245a4587a6f71061e405594efa"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1578, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}