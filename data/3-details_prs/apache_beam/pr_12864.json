{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg4NzI4NjQ5", "number": 12864, "title": "[BEAM-10650] Windmill implementation for TimestampOrderedState", "bodyText": "", "createdAt": "2020-09-17T14:53:03Z", "url": "https://github.com/apache/beam/pull/12864", "merged": true, "mergeCommit": {"oid": "488c10c23312ae14000e292efe835d273e67883a"}, "closed": true, "closedAt": "2020-10-17T16:43:20Z", "author": {"login": "reuvenlax"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdKo0mYABqjM3ODU4NjA5Mjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdS-Ww3gH2gAyNDg4NzI4NjQ5OjA3ZjMzODY0NzE0YTQ3NTVjZDlmZjQ1NWIyM2YzNTVjNGU3YWJjNWU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "47d01390164c4ac6efdc792c4d3f936e8a7bb42f", "author": {"user": {"login": "reuvenlax", "name": null}}, "url": "https://github.com/apache/beam/commit/47d01390164c4ac6efdc792c4d3f936e8a7bb42f", "committedDate": "2020-09-20T06:21:34Z", "message": "enable OrderedListState tests on Dataflow"}, "afterCommit": {"oid": "a3057b9c0938b00eae8b8bd20feda936d9ae0d71", "author": {"user": {"login": "reuvenlax", "name": null}}, "url": "https://github.com/apache/beam/commit/a3057b9c0938b00eae8b8bd20feda936d9ae0d71", "committedDate": "2020-09-20T06:29:49Z", "message": "Windmill implementation for TimestampOrderedState"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMDk1MTEz", "url": "https://github.com/apache/beam/pull/12864#pullrequestreview-493095113", "createdAt": "2020-09-22T02:37:53Z", "commit": {"oid": "51f72ea52a7e3883fbbf0a0fe79d3c1a82c8ac14"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMDk3NTUy", "url": "https://github.com/apache/beam/pull/12864#pullrequestreview-493097552", "createdAt": "2020-09-22T02:49:14Z", "commit": {"oid": "51f72ea52a7e3883fbbf0a0fe79d3c1a82c8ac14"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwMjo0OToxNVrOHVoomQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwMjo0OToxNVrOHVoomQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ0Nzg5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * identified by the pair of timestamp and id. This means that tow unique elements e1, e2 must\n          \n          \n            \n               * identified by the pair of timestamp and id. This means that two unique elements e1, e2 must", "url": "https://github.com/apache/beam/pull/12864#discussion_r492447897", "createdAt": "2020-09-22T02:49:15Z", "author": {"login": "rezarokni"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateInternals.java", "diffHunk": "@@ -470,81 +541,514 @@ protected WorkItemCommitRequest persistDirectly(WindmillStateCache.ForKey cache)\n     }\n   }\n \n-  private static class WindmillOrderedList<T> extends SimpleWindmillState\n-      implements OrderedListState<T> {\n+  // Coder for closed-open ranges.\n+  private static class RangeCoder<T extends Comparable> extends CustomCoder<Range<T>> {\n+    private Coder<T> boundCoder;\n+\n+    RangeCoder(Coder<T> boundCoder) {\n+      this.boundCoder = NullableCoder.of(boundCoder);\n+    }\n+\n+    @Override\n+    public void encode(Range<T> value, OutputStream outStream) throws CoderException, IOException {\n+      Preconditions.checkState(\n+          value.lowerBoundType().equals(BoundType.CLOSED), \"unexpected range \" + value);\n+      Preconditions.checkState(\n+          value.upperBoundType().equals(BoundType.OPEN), \"unexpected range \" + value);\n+      boundCoder.encode(value.hasLowerBound() ? value.lowerEndpoint() : null, outStream);\n+      boundCoder.encode(value.hasUpperBound() ? value.upperEndpoint() : null, outStream);\n+    }\n+\n+    @Override\n+    public Range<T> decode(InputStream inStream) throws CoderException, IOException {\n+      @Nullable T lower = boundCoder.decode(inStream);\n+      @Nullable T upper = boundCoder.decode(inStream);\n+      if (lower == null) {\n+        return upper != null ? Range.lessThan(upper) : Range.all();\n+      } else if (upper == null) {\n+        return Range.atLeast(lower);\n+      } else {\n+        return Range.closedOpen(lower, upper);\n+      }\n+    }\n+  }\n+\n+  private static class RangeSetCoder<T extends Comparable> extends CustomCoder<RangeSet<T>> {\n+    private SetCoder<Range<T>> rangesCoder;\n+\n+    RangeSetCoder(Coder<T> boundCoder) {\n+      this.rangesCoder = SetCoder.of(new RangeCoder<>(boundCoder));\n+    }\n+\n+    @Override\n+    public void encode(RangeSet<T> value, OutputStream outStream) throws IOException {\n+      rangesCoder.encode(value.asRanges(), outStream);\n+    }\n+\n+    @Override\n+    public RangeSet<T> decode(InputStream inStream) throws CoderException, IOException {\n+      return TreeRangeSet.create(rangesCoder.decode(inStream));\n+    }\n+  }\n+\n+  /**\n+   * Tracker for the ids used in an ordered list.\n+   *\n+   * <p>Windmill accepts an int64 id for each timestamped-element in the list. Unique elements are\n+   * identified by the pair of timestamp and id. This means that tow unique elements e1, e2 must", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51f72ea52a7e3883fbbf0a0fe79d3c1a82c8ac14"}, "originalPosition": 288}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMDk4NzI4", "url": "https://github.com/apache/beam/pull/12864#pullrequestreview-493098728", "createdAt": "2020-09-22T02:54:37Z", "commit": {"oid": "51f72ea52a7e3883fbbf0a0fe79d3c1a82c8ac14"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwMjo1NDozN1rOHVosow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwMjo1NDozN1rOHVosow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ0ODkzMQ==", "bodyText": "Should call out that in the case where there is no unique id, there is loss of information.\nMaybe should think about configuration which has to be explicitly overwritten to allow for inserts of two identical elements.", "url": "https://github.com/apache/beam/pull/12864#discussion_r492448931", "createdAt": "2020-09-22T02:54:37Z", "author": {"login": "rezarokni"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateInternals.java", "diffHunk": "@@ -470,81 +541,514 @@ protected WorkItemCommitRequest persistDirectly(WindmillStateCache.ForKey cache)\n     }\n   }\n \n-  private static class WindmillOrderedList<T> extends SimpleWindmillState\n-      implements OrderedListState<T> {\n+  // Coder for closed-open ranges.\n+  private static class RangeCoder<T extends Comparable> extends CustomCoder<Range<T>> {\n+    private Coder<T> boundCoder;\n+\n+    RangeCoder(Coder<T> boundCoder) {\n+      this.boundCoder = NullableCoder.of(boundCoder);\n+    }\n+\n+    @Override\n+    public void encode(Range<T> value, OutputStream outStream) throws CoderException, IOException {\n+      Preconditions.checkState(\n+          value.lowerBoundType().equals(BoundType.CLOSED), \"unexpected range \" + value);\n+      Preconditions.checkState(\n+          value.upperBoundType().equals(BoundType.OPEN), \"unexpected range \" + value);\n+      boundCoder.encode(value.hasLowerBound() ? value.lowerEndpoint() : null, outStream);\n+      boundCoder.encode(value.hasUpperBound() ? value.upperEndpoint() : null, outStream);\n+    }\n+\n+    @Override\n+    public Range<T> decode(InputStream inStream) throws CoderException, IOException {\n+      @Nullable T lower = boundCoder.decode(inStream);\n+      @Nullable T upper = boundCoder.decode(inStream);\n+      if (lower == null) {\n+        return upper != null ? Range.lessThan(upper) : Range.all();\n+      } else if (upper == null) {\n+        return Range.atLeast(lower);\n+      } else {\n+        return Range.closedOpen(lower, upper);\n+      }\n+    }\n+  }\n+\n+  private static class RangeSetCoder<T extends Comparable> extends CustomCoder<RangeSet<T>> {\n+    private SetCoder<Range<T>> rangesCoder;\n+\n+    RangeSetCoder(Coder<T> boundCoder) {\n+      this.rangesCoder = SetCoder.of(new RangeCoder<>(boundCoder));\n+    }\n+\n+    @Override\n+    public void encode(RangeSet<T> value, OutputStream outStream) throws IOException {\n+      rangesCoder.encode(value.asRanges(), outStream);\n+    }\n+\n+    @Override\n+    public RangeSet<T> decode(InputStream inStream) throws CoderException, IOException {\n+      return TreeRangeSet.create(rangesCoder.decode(inStream));\n+    }\n+  }\n+\n+  /**\n+   * Tracker for the ids used in an ordered list.\n+   *\n+   * <p>Windmill accepts an int64 id for each timestamped-element in the list. Unique elements are\n+   * identified by the pair of timestamp and id. This means that tow unique elements e1, e2 must\n+   * have different (ts1, id1), (ts2, id2) pairs. To accomplish this we bucket time into five-minute", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51f72ea52a7e3883fbbf0a0fe79d3c1a82c8ac14"}, "originalPosition": 289}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMDk5NzMw", "url": "https://github.com/apache/beam/pull/12864#pullrequestreview-493099730", "createdAt": "2020-09-22T02:59:03Z", "commit": {"oid": "51f72ea52a7e3883fbbf0a0fe79d3c1a82c8ac14"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwMjo1OTowM1rOHVowOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwMjo1OTowM1rOHVowOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ0OTg1MQ==", "bodyText": "Would be useful to have a readAndRemoveRange op. When in OnTimer doing process up to this point work, the next step after reading is to clear. So this would save having to make two calls.", "url": "https://github.com/apache/beam/pull/12864#discussion_r492449851", "createdAt": "2020-09-22T02:59:03Z", "author": {"login": "rezarokni"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateInternals.java", "diffHunk": "@@ -470,81 +541,514 @@ protected WorkItemCommitRequest persistDirectly(WindmillStateCache.ForKey cache)\n     }\n   }\n \n-  private static class WindmillOrderedList<T> extends SimpleWindmillState\n-      implements OrderedListState<T> {\n+  // Coder for closed-open ranges.\n+  private static class RangeCoder<T extends Comparable> extends CustomCoder<Range<T>> {\n+    private Coder<T> boundCoder;\n+\n+    RangeCoder(Coder<T> boundCoder) {\n+      this.boundCoder = NullableCoder.of(boundCoder);\n+    }\n+\n+    @Override\n+    public void encode(Range<T> value, OutputStream outStream) throws CoderException, IOException {\n+      Preconditions.checkState(\n+          value.lowerBoundType().equals(BoundType.CLOSED), \"unexpected range \" + value);\n+      Preconditions.checkState(\n+          value.upperBoundType().equals(BoundType.OPEN), \"unexpected range \" + value);\n+      boundCoder.encode(value.hasLowerBound() ? value.lowerEndpoint() : null, outStream);\n+      boundCoder.encode(value.hasUpperBound() ? value.upperEndpoint() : null, outStream);\n+    }\n+\n+    @Override\n+    public Range<T> decode(InputStream inStream) throws CoderException, IOException {\n+      @Nullable T lower = boundCoder.decode(inStream);\n+      @Nullable T upper = boundCoder.decode(inStream);\n+      if (lower == null) {\n+        return upper != null ? Range.lessThan(upper) : Range.all();\n+      } else if (upper == null) {\n+        return Range.atLeast(lower);\n+      } else {\n+        return Range.closedOpen(lower, upper);\n+      }\n+    }\n+  }\n+\n+  private static class RangeSetCoder<T extends Comparable> extends CustomCoder<RangeSet<T>> {\n+    private SetCoder<Range<T>> rangesCoder;\n+\n+    RangeSetCoder(Coder<T> boundCoder) {\n+      this.rangesCoder = SetCoder.of(new RangeCoder<>(boundCoder));\n+    }\n+\n+    @Override\n+    public void encode(RangeSet<T> value, OutputStream outStream) throws IOException {\n+      rangesCoder.encode(value.asRanges(), outStream);\n+    }\n+\n+    @Override\n+    public RangeSet<T> decode(InputStream inStream) throws CoderException, IOException {\n+      return TreeRangeSet.create(rangesCoder.decode(inStream));\n+    }\n+  }\n+\n+  /**\n+   * Tracker for the ids used in an ordered list.\n+   *\n+   * <p>Windmill accepts an int64 id for each timestamped-element in the list. Unique elements are\n+   * identified by the pair of timestamp and id. This means that tow unique elements e1, e2 must\n+   * have different (ts1, id1), (ts2, id2) pairs. To accomplish this we bucket time into five-minute\n+   * buckets, and store a free list of ids available for each bucket.\n+   *\n+   * <p>When a timestamp range is deleted, we remove id tracking for elements in that range. In\n+   * order to handle the case where a range is deleted piecemeal, we track sub-range deletions for\n+   * each range. For example:\n+   *\n+   * <p>12:00 - 12:05 ids 12:05 - 12:10 ids\n+   *\n+   * <p>delete 12:00-12:06\n+   *\n+   * <p>12:00 - 12:05 *removed* 12:05 - 12:10 ids subranges deleted 12:05-12:06\n+   *\n+   * <p>delete 12:06 - 12:07\n+   *\n+   * <p>12:05 - 12:10 ids subranges deleted 12:05-12:07\n+   *\n+   * <p>delete 12:07 - 12:10\n+   *\n+   * <p>12:05 - 12:10 *removed*\n+   */\n+  static final class IdTracker {\n+    static final String IDS_AVAILABLE_STR = \"IdsAvailable\";\n+    static final String DELETIONS_STR = \"Deletions\";\n+\n+    static final long MIN_ID = Long.MIN_VALUE;\n+    static final long MAX_ID = Long.MAX_VALUE;\n+\n+    // We track ids on five-minute boundaries.\n+    private static final Duration RESOLUTION = Duration.standardMinutes(5);\n+    static final MapCoder<Range<Instant>, RangeSet<Long>> IDS_AVAILABLE_CODER =\n+        MapCoder.of(new RangeCoder<>(InstantCoder.of()), new RangeSetCoder<>(VarLongCoder.of()));\n+    static final MapCoder<Range<Instant>, RangeSet<Instant>> SUBRANGE_DELETIONS_CODER =\n+        MapCoder.of(new RangeCoder<>(InstantCoder.of()), new RangeSetCoder<>(InstantCoder.of()));\n+    private final StateTag<ValueState<Map<Range<Instant>, RangeSet<Long>>>> idsAvailableTag;\n+    // A map from five-minute ranges to the set of ids available in that interval.\n+    final ValueState<Map<Range<Instant>, RangeSet<Long>>> idsAvailableValue;\n+    private final StateTag<ValueState<Map<Range<Instant>, RangeSet<Instant>>>> subRangeDeletionsTag;\n+    // If a timestamp-range in the map has been partially cleared, the cleared intervals are stored\n+    // here.\n+    final ValueState<Map<Range<Instant>, RangeSet<Instant>>> subRangeDeletionsValue;\n+\n+    IdTracker(\n+        StateTable stateTable,\n+        StateNamespace namespace,\n+        StateTag<?> spec,\n+        String stateFamily,\n+        boolean complete) {\n+      this.idsAvailableTag =\n+          StateTags.makeSystemTagInternal(\n+              StateTags.value(spec.getId() + IDS_AVAILABLE_STR, IDS_AVAILABLE_CODER));\n+      this.idsAvailableValue =\n+          stateTable.get(namespace, idsAvailableTag, StateContexts.nullContext());\n+      this.subRangeDeletionsTag =\n+          StateTags.makeSystemTagInternal(\n+              StateTags.value(spec.getId() + DELETIONS_STR, SUBRANGE_DELETIONS_CODER));\n+      this.subRangeDeletionsValue =\n+          stateTable.get(namespace, subRangeDeletionsTag, StateContexts.nullContext());\n+    }\n+\n+    static <ValueT extends Comparable<? super ValueT>>\n+        Map<Range<Instant>, RangeSet<ValueT>> newSortedRangeMap(Class<ValueT> valueClass) {\n+      return Maps.newTreeMap(\n+          Comparator.<Range<Instant>, Instant>comparing(Range::lowerEndpoint)\n+              .thenComparing(Range::upperEndpoint));\n+    }\n+\n+    private Range<Instant> getTrackedRange(Instant ts) {\n+      Instant snapped =\n+          new Instant(ts.getMillis() - ts.plus(RESOLUTION).getMillis() % RESOLUTION.getMillis());\n+      return Range.closedOpen(snapped, snapped.plus(RESOLUTION));\n+    }\n+\n+    @SuppressWarnings(\"FutureReturnValueIgnored\")\n+    void readLater() {\n+      idsAvailableValue.readLater();\n+      subRangeDeletionsValue.readLater();\n+    }\n+\n+    Map<Range<Instant>, RangeSet<Long>> readIdsAvailable() {\n+      Map<Range<Instant>, RangeSet<Long>> idsAvailable = idsAvailableValue.read();\n+      return idsAvailable != null ? idsAvailable : newSortedRangeMap(Long.class);\n+    }\n+\n+    Map<Range<Instant>, RangeSet<Instant>> readSubRangeDeletions() {\n+      Map<Range<Instant>, RangeSet<Instant>> subRangeDeletions = subRangeDeletionsValue.read();\n+      return subRangeDeletions != null ? subRangeDeletions : newSortedRangeMap(Instant.class);\n+    }\n+\n+    void clear() throws ExecutionException, InterruptedException {\n+      idsAvailableValue.clear();\n+      subRangeDeletionsValue.clear();\n+    }\n+\n+    <T> void add(\n+        SortedSet<TimestampedValueWithId<T>> elements, BiConsumer<TimestampedValue<T>, Long> output)\n+        throws ExecutionException, InterruptedException {\n+      Range<Long> currentIdRange = null;\n+      long currentId = 0;\n+\n+      Range<Instant> currentTsRange = null;\n+      RangeSet<Instant> currentTsRangeDeletions = null;\n+\n+      Map<Range<Instant>, RangeSet<Long>> idsAvailable = readIdsAvailable();\n+      Map<Range<Instant>, RangeSet<Instant>> subRangeDeletions = readSubRangeDeletions();\n+\n+      RangeSet<Long> availableIdsForTsRange = null;\n+      Iterator<Range<Long>> idRangeIter = null;\n+      RangeSet<Long> idsUsed = TreeRangeSet.create();\n+      for (TimestampedValueWithId<T> pendingAdd : elements) {\n+        // Since elements are in increasing ts order, often we'll be able to reuse the previous\n+        // iteration's range.\n+        if (currentTsRange == null\n+            || !currentTsRange.contains(pendingAdd.getValue().getTimestamp())) {\n+          if (availableIdsForTsRange != null) {\n+            // We're moving onto a new ts range. Remove all used ids\n+            availableIdsForTsRange.removeAll(idsUsed);\n+            idsUsed = TreeRangeSet.create();\n+          }\n+\n+          // Lookup the range for the current timestamp.\n+          currentTsRange = getTrackedRange(pendingAdd.getValue().getTimestamp());\n+          // Lookup available ids for this timestamp range. If nothing there, we default to all ids\n+          // available.\n+          availableIdsForTsRange =\n+              idsAvailable.computeIfAbsent(\n+                  currentTsRange,\n+                  r -> TreeRangeSet.create(ImmutableList.of(Range.closedOpen(MIN_ID, MAX_ID))));\n+          idRangeIter = availableIdsForTsRange.asRanges().iterator();\n+          currentIdRange = null;\n+          currentTsRangeDeletions = subRangeDeletions.get(currentTsRange);\n+        }\n \n+        if (currentIdRange == null || currentId >= currentIdRange.upperEndpoint()) {\n+          // Move to the next range of free ids, and start assigning ranges from there.\n+          currentIdRange = idRangeIter.next();\n+          currentId = currentIdRange.lowerEndpoint();\n+        }\n+\n+        if (currentTsRangeDeletions != null) {\n+          currentTsRangeDeletions.remove(\n+              Range.closedOpen(\n+                  pendingAdd.getValue().getTimestamp(),\n+                  pendingAdd.getValue().getTimestamp().plus(1)));\n+        }\n+        idsUsed.add(Range.closedOpen(currentId, currentId + 1));\n+        output.accept(pendingAdd.getValue(), currentId++);\n+      }\n+      if (availableIdsForTsRange != null) {\n+        availableIdsForTsRange.removeAll(idsUsed);\n+      }\n+      idsAvailableValue.write(idsAvailable);\n+      subRangeDeletionsValue.write(subRangeDeletions);\n+    }\n+\n+    // Remove a timestamp range. Returns ids freed up.\n+    void remove(Range<Instant> tsRange) throws ExecutionException, InterruptedException {\n+      Map<Range<Instant>, RangeSet<Long>> idsAvailable = readIdsAvailable();\n+      Map<Range<Instant>, RangeSet<Instant>> subRangeDeletions = readSubRangeDeletions();\n+\n+      for (Range<Instant> current = getTrackedRange(tsRange.lowerEndpoint());\n+          current.lowerEndpoint().isBefore(tsRange.upperEndpoint());\n+          current = getTrackedRange(current.lowerEndpoint().plus(RESOLUTION))) {\n+        // TODO: shouldn't need to iterate over all ranges.\n+        boolean rangeCleared;\n+        if (!tsRange.encloses(current)) {\n+          // This can happen if the beginning or the end of tsRange doesn't fall on a RESOLUTION\n+          // boundary. Since we\n+          // are deleting a portion of a tracked range, track what we are deleting.\n+          RangeSet<Instant> rangeDeletions =\n+              subRangeDeletions.computeIfAbsent(current, r -> TreeRangeSet.create());\n+          rangeDeletions.add(tsRange.intersection(current));\n+          // If we ended up deleting the whole range, than we can simply remove it from the tracking\n+          // map.\n+          rangeCleared = rangeDeletions.encloses(current);\n+        } else {\n+          rangeCleared = true;\n+        }\n+        if (rangeCleared) {\n+          // Remove the range from both maps.\n+          idsAvailable.remove(current);\n+          subRangeDeletions.remove(current);\n+        }\n+      }\n+      idsAvailableValue.write(idsAvailable);\n+      subRangeDeletionsValue.write(subRangeDeletions);\n+    }\n+  }\n+\n+  @AutoValue\n+  abstract static class TimestampedValueWithId<T> {\n+    private static final Comparator<TimestampedValueWithId<?>> COMPARATOR =\n+        Comparator.<TimestampedValueWithId<?>, Instant>comparing(v -> v.getValue().getTimestamp())\n+            .thenComparingLong(TimestampedValueWithId::getId);\n+\n+    abstract TimestampedValue<T> getValue();\n+\n+    abstract long getId();\n+\n+    static <T> TimestampedValueWithId<T> of(TimestampedValue<T> value, long id) {\n+      return new AutoValue_WindmillStateInternals_TimestampedValueWithId<>(value, id);\n+    }\n+\n+    static <T> TimestampedValueWithId<T> bound(Instant ts) {\n+      return of(TimestampedValue.of(null, ts), Long.MIN_VALUE);\n+    }\n+  }\n+\n+  static class WindmillOrderedList<T> extends SimpleWindmillState implements OrderedListState<T> {\n     private final StateNamespace namespace;\n     private final StateTag<OrderedListState<T>> spec;\n     private final ByteString stateKey;\n     private final String stateFamily;\n     private final Coder<T> elemCoder;\n+    private boolean complete;\n+    private boolean cleared = false;\n+    // We need to sort based on timestamp, but we need objects with the same timestamp to be treated\n+    // as unique. We can't use a MultiSet as we can't construct a comparator that uniquely\n+    // identifies objects,\n+    // so we construct a unique in-memory long ids for each element.\n+    private SortedSet<TimestampedValueWithId<T>> pendingAdds =\n+        Sets.newTreeSet(TimestampedValueWithId.COMPARATOR);\n+\n+    private RangeSet<Instant> pendingDeletes = TreeRangeSet.create();\n+    private IdTracker idTracker;\n+\n+    // The default proto values for SortedListRange correspond to the minimum and maximum\n+    // timestamps.\n+    static final long MIN_TS_MICROS = SortedListRange.getDefaultInstance().getStart();\n+    static final long MAX_TS_MICROS = SortedListRange.getDefaultInstance().getLimit();\n \n     private WindmillOrderedList(\n+        StateTable derivedStateTable,\n         StateNamespace namespace,\n         StateTag<OrderedListState<T>> spec,\n         String stateFamily,\n         Coder<T> elemCoder,\n         boolean isNewKey) {\n       this.namespace = namespace;\n       this.spec = spec;\n+\n       this.stateKey = encodeKey(namespace, spec);\n       this.stateFamily = stateFamily;\n       this.elemCoder = elemCoder;\n+      this.complete = isNewKey;\n+      this.idTracker = new IdTracker(derivedStateTable, namespace, spec, stateFamily, complete);\n     }\n \n     @Override\n     public Iterable<TimestampedValue<T>> read() {\n-      throw new UnsupportedOperationException(\n-          String.format(\"%s is not supported\", OrderedListState.class.getSimpleName()));\n+      return readRange(null, null);\n+    }\n+\n+    private SortedSet<TimestampedValueWithId<T>> getPendingAddRange(\n+        @Nullable Instant minTimestamp, @Nullable Instant limitTimestamp) {\n+      SortedSet<TimestampedValueWithId<T>> pendingInRange = pendingAdds;\n+      if (minTimestamp != null && limitTimestamp != null) {\n+        pendingInRange =\n+            pendingInRange.subSet(\n+                TimestampedValueWithId.bound(minTimestamp),\n+                TimestampedValueWithId.bound(limitTimestamp));\n+      } else if (minTimestamp == null && limitTimestamp != null) {\n+        pendingInRange = pendingInRange.headSet(TimestampedValueWithId.bound(limitTimestamp));\n+      } else if (limitTimestamp == null && minTimestamp != null) {\n+        pendingInRange = pendingInRange.tailSet(TimestampedValueWithId.bound(minTimestamp));\n+      }\n+      return pendingInRange;\n     }\n \n     @Override\n-    public Iterable<TimestampedValue<T>> readRange(Instant minTimestamp, Instant limitTimestamp) {\n-      throw new UnsupportedOperationException(\n-          String.format(\"%s is not supported\", OrderedListState.class.getSimpleName()));\n+    public Iterable<TimestampedValue<T>> readRange(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51f72ea52a7e3883fbbf0a0fe79d3c1a82c8ac14"}, "originalPosition": 564}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNzExODEy", "url": "https://github.com/apache/beam/pull/12864#pullrequestreview-493711812", "createdAt": "2020-09-22T17:55:45Z", "commit": {"oid": "51f72ea52a7e3883fbbf0a0fe79d3c1a82c8ac14"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNzo1NTo0NlrOHWF69g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMDo0Njo0M1rOHWRHNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkyNzczNA==", "bodyText": "This should probably extend StructuredCoder instead of CustomCoder, although it may not matter if it's never serialized.  If you leave it as CustomCoder, implement hashCode and equals", "url": "https://github.com/apache/beam/pull/12864#discussion_r492927734", "createdAt": "2020-09-22T17:55:46Z", "author": {"login": "dpmills"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateInternals.java", "diffHunk": "@@ -470,81 +541,514 @@ protected WorkItemCommitRequest persistDirectly(WindmillStateCache.ForKey cache)\n     }\n   }\n \n-  private static class WindmillOrderedList<T> extends SimpleWindmillState\n-      implements OrderedListState<T> {\n+  // Coder for closed-open ranges.\n+  private static class RangeCoder<T extends Comparable> extends CustomCoder<Range<T>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51f72ea52a7e3883fbbf0a0fe79d3c1a82c8ac14"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzEwOTAzNQ==", "bodyText": "Could simplify this a little with DelegateCoder", "url": "https://github.com/apache/beam/pull/12864#discussion_r493109035", "createdAt": "2020-09-23T00:38:42Z", "author": {"login": "dpmills"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateInternals.java", "diffHunk": "@@ -470,81 +541,514 @@ protected WorkItemCommitRequest persistDirectly(WindmillStateCache.ForKey cache)\n     }\n   }\n \n-  private static class WindmillOrderedList<T> extends SimpleWindmillState\n-      implements OrderedListState<T> {\n+  // Coder for closed-open ranges.\n+  private static class RangeCoder<T extends Comparable> extends CustomCoder<Range<T>> {\n+    private Coder<T> boundCoder;\n+\n+    RangeCoder(Coder<T> boundCoder) {\n+      this.boundCoder = NullableCoder.of(boundCoder);\n+    }\n+\n+    @Override\n+    public void encode(Range<T> value, OutputStream outStream) throws CoderException, IOException {\n+      Preconditions.checkState(\n+          value.lowerBoundType().equals(BoundType.CLOSED), \"unexpected range \" + value);\n+      Preconditions.checkState(\n+          value.upperBoundType().equals(BoundType.OPEN), \"unexpected range \" + value);\n+      boundCoder.encode(value.hasLowerBound() ? value.lowerEndpoint() : null, outStream);\n+      boundCoder.encode(value.hasUpperBound() ? value.upperEndpoint() : null, outStream);\n+    }\n+\n+    @Override\n+    public Range<T> decode(InputStream inStream) throws CoderException, IOException {\n+      @Nullable T lower = boundCoder.decode(inStream);\n+      @Nullable T upper = boundCoder.decode(inStream);\n+      if (lower == null) {\n+        return upper != null ? Range.lessThan(upper) : Range.all();\n+      } else if (upper == null) {\n+        return Range.atLeast(lower);\n+      } else {\n+        return Range.closedOpen(lower, upper);\n+      }\n+    }\n+  }\n+\n+  private static class RangeSetCoder<T extends Comparable> extends CustomCoder<RangeSet<T>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51f72ea52a7e3883fbbf0a0fe79d3c1a82c8ac14"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExMDQ3Mg==", "bodyText": "For all of these \"millis * 1000\" calls, use WindmillTimeUtils.harnessToWindmillTimestamp()", "url": "https://github.com/apache/beam/pull/12864#discussion_r493110472", "createdAt": "2020-09-23T00:44:19Z", "author": {"login": "dpmills"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateInternals.java", "diffHunk": "@@ -470,81 +541,514 @@ protected WorkItemCommitRequest persistDirectly(WindmillStateCache.ForKey cache)\n     }\n   }\n \n-  private static class WindmillOrderedList<T> extends SimpleWindmillState\n-      implements OrderedListState<T> {\n+  // Coder for closed-open ranges.\n+  private static class RangeCoder<T extends Comparable> extends CustomCoder<Range<T>> {\n+    private Coder<T> boundCoder;\n+\n+    RangeCoder(Coder<T> boundCoder) {\n+      this.boundCoder = NullableCoder.of(boundCoder);\n+    }\n+\n+    @Override\n+    public void encode(Range<T> value, OutputStream outStream) throws CoderException, IOException {\n+      Preconditions.checkState(\n+          value.lowerBoundType().equals(BoundType.CLOSED), \"unexpected range \" + value);\n+      Preconditions.checkState(\n+          value.upperBoundType().equals(BoundType.OPEN), \"unexpected range \" + value);\n+      boundCoder.encode(value.hasLowerBound() ? value.lowerEndpoint() : null, outStream);\n+      boundCoder.encode(value.hasUpperBound() ? value.upperEndpoint() : null, outStream);\n+    }\n+\n+    @Override\n+    public Range<T> decode(InputStream inStream) throws CoderException, IOException {\n+      @Nullable T lower = boundCoder.decode(inStream);\n+      @Nullable T upper = boundCoder.decode(inStream);\n+      if (lower == null) {\n+        return upper != null ? Range.lessThan(upper) : Range.all();\n+      } else if (upper == null) {\n+        return Range.atLeast(lower);\n+      } else {\n+        return Range.closedOpen(lower, upper);\n+      }\n+    }\n+  }\n+\n+  private static class RangeSetCoder<T extends Comparable> extends CustomCoder<RangeSet<T>> {\n+    private SetCoder<Range<T>> rangesCoder;\n+\n+    RangeSetCoder(Coder<T> boundCoder) {\n+      this.rangesCoder = SetCoder.of(new RangeCoder<>(boundCoder));\n+    }\n+\n+    @Override\n+    public void encode(RangeSet<T> value, OutputStream outStream) throws IOException {\n+      rangesCoder.encode(value.asRanges(), outStream);\n+    }\n+\n+    @Override\n+    public RangeSet<T> decode(InputStream inStream) throws CoderException, IOException {\n+      return TreeRangeSet.create(rangesCoder.decode(inStream));\n+    }\n+  }\n+\n+  /**\n+   * Tracker for the ids used in an ordered list.\n+   *\n+   * <p>Windmill accepts an int64 id for each timestamped-element in the list. Unique elements are\n+   * identified by the pair of timestamp and id. This means that tow unique elements e1, e2 must\n+   * have different (ts1, id1), (ts2, id2) pairs. To accomplish this we bucket time into five-minute\n+   * buckets, and store a free list of ids available for each bucket.\n+   *\n+   * <p>When a timestamp range is deleted, we remove id tracking for elements in that range. In\n+   * order to handle the case where a range is deleted piecemeal, we track sub-range deletions for\n+   * each range. For example:\n+   *\n+   * <p>12:00 - 12:05 ids 12:05 - 12:10 ids\n+   *\n+   * <p>delete 12:00-12:06\n+   *\n+   * <p>12:00 - 12:05 *removed* 12:05 - 12:10 ids subranges deleted 12:05-12:06\n+   *\n+   * <p>delete 12:06 - 12:07\n+   *\n+   * <p>12:05 - 12:10 ids subranges deleted 12:05-12:07\n+   *\n+   * <p>delete 12:07 - 12:10\n+   *\n+   * <p>12:05 - 12:10 *removed*\n+   */\n+  static final class IdTracker {\n+    static final String IDS_AVAILABLE_STR = \"IdsAvailable\";\n+    static final String DELETIONS_STR = \"Deletions\";\n+\n+    static final long MIN_ID = Long.MIN_VALUE;\n+    static final long MAX_ID = Long.MAX_VALUE;\n+\n+    // We track ids on five-minute boundaries.\n+    private static final Duration RESOLUTION = Duration.standardMinutes(5);\n+    static final MapCoder<Range<Instant>, RangeSet<Long>> IDS_AVAILABLE_CODER =\n+        MapCoder.of(new RangeCoder<>(InstantCoder.of()), new RangeSetCoder<>(VarLongCoder.of()));\n+    static final MapCoder<Range<Instant>, RangeSet<Instant>> SUBRANGE_DELETIONS_CODER =\n+        MapCoder.of(new RangeCoder<>(InstantCoder.of()), new RangeSetCoder<>(InstantCoder.of()));\n+    private final StateTag<ValueState<Map<Range<Instant>, RangeSet<Long>>>> idsAvailableTag;\n+    // A map from five-minute ranges to the set of ids available in that interval.\n+    final ValueState<Map<Range<Instant>, RangeSet<Long>>> idsAvailableValue;\n+    private final StateTag<ValueState<Map<Range<Instant>, RangeSet<Instant>>>> subRangeDeletionsTag;\n+    // If a timestamp-range in the map has been partially cleared, the cleared intervals are stored\n+    // here.\n+    final ValueState<Map<Range<Instant>, RangeSet<Instant>>> subRangeDeletionsValue;\n+\n+    IdTracker(\n+        StateTable stateTable,\n+        StateNamespace namespace,\n+        StateTag<?> spec,\n+        String stateFamily,\n+        boolean complete) {\n+      this.idsAvailableTag =\n+          StateTags.makeSystemTagInternal(\n+              StateTags.value(spec.getId() + IDS_AVAILABLE_STR, IDS_AVAILABLE_CODER));\n+      this.idsAvailableValue =\n+          stateTable.get(namespace, idsAvailableTag, StateContexts.nullContext());\n+      this.subRangeDeletionsTag =\n+          StateTags.makeSystemTagInternal(\n+              StateTags.value(spec.getId() + DELETIONS_STR, SUBRANGE_DELETIONS_CODER));\n+      this.subRangeDeletionsValue =\n+          stateTable.get(namespace, subRangeDeletionsTag, StateContexts.nullContext());\n+    }\n+\n+    static <ValueT extends Comparable<? super ValueT>>\n+        Map<Range<Instant>, RangeSet<ValueT>> newSortedRangeMap(Class<ValueT> valueClass) {\n+      return Maps.newTreeMap(\n+          Comparator.<Range<Instant>, Instant>comparing(Range::lowerEndpoint)\n+              .thenComparing(Range::upperEndpoint));\n+    }\n+\n+    private Range<Instant> getTrackedRange(Instant ts) {\n+      Instant snapped =\n+          new Instant(ts.getMillis() - ts.plus(RESOLUTION).getMillis() % RESOLUTION.getMillis());\n+      return Range.closedOpen(snapped, snapped.plus(RESOLUTION));\n+    }\n+\n+    @SuppressWarnings(\"FutureReturnValueIgnored\")\n+    void readLater() {\n+      idsAvailableValue.readLater();\n+      subRangeDeletionsValue.readLater();\n+    }\n+\n+    Map<Range<Instant>, RangeSet<Long>> readIdsAvailable() {\n+      Map<Range<Instant>, RangeSet<Long>> idsAvailable = idsAvailableValue.read();\n+      return idsAvailable != null ? idsAvailable : newSortedRangeMap(Long.class);\n+    }\n+\n+    Map<Range<Instant>, RangeSet<Instant>> readSubRangeDeletions() {\n+      Map<Range<Instant>, RangeSet<Instant>> subRangeDeletions = subRangeDeletionsValue.read();\n+      return subRangeDeletions != null ? subRangeDeletions : newSortedRangeMap(Instant.class);\n+    }\n+\n+    void clear() throws ExecutionException, InterruptedException {\n+      idsAvailableValue.clear();\n+      subRangeDeletionsValue.clear();\n+    }\n+\n+    <T> void add(\n+        SortedSet<TimestampedValueWithId<T>> elements, BiConsumer<TimestampedValue<T>, Long> output)\n+        throws ExecutionException, InterruptedException {\n+      Range<Long> currentIdRange = null;\n+      long currentId = 0;\n+\n+      Range<Instant> currentTsRange = null;\n+      RangeSet<Instant> currentTsRangeDeletions = null;\n+\n+      Map<Range<Instant>, RangeSet<Long>> idsAvailable = readIdsAvailable();\n+      Map<Range<Instant>, RangeSet<Instant>> subRangeDeletions = readSubRangeDeletions();\n+\n+      RangeSet<Long> availableIdsForTsRange = null;\n+      Iterator<Range<Long>> idRangeIter = null;\n+      RangeSet<Long> idsUsed = TreeRangeSet.create();\n+      for (TimestampedValueWithId<T> pendingAdd : elements) {\n+        // Since elements are in increasing ts order, often we'll be able to reuse the previous\n+        // iteration's range.\n+        if (currentTsRange == null\n+            || !currentTsRange.contains(pendingAdd.getValue().getTimestamp())) {\n+          if (availableIdsForTsRange != null) {\n+            // We're moving onto a new ts range. Remove all used ids\n+            availableIdsForTsRange.removeAll(idsUsed);\n+            idsUsed = TreeRangeSet.create();\n+          }\n+\n+          // Lookup the range for the current timestamp.\n+          currentTsRange = getTrackedRange(pendingAdd.getValue().getTimestamp());\n+          // Lookup available ids for this timestamp range. If nothing there, we default to all ids\n+          // available.\n+          availableIdsForTsRange =\n+              idsAvailable.computeIfAbsent(\n+                  currentTsRange,\n+                  r -> TreeRangeSet.create(ImmutableList.of(Range.closedOpen(MIN_ID, MAX_ID))));\n+          idRangeIter = availableIdsForTsRange.asRanges().iterator();\n+          currentIdRange = null;\n+          currentTsRangeDeletions = subRangeDeletions.get(currentTsRange);\n+        }\n \n+        if (currentIdRange == null || currentId >= currentIdRange.upperEndpoint()) {\n+          // Move to the next range of free ids, and start assigning ranges from there.\n+          currentIdRange = idRangeIter.next();\n+          currentId = currentIdRange.lowerEndpoint();\n+        }\n+\n+        if (currentTsRangeDeletions != null) {\n+          currentTsRangeDeletions.remove(\n+              Range.closedOpen(\n+                  pendingAdd.getValue().getTimestamp(),\n+                  pendingAdd.getValue().getTimestamp().plus(1)));\n+        }\n+        idsUsed.add(Range.closedOpen(currentId, currentId + 1));\n+        output.accept(pendingAdd.getValue(), currentId++);\n+      }\n+      if (availableIdsForTsRange != null) {\n+        availableIdsForTsRange.removeAll(idsUsed);\n+      }\n+      idsAvailableValue.write(idsAvailable);\n+      subRangeDeletionsValue.write(subRangeDeletions);\n+    }\n+\n+    // Remove a timestamp range. Returns ids freed up.\n+    void remove(Range<Instant> tsRange) throws ExecutionException, InterruptedException {\n+      Map<Range<Instant>, RangeSet<Long>> idsAvailable = readIdsAvailable();\n+      Map<Range<Instant>, RangeSet<Instant>> subRangeDeletions = readSubRangeDeletions();\n+\n+      for (Range<Instant> current = getTrackedRange(tsRange.lowerEndpoint());\n+          current.lowerEndpoint().isBefore(tsRange.upperEndpoint());\n+          current = getTrackedRange(current.lowerEndpoint().plus(RESOLUTION))) {\n+        // TODO: shouldn't need to iterate over all ranges.\n+        boolean rangeCleared;\n+        if (!tsRange.encloses(current)) {\n+          // This can happen if the beginning or the end of tsRange doesn't fall on a RESOLUTION\n+          // boundary. Since we\n+          // are deleting a portion of a tracked range, track what we are deleting.\n+          RangeSet<Instant> rangeDeletions =\n+              subRangeDeletions.computeIfAbsent(current, r -> TreeRangeSet.create());\n+          rangeDeletions.add(tsRange.intersection(current));\n+          // If we ended up deleting the whole range, than we can simply remove it from the tracking\n+          // map.\n+          rangeCleared = rangeDeletions.encloses(current);\n+        } else {\n+          rangeCleared = true;\n+        }\n+        if (rangeCleared) {\n+          // Remove the range from both maps.\n+          idsAvailable.remove(current);\n+          subRangeDeletions.remove(current);\n+        }\n+      }\n+      idsAvailableValue.write(idsAvailable);\n+      subRangeDeletionsValue.write(subRangeDeletions);\n+    }\n+  }\n+\n+  @AutoValue\n+  abstract static class TimestampedValueWithId<T> {\n+    private static final Comparator<TimestampedValueWithId<?>> COMPARATOR =\n+        Comparator.<TimestampedValueWithId<?>, Instant>comparing(v -> v.getValue().getTimestamp())\n+            .thenComparingLong(TimestampedValueWithId::getId);\n+\n+    abstract TimestampedValue<T> getValue();\n+\n+    abstract long getId();\n+\n+    static <T> TimestampedValueWithId<T> of(TimestampedValue<T> value, long id) {\n+      return new AutoValue_WindmillStateInternals_TimestampedValueWithId<>(value, id);\n+    }\n+\n+    static <T> TimestampedValueWithId<T> bound(Instant ts) {\n+      return of(TimestampedValue.of(null, ts), Long.MIN_VALUE);\n+    }\n+  }\n+\n+  static class WindmillOrderedList<T> extends SimpleWindmillState implements OrderedListState<T> {\n     private final StateNamespace namespace;\n     private final StateTag<OrderedListState<T>> spec;\n     private final ByteString stateKey;\n     private final String stateFamily;\n     private final Coder<T> elemCoder;\n+    private boolean complete;\n+    private boolean cleared = false;\n+    // We need to sort based on timestamp, but we need objects with the same timestamp to be treated\n+    // as unique. We can't use a MultiSet as we can't construct a comparator that uniquely\n+    // identifies objects,\n+    // so we construct a unique in-memory long ids for each element.\n+    private SortedSet<TimestampedValueWithId<T>> pendingAdds =\n+        Sets.newTreeSet(TimestampedValueWithId.COMPARATOR);\n+\n+    private RangeSet<Instant> pendingDeletes = TreeRangeSet.create();\n+    private IdTracker idTracker;\n+\n+    // The default proto values for SortedListRange correspond to the minimum and maximum\n+    // timestamps.\n+    static final long MIN_TS_MICROS = SortedListRange.getDefaultInstance().getStart();\n+    static final long MAX_TS_MICROS = SortedListRange.getDefaultInstance().getLimit();\n \n     private WindmillOrderedList(\n+        StateTable derivedStateTable,\n         StateNamespace namespace,\n         StateTag<OrderedListState<T>> spec,\n         String stateFamily,\n         Coder<T> elemCoder,\n         boolean isNewKey) {\n       this.namespace = namespace;\n       this.spec = spec;\n+\n       this.stateKey = encodeKey(namespace, spec);\n       this.stateFamily = stateFamily;\n       this.elemCoder = elemCoder;\n+      this.complete = isNewKey;\n+      this.idTracker = new IdTracker(derivedStateTable, namespace, spec, stateFamily, complete);\n     }\n \n     @Override\n     public Iterable<TimestampedValue<T>> read() {\n-      throw new UnsupportedOperationException(\n-          String.format(\"%s is not supported\", OrderedListState.class.getSimpleName()));\n+      return readRange(null, null);\n+    }\n+\n+    private SortedSet<TimestampedValueWithId<T>> getPendingAddRange(\n+        @Nullable Instant minTimestamp, @Nullable Instant limitTimestamp) {\n+      SortedSet<TimestampedValueWithId<T>> pendingInRange = pendingAdds;\n+      if (minTimestamp != null && limitTimestamp != null) {\n+        pendingInRange =\n+            pendingInRange.subSet(\n+                TimestampedValueWithId.bound(minTimestamp),\n+                TimestampedValueWithId.bound(limitTimestamp));\n+      } else if (minTimestamp == null && limitTimestamp != null) {\n+        pendingInRange = pendingInRange.headSet(TimestampedValueWithId.bound(limitTimestamp));\n+      } else if (limitTimestamp == null && minTimestamp != null) {\n+        pendingInRange = pendingInRange.tailSet(TimestampedValueWithId.bound(minTimestamp));\n+      }\n+      return pendingInRange;\n     }\n \n     @Override\n-    public Iterable<TimestampedValue<T>> readRange(Instant minTimestamp, Instant limitTimestamp) {\n-      throw new UnsupportedOperationException(\n-          String.format(\"%s is not supported\", OrderedListState.class.getSimpleName()));\n+    public Iterable<TimestampedValue<T>> readRange(\n+        @Nullable Instant minTimestamp, @Nullable Instant limitTimestamp) {\n+      idTracker.readLater();\n+\n+      final Future<Iterable<TimestampedValue<T>>> future = getFuture(minTimestamp, limitTimestamp);\n+      try (Closeable scope = scopedReadState()) {\n+        SortedSet<TimestampedValueWithId<T>> pendingInRange =\n+            getPendingAddRange(minTimestamp, limitTimestamp);\n+\n+        // Transform the return iterator so it has the same type as pendingAdds. We need to ensure\n+        // that the ids don't overlap with any in pendingAdds, so begin with pendingAdfds.size().\n+        Iterable<TimestampedValueWithId<T>> data =\n+            new Iterable<TimestampedValueWithId<T>>() {\n+              private Iterator<TimestampedValue<T>> iter = future.get().iterator();\n+\n+              @Override\n+              public Iterator<TimestampedValueWithId<T>> iterator() {\n+                return new Iterator<TimestampedValueWithId<T>>() {\n+                  private long currentId = pendingAdds.size();\n+\n+                  @Override\n+                  public boolean hasNext() {\n+                    return iter.hasNext();\n+                  }\n+\n+                  @Override\n+                  public TimestampedValueWithId<T> next() {\n+                    return TimestampedValueWithId.of(iter.next(), currentId++);\n+                  }\n+                };\n+              }\n+            };\n+\n+        Iterable<TimestampedValueWithId<T>> includingAdds =\n+            Iterables.mergeSorted(\n+                ImmutableList.of(data, pendingInRange), TimestampedValueWithId.COMPARATOR);\n+\n+        Iterable<TimestampedValue<T>> fullIterable =\n+            Iterables.filter(\n+                Iterables.transform(includingAdds, TimestampedValueWithId::getValue),\n+                tv -> !pendingDeletes.contains(tv.getTimestamp()));\n+        // TODO: If we have a known bounded amount of data, cache known ranges.\n+        return fullIterable;\n+      } catch (InterruptedException | ExecutionException | IOException e) {\n+        if (e instanceof InterruptedException) {\n+          Thread.currentThread().interrupt();\n+        }\n+        throw new RuntimeException(\"Unable to read state\", e);\n+      }\n     }\n \n     @Override\n     public void clear() {\n-      throw new UnsupportedOperationException(\n-          String.format(\"%s is not supported\", OrderedListState.class.getSimpleName()));\n+      cleared = true;\n+      complete = true;\n+      pendingAdds.clear();\n+      pendingDeletes.clear();\n+      try {\n+        idTracker.clear();\n+      } catch (ExecutionException | InterruptedException e) {\n+        throw new RuntimeException(e);\n+      }\n     }\n \n     @Override\n     public void clearRange(Instant minTimestamp, Instant limitTimestamp) {\n-      throw new UnsupportedOperationException(\n-          String.format(\"%s is not supported\", OrderedListState.class.getSimpleName()));\n+      getPendingAddRange(minTimestamp, limitTimestamp).clear();\n+      pendingDeletes.add(Range.closedOpen(minTimestamp, limitTimestamp));\n     }\n \n     @Override\n     public void add(TimestampedValue<T> value) {\n-      throw new UnsupportedOperationException(\n-          String.format(\"%s is not supported\", OrderedListState.class.getSimpleName()));\n+      // We use the current size of the container as the in-memory id. This works because\n+      // pendingAdds is completely\n+      // cleared when it is processed (otherwise we could end up with duplicate elements in the same\n+      // container). These\n+      // are not the ids that will be sent to windmill.\n+      pendingAdds.add(TimestampedValueWithId.of(value, pendingAdds.size()));\n+      // Leave pendingDeletes alone. Since we can have multiple values with the same timestamp, we\n+      // may still need\n+      // overlapping deletes to remove previous entries at this timestamp.\n     }\n \n     @Override\n     public ReadableState<Boolean> isEmpty() {\n-      throw new UnsupportedOperationException(\n-          String.format(\"%s is not supported\", OrderedListState.class.getSimpleName()));\n+      return new ReadableState<Boolean>() {\n+        @Override\n+        public ReadableState<Boolean> readLater() {\n+          WindmillOrderedList.this.readLater();\n+          return this;\n+        }\n+\n+        @Override\n+        public Boolean read() {\n+          return Iterables.isEmpty(WindmillOrderedList.this.read());\n+        }\n+      };\n     }\n \n     @Override\n     public OrderedListState<T> readLater() {\n-      throw new UnsupportedOperationException(\n-          String.format(\"%s is not supported\", OrderedListState.class.getSimpleName()));\n+      return readRangeLater(null, null);\n     }\n \n     @Override\n-    public OrderedListState<T> readRangeLater(Instant minTimestamp, Instant limitTimestamp) {\n-      throw new UnsupportedOperationException(\n-          String.format(\"%s is not supported\", OrderedListState.class.getSimpleName()));\n+    @SuppressWarnings(\"FutureReturnValueIgnored\")\n+    public OrderedListState<T> readRangeLater(\n+        @Nullable Instant minTimestamp, @Nullable Instant limitTimestamp) {\n+      idTracker.readLater();\n+      getFuture(minTimestamp, limitTimestamp);\n+      return this;\n     }\n \n     @Override\n     public WorkItemCommitRequest persistDirectly(ForKey cache) throws IOException {\n       WorkItemCommitRequest.Builder commitBuilder = WorkItemCommitRequest.newBuilder();\n+      TagSortedListUpdateRequest.Builder updatesBuilder =\n+          commitBuilder.addSortedListUpdatesBuilder().setStateFamily(stateFamily).setTag(stateKey);\n+      try {\n+        if (cleared) {\n+          // Default range.\n+          updatesBuilder.addDeletesBuilder().build();\n+          cleared = false;\n+        }\n+\n+        if (!pendingAdds.isEmpty()) {\n+          // TODO: Once we start caching data, we should remove this line. We have it here now\n+          // because once we persist\n+          // added data we forget about it from the cache, so the object is no longer complete.\n+          complete = false;\n+\n+          TagSortedListInsertRequest.Builder insertBuilder = updatesBuilder.addInsertsBuilder();\n+          idTracker.add(\n+              pendingAdds,\n+              (elem, id) -> {\n+                try {\n+                  ByteString.Output elementStream = ByteString.newOutput();\n+                  elemCoder.encode(elem.getValue(), elementStream, Context.OUTER);\n+                  insertBuilder.addEntries(\n+                      SortedListEntry.newBuilder()\n+                          .setValue(elementStream.toByteString())\n+                          .setSortKey(elem.getTimestamp().getMillis() * 1000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51f72ea52a7e3883fbbf0a0fe79d3c1a82c8ac14"}, "originalPosition": 718}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExMDc4NA==", "bodyText": "Put your username or a JIRA issue in the TODOs", "url": "https://github.com/apache/beam/pull/12864#discussion_r493110784", "createdAt": "2020-09-23T00:45:26Z", "author": {"login": "dpmills"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateInternals.java", "diffHunk": "@@ -470,81 +541,514 @@ protected WorkItemCommitRequest persistDirectly(WindmillStateCache.ForKey cache)\n     }\n   }\n \n-  private static class WindmillOrderedList<T> extends SimpleWindmillState\n-      implements OrderedListState<T> {\n+  // Coder for closed-open ranges.\n+  private static class RangeCoder<T extends Comparable> extends CustomCoder<Range<T>> {\n+    private Coder<T> boundCoder;\n+\n+    RangeCoder(Coder<T> boundCoder) {\n+      this.boundCoder = NullableCoder.of(boundCoder);\n+    }\n+\n+    @Override\n+    public void encode(Range<T> value, OutputStream outStream) throws CoderException, IOException {\n+      Preconditions.checkState(\n+          value.lowerBoundType().equals(BoundType.CLOSED), \"unexpected range \" + value);\n+      Preconditions.checkState(\n+          value.upperBoundType().equals(BoundType.OPEN), \"unexpected range \" + value);\n+      boundCoder.encode(value.hasLowerBound() ? value.lowerEndpoint() : null, outStream);\n+      boundCoder.encode(value.hasUpperBound() ? value.upperEndpoint() : null, outStream);\n+    }\n+\n+    @Override\n+    public Range<T> decode(InputStream inStream) throws CoderException, IOException {\n+      @Nullable T lower = boundCoder.decode(inStream);\n+      @Nullable T upper = boundCoder.decode(inStream);\n+      if (lower == null) {\n+        return upper != null ? Range.lessThan(upper) : Range.all();\n+      } else if (upper == null) {\n+        return Range.atLeast(lower);\n+      } else {\n+        return Range.closedOpen(lower, upper);\n+      }\n+    }\n+  }\n+\n+  private static class RangeSetCoder<T extends Comparable> extends CustomCoder<RangeSet<T>> {\n+    private SetCoder<Range<T>> rangesCoder;\n+\n+    RangeSetCoder(Coder<T> boundCoder) {\n+      this.rangesCoder = SetCoder.of(new RangeCoder<>(boundCoder));\n+    }\n+\n+    @Override\n+    public void encode(RangeSet<T> value, OutputStream outStream) throws IOException {\n+      rangesCoder.encode(value.asRanges(), outStream);\n+    }\n+\n+    @Override\n+    public RangeSet<T> decode(InputStream inStream) throws CoderException, IOException {\n+      return TreeRangeSet.create(rangesCoder.decode(inStream));\n+    }\n+  }\n+\n+  /**\n+   * Tracker for the ids used in an ordered list.\n+   *\n+   * <p>Windmill accepts an int64 id for each timestamped-element in the list. Unique elements are\n+   * identified by the pair of timestamp and id. This means that tow unique elements e1, e2 must\n+   * have different (ts1, id1), (ts2, id2) pairs. To accomplish this we bucket time into five-minute\n+   * buckets, and store a free list of ids available for each bucket.\n+   *\n+   * <p>When a timestamp range is deleted, we remove id tracking for elements in that range. In\n+   * order to handle the case where a range is deleted piecemeal, we track sub-range deletions for\n+   * each range. For example:\n+   *\n+   * <p>12:00 - 12:05 ids 12:05 - 12:10 ids\n+   *\n+   * <p>delete 12:00-12:06\n+   *\n+   * <p>12:00 - 12:05 *removed* 12:05 - 12:10 ids subranges deleted 12:05-12:06\n+   *\n+   * <p>delete 12:06 - 12:07\n+   *\n+   * <p>12:05 - 12:10 ids subranges deleted 12:05-12:07\n+   *\n+   * <p>delete 12:07 - 12:10\n+   *\n+   * <p>12:05 - 12:10 *removed*\n+   */\n+  static final class IdTracker {\n+    static final String IDS_AVAILABLE_STR = \"IdsAvailable\";\n+    static final String DELETIONS_STR = \"Deletions\";\n+\n+    static final long MIN_ID = Long.MIN_VALUE;\n+    static final long MAX_ID = Long.MAX_VALUE;\n+\n+    // We track ids on five-minute boundaries.\n+    private static final Duration RESOLUTION = Duration.standardMinutes(5);\n+    static final MapCoder<Range<Instant>, RangeSet<Long>> IDS_AVAILABLE_CODER =\n+        MapCoder.of(new RangeCoder<>(InstantCoder.of()), new RangeSetCoder<>(VarLongCoder.of()));\n+    static final MapCoder<Range<Instant>, RangeSet<Instant>> SUBRANGE_DELETIONS_CODER =\n+        MapCoder.of(new RangeCoder<>(InstantCoder.of()), new RangeSetCoder<>(InstantCoder.of()));\n+    private final StateTag<ValueState<Map<Range<Instant>, RangeSet<Long>>>> idsAvailableTag;\n+    // A map from five-minute ranges to the set of ids available in that interval.\n+    final ValueState<Map<Range<Instant>, RangeSet<Long>>> idsAvailableValue;\n+    private final StateTag<ValueState<Map<Range<Instant>, RangeSet<Instant>>>> subRangeDeletionsTag;\n+    // If a timestamp-range in the map has been partially cleared, the cleared intervals are stored\n+    // here.\n+    final ValueState<Map<Range<Instant>, RangeSet<Instant>>> subRangeDeletionsValue;\n+\n+    IdTracker(\n+        StateTable stateTable,\n+        StateNamespace namespace,\n+        StateTag<?> spec,\n+        String stateFamily,\n+        boolean complete) {\n+      this.idsAvailableTag =\n+          StateTags.makeSystemTagInternal(\n+              StateTags.value(spec.getId() + IDS_AVAILABLE_STR, IDS_AVAILABLE_CODER));\n+      this.idsAvailableValue =\n+          stateTable.get(namespace, idsAvailableTag, StateContexts.nullContext());\n+      this.subRangeDeletionsTag =\n+          StateTags.makeSystemTagInternal(\n+              StateTags.value(spec.getId() + DELETIONS_STR, SUBRANGE_DELETIONS_CODER));\n+      this.subRangeDeletionsValue =\n+          stateTable.get(namespace, subRangeDeletionsTag, StateContexts.nullContext());\n+    }\n+\n+    static <ValueT extends Comparable<? super ValueT>>\n+        Map<Range<Instant>, RangeSet<ValueT>> newSortedRangeMap(Class<ValueT> valueClass) {\n+      return Maps.newTreeMap(\n+          Comparator.<Range<Instant>, Instant>comparing(Range::lowerEndpoint)\n+              .thenComparing(Range::upperEndpoint));\n+    }\n+\n+    private Range<Instant> getTrackedRange(Instant ts) {\n+      Instant snapped =\n+          new Instant(ts.getMillis() - ts.plus(RESOLUTION).getMillis() % RESOLUTION.getMillis());\n+      return Range.closedOpen(snapped, snapped.plus(RESOLUTION));\n+    }\n+\n+    @SuppressWarnings(\"FutureReturnValueIgnored\")\n+    void readLater() {\n+      idsAvailableValue.readLater();\n+      subRangeDeletionsValue.readLater();\n+    }\n+\n+    Map<Range<Instant>, RangeSet<Long>> readIdsAvailable() {\n+      Map<Range<Instant>, RangeSet<Long>> idsAvailable = idsAvailableValue.read();\n+      return idsAvailable != null ? idsAvailable : newSortedRangeMap(Long.class);\n+    }\n+\n+    Map<Range<Instant>, RangeSet<Instant>> readSubRangeDeletions() {\n+      Map<Range<Instant>, RangeSet<Instant>> subRangeDeletions = subRangeDeletionsValue.read();\n+      return subRangeDeletions != null ? subRangeDeletions : newSortedRangeMap(Instant.class);\n+    }\n+\n+    void clear() throws ExecutionException, InterruptedException {\n+      idsAvailableValue.clear();\n+      subRangeDeletionsValue.clear();\n+    }\n+\n+    <T> void add(\n+        SortedSet<TimestampedValueWithId<T>> elements, BiConsumer<TimestampedValue<T>, Long> output)\n+        throws ExecutionException, InterruptedException {\n+      Range<Long> currentIdRange = null;\n+      long currentId = 0;\n+\n+      Range<Instant> currentTsRange = null;\n+      RangeSet<Instant> currentTsRangeDeletions = null;\n+\n+      Map<Range<Instant>, RangeSet<Long>> idsAvailable = readIdsAvailable();\n+      Map<Range<Instant>, RangeSet<Instant>> subRangeDeletions = readSubRangeDeletions();\n+\n+      RangeSet<Long> availableIdsForTsRange = null;\n+      Iterator<Range<Long>> idRangeIter = null;\n+      RangeSet<Long> idsUsed = TreeRangeSet.create();\n+      for (TimestampedValueWithId<T> pendingAdd : elements) {\n+        // Since elements are in increasing ts order, often we'll be able to reuse the previous\n+        // iteration's range.\n+        if (currentTsRange == null\n+            || !currentTsRange.contains(pendingAdd.getValue().getTimestamp())) {\n+          if (availableIdsForTsRange != null) {\n+            // We're moving onto a new ts range. Remove all used ids\n+            availableIdsForTsRange.removeAll(idsUsed);\n+            idsUsed = TreeRangeSet.create();\n+          }\n+\n+          // Lookup the range for the current timestamp.\n+          currentTsRange = getTrackedRange(pendingAdd.getValue().getTimestamp());\n+          // Lookup available ids for this timestamp range. If nothing there, we default to all ids\n+          // available.\n+          availableIdsForTsRange =\n+              idsAvailable.computeIfAbsent(\n+                  currentTsRange,\n+                  r -> TreeRangeSet.create(ImmutableList.of(Range.closedOpen(MIN_ID, MAX_ID))));\n+          idRangeIter = availableIdsForTsRange.asRanges().iterator();\n+          currentIdRange = null;\n+          currentTsRangeDeletions = subRangeDeletions.get(currentTsRange);\n+        }\n \n+        if (currentIdRange == null || currentId >= currentIdRange.upperEndpoint()) {\n+          // Move to the next range of free ids, and start assigning ranges from there.\n+          currentIdRange = idRangeIter.next();\n+          currentId = currentIdRange.lowerEndpoint();\n+        }\n+\n+        if (currentTsRangeDeletions != null) {\n+          currentTsRangeDeletions.remove(\n+              Range.closedOpen(\n+                  pendingAdd.getValue().getTimestamp(),\n+                  pendingAdd.getValue().getTimestamp().plus(1)));\n+        }\n+        idsUsed.add(Range.closedOpen(currentId, currentId + 1));\n+        output.accept(pendingAdd.getValue(), currentId++);\n+      }\n+      if (availableIdsForTsRange != null) {\n+        availableIdsForTsRange.removeAll(idsUsed);\n+      }\n+      idsAvailableValue.write(idsAvailable);\n+      subRangeDeletionsValue.write(subRangeDeletions);\n+    }\n+\n+    // Remove a timestamp range. Returns ids freed up.\n+    void remove(Range<Instant> tsRange) throws ExecutionException, InterruptedException {\n+      Map<Range<Instant>, RangeSet<Long>> idsAvailable = readIdsAvailable();\n+      Map<Range<Instant>, RangeSet<Instant>> subRangeDeletions = readSubRangeDeletions();\n+\n+      for (Range<Instant> current = getTrackedRange(tsRange.lowerEndpoint());\n+          current.lowerEndpoint().isBefore(tsRange.upperEndpoint());\n+          current = getTrackedRange(current.lowerEndpoint().plus(RESOLUTION))) {\n+        // TODO: shouldn't need to iterate over all ranges.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51f72ea52a7e3883fbbf0a0fe79d3c1a82c8ac14"}, "originalPosition": 452}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExMTA5NQ==", "bodyText": "Use WindmillTimeUtils.windmillToHarnessTimestamp().  Current code is wrong for negative timestamps.", "url": "https://github.com/apache/beam/pull/12864#discussion_r493111095", "createdAt": "2020-09-23T00:46:43Z", "author": {"login": "dpmills"}, "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillStateReader.java", "diffHunk": "@@ -577,9 +655,30 @@ public void addWeighted(T elem, long weight) {\n     return valueList;\n   }\n \n-  private <T> void consumeBag(TagBag bag, StateTag stateTag) {\n+  private <T> List<TimestampedValue<T>> sortedListPageValues(\n+      Windmill.TagSortedListFetchResponse sortedListFetchResponse, Coder<T> elemCoder) {\n+    if (sortedListFetchResponse.getEntriesCount() == 0) {\n+      return new WeightedList<>(Collections.emptyList());\n+    }\n+\n+    WeightedList<TimestampedValue<T>> entryList =\n+        new WeightedList<>(new ArrayList<>(sortedListFetchResponse.getEntriesCount()));\n+    for (SortedListEntry entry : sortedListFetchResponse.getEntriesList()) {\n+      try {\n+        T value = elemCoder.decode(entry.getValue().newInput(), Coder.Context.OUTER);\n+        entryList.addWeighted(\n+            TimestampedValue.of(value, Instant.ofEpochMilli(entry.getSortKey() / 1000)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51f72ea52a7e3883fbbf0a0fe79d3c1a82c8ac14"}, "originalPosition": 533}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49ab7e6745ce26b6c157ebddc41aa6a01b2ab3a8", "author": {"user": {"login": "reuvenlax", "name": null}}, "url": "https://github.com/apache/beam/commit/49ab7e6745ce26b6c157ebddc41aa6a01b2ab3a8", "committedDate": "2020-10-14T04:50:38Z", "message": "Windmill implementation for TimestampOrderedState"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "51f72ea52a7e3883fbbf0a0fe79d3c1a82c8ac14", "author": {"user": {"login": "reuvenlax", "name": null}}, "url": "https://github.com/apache/beam/commit/51f72ea52a7e3883fbbf0a0fe79d3c1a82c8ac14", "committedDate": "2020-09-20T19:59:07Z", "message": "fix spotbugs"}, "afterCommit": {"oid": "49ab7e6745ce26b6c157ebddc41aa6a01b2ab3a8", "author": {"user": {"login": "reuvenlax", "name": null}}, "url": "https://github.com/apache/beam/commit/49ab7e6745ce26b6c157ebddc41aa6a01b2ab3a8", "committedDate": "2020-10-14T04:50:38Z", "message": "Windmill implementation for TimestampOrderedState"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "532b634ed9eb8198608dd5a5258b325332413254", "author": {"user": {"login": "reuvenlax", "name": null}}, "url": "https://github.com/apache/beam/commit/532b634ed9eb8198608dd5a5258b325332413254", "committedDate": "2020-10-14T05:12:52Z", "message": "address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7aecbb3b4577380674701437ef07f110a63982ab", "author": {"user": {"login": "reuvenlax", "name": null}}, "url": "https://github.com/apache/beam/commit/7aecbb3b4577380674701437ef07f110a63982ab", "committedDate": "2020-10-14T20:39:27Z", "message": "ensure tests run on streaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "119cb17e17d33a05618b99763e8c14a8ebd1dc91", "author": {"user": {"login": "reuvenlax", "name": null}}, "url": "https://github.com/apache/beam/commit/119cb17e17d33a05618b99763e8c14a8ebd1dc91", "committedDate": "2020-10-16T04:04:09Z", "message": "Ensure tests run on streaming and fix broken iterable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07f33864714a4755cd9ff455b23f355c4e7abc5e", "author": {"user": {"login": "reuvenlax", "name": null}}, "url": "https://github.com/apache/beam/commit/07f33864714a4755cd9ff455b23f355c4e7abc5e", "committedDate": "2020-10-16T04:06:51Z", "message": "disable test until windmill fixed"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2783, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}