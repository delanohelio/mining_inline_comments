{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzMjc2MzI1", "number": 11413, "title": "[BEAM-9746] check for 0 length copies from state", "bodyText": "@thetorpedodog discovered that side inputs that produce empty pcollections would produce a spurious \"zero element\". The root cause was because the SDK's handling of state api responses didn't check for 0 length byte buffers from the API, and interpret them as the EOF signal.\nIn particular for elements whose coded form is length prefixed, this would yield a 0 length read for a request of 1 byte when calling graph.DecodeVarInt, but no error, preventing subsequent error handling. This would tell the decoder that the encoded size is 0, and it would then read that data accordingly.\nNow when there are 0 length copies and there are no more pages of data, the Read call will immeadiately return EOF rather than defer to the next call, which in the empty case, never comes.\nWhile it's unlikely that runners would ever intentionally return mid stream 0 length reads while saying there is subsequent data, we can't simply end the paging on empty buffers. It's inline with Go's io.Reader interface semantics to permit 0 length reads without error, as like in any short read case, data could be available later, instead of waiting for the full length of the read, and require multiple reads.\nIt's probable that there are places we should be handling the io.Reader contract more rigorously, such as by always handling the non-zero read bytes even when an error is returned, but care would need to be taken during such a retrofit.\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nApex\nDataflow\nFlink\nGearpump\nSamza\nSpark\n\n\n\n\nGo\n\n---\n---\n\n---\n---\n\n\n\nJava\n\n\n\n\n\n\n\n\n\nPython\n\n---\n\n\n---\n---\n\n\n\nXLang\n---\n---\n---\n\n---\n---\n\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.", "createdAt": "2020-04-14T16:04:10Z", "url": "https://github.com/apache/beam/pull/11413", "merged": true, "mergeCommit": {"oid": "acb37bb29d155d4b9ded630fe8dc23fbfea57a8a"}, "closed": true, "closedAt": "2020-04-15T00:33:10Z", "author": {"login": "lostluck"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcXlejaAH2gAyNDAzMjc2MzI1OjkwMGMyOGU0NWEyZTZjMGM5ZWQ2NmNlMjc3ZGU1ZDYyYjA5OTMxNGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcXsxcRAH2gAyNDAzMjc2MzI1OjAyYzcxNTYzYmQyODczYjBjNjJhODljMmE4OTlmMjg2MDM2ZGNhZjc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "900c28e45a2e6c0c9ed66ce277de5d62b099314f", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/900c28e45a2e6c0c9ed66ce277de5d62b099314f", "committedDate": "2020-04-14T15:46:12Z", "message": "[BEAM-9746] check for 0 length reads from state"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/d6a59119ccc9f1b8f6c95d2ccb38f613861668b5", "committedDate": "2020-04-14T16:11:56Z", "message": "!fixup clean up test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMTExMTQw", "url": "https://github.com/apache/beam/pull/11413#pullrequestreview-393111140", "createdAt": "2020-04-14T16:46:19Z", "commit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNjo0NjoxOVrOGFXraw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNjo0NjoxOVrOGFXraw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI4NDAxMQ==", "bodyText": "seems like this could still be an if-else?", "url": "https://github.com/apache/beam/pull/11413#discussion_r408284011", "createdAt": "2020-04-14T16:46:19Z", "author": {"login": "thetorpedodog"}, "path": "sdks/go/pkg/beam/core/runtime/harness/datamgr.go", "diffHunk": "@@ -369,11 +371,14 @@ func (r *dataReader) Read(buf []byte) (int, error) {\n \t\tr.cur = b\n \t}\n \n+\t// We don't need to check for a 0 length copy from r.cur here, since that's\n+\t// checked before buffers are handed to the r.buf channel.\n \tn := copy(buf, r.cur)\n \n-\tif len(r.cur) == n {\n+\tswitch {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMjQ5Njg0", "url": "https://github.com/apache/beam/pull/11413#pullrequestreview-393249684", "createdAt": "2020-04-14T19:57:31Z", "commit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxOTo1NzozMlrOGFen6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxOTo1NzozMlrOGFen6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM5NzgwMw==", "bodyText": "i, buflen := range test.buflens ?", "url": "https://github.com/apache/beam/pull/11413#discussion_r408397803", "createdAt": "2020-04-14T19:57:32Z", "author": {"login": "thetorpedodog"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tfor i := 0; i < len(test.buflens); i++ {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5"}, "originalPosition": 99}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afc95c82202bf9bf5c2781d574abe346de33f8da", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/afc95c82202bf9bf5c2781d574abe346de33f8da", "committedDate": "2020-04-14T20:07:04Z", "message": "!fixup use range syntax"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMjUzNjY5", "url": "https://github.com/apache/beam/pull/11413#pullrequestreview-393253669", "createdAt": "2020-04-14T20:03:18Z", "commit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDowMzoxOVrOGFe0hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDoyNDoyM1rOGFfh3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMTAzMA==", "bodyText": "Since this doesn't depend on the rest of what is going on in the loop, pulling this up to the top might be a good idea.", "url": "https://github.com/apache/beam/pull/11413#discussion_r408401030", "createdAt": "2020-04-14T20:03:19Z", "author": {"login": "thetorpedodog"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tfor i := 0; i < len(test.buflens); i++ {\n+\t\t\t\t\ttoken := []byte(strconv.Itoa(i))\n+\t\t\t\t\tvar buf []byte\n+\t\t\t\t\tif test.buflens[i] >= 0 {\n+\t\t\t\t\t\tbuf = bytes.Repeat([]byte{42}, test.buflens[i])\n+\t\t\t\t\t}\n+\t\t\t\t\t// On the last request response pair, send no token.\n+\t\t\t\t\tif i+1 == len(test.buflens) {\n+\t\t\t\t\t\ttoken = nil\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treq := <-ch.requests\n+\n+\t\t\t\t\tif test.noGet {\n+\t\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMzg5MA==", "bodyText": "rearranging this so that all the initialization for this variable is together might make it easier to follow:\nvar buf []byte\nif ... {\n  ...\n}\n\n// I can see it making sense to reverse the if-statement here to match the one above,\n// but it there is a case to keep it as-is so that the common case is outside the 'if'.\n// Up to you.\nvar token []byte\nif (not last entry) {\n  // Maybe use fmt.Sprint() here rather than Itoa to avoid needing the strconv package?\n  token = []byte(fmt.Sprint(i))\n}\n\nch.responses[...] <- ...", "url": "https://github.com/apache/beam/pull/11413#discussion_r408403890", "createdAt": "2020-04-14T20:08:27Z", "author": {"login": "thetorpedodog"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tfor i := 0; i < len(test.buflens); i++ {\n+\t\t\t\t\ttoken := []byte(strconv.Itoa(i))\n+\t\t\t\t\tvar buf []byte\n+\t\t\t\t\tif test.buflens[i] >= 0 {\n+\t\t\t\t\t\tbuf = bytes.Repeat([]byte{42}, test.buflens[i])\n+\t\t\t\t\t}\n+\t\t\t\t\t// On the last request response pair, send no token.\n+\t\t\t\t\tif i+1 == len(test.buflens) {\n+\t\t\t\t\t\ttoken = nil\n+\t\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMjYzOQ==", "bodyText": "Is this a common idiom in beam testing? Inside Google, I don't think I've seen reassignment to want/got for things which are already stored in their own variables. I would expect something like:\nif reads != test.numReads {\n  t.Errorf(\"read %d times, want %d\", reads, test.numReads)\n}\nfor simpler tests I have seen things like:\nif got := sut.CallSomeFn(params); got != tc.want {\n  // ...\n}", "url": "https://github.com/apache/beam/pull/11413#discussion_r408412639", "createdAt": "2020-04-14T20:24:23Z", "author": {"login": "thetorpedodog"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tfor i := 0; i < len(test.buflens); i++ {\n+\t\t\t\t\ttoken := []byte(strconv.Itoa(i))\n+\t\t\t\t\tvar buf []byte\n+\t\t\t\t\tif test.buflens[i] >= 0 {\n+\t\t\t\t\t\tbuf = bytes.Repeat([]byte{42}, test.buflens[i])\n+\t\t\t\t\t}\n+\t\t\t\t\t// On the last request response pair, send no token.\n+\t\t\t\t\tif i+1 == len(test.buflens) {\n+\t\t\t\t\t\ttoken = nil\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treq := <-ch.requests\n+\n+\t\t\t\t\tif test.noGet {\n+\t\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\tResponse: &fnpb.StateResponse_Get{\n+\t\t\t\t\t\t\tGet: &fnpb.StateGetResponse{\n+\t\t\t\t\t\t\t\tContinuationToken: token,\n+\t\t\t\t\t\t\t\tData:              buf,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}()\n+\n+\t\t\tr := stateKeyReader{\n+\t\t\t\tch: ch,\n+\t\t\t}\n+\n+\t\t\tif test.closed {\n+\t\t\t\terr := r.Close()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"unexpected error on Close(), got %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tvar totalBytes int\n+\t\t\tfor _, l := range test.buflens {\n+\t\t\t\tif l > 0 {\n+\t\t\t\t\ttotalBytes += l\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tvar finalerr error\n+\t\t\tvar count, reads int\n+\n+\t\t\t// Read all the bytes.\n+\t\t\tfor count <= totalBytes {\n+\t\t\t\treads++\n+\t\t\t\tb := make([]byte, readLen) // io.Read is keyed off of length, not capacity.\n+\t\t\t\tn, err := r.Read(b)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tfinalerr = err\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tcount += n\n+\t\t\t\t// Special check to avoid spurious zero elements.\n+\t\t\t\tif count == totalBytes && n == 0 {\n+\t\t\t\t\tt.Error(\"expected byte count read, last read is 0, but no EOF\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif got, want := reads, test.numReads; got != want {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5"}, "originalPosition": 166}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9acd8ee186b9cfb782f027ea00049a7d6f287758", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/9acd8ee186b9cfb782f027ea00049a7d6f287758", "committedDate": "2020-04-14T22:16:37Z", "message": "!fixup comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzQ1OTcw", "url": "https://github.com/apache/beam/pull/11413#pullrequestreview-393345970", "createdAt": "2020-04-14T22:44:17Z", "commit": {"oid": "9acd8ee186b9cfb782f027ea00049a7d6f287758"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo0NDoxN1rOGFjk9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo0NjowOVrOGFjneQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3ODk2NQ==", "bodyText": "I'm still not a huge fan, because it introduces another layer of indirection around what is gotten vs. wanted (e.g. in the ==/!= itself and in the error message string)\u2026", "url": "https://github.com/apache/beam/pull/11413#discussion_r408478965", "createdAt": "2020-04-14T22:44:17Z", "author": {"login": "thetorpedodog"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tfor i := 0; i < len(test.buflens); i++ {\n+\t\t\t\t\ttoken := []byte(strconv.Itoa(i))\n+\t\t\t\t\tvar buf []byte\n+\t\t\t\t\tif test.buflens[i] >= 0 {\n+\t\t\t\t\t\tbuf = bytes.Repeat([]byte{42}, test.buflens[i])\n+\t\t\t\t\t}\n+\t\t\t\t\t// On the last request response pair, send no token.\n+\t\t\t\t\tif i+1 == len(test.buflens) {\n+\t\t\t\t\t\ttoken = nil\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treq := <-ch.requests\n+\n+\t\t\t\t\tif test.noGet {\n+\t\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\tResponse: &fnpb.StateResponse_Get{\n+\t\t\t\t\t\t\tGet: &fnpb.StateGetResponse{\n+\t\t\t\t\t\t\t\tContinuationToken: token,\n+\t\t\t\t\t\t\t\tData:              buf,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}()\n+\n+\t\t\tr := stateKeyReader{\n+\t\t\t\tch: ch,\n+\t\t\t}\n+\n+\t\t\tif test.closed {\n+\t\t\t\terr := r.Close()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"unexpected error on Close(), got %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tvar totalBytes int\n+\t\t\tfor _, l := range test.buflens {\n+\t\t\t\tif l > 0 {\n+\t\t\t\t\ttotalBytes += l\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tvar finalerr error\n+\t\t\tvar count, reads int\n+\n+\t\t\t// Read all the bytes.\n+\t\t\tfor count <= totalBytes {\n+\t\t\t\treads++\n+\t\t\t\tb := make([]byte, readLen) // io.Read is keyed off of length, not capacity.\n+\t\t\t\tn, err := r.Read(b)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tfinalerr = err\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tcount += n\n+\t\t\t\t// Special check to avoid spurious zero elements.\n+\t\t\t\tif count == totalBytes && n == 0 {\n+\t\t\t\t\tt.Error(\"expected byte count read, last read is 0, but no EOF\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif got, want := reads, test.numReads; got != want {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMjYzOQ=="}, "originalCommit": {"oid": "d6a59119ccc9f1b8f6c95d2ccb38f613861668b5"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3OTYwOQ==", "bodyText": "...for instance, here, I would find\nif want := errors.New(\"side input closed\"); !contains(finalErr, want) {\n  t.Errorf(\"got err %v; want to contain %v, finalErr, want)\n}\neasier to read, since the thing you Got is right there. That being said, I wouldn't block submission on this.", "url": "https://github.com/apache/beam/pull/11413#discussion_r408479609", "createdAt": "2020-04-14T22:46:09Z", "author": {"login": "thetorpedodog"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +260,166 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tif test.noGet {\n+\t\t\t\t\treq := <-ch.requests\n+\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t}\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tfor i, buflen := range test.buflens {\n+\t\t\t\t\tvar buf []byte\n+\t\t\t\t\tif buflen >= 0 {\n+\t\t\t\t\t\tbuf = bytes.Repeat([]byte{42}, buflen)\n+\t\t\t\t\t}\n+\t\t\t\t\ttoken := []byte(fmt.Sprint(i))\n+\t\t\t\t\tif i+1 == len(test.buflens) {\n+\t\t\t\t\t\t// On the last request response pair, send no token.\n+\t\t\t\t\t\ttoken = nil\n+\t\t\t\t\t}\n+\t\t\t\t\treq := <-ch.requests\n+\n+\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\tResponse: &fnpb.StateResponse_Get{\n+\t\t\t\t\t\t\tGet: &fnpb.StateGetResponse{\n+\t\t\t\t\t\t\t\tContinuationToken: token,\n+\t\t\t\t\t\t\t\tData:              buf,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}()\n+\n+\t\t\tr := stateKeyReader{\n+\t\t\t\tch: ch,\n+\t\t\t}\n+\n+\t\t\tif test.closed {\n+\t\t\t\terr := r.Close()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"unexpected error on Close(), got %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tvar totalBytes int\n+\t\t\tfor _, l := range test.buflens {\n+\t\t\t\tif l > 0 {\n+\t\t\t\t\ttotalBytes += l\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tvar finalerr error\n+\t\t\tvar count, reads int\n+\n+\t\t\t// Read all the bytes.\n+\t\t\tfor count <= totalBytes {\n+\t\t\t\treads++\n+\t\t\t\tb := make([]byte, readLen) // io.Read is keyed off of length, not capacity.\n+\t\t\t\tn, err := r.Read(b)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tfinalerr = err\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tcount += n\n+\t\t\t\t// Special check to avoid spurious zero elements.\n+\t\t\t\tif count == totalBytes && n == 0 {\n+\t\t\t\t\tt.Error(\"expected byte count read, last read is 0, but no EOF\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif got, want := reads, test.numReads; got != want {\n+\t\t\t\tt.Errorf(\"read %d times, want %d\", got, want)\n+\t\t\t}\n+\t\t\tif got, want := count, totalBytes; got != want {\n+\t\t\t\tt.Errorf(\"read %v bytes, want %v\", got, want)\n+\t\t\t}\n+\t\t\tif test.closed {\n+\t\t\t\tif got, want := finalerr, errors.New(\"side input closed\"); !contains(got, want) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9acd8ee186b9cfb782f027ea00049a7d6f287758"}, "originalPosition": 168}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzQ0NDMx", "url": "https://github.com/apache/beam/pull/11413#pullrequestreview-393344431", "createdAt": "2020-04-14T22:40:23Z", "commit": {"oid": "afc95c82202bf9bf5c2781d574abe346de33f8da"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo0MDoyM1rOGFjfdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo1Mjo0MVrOGFjwWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NzU1Ng==", "bodyText": "Nit: This error message could benefit from some escaped quotation marks around the %v, to make it explicit where the quoted error begins and ends. Alternatively, surrounding the quoted error with some newlines and tabs might work well too, like so:\ngot err:\n    <error message>\nwant to contain:\n    <error message>", "url": "https://github.com/apache/beam/pull/11413#discussion_r408477556", "createdAt": "2020-04-14T22:40:23Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tfor i, buflen := range test.buflens {\n+\t\t\t\t\ttoken := []byte(strconv.Itoa(i))\n+\t\t\t\t\tvar buf []byte\n+\t\t\t\t\tif buflen >= 0 {\n+\t\t\t\t\t\tbuf = bytes.Repeat([]byte{42}, buflen)\n+\t\t\t\t\t}\n+\t\t\t\t\t// On the last request response pair, send no token.\n+\t\t\t\t\tif i+1 == len(test.buflens) {\n+\t\t\t\t\t\ttoken = nil\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treq := <-ch.requests\n+\n+\t\t\t\t\tif test.noGet {\n+\t\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\tResponse: &fnpb.StateResponse_Get{\n+\t\t\t\t\t\t\tGet: &fnpb.StateGetResponse{\n+\t\t\t\t\t\t\t\tContinuationToken: token,\n+\t\t\t\t\t\t\t\tData:              buf,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}()\n+\n+\t\t\tr := stateKeyReader{\n+\t\t\t\tch: ch,\n+\t\t\t}\n+\n+\t\t\tif test.closed {\n+\t\t\t\terr := r.Close()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"unexpected error on Close(), got %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tvar totalBytes int\n+\t\t\tfor _, l := range test.buflens {\n+\t\t\t\tif l > 0 {\n+\t\t\t\t\ttotalBytes += l\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tvar finalerr error\n+\t\t\tvar count, reads int\n+\n+\t\t\t// Read all the bytes.\n+\t\t\tfor count <= totalBytes {\n+\t\t\t\treads++\n+\t\t\t\tb := make([]byte, readLen) // io.Read is keyed off of length, not capacity.\n+\t\t\t\tn, err := r.Read(b)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tfinalerr = err\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tcount += n\n+\t\t\t\t// Special check to avoid spurious zero elements.\n+\t\t\t\tif count == totalBytes && n == 0 {\n+\t\t\t\t\tt.Error(\"expected byte count read, last read is 0, but no EOF\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif got, want := reads, test.numReads; got != want {\n+\t\t\t\tt.Errorf(\"read %d times, want %d\", got, want)\n+\t\t\t}\n+\t\t\tif got, want := count, totalBytes; got != want {\n+\t\t\t\tt.Errorf(\"read %v bytes, want %v\", got, want)\n+\t\t\t}\n+\t\t\tif test.closed {\n+\t\t\t\tif got, want := finalerr, errors.New(\"side input closed\"); !contains(got, want) {\n+\t\t\t\t\tt.Errorf(\"got err %v, want to contain %v\", got, want)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afc95c82202bf9bf5c2781d574abe346de33f8da"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NzgzMw==", "bodyText": "Nit: Same as above. Could use some way to make it more explicit where the quoted error begins and ends.", "url": "https://github.com/apache/beam/pull/11413#discussion_r408477833", "createdAt": "2020-04-14T22:41:07Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int\n+\t\tclosed   bool // tries to read from closed reader\n+\t\tnoGet    bool // tries to read from nil get response reader\n+\t}{\n+\t\t{\n+\t\t\tname:     \"emptyData\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferSingleRead\",\n+\t\t\tbuflens:  []int{readLen},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferMultipleReads\",\n+\t\t\tbuflens:  []int{2 * readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"singleBufferShortRead\",\n+\t\t\tbuflens:  []int{readLen - 1},\n+\t\t\tnumReads: 2,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer\",\n+\t\t\tbuflens:  []int{readLen, readLen},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"multiBuffer-short-reads\",\n+\t\t\tbuflens:  []int{readLen - 1, readLen - 1, readLen - 2},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataFirst\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{-1, readLen, readLen},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataMid\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1, readLen},\n+\t\t\tnumReads: 5,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast\", // Shouldn't happen, but not unreasonable to handle.\n+\t\t\tbuflens:  []int{readLen, readLen, -1},\n+\t\t\tnumReads: 3,\n+\t\t}, {\n+\t\t\tname:     \"emptyDataLast-short\",\n+\t\t\tbuflens:  []int{3*readLen - 2, -1},\n+\t\t\tnumReads: 4,\n+\t\t}, {\n+\t\t\tname:     \"closed\",\n+\t\t\tbuflens:  []int{-1, -1},\n+\t\t\tnumReads: 1,\n+\t\t\tclosed:   true,\n+\t\t}, {\n+\t\t\tname:     \"noGet\",\n+\t\t\tbuflens:  []int{-1},\n+\t\t\tnumReads: 1,\n+\t\t\tnoGet:    true,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tctx, cancelFn := context.WithCancel(context.Background())\n+\t\t\tch := &StateChannel{\n+\t\t\t\tid:        \"test\",\n+\t\t\t\trequests:  make(chan *fnpb.StateRequest),\n+\t\t\t\tresponses: make(map[string]chan<- *fnpb.StateResponse),\n+\t\t\t\tcancelFn:  cancelFn,\n+\t\t\t\tDoneCh:    ctx.Done(),\n+\t\t\t}\n+\n+\t\t\t// Handle the channel behavior asynchronously.\n+\t\t\tgo func() {\n+\t\t\t\tfor i, buflen := range test.buflens {\n+\t\t\t\t\ttoken := []byte(strconv.Itoa(i))\n+\t\t\t\t\tvar buf []byte\n+\t\t\t\t\tif buflen >= 0 {\n+\t\t\t\t\t\tbuf = bytes.Repeat([]byte{42}, buflen)\n+\t\t\t\t\t}\n+\t\t\t\t\t// On the last request response pair, send no token.\n+\t\t\t\t\tif i+1 == len(test.buflens) {\n+\t\t\t\t\t\ttoken = nil\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treq := <-ch.requests\n+\n+\t\t\t\t\tif test.noGet {\n+\t\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tch.responses[req.Id] <- &fnpb.StateResponse{\n+\t\t\t\t\t\tId: req.Id,\n+\t\t\t\t\t\tResponse: &fnpb.StateResponse_Get{\n+\t\t\t\t\t\t\tGet: &fnpb.StateGetResponse{\n+\t\t\t\t\t\t\t\tContinuationToken: token,\n+\t\t\t\t\t\t\t\tData:              buf,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}()\n+\n+\t\t\tr := stateKeyReader{\n+\t\t\t\tch: ch,\n+\t\t\t}\n+\n+\t\t\tif test.closed {\n+\t\t\t\terr := r.Close()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"unexpected error on Close(), got %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tvar totalBytes int\n+\t\t\tfor _, l := range test.buflens {\n+\t\t\t\tif l > 0 {\n+\t\t\t\t\ttotalBytes += l\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tvar finalerr error\n+\t\t\tvar count, reads int\n+\n+\t\t\t// Read all the bytes.\n+\t\t\tfor count <= totalBytes {\n+\t\t\t\treads++\n+\t\t\t\tb := make([]byte, readLen) // io.Read is keyed off of length, not capacity.\n+\t\t\t\tn, err := r.Read(b)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tfinalerr = err\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tcount += n\n+\t\t\t\t// Special check to avoid spurious zero elements.\n+\t\t\t\tif count == totalBytes && n == 0 {\n+\t\t\t\t\tt.Error(\"expected byte count read, last read is 0, but no EOF\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif got, want := reads, test.numReads; got != want {\n+\t\t\t\tt.Errorf(\"read %d times, want %d\", got, want)\n+\t\t\t}\n+\t\t\tif got, want := count, totalBytes; got != want {\n+\t\t\t\tt.Errorf(\"read %v bytes, want %v\", got, want)\n+\t\t\t}\n+\t\t\tif test.closed {\n+\t\t\t\tif got, want := finalerr, errors.New(\"side input closed\"); !contains(got, want) {\n+\t\t\t\t\tt.Errorf(\"got err %v, want to contain %v\", got, want)\n+\t\t\t\t}\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif got, want := finalerr, io.EOF; got != want {\n+\t\t\t\tt.Errorf(\"got err %v, want %v\", got, want)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afc95c82202bf9bf5c2781d574abe346de33f8da"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MTg4MQ==", "bodyText": "Is the number of reads something that needs to be predictable to whatever code uses the reader? To me it seems like one of those implementation details that doesn't need to be unit tested because it's invisible to the caller.\nThe reason this stood out to me is that the numReads in all the test cases below seem a bit inscrutable, and it would cause these tests to fail if the implementation of the stateKeyReader was changed slightly, which is just an annoyance unless it would actually break code.\nOn the other hand, if the number of reads is a detail that users should know, and correctness does rely on it staying consistent, that seems like it should be explicitly documented on stateKeyReader.Read.", "url": "https://github.com/apache/beam/pull/11413#discussion_r408481881", "createdAt": "2020-04-14T22:52:41Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/core/runtime/harness/statemgr_test.go", "diffHunk": "@@ -258,6 +261,167 @@ func TestStateChannel(t *testing.T) {\n \t}\n }\n \n+// TestStateKeyReader validates ordinary Read cases\n+func TestStateKeyReader(t *testing.T) {\n+\tconst readLen = 4\n+\ttests := []struct {\n+\t\tname     string\n+\t\tbuflens  []int // sizes of the buffers received on the state channel.\n+\t\tnumReads int", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afc95c82202bf9bf5c2781d574abe346de33f8da"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02c71563bd2873b0c62a89c2a899f286036dcaf7", "author": {"user": {"login": "lostluck", "name": "Robert Burke"}}, "url": "https://github.com/apache/beam/commit/02c71563bd2873b0c62a89c2a899f286036dcaf7", "committedDate": "2020-04-15T00:16:10Z", "message": "!fixup quote errors"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4216, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}