{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1MDA2NjYx", "number": 12184, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMToxODoxMlrOEMCCxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMToxODoxMlrOEMCCxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDUxODQ1OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/rabbitmq/src/test/java/org/apache/beam/sdk/io/rabbitmq/RabbitMqIOTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMToxODoxMlrOGt6BqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMDoyNzo0OVrOGuOaGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc4OTgwMA==", "bodyText": "I think this has to be:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                waitForExchangeToBeDeclared.countDown();\n          \n          \n            \n                waitForExchangeToBeDeclared.await();", "url": "https://github.com/apache/beam/pull/12184#discussion_r450789800", "createdAt": "2020-07-07T11:18:12Z", "author": {"login": "mxm"}, "path": "sdks/java/io/rabbitmq/src/test/java/org/apache/beam/sdk/io/rabbitmq/RabbitMqIOTest.java", "diffHunk": "@@ -196,59 +200,74 @@ private void doExchangeTest(ExchangeTestPlan testPlan, boolean simulateIncompati\n         exchangeType = \"fanout\";\n       }\n     }\n+    final String finalExchangeType = exchangeType;\n+    final CountDownLatch waitForExchangeToBeDeclared = new CountDownLatch(1);\n+    final BlockingQueue<byte[]> recordsToPublish = new LinkedBlockingQueue<>();\n+    recordsToPublish.addAll(RabbitMqTestUtils.generateRecords(testPlan.getNumRecordsToPublish()));\n+    Thread publisher =\n+        new Thread(\n+            () -> {\n+              Connection connection = null;\n+              Channel channel = null;\n+              try {\n+                ConnectionFactory connectionFactory = new ConnectionFactory();\n+                connectionFactory.setAutomaticRecoveryEnabled(false);\n+                connectionFactory.setUri(uri);\n+                connection = connectionFactory.newConnection();\n+                channel = connection.createChannel();\n+                channel.exchangeDeclare(exchange, finalExchangeType);\n+                // We are relying on the pipeline to declare the queue and messages that are\n+                // published without a queue being declared are \"unroutable\". Since there is a race\n+                // between when the pipeline declares and when we can start publishing, we add a\n+                // handler to republish messages that are returned to us.\n+                channel.addReturnListener(\n+                    (replyCode, replyText, exchange1, routingKey, properties, body) -> {\n+                      try {\n+                        recordsToPublish.put(body);\n+                      } catch (Exception e) {\n+                        throw new RuntimeException(e);\n+                      }\n+                    });\n+                waitForExchangeToBeDeclared.countDown();\n+                while (true) {\n+                  byte[] record = recordsToPublish.take();\n+                  if (record == terminalRecord) {\n+                    return;\n+                  }\n+                  channel.basicPublish(\n+                      exchange,\n+                      testPlan.publishRoutingKeyGen().get(),\n+                      true, // ensure that messages are returned to sender\n+                      testPlan.getPublishProperties(),\n+                      record);\n+                }\n \n-    ConnectionFactory connectionFactory = new ConnectionFactory();\n-    connectionFactory.setAutomaticRecoveryEnabled(false);\n-    connectionFactory.setUri(uri);\n-    Connection connection = null;\n-    Channel channel = null;\n-\n-    try {\n-      connection = connectionFactory.newConnection();\n-      channel = connection.createChannel();\n-      channel.exchangeDeclare(exchange, exchangeType);\n-      final Channel finalChannel = channel;\n-      Thread publisher =\n-          new Thread(\n-              () -> {\n-                try {\n-                  Thread.sleep(5000);\n-                } catch (Exception e) {\n-                  LOG.error(e.getMessage(), e);\n+              } catch (Exception e) {\n+                throw new RuntimeException(e);\n+              } finally {\n+                if (channel != null) {\n+                  // channel may have already been closed automatically due to protocol failure\n+                  try {\n+                    channel.close();\n+                  } catch (Exception e) {\n+                    /* ignored */\n+                  }\n                 }\n-                for (int i = 0; i < testPlan.getNumRecordsToPublish(); i++) {\n+                if (connection != null) {\n+                  // connection may have already been closed automatically due to protocol failure\n                   try {\n-                    finalChannel.basicPublish(\n-                        exchange,\n-                        testPlan.publishRoutingKeyGen().get(),\n-                        testPlan.getPublishProperties(),\n-                        RabbitMqTestUtils.generateRecord(i));\n+                    connection.close();\n                   } catch (Exception e) {\n-                    LOG.error(e.getMessage(), e);\n+                    /* ignored */\n                   }\n                 }\n-              });\n-      publisher.start();\n-      p.run();\n-      publisher.join();\n-    } finally {\n-      if (channel != null) {\n-        // channel may have already been closed automatically due to protocol failure\n-        try {\n-          channel.close();\n-        } catch (Exception e) {\n-          /* ignored */\n-        }\n-      }\n-      if (connection != null) {\n-        // connection may have already been closed automatically due to protocol failure\n-        try {\n-          connection.close();\n-        } catch (Exception e) {\n-          /* ignored */\n-        }\n-      }\n-    }\n+              }\n+            });\n+    publisher.start();\n+    waitForExchangeToBeDeclared.countDown();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1ce25cf9aaf99ae94a98a25fe8287c884d5f2d"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEyMzczOQ==", "bodyText": "Your right.", "url": "https://github.com/apache/beam/pull/12184#discussion_r451123739", "createdAt": "2020-07-07T20:27:49Z", "author": {"login": "lukecwik"}, "path": "sdks/java/io/rabbitmq/src/test/java/org/apache/beam/sdk/io/rabbitmq/RabbitMqIOTest.java", "diffHunk": "@@ -196,59 +200,74 @@ private void doExchangeTest(ExchangeTestPlan testPlan, boolean simulateIncompati\n         exchangeType = \"fanout\";\n       }\n     }\n+    final String finalExchangeType = exchangeType;\n+    final CountDownLatch waitForExchangeToBeDeclared = new CountDownLatch(1);\n+    final BlockingQueue<byte[]> recordsToPublish = new LinkedBlockingQueue<>();\n+    recordsToPublish.addAll(RabbitMqTestUtils.generateRecords(testPlan.getNumRecordsToPublish()));\n+    Thread publisher =\n+        new Thread(\n+            () -> {\n+              Connection connection = null;\n+              Channel channel = null;\n+              try {\n+                ConnectionFactory connectionFactory = new ConnectionFactory();\n+                connectionFactory.setAutomaticRecoveryEnabled(false);\n+                connectionFactory.setUri(uri);\n+                connection = connectionFactory.newConnection();\n+                channel = connection.createChannel();\n+                channel.exchangeDeclare(exchange, finalExchangeType);\n+                // We are relying on the pipeline to declare the queue and messages that are\n+                // published without a queue being declared are \"unroutable\". Since there is a race\n+                // between when the pipeline declares and when we can start publishing, we add a\n+                // handler to republish messages that are returned to us.\n+                channel.addReturnListener(\n+                    (replyCode, replyText, exchange1, routingKey, properties, body) -> {\n+                      try {\n+                        recordsToPublish.put(body);\n+                      } catch (Exception e) {\n+                        throw new RuntimeException(e);\n+                      }\n+                    });\n+                waitForExchangeToBeDeclared.countDown();\n+                while (true) {\n+                  byte[] record = recordsToPublish.take();\n+                  if (record == terminalRecord) {\n+                    return;\n+                  }\n+                  channel.basicPublish(\n+                      exchange,\n+                      testPlan.publishRoutingKeyGen().get(),\n+                      true, // ensure that messages are returned to sender\n+                      testPlan.getPublishProperties(),\n+                      record);\n+                }\n \n-    ConnectionFactory connectionFactory = new ConnectionFactory();\n-    connectionFactory.setAutomaticRecoveryEnabled(false);\n-    connectionFactory.setUri(uri);\n-    Connection connection = null;\n-    Channel channel = null;\n-\n-    try {\n-      connection = connectionFactory.newConnection();\n-      channel = connection.createChannel();\n-      channel.exchangeDeclare(exchange, exchangeType);\n-      final Channel finalChannel = channel;\n-      Thread publisher =\n-          new Thread(\n-              () -> {\n-                try {\n-                  Thread.sleep(5000);\n-                } catch (Exception e) {\n-                  LOG.error(e.getMessage(), e);\n+              } catch (Exception e) {\n+                throw new RuntimeException(e);\n+              } finally {\n+                if (channel != null) {\n+                  // channel may have already been closed automatically due to protocol failure\n+                  try {\n+                    channel.close();\n+                  } catch (Exception e) {\n+                    /* ignored */\n+                  }\n                 }\n-                for (int i = 0; i < testPlan.getNumRecordsToPublish(); i++) {\n+                if (connection != null) {\n+                  // connection may have already been closed automatically due to protocol failure\n                   try {\n-                    finalChannel.basicPublish(\n-                        exchange,\n-                        testPlan.publishRoutingKeyGen().get(),\n-                        testPlan.getPublishProperties(),\n-                        RabbitMqTestUtils.generateRecord(i));\n+                    connection.close();\n                   } catch (Exception e) {\n-                    LOG.error(e.getMessage(), e);\n+                    /* ignored */\n                   }\n                 }\n-              });\n-      publisher.start();\n-      p.run();\n-      publisher.join();\n-    } finally {\n-      if (channel != null) {\n-        // channel may have already been closed automatically due to protocol failure\n-        try {\n-          channel.close();\n-        } catch (Exception e) {\n-          /* ignored */\n-        }\n-      }\n-      if (connection != null) {\n-        // connection may have already been closed automatically due to protocol failure\n-        try {\n-          connection.close();\n-        } catch (Exception e) {\n-          /* ignored */\n-        }\n-      }\n-    }\n+              }\n+            });\n+    publisher.start();\n+    waitForExchangeToBeDeclared.countDown();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc4OTgwMA=="}, "originalCommit": {"oid": "af1ce25cf9aaf99ae94a98a25fe8287c884d5f2d"}, "originalPosition": 135}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3491, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}