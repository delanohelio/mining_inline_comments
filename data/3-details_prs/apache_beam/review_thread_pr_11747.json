{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5NzY2NDMx", "number": 11747, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjo1NjoyMFrOD9lDCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMzowMzo1N1rOD9lKEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODk2NzE0OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/io/synthetic/source.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjo1NjoyMFrOGXKGXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMzoxMDoxOFrOGXOSwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzNTkwMw==", "bodyText": "Note: Default encoding with JSON (or even future with beam.Schemas) will not encode unexported fields. You'll need to register a coder with beam.RegisterCoder if you want to ensure these get encoded properly.\nAlternatively, having the fields be exported while still providing and recommending a builder is not unreasonable. Eg. Document on the type  (as you have it) that the builder is recommended etc.", "url": "https://github.com/apache/beam/pull/11747#discussion_r426935903", "createdAt": "2020-05-18T22:56:20Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -135,27 +155,79 @@ func (fn *sourceFn) ProcessElement(rt *offsetrange.Tracker, config SourceConfig,\n \treturn nil\n }\n \n-// DefaultSourceConfig creates a SourceConfig with intended defaults for its\n-// fields. SourceConfigs should be initialized with this method.\n-func DefaultSourceConfig() SourceConfig {\n-\treturn SourceConfig{\n-\t\tNumElements:   1, // Defaults shouldn't drop elements, so at least 1.\n-\t\tInitialSplits: 1, // Defaults to 1, i.e. no initial splitting.\n+// SourceConfigBuilder is used to initialize SourceConfigs. See\n+// SourceConfigBuilder's methods for descriptions of the fields in a\n+// SourceConfig and how they can be set. The intended approach for using this\n+// builder is to begin by calling the DefaultSourceConfig function, followed by\n+// calling setters, followed by calling Build.\n+//\n+// Usage example:\n+//\n+//    cfg := synthetic.DefaultSourceConfig().NumElements(5000).InitialSplits(2).Build()\n+type SourceConfigBuilder struct {\n+\tcfg SourceConfig\n+}\n+\n+// DefaultSourceConfig creates a SourceConfigBuilder set with intended defaults\n+// for the SourceConfig fields. This function is the intended starting point for\n+// initializing a SourceConfig and should always be used to create\n+// SourceConfigBuilders.\n+//\n+// To see descriptions of the various SourceConfig fields and their defaults,\n+// see the methods to SourceConfigBuilder.\n+func DefaultSourceConfig() *SourceConfigBuilder {\n+\treturn &SourceConfigBuilder{\n+\t\tcfg: SourceConfig{\n+\t\t\tnumElements:   1, // 0 is invalid (drops elements).\n+\t\t\tinitialSplits: 1, // 0 is invalid (drops elements).\n+\t\t},\n+\t}\n+}\n+\n+// NumElements is the number of elements for the source to generate and emit.\n+//\n+// Valid values are in the range of [1, ...] and the default value is 1. Values\n+// of 0 (and below) are invalid as they result in sources that emit no elements.\n+func (b *SourceConfigBuilder) NumElements(val int) *SourceConfigBuilder {\n+\tb.cfg.numElements = val\n+\treturn b\n+}\n+\n+// InitialSplits determines the number of initial splits to perform in the\n+// source's SplitRestriction method. Restrictions in synthetic sources represent\n+// the number of elements being emitted, and this split is performed evenly\n+// across that number of elements.\n+//\n+// Each resulting restriction will have at least 1 element in it, and each\n+// element being emitted will be contained in exactly one restriction. That\n+// means that if the desired number of splits is greater than the number of\n+// elements N, then N initial restrictions will be created, each containing 1\n+// element.\n+//\n+// Valid values are in the range of [1, ...] and the default value is 1. Values\n+// of 0 (and below) are invalid as they would result in dropping elements that\n+// are expected to be emitted.\n+func (b *SourceConfigBuilder) InitialSplits(val int) *SourceConfigBuilder {\n+\tb.cfg.initialSplits = val\n+\treturn b\n+}\n+\n+// Build constructs the SourceConfig initialized by this builder. It also\n+// performs error checking on the fields, and panics if any have been set to\n+// invalid values.\n+func (b *SourceConfigBuilder) Build() SourceConfig {\n+\tif b.cfg.initialSplits <= 0 {\n+\t\tpanic(fmt.Sprintf(\"SourceConfig.InitialSplits must be >= 1. Got: %v\", b.cfg.initialSplits))\n+\t}\n+\tif b.cfg.numElements <= 0 {\n+\t\tpanic(fmt.Sprintf(\"SourceConfig.NumElements must be >= 1. Got: %v\", b.cfg.numElements))\n \t}\n+\treturn b.cfg\n }\n \n // SourceConfig is a struct containing all the configuration options for a\n-// synthetic source.\n+// synthetic source. It should be created via a SourceConfigBuilder.\n type SourceConfig struct {\n-\t// NumElements is the number of elements for the source to generate and\n-\t// emit.\n-\tNumElements int\n-\n-\t// InitialSplits determines the number of initial splits to perform in the\n-\t// source's SplitRestriction method. Note that in some edge cases, the\n-\t// number of splits performed might differ from this config value. Each\n-\t// restriction will always have one element in it, and at least one\n-\t// restriction will always be output, so the number of splits will be in\n-\t// the range of [1, N] where N is the size of the original restriction.\n-\tInitialSplits int\n+\tnumElements   int", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "875cc99bb795b761333a8513e8c3884961be054e"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwNDYwOA==", "bodyText": "Oh yea, forgot about that. I'll go with having them exported and just recommend a builder. Done.", "url": "https://github.com/apache/beam/pull/11747#discussion_r427004608", "createdAt": "2020-05-19T03:10:18Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -135,27 +155,79 @@ func (fn *sourceFn) ProcessElement(rt *offsetrange.Tracker, config SourceConfig,\n \treturn nil\n }\n \n-// DefaultSourceConfig creates a SourceConfig with intended defaults for its\n-// fields. SourceConfigs should be initialized with this method.\n-func DefaultSourceConfig() SourceConfig {\n-\treturn SourceConfig{\n-\t\tNumElements:   1, // Defaults shouldn't drop elements, so at least 1.\n-\t\tInitialSplits: 1, // Defaults to 1, i.e. no initial splitting.\n+// SourceConfigBuilder is used to initialize SourceConfigs. See\n+// SourceConfigBuilder's methods for descriptions of the fields in a\n+// SourceConfig and how they can be set. The intended approach for using this\n+// builder is to begin by calling the DefaultSourceConfig function, followed by\n+// calling setters, followed by calling Build.\n+//\n+// Usage example:\n+//\n+//    cfg := synthetic.DefaultSourceConfig().NumElements(5000).InitialSplits(2).Build()\n+type SourceConfigBuilder struct {\n+\tcfg SourceConfig\n+}\n+\n+// DefaultSourceConfig creates a SourceConfigBuilder set with intended defaults\n+// for the SourceConfig fields. This function is the intended starting point for\n+// initializing a SourceConfig and should always be used to create\n+// SourceConfigBuilders.\n+//\n+// To see descriptions of the various SourceConfig fields and their defaults,\n+// see the methods to SourceConfigBuilder.\n+func DefaultSourceConfig() *SourceConfigBuilder {\n+\treturn &SourceConfigBuilder{\n+\t\tcfg: SourceConfig{\n+\t\t\tnumElements:   1, // 0 is invalid (drops elements).\n+\t\t\tinitialSplits: 1, // 0 is invalid (drops elements).\n+\t\t},\n+\t}\n+}\n+\n+// NumElements is the number of elements for the source to generate and emit.\n+//\n+// Valid values are in the range of [1, ...] and the default value is 1. Values\n+// of 0 (and below) are invalid as they result in sources that emit no elements.\n+func (b *SourceConfigBuilder) NumElements(val int) *SourceConfigBuilder {\n+\tb.cfg.numElements = val\n+\treturn b\n+}\n+\n+// InitialSplits determines the number of initial splits to perform in the\n+// source's SplitRestriction method. Restrictions in synthetic sources represent\n+// the number of elements being emitted, and this split is performed evenly\n+// across that number of elements.\n+//\n+// Each resulting restriction will have at least 1 element in it, and each\n+// element being emitted will be contained in exactly one restriction. That\n+// means that if the desired number of splits is greater than the number of\n+// elements N, then N initial restrictions will be created, each containing 1\n+// element.\n+//\n+// Valid values are in the range of [1, ...] and the default value is 1. Values\n+// of 0 (and below) are invalid as they would result in dropping elements that\n+// are expected to be emitted.\n+func (b *SourceConfigBuilder) InitialSplits(val int) *SourceConfigBuilder {\n+\tb.cfg.initialSplits = val\n+\treturn b\n+}\n+\n+// Build constructs the SourceConfig initialized by this builder. It also\n+// performs error checking on the fields, and panics if any have been set to\n+// invalid values.\n+func (b *SourceConfigBuilder) Build() SourceConfig {\n+\tif b.cfg.initialSplits <= 0 {\n+\t\tpanic(fmt.Sprintf(\"SourceConfig.InitialSplits must be >= 1. Got: %v\", b.cfg.initialSplits))\n+\t}\n+\tif b.cfg.numElements <= 0 {\n+\t\tpanic(fmt.Sprintf(\"SourceConfig.NumElements must be >= 1. Got: %v\", b.cfg.numElements))\n \t}\n+\treturn b.cfg\n }\n \n // SourceConfig is a struct containing all the configuration options for a\n-// synthetic source.\n+// synthetic source. It should be created via a SourceConfigBuilder.\n type SourceConfig struct {\n-\t// NumElements is the number of elements for the source to generate and\n-\t// emit.\n-\tNumElements int\n-\n-\t// InitialSplits determines the number of initial splits to perform in the\n-\t// source's SplitRestriction method. Note that in some edge cases, the\n-\t// number of splits performed might differ from this config value. Each\n-\t// restriction will always have one element in it, and at least one\n-\t// restriction will always be output, so the number of splits will be in\n-\t// the range of [1, N] where N is the size of the original restriction.\n-\tInitialSplits int\n+\tnumElements   int", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzNTkwMw=="}, "originalCommit": {"oid": "875cc99bb795b761333a8513e8c3884961be054e"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODk4NTE1OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/io/synthetic/step.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMzowMzo1N1rOGXKRUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMzoxMDoyNlrOGXOS2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzODcwNA==", "bodyText": "Same comment here WRT the unexported fields being unserializable.", "url": "https://github.com/apache/beam/pull/11747#discussion_r426938704", "createdAt": "2020-05-18T23:03:57Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/step.go", "diffHunk": "@@ -144,49 +143,130 @@ func (fn *sdfStepFn) Setup() {\n // ProcessElement takes an input and either filters it or produces a number of\n // outputs identical to that input based on the restriction size.\n func (fn *sdfStepFn) ProcessElement(rt *offsetrange.Tracker, key, val []byte, emit func([]byte, []byte)) {\n-\tif fn.cfg.FilterRatio > 0 && fn.rng.Float64() < fn.cfg.FilterRatio {\n-\t\treturn\n-\t}\n+\tfiltered := fn.cfg.filterRatio > 0 && fn.rng.Float64() < fn.cfg.filterRatio\n+\n \tfor i := rt.Rest.Start; rt.TryClaim(i) == true; i++ {\n-\t\temit(key, val)\n+\t\tif !filtered {\n+\t\t\temit(key, val)\n+\t\t}\n+\t}\n+}\n+\n+// StepConfigBuilder is used to initialize StepConfigs. See StepConfigBuilder's\n+// methods for descriptions of the fields in a StepConfig and how they can be\n+// set. The intended approach for using this builder is to begin by calling the\n+// DefaultStepConfig function, followed by calling setters, followed by calling\n+// Build.\n+//\n+// Usage example:\n+//\n+//    cfg := synthetic.DefaultStepConfig().OutputPerInput(10).FilterRatio(0.5).Build()\n+type StepConfigBuilder struct {\n+\tcfg StepConfig\n+}\n+\n+// DefaultSourceConfig creates a StepConfig with intended defaults for the\n+// StepConfig fields. This function is the intended starting point for\n+// initializing a StepConfig and should always be used to create\n+// StepConfigBuilders.\n+//\n+// To see descriptions of the various StepConfig fields and their defaults, see\n+// the methods to StepConfigBuilder.\n+func DefaultStepConfig() *StepConfigBuilder {\n+\treturn &StepConfigBuilder{\n+\t\tcfg: StepConfig{\n+\t\t\toutputPerInput: 1,     // Defaults shouldn't drop elements, so at least 1.\n+\t\t\tfilterRatio:    0.0,   // Defaults shouldn't drop elements, so don't filter.\n+\t\t\tsplittable:     false, // Default to non-splittable, SDFs are situational.\n+\t\t\tinitialSplits:  1,     // Defaults to 1, i.e. no initial splitting.\n+\t\t},\n \t}\n }\n \n-// DefaultSourceConfig creates a SourceConfig with intended defaults for its\n-// fields. SourceConfigs should be initialized with this method.\n-func DefaultStepConfig() StepConfig {\n-\treturn StepConfig{\n-\t\tOutputPerInput: 1,     // Defaults shouldn't drop elements, so at least 1.\n-\t\tFilterRatio:    0.0,   // Defaults shouldn't drop elements, so don't filter.\n-\t\tSplittable:     false, // Default to non-splittable, SDFs are situational.\n-\t\tInitialSplits:  1,     // Defaults to 1, i.e. no initial splitting.\n+// OutputPerInput is the number of outputs to emit per input received. Each\n+// output is identical to the original input. A value of 0 drops all inputs and\n+// produces no output.\n+//\n+// Valid values are in the range of [0, ...] and the default value is 1. Values\n+// below 0 are invalid as they have no logical meaning for this field.\n+func (b *StepConfigBuilder) OutputPerInput(val int) *StepConfigBuilder {\n+\tb.cfg.outputPerInput = val\n+\treturn b\n+}\n+\n+// FilterRatio indicates the random chance that an input will be filtered\n+// out, meaning that no outputs will get emitted for it. For example, a\n+// FilterRatio of 0.25 means that 25% of inputs will be filtered out, a\n+// FilterRatio of 0 means no elements are filtered, and a FilterRatio of 1.0\n+// means every element is filtered.\n+//\n+// In a non-splittable step, this is performed on each input element, meaning\n+// all outputs for that element would be filtered. In a splittable step, this is\n+// performed on each input restriction instead of the entire element, meaning\n+// that some outputs for an element may be filtered and others kept.\n+//\n+// Note that even when elements are filtered out, the work associated with\n+// processing those elements is still performed, which differs from setting an\n+// OutputPerInput of 0. Also note that if a\n+//\n+// Valid values are in the range if [0.0, 1.0], and the default value is 0. In\n+// order to avoid precision errors, invalid values do not cause errors. Instead,\n+// values below 0 are functionally equivalent to 0, and values above 1 are\n+// functionally equivalent to 1.\n+func (b *StepConfigBuilder) FilterRatio(val float64) *StepConfigBuilder {\n+\tb.cfg.filterRatio = val\n+\treturn b\n+}\n+\n+// Splittable indicates whether the step should use the splittable DoFn or\n+// non-splittable DoFn implementation.\n+//\n+// Splittable steps will split along restrictions representing the number of\n+// OutputPerInput for each element, so it is most useful for steps with a high\n+// OutputPerInput. Conversely, if OutputPerInput is 1, then there is no way to\n+// split restrictions further, so making the step splittable will do nothing.\n+func (b *StepConfigBuilder) Splittable(val bool) *StepConfigBuilder {\n+\tb.cfg.splittable = val\n+\treturn b\n+}\n+\n+// InitialSplits is only applicable if Splittable is set to true, and determines\n+// the number of initial splits to perform in the step's SplitRestriction\n+// method. Restrictions in synthetic steps represent the number of elements to\n+// emit for each input element, as defined by the OutputPerInput config field,\n+// and this split is performed evenly across that number of elements.\n+//\n+// Each resulting restriction will have at least 1 element in it, and each\n+// element being emitted will be contained in exactly one restriction. That\n+// means that if the desired number of splits is greater than the OutputPerInput\n+// N, then N initial restrictions will be created, each containing 1 element.\n+//\n+// Valid values are in the range of [1, ...] and the default value is 1. Values\n+// of 0 (and below) are invalid as they would result in dropping elements that\n+// are expected to be emitted.\n+func (b *StepConfigBuilder) InitialSplits(val int) *StepConfigBuilder {\n+\tb.cfg.initialSplits = val\n+\treturn b\n+}\n+\n+// Build constructs the StepConfig initialized by this builder. It also performs\n+// error checking on the fields, and panics if any have been set to invalid\n+// values.\n+func (b *StepConfigBuilder) Build() StepConfig {\n+\tif b.cfg.initialSplits <= 0 {\n+\t\tpanic(fmt.Sprintf(\"StepConfig.InitialSplits must be >= 1. Got: %v\", b.cfg.initialSplits))\n+\t}\n+\tif b.cfg.outputPerInput < 0 {\n+\t\tpanic(fmt.Sprintf(\"StepConfig.OutputPerInput cannot be negative. Got: %v\", b.cfg.outputPerInput))\n \t}\n+\treturn b.cfg\n }\n \n // StepConfig is a struct containing all the configuration options for a\n-// synthetic step.\n+// synthetic step. It should be created via a StepConfigBuilder.\n type StepConfig struct {\n-\t// OutputPerInput is the number of outputs to emit per input received. Each\n-\t// output is identical to the original input. A value of 0 drops each input.\n-\tOutputPerInput int\n-\n-\t// FilterRatio indicates the random chance that an input will be filtered\n-\t// out, meaning that no outputs will get emitted for it. For example, a\n-\t// FilterRatio of 0.25 means that 25% of inputs will get filtered out.\n-\tFilterRatio float64\n-\n-\t// Splittable indicates whether the step should use the splittable DoFn or\n-\t// non-splittable DoFn implementation. Splittable steps will split the\n-\t// number of OutputPerInput into restrictions, so it is most useful for\n-\t// steps with a high OutputPerInput.\n-\tSplittable bool\n-\n-\t// InitialSplits is only applicable if Splittable is set to true, and\n-\t// determines the number of initial splits to perform in the step's\n-\t// SplitRestriction method. Note that in some edge cases, the number of\n-\t// splits performed might differ from this config value. Each restriction\n-\t// will always have one element in it, and at least one restriction will\n-\t// always be output, so the number of splits will be in the range of [1, N]\n-\t// where N is the size of the original restriction.\n-\tInitialSplits int\n+\toutputPerInput int", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "875cc99bb795b761333a8513e8c3884961be054e"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwNDYzNA==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/11747#discussion_r427004634", "createdAt": "2020-05-19T03:10:26Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/io/synthetic/step.go", "diffHunk": "@@ -144,49 +143,130 @@ func (fn *sdfStepFn) Setup() {\n // ProcessElement takes an input and either filters it or produces a number of\n // outputs identical to that input based on the restriction size.\n func (fn *sdfStepFn) ProcessElement(rt *offsetrange.Tracker, key, val []byte, emit func([]byte, []byte)) {\n-\tif fn.cfg.FilterRatio > 0 && fn.rng.Float64() < fn.cfg.FilterRatio {\n-\t\treturn\n-\t}\n+\tfiltered := fn.cfg.filterRatio > 0 && fn.rng.Float64() < fn.cfg.filterRatio\n+\n \tfor i := rt.Rest.Start; rt.TryClaim(i) == true; i++ {\n-\t\temit(key, val)\n+\t\tif !filtered {\n+\t\t\temit(key, val)\n+\t\t}\n+\t}\n+}\n+\n+// StepConfigBuilder is used to initialize StepConfigs. See StepConfigBuilder's\n+// methods for descriptions of the fields in a StepConfig and how they can be\n+// set. The intended approach for using this builder is to begin by calling the\n+// DefaultStepConfig function, followed by calling setters, followed by calling\n+// Build.\n+//\n+// Usage example:\n+//\n+//    cfg := synthetic.DefaultStepConfig().OutputPerInput(10).FilterRatio(0.5).Build()\n+type StepConfigBuilder struct {\n+\tcfg StepConfig\n+}\n+\n+// DefaultSourceConfig creates a StepConfig with intended defaults for the\n+// StepConfig fields. This function is the intended starting point for\n+// initializing a StepConfig and should always be used to create\n+// StepConfigBuilders.\n+//\n+// To see descriptions of the various StepConfig fields and their defaults, see\n+// the methods to StepConfigBuilder.\n+func DefaultStepConfig() *StepConfigBuilder {\n+\treturn &StepConfigBuilder{\n+\t\tcfg: StepConfig{\n+\t\t\toutputPerInput: 1,     // Defaults shouldn't drop elements, so at least 1.\n+\t\t\tfilterRatio:    0.0,   // Defaults shouldn't drop elements, so don't filter.\n+\t\t\tsplittable:     false, // Default to non-splittable, SDFs are situational.\n+\t\t\tinitialSplits:  1,     // Defaults to 1, i.e. no initial splitting.\n+\t\t},\n \t}\n }\n \n-// DefaultSourceConfig creates a SourceConfig with intended defaults for its\n-// fields. SourceConfigs should be initialized with this method.\n-func DefaultStepConfig() StepConfig {\n-\treturn StepConfig{\n-\t\tOutputPerInput: 1,     // Defaults shouldn't drop elements, so at least 1.\n-\t\tFilterRatio:    0.0,   // Defaults shouldn't drop elements, so don't filter.\n-\t\tSplittable:     false, // Default to non-splittable, SDFs are situational.\n-\t\tInitialSplits:  1,     // Defaults to 1, i.e. no initial splitting.\n+// OutputPerInput is the number of outputs to emit per input received. Each\n+// output is identical to the original input. A value of 0 drops all inputs and\n+// produces no output.\n+//\n+// Valid values are in the range of [0, ...] and the default value is 1. Values\n+// below 0 are invalid as they have no logical meaning for this field.\n+func (b *StepConfigBuilder) OutputPerInput(val int) *StepConfigBuilder {\n+\tb.cfg.outputPerInput = val\n+\treturn b\n+}\n+\n+// FilterRatio indicates the random chance that an input will be filtered\n+// out, meaning that no outputs will get emitted for it. For example, a\n+// FilterRatio of 0.25 means that 25% of inputs will be filtered out, a\n+// FilterRatio of 0 means no elements are filtered, and a FilterRatio of 1.0\n+// means every element is filtered.\n+//\n+// In a non-splittable step, this is performed on each input element, meaning\n+// all outputs for that element would be filtered. In a splittable step, this is\n+// performed on each input restriction instead of the entire element, meaning\n+// that some outputs for an element may be filtered and others kept.\n+//\n+// Note that even when elements are filtered out, the work associated with\n+// processing those elements is still performed, which differs from setting an\n+// OutputPerInput of 0. Also note that if a\n+//\n+// Valid values are in the range if [0.0, 1.0], and the default value is 0. In\n+// order to avoid precision errors, invalid values do not cause errors. Instead,\n+// values below 0 are functionally equivalent to 0, and values above 1 are\n+// functionally equivalent to 1.\n+func (b *StepConfigBuilder) FilterRatio(val float64) *StepConfigBuilder {\n+\tb.cfg.filterRatio = val\n+\treturn b\n+}\n+\n+// Splittable indicates whether the step should use the splittable DoFn or\n+// non-splittable DoFn implementation.\n+//\n+// Splittable steps will split along restrictions representing the number of\n+// OutputPerInput for each element, so it is most useful for steps with a high\n+// OutputPerInput. Conversely, if OutputPerInput is 1, then there is no way to\n+// split restrictions further, so making the step splittable will do nothing.\n+func (b *StepConfigBuilder) Splittable(val bool) *StepConfigBuilder {\n+\tb.cfg.splittable = val\n+\treturn b\n+}\n+\n+// InitialSplits is only applicable if Splittable is set to true, and determines\n+// the number of initial splits to perform in the step's SplitRestriction\n+// method. Restrictions in synthetic steps represent the number of elements to\n+// emit for each input element, as defined by the OutputPerInput config field,\n+// and this split is performed evenly across that number of elements.\n+//\n+// Each resulting restriction will have at least 1 element in it, and each\n+// element being emitted will be contained in exactly one restriction. That\n+// means that if the desired number of splits is greater than the OutputPerInput\n+// N, then N initial restrictions will be created, each containing 1 element.\n+//\n+// Valid values are in the range of [1, ...] and the default value is 1. Values\n+// of 0 (and below) are invalid as they would result in dropping elements that\n+// are expected to be emitted.\n+func (b *StepConfigBuilder) InitialSplits(val int) *StepConfigBuilder {\n+\tb.cfg.initialSplits = val\n+\treturn b\n+}\n+\n+// Build constructs the StepConfig initialized by this builder. It also performs\n+// error checking on the fields, and panics if any have been set to invalid\n+// values.\n+func (b *StepConfigBuilder) Build() StepConfig {\n+\tif b.cfg.initialSplits <= 0 {\n+\t\tpanic(fmt.Sprintf(\"StepConfig.InitialSplits must be >= 1. Got: %v\", b.cfg.initialSplits))\n+\t}\n+\tif b.cfg.outputPerInput < 0 {\n+\t\tpanic(fmt.Sprintf(\"StepConfig.OutputPerInput cannot be negative. Got: %v\", b.cfg.outputPerInput))\n \t}\n+\treturn b.cfg\n }\n \n // StepConfig is a struct containing all the configuration options for a\n-// synthetic step.\n+// synthetic step. It should be created via a StepConfigBuilder.\n type StepConfig struct {\n-\t// OutputPerInput is the number of outputs to emit per input received. Each\n-\t// output is identical to the original input. A value of 0 drops each input.\n-\tOutputPerInput int\n-\n-\t// FilterRatio indicates the random chance that an input will be filtered\n-\t// out, meaning that no outputs will get emitted for it. For example, a\n-\t// FilterRatio of 0.25 means that 25% of inputs will get filtered out.\n-\tFilterRatio float64\n-\n-\t// Splittable indicates whether the step should use the splittable DoFn or\n-\t// non-splittable DoFn implementation. Splittable steps will split the\n-\t// number of OutputPerInput into restrictions, so it is most useful for\n-\t// steps with a high OutputPerInput.\n-\tSplittable bool\n-\n-\t// InitialSplits is only applicable if Splittable is set to true, and\n-\t// determines the number of initial splits to perform in the step's\n-\t// SplitRestriction method. Note that in some edge cases, the number of\n-\t// splits performed might differ from this config value. Each restriction\n-\t// will always have one element in it, and at least one restriction will\n-\t// always be output, so the number of splits will be in the range of [1, N]\n-\t// where N is the size of the original restriction.\n-\tInitialSplits int\n+\toutputPerInput int", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkzODcwNA=="}, "originalCommit": {"oid": "875cc99bb795b761333a8513e8c3884961be054e"}, "originalPosition": 236}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3802, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}