{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3NzE2MTM1", "number": 12580, "title": "[BEAM-2855] nexmark python suite implement implement query 3, 4, 5, 6, 7, 8, 11", "bodyText": "implemented querys\nmade a little change to nexmark Launcher to fix a bug where the error is not passed out correctly\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nDataflow\nFlink\nSamza\nSpark\nTwister2\n\n\n\n\nGo\n\n---\n\n---\n\n---\n\n\nJava\n\n\n\n\n\n\n\n\nPython\n\n\n\n---\n\n---\n\n\nXLang\n\n---\n\n---\n\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\n\n\n\n\nNon-portable\n\n\n\n\n\n\nPortable\n---\n\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.\nGitHub Actions Tests Status (on master branch)\n\nSee CI.md for more information about GitHub Actions CI.", "createdAt": "2020-08-14T01:25:07Z", "url": "https://github.com/apache/beam/pull/12580", "merged": true, "mergeCommit": {"oid": "66055dbc8ac4e9338aaf04bdf7171549b339b898"}, "closed": true, "closedAt": "2020-08-22T00:15:03Z", "author": {"login": "leiyiz"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc-qMwcAH2gAyNDY3NzE2MTM1OjMwODVlNGExZWI2YjZlYmNkNTlhNTI1MGJjZGUzMjgwYmZiMmEyNGQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdBKXNvAH2gAyNDY3NzE2MTM1OjU1M2MwNzgwMDM4YjkwMDc3OTZlODU5ODM5NWU4MjVkZWIxN2FlZWQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3085e4a1eb6b6ebcd59a5250bcde3280bfb2a24d", "author": {"user": {"login": "leiyiz", "name": "Leiyi Zhang"}}, "url": "https://github.com/apache/beam/commit/3085e4a1eb6b6ebcd59a5250bcde3280bfb2a24d", "committedDate": "2020-08-14T01:19:20Z", "message": "implement query 3, 4, 5, 6, 7, 8, 11"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d", "author": {"user": {"login": "leiyiz", "name": "Leiyi Zhang"}}, "url": "https://github.com/apache/beam/commit/4a67c7bbaf85add9d52c5f0416ea7fae536b588d", "committedDate": "2020-08-14T02:08:31Z", "message": "forgot to run pylint2_3"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MjgxNzM3", "url": "https://github.com/apache/beam/pull/12580#pullrequestreview-467281737", "createdAt": "2020-08-14T03:18:43Z", "commit": {"oid": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMzoxODo0M1rOHAmJfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMzo1Mjo1MlrOHAmpnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4NzA2OA==", "bodyText": "The module document should be more explanatory.", "url": "https://github.com/apache/beam/pull/12580#discussion_r470387068", "createdAt": "2020-08-14T03:18:43Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/models/auction_count.py", "diffHunk": "@@ -0,0 +1,56 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Result of Query5.\"\"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4NzI2Mw==", "bodyText": "ditto", "url": "https://github.com/apache/beam/pull/12580#discussion_r470387263", "createdAt": "2020-08-14T03:19:27Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/models/bids_per_session.py", "diffHunk": "@@ -0,0 +1,56 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Result of Query11 and 12.\"\"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4ODE5MQ==", "bodyText": "Does every result class need a coder? What are the coder used for?", "url": "https://github.com/apache/beam/pull/12580#discussion_r470388191", "createdAt": "2020-08-14T03:23:12Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/models/bids_per_session.py", "diffHunk": "@@ -0,0 +1,56 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Result of Query11 and 12.\"\"\"\n+from __future__ import absolute_import\n+\n+from apache_beam.coders import coder_impl\n+from apache_beam.coders.coders import FastCoder\n+from apache_beam.testing.benchmarks.nexmark import nexmark_util\n+\n+\n+class BidsPerSessionCoder(FastCoder):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5MDEyMg==", "bodyText": "are all the result objects necessary? if it is for validation purpose we should be able to just use a dict and rely on additional script to compare.", "url": "https://github.com/apache/beam/pull/12580#discussion_r470390122", "createdAt": "2020-08-14T03:30:56Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/models/auction_count.py", "diffHunk": "@@ -0,0 +1,56 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Result of Query5.\"\"\"\n+from __future__ import absolute_import\n+\n+from apache_beam.coders import coder_impl\n+from apache_beam.coders.coders import FastCoder\n+from apache_beam.testing.benchmarks.nexmark import nexmark_util\n+\n+\n+class AuctionCountCoder(FastCoder):\n+  def _create_impl(self):\n+    return AuctionCountCoderImpl()\n+\n+  def is_deterministic(self):\n+    # type: () -> bool\n+    return True\n+\n+\n+class AuctionCount(object):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5MTQ2Nw==", "bodyText": "by default it should be 0 so this is not necessary.", "url": "https://github.com/apache/beam/pull/12580#discussion_r470391467", "createdAt": "2020-08-14T03:36:22Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query3.py", "diffHunk": "@@ -0,0 +1,164 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 3, 'Local Item Suggestion'. Who is selling in OR, ID or CA in category\n+10, and for what auction ids? In CQL syntax::\n+\n+  SELECT Istream(P.name, P.city, P.state, A.id)\n+  FROM Auction A [ROWS UNBOUNDED], Person P [ROWS UNBOUNDED]\n+  WHERE A.seller = P.id\n+    AND (P.state = `OR' OR P.state = `ID' OR P.state = `CA')\n+    AND A.category = 10;\n+\n+We'll implement this query to allow 'new auction' events to come before the\n+'new person' events for the auction seller. Those auctions will be stored until\n+the matching person is seen. Then all subsequent auctions for a person will use\n+the stored person record.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import logging\n+\n+import apache_beam as beam\n+from apache_beam.coders import coders\n+from apache_beam.testing.benchmarks.nexmark.models import name_city_state_id\n+from apache_beam.testing.benchmarks.nexmark.models import nexmark_model\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import userstate\n+from apache_beam.transforms import window\n+from apache_beam.transforms.userstate import on_timer\n+from apache_beam.utils.timestamp import Duration\n+\n+\n+def load(events, metadata=None):\n+  num_events_in_pane = 30\n+  windowed_events = (\n+      events\n+      | beam.WindowInto(\n+          window.GlobalWindows(),\n+          trigger=trigger.Repeatedly(trigger.AfterCount(num_events_in_pane)),\n+          accumulation_mode=trigger.AccumulationMode.DISCARDING,\n+          allowed_lateness=Duration.of(0)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5Mjc2Nw==", "bodyText": "Should this be a BagUserState instead, generally it's better to use BagUserState for iterables.", "url": "https://github.com/apache/beam/pull/12580#discussion_r470392767", "createdAt": "2020-08-14T03:42:16Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query3.py", "diffHunk": "@@ -0,0 +1,164 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 3, 'Local Item Suggestion'. Who is selling in OR, ID or CA in category\n+10, and for what auction ids? In CQL syntax::\n+\n+  SELECT Istream(P.name, P.city, P.state, A.id)\n+  FROM Auction A [ROWS UNBOUNDED], Person P [ROWS UNBOUNDED]\n+  WHERE A.seller = P.id\n+    AND (P.state = `OR' OR P.state = `ID' OR P.state = `CA')\n+    AND A.category = 10;\n+\n+We'll implement this query to allow 'new auction' events to come before the\n+'new person' events for the auction seller. Those auctions will be stored until\n+the matching person is seen. Then all subsequent auctions for a person will use\n+the stored person record.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import logging\n+\n+import apache_beam as beam\n+from apache_beam.coders import coders\n+from apache_beam.testing.benchmarks.nexmark.models import name_city_state_id\n+from apache_beam.testing.benchmarks.nexmark.models import nexmark_model\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import userstate\n+from apache_beam.transforms import window\n+from apache_beam.transforms.userstate import on_timer\n+from apache_beam.utils.timestamp import Duration\n+\n+\n+def load(events, metadata=None):\n+  num_events_in_pane = 30\n+  windowed_events = (\n+      events\n+      | beam.WindowInto(\n+          window.GlobalWindows(),\n+          trigger=trigger.Repeatedly(trigger.AfterCount(num_events_in_pane)),\n+          accumulation_mode=trigger.AccumulationMode.DISCARDING,\n+          allowed_lateness=Duration.of(0)))\n+  auction_by_seller_id = (\n+      windowed_events\n+      | nexmark_query_util.JustAuctions()\n+      | 'query3_filter_category' >> beam.Filter(lambda auc: auc.category == 10)\n+      | 'query3_key_by_seller' >> beam.ParDo(\n+          nexmark_query_util.AuctionBySellerFn()))\n+  person_by_id = (\n+      windowed_events\n+      | nexmark_query_util.JustPerson()\n+      | 'query3_filter_region' >> beam.Filter(\n+          lambda person: person.state == 'OR' or person.state == 'ID' or person.\n+          state == 'CA')\n+      | 'query3_key_by_person_id' >> beam.ParDo(\n+          nexmark_query_util.PersonByIdFn()))\n+  return ({\n+      nexmark_query_util.AUCTION_TAG: auction_by_seller_id,\n+      nexmark_query_util.PERSON_TAG: person_by_id,\n+  }\n+          | beam.CoGroupByKey()\n+          | 'query3_join' >> beam.ParDo(\n+              JoinFn(metadata.get('max_auction_waiting_time')))\n+          | 'query3_output' >> beam.Map(\n+              lambda t: name_city_state_id.NameCiyStateId(\n+                  t[1].name, t[1].city, t[1].state, t[0].id)))\n+\n+\n+class JoinFn(beam.DoFn):\n+  \"\"\"\n+  Join auctions and person by person id and emit their product one pair at\n+  a time.\n+\n+  We know a person may submit any number of auctions. Thus new person event\n+  must have the person record stored in persistent state in order to match\n+  future auctions by that person.\n+\n+  However we know that each auction is associated with at most one person, so\n+  only need to store auction records in persistent state until we have seen the\n+  corresponding person record. And of course may have already seen that record.\n+  \"\"\"\n+\n+  AUCTIONS = 'auctions_state'\n+  PERSON = 'person_state'\n+  PERSON_EXPIRING = 'person_state_expiring'\n+\n+  auction_spec = userstate.ReadModifyWriteStateSpec(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5NDQ4Ng==", "bodyText": "remove this?", "url": "https://github.com/apache/beam/pull/12580#discussion_r470394486", "createdAt": "2020-08-14T03:49:28Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query6.py", "diffHunk": "@@ -0,0 +1,93 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 6, 'Average Selling Price by Seller'. Select the average selling price\n+over the last 10 closed auctions by the same seller. In CQL syntax::\n+\n+  SELECT Istream(AVG(Q.final), Q.seller)\n+  FROM (SELECT Rstream(MAX(B.price) AS final, A.seller)\n+    FROM Auction A [ROWS UNBOUNDED], Bid B [ROWS UNBOUNDED]\n+    WHERE A.id=B.auction\n+      AND B.datetime < A.expires AND A.expires < CURRENT_TIME\n+    GROUP BY A.id, A.seller) [PARTITION BY A.seller ROWS 10] Q\n+  GROUP BY Q.seller;\n+\"\"\"\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.models import seller_price\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.testing.benchmarks.nexmark.queries import winning_bids\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import window\n+\n+\n+def load(events, metadata=None):\n+  # find winning bids for each closed auction\n+  return (\n+      events\n+      # find winning bids\n+      | beam.Filter(nexmark_query_util.auction_or_bid)\n+      | winning_bids.WinningBids()\n+      # (auction_bids -> (aution.seller, bid)\n+      | beam.Map(lambda auc_bid: (auc_bid.auction.seller, auc_bid.bid))\n+      # calculate and output mean as data arrives\n+      | beam.WindowInto(\n+          window.GlobalWindows(),\n+          trigger=trigger.Repeatedly(trigger.AfterCount(1)),\n+          accumulation_mode=trigger.AccumulationMode.ACCUMULATING,\n+          allowed_lateness=0)\n+      # | beam.combiners.Count.Globally())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5NDkyMw==", "bodyText": "should this be a while loop?", "url": "https://github.com/apache/beam/pull/12580#discussion_r470394923", "createdAt": "2020-08-14T03:51:13Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query6.py", "diffHunk": "@@ -0,0 +1,93 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 6, 'Average Selling Price by Seller'. Select the average selling price\n+over the last 10 closed auctions by the same seller. In CQL syntax::\n+\n+  SELECT Istream(AVG(Q.final), Q.seller)\n+  FROM (SELECT Rstream(MAX(B.price) AS final, A.seller)\n+    FROM Auction A [ROWS UNBOUNDED], Bid B [ROWS UNBOUNDED]\n+    WHERE A.id=B.auction\n+      AND B.datetime < A.expires AND A.expires < CURRENT_TIME\n+    GROUP BY A.id, A.seller) [PARTITION BY A.seller ROWS 10] Q\n+  GROUP BY Q.seller;\n+\"\"\"\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.models import seller_price\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.testing.benchmarks.nexmark.queries import winning_bids\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import window\n+\n+\n+def load(events, metadata=None):\n+  # find winning bids for each closed auction\n+  return (\n+      events\n+      # find winning bids\n+      | beam.Filter(nexmark_query_util.auction_or_bid)\n+      | winning_bids.WinningBids()\n+      # (auction_bids -> (aution.seller, bid)\n+      | beam.Map(lambda auc_bid: (auc_bid.auction.seller, auc_bid.bid))\n+      # calculate and output mean as data arrives\n+      | beam.WindowInto(\n+          window.GlobalWindows(),\n+          trigger=trigger.Repeatedly(trigger.AfterCount(1)),\n+          accumulation_mode=trigger.AccumulationMode.ACCUMULATING,\n+          allowed_lateness=0)\n+      # | beam.combiners.Count.Globally())\n+      | beam.CombinePerKey(MovingMeanSellingPriceFn(10))\n+      | beam.Map(lambda t: seller_price.SellerPrice(t[0], t[1])))\n+\n+\n+class MovingMeanSellingPriceFn(beam.CombineFn):\n+  \"\"\"\n+  Combiner to keep track of up to max_num_bids of the most recent wining\n+  bids and calculate their average selling price.\n+  \"\"\"\n+  def __init__(self, max_num_bids):\n+    self.max_num_bids = max_num_bids\n+\n+  def create_accumulator(self):\n+    return []\n+\n+  def add_input(self, accumulator, element):\n+    accumulator.append(element)\n+    new_accu = sorted(accumulator, key=lambda bid: (bid.date_time, bid.price))\n+    if len(new_accu) > self.max_num_bids:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5NTI5NQ==", "bodyText": "call sum() directly?", "url": "https://github.com/apache/beam/pull/12580#discussion_r470395295", "createdAt": "2020-08-14T03:52:52Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query6.py", "diffHunk": "@@ -0,0 +1,93 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 6, 'Average Selling Price by Seller'. Select the average selling price\n+over the last 10 closed auctions by the same seller. In CQL syntax::\n+\n+  SELECT Istream(AVG(Q.final), Q.seller)\n+  FROM (SELECT Rstream(MAX(B.price) AS final, A.seller)\n+    FROM Auction A [ROWS UNBOUNDED], Bid B [ROWS UNBOUNDED]\n+    WHERE A.id=B.auction\n+      AND B.datetime < A.expires AND A.expires < CURRENT_TIME\n+    GROUP BY A.id, A.seller) [PARTITION BY A.seller ROWS 10] Q\n+  GROUP BY Q.seller;\n+\"\"\"\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.models import seller_price\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.testing.benchmarks.nexmark.queries import winning_bids\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import window\n+\n+\n+def load(events, metadata=None):\n+  # find winning bids for each closed auction\n+  return (\n+      events\n+      # find winning bids\n+      | beam.Filter(nexmark_query_util.auction_or_bid)\n+      | winning_bids.WinningBids()\n+      # (auction_bids -> (aution.seller, bid)\n+      | beam.Map(lambda auc_bid: (auc_bid.auction.seller, auc_bid.bid))\n+      # calculate and output mean as data arrives\n+      | beam.WindowInto(\n+          window.GlobalWindows(),\n+          trigger=trigger.Repeatedly(trigger.AfterCount(1)),\n+          accumulation_mode=trigger.AccumulationMode.ACCUMULATING,\n+          allowed_lateness=0)\n+      # | beam.combiners.Count.Globally())\n+      | beam.CombinePerKey(MovingMeanSellingPriceFn(10))\n+      | beam.Map(lambda t: seller_price.SellerPrice(t[0], t[1])))\n+\n+\n+class MovingMeanSellingPriceFn(beam.CombineFn):\n+  \"\"\"\n+  Combiner to keep track of up to max_num_bids of the most recent wining\n+  bids and calculate their average selling price.\n+  \"\"\"\n+  def __init__(self, max_num_bids):\n+    self.max_num_bids = max_num_bids\n+\n+  def create_accumulator(self):\n+    return []\n+\n+  def add_input(self, accumulator, element):\n+    accumulator.append(element)\n+    new_accu = sorted(accumulator, key=lambda bid: (bid.date_time, bid.price))\n+    if len(new_accu) > self.max_num_bids:\n+      del new_accu[0]\n+    return new_accu\n+\n+  def merge_accumulators(self, accumulators):\n+    new_accu = []\n+    for accumulator in accumulators:\n+      new_accu += accumulator\n+    new_accu.sort(key=lambda bid: (bid.date_time, bid.price))\n+    return new_accu[-10:]\n+\n+  def extract_output(self, accumulator):\n+    if len(accumulator) == 0:\n+      return 0\n+    sum_price = 0\n+    for bid in accumulator:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d"}, "originalPosition": 91}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9aa549faf09689672663feddd91b365f231ec683", "author": {"user": {"login": "leiyiz", "name": "Leiyi Zhang"}}, "url": "https://github.com/apache/beam/commit/9aa549faf09689672663feddd91b365f231ec683", "committedDate": "2020-08-17T22:41:55Z", "message": "using dict instead of object for results of query"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTY3OTU5", "url": "https://github.com/apache/beam/pull/12580#pullrequestreview-468967959", "createdAt": "2020-08-18T03:34:16Z", "commit": {"oid": "9aa549faf09689672663feddd91b365f231ec683"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMzozNDoxNlrOHCCG8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMzo1MTowNFrOHCCWgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5Mzc0NA==", "bodyText": "this can be put in nexmark_query_utils", "url": "https://github.com/apache/beam/pull/12580#discussion_r471893744", "createdAt": "2020-08-18T03:34:16Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/models/result_name.py", "diffHunk": "@@ -0,0 +1,35 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\" field names for the final results of queries\n+\"\"\"\n+\n+\n+class ResultNames:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9aa549faf09689672663feddd91b365f231ec683"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5NDk4NA==", "bodyText": "nit: person.state in ['OR', 'ID', 'CA']", "url": "https://github.com/apache/beam/pull/12580#discussion_r471894984", "createdAt": "2020-08-18T03:39:30Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query3.py", "diffHunk": "@@ -0,0 +1,160 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 3, 'Local Item Suggestion'. Who is selling in OR, ID or CA in category\n+10, and for what auction ids? In CQL syntax::\n+\n+  SELECT Istream(P.name, P.city, P.state, A.id)\n+  FROM Auction A [ROWS UNBOUNDED], Person P [ROWS UNBOUNDED]\n+  WHERE A.seller = P.id\n+    AND (P.state = `OR' OR P.state = `ID' OR P.state = `CA')\n+    AND A.category = 10;\n+\n+We'll implement this query to allow 'new auction' events to come before the\n+'new person' events for the auction seller. Those auctions will be stored until\n+the matching person is seen. Then all subsequent auctions for a person will use\n+the stored person record.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import logging\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.models import nexmark_model\n+from apache_beam.testing.benchmarks.nexmark.models.result_name import ResultNames\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import userstate\n+from apache_beam.transforms import window\n+from apache_beam.transforms.userstate import on_timer\n+\n+\n+def load(events, metadata=None):\n+  num_events_in_pane = 30\n+  windowed_events = (\n+      events\n+      | beam.WindowInto(\n+          window.GlobalWindows(),\n+          trigger=trigger.Repeatedly(trigger.AfterCount(num_events_in_pane)),\n+          accumulation_mode=trigger.AccumulationMode.DISCARDING))\n+  auction_by_seller_id = (\n+      windowed_events\n+      | nexmark_query_util.JustAuctions()\n+      | 'query3_filter_category' >> beam.Filter(lambda auc: auc.category == 10)\n+      | 'query3_key_by_seller' >> beam.ParDo(\n+          nexmark_query_util.AuctionBySellerFn()))\n+  person_by_id = (\n+      windowed_events\n+      | nexmark_query_util.JustPerson()\n+      | 'query3_filter_region' >> beam.Filter(\n+          lambda person: person.state == 'OR' or person.state == 'ID' or person.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9aa549faf09689672663feddd91b365f231ec683"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5NTkwNw==", "bodyText": "fanout has bug -> fanout with sliding window produces duplicated results.", "url": "https://github.com/apache/beam/pull/12580#discussion_r471895907", "createdAt": "2020-08-18T03:43:40Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query4.py", "diffHunk": "@@ -0,0 +1,80 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 4, 'Average Price for a Category'. Select the average of the wining bid\n+prices for all closed auctions in each category. In CQL syntax::\n+\n+  SELECT Istream(AVG(Q.final))\n+  FROM Category C, (SELECT Rstream(MAX(B.price) AS final, A.category)\n+    FROM Auction A [ROWS UNBOUNDED], Bid B [ROWS UNBOUNDED]\n+    WHERE A.id=B.auction\n+      AND B.datetime < A.expires AND A.expires < CURRENT_TIME\n+    GROUP BY A.id, A.category) Q\n+  WHERE Q.category = C.id\n+  GROUP BY C.id;\n+\n+For extra spiciness our implementation differs slightly from the above:\n+\n+* We select both the average winning price and the category.\n+* We don't bother joining with a static category table, since it's\n+  contents are never used.\n+* We only consider bids which are above the auction's reserve price.\n+* We accept the highest-price, earliest valid bid as the winner.\n+* We calculate the averages oven a sliding window of size\n+  window_size_sec and period window_period_sec.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.models.result_name import ResultNames\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.testing.benchmarks.nexmark.queries import winning_bids\n+from apache_beam.transforms import window\n+\n+\n+def load(events, metadata=None):\n+  # find winning bids for each closed auction\n+  all_winning_bids = (\n+      events\n+      | beam.Filter(nexmark_query_util.auction_or_bid)\n+      | winning_bids.WinningBids())\n+  return (\n+      all_winning_bids\n+      # key winning bids by auction category\n+      | beam.Map(lambda auc_bid: (auc_bid.auction.category, auc_bid.bid.price))\n+      # re-window for sliding average\n+      | beam.WindowInto(\n+          window.SlidingWindows(\n+              metadata.get('window_size_sec'),\n+              metadata.get('window_period_sec')))\n+      # average for each category\n+      | beam.CombinePerKey(beam.combiners.MeanCombineFn())\n+      # TODO(leiyiz): fanout has bug, uncomment after it is fixed [BEAM-10617]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9aa549faf09689672663feddd91b365f231ec683"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5NzczMQ==", "bodyText": "'repr' seems redundant", "url": "https://github.com/apache/beam/pull/12580#discussion_r471897731", "createdAt": "2020-08-18T03:51:04Z", "author": {"login": "y1chi"}, "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query3.py", "diffHunk": "@@ -0,0 +1,160 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 3, 'Local Item Suggestion'. Who is selling in OR, ID or CA in category\n+10, and for what auction ids? In CQL syntax::\n+\n+  SELECT Istream(P.name, P.city, P.state, A.id)\n+  FROM Auction A [ROWS UNBOUNDED], Person P [ROWS UNBOUNDED]\n+  WHERE A.seller = P.id\n+    AND (P.state = `OR' OR P.state = `ID' OR P.state = `CA')\n+    AND A.category = 10;\n+\n+We'll implement this query to allow 'new auction' events to come before the\n+'new person' events for the auction seller. Those auctions will be stored until\n+the matching person is seen. Then all subsequent auctions for a person will use\n+the stored person record.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import logging\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.models import nexmark_model\n+from apache_beam.testing.benchmarks.nexmark.models.result_name import ResultNames\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import userstate\n+from apache_beam.transforms import window\n+from apache_beam.transforms.userstate import on_timer\n+\n+\n+def load(events, metadata=None):\n+  num_events_in_pane = 30\n+  windowed_events = (\n+      events\n+      | beam.WindowInto(\n+          window.GlobalWindows(),\n+          trigger=trigger.Repeatedly(trigger.AfterCount(num_events_in_pane)),\n+          accumulation_mode=trigger.AccumulationMode.DISCARDING))\n+  auction_by_seller_id = (\n+      windowed_events\n+      | nexmark_query_util.JustAuctions()\n+      | 'query3_filter_category' >> beam.Filter(lambda auc: auc.category == 10)\n+      | 'query3_key_by_seller' >> beam.ParDo(\n+          nexmark_query_util.AuctionBySellerFn()))\n+  person_by_id = (\n+      windowed_events\n+      | nexmark_query_util.JustPerson()\n+      | 'query3_filter_region' >> beam.Filter(\n+          lambda person: person.state == 'OR' or person.state == 'ID' or person.\n+          state == 'CA')\n+      | 'query3_key_by_person_id' >> beam.ParDo(\n+          nexmark_query_util.PersonByIdFn()))\n+  return ({\n+      nexmark_query_util.AUCTION_TAG: auction_by_seller_id,\n+      nexmark_query_util.PERSON_TAG: person_by_id,\n+  }\n+          | beam.CoGroupByKey()\n+          | 'query3_join' >> beam.ParDo(\n+              JoinFn(metadata.get('max_auction_waiting_time')))\n+          | 'query3_output' >> beam.Map(\n+              lambda t: {\n+                  ResultNames.NAME: t[1].name,\n+                  ResultNames.CITY: t[1].city,\n+                  ResultNames.STATE: t[1].state,\n+                  ResultNames.AUCTION_ID: t[0].id\n+              }))\n+\n+\n+class JoinFn(beam.DoFn):\n+  \"\"\"\n+  Join auctions and person by person id and emit their product one pair at\n+  a time.\n+\n+  We know a person may submit any number of auctions. Thus new person event\n+  must have the person record stored in persistent state in order to match\n+  future auctions by that person.\n+\n+  However we know that each auction is associated with at most one person, so\n+  only need to store auction records in persistent state until we have seen the\n+  corresponding person record. And of course may have already seen that record.\n+  \"\"\"\n+\n+  AUCTIONS = 'auctions_state'\n+  PERSON = 'person_state'\n+  PERSON_EXPIRING = 'person_state_expiring'\n+\n+  auction_spec = userstate.BagStateSpec(AUCTIONS, nexmark_model.Auction.CODER)\n+  person_spec = userstate.ReadModifyWriteStateSpec(\n+      PERSON, nexmark_model.Person.CODER)\n+  person_timer_spec = userstate.TimerSpec(\n+      PERSON_EXPIRING, userstate.TimeDomain.WATERMARK)\n+\n+  def __init__(self, max_auction_wait_time):\n+    self.max_auction_wait_time = max_auction_wait_time\n+\n+  def process(\n+      self,\n+      element,\n+      auction_state=beam.DoFn.StateParam(auction_spec),\n+      person_state=beam.DoFn.StateParam(person_spec),\n+      person_timer=beam.DoFn.TimerParam(person_timer_spec)):\n+    # extract group with tags from element tuple\n+    _, group = element\n+\n+    existing_person = person_state.read()\n+    if existing_person:\n+      # the person exists in person_state for this person id\n+      for auction in group[nexmark_query_util.AUCTION_TAG]:\n+        yield auction, existing_person\n+      return\n+\n+    new_person = None\n+    for person in group[nexmark_query_util.PERSON_TAG]:\n+      if not new_person:\n+        new_person = person\n+      else:\n+        logging.error(\n+            'two new person wtih same key: %s and %s' %\n+            (repr(person), repr(new_person)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9aa549faf09689672663feddd91b365f231ec683"}, "originalPosition": 136}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f972b520c825d95e750801d8e3985834d17eef70", "author": {"user": {"login": "leiyiz", "name": "Leiyi Zhang"}}, "url": "https://github.com/apache/beam/commit/f972b520c825d95e750801d8e3985834d17eef70", "committedDate": "2020-08-20T00:03:32Z", "message": "added to_type_hint for coders, fixed issues brought up in code review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMTQ3Mjcz", "url": "https://github.com/apache/beam/pull/12580#pullrequestreview-472147273", "createdAt": "2020-08-21T05:07:56Z", "commit": {"oid": "f972b520c825d95e750801d8e3985834d17eef70"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwNTowNzo1NlrOHEbwvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwNjowMzoyM1rOHEcqXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMTE5OA==", "bodyText": "maybe remove this TODO", "url": "https://github.com/apache/beam/pull/12580#discussion_r474411198", "createdAt": "2020-08-21T05:07:56Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/nexmark_launcher.py", "diffHunk": "@@ -242,12 +249,28 @@ def run(self):\n     queries = {\n         0: query0,\n         1: query1,\n-        2: query2,  # TODO(mariagh): Add more queries.\n-        9: query9\n+        2: query2,\n+        3: query3,\n+        4: query4,\n+        5: query5,\n+        6: query6,\n+        7: query7,\n+        8: query8,\n+        9: query9,\n+        11: query11\n     }\n \n     # TODO(mariagh): Move to a config file.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f972b520c825d95e750801d8e3985834d17eef70"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMTQxNw==", "bodyText": "how come we don't have per-query query-args anymore?", "url": "https://github.com/apache/beam/pull/12580#discussion_r474411417", "createdAt": "2020-08-21T05:08:55Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/nexmark_launcher.py", "diffHunk": "@@ -262,13 +285,13 @@ def run(self):\n       query_duration = self.pipeline_options.view_as(TestOptions).wait_until_finish_duration  # pylint: disable=line-too-long\n       if launch_from_direct_runner:\n         command = Command(\n-            self.run_query, args=[queries[i], query_args.get(i), query_errors])\n+            self.run_query, args=[queries[i], query_args, query_errors])\n         command.run(timeout=query_duration // 1000)\n       else:\n         try:\n-          self.run_query(queries[i], query_args.get(i), query_errors=None)\n+          self.run_query(queries[i], query_args, query_errors=query_errors)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f972b520c825d95e750801d8e3985834d17eef70"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxOTkwOQ==", "bodyText": "Is this how this is implemented in Java? I am wondering if we should make bids comparable. If they were comparable, then you would be able to just return max_prices\ne.g.:\n@functools.total_ordering\nclass ComparableBidByPrice(object):\n  def __init__(self, bid):\n    self.bid = bid\n  def __eq__(self, other):\n    return self.bid == other.bid\n  def __lt__(self, other):\n    return self.bid.price < other.bid.price\n\nAnd then you'd do:\n  max_bids = (\n      sliding_bids\n      | beam.Map(ComparableBidByPrice)\n      | beam.CombineGlobally(max).without_defaults())\n\nthoughts? The main thing here is having one fewer stage, thus higher performance - but I think the best option is to do whatever Java does.", "url": "https://github.com/apache/beam/pull/12580#discussion_r474419909", "createdAt": "2020-08-21T05:41:58Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query7.py", "diffHunk": "@@ -0,0 +1,59 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 7, 'Highest Bid'. Select the bids with the highest bid price in the\n+last minute. In CQL syntax::\n+\n+  SELECT Rstream(B.auction, B.price, B.bidder)\n+  FROM Bid [RANGE 1 MINUTE SLIDE 1 MINUTE] B\n+  WHERE B.price = (SELECT MAX(B1.price)\n+                   FROM BID [RANGE 1 MINUTE SLIDE 1 MINUTE] B1);\n+\n+We will use a shorter window to help make testing easier. We'll also\n+implement this using a side-input in order to exercise that functionality.\n+(A combiner, as used in Query 5, is a more efficient approach.).\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.transforms import window\n+\n+\n+def load(events, metadata=None):\n+  # window bids into fixed window\n+  sliding_bids = (\n+      events\n+      | nexmark_query_util.JustBids()\n+      | beam.WindowInto(window.FixedWindows(metadata.get('window_size_sec'))))\n+  # find the largest price in all bids per window\n+  max_prices = (\n+      sliding_bids\n+      | beam.Map(lambda bid: bid.price)\n+      | beam.CombineGlobally(max).without_defaults())\n+  return (\n+      sliding_bids\n+      | 'select_bids' >> beam.ParDo(\n+          SelectMaxBidFn(), beam.pvalue.AsSingleton(max_prices)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f972b520c825d95e750801d8e3985834d17eef70"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQyMjc0Mg==", "bodyText": "Deleting from the begining of a Python list is very slow (as all elements have to be shifted). Should the sorting be opposite and wwe just drop from the end?", "url": "https://github.com/apache/beam/pull/12580#discussion_r474422742", "createdAt": "2020-08-21T05:52:02Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query6.py", "diffHunk": "@@ -0,0 +1,92 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 6, 'Average Selling Price by Seller'. Select the average selling price\n+over the last 10 closed auctions by the same seller. In CQL syntax::\n+\n+  SELECT Istream(AVG(Q.final), Q.seller)\n+  FROM (SELECT Rstream(MAX(B.price) AS final, A.seller)\n+    FROM Auction A [ROWS UNBOUNDED], Bid B [ROWS UNBOUNDED]\n+    WHERE A.id=B.auction\n+      AND B.datetime < A.expires AND A.expires < CURRENT_TIME\n+    GROUP BY A.id, A.seller) [PARTITION BY A.seller ROWS 10] Q\n+  GROUP BY Q.seller;\n+\"\"\"\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.testing.benchmarks.nexmark.queries import winning_bids\n+from apache_beam.testing.benchmarks.nexmark.queries.nexmark_query_util import ResultNames\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import window\n+\n+\n+def load(events, metadata=None):\n+  # find winning bids for each closed auction\n+  return (\n+      events\n+      # find winning bids\n+      | beam.Filter(nexmark_query_util.auction_or_bid)\n+      | winning_bids.WinningBids()\n+      # (auction_bids -> (aution.seller, bid)\n+      | beam.Map(lambda auc_bid: (auc_bid.auction.seller, auc_bid.bid))\n+      # calculate and output mean as data arrives\n+      | beam.WindowInto(\n+          window.GlobalWindows(),\n+          trigger=trigger.Repeatedly(trigger.AfterCount(1)),\n+          accumulation_mode=trigger.AccumulationMode.ACCUMULATING,\n+          allowed_lateness=0)\n+      | beam.CombinePerKey(MovingMeanSellingPriceFn(10))\n+      | beam.Map(lambda t: {\n+          ResultNames.SELLER: t[0], ResultNames.PRICE: t[1]\n+      }))\n+\n+\n+class MovingMeanSellingPriceFn(beam.CombineFn):\n+  \"\"\"\n+  Combiner to keep track of up to max_num_bids of the most recent wining\n+  bids and calculate their average selling price.\n+  \"\"\"\n+  def __init__(self, max_num_bids):\n+    self.max_num_bids = max_num_bids\n+\n+  def create_accumulator(self):\n+    return []\n+\n+  def add_input(self, accumulator, element):\n+    accumulator.append(element)\n+    new_accu = sorted(accumulator, key=lambda bid: (bid.date_time, bid.price))\n+    if len(new_accu) > self.max_num_bids:\n+      del new_accu[0]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f972b520c825d95e750801d8e3985834d17eef70"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQyMzMzMw==", "bodyText": "This trigger is a little hard to wrap my head around : ) can you help me understand it? So I guess we simply accumulate fired panes and fire everything every time? (let's say that the stream contains a new element every second. Would we fire 1000 elements after 1000 seconds?)", "url": "https://github.com/apache/beam/pull/12580#discussion_r474423333", "createdAt": "2020-08-21T05:54:14Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query6.py", "diffHunk": "@@ -0,0 +1,92 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 6, 'Average Selling Price by Seller'. Select the average selling price\n+over the last 10 closed auctions by the same seller. In CQL syntax::\n+\n+  SELECT Istream(AVG(Q.final), Q.seller)\n+  FROM (SELECT Rstream(MAX(B.price) AS final, A.seller)\n+    FROM Auction A [ROWS UNBOUNDED], Bid B [ROWS UNBOUNDED]\n+    WHERE A.id=B.auction\n+      AND B.datetime < A.expires AND A.expires < CURRENT_TIME\n+    GROUP BY A.id, A.seller) [PARTITION BY A.seller ROWS 10] Q\n+  GROUP BY Q.seller;\n+\"\"\"\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.testing.benchmarks.nexmark.queries import winning_bids\n+from apache_beam.testing.benchmarks.nexmark.queries.nexmark_query_util import ResultNames\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import window\n+\n+\n+def load(events, metadata=None):\n+  # find winning bids for each closed auction\n+  return (\n+      events\n+      # find winning bids\n+      | beam.Filter(nexmark_query_util.auction_or_bid)\n+      | winning_bids.WinningBids()\n+      # (auction_bids -> (aution.seller, bid)\n+      | beam.Map(lambda auc_bid: (auc_bid.auction.seller, auc_bid.bid))\n+      # calculate and output mean as data arrives\n+      | beam.WindowInto(\n+          window.GlobalWindows(),\n+          trigger=trigger.Repeatedly(trigger.AfterCount(1)),\n+          accumulation_mode=trigger.AccumulationMode.ACCUMULATING,\n+          allowed_lateness=0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f972b520c825d95e750801d8e3985834d17eef70"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQyMzkzNQ==", "bodyText": "why do we also return whether this is the last pane in a window?", "url": "https://github.com/apache/beam/pull/12580#discussion_r474423935", "createdAt": "2020-08-21T05:56:23Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query4.py", "diffHunk": "@@ -0,0 +1,81 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 4, 'Average Price for a Category'. Select the average of the wining bid\n+prices for all closed auctions in each category. In CQL syntax::\n+\n+  SELECT Istream(AVG(Q.final))\n+  FROM Category C, (SELECT Rstream(MAX(B.price) AS final, A.category)\n+    FROM Auction A [ROWS UNBOUNDED], Bid B [ROWS UNBOUNDED]\n+    WHERE A.id=B.auction\n+      AND B.datetime < A.expires AND A.expires < CURRENT_TIME\n+    GROUP BY A.id, A.category) Q\n+  WHERE Q.category = C.id\n+  GROUP BY C.id;\n+\n+For extra spiciness our implementation differs slightly from the above:\n+\n+* We select both the average winning price and the category.\n+* We don't bother joining with a static category table, since it's\n+  contents are never used.\n+* We only consider bids which are above the auction's reserve price.\n+* We accept the highest-price, earliest valid bid as the winner.\n+* We calculate the averages oven a sliding window of size\n+  window_size_sec and period window_period_sec.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.testing.benchmarks.nexmark.queries import winning_bids\n+from apache_beam.testing.benchmarks.nexmark.queries.nexmark_query_util import ResultNames\n+from apache_beam.transforms import window\n+\n+\n+def load(events, metadata=None):\n+  # find winning bids for each closed auction\n+  all_winning_bids = (\n+      events\n+      | beam.Filter(nexmark_query_util.auction_or_bid)\n+      | winning_bids.WinningBids())\n+  return (\n+      all_winning_bids\n+      # key winning bids by auction category\n+      | beam.Map(lambda auc_bid: (auc_bid.auction.category, auc_bid.bid.price))\n+      # re-window for sliding average\n+      | beam.WindowInto(\n+          window.SlidingWindows(\n+              metadata.get('window_size_sec'),\n+              metadata.get('window_period_sec')))\n+      # average for each category\n+      | beam.CombinePerKey(beam.combiners.MeanCombineFn())\n+      # TODO(leiyiz): fanout with sliding window produces duplicated results,\n+      #   uncomment after it is fixed [BEAM-10617]\n+      # .with_hot_key_fanout(metadata.get('fanout'))\n+      # produce output\n+      | beam.ParDo(ProjectToCategoryPriceFn()))\n+\n+\n+class ProjectToCategoryPriceFn(beam.DoFn):\n+  def process(self, element, pane_info=beam.DoFn.PaneInfoParam):\n+    yield {\n+        ResultNames.CATEGORY: element[0],\n+        ResultNames.PRICE: element[1],\n+        ResultNames.IS_LAST: pane_info.is_last", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f972b520c825d95e750801d8e3985834d17eef70"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQyNTk0OA==", "bodyText": "Can it happen that the same person creates new auctions after > max_auction_waiting_time ? Will there be a new person event? If we get new auctions after the person is expired, then we'll just keep adding them to auction_state forevetr, no?", "url": "https://github.com/apache/beam/pull/12580#discussion_r474425948", "createdAt": "2020-08-21T06:03:23Z", "author": {"login": "pabloem"}, "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query3.py", "diffHunk": "@@ -0,0 +1,158 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 3, 'Local Item Suggestion'. Who is selling in OR, ID or CA in category\n+10, and for what auction ids? In CQL syntax::\n+\n+  SELECT Istream(P.name, P.city, P.state, A.id)\n+  FROM Auction A [ROWS UNBOUNDED], Person P [ROWS UNBOUNDED]\n+  WHERE A.seller = P.id\n+    AND (P.state = `OR' OR P.state = `ID' OR P.state = `CA')\n+    AND A.category = 10;\n+\n+We'll implement this query to allow 'new auction' events to come before the\n+'new person' events for the auction seller. Those auctions will be stored until\n+the matching person is seen. Then all subsequent auctions for a person will use\n+the stored person record.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import logging\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.models import nexmark_model\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.testing.benchmarks.nexmark.queries.nexmark_query_util import ResultNames\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import userstate\n+from apache_beam.transforms import window\n+from apache_beam.transforms.userstate import on_timer\n+\n+\n+def load(events, metadata=None):\n+  num_events_in_pane = 30\n+  windowed_events = (\n+      events\n+      | beam.WindowInto(\n+          window.GlobalWindows(),\n+          trigger=trigger.Repeatedly(trigger.AfterCount(num_events_in_pane)),\n+          accumulation_mode=trigger.AccumulationMode.DISCARDING))\n+  auction_by_seller_id = (\n+      windowed_events\n+      | nexmark_query_util.JustAuctions()\n+      | 'query3_filter_category' >> beam.Filter(lambda auc: auc.category == 10)\n+      | 'query3_key_by_seller' >> beam.ParDo(\n+          nexmark_query_util.AuctionBySellerFn()))\n+  person_by_id = (\n+      windowed_events\n+      | nexmark_query_util.JustPerson()\n+      | 'query3_filter_region' >>\n+      beam.Filter(lambda person: person.state in ['OR', 'ID', 'CA'])\n+      | 'query3_key_by_person_id' >> beam.ParDo(\n+          nexmark_query_util.PersonByIdFn()))\n+  return ({\n+      nexmark_query_util.AUCTION_TAG: auction_by_seller_id,\n+      nexmark_query_util.PERSON_TAG: person_by_id,\n+  }\n+          | beam.CoGroupByKey()\n+          | 'query3_join' >> beam.ParDo(\n+              JoinFn(metadata.get('max_auction_waiting_time')))\n+          | 'query3_output' >> beam.Map(\n+              lambda t: {\n+                  ResultNames.NAME: t[1].name,\n+                  ResultNames.CITY: t[1].city,\n+                  ResultNames.STATE: t[1].state,\n+                  ResultNames.AUCTION_ID: t[0].id\n+              }))\n+\n+\n+class JoinFn(beam.DoFn):\n+  \"\"\"\n+  Join auctions and person by person id and emit their product one pair at\n+  a time.\n+\n+  We know a person may submit any number of auctions. Thus new person event\n+  must have the person record stored in persistent state in order to match\n+  future auctions by that person.\n+\n+  However we know that each auction is associated with at most one person, so\n+  only need to store auction records in persistent state until we have seen the\n+  corresponding person record. And of course may have already seen that record.\n+  \"\"\"\n+\n+  AUCTIONS = 'auctions_state'\n+  PERSON = 'person_state'\n+  PERSON_EXPIRING = 'person_state_expiring'\n+\n+  auction_spec = userstate.BagStateSpec(AUCTIONS, nexmark_model.Auction.CODER)\n+  person_spec = userstate.ReadModifyWriteStateSpec(\n+      PERSON, nexmark_model.Person.CODER)\n+  person_timer_spec = userstate.TimerSpec(\n+      PERSON_EXPIRING, userstate.TimeDomain.WATERMARK)\n+\n+  def __init__(self, max_auction_wait_time):\n+    self.max_auction_wait_time = max_auction_wait_time\n+\n+  def process(\n+      self,\n+      element,\n+      auction_state=beam.DoFn.StateParam(auction_spec),\n+      person_state=beam.DoFn.StateParam(person_spec),\n+      person_timer=beam.DoFn.TimerParam(person_timer_spec)):\n+    # extract group with tags from element tuple\n+    _, group = element\n+\n+    existing_person = person_state.read()\n+    if existing_person:\n+      # the person exists in person_state for this person id\n+      for auction in group[nexmark_query_util.AUCTION_TAG]:\n+        yield auction, existing_person\n+      return\n+\n+    new_person = None\n+    for person in group[nexmark_query_util.PERSON_TAG]:\n+      if not new_person:\n+        new_person = person\n+      else:\n+        logging.error(\n+            'two new person wtih same key: %s and %s' % (person, new_person))\n+        continue\n+      # read all pending auctions for this person id, output and flush it\n+      pending_auctions = auction_state.read()\n+      if pending_auctions:\n+        for pending_auction in pending_auctions:\n+          yield pending_auction, new_person\n+        auction_state.clear()\n+      # output new auction for this person id\n+      for auction in group[nexmark_query_util.AUCTION_TAG]:\n+        yield auction, new_person\n+      # remember person for max_auction_wait_time seconds for future auctions\n+      person_state.write(new_person)\n+      person_timer.set(new_person.date_time + self.max_auction_wait_time)\n+    # we are done if we have seen a new person\n+    if new_person:\n+      return\n+\n+    # remember auction until we see person\n+    for auction in group[nexmark_query_util.AUCTION_TAG]:\n+      auction_state.add(auction)\n+\n+  @on_timer(person_timer_spec)\n+  def expiry(self, person_state=beam.DoFn.StateParam(person_spec)):\n+    person_state.clear()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f972b520c825d95e750801d8e3985834d17eef70"}, "originalPosition": 158}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "553c0780038b9007796e8598395e825deb17aeed", "author": {"user": {"login": "leiyiz", "name": "Leiyi Zhang"}}, "url": "https://github.com/apache/beam/commit/553c0780038b9007796e8598395e825deb17aeed", "committedDate": "2020-08-21T19:55:34Z", "message": "reversed the sorting to not remove from front of list"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3534, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}