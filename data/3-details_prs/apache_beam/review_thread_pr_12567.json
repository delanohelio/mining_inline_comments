{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3MjEwNzg3", "number": 12567, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNjo1MjoyOVrOEYI0Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjowNzo0OFrOEZHE0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNzQ1NzExOnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNjo1MjoyOVrOHAUCng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNjo1MjoyOVrOHAUCng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA5MDM5OA==", "bodyText": "I gave bad advice earlier, we have split out the validates runner suites to be their own jenkins job (for example https://github.com/apache/beam/blob/master/.test-infra/jenkins/job_PostCommit_Java_ValidatesRunner_Twister2.groovy).", "url": "https://github.com/apache/beam/pull/12567#discussion_r470090398", "createdAt": "2020-08-13T16:52:29Z", "author": {"login": "lukecwik"}, "path": "build.gradle", "diffHunk": "@@ -155,6 +155,7 @@ task javaPreCommit() {\n   dependsOn \":sdks:java:extensions:sql:jdbc:preCommit\"\n   dependsOn \":sdks:java:javadoc:allJavadoc\"\n   dependsOn \":runners:direct-java:needsRunnerTests\"\n+  dependsOn \":runners:jet:validatesRunner\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55af2d42fbbfc486f25adac8023cddecfcf81d54"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNzQ4OTAzOnYy", "diffSide": "RIGHT", "path": "runners/jet/src/main/java/org/apache/beam/runners/jet/processors/StatefulParDoP.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNzowMTowN1rOHAUXFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxMTowNzowN1rOHBkUPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA5NTYzOQ==", "bodyText": "We should be dropping processing based timers if the watermark advances to infinity and not be executing them.\nWe can keep the existing behavior that we had but in a follow-up PR it would make sense to fix this logic.", "url": "https://github.com/apache/beam/pull/12567#discussion_r470095639", "createdAt": "2020-08-13T17:01:07Z", "author": {"login": "lukecwik"}, "path": "runners/jet/src/main/java/org/apache/beam/runners/jet/processors/StatefulParDoP.java", "diffHunk": "@@ -276,36 +262,94 @@ Processor getEx(\n           inputValueCoder,\n           outputValueCoders,\n           ordinalToSideInput,\n+          sideInputMapping,\n           ownerId,\n           stepId);\n     }\n   }\n \n-  private static class KeyedStepContext implements StepContext {\n+  private class KeyedStepContext implements StepContext {\n \n-    private final Map<Object, InMemoryStateInternals> stateInternalsOfKeys;\n-    private final InMemoryTimerInternals timerInternals;\n+    private final Object nullKey = new Object();\n \n-    private InMemoryStateInternals currentStateInternals;\n+    private final ConcurrentHashMap<Object, InMemoryStateInternals> keyedStateInternals;\n+    private final ConcurrentHashMap<Object, InMemoryTimerInternals> keyedTimerInternals;\n \n-    KeyedStepContext(InMemoryTimerInternals timerInternals) {\n-      this.stateInternalsOfKeys = new HashMap<>();\n-      this.timerInternals = timerInternals;\n+    @SuppressWarnings(\"ThreadLocalUsage\")\n+    private final ThreadLocal<Object> currentKey = new ThreadLocal<>();\n+\n+    KeyedStepContext() {\n+      this.keyedStateInternals = new ConcurrentHashMap<>();\n+      this.keyedTimerInternals = new ConcurrentHashMap<>();\n     }\n \n     void setKey(Object key) {\n-      currentStateInternals =\n-          stateInternalsOfKeys.computeIfAbsent(key, InMemoryStateInternals::forKey);\n+      Object normalizedKey = key == null ? nullKey : key;\n+      currentKey.set(normalizedKey);\n+      keyedStateInternals.computeIfAbsent(normalizedKey, InMemoryStateInternals::forKey);\n+      keyedTimerInternals.computeIfAbsent(normalizedKey, k -> new InMemoryTimerInternals());\n+    }\n+\n+    void clearKey() {\n+      currentKey.remove();\n     }\n \n     @Override\n     public StateInternals stateInternals() {\n-      return currentStateInternals;\n+      Object key = currentKey.get();\n+      if (key == null) {\n+        throw new IllegalStateException(\"Active key should be set\");\n+      }\n+      return keyedStateInternals.get(key);\n     }\n \n     @Override\n     public TimerInternals timerInternals() {\n-      return timerInternals;\n+      Object key = currentKey.get();\n+      if (key == null) {\n+        throw new IllegalStateException(\"Active key should be set\");\n+      }\n+      return keyedTimerInternals.get(key);\n+    }\n+\n+    public void advanceProcessingTimes() {\n+      Instant now = Instant.now();\n+      keyedTimerInternals\n+          .values()\n+          .forEach(\n+              timerInternals -> {\n+                try {\n+                  timerInternals.advanceProcessingTime(now);\n+                  timerInternals.advanceSynchronizedProcessingTime(now);\n+                } catch (Exception e) {\n+                  throw new RuntimeException(\"Failed advancing time!\");\n+                }\n+              });\n+    }\n+\n+    public void flushTimers(long watermark) {\n+      Instant watermarkInstant = new Instant(watermark);\n+      keyedTimerInternals\n+          .entrySet()\n+          .forEach(\n+              (entry) -> {\n+                InMemoryTimerInternals timerInternals = entry.getValue();\n+                if (timerInternals.currentInputWatermarkTime().isBefore(watermark)) {\n+                  try {\n+                    timerInternals.advanceInputWatermark(watermarkInstant);\n+                    if (watermarkInstant.equals(BoundedWindow.TIMESTAMP_MAX_VALUE)) {\n+                      timerInternals.advanceProcessingTime(watermarkInstant);\n+                      timerInternals.advanceSynchronizedProcessingTime(watermarkInstant);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55af2d42fbbfc486f25adac8023cddecfcf81d54"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwNTYzMA==", "bodyText": "ok", "url": "https://github.com/apache/beam/pull/12567#discussion_r471405630", "createdAt": "2020-08-17T11:07:07Z", "author": {"login": "jbartok"}, "path": "runners/jet/src/main/java/org/apache/beam/runners/jet/processors/StatefulParDoP.java", "diffHunk": "@@ -276,36 +262,94 @@ Processor getEx(\n           inputValueCoder,\n           outputValueCoders,\n           ordinalToSideInput,\n+          sideInputMapping,\n           ownerId,\n           stepId);\n     }\n   }\n \n-  private static class KeyedStepContext implements StepContext {\n+  private class KeyedStepContext implements StepContext {\n \n-    private final Map<Object, InMemoryStateInternals> stateInternalsOfKeys;\n-    private final InMemoryTimerInternals timerInternals;\n+    private final Object nullKey = new Object();\n \n-    private InMemoryStateInternals currentStateInternals;\n+    private final ConcurrentHashMap<Object, InMemoryStateInternals> keyedStateInternals;\n+    private final ConcurrentHashMap<Object, InMemoryTimerInternals> keyedTimerInternals;\n \n-    KeyedStepContext(InMemoryTimerInternals timerInternals) {\n-      this.stateInternalsOfKeys = new HashMap<>();\n-      this.timerInternals = timerInternals;\n+    @SuppressWarnings(\"ThreadLocalUsage\")\n+    private final ThreadLocal<Object> currentKey = new ThreadLocal<>();\n+\n+    KeyedStepContext() {\n+      this.keyedStateInternals = new ConcurrentHashMap<>();\n+      this.keyedTimerInternals = new ConcurrentHashMap<>();\n     }\n \n     void setKey(Object key) {\n-      currentStateInternals =\n-          stateInternalsOfKeys.computeIfAbsent(key, InMemoryStateInternals::forKey);\n+      Object normalizedKey = key == null ? nullKey : key;\n+      currentKey.set(normalizedKey);\n+      keyedStateInternals.computeIfAbsent(normalizedKey, InMemoryStateInternals::forKey);\n+      keyedTimerInternals.computeIfAbsent(normalizedKey, k -> new InMemoryTimerInternals());\n+    }\n+\n+    void clearKey() {\n+      currentKey.remove();\n     }\n \n     @Override\n     public StateInternals stateInternals() {\n-      return currentStateInternals;\n+      Object key = currentKey.get();\n+      if (key == null) {\n+        throw new IllegalStateException(\"Active key should be set\");\n+      }\n+      return keyedStateInternals.get(key);\n     }\n \n     @Override\n     public TimerInternals timerInternals() {\n-      return timerInternals;\n+      Object key = currentKey.get();\n+      if (key == null) {\n+        throw new IllegalStateException(\"Active key should be set\");\n+      }\n+      return keyedTimerInternals.get(key);\n+    }\n+\n+    public void advanceProcessingTimes() {\n+      Instant now = Instant.now();\n+      keyedTimerInternals\n+          .values()\n+          .forEach(\n+              timerInternals -> {\n+                try {\n+                  timerInternals.advanceProcessingTime(now);\n+                  timerInternals.advanceSynchronizedProcessingTime(now);\n+                } catch (Exception e) {\n+                  throw new RuntimeException(\"Failed advancing time!\");\n+                }\n+              });\n+    }\n+\n+    public void flushTimers(long watermark) {\n+      Instant watermarkInstant = new Instant(watermark);\n+      keyedTimerInternals\n+          .entrySet()\n+          .forEach(\n+              (entry) -> {\n+                InMemoryTimerInternals timerInternals = entry.getValue();\n+                if (timerInternals.currentInputWatermarkTime().isBefore(watermark)) {\n+                  try {\n+                    timerInternals.advanceInputWatermark(watermarkInstant);\n+                    if (watermarkInstant.equals(BoundedWindow.TIMESTAMP_MAX_VALUE)) {\n+                      timerInternals.advanceProcessingTime(watermarkInstant);\n+                      timerInternals.advanceSynchronizedProcessingTime(watermarkInstant);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA5NTYzOQ=="}, "originalCommit": {"oid": "55af2d42fbbfc486f25adac8023cddecfcf81d54"}, "originalPosition": 255}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NzY1Nzc4OnYy", "diffSide": "RIGHT", "path": "runners/jet/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjowNzo0OFrOHBvOag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjowNzo0OFrOHBvOag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU4NDM2Mg==", "bodyText": "Lets exclude test categories when possible based upon missing features within the runner. This will allow additional tests to be added without needing the exclusion lists of each runner to be updated.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    excludeCategories 'org.apache.beam.sdk.testing.UsesBundleFinalizer'\n          \n          \n            \n                }\n          \n          \n            \n                filter {\n          \n          \n            \n                    //Jet Runner doesn't current support @RequiresTimeSortedInput annotation.\n          \n          \n            \n                    excludeTestsMatching 'org.apache.beam.sdk.transforms.ParDoTest$StateTests.*TimeSortedInput*'\n          \n          \n            \n            \n          \n          \n            \n                    //Event type not supported in TestStream: class org.apache.beam.sdk.testing.AutoValue_TestStream_ProcessingTimeEvent\n          \n          \n            \n                    excludeTestsMatching 'org.apache.beam.sdk.transforms.ParDoTest$TimerTests.testOutputTimestampWithProcessingTime'\n          \n          \n            \n                    excludeTestsMatching 'org.apache.beam.sdk.transforms.ParDoTest$TimerTests.testProcessingTimeTimerCanBeReset'\n          \n          \n            \n            \n          \n          \n            \n                    //unbounded streams created from bounded sources not supported by Jet Runner\n          \n          \n            \n                    excludeTestsMatching 'org.apache.beam.sdk.transforms.ParDoTest$TimerTests.testTwoTimersSettingEachOtherWithCreateAsInputUnbounded'\n          \n          \n            \n            \n          \n          \n            \n                    //timer output timestamps not supported by Jet Runner\n          \n          \n            \n                    excludeTestsMatching 'org.apache.beam.sdk.transforms.ParDoTest$TimerTests.testOutputTimestamp'\n          \n          \n            \n            \n          \n          \n            \n                    excludeTestsMatching 'org.apache.beam.sdk.testing.PAssertTest.testAssertionSiteIsCaptured*'\n          \n          \n            \n                    excludeCategories 'org.apache.beam.sdk.testing.UsesBundleFinalizer'\n          \n          \n            \n                    \n          \n          \n            \n                    //Jet Runner doesn't current support @RequiresTimeSortedInput annotation.\n          \n          \n            \n                    excludeCategories 'org.apache.beam.sdk.testing.UsesRequiresTimeSortedInput'\n          \n          \n            \n            \n          \n          \n            \n                    //Event type not supported in TestStream: class org.apache.beam.sdk.testing.AutoValue_TestStream_ProcessingTimeEvent\n          \n          \n            \n                    excludeCategories 'org.apache.beam.sdk.testing.UsesTestStreamWithProcessingTime'\n          \n          \n            \n                }\n          \n          \n            \n                filter {\n          \n          \n            \n                    // unbounded streams created from bounded sources not supported by Jet Runner\n          \n          \n            \n                    excludeTestsMatching 'org.apache.beam.sdk.transforms.ParDoTest$TimerTests.testTwoTimersSettingEachOtherWithCreateAsInputUnbounded'\n          \n          \n            \n            \n          \n          \n            \n                    // timer output timestamps not supported by Jet Runner\n          \n          \n            \n                    excludeTestsMatching 'org.apache.beam.sdk.transforms.ParDoTest$TimerTests.testOutputTimestamp'\n          \n          \n            \n            \n          \n          \n            \n                    excludeTestsMatching 'org.apache.beam.sdk.testing.PAssertTest.testAssertionSiteIsCaptured*'", "url": "https://github.com/apache/beam/pull/12567#discussion_r471584362", "createdAt": "2020-08-17T16:07:48Z", "author": {"login": "lukecwik"}, "path": "runners/jet/build.gradle", "diffHunk": "@@ -78,6 +78,22 @@ task validatesRunnerBatch(type: Test) {\n         exclude '**/SplittableDoFnTest.class' //Splittable DoFn functionality not yet in the runner\n         excludeCategories 'org.apache.beam.sdk.testing.UsesBundleFinalizer'\n     }\n+    filter {\n+        //Jet Runner doesn't current support @RequiresTimeSortedInput annotation.\n+        excludeTestsMatching 'org.apache.beam.sdk.transforms.ParDoTest$StateTests.*TimeSortedInput*'\n+\n+        //Event type not supported in TestStream: class org.apache.beam.sdk.testing.AutoValue_TestStream_ProcessingTimeEvent\n+        excludeTestsMatching 'org.apache.beam.sdk.transforms.ParDoTest$TimerTests.testOutputTimestampWithProcessingTime'\n+        excludeTestsMatching 'org.apache.beam.sdk.transforms.ParDoTest$TimerTests.testProcessingTimeTimerCanBeReset'\n+\n+        //unbounded streams created from bounded sources not supported by Jet Runner\n+        excludeTestsMatching 'org.apache.beam.sdk.transforms.ParDoTest$TimerTests.testTwoTimersSettingEachOtherWithCreateAsInputUnbounded'\n+\n+        //timer output timestamps not supported by Jet Runner\n+        excludeTestsMatching 'org.apache.beam.sdk.transforms.ParDoTest$TimerTests.testOutputTimestamp'\n+\n+        excludeTestsMatching 'org.apache.beam.sdk.testing.PAssertTest.testAssertionSiteIsCaptured*'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a606d54a14be3df23dc613498e17c24fa5d0d672"}, "originalPosition": 18}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 681, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}