{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwNTg3NzYx", "number": 11339, "reviewThreads": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxODoxOTowMFrODwHDdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDozNTowMlrOD8OjpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzczODEzOnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxODoxOTowMFrOGC7VKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNTo0MzoxNVrOGF_8-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyMjQxMQ==", "bodyText": "@lastomato @yeweidaniel @ygupta89 @pabloem\nPlease review the logic here and LMK if you feel this is spamming the import API.\nAs written this will create a separate new line delimited JSON file per bundle (group of elements in a PCollection of arbitrary size decided by runner) and import it w/ a separate call to import API.\nThis was the \"easiest\" way to implement but may not be the most appropriate usage of the import API.\nPTAL and LMK if you'd like this to refactored into something that:\n\nasserts bounded PCollection\nwaits til all temp files are written\nblocks on import by polling the operation til complete.\n\nIt's not immediately obvious to me how to achieve 1 & 2 in the beam framework but I can do some research.", "url": "https://github.com/apache/beam/pull/11339#discussion_r405722411", "createdAt": "2020-04-08T18:19:00Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,662 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.FhirIO.Import.ContentStructure;\n+import org.apache.beam.sdk.io.gcp.healthcare.FhirIO.Write.Result;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.util.Sleeper;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link HttpBody}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()} to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError} containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection} contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link HttpBody} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, ContentStructure)} This will return a\n+ *     {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedInsertsWithErr()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link HttpBody} that failed to be ingested and the\n+ *     exception.\n+ */\n+public class FhirIO {\n+\n+  @Experimental\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    public Read() {\n+      LOG.warn(\"FhirIO.Read is experimental and has not been tested.\");\n+    }\n+\n+    public static class Result implements POutput, PInput {\n+      private PCollection<HttpBody> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      PCollectionTuple pct;\n+\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT).setCoder(new HttpBodyCoder());\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+      }\n+\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      public PCollection<HttpBody> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<HttpBody> OUT = new TupleTag<HttpBody>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FhirIO.Read.FetchHttpBody());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link HttpBody} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError} of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchHttpBody extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchHttpBody() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FhirIO.Read.FetchHttpBody.HttpBodyGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class HttpBodyGetFn extends DoFn<String, HttpBody> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class);\n+        private final Counter successfulHttpBodyGets =\n+            Metrics.counter(\n+                FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        HttpBodyGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private HttpBody fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException, InterruptedException {\n+          long startTime = System.currentTimeMillis();\n+          Sleeper sleeper = Sleeper.DEFAULT;\n+\n+          com.google.api.services.healthcare.v1beta1.model.HttpBody resource =\n+              client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulHttpBodyGets.inc();\n+          return resource;\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<HttpBody>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<HttpBody>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<HttpBody>>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<HttpBody>> failedInsertsWithErr;\n+\n+      /** Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<HttpBody>> failedInserts) {\n+        return new Result(pipeline, failedInserts);\n+      }\n+\n+      public PCollection<HealthcareIOError<HttpBody>> getFailedInsertsWithErr() {\n+        return this.failedInsertsWithErr;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        failedInsertsWithErr.setCoder(new HealthcareIOErrorCoder<HttpBody>(new HttpBodyCoder()));\n+        return ImmutableMap.of(Write.FAILED_BODY, failedInsertsWithErr);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline, PCollection<HealthcareIOError<HttpBody>> failedInsertsWithErr) {\n+        this.pipeline = pipeline;\n+        this.failedInsertsWithErr = failedInsertsWithErr;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    abstract Optional<ContentStructure> getContentStructure();\n+\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      abstract Builder setContentStructure(ContentStructure contentStructure);\n+\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<HttpBody> input) {\n+      PCollection<HealthcareIOError<HttpBody>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.warn(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          failedBundles =\n+              input\n+                  .apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure))\n+                  .setCoder(new HealthcareIOErrorCoder<>(new HttpBodyCoder()));\n+          // fall through\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input.apply(\n+                  \"Execute FHIR Bundles\",\n+                  ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file.\n+   */\n+  public static class Import\n+      extends PTransform<PCollection<HttpBody>, PCollection<HealthcareIOError<HttpBody>>> {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    public PCollection<HealthcareIOError<HttpBody>> expand(PCollection<HttpBody> input) {\n+      return input.apply(\n+          ParDo.of(new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)));\n+    }\n+\n+    public enum ContentStructure {\n+      /** If the content structure is not specified, the default value BUNDLE will be used. */\n+      CONTENT_STRUCTURE_UNSPECIFIED,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a bundle, which contains one or more resources. Set the bundle type to history to import\n+       * resource versions.\n+       */\n+      BUNDLE,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a single resource.\n+       */\n+      RESOURCE,\n+      /** The entire file is one JSON bundle. The JSON can span multiple lines. */\n+      BUNDLE_PRETTY,\n+      /** The entire file is one JSON resource. The JSON can span multiple lines. */\n+      RESOURCE_PRETTY\n+    }\n+\n+    static class ImportFn extends DoFn<HttpBody, HealthcareIOError<HttpBody>> {\n+      private final String fhirStore;\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private final ContentStructure contentStructure;\n+      private ObjectMapper mapper;\n+      private ResourceId resourceId;\n+      private ResourceId deadLetterResourceId;\n+      private WritableByteChannel ndJsonChannel;\n+\n+      private transient HealthcareApiClient client;\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void initClient() throws IOException {\n+        this.client = new HttpHealthcareApiClient();\n+      }\n+\n+      @StartBundle\n+      public void initBatch() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e7589e019b32335295f782dc4b13968c465470f"}, "originalPosition": 542}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc2MTE3MQ==", "bodyText": "I am a little worried about the fact that the bundle size is unknown. In extreme (though unlikely) cases, we could be making one import API call per resource.", "url": "https://github.com/apache/beam/pull/11339#discussion_r405761171", "createdAt": "2020-04-08T19:27:09Z", "author": {"login": "lastomato"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,662 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.FhirIO.Import.ContentStructure;\n+import org.apache.beam.sdk.io.gcp.healthcare.FhirIO.Write.Result;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.util.Sleeper;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link HttpBody}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()} to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError} containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection} contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link HttpBody} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, ContentStructure)} This will return a\n+ *     {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedInsertsWithErr()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link HttpBody} that failed to be ingested and the\n+ *     exception.\n+ */\n+public class FhirIO {\n+\n+  @Experimental\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    public Read() {\n+      LOG.warn(\"FhirIO.Read is experimental and has not been tested.\");\n+    }\n+\n+    public static class Result implements POutput, PInput {\n+      private PCollection<HttpBody> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      PCollectionTuple pct;\n+\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT).setCoder(new HttpBodyCoder());\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+      }\n+\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      public PCollection<HttpBody> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<HttpBody> OUT = new TupleTag<HttpBody>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FhirIO.Read.FetchHttpBody());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link HttpBody} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError} of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchHttpBody extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchHttpBody() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FhirIO.Read.FetchHttpBody.HttpBodyGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class HttpBodyGetFn extends DoFn<String, HttpBody> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class);\n+        private final Counter successfulHttpBodyGets =\n+            Metrics.counter(\n+                FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        HttpBodyGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private HttpBody fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException, InterruptedException {\n+          long startTime = System.currentTimeMillis();\n+          Sleeper sleeper = Sleeper.DEFAULT;\n+\n+          com.google.api.services.healthcare.v1beta1.model.HttpBody resource =\n+              client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulHttpBodyGets.inc();\n+          return resource;\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<HttpBody>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<HttpBody>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<HttpBody>>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<HttpBody>> failedInsertsWithErr;\n+\n+      /** Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<HttpBody>> failedInserts) {\n+        return new Result(pipeline, failedInserts);\n+      }\n+\n+      public PCollection<HealthcareIOError<HttpBody>> getFailedInsertsWithErr() {\n+        return this.failedInsertsWithErr;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        failedInsertsWithErr.setCoder(new HealthcareIOErrorCoder<HttpBody>(new HttpBodyCoder()));\n+        return ImmutableMap.of(Write.FAILED_BODY, failedInsertsWithErr);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline, PCollection<HealthcareIOError<HttpBody>> failedInsertsWithErr) {\n+        this.pipeline = pipeline;\n+        this.failedInsertsWithErr = failedInsertsWithErr;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    abstract Optional<ContentStructure> getContentStructure();\n+\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      abstract Builder setContentStructure(ContentStructure contentStructure);\n+\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<HttpBody> input) {\n+      PCollection<HealthcareIOError<HttpBody>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.warn(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          failedBundles =\n+              input\n+                  .apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure))\n+                  .setCoder(new HealthcareIOErrorCoder<>(new HttpBodyCoder()));\n+          // fall through\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input.apply(\n+                  \"Execute FHIR Bundles\",\n+                  ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file.\n+   */\n+  public static class Import\n+      extends PTransform<PCollection<HttpBody>, PCollection<HealthcareIOError<HttpBody>>> {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    public PCollection<HealthcareIOError<HttpBody>> expand(PCollection<HttpBody> input) {\n+      return input.apply(\n+          ParDo.of(new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)));\n+    }\n+\n+    public enum ContentStructure {\n+      /** If the content structure is not specified, the default value BUNDLE will be used. */\n+      CONTENT_STRUCTURE_UNSPECIFIED,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a bundle, which contains one or more resources. Set the bundle type to history to import\n+       * resource versions.\n+       */\n+      BUNDLE,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a single resource.\n+       */\n+      RESOURCE,\n+      /** The entire file is one JSON bundle. The JSON can span multiple lines. */\n+      BUNDLE_PRETTY,\n+      /** The entire file is one JSON resource. The JSON can span multiple lines. */\n+      RESOURCE_PRETTY\n+    }\n+\n+    static class ImportFn extends DoFn<HttpBody, HealthcareIOError<HttpBody>> {\n+      private final String fhirStore;\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private final ContentStructure contentStructure;\n+      private ObjectMapper mapper;\n+      private ResourceId resourceId;\n+      private ResourceId deadLetterResourceId;\n+      private WritableByteChannel ndJsonChannel;\n+\n+      private transient HealthcareApiClient client;\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void initClient() throws IOException {\n+        this.client = new HttpHealthcareApiClient();\n+      }\n+\n+      @StartBundle\n+      public void initBatch() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyMjQxMQ=="}, "originalCommit": {"oid": "7e7589e019b32335295f782dc4b13968c465470f"}, "originalPosition": 542}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgyNDQ3Mw==", "bodyText": "Research:\n\nBased on this SO post\nWe might be able to GroupByKey single dummy key to encourage runner to do less bundle splitting, though I'm not sure that will really do the trick.\nFrom Beam docs:\n\n\nSpecifically, it makes it impossible to batch any operations, such as writing elements to a sink or checkpointing progress during processing.\nThe division of the collection into bundles is arbitrary and selected by the runner. This allows the runner to choose an appropriate middle-ground between persisting results after every element, and having to retry everything if there is a failure. For example, a streaming runner may prefer to process and commit small bundles, and a batch runner may prefer to process larger bundles.\n(source)\n\nIt seems to me that our predominant use case for Import is a batch pipeline and this sentence implies that bundles are larger in batch (not sure if we can find internal details on Dataflow Runner).\n\nBigQueryIO has a batch loads pattern which seems similar to what we are aiming to achieve here. This seems quite complex and I'm wondering if there are simpler approaches elsewhere in the beam code base.\n\nDo we have any guidance on how many parallel import operations would be acceptable? Perhaps we can run some benchmarks with 500, 1000, 10000 resources with this approach / adding group by single key and see if it's acceptable.", "url": "https://github.com/apache/beam/pull/11339#discussion_r405824473", "createdAt": "2020-04-08T21:25:29Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,662 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.FhirIO.Import.ContentStructure;\n+import org.apache.beam.sdk.io.gcp.healthcare.FhirIO.Write.Result;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.util.Sleeper;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link HttpBody}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()} to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError} containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection} contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link HttpBody} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, ContentStructure)} This will return a\n+ *     {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedInsertsWithErr()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link HttpBody} that failed to be ingested and the\n+ *     exception.\n+ */\n+public class FhirIO {\n+\n+  @Experimental\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    public Read() {\n+      LOG.warn(\"FhirIO.Read is experimental and has not been tested.\");\n+    }\n+\n+    public static class Result implements POutput, PInput {\n+      private PCollection<HttpBody> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      PCollectionTuple pct;\n+\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT).setCoder(new HttpBodyCoder());\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+      }\n+\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      public PCollection<HttpBody> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<HttpBody> OUT = new TupleTag<HttpBody>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FhirIO.Read.FetchHttpBody());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link HttpBody} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError} of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchHttpBody extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchHttpBody() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FhirIO.Read.FetchHttpBody.HttpBodyGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class HttpBodyGetFn extends DoFn<String, HttpBody> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class);\n+        private final Counter successfulHttpBodyGets =\n+            Metrics.counter(\n+                FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        HttpBodyGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private HttpBody fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException, InterruptedException {\n+          long startTime = System.currentTimeMillis();\n+          Sleeper sleeper = Sleeper.DEFAULT;\n+\n+          com.google.api.services.healthcare.v1beta1.model.HttpBody resource =\n+              client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulHttpBodyGets.inc();\n+          return resource;\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<HttpBody>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<HttpBody>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<HttpBody>>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<HttpBody>> failedInsertsWithErr;\n+\n+      /** Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<HttpBody>> failedInserts) {\n+        return new Result(pipeline, failedInserts);\n+      }\n+\n+      public PCollection<HealthcareIOError<HttpBody>> getFailedInsertsWithErr() {\n+        return this.failedInsertsWithErr;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        failedInsertsWithErr.setCoder(new HealthcareIOErrorCoder<HttpBody>(new HttpBodyCoder()));\n+        return ImmutableMap.of(Write.FAILED_BODY, failedInsertsWithErr);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline, PCollection<HealthcareIOError<HttpBody>> failedInsertsWithErr) {\n+        this.pipeline = pipeline;\n+        this.failedInsertsWithErr = failedInsertsWithErr;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    abstract Optional<ContentStructure> getContentStructure();\n+\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      abstract Builder setContentStructure(ContentStructure contentStructure);\n+\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<HttpBody> input) {\n+      PCollection<HealthcareIOError<HttpBody>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.warn(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          failedBundles =\n+              input\n+                  .apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure))\n+                  .setCoder(new HealthcareIOErrorCoder<>(new HttpBodyCoder()));\n+          // fall through\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input.apply(\n+                  \"Execute FHIR Bundles\",\n+                  ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file.\n+   */\n+  public static class Import\n+      extends PTransform<PCollection<HttpBody>, PCollection<HealthcareIOError<HttpBody>>> {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    public PCollection<HealthcareIOError<HttpBody>> expand(PCollection<HttpBody> input) {\n+      return input.apply(\n+          ParDo.of(new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)));\n+    }\n+\n+    public enum ContentStructure {\n+      /** If the content structure is not specified, the default value BUNDLE will be used. */\n+      CONTENT_STRUCTURE_UNSPECIFIED,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a bundle, which contains one or more resources. Set the bundle type to history to import\n+       * resource versions.\n+       */\n+      BUNDLE,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a single resource.\n+       */\n+      RESOURCE,\n+      /** The entire file is one JSON bundle. The JSON can span multiple lines. */\n+      BUNDLE_PRETTY,\n+      /** The entire file is one JSON resource. The JSON can span multiple lines. */\n+      RESOURCE_PRETTY\n+    }\n+\n+    static class ImportFn extends DoFn<HttpBody, HealthcareIOError<HttpBody>> {\n+      private final String fhirStore;\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private final ContentStructure contentStructure;\n+      private ObjectMapper mapper;\n+      private ResourceId resourceId;\n+      private ResourceId deadLetterResourceId;\n+      private WritableByteChannel ndJsonChannel;\n+\n+      private transient HealthcareApiClient client;\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void initClient() throws IOException {\n+        this.client = new HttpHealthcareApiClient();\n+      }\n+\n+      @StartBundle\n+      public void initBatch() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyMjQxMQ=="}, "originalCommit": {"oid": "7e7589e019b32335295f782dc4b13968c465470f"}, "originalPosition": 542}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0Mzg2Ng==", "bodyText": "@pabloem is there a good way to signal to the runner to prefer large bundles for this DoFn? Are there any other common patterns for batching files for bulk import operations that are less complicated than the BQ File Loads (which seem to have a lot of complexity to handle dynamic destinations)?", "url": "https://github.com/apache/beam/pull/11339#discussion_r408943866", "createdAt": "2020-04-15T15:43:15Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,662 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.FhirIO.Import.ContentStructure;\n+import org.apache.beam.sdk.io.gcp.healthcare.FhirIO.Write.Result;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.util.Sleeper;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link HttpBody}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()} to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError} containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection} contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link HttpBody} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, ContentStructure)} This will return a\n+ *     {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedInsertsWithErr()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link HttpBody} that failed to be ingested and the\n+ *     exception.\n+ */\n+public class FhirIO {\n+\n+  @Experimental\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    public Read() {\n+      LOG.warn(\"FhirIO.Read is experimental and has not been tested.\");\n+    }\n+\n+    public static class Result implements POutput, PInput {\n+      private PCollection<HttpBody> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      PCollectionTuple pct;\n+\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT).setCoder(new HttpBodyCoder());\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+      }\n+\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      public PCollection<HttpBody> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<HttpBody> OUT = new TupleTag<HttpBody>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FhirIO.Read.FetchHttpBody());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link HttpBody} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError} of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchHttpBody extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchHttpBody() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FhirIO.Read.FetchHttpBody.HttpBodyGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class HttpBodyGetFn extends DoFn<String, HttpBody> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class);\n+        private final Counter successfulHttpBodyGets =\n+            Metrics.counter(\n+                FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        HttpBodyGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private HttpBody fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException, InterruptedException {\n+          long startTime = System.currentTimeMillis();\n+          Sleeper sleeper = Sleeper.DEFAULT;\n+\n+          com.google.api.services.healthcare.v1beta1.model.HttpBody resource =\n+              client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulHttpBodyGets.inc();\n+          return resource;\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<HttpBody>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<HttpBody>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<HttpBody>>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<HttpBody>> failedInsertsWithErr;\n+\n+      /** Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<HttpBody>> failedInserts) {\n+        return new Result(pipeline, failedInserts);\n+      }\n+\n+      public PCollection<HealthcareIOError<HttpBody>> getFailedInsertsWithErr() {\n+        return this.failedInsertsWithErr;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        failedInsertsWithErr.setCoder(new HealthcareIOErrorCoder<HttpBody>(new HttpBodyCoder()));\n+        return ImmutableMap.of(Write.FAILED_BODY, failedInsertsWithErr);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline, PCollection<HealthcareIOError<HttpBody>> failedInsertsWithErr) {\n+        this.pipeline = pipeline;\n+        this.failedInsertsWithErr = failedInsertsWithErr;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    abstract Optional<ContentStructure> getContentStructure();\n+\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      abstract Builder setContentStructure(ContentStructure contentStructure);\n+\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<HttpBody> input) {\n+      PCollection<HealthcareIOError<HttpBody>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.warn(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          failedBundles =\n+              input\n+                  .apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure))\n+                  .setCoder(new HealthcareIOErrorCoder<>(new HttpBodyCoder()));\n+          // fall through\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input.apply(\n+                  \"Execute FHIR Bundles\",\n+                  ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file.\n+   */\n+  public static class Import\n+      extends PTransform<PCollection<HttpBody>, PCollection<HealthcareIOError<HttpBody>>> {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    public PCollection<HealthcareIOError<HttpBody>> expand(PCollection<HttpBody> input) {\n+      return input.apply(\n+          ParDo.of(new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)));\n+    }\n+\n+    public enum ContentStructure {\n+      /** If the content structure is not specified, the default value BUNDLE will be used. */\n+      CONTENT_STRUCTURE_UNSPECIFIED,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a bundle, which contains one or more resources. Set the bundle type to history to import\n+       * resource versions.\n+       */\n+      BUNDLE,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a single resource.\n+       */\n+      RESOURCE,\n+      /** The entire file is one JSON bundle. The JSON can span multiple lines. */\n+      BUNDLE_PRETTY,\n+      /** The entire file is one JSON resource. The JSON can span multiple lines. */\n+      RESOURCE_PRETTY\n+    }\n+\n+    static class ImportFn extends DoFn<HttpBody, HealthcareIOError<HttpBody>> {\n+      private final String fhirStore;\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private final ContentStructure contentStructure;\n+      private ObjectMapper mapper;\n+      private ResourceId resourceId;\n+      private ResourceId deadLetterResourceId;\n+      private WritableByteChannel ndJsonChannel;\n+\n+      private transient HealthcareApiClient client;\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void initClient() throws IOException {\n+        this.client = new HttpHealthcareApiClient();\n+      }\n+\n+      @StartBundle\n+      public void initBatch() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyMjQxMQ=="}, "originalCommit": {"oid": "7e7589e019b32335295f782dc4b13968c465470f"}, "originalPosition": 542}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzc1Mzc2OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HttpHealthcareApiClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxODoyMzozM1rOGC7fZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxOToyOToyNlrOGC9xWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyNTAzMQ==", "bodyText": "@lastomato @yeweidaniel @ygupta89\nThis is super awkward but the executeBundle method of client lib seems broken always giving errors about unparsable resource based on my testing (CDAP plugins also written similar to this).\nAny ETA on fix for that?\nDoes this workaround seem acceptable til then?", "url": "https://github.com/apache/beam/pull/11339#discussion_r405725031", "createdAt": "2020-04-08T18:23:33Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HttpHealthcareApiClient.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.google.api.client.http.HttpHeaders;\n+import com.google.api.client.http.HttpRequest;\n+import com.google.api.client.http.HttpRequestInitializer;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.gson.GsonFactory;\n+import com.google.api.services.healthcare.v1beta1.CloudHealthcare;\n+import com.google.api.services.healthcare.v1beta1.CloudHealthcare.Projects.Locations.Datasets.Hl7V2Stores.Messages;\n+import com.google.api.services.healthcare.v1beta1.CloudHealthcareScopes;\n+import com.google.api.services.healthcare.v1beta1.model.CreateMessageRequest;\n+import com.google.api.services.healthcare.v1beta1.model.Empty;\n+import com.google.api.services.healthcare.v1beta1.model.FhirStore;\n+import com.google.api.services.healthcare.v1beta1.model.GoogleCloudHealthcareV1beta1FhirRestGcsSource;\n+import com.google.api.services.healthcare.v1beta1.model.Hl7V2Store;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.ImportResourcesRequest;\n+import com.google.api.services.healthcare.v1beta1.model.IngestMessageRequest;\n+import com.google.api.services.healthcare.v1beta1.model.IngestMessageResponse;\n+import com.google.api.services.healthcare.v1beta1.model.ListMessagesResponse;\n+import com.google.api.services.healthcare.v1beta1.model.Message;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.api.services.healthcare.v1beta1.model.SearchResourcesRequest;\n+import com.google.api.services.storage.StorageScopes;\n+import com.google.auth.oauth2.GoogleCredentials;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Spliterator;\n+import java.util.Spliterators;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.extensions.gcp.util.RetryHttpRequestInitializer;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Strings;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.client.methods.RequestBuilder;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A client that talks to the Cloud Healthcare API through HTTP requests. This client is created\n+ * mainly to encapsulate the unserializable dependencies, since most generated classes are not\n+ * serializable in the HTTP client.\n+ */\n+public class HttpHealthcareApiClient implements HealthcareApiClient, Serializable {\n+  private static final String FHIRSTORE_HEADER_CONTENT_TYPE = \"application/fhir+json\";\n+  private static final String FHIRSTORE_HEADER_ACCEPT = \"application/fhir+json; charset=utf-8\";\n+  private static final String FHIRSTORE_HEADER_ACCEPT_CHARSET = \"utf-8\";\n+  private static final Logger LOG = LoggerFactory.getLogger(HttpHealthcareApiClient.class);\n+  private transient CloudHealthcare client;\n+  private transient HttpClient httpClient;\n+  private transient GoogleCredentials credentials;\n+\n+  /**\n+   * Instantiates a new Http healthcare api client.\n+   *\n+   * @throws IOException the io exception\n+   */\n+  public HttpHealthcareApiClient() throws IOException {\n+    initClient();\n+  }\n+\n+  /**\n+   * Instantiates a new Http healthcare api client.\n+   *\n+   * @param client the client\n+   * @throws IOException the io exception\n+   */\n+  public HttpHealthcareApiClient(CloudHealthcare client) throws IOException {\n+    this.client = client;\n+    this.httpClient = HttpClients.createDefault();\n+    initClient();\n+  }\n+\n+  @VisibleForTesting\n+  static <T, X extends Collection<T>> Stream<T> flattenIteratorCollectionsToStream(\n+      Iterator<X> iterator) {\n+    Spliterator<Collection<T>> spliterator = Spliterators.spliteratorUnknownSize(iterator, 0);\n+    return StreamSupport.stream(spliterator, false).flatMap(Collection::stream);\n+  }\n+\n+  public JsonFactory getJsonFactory() {\n+    return this.client.getJsonFactory();\n+  }\n+\n+  @Override\n+  public Hl7V2Store createHL7v2Store(String dataset, String name) throws IOException {\n+    Hl7V2Store store = new Hl7V2Store();\n+    return client\n+        .projects()\n+        .locations()\n+        .datasets()\n+        .hl7V2Stores()\n+        .create(dataset, store)\n+        .setHl7V2StoreId(name)\n+        .execute();\n+  }\n+\n+  @Override\n+  public FhirStore createFhirStore(String dataset, String name, String version) throws IOException {\n+    FhirStore store = new FhirStore();\n+    // TODO add separate integration tests for each FHIR version: https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores#Version\n+    // Our integration test data is STU3.\n+    store.setVersion(version);\n+    store.setDisableReferentialIntegrity(true);\n+    store.setEnableUpdateCreate(true);\n+    return client\n+        .projects()\n+        .locations()\n+        .datasets()\n+        .fhirStores()\n+        .create(dataset, store)\n+        .setFhirStoreId(name)\n+        .execute();\n+  }\n+\n+  @Override\n+  public Empty deleteHL7v2Store(String name) throws IOException {\n+    return client.projects().locations().datasets().hl7V2Stores().delete(name).execute();\n+  }\n+\n+  @Override\n+  public Empty deleteFhirStore(String name) throws IOException {\n+    return client.projects().locations().datasets().fhirStores().delete(name).execute();\n+  }\n+\n+  @Override\n+  public ListMessagesResponse makeHL7v2ListRequest(\n+      String hl7v2Store, @Nullable String filter, @Nullable String pageToken) throws IOException {\n+\n+    Messages.List baseRequest =\n+        client\n+            .projects()\n+            .locations()\n+            .datasets()\n+            .hl7V2Stores()\n+            .messages()\n+            .list(hl7v2Store)\n+            .set(\"view\", \"full\")\n+            .setPageToken(pageToken);\n+\n+    if (Strings.isNullOrEmpty(filter)) {\n+      return baseRequest.execute();\n+    } else {\n+      return baseRequest.setFilter(filter).execute();\n+    }\n+  }\n+\n+  /**\n+   * Gets message id page iterator.\n+   *\n+   * @param hl7v2Store the HL7v2 store\n+   * @return the message id page iterator\n+   * @throws IOException the io exception\n+   */\n+  @Override\n+  public Stream<HL7v2Message> getHL7v2MessageStream(String hl7v2Store) throws IOException {\n+    return getHL7v2MessageStream(hl7v2Store, null);\n+  }\n+\n+  /**\n+   * Get a {@link Stream} of message IDs from flattening the pages of a new {@link\n+   * HL7v2MessagePages}.\n+   *\n+   * @param hl7v2Store the HL7v2 store\n+   * @param filter the filter\n+   * @return the message id Stream\n+   * @throws IOException the io exception\n+   */\n+  @Override\n+  public Stream<HL7v2Message> getHL7v2MessageStream(String hl7v2Store, @Nullable String filter)\n+      throws IOException {\n+    Iterator<List<HL7v2Message>> iterator =\n+        new HL7v2MessagePages(this, hl7v2Store, filter).iterator();\n+    return flattenIteratorCollectionsToStream(iterator);\n+  }\n+\n+  /**\n+   * Gets HL7v2 message.\n+   *\n+   * @param msgName the msg name\n+   * @return the message\n+   * @throws IOException the io exception\n+   * @throws ParseException the parse exception\n+   */\n+  @Override\n+  public Message getHL7v2Message(String msgName) throws IOException {\n+    Message msg =\n+        client.projects().locations().datasets().hl7V2Stores().messages().get(msgName).execute();\n+    if (msg == null) {\n+      throw new IOException(String.format(\"Couldn't find message: %s.\", msgName));\n+    }\n+    return msg;\n+  }\n+\n+  @Override\n+  public Empty deleteHL7v2Message(String msgName) throws IOException {\n+    return client\n+        .projects()\n+        .locations()\n+        .datasets()\n+        .hl7V2Stores()\n+        .messages()\n+        .delete(msgName)\n+        .execute();\n+  }\n+\n+  /**\n+   * Gets HL7v2 store.\n+   *\n+   * @param storeName the store name\n+   * @return the HL7v2 store\n+   * @throws IOException the io exception\n+   */\n+  @Override\n+  public Hl7V2Store getHL7v2Store(String storeName) throws IOException {\n+    return client.projects().locations().datasets().hl7V2Stores().get(storeName).execute();\n+  }\n+\n+  @Override\n+  public IngestMessageResponse ingestHL7v2Message(String hl7v2Store, Message msg)\n+      throws IOException {\n+    IngestMessageRequest ingestMessageRequest = new IngestMessageRequest();\n+    ingestMessageRequest.setMessage(msg);\n+    return client\n+        .projects()\n+        .locations()\n+        .datasets()\n+        .hl7V2Stores()\n+        .messages()\n+        .ingest(hl7v2Store, ingestMessageRequest)\n+        .execute();\n+  }\n+\n+  @Override\n+  public HttpBody fhirSearch(String fhirStore, SearchResourcesRequest query) throws IOException {\n+    return client\n+        .projects()\n+        .locations()\n+        .datasets()\n+        .fhirStores()\n+        .fhir()\n+        .search(fhirStore, query)\n+        .execute();\n+  }\n+\n+  @Override\n+  public Message createHL7v2Message(String hl7v2Store, Message msg) throws IOException {\n+    CreateMessageRequest createMessageRequest = new CreateMessageRequest();\n+    createMessageRequest.setMessage(msg);\n+    return client\n+        .projects()\n+        .locations()\n+        .datasets()\n+        .hl7V2Stores()\n+        .messages()\n+        .create(hl7v2Store, createMessageRequest)\n+        .execute();\n+  }\n+\n+  @Override\n+  public HttpBody createFhirResource(String fhirStore, String type, HttpBody body)\n+      throws IOException {\n+    return client\n+        .projects()\n+        .locations()\n+        .datasets()\n+        .fhirStores()\n+        .fhir()\n+        .create(fhirStore, type, body)\n+        .execute();\n+  }\n+\n+  @Override\n+  public Operation importFhirResource(\n+      String fhirStore, String gcsSourcePath, @Nullable String contentStructure)\n+      throws IOException {\n+    GoogleCloudHealthcareV1beta1FhirRestGcsSource gcsSrc =\n+        new GoogleCloudHealthcareV1beta1FhirRestGcsSource();\n+\n+    gcsSrc.setUri(gcsSourcePath);\n+    ImportResourcesRequest importRequest = new ImportResourcesRequest();\n+    importRequest.setGcsSource(gcsSrc).setContentStructure(contentStructure);\n+    return client\n+        .projects()\n+        .locations()\n+        .datasets()\n+        .fhirStores()\n+        .healthcareImport(fhirStore, importRequest)\n+        .execute();\n+  }\n+\n+  @Override\n+  public Operation pollOperation(Operation operation, Long sleepMs)\n+      throws InterruptedException, IOException {\n+    LOG.debug(String.format(\"started opertation %s. polling until complete.\", operation.getName()));\n+    while (operation.getDone() == null || !operation.getDone()) {\n+      // Update the status of the operation with another request.\n+      Thread.sleep(sleepMs); // Pause between requests.\n+      operation =\n+          client.projects().locations().datasets().operations().get(operation.getName()).execute();\n+    }\n+    return operation;\n+  }\n+\n+  @Override\n+  public HttpBody executeFhirBundle(String fhirStore, HttpBody bundle) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e7589e019b32335295f782dc4b13968c465470f"}, "originalPosition": 345}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc2MjM5NQ==", "bodyText": "There is no ETA for a fix, and it is out of our control. It is acceptable to me :)", "url": "https://github.com/apache/beam/pull/11339#discussion_r405762395", "createdAt": "2020-04-08T19:29:26Z", "author": {"login": "lastomato"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HttpHealthcareApiClient.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.google.api.client.http.HttpHeaders;\n+import com.google.api.client.http.HttpRequest;\n+import com.google.api.client.http.HttpRequestInitializer;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.gson.GsonFactory;\n+import com.google.api.services.healthcare.v1beta1.CloudHealthcare;\n+import com.google.api.services.healthcare.v1beta1.CloudHealthcare.Projects.Locations.Datasets.Hl7V2Stores.Messages;\n+import com.google.api.services.healthcare.v1beta1.CloudHealthcareScopes;\n+import com.google.api.services.healthcare.v1beta1.model.CreateMessageRequest;\n+import com.google.api.services.healthcare.v1beta1.model.Empty;\n+import com.google.api.services.healthcare.v1beta1.model.FhirStore;\n+import com.google.api.services.healthcare.v1beta1.model.GoogleCloudHealthcareV1beta1FhirRestGcsSource;\n+import com.google.api.services.healthcare.v1beta1.model.Hl7V2Store;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.ImportResourcesRequest;\n+import com.google.api.services.healthcare.v1beta1.model.IngestMessageRequest;\n+import com.google.api.services.healthcare.v1beta1.model.IngestMessageResponse;\n+import com.google.api.services.healthcare.v1beta1.model.ListMessagesResponse;\n+import com.google.api.services.healthcare.v1beta1.model.Message;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.api.services.healthcare.v1beta1.model.SearchResourcesRequest;\n+import com.google.api.services.storage.StorageScopes;\n+import com.google.auth.oauth2.GoogleCredentials;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Spliterator;\n+import java.util.Spliterators;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.extensions.gcp.util.RetryHttpRequestInitializer;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Strings;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.client.methods.RequestBuilder;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A client that talks to the Cloud Healthcare API through HTTP requests. This client is created\n+ * mainly to encapsulate the unserializable dependencies, since most generated classes are not\n+ * serializable in the HTTP client.\n+ */\n+public class HttpHealthcareApiClient implements HealthcareApiClient, Serializable {\n+  private static final String FHIRSTORE_HEADER_CONTENT_TYPE = \"application/fhir+json\";\n+  private static final String FHIRSTORE_HEADER_ACCEPT = \"application/fhir+json; charset=utf-8\";\n+  private static final String FHIRSTORE_HEADER_ACCEPT_CHARSET = \"utf-8\";\n+  private static final Logger LOG = LoggerFactory.getLogger(HttpHealthcareApiClient.class);\n+  private transient CloudHealthcare client;\n+  private transient HttpClient httpClient;\n+  private transient GoogleCredentials credentials;\n+\n+  /**\n+   * Instantiates a new Http healthcare api client.\n+   *\n+   * @throws IOException the io exception\n+   */\n+  public HttpHealthcareApiClient() throws IOException {\n+    initClient();\n+  }\n+\n+  /**\n+   * Instantiates a new Http healthcare api client.\n+   *\n+   * @param client the client\n+   * @throws IOException the io exception\n+   */\n+  public HttpHealthcareApiClient(CloudHealthcare client) throws IOException {\n+    this.client = client;\n+    this.httpClient = HttpClients.createDefault();\n+    initClient();\n+  }\n+\n+  @VisibleForTesting\n+  static <T, X extends Collection<T>> Stream<T> flattenIteratorCollectionsToStream(\n+      Iterator<X> iterator) {\n+    Spliterator<Collection<T>> spliterator = Spliterators.spliteratorUnknownSize(iterator, 0);\n+    return StreamSupport.stream(spliterator, false).flatMap(Collection::stream);\n+  }\n+\n+  public JsonFactory getJsonFactory() {\n+    return this.client.getJsonFactory();\n+  }\n+\n+  @Override\n+  public Hl7V2Store createHL7v2Store(String dataset, String name) throws IOException {\n+    Hl7V2Store store = new Hl7V2Store();\n+    return client\n+        .projects()\n+        .locations()\n+        .datasets()\n+        .hl7V2Stores()\n+        .create(dataset, store)\n+        .setHl7V2StoreId(name)\n+        .execute();\n+  }\n+\n+  @Override\n+  public FhirStore createFhirStore(String dataset, String name, String version) throws IOException {\n+    FhirStore store = new FhirStore();\n+    // TODO add separate integration tests for each FHIR version: https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores#Version\n+    // Our integration test data is STU3.\n+    store.setVersion(version);\n+    store.setDisableReferentialIntegrity(true);\n+    store.setEnableUpdateCreate(true);\n+    return client\n+        .projects()\n+        .locations()\n+        .datasets()\n+        .fhirStores()\n+        .create(dataset, store)\n+        .setFhirStoreId(name)\n+        .execute();\n+  }\n+\n+  @Override\n+  public Empty deleteHL7v2Store(String name) throws IOException {\n+    return client.projects().locations().datasets().hl7V2Stores().delete(name).execute();\n+  }\n+\n+  @Override\n+  public Empty deleteFhirStore(String name) throws IOException {\n+    return client.projects().locations().datasets().fhirStores().delete(name).execute();\n+  }\n+\n+  @Override\n+  public ListMessagesResponse makeHL7v2ListRequest(\n+      String hl7v2Store, @Nullable String filter, @Nullable String pageToken) throws IOException {\n+\n+    Messages.List baseRequest =\n+        client\n+            .projects()\n+            .locations()\n+            .datasets()\n+            .hl7V2Stores()\n+            .messages()\n+            .list(hl7v2Store)\n+            .set(\"view\", \"full\")\n+            .setPageToken(pageToken);\n+\n+    if (Strings.isNullOrEmpty(filter)) {\n+      return baseRequest.execute();\n+    } else {\n+      return baseRequest.setFilter(filter).execute();\n+    }\n+  }\n+\n+  /**\n+   * Gets message id page iterator.\n+   *\n+   * @param hl7v2Store the HL7v2 store\n+   * @return the message id page iterator\n+   * @throws IOException the io exception\n+   */\n+  @Override\n+  public Stream<HL7v2Message> getHL7v2MessageStream(String hl7v2Store) throws IOException {\n+    return getHL7v2MessageStream(hl7v2Store, null);\n+  }\n+\n+  /**\n+   * Get a {@link Stream} of message IDs from flattening the pages of a new {@link\n+   * HL7v2MessagePages}.\n+   *\n+   * @param hl7v2Store the HL7v2 store\n+   * @param filter the filter\n+   * @return the message id Stream\n+   * @throws IOException the io exception\n+   */\n+  @Override\n+  public Stream<HL7v2Message> getHL7v2MessageStream(String hl7v2Store, @Nullable String filter)\n+      throws IOException {\n+    Iterator<List<HL7v2Message>> iterator =\n+        new HL7v2MessagePages(this, hl7v2Store, filter).iterator();\n+    return flattenIteratorCollectionsToStream(iterator);\n+  }\n+\n+  /**\n+   * Gets HL7v2 message.\n+   *\n+   * @param msgName the msg name\n+   * @return the message\n+   * @throws IOException the io exception\n+   * @throws ParseException the parse exception\n+   */\n+  @Override\n+  public Message getHL7v2Message(String msgName) throws IOException {\n+    Message msg =\n+        client.projects().locations().datasets().hl7V2Stores().messages().get(msgName).execute();\n+    if (msg == null) {\n+      throw new IOException(String.format(\"Couldn't find message: %s.\", msgName));\n+    }\n+    return msg;\n+  }\n+\n+  @Override\n+  public Empty deleteHL7v2Message(String msgName) throws IOException {\n+    return client\n+        .projects()\n+        .locations()\n+        .datasets()\n+        .hl7V2Stores()\n+        .messages()\n+        .delete(msgName)\n+        .execute();\n+  }\n+\n+  /**\n+   * Gets HL7v2 store.\n+   *\n+   * @param storeName the store name\n+   * @return the HL7v2 store\n+   * @throws IOException the io exception\n+   */\n+  @Override\n+  public Hl7V2Store getHL7v2Store(String storeName) throws IOException {\n+    return client.projects().locations().datasets().hl7V2Stores().get(storeName).execute();\n+  }\n+\n+  @Override\n+  public IngestMessageResponse ingestHL7v2Message(String hl7v2Store, Message msg)\n+      throws IOException {\n+    IngestMessageRequest ingestMessageRequest = new IngestMessageRequest();\n+    ingestMessageRequest.setMessage(msg);\n+    return client\n+        .projects()\n+        .locations()\n+        .datasets()\n+        .hl7V2Stores()\n+        .messages()\n+        .ingest(hl7v2Store, ingestMessageRequest)\n+        .execute();\n+  }\n+\n+  @Override\n+  public HttpBody fhirSearch(String fhirStore, SearchResourcesRequest query) throws IOException {\n+    return client\n+        .projects()\n+        .locations()\n+        .datasets()\n+        .fhirStores()\n+        .fhir()\n+        .search(fhirStore, query)\n+        .execute();\n+  }\n+\n+  @Override\n+  public Message createHL7v2Message(String hl7v2Store, Message msg) throws IOException {\n+    CreateMessageRequest createMessageRequest = new CreateMessageRequest();\n+    createMessageRequest.setMessage(msg);\n+    return client\n+        .projects()\n+        .locations()\n+        .datasets()\n+        .hl7V2Stores()\n+        .messages()\n+        .create(hl7v2Store, createMessageRequest)\n+        .execute();\n+  }\n+\n+  @Override\n+  public HttpBody createFhirResource(String fhirStore, String type, HttpBody body)\n+      throws IOException {\n+    return client\n+        .projects()\n+        .locations()\n+        .datasets()\n+        .fhirStores()\n+        .fhir()\n+        .create(fhirStore, type, body)\n+        .execute();\n+  }\n+\n+  @Override\n+  public Operation importFhirResource(\n+      String fhirStore, String gcsSourcePath, @Nullable String contentStructure)\n+      throws IOException {\n+    GoogleCloudHealthcareV1beta1FhirRestGcsSource gcsSrc =\n+        new GoogleCloudHealthcareV1beta1FhirRestGcsSource();\n+\n+    gcsSrc.setUri(gcsSourcePath);\n+    ImportResourcesRequest importRequest = new ImportResourcesRequest();\n+    importRequest.setGcsSource(gcsSrc).setContentStructure(contentStructure);\n+    return client\n+        .projects()\n+        .locations()\n+        .datasets()\n+        .fhirStores()\n+        .healthcareImport(fhirStore, importRequest)\n+        .execute();\n+  }\n+\n+  @Override\n+  public Operation pollOperation(Operation operation, Long sleepMs)\n+      throws InterruptedException, IOException {\n+    LOG.debug(String.format(\"started opertation %s. polling until complete.\", operation.getName()));\n+    while (operation.getDone() == null || !operation.getDone()) {\n+      // Update the status of the operation with another request.\n+      Thread.sleep(sleepMs); // Pause between requests.\n+      operation =\n+          client.projects().locations().datasets().operations().get(operation.getName()).execute();\n+    }\n+    return operation;\n+  }\n+\n+  @Override\n+  public HttpBody executeFhirBundle(String fhirStore, HttpBody bundle) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyNTAzMQ=="}, "originalCommit": {"oid": "7e7589e019b32335295f782dc4b13968c465470f"}, "originalPosition": 345}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3OTE5OTA3OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMTo1NjowMlrOGLqnuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjoxNzo0N1rOGNpFFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg4NTgxNg==", "bodyText": "Is there any specific reason that the input is HttpBody instead of String? It feels weird to me because we only use the data field in the API client.", "url": "https://github.com/apache/beam/pull/11339#discussion_r414885816", "createdAt": "2020-04-24T21:56:02Z", "author": {"login": "lastomato"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,977 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.util.Sleeper;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link HttpBody}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link HttpBody} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This will return a\n+ *     {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedInsertsWithErr()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link HttpBody} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FHIRIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<HttpBody> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs of Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<HttpBody>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<HttpBody> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Of fhir io . read . result.\n+       *\n+       * @param pct the pct\n+       * @return the fhir io . read . result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT).setCoder(new HttpBodyCoder());\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<HttpBody> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<HttpBody> OUT = new TupleTag<HttpBody>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FhirIO.Read.FetchHttpBody());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link HttpBody} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchHttpBody extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchHttpBody() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FhirIO.Read.FetchHttpBody.HttpBodyGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class HttpBodyGetFn extends DoFn<String, HttpBody> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class);\n+        private final Counter successfulHttpBodyGets =\n+            Metrics.counter(\n+                FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        HttpBodyGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private HttpBody fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException, InterruptedException {\n+          long startTime = System.currentTimeMillis();\n+          Sleeper sleeper = Sleeper.DEFAULT;\n+\n+          com.google.api.services.healthcare.v1beta1.model.HttpBody resource =\n+              client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulHttpBodyGets.inc();\n+          return resource;\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<HttpBody>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<HttpBody>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<HttpBody>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<HttpBody>> failedInsertsWithErr;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedInserts the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<HttpBody>> failedInserts) {\n+        return new Result(pipeline, failedInserts);\n+      }\n+\n+      /**\n+       * Gets failed inserts with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<HttpBody>> getFailedInsertsWithErr() {\n+        return this.failedInsertsWithErr;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        failedInsertsWithErr.setCoder(new HealthcareIOErrorCoder<HttpBody>(new HttpBodyCoder()));\n+        return ImmutableMap.of(Write.FAILED_BODY, failedInsertsWithErr);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline, PCollection<HealthcareIOError<HttpBody>> failedInsertsWithErr) {\n+        this.pipeline = pipeline;\n+        this.failedInsertsWithErr = failedInsertsWithErr;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<HttpBody> input) {\n+      PCollection<HealthcareIOError<HttpBody>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.warn(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          FhirIO.Import.ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          failedBundles =\n+              input\n+                  .apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure))\n+                  .setCoder(new HealthcareIOErrorCoder<>(new HttpBodyCoder()));\n+          // fall through\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input.apply(\n+                  \"Execute FHIR Bundles\",\n+                  ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file.\n+   */\n+  public static class Import\n+      extends PTransform<PCollection<HttpBody>, PCollection<HealthcareIOError<HttpBody>>> {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+    private final int batchSize = 10000;\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> tempGcsPath,\n+        ValueProvider<String> deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore.get();\n+      this.tempGcsPath = tempGcsPath.get();\n+      this.deadLetterGcsPath = deadLetterGcsPath.get();\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    public PCollection<HealthcareIOError<HttpBody>> expand(PCollection<HttpBody> input) {\n+      // write bundles of HttpBody to GCS\n+      PCollectionTuple writeResults =\n+          input.apply(\n+              \"Write nd json to GCS\",\n+              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempGcsPath, deadLetterGcsPath))\n+                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+      int numShards = 100;\n+      PCollection<HealthcareIOError<String>> importResults =\n+          writeResults\n+              .get(Write.TEMP_FILES)\n+              .apply(\n+                  \"Shard files\", // to paralelize group into batches\n+                  WithKeys.of(ThreadLocalRandom.current().nextInt(0, numShards)))\n+              .apply(\"File Batches\", GroupIntoBatches.ofSize(batchSize))\n+              .apply(\n+                  ParDo.of(\n+                      new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)))\n+              .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+\n+      return writeResults\n+          .get(Write.FAILED_BODY)\n+          .setCoder(new HealthcareIOErrorCoder<>(HttpBodyCoder.of()));\n+    }\n+\n+    static class ImportFn\n+        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ResourceId tempDir;\n+      private final ContentStructure contentStructure;\n+      private HealthcareApiClient client;\n+      private final String fhirStore;\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void init() throws IOException {\n+        tempDir =\n+            FileSystems.matchNewResource(tempGcsPath, true)\n+                .resolve(\n+                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                    StandardResolveOptions.RESOLVE_DIRECTORY);\n+        client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+       * GCS URI.\n+       */\n+      @ProcessElement\n+      public void importBatch(ProcessContext context) throws IOException {\n+        Iterable<ResourceId> batch = context.element().getValue();\n+        List<ResourceId> tempDestinations = new ArrayList<>();\n+        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+        assert batch != null;\n+        for (ResourceId file : batch) {\n+          tempDestinations.add(\n+              tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+          deadLetterDestinations.add(\n+              FileSystems.matchNewResource(deadLetterGcsPath, true)\n+                  .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+        }\n+        FileSystems.rename(ImmutableList.copyOf(batch), tempDestinations);\n+        ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n+        try {\n+          // Blocking fhirStores.import request.\n+          assert contentStructure != null;\n+          Operation operation =\n+              client.importFhirResource(fhirStore, importUri.toString(), contentStructure.name());\n+          client.pollOperation(operation, 500L);\n+          // Clean up temp file on GCS.\n+          FileSystems.delete(tempDestinations);\n+        } catch (IOException | InterruptedException e) {\n+          ResourceId deadLetterResourceId = FileSystems.matchNewResource(deadLetterGcsPath, true);\n+          LOG.warn(\n+              String.format(\n+                  \"Failed to import %s with error: %s. Moving to deadletter path %s\",\n+                  importUri.toString(), e.getMessage(), deadLetterResourceId.toString()));\n+          FileSystems.rename(tempDestinations, deadLetterDestinations);\n+        }\n+      }\n+    }\n+\n+    /** The enum Content structure. */\n+    public enum ContentStructure {\n+      /** If the content structure is not specified, the default value BUNDLE will be used. */\n+      CONTENT_STRUCTURE_UNSPECIFIED,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a bundle, which contains one or more resources. Set the bundle type to history to import\n+       * resource versions.\n+       */\n+      BUNDLE,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a single resource.\n+       */\n+      RESOURCE,\n+      /** The entire file is one JSON bundle. The JSON can span multiple lines. */\n+      BUNDLE_PRETTY,\n+      /** The entire file is one JSON resource. The JSON can span multiple lines. */\n+      RESOURCE_PRETTY\n+    }\n+\n+    /** The type Import fn. */\n+    static class WriteBundlesToFilesFn extends DoFn<HttpBody, ResourceId> {\n+\n+      private final String fhirStore;\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ObjectMapper mapper;\n+      private ResourceId resourceId;\n+      private WritableByteChannel ndJsonChannel;\n+      private BoundedWindow window;\n+\n+      private transient HealthcareApiClient client;\n+      private static final Logger LOG = LoggerFactory.getLogger(WriteBundlesToFilesFn.class);\n+\n+      /**\n+       * Instantiates a new Import fn.\n+       *\n+       * @param fhirStore the fhir store\n+       * @param tempGcsPath the temp gcs path\n+       * @param deadLetterGcsPath the dead letter gcs path\n+       */\n+      WriteBundlesToFilesFn(String fhirStore, String tempGcsPath, String deadLetterGcsPath) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+      }\n+\n+      /**\n+       * Init client.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @Setup\n+      public void initClient() throws IOException {\n+        this.client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Init batch.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @StartBundle\n+      public void initFile() throws IOException {\n+        // Write each bundle to newline delimited JSON file.\n+        String filename = String.format(\"/fhirImportBatch-%s.ndjson\", UUID.randomUUID().toString());\n+        this.resourceId = FileSystems.matchNewResource(this.tempGcsPath + filename, false);\n+        this.ndJsonChannel = FileSystems.create(resourceId, \"application/ld+json\");\n+        if (mapper == null) {\n+          this.mapper = new ObjectMapper();\n+        }\n+      }\n+\n+      /**\n+       * Add to batch.\n+       *\n+       * @param context the context\n+       * @throws IOException the io exception\n+       */\n+      @ProcessElement\n+      public void addToFile(ProcessContext context, BoundedWindow window) throws IOException {\n+        this.window = window;\n+        HttpBody httpBody = context.element();\n+        try {\n+          // This will error if not valid JSON an convert Pretty JSON to raw JSON.\n+          Object data = this.mapper.readValue(httpBody.getData(), Object.class);\n+          String ndJson = this.mapper.writeValueAsString(data) + \"\\n\";\n+          this.ndJsonChannel.write(ByteBuffer.wrap(ndJson.getBytes(StandardCharsets.UTF_8)));\n+        } catch (JsonProcessingException e) {\n+          String resource =\n+              String.format(\n+                  \"Failed to parse payload: %s as json at: %s : %s.\"\n+                      + \"Dropping message from batch import.\",\n+                  httpBody.toString(), e.getLocation().getCharOffset(), e.getMessage());\n+          LOG.warn(resource);\n+          context.output(\n+              Write.FAILED_BODY, HealthcareIOError.of(httpBody, new IOException(resource)));\n+        }\n+      }\n+\n+      /**\n+       * Close file.\n+       *\n+       * @param context the context\n+       * @throws IOException the io exception\n+       */\n+      @FinishBundle\n+      public void closeFile(FinishBundleContext context) throws IOException {\n+        // Write the file with all elements in this bundle to GCS.\n+        ndJsonChannel.close();\n+        context.output(resourceId, window.maxTimestamp(), window);\n+      }\n+    }\n+  }\n+\n+  /** The type Execute bundles. */\n+  public static class ExecuteBundles extends PTransform<PCollection<HttpBody>, Write.Result> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216cde79d5e41ed14bc7c0668b7431e7f65af45d"}, "originalPosition": 903}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIxODk3NA==", "bodyText": "@lastomato\nMy original goal was just to mimic the client library as closely as possible to be familiar to users that are used to that interface and to smooth migration to use the client library (rather than using apache http clinet / requests as a workaround).\nFor example, if the signature was PTransform<PCollection, Write.Result> it might be confusing to a user if they need to base 64 encode the strings themselves or not.\nI was also unsure if there would be some use cases where users would want to set certain other things like extensions or content type in the HttpBody. Though it's worth noting that in the current implementation we are hard coding content type and don't handle extensions.\nIf you feel strongly that the API should accept Strings I'm open to refactoring for that.", "url": "https://github.com/apache/beam/pull/11339#discussion_r416218974", "createdAt": "2020-04-27T23:31:01Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,977 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.util.Sleeper;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link HttpBody}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link HttpBody} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This will return a\n+ *     {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedInsertsWithErr()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link HttpBody} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FHIRIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<HttpBody> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs of Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<HttpBody>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<HttpBody> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Of fhir io . read . result.\n+       *\n+       * @param pct the pct\n+       * @return the fhir io . read . result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT).setCoder(new HttpBodyCoder());\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<HttpBody> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<HttpBody> OUT = new TupleTag<HttpBody>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FhirIO.Read.FetchHttpBody());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link HttpBody} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchHttpBody extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchHttpBody() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FhirIO.Read.FetchHttpBody.HttpBodyGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class HttpBodyGetFn extends DoFn<String, HttpBody> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class);\n+        private final Counter successfulHttpBodyGets =\n+            Metrics.counter(\n+                FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        HttpBodyGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private HttpBody fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException, InterruptedException {\n+          long startTime = System.currentTimeMillis();\n+          Sleeper sleeper = Sleeper.DEFAULT;\n+\n+          com.google.api.services.healthcare.v1beta1.model.HttpBody resource =\n+              client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulHttpBodyGets.inc();\n+          return resource;\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<HttpBody>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<HttpBody>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<HttpBody>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<HttpBody>> failedInsertsWithErr;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedInserts the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<HttpBody>> failedInserts) {\n+        return new Result(pipeline, failedInserts);\n+      }\n+\n+      /**\n+       * Gets failed inserts with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<HttpBody>> getFailedInsertsWithErr() {\n+        return this.failedInsertsWithErr;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        failedInsertsWithErr.setCoder(new HealthcareIOErrorCoder<HttpBody>(new HttpBodyCoder()));\n+        return ImmutableMap.of(Write.FAILED_BODY, failedInsertsWithErr);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline, PCollection<HealthcareIOError<HttpBody>> failedInsertsWithErr) {\n+        this.pipeline = pipeline;\n+        this.failedInsertsWithErr = failedInsertsWithErr;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<HttpBody> input) {\n+      PCollection<HealthcareIOError<HttpBody>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.warn(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          FhirIO.Import.ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          failedBundles =\n+              input\n+                  .apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure))\n+                  .setCoder(new HealthcareIOErrorCoder<>(new HttpBodyCoder()));\n+          // fall through\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input.apply(\n+                  \"Execute FHIR Bundles\",\n+                  ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file.\n+   */\n+  public static class Import\n+      extends PTransform<PCollection<HttpBody>, PCollection<HealthcareIOError<HttpBody>>> {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+    private final int batchSize = 10000;\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> tempGcsPath,\n+        ValueProvider<String> deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore.get();\n+      this.tempGcsPath = tempGcsPath.get();\n+      this.deadLetterGcsPath = deadLetterGcsPath.get();\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    public PCollection<HealthcareIOError<HttpBody>> expand(PCollection<HttpBody> input) {\n+      // write bundles of HttpBody to GCS\n+      PCollectionTuple writeResults =\n+          input.apply(\n+              \"Write nd json to GCS\",\n+              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempGcsPath, deadLetterGcsPath))\n+                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+      int numShards = 100;\n+      PCollection<HealthcareIOError<String>> importResults =\n+          writeResults\n+              .get(Write.TEMP_FILES)\n+              .apply(\n+                  \"Shard files\", // to paralelize group into batches\n+                  WithKeys.of(ThreadLocalRandom.current().nextInt(0, numShards)))\n+              .apply(\"File Batches\", GroupIntoBatches.ofSize(batchSize))\n+              .apply(\n+                  ParDo.of(\n+                      new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)))\n+              .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+\n+      return writeResults\n+          .get(Write.FAILED_BODY)\n+          .setCoder(new HealthcareIOErrorCoder<>(HttpBodyCoder.of()));\n+    }\n+\n+    static class ImportFn\n+        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ResourceId tempDir;\n+      private final ContentStructure contentStructure;\n+      private HealthcareApiClient client;\n+      private final String fhirStore;\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void init() throws IOException {\n+        tempDir =\n+            FileSystems.matchNewResource(tempGcsPath, true)\n+                .resolve(\n+                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                    StandardResolveOptions.RESOLVE_DIRECTORY);\n+        client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+       * GCS URI.\n+       */\n+      @ProcessElement\n+      public void importBatch(ProcessContext context) throws IOException {\n+        Iterable<ResourceId> batch = context.element().getValue();\n+        List<ResourceId> tempDestinations = new ArrayList<>();\n+        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+        assert batch != null;\n+        for (ResourceId file : batch) {\n+          tempDestinations.add(\n+              tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+          deadLetterDestinations.add(\n+              FileSystems.matchNewResource(deadLetterGcsPath, true)\n+                  .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+        }\n+        FileSystems.rename(ImmutableList.copyOf(batch), tempDestinations);\n+        ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n+        try {\n+          // Blocking fhirStores.import request.\n+          assert contentStructure != null;\n+          Operation operation =\n+              client.importFhirResource(fhirStore, importUri.toString(), contentStructure.name());\n+          client.pollOperation(operation, 500L);\n+          // Clean up temp file on GCS.\n+          FileSystems.delete(tempDestinations);\n+        } catch (IOException | InterruptedException e) {\n+          ResourceId deadLetterResourceId = FileSystems.matchNewResource(deadLetterGcsPath, true);\n+          LOG.warn(\n+              String.format(\n+                  \"Failed to import %s with error: %s. Moving to deadletter path %s\",\n+                  importUri.toString(), e.getMessage(), deadLetterResourceId.toString()));\n+          FileSystems.rename(tempDestinations, deadLetterDestinations);\n+        }\n+      }\n+    }\n+\n+    /** The enum Content structure. */\n+    public enum ContentStructure {\n+      /** If the content structure is not specified, the default value BUNDLE will be used. */\n+      CONTENT_STRUCTURE_UNSPECIFIED,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a bundle, which contains one or more resources. Set the bundle type to history to import\n+       * resource versions.\n+       */\n+      BUNDLE,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a single resource.\n+       */\n+      RESOURCE,\n+      /** The entire file is one JSON bundle. The JSON can span multiple lines. */\n+      BUNDLE_PRETTY,\n+      /** The entire file is one JSON resource. The JSON can span multiple lines. */\n+      RESOURCE_PRETTY\n+    }\n+\n+    /** The type Import fn. */\n+    static class WriteBundlesToFilesFn extends DoFn<HttpBody, ResourceId> {\n+\n+      private final String fhirStore;\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ObjectMapper mapper;\n+      private ResourceId resourceId;\n+      private WritableByteChannel ndJsonChannel;\n+      private BoundedWindow window;\n+\n+      private transient HealthcareApiClient client;\n+      private static final Logger LOG = LoggerFactory.getLogger(WriteBundlesToFilesFn.class);\n+\n+      /**\n+       * Instantiates a new Import fn.\n+       *\n+       * @param fhirStore the fhir store\n+       * @param tempGcsPath the temp gcs path\n+       * @param deadLetterGcsPath the dead letter gcs path\n+       */\n+      WriteBundlesToFilesFn(String fhirStore, String tempGcsPath, String deadLetterGcsPath) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+      }\n+\n+      /**\n+       * Init client.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @Setup\n+      public void initClient() throws IOException {\n+        this.client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Init batch.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @StartBundle\n+      public void initFile() throws IOException {\n+        // Write each bundle to newline delimited JSON file.\n+        String filename = String.format(\"/fhirImportBatch-%s.ndjson\", UUID.randomUUID().toString());\n+        this.resourceId = FileSystems.matchNewResource(this.tempGcsPath + filename, false);\n+        this.ndJsonChannel = FileSystems.create(resourceId, \"application/ld+json\");\n+        if (mapper == null) {\n+          this.mapper = new ObjectMapper();\n+        }\n+      }\n+\n+      /**\n+       * Add to batch.\n+       *\n+       * @param context the context\n+       * @throws IOException the io exception\n+       */\n+      @ProcessElement\n+      public void addToFile(ProcessContext context, BoundedWindow window) throws IOException {\n+        this.window = window;\n+        HttpBody httpBody = context.element();\n+        try {\n+          // This will error if not valid JSON an convert Pretty JSON to raw JSON.\n+          Object data = this.mapper.readValue(httpBody.getData(), Object.class);\n+          String ndJson = this.mapper.writeValueAsString(data) + \"\\n\";\n+          this.ndJsonChannel.write(ByteBuffer.wrap(ndJson.getBytes(StandardCharsets.UTF_8)));\n+        } catch (JsonProcessingException e) {\n+          String resource =\n+              String.format(\n+                  \"Failed to parse payload: %s as json at: %s : %s.\"\n+                      + \"Dropping message from batch import.\",\n+                  httpBody.toString(), e.getLocation().getCharOffset(), e.getMessage());\n+          LOG.warn(resource);\n+          context.output(\n+              Write.FAILED_BODY, HealthcareIOError.of(httpBody, new IOException(resource)));\n+        }\n+      }\n+\n+      /**\n+       * Close file.\n+       *\n+       * @param context the context\n+       * @throws IOException the io exception\n+       */\n+      @FinishBundle\n+      public void closeFile(FinishBundleContext context) throws IOException {\n+        // Write the file with all elements in this bundle to GCS.\n+        ndJsonChannel.close();\n+        context.output(resourceId, window.maxTimestamp(), window);\n+      }\n+    }\n+  }\n+\n+  /** The type Execute bundles. */\n+  public static class ExecuteBundles extends PTransform<PCollection<HttpBody>, Write.Result> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg4NTgxNg=="}, "originalCommit": {"oid": "216cde79d5e41ed14bc7c0668b7431e7f65af45d"}, "originalPosition": 903}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NzcxOQ==", "bodyText": "discussed offline, will refactor to pass around as strings.", "url": "https://github.com/apache/beam/pull/11339#discussion_r416957719", "createdAt": "2020-04-28T22:17:47Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,977 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.util.Sleeper;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link HttpBody}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link HttpBody} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This will return a\n+ *     {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedInsertsWithErr()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link HttpBody} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FHIRIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<HttpBody> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs of Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<HttpBody>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<HttpBody> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Of fhir io . read . result.\n+       *\n+       * @param pct the pct\n+       * @return the fhir io . read . result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT).setCoder(new HttpBodyCoder());\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<HttpBody> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<HttpBody> OUT = new TupleTag<HttpBody>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FhirIO.Read.FetchHttpBody());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link HttpBody} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchHttpBody extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchHttpBody() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FhirIO.Read.FetchHttpBody.HttpBodyGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class HttpBodyGetFn extends DoFn<String, HttpBody> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class);\n+        private final Counter successfulHttpBodyGets =\n+            Metrics.counter(\n+                FhirIO.Read.FetchHttpBody.HttpBodyGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        HttpBodyGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private HttpBody fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException, InterruptedException {\n+          long startTime = System.currentTimeMillis();\n+          Sleeper sleeper = Sleeper.DEFAULT;\n+\n+          com.google.api.services.healthcare.v1beta1.model.HttpBody resource =\n+              client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulHttpBodyGets.inc();\n+          return resource;\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<HttpBody>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<HttpBody>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<HttpBody>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<HttpBody>> failedInsertsWithErr;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedInserts the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<HttpBody>> failedInserts) {\n+        return new Result(pipeline, failedInserts);\n+      }\n+\n+      /**\n+       * Gets failed inserts with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<HttpBody>> getFailedInsertsWithErr() {\n+        return this.failedInsertsWithErr;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        failedInsertsWithErr.setCoder(new HealthcareIOErrorCoder<HttpBody>(new HttpBodyCoder()));\n+        return ImmutableMap.of(Write.FAILED_BODY, failedInsertsWithErr);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline, PCollection<HealthcareIOError<HttpBody>> failedInsertsWithErr) {\n+        this.pipeline = pipeline;\n+        this.failedInsertsWithErr = failedInsertsWithErr;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<HttpBody> input) {\n+      PCollection<HealthcareIOError<HttpBody>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.warn(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          FhirIO.Import.ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          failedBundles =\n+              input\n+                  .apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure))\n+                  .setCoder(new HealthcareIOErrorCoder<>(new HttpBodyCoder()));\n+          // fall through\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input.apply(\n+                  \"Execute FHIR Bundles\",\n+                  ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file.\n+   */\n+  public static class Import\n+      extends PTransform<PCollection<HttpBody>, PCollection<HealthcareIOError<HttpBody>>> {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+    private final int batchSize = 10000;\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> tempGcsPath,\n+        ValueProvider<String> deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore.get();\n+      this.tempGcsPath = tempGcsPath.get();\n+      this.deadLetterGcsPath = deadLetterGcsPath.get();\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    public PCollection<HealthcareIOError<HttpBody>> expand(PCollection<HttpBody> input) {\n+      // write bundles of HttpBody to GCS\n+      PCollectionTuple writeResults =\n+          input.apply(\n+              \"Write nd json to GCS\",\n+              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempGcsPath, deadLetterGcsPath))\n+                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+      int numShards = 100;\n+      PCollection<HealthcareIOError<String>> importResults =\n+          writeResults\n+              .get(Write.TEMP_FILES)\n+              .apply(\n+                  \"Shard files\", // to paralelize group into batches\n+                  WithKeys.of(ThreadLocalRandom.current().nextInt(0, numShards)))\n+              .apply(\"File Batches\", GroupIntoBatches.ofSize(batchSize))\n+              .apply(\n+                  ParDo.of(\n+                      new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)))\n+              .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+\n+      return writeResults\n+          .get(Write.FAILED_BODY)\n+          .setCoder(new HealthcareIOErrorCoder<>(HttpBodyCoder.of()));\n+    }\n+\n+    static class ImportFn\n+        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ResourceId tempDir;\n+      private final ContentStructure contentStructure;\n+      private HealthcareApiClient client;\n+      private final String fhirStore;\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void init() throws IOException {\n+        tempDir =\n+            FileSystems.matchNewResource(tempGcsPath, true)\n+                .resolve(\n+                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                    StandardResolveOptions.RESOLVE_DIRECTORY);\n+        client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+       * GCS URI.\n+       */\n+      @ProcessElement\n+      public void importBatch(ProcessContext context) throws IOException {\n+        Iterable<ResourceId> batch = context.element().getValue();\n+        List<ResourceId> tempDestinations = new ArrayList<>();\n+        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+        assert batch != null;\n+        for (ResourceId file : batch) {\n+          tempDestinations.add(\n+              tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+          deadLetterDestinations.add(\n+              FileSystems.matchNewResource(deadLetterGcsPath, true)\n+                  .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+        }\n+        FileSystems.rename(ImmutableList.copyOf(batch), tempDestinations);\n+        ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n+        try {\n+          // Blocking fhirStores.import request.\n+          assert contentStructure != null;\n+          Operation operation =\n+              client.importFhirResource(fhirStore, importUri.toString(), contentStructure.name());\n+          client.pollOperation(operation, 500L);\n+          // Clean up temp file on GCS.\n+          FileSystems.delete(tempDestinations);\n+        } catch (IOException | InterruptedException e) {\n+          ResourceId deadLetterResourceId = FileSystems.matchNewResource(deadLetterGcsPath, true);\n+          LOG.warn(\n+              String.format(\n+                  \"Failed to import %s with error: %s. Moving to deadletter path %s\",\n+                  importUri.toString(), e.getMessage(), deadLetterResourceId.toString()));\n+          FileSystems.rename(tempDestinations, deadLetterDestinations);\n+        }\n+      }\n+    }\n+\n+    /** The enum Content structure. */\n+    public enum ContentStructure {\n+      /** If the content structure is not specified, the default value BUNDLE will be used. */\n+      CONTENT_STRUCTURE_UNSPECIFIED,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a bundle, which contains one or more resources. Set the bundle type to history to import\n+       * resource versions.\n+       */\n+      BUNDLE,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a single resource.\n+       */\n+      RESOURCE,\n+      /** The entire file is one JSON bundle. The JSON can span multiple lines. */\n+      BUNDLE_PRETTY,\n+      /** The entire file is one JSON resource. The JSON can span multiple lines. */\n+      RESOURCE_PRETTY\n+    }\n+\n+    /** The type Import fn. */\n+    static class WriteBundlesToFilesFn extends DoFn<HttpBody, ResourceId> {\n+\n+      private final String fhirStore;\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ObjectMapper mapper;\n+      private ResourceId resourceId;\n+      private WritableByteChannel ndJsonChannel;\n+      private BoundedWindow window;\n+\n+      private transient HealthcareApiClient client;\n+      private static final Logger LOG = LoggerFactory.getLogger(WriteBundlesToFilesFn.class);\n+\n+      /**\n+       * Instantiates a new Import fn.\n+       *\n+       * @param fhirStore the fhir store\n+       * @param tempGcsPath the temp gcs path\n+       * @param deadLetterGcsPath the dead letter gcs path\n+       */\n+      WriteBundlesToFilesFn(String fhirStore, String tempGcsPath, String deadLetterGcsPath) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+      }\n+\n+      /**\n+       * Init client.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @Setup\n+      public void initClient() throws IOException {\n+        this.client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Init batch.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @StartBundle\n+      public void initFile() throws IOException {\n+        // Write each bundle to newline delimited JSON file.\n+        String filename = String.format(\"/fhirImportBatch-%s.ndjson\", UUID.randomUUID().toString());\n+        this.resourceId = FileSystems.matchNewResource(this.tempGcsPath + filename, false);\n+        this.ndJsonChannel = FileSystems.create(resourceId, \"application/ld+json\");\n+        if (mapper == null) {\n+          this.mapper = new ObjectMapper();\n+        }\n+      }\n+\n+      /**\n+       * Add to batch.\n+       *\n+       * @param context the context\n+       * @throws IOException the io exception\n+       */\n+      @ProcessElement\n+      public void addToFile(ProcessContext context, BoundedWindow window) throws IOException {\n+        this.window = window;\n+        HttpBody httpBody = context.element();\n+        try {\n+          // This will error if not valid JSON an convert Pretty JSON to raw JSON.\n+          Object data = this.mapper.readValue(httpBody.getData(), Object.class);\n+          String ndJson = this.mapper.writeValueAsString(data) + \"\\n\";\n+          this.ndJsonChannel.write(ByteBuffer.wrap(ndJson.getBytes(StandardCharsets.UTF_8)));\n+        } catch (JsonProcessingException e) {\n+          String resource =\n+              String.format(\n+                  \"Failed to parse payload: %s as json at: %s : %s.\"\n+                      + \"Dropping message from batch import.\",\n+                  httpBody.toString(), e.getLocation().getCharOffset(), e.getMessage());\n+          LOG.warn(resource);\n+          context.output(\n+              Write.FAILED_BODY, HealthcareIOError.of(httpBody, new IOException(resource)));\n+        }\n+      }\n+\n+      /**\n+       * Close file.\n+       *\n+       * @param context the context\n+       * @throws IOException the io exception\n+       */\n+      @FinishBundle\n+      public void closeFile(FinishBundleContext context) throws IOException {\n+        // Write the file with all elements in this bundle to GCS.\n+        ndJsonChannel.close();\n+        context.output(resourceId, window.maxTimestamp(), window);\n+      }\n+    }\n+  }\n+\n+  /** The type Execute bundles. */\n+  public static class ExecuteBundles extends PTransform<PCollection<HttpBody>, Write.Result> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg4NTgxNg=="}, "originalCommit": {"oid": "216cde79d5e41ed14bc7c0668b7431e7f65af45d"}, "originalPosition": 903}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjk1MTcwOnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDo0NDo1NVrOGQ620Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDo0NDo1NVrOGQ620Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5NDcwNQ==", "bodyText": "should this be warn or info?", "url": "https://github.com/apache/beam/pull/11339#discussion_r420394705", "createdAt": "2020-05-05T20:44:55Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,977 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedInsertsWithErr()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FHIRIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs of Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Of fhir io . read . result.\n+       *\n+       * @param pct the pct\n+       * @return the fhir io . read . result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FhirIO.Read.FetchString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchString extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FhirIO.Read.FetchString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FhirIO.Read.FetchString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FhirIO.Read.FetchString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FhirIO.Read.FetchString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private String fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException {\n+          long startTime = System.currentTimeMillis();\n+\n+          HttpBody resource = client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulStringGets.inc();\n+          return mapper.writeValueAsString(resource);\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<String>> failedInsertsWithErr;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedInserts the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInserts) {\n+        return new Result(pipeline, failedInserts);\n+      }\n+\n+      /**\n+       * Gets failed inserts with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedInsertsWithErr() {\n+        return this.failedInsertsWithErr;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        failedInsertsWithErr.setCoder(new HealthcareIOErrorCoder<String>(StringUtf8Coder.of()));\n+        return ImmutableMap.of(Write.FAILED_BODY, failedInsertsWithErr);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInsertsWithErr) {\n+        this.pipeline = pipeline;\n+        this.failedInsertsWithErr = failedInsertsWithErr;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<String> input) {\n+      PCollection<HealthcareIOError<String>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.warn(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7533139cc92d4e50221b4a560937e621c9c21d8a"}, "originalPosition": 602}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjk2ODg2OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDo0OTo1NFrOGQ7Bfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDo0OTo1NFrOGQ7Bfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5NzQzOA==", "bodyText": "Consider adding ValueProvider support for temp and deadletter paths.", "url": "https://github.com/apache/beam/pull/11339#discussion_r420397438", "createdAt": "2020-05-05T20:49:54Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,977 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedInsertsWithErr()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FHIRIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs of Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Of fhir io . read . result.\n+       *\n+       * @param pct the pct\n+       * @return the fhir io . read . result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FhirIO.Read.FetchString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchString extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FhirIO.Read.FetchString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FhirIO.Read.FetchString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FhirIO.Read.FetchString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FhirIO.Read.FetchString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private String fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException {\n+          long startTime = System.currentTimeMillis();\n+\n+          HttpBody resource = client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulStringGets.inc();\n+          return mapper.writeValueAsString(resource);\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<String>> failedInsertsWithErr;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedInserts the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInserts) {\n+        return new Result(pipeline, failedInserts);\n+      }\n+\n+      /**\n+       * Gets failed inserts with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedInsertsWithErr() {\n+        return this.failedInsertsWithErr;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        failedInsertsWithErr.setCoder(new HealthcareIOErrorCoder<String>(StringUtf8Coder.of()));\n+        return ImmutableMap.of(Write.FAILED_BODY, failedInsertsWithErr);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInsertsWithErr) {\n+        this.pipeline = pipeline;\n+        this.failedInsertsWithErr = failedInsertsWithErr;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<String> input) {\n+      PCollection<HealthcareIOError<String>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.warn(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7533139cc92d4e50221b4a560937e621c9c21d8a"}, "originalPosition": 605}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjk3NTQzOnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDo1MTo1NFrOGQ7Fvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDo1MTo1NFrOGQ7Fvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5ODUyNg==", "bodyText": "move this above ImportFn", "url": "https://github.com/apache/beam/pull/11339#discussion_r420398526", "createdAt": "2020-05-05T20:51:54Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,977 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedInsertsWithErr()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FHIRIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs of Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Of fhir io . read . result.\n+       *\n+       * @param pct the pct\n+       * @return the fhir io . read . result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FhirIO.Read.FetchString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchString extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FhirIO.Read.FetchString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FhirIO.Read.FetchString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FhirIO.Read.FetchString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FhirIO.Read.FetchString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private String fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException {\n+          long startTime = System.currentTimeMillis();\n+\n+          HttpBody resource = client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulStringGets.inc();\n+          return mapper.writeValueAsString(resource);\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<String>> failedInsertsWithErr;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedInserts the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInserts) {\n+        return new Result(pipeline, failedInserts);\n+      }\n+\n+      /**\n+       * Gets failed inserts with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedInsertsWithErr() {\n+        return this.failedInsertsWithErr;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        failedInsertsWithErr.setCoder(new HealthcareIOErrorCoder<String>(StringUtf8Coder.of()));\n+        return ImmutableMap.of(Write.FAILED_BODY, failedInsertsWithErr);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInsertsWithErr) {\n+        this.pipeline = pipeline;\n+        this.failedInsertsWithErr = failedInsertsWithErr;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<String> input) {\n+      PCollection<HealthcareIOError<String>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.warn(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          FhirIO.Import.ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          failedBundles =\n+              input\n+                  .apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure))\n+                  .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+          // fall through\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input.apply(\n+                  \"Execute FHIR Bundles\",\n+                  ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file.\n+   */\n+  public static class Import\n+      extends PTransform<PCollection<String>, PCollection<HealthcareIOError<String>>> {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+    private final int batchSize = 10000;\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> tempGcsPath,\n+        ValueProvider<String> deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore.get();\n+      this.tempGcsPath = tempGcsPath.get();\n+      this.deadLetterGcsPath = deadLetterGcsPath.get();\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    public PCollection<HealthcareIOError<String>> expand(PCollection<String> input) {\n+      // write bundles of String to GCS\n+      PCollectionTuple writeResults =\n+          input.apply(\n+              \"Write nd json to GCS\",\n+              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempGcsPath, deadLetterGcsPath))\n+                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+      int numShards = 100;\n+      PCollection<HealthcareIOError<String>> importResults =\n+          writeResults\n+              .get(Write.TEMP_FILES)\n+              .apply(\n+                  \"Shard files\", // to paralelize group into batches\n+                  WithKeys.of(ThreadLocalRandom.current().nextInt(0, numShards)))\n+              .apply(\"File Batches\", GroupIntoBatches.ofSize(batchSize))\n+              .apply(\n+                  ParDo.of(\n+                      new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)))\n+              .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+\n+      return writeResults\n+          .get(Write.FAILED_BODY)\n+          .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+    }\n+\n+    static class ImportFn\n+        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ResourceId tempDir;\n+      private final ContentStructure contentStructure;\n+      private HealthcareApiClient client;\n+      private final String fhirStore;\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void init() throws IOException {\n+        tempDir =\n+            FileSystems.matchNewResource(tempGcsPath, true)\n+                .resolve(\n+                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                    StandardResolveOptions.RESOLVE_DIRECTORY);\n+        client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+       * GCS URI.\n+       */\n+      @ProcessElement\n+      public void importBatch(ProcessContext context) throws IOException {\n+        Iterable<ResourceId> batch = context.element().getValue();\n+        List<ResourceId> tempDestinations = new ArrayList<>();\n+        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+        assert batch != null;\n+        for (ResourceId file : batch) {\n+          tempDestinations.add(\n+              tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+          deadLetterDestinations.add(\n+              FileSystems.matchNewResource(deadLetterGcsPath, true)\n+                  .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+        }\n+        FileSystems.rename(ImmutableList.copyOf(batch), tempDestinations);\n+        ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n+        try {\n+          // Blocking fhirStores.import request.\n+          assert contentStructure != null;\n+          Operation operation =\n+              client.importFhirResource(fhirStore, importUri.toString(), contentStructure.name());\n+          client.pollOperation(operation, 500L);\n+          // Clean up temp file on GCS.\n+          FileSystems.delete(tempDestinations);\n+        } catch (IOException | InterruptedException e) {\n+          ResourceId deadLetterResourceId = FileSystems.matchNewResource(deadLetterGcsPath, true);\n+          LOG.warn(\n+              String.format(\n+                  \"Failed to import %s with error: %s. Moving to deadletter path %s\",\n+                  importUri.toString(), e.getMessage(), deadLetterResourceId.toString()));\n+          FileSystems.rename(tempDestinations, deadLetterDestinations);\n+        }\n+      }\n+    }\n+\n+    /** The enum Content structure. */\n+    public enum ContentStructure {\n+      /** If the content structure is not specified, the default value BUNDLE will be used. */\n+      CONTENT_STRUCTURE_UNSPECIFIED,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a bundle, which contains one or more resources. Set the bundle type to history to import\n+       * resource versions.\n+       */\n+      BUNDLE,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a single resource.\n+       */\n+      RESOURCE,\n+      /** The entire file is one JSON bundle. The JSON can span multiple lines. */\n+      BUNDLE_PRETTY,\n+      /** The entire file is one JSON resource. The JSON can span multiple lines. */\n+      RESOURCE_PRETTY\n+    }\n+\n+    /** The type Import fn. */\n+    static class WriteBundlesToFilesFn extends DoFn<String, ResourceId> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7533139cc92d4e50221b4a560937e621c9c21d8a"}, "originalPosition": 808}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjk3OTQwOnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDo1MzoxMVrOGQ7IUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDo1MzoxMVrOGQ7IUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5OTE4NQ==", "bodyText": "use a path joining method to handle trailing slash, etc.", "url": "https://github.com/apache/beam/pull/11339#discussion_r420399185", "createdAt": "2020-05-05T20:53:11Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,977 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedInsertsWithErr()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FHIRIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs of Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Of fhir io . read . result.\n+       *\n+       * @param pct the pct\n+       * @return the fhir io . read . result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FhirIO.Read.FetchString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchString extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FhirIO.Read.FetchString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FhirIO.Read.FetchString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FhirIO.Read.FetchString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FhirIO.Read.FetchString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private String fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException {\n+          long startTime = System.currentTimeMillis();\n+\n+          HttpBody resource = client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulStringGets.inc();\n+          return mapper.writeValueAsString(resource);\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<String>> failedInsertsWithErr;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedInserts the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInserts) {\n+        return new Result(pipeline, failedInserts);\n+      }\n+\n+      /**\n+       * Gets failed inserts with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedInsertsWithErr() {\n+        return this.failedInsertsWithErr;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        failedInsertsWithErr.setCoder(new HealthcareIOErrorCoder<String>(StringUtf8Coder.of()));\n+        return ImmutableMap.of(Write.FAILED_BODY, failedInsertsWithErr);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInsertsWithErr) {\n+        this.pipeline = pipeline;\n+        this.failedInsertsWithErr = failedInsertsWithErr;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<String> input) {\n+      PCollection<HealthcareIOError<String>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.warn(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          FhirIO.Import.ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          failedBundles =\n+              input\n+                  .apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure))\n+                  .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+          // fall through\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input.apply(\n+                  \"Execute FHIR Bundles\",\n+                  ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file.\n+   */\n+  public static class Import\n+      extends PTransform<PCollection<String>, PCollection<HealthcareIOError<String>>> {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+    private final int batchSize = 10000;\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> tempGcsPath,\n+        ValueProvider<String> deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore.get();\n+      this.tempGcsPath = tempGcsPath.get();\n+      this.deadLetterGcsPath = deadLetterGcsPath.get();\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    public PCollection<HealthcareIOError<String>> expand(PCollection<String> input) {\n+      // write bundles of String to GCS\n+      PCollectionTuple writeResults =\n+          input.apply(\n+              \"Write nd json to GCS\",\n+              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempGcsPath, deadLetterGcsPath))\n+                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+      int numShards = 100;\n+      PCollection<HealthcareIOError<String>> importResults =\n+          writeResults\n+              .get(Write.TEMP_FILES)\n+              .apply(\n+                  \"Shard files\", // to paralelize group into batches\n+                  WithKeys.of(ThreadLocalRandom.current().nextInt(0, numShards)))\n+              .apply(\"File Batches\", GroupIntoBatches.ofSize(batchSize))\n+              .apply(\n+                  ParDo.of(\n+                      new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)))\n+              .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+\n+      return writeResults\n+          .get(Write.FAILED_BODY)\n+          .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+    }\n+\n+    static class ImportFn\n+        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ResourceId tempDir;\n+      private final ContentStructure contentStructure;\n+      private HealthcareApiClient client;\n+      private final String fhirStore;\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void init() throws IOException {\n+        tempDir =\n+            FileSystems.matchNewResource(tempGcsPath, true)\n+                .resolve(\n+                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                    StandardResolveOptions.RESOLVE_DIRECTORY);\n+        client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+       * GCS URI.\n+       */\n+      @ProcessElement\n+      public void importBatch(ProcessContext context) throws IOException {\n+        Iterable<ResourceId> batch = context.element().getValue();\n+        List<ResourceId> tempDestinations = new ArrayList<>();\n+        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+        assert batch != null;\n+        for (ResourceId file : batch) {\n+          tempDestinations.add(\n+              tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+          deadLetterDestinations.add(\n+              FileSystems.matchNewResource(deadLetterGcsPath, true)\n+                  .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+        }\n+        FileSystems.rename(ImmutableList.copyOf(batch), tempDestinations);\n+        ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n+        try {\n+          // Blocking fhirStores.import request.\n+          assert contentStructure != null;\n+          Operation operation =\n+              client.importFhirResource(fhirStore, importUri.toString(), contentStructure.name());\n+          client.pollOperation(operation, 500L);\n+          // Clean up temp file on GCS.\n+          FileSystems.delete(tempDestinations);\n+        } catch (IOException | InterruptedException e) {\n+          ResourceId deadLetterResourceId = FileSystems.matchNewResource(deadLetterGcsPath, true);\n+          LOG.warn(\n+              String.format(\n+                  \"Failed to import %s with error: %s. Moving to deadletter path %s\",\n+                  importUri.toString(), e.getMessage(), deadLetterResourceId.toString()));\n+          FileSystems.rename(tempDestinations, deadLetterDestinations);\n+        }\n+      }\n+    }\n+\n+    /** The enum Content structure. */\n+    public enum ContentStructure {\n+      /** If the content structure is not specified, the default value BUNDLE will be used. */\n+      CONTENT_STRUCTURE_UNSPECIFIED,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a bundle, which contains one or more resources. Set the bundle type to history to import\n+       * resource versions.\n+       */\n+      BUNDLE,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a single resource.\n+       */\n+      RESOURCE,\n+      /** The entire file is one JSON bundle. The JSON can span multiple lines. */\n+      BUNDLE_PRETTY,\n+      /** The entire file is one JSON resource. The JSON can span multiple lines. */\n+      RESOURCE_PRETTY\n+    }\n+\n+    /** The type Import fn. */\n+    static class WriteBundlesToFilesFn extends DoFn<String, ResourceId> {\n+\n+      private final String fhirStore;\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ObjectMapper mapper;\n+      private ResourceId resourceId;\n+      private WritableByteChannel ndJsonChannel;\n+      private BoundedWindow window;\n+\n+      private transient HealthcareApiClient client;\n+      private static final Logger LOG = LoggerFactory.getLogger(WriteBundlesToFilesFn.class);\n+\n+      /**\n+       * Instantiates a new Import fn.\n+       *\n+       * @param fhirStore the fhir store\n+       * @param tempGcsPath the temp gcs path\n+       * @param deadLetterGcsPath the dead letter gcs path\n+       */\n+      WriteBundlesToFilesFn(String fhirStore, String tempGcsPath, String deadLetterGcsPath) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+      }\n+\n+      /**\n+       * Init client.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @Setup\n+      public void initClient() throws IOException {\n+        this.client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Init batch.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @StartBundle\n+      public void initFile() throws IOException {\n+        // Write each bundle to newline delimited JSON file.\n+        String filename = String.format(\"/fhirImportBatch-%s.ndjson\", UUID.randomUUID().toString());\n+        this.resourceId = FileSystems.matchNewResource(this.tempGcsPath + filename, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7533139cc92d4e50221b4a560937e621c9c21d8a"}, "originalPosition": 853}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzAxNTQ0OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMTowMzozN1rOGQ7eiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMTo0OToyNlrOGTuoSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwNDg3NQ==", "bodyText": "is import method idempotent?", "url": "https://github.com/apache/beam/pull/11339#discussion_r420404875", "createdAt": "2020-05-05T21:03:37Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,977 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedInsertsWithErr()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FHIRIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs of Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Of fhir io . read . result.\n+       *\n+       * @param pct the pct\n+       * @return the fhir io . read . result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FhirIO.Read.FetchString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchString extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FhirIO.Read.FetchString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FhirIO.Read.FetchString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FhirIO.Read.FetchString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FhirIO.Read.FetchString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private String fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException {\n+          long startTime = System.currentTimeMillis();\n+\n+          HttpBody resource = client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulStringGets.inc();\n+          return mapper.writeValueAsString(resource);\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<String>> failedInsertsWithErr;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedInserts the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInserts) {\n+        return new Result(pipeline, failedInserts);\n+      }\n+\n+      /**\n+       * Gets failed inserts with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedInsertsWithErr() {\n+        return this.failedInsertsWithErr;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        failedInsertsWithErr.setCoder(new HealthcareIOErrorCoder<String>(StringUtf8Coder.of()));\n+        return ImmutableMap.of(Write.FAILED_BODY, failedInsertsWithErr);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInsertsWithErr) {\n+        this.pipeline = pipeline;\n+        this.failedInsertsWithErr = failedInsertsWithErr;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<String> input) {\n+      PCollection<HealthcareIOError<String>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.warn(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          FhirIO.Import.ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          failedBundles =\n+              input\n+                  .apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure))\n+                  .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+          // fall through\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input.apply(\n+                  \"Execute FHIR Bundles\",\n+                  ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file.\n+   */\n+  public static class Import\n+      extends PTransform<PCollection<String>, PCollection<HealthcareIOError<String>>> {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+    private final int batchSize = 10000;\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> tempGcsPath,\n+        ValueProvider<String> deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore.get();\n+      this.tempGcsPath = tempGcsPath.get();\n+      this.deadLetterGcsPath = deadLetterGcsPath.get();\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    public PCollection<HealthcareIOError<String>> expand(PCollection<String> input) {\n+      // write bundles of String to GCS\n+      PCollectionTuple writeResults =\n+          input.apply(\n+              \"Write nd json to GCS\",\n+              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempGcsPath, deadLetterGcsPath))\n+                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+      int numShards = 100;\n+      PCollection<HealthcareIOError<String>> importResults =\n+          writeResults\n+              .get(Write.TEMP_FILES)\n+              .apply(\n+                  \"Shard files\", // to paralelize group into batches\n+                  WithKeys.of(ThreadLocalRandom.current().nextInt(0, numShards)))\n+              .apply(\"File Batches\", GroupIntoBatches.ofSize(batchSize))\n+              .apply(\n+                  ParDo.of(\n+                      new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)))\n+              .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+\n+      return writeResults\n+          .get(Write.FAILED_BODY)\n+          .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+    }\n+\n+    static class ImportFn\n+        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ResourceId tempDir;\n+      private final ContentStructure contentStructure;\n+      private HealthcareApiClient client;\n+      private final String fhirStore;\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void init() throws IOException {\n+        tempDir =\n+            FileSystems.matchNewResource(tempGcsPath, true)\n+                .resolve(\n+                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                    StandardResolveOptions.RESOLVE_DIRECTORY);\n+        client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+       * GCS URI.\n+       */\n+      @ProcessElement\n+      public void importBatch(ProcessContext context) throws IOException {\n+        Iterable<ResourceId> batch = context.element().getValue();\n+        List<ResourceId> tempDestinations = new ArrayList<>();\n+        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+        assert batch != null;\n+        for (ResourceId file : batch) {\n+          tempDestinations.add(\n+              tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+          deadLetterDestinations.add(\n+              FileSystems.matchNewResource(deadLetterGcsPath, true)\n+                  .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+        }\n+        FileSystems.rename(ImmutableList.copyOf(batch), tempDestinations);\n+        ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n+        try {\n+          // Blocking fhirStores.import request.\n+          assert contentStructure != null;\n+          Operation operation =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7533139cc92d4e50221b4a560937e621c9c21d8a"}, "originalPosition": 770}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0MDEwNQ==", "bodyText": "@pabloem FYI\nYes. it is idempotent.\n\nThe import operation is idempotent unless the input data contains multiple valid resources with the same ID but different contents. In that case, after the import completes, the store contains exactly one resource with each ID, but the duplicate entries could contain any version of the contents. For example, importing a million resources with the same ID writes only one resource to the store.\n\n-FHIR Import Public Docs", "url": "https://github.com/apache/beam/pull/11339#discussion_r423340105", "createdAt": "2020-05-11T21:49:26Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,977 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedInsertsWithErr()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FHIRIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs of Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Of fhir io . read . result.\n+       *\n+       * @param pct the pct\n+       * @return the fhir io . read . result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FhirIO.Read.FetchString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchString extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FhirIO.Read.FetchString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FhirIO.Read.FetchString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FhirIO.Read.FetchString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FhirIO.Read.FetchString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private String fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException {\n+          long startTime = System.currentTimeMillis();\n+\n+          HttpBody resource = client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulStringGets.inc();\n+          return mapper.writeValueAsString(resource);\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<String>> failedInsertsWithErr;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedInserts the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInserts) {\n+        return new Result(pipeline, failedInserts);\n+      }\n+\n+      /**\n+       * Gets failed inserts with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedInsertsWithErr() {\n+        return this.failedInsertsWithErr;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        failedInsertsWithErr.setCoder(new HealthcareIOErrorCoder<String>(StringUtf8Coder.of()));\n+        return ImmutableMap.of(Write.FAILED_BODY, failedInsertsWithErr);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInsertsWithErr) {\n+        this.pipeline = pipeline;\n+        this.failedInsertsWithErr = failedInsertsWithErr;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<String> input) {\n+      PCollection<HealthcareIOError<String>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.warn(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          FhirIO.Import.ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          failedBundles =\n+              input\n+                  .apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure))\n+                  .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+          // fall through\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input.apply(\n+                  \"Execute FHIR Bundles\",\n+                  ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file.\n+   */\n+  public static class Import\n+      extends PTransform<PCollection<String>, PCollection<HealthcareIOError<String>>> {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+    private final int batchSize = 10000;\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> tempGcsPath,\n+        ValueProvider<String> deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore.get();\n+      this.tempGcsPath = tempGcsPath.get();\n+      this.deadLetterGcsPath = deadLetterGcsPath.get();\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    public PCollection<HealthcareIOError<String>> expand(PCollection<String> input) {\n+      // write bundles of String to GCS\n+      PCollectionTuple writeResults =\n+          input.apply(\n+              \"Write nd json to GCS\",\n+              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempGcsPath, deadLetterGcsPath))\n+                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+      int numShards = 100;\n+      PCollection<HealthcareIOError<String>> importResults =\n+          writeResults\n+              .get(Write.TEMP_FILES)\n+              .apply(\n+                  \"Shard files\", // to paralelize group into batches\n+                  WithKeys.of(ThreadLocalRandom.current().nextInt(0, numShards)))\n+              .apply(\"File Batches\", GroupIntoBatches.ofSize(batchSize))\n+              .apply(\n+                  ParDo.of(\n+                      new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)))\n+              .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+\n+      return writeResults\n+          .get(Write.FAILED_BODY)\n+          .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+    }\n+\n+    static class ImportFn\n+        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ResourceId tempDir;\n+      private final ContentStructure contentStructure;\n+      private HealthcareApiClient client;\n+      private final String fhirStore;\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void init() throws IOException {\n+        tempDir =\n+            FileSystems.matchNewResource(tempGcsPath, true)\n+                .resolve(\n+                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                    StandardResolveOptions.RESOLVE_DIRECTORY);\n+        client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+       * GCS URI.\n+       */\n+      @ProcessElement\n+      public void importBatch(ProcessContext context) throws IOException {\n+        Iterable<ResourceId> batch = context.element().getValue();\n+        List<ResourceId> tempDestinations = new ArrayList<>();\n+        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+        assert batch != null;\n+        for (ResourceId file : batch) {\n+          tempDestinations.add(\n+              tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+          deadLetterDestinations.add(\n+              FileSystems.matchNewResource(deadLetterGcsPath, true)\n+                  .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+        }\n+        FileSystems.rename(ImmutableList.copyOf(batch), tempDestinations);\n+        ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n+        try {\n+          // Blocking fhirStores.import request.\n+          assert contentStructure != null;\n+          Operation operation =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwNDg3NQ=="}, "originalCommit": {"oid": "7533139cc92d4e50221b4a560937e621c9c21d8a"}, "originalPosition": 770}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzAyMTg0OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMTowNTowOVrOGQ7iOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwMzowODoxNlrOGT0dYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwNTgxOQ==", "bodyText": "what happens if this gets rescheduled.", "url": "https://github.com/apache/beam/pull/11339#discussion_r420405819", "createdAt": "2020-05-05T21:05:09Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,977 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedInsertsWithErr()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FHIRIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs of Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Of fhir io . read . result.\n+       *\n+       * @param pct the pct\n+       * @return the fhir io . read . result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FhirIO.Read.FetchString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchString extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FhirIO.Read.FetchString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FhirIO.Read.FetchString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FhirIO.Read.FetchString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FhirIO.Read.FetchString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private String fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException {\n+          long startTime = System.currentTimeMillis();\n+\n+          HttpBody resource = client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulStringGets.inc();\n+          return mapper.writeValueAsString(resource);\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<String>> failedInsertsWithErr;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedInserts the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInserts) {\n+        return new Result(pipeline, failedInserts);\n+      }\n+\n+      /**\n+       * Gets failed inserts with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedInsertsWithErr() {\n+        return this.failedInsertsWithErr;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        failedInsertsWithErr.setCoder(new HealthcareIOErrorCoder<String>(StringUtf8Coder.of()));\n+        return ImmutableMap.of(Write.FAILED_BODY, failedInsertsWithErr);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInsertsWithErr) {\n+        this.pipeline = pipeline;\n+        this.failedInsertsWithErr = failedInsertsWithErr;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<String> input) {\n+      PCollection<HealthcareIOError<String>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.warn(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          FhirIO.Import.ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          failedBundles =\n+              input\n+                  .apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure))\n+                  .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+          // fall through\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input.apply(\n+                  \"Execute FHIR Bundles\",\n+                  ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file.\n+   */\n+  public static class Import\n+      extends PTransform<PCollection<String>, PCollection<HealthcareIOError<String>>> {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+    private final int batchSize = 10000;\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> tempGcsPath,\n+        ValueProvider<String> deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore.get();\n+      this.tempGcsPath = tempGcsPath.get();\n+      this.deadLetterGcsPath = deadLetterGcsPath.get();\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    public PCollection<HealthcareIOError<String>> expand(PCollection<String> input) {\n+      // write bundles of String to GCS\n+      PCollectionTuple writeResults =\n+          input.apply(\n+              \"Write nd json to GCS\",\n+              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempGcsPath, deadLetterGcsPath))\n+                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+      int numShards = 100;\n+      PCollection<HealthcareIOError<String>> importResults =\n+          writeResults\n+              .get(Write.TEMP_FILES)\n+              .apply(\n+                  \"Shard files\", // to paralelize group into batches\n+                  WithKeys.of(ThreadLocalRandom.current().nextInt(0, numShards)))\n+              .apply(\"File Batches\", GroupIntoBatches.ofSize(batchSize))\n+              .apply(\n+                  ParDo.of(\n+                      new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)))\n+              .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+\n+      return writeResults\n+          .get(Write.FAILED_BODY)\n+          .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+    }\n+\n+    static class ImportFn\n+        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ResourceId tempDir;\n+      private final ContentStructure contentStructure;\n+      private HealthcareApiClient client;\n+      private final String fhirStore;\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void init() throws IOException {\n+        tempDir =\n+            FileSystems.matchNewResource(tempGcsPath, true)\n+                .resolve(\n+                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                    StandardResolveOptions.RESOLVE_DIRECTORY);\n+        client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+       * GCS URI.\n+       */\n+      @ProcessElement\n+      public void importBatch(ProcessContext context) throws IOException {\n+        Iterable<ResourceId> batch = context.element().getValue();\n+        List<ResourceId> tempDestinations = new ArrayList<>();\n+        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+        assert batch != null;\n+        for (ResourceId file : batch) {\n+          tempDestinations.add(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7533139cc92d4e50221b4a560937e621c9c21d8a"}, "originalPosition": 759}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0Njk2Ng==", "bodyText": "The steps of ImportFn are:\n\nmove files for this batch import call to a temp prefix (in order to capture with a single wildcard for the import API call) with a UUID\nMake and FHIR Import call\nPoll/block until this operation completes.\nClean up temp files\n\nThe FHIR import operation should be idempotent (see comment below).", "url": "https://github.com/apache/beam/pull/11339#discussion_r423346966", "createdAt": "2020-05-11T22:05:28Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,977 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedInsertsWithErr()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FHIRIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs of Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Of fhir io . read . result.\n+       *\n+       * @param pct the pct\n+       * @return the fhir io . read . result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FhirIO.Read.FetchString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchString extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FhirIO.Read.FetchString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FhirIO.Read.FetchString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FhirIO.Read.FetchString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FhirIO.Read.FetchString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private String fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException {\n+          long startTime = System.currentTimeMillis();\n+\n+          HttpBody resource = client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulStringGets.inc();\n+          return mapper.writeValueAsString(resource);\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<String>> failedInsertsWithErr;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedInserts the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInserts) {\n+        return new Result(pipeline, failedInserts);\n+      }\n+\n+      /**\n+       * Gets failed inserts with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedInsertsWithErr() {\n+        return this.failedInsertsWithErr;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        failedInsertsWithErr.setCoder(new HealthcareIOErrorCoder<String>(StringUtf8Coder.of()));\n+        return ImmutableMap.of(Write.FAILED_BODY, failedInsertsWithErr);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInsertsWithErr) {\n+        this.pipeline = pipeline;\n+        this.failedInsertsWithErr = failedInsertsWithErr;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<String> input) {\n+      PCollection<HealthcareIOError<String>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.warn(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          FhirIO.Import.ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          failedBundles =\n+              input\n+                  .apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure))\n+                  .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+          // fall through\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input.apply(\n+                  \"Execute FHIR Bundles\",\n+                  ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file.\n+   */\n+  public static class Import\n+      extends PTransform<PCollection<String>, PCollection<HealthcareIOError<String>>> {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+    private final int batchSize = 10000;\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> tempGcsPath,\n+        ValueProvider<String> deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore.get();\n+      this.tempGcsPath = tempGcsPath.get();\n+      this.deadLetterGcsPath = deadLetterGcsPath.get();\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    public PCollection<HealthcareIOError<String>> expand(PCollection<String> input) {\n+      // write bundles of String to GCS\n+      PCollectionTuple writeResults =\n+          input.apply(\n+              \"Write nd json to GCS\",\n+              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempGcsPath, deadLetterGcsPath))\n+                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+      int numShards = 100;\n+      PCollection<HealthcareIOError<String>> importResults =\n+          writeResults\n+              .get(Write.TEMP_FILES)\n+              .apply(\n+                  \"Shard files\", // to paralelize group into batches\n+                  WithKeys.of(ThreadLocalRandom.current().nextInt(0, numShards)))\n+              .apply(\"File Batches\", GroupIntoBatches.ofSize(batchSize))\n+              .apply(\n+                  ParDo.of(\n+                      new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)))\n+              .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+\n+      return writeResults\n+          .get(Write.FAILED_BODY)\n+          .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+    }\n+\n+    static class ImportFn\n+        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ResourceId tempDir;\n+      private final ContentStructure contentStructure;\n+      private HealthcareApiClient client;\n+      private final String fhirStore;\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void init() throws IOException {\n+        tempDir =\n+            FileSystems.matchNewResource(tempGcsPath, true)\n+                .resolve(\n+                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                    StandardResolveOptions.RESOLVE_DIRECTORY);\n+        client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+       * GCS URI.\n+       */\n+      @ProcessElement\n+      public void importBatch(ProcessContext context) throws IOException {\n+        Iterable<ResourceId> batch = context.element().getValue();\n+        List<ResourceId> tempDestinations = new ArrayList<>();\n+        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+        assert batch != null;\n+        for (ResourceId file : batch) {\n+          tempDestinations.add(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwNTgxOQ=="}, "originalCommit": {"oid": "7533139cc92d4e50221b4a560937e621c9c21d8a"}, "originalPosition": 759}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NzAwNw==", "bodyText": "Let's consider what happens if the process get killed / rescheduled between each of these setps\n\n\n\nwhen?\nGCS\nFHIR Store\nNotes\n\n\n\n\n(1) -> (1) between non-atomic object moves on GCS\nsome objects moved to a tmp-UUID prefix.\nNo FHIR Import Job Attempted\nwhen rescheduled, will try to import the subset of objects that were NOT moved. This is a very confusing state.\n\n\n(1) -> (2)\nobjects moved to a tmp-UUID prefix.\nNo FHIR Import Job Attempted\nwhen rescheduled we'll fail because  the original URIs don't exist.\n\n\n(2) -> (3)\nobjects moved to a tmp-UUID prefix\nan in-flight FHIR Import job that beam has lost track of. We could safely re-do this import job without consequence as it is idempotent.\nHowever, a rescheduled attempt will fail as the original object URIs now will not exist because they've been \"claimed\" by being moved to the temp dir.\n\n\n(3) -> (3) aka killed between polling calls:\nIn some cases where InterruptedException is thrown we will move the objects in questions to the dead letter path.\nin-flight FHIR Import job may or may not succeed.\nPotential for low consequence false negative: If user re-runs import from DLQ should be fine due to idempontency. But this could be wasteful if the original job in-fact succeeds\n\n\n(3) -> (4):\ntmp-UUID dir will not be cleaned up properly\nFHIR Import Job succeeded\nThis is not a critical failure but inconvenient and will incur storage costs.", "url": "https://github.com/apache/beam/pull/11339#discussion_r423357007", "createdAt": "2020-05-11T22:30:41Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,977 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedInsertsWithErr()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FHIRIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs of Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Of fhir io . read . result.\n+       *\n+       * @param pct the pct\n+       * @return the fhir io . read . result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FhirIO.Read.FetchString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchString extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FhirIO.Read.FetchString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FhirIO.Read.FetchString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FhirIO.Read.FetchString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FhirIO.Read.FetchString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private String fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException {\n+          long startTime = System.currentTimeMillis();\n+\n+          HttpBody resource = client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulStringGets.inc();\n+          return mapper.writeValueAsString(resource);\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<String>> failedInsertsWithErr;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedInserts the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInserts) {\n+        return new Result(pipeline, failedInserts);\n+      }\n+\n+      /**\n+       * Gets failed inserts with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedInsertsWithErr() {\n+        return this.failedInsertsWithErr;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        failedInsertsWithErr.setCoder(new HealthcareIOErrorCoder<String>(StringUtf8Coder.of()));\n+        return ImmutableMap.of(Write.FAILED_BODY, failedInsertsWithErr);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInsertsWithErr) {\n+        this.pipeline = pipeline;\n+        this.failedInsertsWithErr = failedInsertsWithErr;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<String> input) {\n+      PCollection<HealthcareIOError<String>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.warn(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          FhirIO.Import.ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          failedBundles =\n+              input\n+                  .apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure))\n+                  .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+          // fall through\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input.apply(\n+                  \"Execute FHIR Bundles\",\n+                  ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file.\n+   */\n+  public static class Import\n+      extends PTransform<PCollection<String>, PCollection<HealthcareIOError<String>>> {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+    private final int batchSize = 10000;\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> tempGcsPath,\n+        ValueProvider<String> deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore.get();\n+      this.tempGcsPath = tempGcsPath.get();\n+      this.deadLetterGcsPath = deadLetterGcsPath.get();\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    public PCollection<HealthcareIOError<String>> expand(PCollection<String> input) {\n+      // write bundles of String to GCS\n+      PCollectionTuple writeResults =\n+          input.apply(\n+              \"Write nd json to GCS\",\n+              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempGcsPath, deadLetterGcsPath))\n+                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+      int numShards = 100;\n+      PCollection<HealthcareIOError<String>> importResults =\n+          writeResults\n+              .get(Write.TEMP_FILES)\n+              .apply(\n+                  \"Shard files\", // to paralelize group into batches\n+                  WithKeys.of(ThreadLocalRandom.current().nextInt(0, numShards)))\n+              .apply(\"File Batches\", GroupIntoBatches.ofSize(batchSize))\n+              .apply(\n+                  ParDo.of(\n+                      new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)))\n+              .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+\n+      return writeResults\n+          .get(Write.FAILED_BODY)\n+          .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+    }\n+\n+    static class ImportFn\n+        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ResourceId tempDir;\n+      private final ContentStructure contentStructure;\n+      private HealthcareApiClient client;\n+      private final String fhirStore;\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void init() throws IOException {\n+        tempDir =\n+            FileSystems.matchNewResource(tempGcsPath, true)\n+                .resolve(\n+                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                    StandardResolveOptions.RESOLVE_DIRECTORY);\n+        client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+       * GCS URI.\n+       */\n+      @ProcessElement\n+      public void importBatch(ProcessContext context) throws IOException {\n+        Iterable<ResourceId> batch = context.element().getValue();\n+        List<ResourceId> tempDestinations = new ArrayList<>();\n+        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+        assert batch != null;\n+        for (ResourceId file : batch) {\n+          tempDestinations.add(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwNTgxOQ=="}, "originalCommit": {"oid": "7533139cc92d4e50221b4a560937e621c9c21d8a"}, "originalPosition": 759}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM2Mjg1Mg==", "bodyText": "All critical failure scenarios can be addressed if we copy originally written files instead of renaming/moving them and update clean up logic to handle this.\nThere still may be issues of phantom temp dirs if the task is killed / rescheduled.", "url": "https://github.com/apache/beam/pull/11339#discussion_r423362852", "createdAt": "2020-05-11T22:46:56Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,977 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedInsertsWithErr()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FHIRIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs of Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Of fhir io . read . result.\n+       *\n+       * @param pct the pct\n+       * @return the fhir io . read . result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FhirIO.Read.FetchString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchString extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FhirIO.Read.FetchString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FhirIO.Read.FetchString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FhirIO.Read.FetchString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FhirIO.Read.FetchString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private String fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException {\n+          long startTime = System.currentTimeMillis();\n+\n+          HttpBody resource = client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulStringGets.inc();\n+          return mapper.writeValueAsString(resource);\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<String>> failedInsertsWithErr;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedInserts the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInserts) {\n+        return new Result(pipeline, failedInserts);\n+      }\n+\n+      /**\n+       * Gets failed inserts with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedInsertsWithErr() {\n+        return this.failedInsertsWithErr;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        failedInsertsWithErr.setCoder(new HealthcareIOErrorCoder<String>(StringUtf8Coder.of()));\n+        return ImmutableMap.of(Write.FAILED_BODY, failedInsertsWithErr);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInsertsWithErr) {\n+        this.pipeline = pipeline;\n+        this.failedInsertsWithErr = failedInsertsWithErr;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<String> input) {\n+      PCollection<HealthcareIOError<String>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.warn(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          FhirIO.Import.ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          failedBundles =\n+              input\n+                  .apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure))\n+                  .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+          // fall through\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input.apply(\n+                  \"Execute FHIR Bundles\",\n+                  ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file.\n+   */\n+  public static class Import\n+      extends PTransform<PCollection<String>, PCollection<HealthcareIOError<String>>> {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+    private final int batchSize = 10000;\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> tempGcsPath,\n+        ValueProvider<String> deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore.get();\n+      this.tempGcsPath = tempGcsPath.get();\n+      this.deadLetterGcsPath = deadLetterGcsPath.get();\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    public PCollection<HealthcareIOError<String>> expand(PCollection<String> input) {\n+      // write bundles of String to GCS\n+      PCollectionTuple writeResults =\n+          input.apply(\n+              \"Write nd json to GCS\",\n+              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempGcsPath, deadLetterGcsPath))\n+                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+      int numShards = 100;\n+      PCollection<HealthcareIOError<String>> importResults =\n+          writeResults\n+              .get(Write.TEMP_FILES)\n+              .apply(\n+                  \"Shard files\", // to paralelize group into batches\n+                  WithKeys.of(ThreadLocalRandom.current().nextInt(0, numShards)))\n+              .apply(\"File Batches\", GroupIntoBatches.ofSize(batchSize))\n+              .apply(\n+                  ParDo.of(\n+                      new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)))\n+              .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+\n+      return writeResults\n+          .get(Write.FAILED_BODY)\n+          .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+    }\n+\n+    static class ImportFn\n+        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ResourceId tempDir;\n+      private final ContentStructure contentStructure;\n+      private HealthcareApiClient client;\n+      private final String fhirStore;\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void init() throws IOException {\n+        tempDir =\n+            FileSystems.matchNewResource(tempGcsPath, true)\n+                .resolve(\n+                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                    StandardResolveOptions.RESOLVE_DIRECTORY);\n+        client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+       * GCS URI.\n+       */\n+      @ProcessElement\n+      public void importBatch(ProcessContext context) throws IOException {\n+        Iterable<ResourceId> batch = context.element().getValue();\n+        List<ResourceId> tempDestinations = new ArrayList<>();\n+        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+        assert batch != null;\n+        for (ResourceId file : batch) {\n+          tempDestinations.add(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwNTgxOQ=="}, "originalCommit": {"oid": "7533139cc92d4e50221b4a560937e621c9c21d8a"}, "originalPosition": 759}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQzNTYxNg==", "bodyText": "In 5540277 Refactored FhirIO.Import to:\n\ncopy (instead of rename) files to temp dirs.\ndelete everything from gcsTempDir once window has closed.\n\nThis addresses all issues in above table except being killed between polling calls.\nTo mitigate this we could split into a ImportFn that is responsible only for starting Import jobs and  outputs KV of Operation IDs and temp dirs and BlockTilDoneFn which handles blocking and clean up.\n@pabloem thoughts on a cleaner way to do this?", "url": "https://github.com/apache/beam/pull/11339#discussion_r423435616", "createdAt": "2020-05-12T03:08:16Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,977 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedInsertsWithErr()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FHIRIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs of Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Of fhir io . read . result.\n+       *\n+       * @param pct the pct\n+       * @return the fhir io . read . result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FhirIO.Read.FetchString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchString extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FhirIO.Read.FetchString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FhirIO.Read.FetchString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FhirIO.Read.FetchString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FhirIO.Read.FetchString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private String fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException {\n+          long startTime = System.currentTimeMillis();\n+\n+          HttpBody resource = client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulStringGets.inc();\n+          return mapper.writeValueAsString(resource);\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<String>> failedInsertsWithErr;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedInserts the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInserts) {\n+        return new Result(pipeline, failedInserts);\n+      }\n+\n+      /**\n+       * Gets failed inserts with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedInsertsWithErr() {\n+        return this.failedInsertsWithErr;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        failedInsertsWithErr.setCoder(new HealthcareIOErrorCoder<String>(StringUtf8Coder.of()));\n+        return ImmutableMap.of(Write.FAILED_BODY, failedInsertsWithErr);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline, PCollection<HealthcareIOError<String>> failedInsertsWithErr) {\n+        this.pipeline = pipeline;\n+        this.failedInsertsWithErr = failedInsertsWithErr;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<String> input) {\n+      PCollection<HealthcareIOError<String>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.warn(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          FhirIO.Import.ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          failedBundles =\n+              input\n+                  .apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure))\n+                  .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+          // fall through\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input.apply(\n+                  \"Execute FHIR Bundles\",\n+                  ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file.\n+   */\n+  public static class Import\n+      extends PTransform<PCollection<String>, PCollection<HealthcareIOError<String>>> {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+    private final int batchSize = 10000;\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> tempGcsPath,\n+        ValueProvider<String> deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore.get();\n+      this.tempGcsPath = tempGcsPath.get();\n+      this.deadLetterGcsPath = deadLetterGcsPath.get();\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    public PCollection<HealthcareIOError<String>> expand(PCollection<String> input) {\n+      // write bundles of String to GCS\n+      PCollectionTuple writeResults =\n+          input.apply(\n+              \"Write nd json to GCS\",\n+              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempGcsPath, deadLetterGcsPath))\n+                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+      int numShards = 100;\n+      PCollection<HealthcareIOError<String>> importResults =\n+          writeResults\n+              .get(Write.TEMP_FILES)\n+              .apply(\n+                  \"Shard files\", // to paralelize group into batches\n+                  WithKeys.of(ThreadLocalRandom.current().nextInt(0, numShards)))\n+              .apply(\"File Batches\", GroupIntoBatches.ofSize(batchSize))\n+              .apply(\n+                  ParDo.of(\n+                      new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)))\n+              .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+\n+      return writeResults\n+          .get(Write.FAILED_BODY)\n+          .setCoder(new HealthcareIOErrorCoder<>(StringUtf8Coder.of()));\n+    }\n+\n+    static class ImportFn\n+        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ResourceId tempDir;\n+      private final ContentStructure contentStructure;\n+      private HealthcareApiClient client;\n+      private final String fhirStore;\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void init() throws IOException {\n+        tempDir =\n+            FileSystems.matchNewResource(tempGcsPath, true)\n+                .resolve(\n+                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                    StandardResolveOptions.RESOLVE_DIRECTORY);\n+        client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+       * GCS URI.\n+       */\n+      @ProcessElement\n+      public void importBatch(ProcessContext context) throws IOException {\n+        Iterable<ResourceId> batch = context.element().getValue();\n+        List<ResourceId> tempDestinations = new ArrayList<>();\n+        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+        assert batch != null;\n+        for (ResourceId file : batch) {\n+          tempDestinations.add(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwNTgxOQ=="}, "originalCommit": {"oid": "7533139cc92d4e50221b4a560937e621c9c21d8a"}, "originalPosition": 759}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDUzOTg2OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2MessageCoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDo1MzoyMlrOGUYiWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDo1MzoyMlrOGUYiWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyNjcxMw==", "bodyText": "How come you're taking an input class coder and ignoring it?", "url": "https://github.com/apache/beam/pull/11339#discussion_r424026713", "createdAt": "2020-05-12T20:53:22Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2MessageCoder.java", "diffHunk": "@@ -29,7 +29,15 @@\n import org.apache.beam.sdk.coders.StringUtf8Coder;\n \n public class HL7v2MessageCoder extends CustomCoder<HL7v2Message> {\n-  public HL7v2MessageCoder() {}\n+  HL7v2MessageCoder() {}\n+\n+  public static HL7v2MessageCoder of() {\n+    return new HL7v2MessageCoder();\n+  }\n+\n+  public static HL7v2MessageCoder of(Class<HL7v2Message> clazz) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDU5MDQ4OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMTowODo1N1rOGUZCZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMTowODo1N1rOGUZCZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAzNDkxOQ==", "bodyText": "Also add a line item about FhirIO to CHANGES.md in the root of apache/beam", "url": "https://github.com/apache/beam/pull/11339#discussion_r424034919", "createdAt": "2020-05-12T21:08:57Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDU5NTU4OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToxMDozOVrOGUZFvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToxMDozOVrOGUZFvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAzNTc3Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * <p>Read\n          \n          \n            \n             * <h3>Reading</h3>", "url": "https://github.com/apache/beam/pull/11339#discussion_r424035772", "createdAt": "2020-05-12T21:10:39Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDYwMDAzOnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToxMTo1N1rOGUZIaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToxMTo1N1rOGUZIaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAzNjQ1Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n          \n          \n            \n             * <p>FHIR resources can be read with {@link FhirIO.Read}, which supports use cases where you have a", "url": "https://github.com/apache/beam/pull/11339#discussion_r424036456", "createdAt": "2020-05-12T21:11:57Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDYwMzMwOnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToxMjo1OFrOGUZKag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToxMjo1OFrOGUZKag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAzNjk3MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n          \n          \n            \n             * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieve a", "url": "https://github.com/apache/beam/pull/11339#discussion_r424036970", "createdAt": "2020-05-12T21:12:58Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDYwNTAyOnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToxMzoyOFrOGUZLgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToxMzoyOFrOGUZLgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAzNzI0OA==", "bodyText": "Perhaps add an <h3>Writing</h3> header", "url": "https://github.com/apache/beam/pull/11339#discussion_r424037248", "createdAt": "2020-05-12T21:13:28Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDYxMDc1OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToxNToyNVrOGUZPHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMTo1Njo1NVrOGUaaRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAzODE3Mg==", "bodyText": "Aren't these meant to be HealthcareIOMessage types?", "url": "https://github.com/apache/beam/pull/11339#discussion_r424038172", "createdAt": "2020-05-12T21:15:25Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedBodies()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FhirIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA1NzQxMw==", "bodyText": "Sorry for the confusion.\nWe used to pass resources around as HttpBody but we only ever use the String data field so we refactored to just pass around as strings.\nThis eliminated the need for a HttpBodyCoder which had proven to be problematic.\nIf you call readResult.getFailedReads() you will get PCollection which is effectively a DLQ to handle if you were trying to read a resource ID that doesn't exist (or some similar error).", "url": "https://github.com/apache/beam/pull/11339#discussion_r424057413", "createdAt": "2020-05-12T21:56:55Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedBodies()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FhirIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAzODE3Mg=="}, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDYxNDUwOnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToxNjo0MVrOGUZRig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToxNjo0MVrOGUZRig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAzODc5NA==", "bodyText": "Perhaps also add code samples for doing an import?", "url": "https://github.com/apache/beam/pull/11339#discussion_r424038794", "createdAt": "2020-05-12T21:16:41Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedBodies()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FhirIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs / Stacktrace for Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDYyNDU2OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToyMDoxNlrOGUZYAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMTo1NzozMVrOGUabTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0MDQ1MA==", "bodyText": "You may be able to make tempDir optional by using the tempLocation pipeline option internally. You can leave this for later, as it would be a backwards-compatible change to add a new factory method. But I recommend you do do this eventually, as it's nice for users to simply forget about the temporary directories.", "url": "https://github.com/apache/beam/pull/11339#discussion_r424040450", "createdAt": "2020-05-12T21:20:16Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedBodies()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FhirIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs / Stacktrace for Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA1NzY3OQ==", "bodyText": "Great suggestion! this should be easy to add!", "url": "https://github.com/apache/beam/pull/11339#discussion_r424057679", "createdAt": "2020-05-12T21:57:31Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedBodies()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FhirIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs / Stacktrace for Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0MDQ1MA=="}, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDYyNzk4OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToyMToyN1rOGUZaNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToyMToyN1rOGUZaNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0MTAxMw==", "bodyText": "does this need to be public?", "url": "https://github.com/apache/beam/pull/11339#discussion_r424041013", "createdAt": "2020-05-12T21:21:27Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedBodies()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FhirIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs / Stacktrace for Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+       *\n+       * @param pct the pct\n+       * @return the read result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 230}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDY0ODA2OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToyODoxNlrOGUZm8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoxNzo1MVrOGVCAqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0NDI3NQ==", "bodyText": "this function makes RPCs to an external service one-by-one. This will be slow. It may be worth buffering these requests, and applying them with a thread pool. You can add this optimization later on, though.", "url": "https://github.com/apache/beam/pull/11339#discussion_r424044275", "createdAt": "2020-05-12T21:28:16Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedBodies()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FhirIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs / Stacktrace for Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+       *\n+       * @param pct the pct\n+       * @return the read result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchResourceJsonString\n+        extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchResourceJsonString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FetchResourceJsonString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FetchResourceJsonString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FetchResourceJsonString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FetchResourceJsonString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 361}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2MTQ1Nw==", "bodyText": "The Fhir.read api doesn't support requesting several resources in a single call.\nWe could look into Fhir.search to request all resources with IDs in a list.", "url": "https://github.com/apache/beam/pull/11339#discussion_r424061457", "createdAt": "2020-05-12T22:06:14Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedBodies()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FhirIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs / Stacktrace for Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+       *\n+       * @param pct the pct\n+       * @return the read result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchResourceJsonString\n+        extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchResourceJsonString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FetchResourceJsonString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FetchResourceJsonString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FetchResourceJsonString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FetchResourceJsonString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0NDI3NQ=="}, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 361}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwNjIxOA==", "bodyText": "You could perform multiple Fhir.read requests from separate threads? This may be fine for now, though, and if you find that the extra optimization will help, then add it later on?", "url": "https://github.com/apache/beam/pull/11339#discussion_r424706218", "createdAt": "2020-05-13T20:17:51Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedBodies()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FhirIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs / Stacktrace for Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+       *\n+       * @param pct the pct\n+       * @return the read result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchResourceJsonString\n+        extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchResourceJsonString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FetchResourceJsonString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FetchResourceJsonString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FetchResourceJsonString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FetchResourceJsonString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0NDI3NQ=="}, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 361}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDY0ODQzOnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToyODoyNVrOGUZnKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToyODoyNVrOGUZnKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0NDMzMQ==", "bodyText": "This may not need to be public?", "url": "https://github.com/apache/beam/pull/11339#discussion_r424044331", "createdAt": "2020-05-12T21:28:25Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedBodies()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FhirIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs / Stacktrace for Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+       *\n+       * @param pct the pct\n+       * @return the read result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchResourceJsonString\n+        extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchResourceJsonString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FetchResourceJsonString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 326}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDY1MTE1OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToyOToyOVrOGUZpAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToyOToyOVrOGUZpAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0NDgwMw==", "bodyText": "May not need to be public?", "url": "https://github.com/apache/beam/pull/11339#discussion_r424044803", "createdAt": "2020-05-12T21:29:29Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedBodies()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FhirIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs / Stacktrace for Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+       *\n+       * @param pct the pct\n+       * @return the read result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchResourceJsonString", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 311}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDY2MjcyOnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMTozMzo1M1rOGUZwqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMTozMzo1M1rOGUZwqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0Njc2MA==", "bodyText": "as mentioned before, you may be able to have a constructor without gcsTempPath", "url": "https://github.com/apache/beam/pull/11339#discussion_r424046760", "createdAt": "2020-05-12T21:33:53Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedBodies()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FhirIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs / Stacktrace for Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+       *\n+       * @param pct the pct\n+       * @return the read result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchResourceJsonString\n+        extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchResourceJsonString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FetchResourceJsonString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FetchResourceJsonString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FetchResourceJsonString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FetchResourceJsonString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private String fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException {\n+          long startTime = System.currentTimeMillis();\n+\n+          HttpBody resource = client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulStringGets.inc();\n+          return mapper.writeValueAsString(resource);\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<String>> failedBodies;\n+      private final PCollection<HealthcareIOError<String>> failedFiles;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedBodies the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedBodies) {\n+        return new Result(pipeline, failedBodies, null);\n+      }\n+\n+      static Result in(\n+          Pipeline pipeline,\n+          PCollection<HealthcareIOError<String>> failedBodies,\n+          PCollection<HealthcareIOError<String>> failedFiles) {\n+        return new Result(pipeline, failedBodies, failedFiles);\n+      }\n+\n+      /**\n+       * Gets failed bodies with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedBodies() {\n+        return this.failedBodies;\n+      }\n+\n+      /**\n+       * Gets failed file imports with err.\n+       *\n+       * @return the failed GCS uri with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedFiles() {\n+        return this.failedFiles;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(Write.FAILED_BODY, failedBodies, Write.FAILED_FILES, failedFiles);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline,\n+          PCollection<HealthcareIOError<String>> failedBodies,\n+          @Nullable PCollection<HealthcareIOError<String>> failedFiles) {\n+        this.pipeline = pipeline;\n+        this.failedBodies = failedBodies;\n+        if (failedFiles == null) {\n+          failedFiles =\n+              (PCollection<HealthcareIOError<String>>)\n+                  pipeline.apply(Create.empty(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+        }\n+        this.failedFiles = failedFiles;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    public static Write fhirStoresImport(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> gcsTempPath,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 605}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDY2NjM0OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMTozNToxM1rOGUZy-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMTozNToxM1rOGUZy-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0NzM1NA==", "bodyText": "A warning may work here. Up to you, though. sorry about the back-and-forth.  : )", "url": "https://github.com/apache/beam/pull/11339#discussion_r424047354", "createdAt": "2020-05-12T21:35:13Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedBodies()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FhirIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs / Stacktrace for Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+       *\n+       * @param pct the pct\n+       * @return the read result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchResourceJsonString\n+        extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchResourceJsonString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FetchResourceJsonString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FetchResourceJsonString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FetchResourceJsonString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FetchResourceJsonString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private String fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException {\n+          long startTime = System.currentTimeMillis();\n+\n+          HttpBody resource = client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulStringGets.inc();\n+          return mapper.writeValueAsString(resource);\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<String>> failedBodies;\n+      private final PCollection<HealthcareIOError<String>> failedFiles;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedBodies the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedBodies) {\n+        return new Result(pipeline, failedBodies, null);\n+      }\n+\n+      static Result in(\n+          Pipeline pipeline,\n+          PCollection<HealthcareIOError<String>> failedBodies,\n+          PCollection<HealthcareIOError<String>> failedFiles) {\n+        return new Result(pipeline, failedBodies, failedFiles);\n+      }\n+\n+      /**\n+       * Gets failed bodies with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedBodies() {\n+        return this.failedBodies;\n+      }\n+\n+      /**\n+       * Gets failed file imports with err.\n+       *\n+       * @return the failed GCS uri with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedFiles() {\n+        return this.failedFiles;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(Write.FAILED_BODY, failedBodies, Write.FAILED_FILES, failedFiles);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline,\n+          PCollection<HealthcareIOError<String>> failedBodies,\n+          @Nullable PCollection<HealthcareIOError<String>> failedFiles) {\n+        this.pipeline = pipeline;\n+        this.failedBodies = failedBodies;\n+        if (failedFiles == null) {\n+          failedFiles =\n+              (PCollection<HealthcareIOError<String>>)\n+                  pipeline.apply(Create.empty(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+        }\n+        this.failedFiles = failedFiles;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    public static Write fhirStoresImport(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> gcsTempPath,\n+        ValueProvider<String> gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath.get())\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath.get())\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<String> input) {\n+      PCollection<HealthcareIOError<String>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.info(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 652}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDY2ODQ1OnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMTozNjowMFrOGUZ0Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMTozNjowMFrOGUZ0Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0NzY4Mw==", "bodyText": "TODO(@pabloem) take a look at this function", "url": "https://github.com/apache/beam/pull/11339#discussion_r424047683", "createdAt": "2020-05-12T21:36:00Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedBodies()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FhirIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs / Stacktrace for Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+       *\n+       * @param pct the pct\n+       * @return the read result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchResourceJsonString\n+        extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchResourceJsonString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FetchResourceJsonString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FetchResourceJsonString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FetchResourceJsonString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FetchResourceJsonString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private String fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException {\n+          long startTime = System.currentTimeMillis();\n+\n+          HttpBody resource = client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulStringGets.inc();\n+          return mapper.writeValueAsString(resource);\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<String>> failedBodies;\n+      private final PCollection<HealthcareIOError<String>> failedFiles;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedBodies the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedBodies) {\n+        return new Result(pipeline, failedBodies, null);\n+      }\n+\n+      static Result in(\n+          Pipeline pipeline,\n+          PCollection<HealthcareIOError<String>> failedBodies,\n+          PCollection<HealthcareIOError<String>> failedFiles) {\n+        return new Result(pipeline, failedBodies, failedFiles);\n+      }\n+\n+      /**\n+       * Gets failed bodies with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedBodies() {\n+        return this.failedBodies;\n+      }\n+\n+      /**\n+       * Gets failed file imports with err.\n+       *\n+       * @return the failed GCS uri with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedFiles() {\n+        return this.failedFiles;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(Write.FAILED_BODY, failedBodies, Write.FAILED_FILES, failedFiles);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline,\n+          PCollection<HealthcareIOError<String>> failedBodies,\n+          @Nullable PCollection<HealthcareIOError<String>> failedFiles) {\n+        this.pipeline = pipeline;\n+        this.failedBodies = failedBodies;\n+        if (failedFiles == null) {\n+          failedFiles =\n+              (PCollection<HealthcareIOError<String>>)\n+                  pipeline.apply(Create.empty(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+        }\n+        this.failedFiles = failedFiles;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    public static Write fhirStoresImport(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> gcsTempPath,\n+        ValueProvider<String> gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath.get())\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath.get())\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<String> input) {\n+      PCollection<HealthcareIOError<String>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.info(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          FhirIO.Import.ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          return input.apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure));\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input\n+                  .apply(\n+                      \"Execute FHIR Bundles\",\n+                      ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())))\n+                  .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file. This is intended for batch use only to facilitate\n+   * large backfills to empty FHIR stores and should not be used with unbounded PCollections. If\n+   * your use case is streaming checkout using {@link ExecuteBundles} to more safely execute bundles\n+   * as transactions which is safer practice for a use on a \"live\" FHIR store.\n+   */\n+  public static class Import extends Write {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+    private static final int DEFAULT_FILES_PER_BATCH = 10000;\n+    private static final Logger LOG = LoggerFactory.getLogger(Import.class);\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> tempGcsPath,\n+        ValueProvider<String> deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore.get();\n+      this.tempGcsPath = tempGcsPath.get();\n+      this.deadLetterGcsPath = deadLetterGcsPath.get();\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    String getFhirStore() {\n+      return fhirStore;\n+    }\n+\n+    @Override\n+    WriteMethod getWriteMethod() {\n+      return WriteMethod.IMPORT;\n+    }\n+\n+    @Override\n+    Optional<ContentStructure> getContentStructure() {\n+      return Optional.of(contentStructure);\n+    }\n+\n+    @Override\n+    Optional<String> getImportGcsTempPath() {\n+      return Optional.of(tempGcsPath);\n+    }\n+\n+    @Override\n+    Optional<String> getImportGcsDeadLetterPath() {\n+      return Optional.of(deadLetterGcsPath);\n+    }\n+\n+    @Override\n+    public Write.Result expand(PCollection<String> input) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 762}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDY3MzkwOnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMTozNzo1NVrOGUZ3iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoxODoxMFrOGVCBWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0ODUyMw==", "bodyText": "This is executing a single RPC per element, right? This will likely be slow, and lead to underutilization of worker resources. As a follow up, messages could be buffered, and RPCs issued via a thread pool", "url": "https://github.com/apache/beam/pull/11339#discussion_r424048523", "createdAt": "2020-05-12T21:37:55Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedBodies()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FhirIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs / Stacktrace for Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+       *\n+       * @param pct the pct\n+       * @return the read result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchResourceJsonString\n+        extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchResourceJsonString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FetchResourceJsonString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FetchResourceJsonString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FetchResourceJsonString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FetchResourceJsonString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private String fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException {\n+          long startTime = System.currentTimeMillis();\n+\n+          HttpBody resource = client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulStringGets.inc();\n+          return mapper.writeValueAsString(resource);\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<String>> failedBodies;\n+      private final PCollection<HealthcareIOError<String>> failedFiles;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedBodies the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedBodies) {\n+        return new Result(pipeline, failedBodies, null);\n+      }\n+\n+      static Result in(\n+          Pipeline pipeline,\n+          PCollection<HealthcareIOError<String>> failedBodies,\n+          PCollection<HealthcareIOError<String>> failedFiles) {\n+        return new Result(pipeline, failedBodies, failedFiles);\n+      }\n+\n+      /**\n+       * Gets failed bodies with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedBodies() {\n+        return this.failedBodies;\n+      }\n+\n+      /**\n+       * Gets failed file imports with err.\n+       *\n+       * @return the failed GCS uri with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedFiles() {\n+        return this.failedFiles;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(Write.FAILED_BODY, failedBodies, Write.FAILED_FILES, failedFiles);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline,\n+          PCollection<HealthcareIOError<String>> failedBodies,\n+          @Nullable PCollection<HealthcareIOError<String>> failedFiles) {\n+        this.pipeline = pipeline;\n+        this.failedBodies = failedBodies;\n+        if (failedFiles == null) {\n+          failedFiles =\n+              (PCollection<HealthcareIOError<String>>)\n+                  pipeline.apply(Create.empty(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+        }\n+        this.failedFiles = failedFiles;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    public static Write fhirStoresImport(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> gcsTempPath,\n+        ValueProvider<String> gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath.get())\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath.get())\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<String> input) {\n+      PCollection<HealthcareIOError<String>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.info(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          FhirIO.Import.ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          return input.apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure));\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input\n+                  .apply(\n+                      \"Execute FHIR Bundles\",\n+                      ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())))\n+                  .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file. This is intended for batch use only to facilitate\n+   * large backfills to empty FHIR stores and should not be used with unbounded PCollections. If\n+   * your use case is streaming checkout using {@link ExecuteBundles} to more safely execute bundles\n+   * as transactions which is safer practice for a use on a \"live\" FHIR store.\n+   */\n+  public static class Import extends Write {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+    private static final int DEFAULT_FILES_PER_BATCH = 10000;\n+    private static final Logger LOG = LoggerFactory.getLogger(Import.class);\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> tempGcsPath,\n+        ValueProvider<String> deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore.get();\n+      this.tempGcsPath = tempGcsPath.get();\n+      this.deadLetterGcsPath = deadLetterGcsPath.get();\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    String getFhirStore() {\n+      return fhirStore;\n+    }\n+\n+    @Override\n+    WriteMethod getWriteMethod() {\n+      return WriteMethod.IMPORT;\n+    }\n+\n+    @Override\n+    Optional<ContentStructure> getContentStructure() {\n+      return Optional.of(contentStructure);\n+    }\n+\n+    @Override\n+    Optional<String> getImportGcsTempPath() {\n+      return Optional.of(tempGcsPath);\n+    }\n+\n+    @Override\n+    Optional<String> getImportGcsDeadLetterPath() {\n+      return Optional.of(deadLetterGcsPath);\n+    }\n+\n+    @Override\n+    public Write.Result expand(PCollection<String> input) {\n+      checkState(\n+          input.isBounded() == IsBounded.BOUNDED,\n+          \"FhirIO.Import should only be used on unbounded PCollections as it is\"\n+              + \"intended for batch use only.\");\n+\n+      // Write bundles of String to GCS\n+      PCollectionTuple writeTmpFileResults =\n+          input.apply(\n+              \"Write nd json to GCS\",\n+              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempGcsPath, deadLetterGcsPath))\n+                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+      PCollection<HealthcareIOError<String>> failedBodies =\n+          writeTmpFileResults\n+              .get(Write.FAILED_BODY)\n+              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      int numShards = 100;\n+      PCollection<HealthcareIOError<String>> failedFiles =\n+          writeTmpFileResults\n+              .get(Write.TEMP_FILES)\n+              .apply(\n+                  \"Shard files\", // to paralelize group into batches\n+                  WithKeys.of(ThreadLocalRandom.current().nextInt(0, numShards)))\n+              .apply(\"File Batches\", GroupIntoBatches.ofSize(DEFAULT_FILES_PER_BATCH))\n+              .apply(\n+                  ParDo.of(\n+                      new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)))\n+              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+\n+      // Wait til window closes for failedBodies and failedFiles to ensure we are done processing\n+      // anything under tempGcsPath because it has been successfully imported to FHIR store or\n+      // copies have been moved to the dead letter path.\n+      // Clean up all of tempGcsPath. This will handle removing phantom temporary objects from\n+      // failed / rescheduled ImportFn::importBatch.\n+      input\n+          .getPipeline()\n+          .apply(Create.of(Collections.singletonList(tempGcsPath)))\n+          .apply(\"Wait On File Writing\", Wait.on(failedBodies))\n+          .apply(\"Wait On FHIR Importing\", Wait.on(failedFiles))\n+          .apply(\n+              \"Match tempGcsPath\",\n+              FileIO.matchAll().withEmptyMatchTreatment(EmptyMatchTreatment.ALLOW))\n+          .apply(\n+              \"Delete tempGcsPath\",\n+              ParDo.of(\n+                  new DoFn<Metadata, Void>() {\n+                    private final Logger LOG = LoggerFactory.getLogger(Import.class);\n+\n+                    @ProcessElement\n+                    public void delete(@Element Metadata path) {\n+                      try {\n+                        FileSystems.delete(\n+                            Collections.singleton(path.resourceId()),\n+                            StandardMoveOptions.IGNORE_MISSING_FILES);\n+                      } catch (IOException e) {\n+                        LOG.error(\"error cleaning up tempGcsDir: %s\", e);\n+                      }\n+                    }\n+                  }))\n+          .setCoder(VoidCoder.of());\n+\n+      return Write.Result.in(input.getPipeline(), failedBodies, failedFiles);\n+    }\n+\n+    /** The Write bundles to new line delimited json files. */\n+    static class WriteBundlesToFilesFn extends DoFn<String, ResourceId> {\n+\n+      private final String fhirStore;\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ObjectMapper mapper;\n+      private ResourceId resourceId;\n+      private WritableByteChannel ndJsonChannel;\n+      private BoundedWindow window;\n+\n+      private transient HealthcareApiClient client;\n+      private static final Logger LOG = LoggerFactory.getLogger(WriteBundlesToFilesFn.class);\n+\n+      /**\n+       * Instantiates a new Import fn.\n+       *\n+       * @param fhirStore the fhir store\n+       * @param tempGcsPath the temp gcs path\n+       * @param deadLetterGcsPath the dead letter gcs path\n+       */\n+      WriteBundlesToFilesFn(String fhirStore, String tempGcsPath, String deadLetterGcsPath) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+      }\n+\n+      /**\n+       * Init client.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @Setup\n+      public void initClient() throws IOException {\n+        this.client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Init batch.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @StartBundle\n+      public void initFile() throws IOException {\n+        // Write each bundle to newline delimited JSON file.\n+        String filename = String.format(\"fhirImportBatch-%s.ndjson\", UUID.randomUUID().toString());\n+        ResourceId tempDir = FileSystems.matchNewResource(this.tempGcsPath, true);\n+        this.resourceId = tempDir.resolve(filename, StandardResolveOptions.RESOLVE_FILE);\n+        this.ndJsonChannel = FileSystems.create(resourceId, \"application/ld+json\");\n+        if (mapper == null) {\n+          this.mapper = new ObjectMapper();\n+        }\n+      }\n+\n+      /**\n+       * Add to batch.\n+       *\n+       * @param context the context\n+       * @throws IOException the io exception\n+       */\n+      @ProcessElement\n+      public void addToFile(ProcessContext context, BoundedWindow window) throws IOException {\n+        this.window = window;\n+        String httpBody = context.element();\n+        try {\n+          // This will error if not valid JSON an convert Pretty JSON to raw JSON.\n+          Object data = this.mapper.readValue(httpBody, Object.class);\n+          String ndJson = this.mapper.writeValueAsString(data) + \"\\n\";\n+          this.ndJsonChannel.write(ByteBuffer.wrap(ndJson.getBytes(StandardCharsets.UTF_8)));\n+        } catch (JsonProcessingException e) {\n+          String resource =\n+              String.format(\n+                  \"Failed to parse payload: %s as json at: %s : %s.\"\n+                      + \"Dropping message from batch import.\",\n+                  httpBody.toString(), e.getLocation().getCharOffset(), e.getMessage());\n+          LOG.warn(resource);\n+          context.output(\n+              Write.FAILED_BODY, HealthcareIOError.of(httpBody, new IOException(resource)));\n+        }\n+      }\n+\n+      /**\n+       * Close file.\n+       *\n+       * @param context the context\n+       * @throws IOException the io exception\n+       */\n+      @FinishBundle\n+      public void closeFile(FinishBundleContext context) throws IOException {\n+        // Write the file with all elements in this bundle to GCS.\n+        ndJsonChannel.close();\n+        context.output(resourceId, window.maxTimestamp(), window);\n+      }\n+    }\n+\n+    /** Import batches of new line delimited json files to FHIR Store. */\n+    static class ImportFn\n+        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ResourceId tempDir;\n+      private final ContentStructure contentStructure;\n+      private HealthcareApiClient client;\n+      private final String fhirStore;\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void init() throws IOException {\n+        tempDir =\n+            FileSystems.matchNewResource(tempGcsPath, true)\n+                .resolve(\n+                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                    StandardResolveOptions.RESOLVE_DIRECTORY);\n+        client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+       * GCS URI.\n+       */\n+      @ProcessElement\n+      public void importBatch(\n+          @Element KV<Integer, Iterable<ResourceId>> element,\n+          OutputReceiver<HealthcareIOError<String>> output)\n+          throws IOException {\n+        Iterable<ResourceId> batch = element.getValue();\n+        List<ResourceId> tempDestinations = new ArrayList<>();\n+        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+        assert batch != null;\n+        for (ResourceId file : batch) {\n+          tempDestinations.add(\n+              tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+          deadLetterDestinations.add(\n+              FileSystems.matchNewResource(deadLetterGcsPath, true)\n+                  .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+        }\n+        FileSystems.copy(ImmutableList.copyOf(batch), tempDestinations);\n+        ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n+        try {\n+          // Blocking fhirStores.import request.\n+          assert contentStructure != null;\n+          Operation operation =\n+              client.importFhirResource(fhirStore, importUri.toString(), contentStructure.name());\n+          client.pollOperation(operation, 500L);\n+          // Clean up temp files on GCS as they we successfully imported to FHIR store and no longer\n+          // needed.\n+          FileSystems.delete(tempDestinations);\n+        } catch (IOException | InterruptedException e) {\n+          ResourceId deadLetterResourceId = FileSystems.matchNewResource(deadLetterGcsPath, true);\n+          LOG.warn(\n+              String.format(\n+                  \"Failed to import %s with error: %s. Moving to deadletter path %s\",\n+                  importUri.toString(), e.getMessage(), deadLetterResourceId.toString()));\n+          FileSystems.rename(tempDestinations, deadLetterDestinations);\n+          output.output(HealthcareIOError.of(importUri.toString(), e));\n+        } finally {\n+          // If we've reached this point files have either been successfully import to FHIR store\n+          // or moved to Dead Letter Queue.\n+          // Clean up original files for this batch on GCS.\n+          FileSystems.delete(ImmutableList.copyOf(batch));\n+        }\n+      }\n+    }\n+\n+    /** The enum Content structure. */\n+    public enum ContentStructure {\n+      /** If the content structure is not specified, the default value BUNDLE will be used. */\n+      CONTENT_STRUCTURE_UNSPECIFIED,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a bundle, which contains one or more resources. Set the bundle type to history to import\n+       * resource versions.\n+       */\n+      BUNDLE,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a single resource.\n+       */\n+      RESOURCE,\n+      /** The entire file is one JSON bundle. The JSON can span multiple lines. */\n+      BUNDLE_PRETTY,\n+      /** The entire file is one JSON resource. The JSON can span multiple lines. */\n+      RESOURCE_PRETTY\n+    }\n+  }\n+\n+  /** The type Execute bundles. */\n+  public static class ExecuteBundles extends PTransform<PCollection<String>, Write.Result> {\n+    private final String fhirStore;\n+\n+    /**\n+     * Instantiates a new Execute bundles.\n+     *\n+     * @param fhirStore the fhir store\n+     */\n+    ExecuteBundles(ValueProvider<String> fhirStore) {\n+      this.fhirStore = fhirStore.get();\n+    }\n+\n+    /**\n+     * Instantiates a new Execute bundles.\n+     *\n+     * @param fhirStore the fhir store\n+     */\n+    ExecuteBundles(String fhirStore) {\n+      this.fhirStore = fhirStore;\n+    }\n+\n+    @Override\n+    public FhirIO.Write.Result expand(PCollection<String> input) {\n+      return Write.Result.in(\n+          input.getPipeline(),\n+          input\n+              .apply(ParDo.of(new ExecuteBundlesFn(fhirStore)))\n+              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+    }\n+\n+    /** The type Write Fhir fn. */\n+    static class ExecuteBundlesFn extends DoFn<String, HealthcareIOError<String>> {\n+\n+      private Counter failedBundles = Metrics.counter(ExecuteBundlesFn.class, \"failed-bundles\");\n+      private transient HealthcareApiClient client;\n+      private final ObjectMapper mapper = new ObjectMapper();\n+      /** The Fhir store. */\n+      private final String fhirStore;\n+\n+      /**\n+       * Instantiates a new Write Fhir fn.\n+       *\n+       * @param fhirStore the Fhir store\n+       */\n+      ExecuteBundlesFn(String fhirStore) {\n+        this.fhirStore = fhirStore;\n+      }\n+\n+      /**\n+       * Initialize healthcare client.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @Setup\n+      public void initClient() throws IOException {\n+        this.client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Execute Bundles.\n+       *\n+       * @param context the context\n+       */\n+      @ProcessElement\n+      public void executeBundles(ProcessContext context) {\n+        String body = context.element();\n+        try {\n+          // Validate that data was set to valid JSON.\n+          mapper.readTree(body);\n+          client.executeFhirBundle(fhirStore, body);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 1099}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA1NTU2OA==", "bodyText": "IMO Batching should be handled upstream from the connector based on what type of bundles the user is trying to commit to fire.\nexecuteBundle is a single call per (beam) element (but each (beam) element in this case is already a FHIR Bundle) but in a transaction type bundle it's very crucial what elements are batched together (as they are committed as a single transaction on the back-end). The user must control this to get the desired behavior.\nwith batch type bundle the operations are executed individually on the back end (but provided by the client as a single call).\nWe could provide a convenience PTransform for buffering batches into a bundle.\ncontext of what we support in Google HCAPI:\nhttps://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle\nbroader context of what the FHIR spec has for bundle type:\nhttps://www.hl7.org/fhir/valueset-bundle-type.html", "url": "https://github.com/apache/beam/pull/11339#discussion_r424055568", "createdAt": "2020-05-12T21:52:54Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedBodies()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FhirIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs / Stacktrace for Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+       *\n+       * @param pct the pct\n+       * @return the read result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchResourceJsonString\n+        extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchResourceJsonString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FetchResourceJsonString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FetchResourceJsonString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FetchResourceJsonString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FetchResourceJsonString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private String fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException {\n+          long startTime = System.currentTimeMillis();\n+\n+          HttpBody resource = client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulStringGets.inc();\n+          return mapper.writeValueAsString(resource);\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<String>> failedBodies;\n+      private final PCollection<HealthcareIOError<String>> failedFiles;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedBodies the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedBodies) {\n+        return new Result(pipeline, failedBodies, null);\n+      }\n+\n+      static Result in(\n+          Pipeline pipeline,\n+          PCollection<HealthcareIOError<String>> failedBodies,\n+          PCollection<HealthcareIOError<String>> failedFiles) {\n+        return new Result(pipeline, failedBodies, failedFiles);\n+      }\n+\n+      /**\n+       * Gets failed bodies with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedBodies() {\n+        return this.failedBodies;\n+      }\n+\n+      /**\n+       * Gets failed file imports with err.\n+       *\n+       * @return the failed GCS uri with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedFiles() {\n+        return this.failedFiles;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(Write.FAILED_BODY, failedBodies, Write.FAILED_FILES, failedFiles);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline,\n+          PCollection<HealthcareIOError<String>> failedBodies,\n+          @Nullable PCollection<HealthcareIOError<String>> failedFiles) {\n+        this.pipeline = pipeline;\n+        this.failedBodies = failedBodies;\n+        if (failedFiles == null) {\n+          failedFiles =\n+              (PCollection<HealthcareIOError<String>>)\n+                  pipeline.apply(Create.empty(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+        }\n+        this.failedFiles = failedFiles;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    public static Write fhirStoresImport(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> gcsTempPath,\n+        ValueProvider<String> gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath.get())\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath.get())\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<String> input) {\n+      PCollection<HealthcareIOError<String>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.info(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          FhirIO.Import.ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          return input.apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure));\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input\n+                  .apply(\n+                      \"Execute FHIR Bundles\",\n+                      ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())))\n+                  .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file. This is intended for batch use only to facilitate\n+   * large backfills to empty FHIR stores and should not be used with unbounded PCollections. If\n+   * your use case is streaming checkout using {@link ExecuteBundles} to more safely execute bundles\n+   * as transactions which is safer practice for a use on a \"live\" FHIR store.\n+   */\n+  public static class Import extends Write {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+    private static final int DEFAULT_FILES_PER_BATCH = 10000;\n+    private static final Logger LOG = LoggerFactory.getLogger(Import.class);\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> tempGcsPath,\n+        ValueProvider<String> deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore.get();\n+      this.tempGcsPath = tempGcsPath.get();\n+      this.deadLetterGcsPath = deadLetterGcsPath.get();\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    String getFhirStore() {\n+      return fhirStore;\n+    }\n+\n+    @Override\n+    WriteMethod getWriteMethod() {\n+      return WriteMethod.IMPORT;\n+    }\n+\n+    @Override\n+    Optional<ContentStructure> getContentStructure() {\n+      return Optional.of(contentStructure);\n+    }\n+\n+    @Override\n+    Optional<String> getImportGcsTempPath() {\n+      return Optional.of(tempGcsPath);\n+    }\n+\n+    @Override\n+    Optional<String> getImportGcsDeadLetterPath() {\n+      return Optional.of(deadLetterGcsPath);\n+    }\n+\n+    @Override\n+    public Write.Result expand(PCollection<String> input) {\n+      checkState(\n+          input.isBounded() == IsBounded.BOUNDED,\n+          \"FhirIO.Import should only be used on unbounded PCollections as it is\"\n+              + \"intended for batch use only.\");\n+\n+      // Write bundles of String to GCS\n+      PCollectionTuple writeTmpFileResults =\n+          input.apply(\n+              \"Write nd json to GCS\",\n+              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempGcsPath, deadLetterGcsPath))\n+                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+      PCollection<HealthcareIOError<String>> failedBodies =\n+          writeTmpFileResults\n+              .get(Write.FAILED_BODY)\n+              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      int numShards = 100;\n+      PCollection<HealthcareIOError<String>> failedFiles =\n+          writeTmpFileResults\n+              .get(Write.TEMP_FILES)\n+              .apply(\n+                  \"Shard files\", // to paralelize group into batches\n+                  WithKeys.of(ThreadLocalRandom.current().nextInt(0, numShards)))\n+              .apply(\"File Batches\", GroupIntoBatches.ofSize(DEFAULT_FILES_PER_BATCH))\n+              .apply(\n+                  ParDo.of(\n+                      new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)))\n+              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+\n+      // Wait til window closes for failedBodies and failedFiles to ensure we are done processing\n+      // anything under tempGcsPath because it has been successfully imported to FHIR store or\n+      // copies have been moved to the dead letter path.\n+      // Clean up all of tempGcsPath. This will handle removing phantom temporary objects from\n+      // failed / rescheduled ImportFn::importBatch.\n+      input\n+          .getPipeline()\n+          .apply(Create.of(Collections.singletonList(tempGcsPath)))\n+          .apply(\"Wait On File Writing\", Wait.on(failedBodies))\n+          .apply(\"Wait On FHIR Importing\", Wait.on(failedFiles))\n+          .apply(\n+              \"Match tempGcsPath\",\n+              FileIO.matchAll().withEmptyMatchTreatment(EmptyMatchTreatment.ALLOW))\n+          .apply(\n+              \"Delete tempGcsPath\",\n+              ParDo.of(\n+                  new DoFn<Metadata, Void>() {\n+                    private final Logger LOG = LoggerFactory.getLogger(Import.class);\n+\n+                    @ProcessElement\n+                    public void delete(@Element Metadata path) {\n+                      try {\n+                        FileSystems.delete(\n+                            Collections.singleton(path.resourceId()),\n+                            StandardMoveOptions.IGNORE_MISSING_FILES);\n+                      } catch (IOException e) {\n+                        LOG.error(\"error cleaning up tempGcsDir: %s\", e);\n+                      }\n+                    }\n+                  }))\n+          .setCoder(VoidCoder.of());\n+\n+      return Write.Result.in(input.getPipeline(), failedBodies, failedFiles);\n+    }\n+\n+    /** The Write bundles to new line delimited json files. */\n+    static class WriteBundlesToFilesFn extends DoFn<String, ResourceId> {\n+\n+      private final String fhirStore;\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ObjectMapper mapper;\n+      private ResourceId resourceId;\n+      private WritableByteChannel ndJsonChannel;\n+      private BoundedWindow window;\n+\n+      private transient HealthcareApiClient client;\n+      private static final Logger LOG = LoggerFactory.getLogger(WriteBundlesToFilesFn.class);\n+\n+      /**\n+       * Instantiates a new Import fn.\n+       *\n+       * @param fhirStore the fhir store\n+       * @param tempGcsPath the temp gcs path\n+       * @param deadLetterGcsPath the dead letter gcs path\n+       */\n+      WriteBundlesToFilesFn(String fhirStore, String tempGcsPath, String deadLetterGcsPath) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+      }\n+\n+      /**\n+       * Init client.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @Setup\n+      public void initClient() throws IOException {\n+        this.client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Init batch.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @StartBundle\n+      public void initFile() throws IOException {\n+        // Write each bundle to newline delimited JSON file.\n+        String filename = String.format(\"fhirImportBatch-%s.ndjson\", UUID.randomUUID().toString());\n+        ResourceId tempDir = FileSystems.matchNewResource(this.tempGcsPath, true);\n+        this.resourceId = tempDir.resolve(filename, StandardResolveOptions.RESOLVE_FILE);\n+        this.ndJsonChannel = FileSystems.create(resourceId, \"application/ld+json\");\n+        if (mapper == null) {\n+          this.mapper = new ObjectMapper();\n+        }\n+      }\n+\n+      /**\n+       * Add to batch.\n+       *\n+       * @param context the context\n+       * @throws IOException the io exception\n+       */\n+      @ProcessElement\n+      public void addToFile(ProcessContext context, BoundedWindow window) throws IOException {\n+        this.window = window;\n+        String httpBody = context.element();\n+        try {\n+          // This will error if not valid JSON an convert Pretty JSON to raw JSON.\n+          Object data = this.mapper.readValue(httpBody, Object.class);\n+          String ndJson = this.mapper.writeValueAsString(data) + \"\\n\";\n+          this.ndJsonChannel.write(ByteBuffer.wrap(ndJson.getBytes(StandardCharsets.UTF_8)));\n+        } catch (JsonProcessingException e) {\n+          String resource =\n+              String.format(\n+                  \"Failed to parse payload: %s as json at: %s : %s.\"\n+                      + \"Dropping message from batch import.\",\n+                  httpBody.toString(), e.getLocation().getCharOffset(), e.getMessage());\n+          LOG.warn(resource);\n+          context.output(\n+              Write.FAILED_BODY, HealthcareIOError.of(httpBody, new IOException(resource)));\n+        }\n+      }\n+\n+      /**\n+       * Close file.\n+       *\n+       * @param context the context\n+       * @throws IOException the io exception\n+       */\n+      @FinishBundle\n+      public void closeFile(FinishBundleContext context) throws IOException {\n+        // Write the file with all elements in this bundle to GCS.\n+        ndJsonChannel.close();\n+        context.output(resourceId, window.maxTimestamp(), window);\n+      }\n+    }\n+\n+    /** Import batches of new line delimited json files to FHIR Store. */\n+    static class ImportFn\n+        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ResourceId tempDir;\n+      private final ContentStructure contentStructure;\n+      private HealthcareApiClient client;\n+      private final String fhirStore;\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void init() throws IOException {\n+        tempDir =\n+            FileSystems.matchNewResource(tempGcsPath, true)\n+                .resolve(\n+                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                    StandardResolveOptions.RESOLVE_DIRECTORY);\n+        client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+       * GCS URI.\n+       */\n+      @ProcessElement\n+      public void importBatch(\n+          @Element KV<Integer, Iterable<ResourceId>> element,\n+          OutputReceiver<HealthcareIOError<String>> output)\n+          throws IOException {\n+        Iterable<ResourceId> batch = element.getValue();\n+        List<ResourceId> tempDestinations = new ArrayList<>();\n+        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+        assert batch != null;\n+        for (ResourceId file : batch) {\n+          tempDestinations.add(\n+              tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+          deadLetterDestinations.add(\n+              FileSystems.matchNewResource(deadLetterGcsPath, true)\n+                  .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+        }\n+        FileSystems.copy(ImmutableList.copyOf(batch), tempDestinations);\n+        ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n+        try {\n+          // Blocking fhirStores.import request.\n+          assert contentStructure != null;\n+          Operation operation =\n+              client.importFhirResource(fhirStore, importUri.toString(), contentStructure.name());\n+          client.pollOperation(operation, 500L);\n+          // Clean up temp files on GCS as they we successfully imported to FHIR store and no longer\n+          // needed.\n+          FileSystems.delete(tempDestinations);\n+        } catch (IOException | InterruptedException e) {\n+          ResourceId deadLetterResourceId = FileSystems.matchNewResource(deadLetterGcsPath, true);\n+          LOG.warn(\n+              String.format(\n+                  \"Failed to import %s with error: %s. Moving to deadletter path %s\",\n+                  importUri.toString(), e.getMessage(), deadLetterResourceId.toString()));\n+          FileSystems.rename(tempDestinations, deadLetterDestinations);\n+          output.output(HealthcareIOError.of(importUri.toString(), e));\n+        } finally {\n+          // If we've reached this point files have either been successfully import to FHIR store\n+          // or moved to Dead Letter Queue.\n+          // Clean up original files for this batch on GCS.\n+          FileSystems.delete(ImmutableList.copyOf(batch));\n+        }\n+      }\n+    }\n+\n+    /** The enum Content structure. */\n+    public enum ContentStructure {\n+      /** If the content structure is not specified, the default value BUNDLE will be used. */\n+      CONTENT_STRUCTURE_UNSPECIFIED,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a bundle, which contains one or more resources. Set the bundle type to history to import\n+       * resource versions.\n+       */\n+      BUNDLE,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a single resource.\n+       */\n+      RESOURCE,\n+      /** The entire file is one JSON bundle. The JSON can span multiple lines. */\n+      BUNDLE_PRETTY,\n+      /** The entire file is one JSON resource. The JSON can span multiple lines. */\n+      RESOURCE_PRETTY\n+    }\n+  }\n+\n+  /** The type Execute bundles. */\n+  public static class ExecuteBundles extends PTransform<PCollection<String>, Write.Result> {\n+    private final String fhirStore;\n+\n+    /**\n+     * Instantiates a new Execute bundles.\n+     *\n+     * @param fhirStore the fhir store\n+     */\n+    ExecuteBundles(ValueProvider<String> fhirStore) {\n+      this.fhirStore = fhirStore.get();\n+    }\n+\n+    /**\n+     * Instantiates a new Execute bundles.\n+     *\n+     * @param fhirStore the fhir store\n+     */\n+    ExecuteBundles(String fhirStore) {\n+      this.fhirStore = fhirStore;\n+    }\n+\n+    @Override\n+    public FhirIO.Write.Result expand(PCollection<String> input) {\n+      return Write.Result.in(\n+          input.getPipeline(),\n+          input\n+              .apply(ParDo.of(new ExecuteBundlesFn(fhirStore)))\n+              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+    }\n+\n+    /** The type Write Fhir fn. */\n+    static class ExecuteBundlesFn extends DoFn<String, HealthcareIOError<String>> {\n+\n+      private Counter failedBundles = Metrics.counter(ExecuteBundlesFn.class, \"failed-bundles\");\n+      private transient HealthcareApiClient client;\n+      private final ObjectMapper mapper = new ObjectMapper();\n+      /** The Fhir store. */\n+      private final String fhirStore;\n+\n+      /**\n+       * Instantiates a new Write Fhir fn.\n+       *\n+       * @param fhirStore the Fhir store\n+       */\n+      ExecuteBundlesFn(String fhirStore) {\n+        this.fhirStore = fhirStore;\n+      }\n+\n+      /**\n+       * Initialize healthcare client.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @Setup\n+      public void initClient() throws IOException {\n+        this.client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Execute Bundles.\n+       *\n+       * @param context the context\n+       */\n+      @ProcessElement\n+      public void executeBundles(ProcessContext context) {\n+        String body = context.element();\n+        try {\n+          // Validate that data was set to valid JSON.\n+          mapper.readTree(body);\n+          client.executeFhirBundle(fhirStore, body);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0ODUyMw=="}, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 1099}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3MTk1Mw==", "bodyText": "To be a bit clearer:\n\nFHIR bundle is 1:1 with beam element here (but may contain many operations).\nThe FHIR bundle a field that dictates if it is transaction or batch type but they use the same endpoint / method.", "url": "https://github.com/apache/beam/pull/11339#discussion_r424071953", "createdAt": "2020-05-12T22:33:50Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedBodies()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FhirIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs / Stacktrace for Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+       *\n+       * @param pct the pct\n+       * @return the read result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchResourceJsonString\n+        extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchResourceJsonString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FetchResourceJsonString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FetchResourceJsonString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FetchResourceJsonString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FetchResourceJsonString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private String fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException {\n+          long startTime = System.currentTimeMillis();\n+\n+          HttpBody resource = client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulStringGets.inc();\n+          return mapper.writeValueAsString(resource);\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<String>> failedBodies;\n+      private final PCollection<HealthcareIOError<String>> failedFiles;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedBodies the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedBodies) {\n+        return new Result(pipeline, failedBodies, null);\n+      }\n+\n+      static Result in(\n+          Pipeline pipeline,\n+          PCollection<HealthcareIOError<String>> failedBodies,\n+          PCollection<HealthcareIOError<String>> failedFiles) {\n+        return new Result(pipeline, failedBodies, failedFiles);\n+      }\n+\n+      /**\n+       * Gets failed bodies with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedBodies() {\n+        return this.failedBodies;\n+      }\n+\n+      /**\n+       * Gets failed file imports with err.\n+       *\n+       * @return the failed GCS uri with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedFiles() {\n+        return this.failedFiles;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(Write.FAILED_BODY, failedBodies, Write.FAILED_FILES, failedFiles);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline,\n+          PCollection<HealthcareIOError<String>> failedBodies,\n+          @Nullable PCollection<HealthcareIOError<String>> failedFiles) {\n+        this.pipeline = pipeline;\n+        this.failedBodies = failedBodies;\n+        if (failedFiles == null) {\n+          failedFiles =\n+              (PCollection<HealthcareIOError<String>>)\n+                  pipeline.apply(Create.empty(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+        }\n+        this.failedFiles = failedFiles;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    public static Write fhirStoresImport(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> gcsTempPath,\n+        ValueProvider<String> gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath.get())\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath.get())\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<String> input) {\n+      PCollection<HealthcareIOError<String>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.info(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          FhirIO.Import.ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          return input.apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure));\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input\n+                  .apply(\n+                      \"Execute FHIR Bundles\",\n+                      ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())))\n+                  .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file. This is intended for batch use only to facilitate\n+   * large backfills to empty FHIR stores and should not be used with unbounded PCollections. If\n+   * your use case is streaming checkout using {@link ExecuteBundles} to more safely execute bundles\n+   * as transactions which is safer practice for a use on a \"live\" FHIR store.\n+   */\n+  public static class Import extends Write {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+    private static final int DEFAULT_FILES_PER_BATCH = 10000;\n+    private static final Logger LOG = LoggerFactory.getLogger(Import.class);\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> tempGcsPath,\n+        ValueProvider<String> deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore.get();\n+      this.tempGcsPath = tempGcsPath.get();\n+      this.deadLetterGcsPath = deadLetterGcsPath.get();\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    String getFhirStore() {\n+      return fhirStore;\n+    }\n+\n+    @Override\n+    WriteMethod getWriteMethod() {\n+      return WriteMethod.IMPORT;\n+    }\n+\n+    @Override\n+    Optional<ContentStructure> getContentStructure() {\n+      return Optional.of(contentStructure);\n+    }\n+\n+    @Override\n+    Optional<String> getImportGcsTempPath() {\n+      return Optional.of(tempGcsPath);\n+    }\n+\n+    @Override\n+    Optional<String> getImportGcsDeadLetterPath() {\n+      return Optional.of(deadLetterGcsPath);\n+    }\n+\n+    @Override\n+    public Write.Result expand(PCollection<String> input) {\n+      checkState(\n+          input.isBounded() == IsBounded.BOUNDED,\n+          \"FhirIO.Import should only be used on unbounded PCollections as it is\"\n+              + \"intended for batch use only.\");\n+\n+      // Write bundles of String to GCS\n+      PCollectionTuple writeTmpFileResults =\n+          input.apply(\n+              \"Write nd json to GCS\",\n+              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempGcsPath, deadLetterGcsPath))\n+                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+      PCollection<HealthcareIOError<String>> failedBodies =\n+          writeTmpFileResults\n+              .get(Write.FAILED_BODY)\n+              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      int numShards = 100;\n+      PCollection<HealthcareIOError<String>> failedFiles =\n+          writeTmpFileResults\n+              .get(Write.TEMP_FILES)\n+              .apply(\n+                  \"Shard files\", // to paralelize group into batches\n+                  WithKeys.of(ThreadLocalRandom.current().nextInt(0, numShards)))\n+              .apply(\"File Batches\", GroupIntoBatches.ofSize(DEFAULT_FILES_PER_BATCH))\n+              .apply(\n+                  ParDo.of(\n+                      new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)))\n+              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+\n+      // Wait til window closes for failedBodies and failedFiles to ensure we are done processing\n+      // anything under tempGcsPath because it has been successfully imported to FHIR store or\n+      // copies have been moved to the dead letter path.\n+      // Clean up all of tempGcsPath. This will handle removing phantom temporary objects from\n+      // failed / rescheduled ImportFn::importBatch.\n+      input\n+          .getPipeline()\n+          .apply(Create.of(Collections.singletonList(tempGcsPath)))\n+          .apply(\"Wait On File Writing\", Wait.on(failedBodies))\n+          .apply(\"Wait On FHIR Importing\", Wait.on(failedFiles))\n+          .apply(\n+              \"Match tempGcsPath\",\n+              FileIO.matchAll().withEmptyMatchTreatment(EmptyMatchTreatment.ALLOW))\n+          .apply(\n+              \"Delete tempGcsPath\",\n+              ParDo.of(\n+                  new DoFn<Metadata, Void>() {\n+                    private final Logger LOG = LoggerFactory.getLogger(Import.class);\n+\n+                    @ProcessElement\n+                    public void delete(@Element Metadata path) {\n+                      try {\n+                        FileSystems.delete(\n+                            Collections.singleton(path.resourceId()),\n+                            StandardMoveOptions.IGNORE_MISSING_FILES);\n+                      } catch (IOException e) {\n+                        LOG.error(\"error cleaning up tempGcsDir: %s\", e);\n+                      }\n+                    }\n+                  }))\n+          .setCoder(VoidCoder.of());\n+\n+      return Write.Result.in(input.getPipeline(), failedBodies, failedFiles);\n+    }\n+\n+    /** The Write bundles to new line delimited json files. */\n+    static class WriteBundlesToFilesFn extends DoFn<String, ResourceId> {\n+\n+      private final String fhirStore;\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ObjectMapper mapper;\n+      private ResourceId resourceId;\n+      private WritableByteChannel ndJsonChannel;\n+      private BoundedWindow window;\n+\n+      private transient HealthcareApiClient client;\n+      private static final Logger LOG = LoggerFactory.getLogger(WriteBundlesToFilesFn.class);\n+\n+      /**\n+       * Instantiates a new Import fn.\n+       *\n+       * @param fhirStore the fhir store\n+       * @param tempGcsPath the temp gcs path\n+       * @param deadLetterGcsPath the dead letter gcs path\n+       */\n+      WriteBundlesToFilesFn(String fhirStore, String tempGcsPath, String deadLetterGcsPath) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+      }\n+\n+      /**\n+       * Init client.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @Setup\n+      public void initClient() throws IOException {\n+        this.client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Init batch.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @StartBundle\n+      public void initFile() throws IOException {\n+        // Write each bundle to newline delimited JSON file.\n+        String filename = String.format(\"fhirImportBatch-%s.ndjson\", UUID.randomUUID().toString());\n+        ResourceId tempDir = FileSystems.matchNewResource(this.tempGcsPath, true);\n+        this.resourceId = tempDir.resolve(filename, StandardResolveOptions.RESOLVE_FILE);\n+        this.ndJsonChannel = FileSystems.create(resourceId, \"application/ld+json\");\n+        if (mapper == null) {\n+          this.mapper = new ObjectMapper();\n+        }\n+      }\n+\n+      /**\n+       * Add to batch.\n+       *\n+       * @param context the context\n+       * @throws IOException the io exception\n+       */\n+      @ProcessElement\n+      public void addToFile(ProcessContext context, BoundedWindow window) throws IOException {\n+        this.window = window;\n+        String httpBody = context.element();\n+        try {\n+          // This will error if not valid JSON an convert Pretty JSON to raw JSON.\n+          Object data = this.mapper.readValue(httpBody, Object.class);\n+          String ndJson = this.mapper.writeValueAsString(data) + \"\\n\";\n+          this.ndJsonChannel.write(ByteBuffer.wrap(ndJson.getBytes(StandardCharsets.UTF_8)));\n+        } catch (JsonProcessingException e) {\n+          String resource =\n+              String.format(\n+                  \"Failed to parse payload: %s as json at: %s : %s.\"\n+                      + \"Dropping message from batch import.\",\n+                  httpBody.toString(), e.getLocation().getCharOffset(), e.getMessage());\n+          LOG.warn(resource);\n+          context.output(\n+              Write.FAILED_BODY, HealthcareIOError.of(httpBody, new IOException(resource)));\n+        }\n+      }\n+\n+      /**\n+       * Close file.\n+       *\n+       * @param context the context\n+       * @throws IOException the io exception\n+       */\n+      @FinishBundle\n+      public void closeFile(FinishBundleContext context) throws IOException {\n+        // Write the file with all elements in this bundle to GCS.\n+        ndJsonChannel.close();\n+        context.output(resourceId, window.maxTimestamp(), window);\n+      }\n+    }\n+\n+    /** Import batches of new line delimited json files to FHIR Store. */\n+    static class ImportFn\n+        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ResourceId tempDir;\n+      private final ContentStructure contentStructure;\n+      private HealthcareApiClient client;\n+      private final String fhirStore;\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void init() throws IOException {\n+        tempDir =\n+            FileSystems.matchNewResource(tempGcsPath, true)\n+                .resolve(\n+                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                    StandardResolveOptions.RESOLVE_DIRECTORY);\n+        client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+       * GCS URI.\n+       */\n+      @ProcessElement\n+      public void importBatch(\n+          @Element KV<Integer, Iterable<ResourceId>> element,\n+          OutputReceiver<HealthcareIOError<String>> output)\n+          throws IOException {\n+        Iterable<ResourceId> batch = element.getValue();\n+        List<ResourceId> tempDestinations = new ArrayList<>();\n+        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+        assert batch != null;\n+        for (ResourceId file : batch) {\n+          tempDestinations.add(\n+              tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+          deadLetterDestinations.add(\n+              FileSystems.matchNewResource(deadLetterGcsPath, true)\n+                  .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+        }\n+        FileSystems.copy(ImmutableList.copyOf(batch), tempDestinations);\n+        ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n+        try {\n+          // Blocking fhirStores.import request.\n+          assert contentStructure != null;\n+          Operation operation =\n+              client.importFhirResource(fhirStore, importUri.toString(), contentStructure.name());\n+          client.pollOperation(operation, 500L);\n+          // Clean up temp files on GCS as they we successfully imported to FHIR store and no longer\n+          // needed.\n+          FileSystems.delete(tempDestinations);\n+        } catch (IOException | InterruptedException e) {\n+          ResourceId deadLetterResourceId = FileSystems.matchNewResource(deadLetterGcsPath, true);\n+          LOG.warn(\n+              String.format(\n+                  \"Failed to import %s with error: %s. Moving to deadletter path %s\",\n+                  importUri.toString(), e.getMessage(), deadLetterResourceId.toString()));\n+          FileSystems.rename(tempDestinations, deadLetterDestinations);\n+          output.output(HealthcareIOError.of(importUri.toString(), e));\n+        } finally {\n+          // If we've reached this point files have either been successfully import to FHIR store\n+          // or moved to Dead Letter Queue.\n+          // Clean up original files for this batch on GCS.\n+          FileSystems.delete(ImmutableList.copyOf(batch));\n+        }\n+      }\n+    }\n+\n+    /** The enum Content structure. */\n+    public enum ContentStructure {\n+      /** If the content structure is not specified, the default value BUNDLE will be used. */\n+      CONTENT_STRUCTURE_UNSPECIFIED,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a bundle, which contains one or more resources. Set the bundle type to history to import\n+       * resource versions.\n+       */\n+      BUNDLE,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a single resource.\n+       */\n+      RESOURCE,\n+      /** The entire file is one JSON bundle. The JSON can span multiple lines. */\n+      BUNDLE_PRETTY,\n+      /** The entire file is one JSON resource. The JSON can span multiple lines. */\n+      RESOURCE_PRETTY\n+    }\n+  }\n+\n+  /** The type Execute bundles. */\n+  public static class ExecuteBundles extends PTransform<PCollection<String>, Write.Result> {\n+    private final String fhirStore;\n+\n+    /**\n+     * Instantiates a new Execute bundles.\n+     *\n+     * @param fhirStore the fhir store\n+     */\n+    ExecuteBundles(ValueProvider<String> fhirStore) {\n+      this.fhirStore = fhirStore.get();\n+    }\n+\n+    /**\n+     * Instantiates a new Execute bundles.\n+     *\n+     * @param fhirStore the fhir store\n+     */\n+    ExecuteBundles(String fhirStore) {\n+      this.fhirStore = fhirStore;\n+    }\n+\n+    @Override\n+    public FhirIO.Write.Result expand(PCollection<String> input) {\n+      return Write.Result.in(\n+          input.getPipeline(),\n+          input\n+              .apply(ParDo.of(new ExecuteBundlesFn(fhirStore)))\n+              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+    }\n+\n+    /** The type Write Fhir fn. */\n+    static class ExecuteBundlesFn extends DoFn<String, HealthcareIOError<String>> {\n+\n+      private Counter failedBundles = Metrics.counter(ExecuteBundlesFn.class, \"failed-bundles\");\n+      private transient HealthcareApiClient client;\n+      private final ObjectMapper mapper = new ObjectMapper();\n+      /** The Fhir store. */\n+      private final String fhirStore;\n+\n+      /**\n+       * Instantiates a new Write Fhir fn.\n+       *\n+       * @param fhirStore the Fhir store\n+       */\n+      ExecuteBundlesFn(String fhirStore) {\n+        this.fhirStore = fhirStore;\n+      }\n+\n+      /**\n+       * Initialize healthcare client.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @Setup\n+      public void initClient() throws IOException {\n+        this.client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Execute Bundles.\n+       *\n+       * @param context the context\n+       */\n+      @ProcessElement\n+      public void executeBundles(ProcessContext context) {\n+        String body = context.element();\n+        try {\n+          // Validate that data was set to valid JSON.\n+          mapper.readTree(body);\n+          client.executeFhirBundle(fhirStore, body);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0ODUyMw=="}, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 1099}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwNjM5NQ==", "bodyText": "Makes sense. Sounds good to me!", "url": "https://github.com/apache/beam/pull/11339#discussion_r424706395", "createdAt": "2020-05-13T20:18:10Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <p>Read\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read} supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieved a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedBodies()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FhirIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs / Stacktrace for Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+       *\n+       * @param pct the pct\n+       * @return the read result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      public static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    public static class FetchResourceJsonString\n+        extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchResourceJsonString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new FetchResourceJsonString.StringGetFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      public static class StringGetFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(FetchResourceJsonString.StringGetFn.class, \"failed-message-reads\");\n+        private static final Logger LOG =\n+            LoggerFactory.getLogger(FetchResourceJsonString.StringGetFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(\n+                FetchResourceJsonString.StringGetFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        StringGetFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private String fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException {\n+          long startTime = System.currentTimeMillis();\n+\n+          HttpBody resource = client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulStringGets.inc();\n+          return mapper.writeValueAsString(resource);\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<String>> failedBodies;\n+      private final PCollection<HealthcareIOError<String>> failedFiles;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedBodies the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedBodies) {\n+        return new Result(pipeline, failedBodies, null);\n+      }\n+\n+      static Result in(\n+          Pipeline pipeline,\n+          PCollection<HealthcareIOError<String>> failedBodies,\n+          PCollection<HealthcareIOError<String>> failedFiles) {\n+        return new Result(pipeline, failedBodies, failedFiles);\n+      }\n+\n+      /**\n+       * Gets failed bodies with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedBodies() {\n+        return this.failedBodies;\n+      }\n+\n+      /**\n+       * Gets failed file imports with err.\n+       *\n+       * @return the failed GCS uri with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedFiles() {\n+        return this.failedFiles;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(Write.FAILED_BODY, failedBodies, Write.FAILED_FILES, failedFiles);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline,\n+          PCollection<HealthcareIOError<String>> failedBodies,\n+          @Nullable PCollection<HealthcareIOError<String>> failedFiles) {\n+        this.pipeline = pipeline;\n+        this.failedBodies = failedBodies;\n+        if (failedFiles == null) {\n+          failedFiles =\n+              (PCollection<HealthcareIOError<String>>)\n+                  pipeline.apply(Create.empty(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+        }\n+        this.failedFiles = failedFiles;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    public static Write fhirStoresImport(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> gcsTempPath,\n+        ValueProvider<String> gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath.get())\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath.get())\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<String> input) {\n+      PCollection<HealthcareIOError<String>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.info(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String tempPath = getImportGcsTempPath().orElseThrow(IllegalArgumentException::new);\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          FhirIO.Import.ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+\n+          return input.apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure));\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input\n+                  .apply(\n+                      \"Execute FHIR Bundles\",\n+                      ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())))\n+                  .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file. This is intended for batch use only to facilitate\n+   * large backfills to empty FHIR stores and should not be used with unbounded PCollections. If\n+   * your use case is streaming checkout using {@link ExecuteBundles} to more safely execute bundles\n+   * as transactions which is safer practice for a use on a \"live\" FHIR store.\n+   */\n+  public static class Import extends Write {\n+\n+    private final String fhirStore;\n+    private final String tempGcsPath;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+    private static final int DEFAULT_FILES_PER_BATCH = 10000;\n+    private static final Logger LOG = LoggerFactory.getLogger(Import.class);\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> tempGcsPath,\n+        ValueProvider<String> deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore.get();\n+      this.tempGcsPath = tempGcsPath.get();\n+      this.deadLetterGcsPath = deadLetterGcsPath.get();\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    String getFhirStore() {\n+      return fhirStore;\n+    }\n+\n+    @Override\n+    WriteMethod getWriteMethod() {\n+      return WriteMethod.IMPORT;\n+    }\n+\n+    @Override\n+    Optional<ContentStructure> getContentStructure() {\n+      return Optional.of(contentStructure);\n+    }\n+\n+    @Override\n+    Optional<String> getImportGcsTempPath() {\n+      return Optional.of(tempGcsPath);\n+    }\n+\n+    @Override\n+    Optional<String> getImportGcsDeadLetterPath() {\n+      return Optional.of(deadLetterGcsPath);\n+    }\n+\n+    @Override\n+    public Write.Result expand(PCollection<String> input) {\n+      checkState(\n+          input.isBounded() == IsBounded.BOUNDED,\n+          \"FhirIO.Import should only be used on unbounded PCollections as it is\"\n+              + \"intended for batch use only.\");\n+\n+      // Write bundles of String to GCS\n+      PCollectionTuple writeTmpFileResults =\n+          input.apply(\n+              \"Write nd json to GCS\",\n+              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempGcsPath, deadLetterGcsPath))\n+                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+      PCollection<HealthcareIOError<String>> failedBodies =\n+          writeTmpFileResults\n+              .get(Write.FAILED_BODY)\n+              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      int numShards = 100;\n+      PCollection<HealthcareIOError<String>> failedFiles =\n+          writeTmpFileResults\n+              .get(Write.TEMP_FILES)\n+              .apply(\n+                  \"Shard files\", // to paralelize group into batches\n+                  WithKeys.of(ThreadLocalRandom.current().nextInt(0, numShards)))\n+              .apply(\"File Batches\", GroupIntoBatches.ofSize(DEFAULT_FILES_PER_BATCH))\n+              .apply(\n+                  ParDo.of(\n+                      new ImportFn(fhirStore, tempGcsPath, deadLetterGcsPath, contentStructure)))\n+              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+\n+      // Wait til window closes for failedBodies and failedFiles to ensure we are done processing\n+      // anything under tempGcsPath because it has been successfully imported to FHIR store or\n+      // copies have been moved to the dead letter path.\n+      // Clean up all of tempGcsPath. This will handle removing phantom temporary objects from\n+      // failed / rescheduled ImportFn::importBatch.\n+      input\n+          .getPipeline()\n+          .apply(Create.of(Collections.singletonList(tempGcsPath)))\n+          .apply(\"Wait On File Writing\", Wait.on(failedBodies))\n+          .apply(\"Wait On FHIR Importing\", Wait.on(failedFiles))\n+          .apply(\n+              \"Match tempGcsPath\",\n+              FileIO.matchAll().withEmptyMatchTreatment(EmptyMatchTreatment.ALLOW))\n+          .apply(\n+              \"Delete tempGcsPath\",\n+              ParDo.of(\n+                  new DoFn<Metadata, Void>() {\n+                    private final Logger LOG = LoggerFactory.getLogger(Import.class);\n+\n+                    @ProcessElement\n+                    public void delete(@Element Metadata path) {\n+                      try {\n+                        FileSystems.delete(\n+                            Collections.singleton(path.resourceId()),\n+                            StandardMoveOptions.IGNORE_MISSING_FILES);\n+                      } catch (IOException e) {\n+                        LOG.error(\"error cleaning up tempGcsDir: %s\", e);\n+                      }\n+                    }\n+                  }))\n+          .setCoder(VoidCoder.of());\n+\n+      return Write.Result.in(input.getPipeline(), failedBodies, failedFiles);\n+    }\n+\n+    /** The Write bundles to new line delimited json files. */\n+    static class WriteBundlesToFilesFn extends DoFn<String, ResourceId> {\n+\n+      private final String fhirStore;\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ObjectMapper mapper;\n+      private ResourceId resourceId;\n+      private WritableByteChannel ndJsonChannel;\n+      private BoundedWindow window;\n+\n+      private transient HealthcareApiClient client;\n+      private static final Logger LOG = LoggerFactory.getLogger(WriteBundlesToFilesFn.class);\n+\n+      /**\n+       * Instantiates a new Import fn.\n+       *\n+       * @param fhirStore the fhir store\n+       * @param tempGcsPath the temp gcs path\n+       * @param deadLetterGcsPath the dead letter gcs path\n+       */\n+      WriteBundlesToFilesFn(String fhirStore, String tempGcsPath, String deadLetterGcsPath) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+      }\n+\n+      /**\n+       * Init client.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @Setup\n+      public void initClient() throws IOException {\n+        this.client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Init batch.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @StartBundle\n+      public void initFile() throws IOException {\n+        // Write each bundle to newline delimited JSON file.\n+        String filename = String.format(\"fhirImportBatch-%s.ndjson\", UUID.randomUUID().toString());\n+        ResourceId tempDir = FileSystems.matchNewResource(this.tempGcsPath, true);\n+        this.resourceId = tempDir.resolve(filename, StandardResolveOptions.RESOLVE_FILE);\n+        this.ndJsonChannel = FileSystems.create(resourceId, \"application/ld+json\");\n+        if (mapper == null) {\n+          this.mapper = new ObjectMapper();\n+        }\n+      }\n+\n+      /**\n+       * Add to batch.\n+       *\n+       * @param context the context\n+       * @throws IOException the io exception\n+       */\n+      @ProcessElement\n+      public void addToFile(ProcessContext context, BoundedWindow window) throws IOException {\n+        this.window = window;\n+        String httpBody = context.element();\n+        try {\n+          // This will error if not valid JSON an convert Pretty JSON to raw JSON.\n+          Object data = this.mapper.readValue(httpBody, Object.class);\n+          String ndJson = this.mapper.writeValueAsString(data) + \"\\n\";\n+          this.ndJsonChannel.write(ByteBuffer.wrap(ndJson.getBytes(StandardCharsets.UTF_8)));\n+        } catch (JsonProcessingException e) {\n+          String resource =\n+              String.format(\n+                  \"Failed to parse payload: %s as json at: %s : %s.\"\n+                      + \"Dropping message from batch import.\",\n+                  httpBody.toString(), e.getLocation().getCharOffset(), e.getMessage());\n+          LOG.warn(resource);\n+          context.output(\n+              Write.FAILED_BODY, HealthcareIOError.of(httpBody, new IOException(resource)));\n+        }\n+      }\n+\n+      /**\n+       * Close file.\n+       *\n+       * @param context the context\n+       * @throws IOException the io exception\n+       */\n+      @FinishBundle\n+      public void closeFile(FinishBundleContext context) throws IOException {\n+        // Write the file with all elements in this bundle to GCS.\n+        ndJsonChannel.close();\n+        context.output(resourceId, window.maxTimestamp(), window);\n+      }\n+    }\n+\n+    /** Import batches of new line delimited json files to FHIR Store. */\n+    static class ImportFn\n+        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+      private final String tempGcsPath;\n+      private final String deadLetterGcsPath;\n+      private ResourceId tempDir;\n+      private final ContentStructure contentStructure;\n+      private HealthcareApiClient client;\n+      private final String fhirStore;\n+\n+      ImportFn(\n+          String fhirStore,\n+          String tempGcsPath,\n+          String deadLetterGcsPath,\n+          @Nullable ContentStructure contentStructure) {\n+        this.fhirStore = fhirStore;\n+        this.tempGcsPath = tempGcsPath;\n+        this.deadLetterGcsPath = deadLetterGcsPath;\n+        if (contentStructure == null) {\n+          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+        } else {\n+          this.contentStructure = contentStructure;\n+        }\n+      }\n+\n+      @Setup\n+      public void init() throws IOException {\n+        tempDir =\n+            FileSystems.matchNewResource(tempGcsPath, true)\n+                .resolve(\n+                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                    StandardResolveOptions.RESOLVE_DIRECTORY);\n+        client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+       * GCS URI.\n+       */\n+      @ProcessElement\n+      public void importBatch(\n+          @Element KV<Integer, Iterable<ResourceId>> element,\n+          OutputReceiver<HealthcareIOError<String>> output)\n+          throws IOException {\n+        Iterable<ResourceId> batch = element.getValue();\n+        List<ResourceId> tempDestinations = new ArrayList<>();\n+        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+        assert batch != null;\n+        for (ResourceId file : batch) {\n+          tempDestinations.add(\n+              tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+          deadLetterDestinations.add(\n+              FileSystems.matchNewResource(deadLetterGcsPath, true)\n+                  .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+        }\n+        FileSystems.copy(ImmutableList.copyOf(batch), tempDestinations);\n+        ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n+        try {\n+          // Blocking fhirStores.import request.\n+          assert contentStructure != null;\n+          Operation operation =\n+              client.importFhirResource(fhirStore, importUri.toString(), contentStructure.name());\n+          client.pollOperation(operation, 500L);\n+          // Clean up temp files on GCS as they we successfully imported to FHIR store and no longer\n+          // needed.\n+          FileSystems.delete(tempDestinations);\n+        } catch (IOException | InterruptedException e) {\n+          ResourceId deadLetterResourceId = FileSystems.matchNewResource(deadLetterGcsPath, true);\n+          LOG.warn(\n+              String.format(\n+                  \"Failed to import %s with error: %s. Moving to deadletter path %s\",\n+                  importUri.toString(), e.getMessage(), deadLetterResourceId.toString()));\n+          FileSystems.rename(tempDestinations, deadLetterDestinations);\n+          output.output(HealthcareIOError.of(importUri.toString(), e));\n+        } finally {\n+          // If we've reached this point files have either been successfully import to FHIR store\n+          // or moved to Dead Letter Queue.\n+          // Clean up original files for this batch on GCS.\n+          FileSystems.delete(ImmutableList.copyOf(batch));\n+        }\n+      }\n+    }\n+\n+    /** The enum Content structure. */\n+    public enum ContentStructure {\n+      /** If the content structure is not specified, the default value BUNDLE will be used. */\n+      CONTENT_STRUCTURE_UNSPECIFIED,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a bundle, which contains one or more resources. Set the bundle type to history to import\n+       * resource versions.\n+       */\n+      BUNDLE,\n+      /**\n+       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+       * a single resource.\n+       */\n+      RESOURCE,\n+      /** The entire file is one JSON bundle. The JSON can span multiple lines. */\n+      BUNDLE_PRETTY,\n+      /** The entire file is one JSON resource. The JSON can span multiple lines. */\n+      RESOURCE_PRETTY\n+    }\n+  }\n+\n+  /** The type Execute bundles. */\n+  public static class ExecuteBundles extends PTransform<PCollection<String>, Write.Result> {\n+    private final String fhirStore;\n+\n+    /**\n+     * Instantiates a new Execute bundles.\n+     *\n+     * @param fhirStore the fhir store\n+     */\n+    ExecuteBundles(ValueProvider<String> fhirStore) {\n+      this.fhirStore = fhirStore.get();\n+    }\n+\n+    /**\n+     * Instantiates a new Execute bundles.\n+     *\n+     * @param fhirStore the fhir store\n+     */\n+    ExecuteBundles(String fhirStore) {\n+      this.fhirStore = fhirStore;\n+    }\n+\n+    @Override\n+    public FhirIO.Write.Result expand(PCollection<String> input) {\n+      return Write.Result.in(\n+          input.getPipeline(),\n+          input\n+              .apply(ParDo.of(new ExecuteBundlesFn(fhirStore)))\n+              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+    }\n+\n+    /** The type Write Fhir fn. */\n+    static class ExecuteBundlesFn extends DoFn<String, HealthcareIOError<String>> {\n+\n+      private Counter failedBundles = Metrics.counter(ExecuteBundlesFn.class, \"failed-bundles\");\n+      private transient HealthcareApiClient client;\n+      private final ObjectMapper mapper = new ObjectMapper();\n+      /** The Fhir store. */\n+      private final String fhirStore;\n+\n+      /**\n+       * Instantiates a new Write Fhir fn.\n+       *\n+       * @param fhirStore the Fhir store\n+       */\n+      ExecuteBundlesFn(String fhirStore) {\n+        this.fhirStore = fhirStore;\n+      }\n+\n+      /**\n+       * Initialize healthcare client.\n+       *\n+       * @throws IOException the io exception\n+       */\n+      @Setup\n+      public void initClient() throws IOException {\n+        this.client = new HttpHealthcareApiClient();\n+      }\n+\n+      /**\n+       * Execute Bundles.\n+       *\n+       * @param context the context\n+       */\n+      @ProcessElement\n+      public void executeBundles(ProcessContext context) {\n+        String body = context.element();\n+        try {\n+          // Validate that data was set to valid JSON.\n+          mapper.readTree(body);\n+          client.executeFhirBundle(fhirStore, body);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0ODUyMw=="}, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 1099}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDY3NTAwOnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2MessageCoder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMTozODoxOVrOGUZ4RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoxOToxMVrOGVCDMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0ODcwOA==", "bodyText": "Howcome you receive a class but ignore it?", "url": "https://github.com/apache/beam/pull/11339#discussion_r424048708", "createdAt": "2020-05-12T21:38:19Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2MessageCoder.java", "diffHunk": "@@ -29,7 +29,15 @@\n import org.apache.beam.sdk.coders.StringUtf8Coder;\n \n public class HL7v2MessageCoder extends CustomCoder<HL7v2Message> {\n-  public HL7v2MessageCoder() {}\n+  HL7v2MessageCoder() {}\n+\n+  public static HL7v2MessageCoder of() {\n+    return new HL7v2MessageCoder();\n+  }\n+\n+  public static HL7v2MessageCoder of(Class<HL7v2Message> clazz) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA1OTYzNw==", "bodyText": "My understanding was this is necessary in order to use @Default.Coder(HL7v2MessageCoder) decorator on the HL7v2Message class.\nHowever, I forgot to add that decorator so no wonder this looks confusing, good catch!\nhttps://beam.apache.org/documentation/programming-guide/#default-coders-and-the-coderregistry", "url": "https://github.com/apache/beam/pull/11339#discussion_r424059637", "createdAt": "2020-05-12T22:01:58Z", "author": {"login": "jaketf"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2MessageCoder.java", "diffHunk": "@@ -29,7 +29,15 @@\n import org.apache.beam.sdk.coders.StringUtf8Coder;\n \n public class HL7v2MessageCoder extends CustomCoder<HL7v2Message> {\n-  public HL7v2MessageCoder() {}\n+  HL7v2MessageCoder() {}\n+\n+  public static HL7v2MessageCoder of() {\n+    return new HL7v2MessageCoder();\n+  }\n+\n+  public static HL7v2MessageCoder of(Class<HL7v2Message> clazz) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0ODcwOA=="}, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwNjg2NA==", "bodyText": "Ah you're right  : ) - cool.", "url": "https://github.com/apache/beam/pull/11339#discussion_r424706864", "createdAt": "2020-05-13T20:19:11Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HL7v2MessageCoder.java", "diffHunk": "@@ -29,7 +29,15 @@\n import org.apache.beam.sdk.coders.StringUtf8Coder;\n \n public class HL7v2MessageCoder extends CustomCoder<HL7v2Message> {\n-  public HL7v2MessageCoder() {}\n+  HL7v2MessageCoder() {}\n+\n+  public static HL7v2MessageCoder of() {\n+    return new HL7v2MessageCoder();\n+  }\n+\n+  public static HL7v2MessageCoder of(Class<HL7v2Message> clazz) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0ODcwOA=="}, "originalCommit": {"oid": "2cb05a65fa6f94f72e922f4e810f99368c52c03d"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDc5NjUyOnYy", "diffSide": "RIGHT", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDozNTowMlrOGVCjYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDozNTowMlrOGVCjYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxNTEwNw==", "bodyText": "This is providing a static key, not a key-generating function, right?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                              WithKeys.of(ThreadLocalRandom.current().nextInt(0, numShards)))\n          \n          \n            \n                              WithKeys.of(elm -> ThreadLocalRandom.current().nextInt(0, numShards)))\n          \n      \n    \n    \n  \n\n(I think)", "url": "https://github.com/apache/beam/pull/11339#discussion_r424715107", "createdAt": "2020-05-13T20:35:02Z", "author": {"login": "pabloem"}, "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -0,0 +1,1144 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.healthcare;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkState;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.api.services.healthcare.v1beta1.model.HttpBody;\n+import com.google.api.services.healthcare.v1beta1.model.Operation;\n+import com.google.auto.value.AutoValue;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VoidCoder;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.EmptyMatchTreatment;\n+import org.apache.beam.sdk.io.fs.MatchResult.Metadata;\n+import org.apache.beam.sdk.io.fs.MoveOptions.StandardMoveOptions;\n+import org.apache.beam.sdk.io.fs.ResolveOptions.StandardResolveOptions;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.io.gcp.healthcare.HttpHealthcareApiClient.HealthcareHttpException;\n+import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.Wait;\n+import org.apache.beam.sdk.transforms.WithKeys;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollection.IsBounded;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.PInput;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.PValue;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Throwables;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link FhirIO} provides an API for reading and writing resources to <a\n+ * href=\"https://cloud.google.com/healthcare/docs/concepts/fhir\">Google Cloud Healthcare Fhir API.\n+ * </a>\n+ *\n+ * <h3>Reading</h3>\n+ *\n+ * <p>FHIR resources can be read with {@link FhirIO.Read}, which supports use cases where you have a\n+ * ${@link PCollection} of message IDS. This is appropriate for reading the Fhir notifications from\n+ * a Pub/Sub subscription with {@link PubsubIO#readStrings()} or in cases where you have a manually\n+ * prepared list of messages that you need to process (e.g. in a text file read with {@link\n+ * org.apache.beam.sdk.io.TextIO}*) .\n+ *\n+ * <p>Fetch Resource contents from Fhir Store based on the {@link PCollection} of message ID strings\n+ * {@link FhirIO.Read.Result} where one can call {@link Read.Result#getResources()} to retrieve a\n+ * {@link PCollection} containing the successfully fetched {@link String}s and/or {@link\n+ * FhirIO.Read.Result#getFailedReads()}* to retrieve a {@link PCollection} of {@link\n+ * HealthcareIOError}* containing the resource ID that could not be fetched and the exception as a\n+ * {@link HealthcareIOError}, this can be used to write to the dead letter storage system of your\n+ * choosing. This error handling is mainly to transparently surface errors where the upstream {@link\n+ * PCollection}* contains IDs that are not valid or are not reachable due to permissions issues.\n+ *\n+ * <h3>Writing</h3>\n+ *\n+ * <p>Write Resources can be written to FHIR with two different methods: Import or Execute Bundle.\n+ *\n+ * <p>Execute Bundle This is best for use cases where you are writing to a non-empty FHIR store with\n+ * other clients or otherwise need referential integrity (e.g. A Streaming HL7v2 to FHIR ETL\n+ * pipeline).\n+ *\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>\n+ *     <p>Import This is best for use cases where you are populating an empty FHIR store with no\n+ *     other clients. It is faster than the execute bundles method but does not respect referential\n+ *     integrity and the resources are not written transactionally (e.g. a historicaly backfill on a\n+ *     new FHIR store) This requires each resource to contain a client provided ID. It is important\n+ *     that when using import you give the appropriate permissions to the Google Cloud Healthcare\n+ *     Service Agent\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions></a>\n+ * @see <a\n+ *     href=>https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>\n+ *     A {@link PCollection} of {@link String} can be ingested into an Fhir store using {@link\n+ *     FhirIO.Write#fhirStoresImport(String, String, String, FhirIO.Import.ContentStructure)} This\n+ *     will return a {@link FhirIO.Write.Result} on which you can call {@link\n+ *     FhirIO.Write.Result#getFailedBodies()} to retrieve a {@link PCollection} of {@link\n+ *     HealthcareIOError} containing the {@link String} that failed to be ingested and the\n+ *     exception.\n+ *     <p>Example\n+ *     <pre>{@code\n+ * Pipeline pipeline = ...\n+ *\n+ * // Tail the FHIR store by retrieving resources based on Pub/Sub notifications.\n+ * FhirIO.Read.Result readResult = p\n+ *   .apply(\"Read FHIR notifications\",\n+ *     PubsubIO.readStrings().fromSubscription(options.getNotificationSubscription()))\n+ *   .apply(FhirIO.readResources());\n+ *\n+ * // happily retrived messages\n+ * PCollection<String> resources = readResult.getResources();\n+ * // message IDs that couldn't be retrieved + error context\n+ * PCollection<HealthcareIOError<String>> failedReads = readResult.getFailedReads();\n+ *\n+ * failedReads.apply(\"Write Message IDs / Stacktrace for Failed Reads to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * output = resources.apply(\"Happy path transformations\", ...);\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Execute FHIR Bundles\", FhirIO.executeBundles(options.getExistingFhirStore()));\n+ *\n+ * PCollection<HealthcareIOError<String>> failedBundles = writeResult.getFailedInsertsWithErr();\n+ *\n+ * failedBundles.apply(\"Write failed bundles to BigQuery\",\n+ *     BigQueryIO\n+ *         .write()\n+ *         .to(option.getBQFhirExecuteBundlesDeadLetterTable())\n+ *         .withFormatFunction(new HealthcareIOErrorToTableRow()));\n+ *\n+ * // Alternatively you could use import for high throughput to a new store.\n+ * FhirIO.Write.Result writeResult =\n+ *     output.apply(\"Import FHIR Resources\", FhirIO.executeBundles(options.getNewFhirStore()));\n+ * }***\n+ * </pre>\n+ */\n+public class FhirIO {\n+\n+  /**\n+   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+   * notifications)\n+   *\n+   * @return the read\n+   * @see Read\n+   */\n+  public static Read readResources() {\n+    return new Read();\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      String fhirStore,\n+      String tempDir,\n+      String deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /**\n+   * Import resources. Intended for use on empty FHIR stores\n+   *\n+   * @param fhirStore the fhir store\n+   * @param tempDir the temp dir\n+   * @param deadLetterDir the dead letter dir\n+   * @param contentStructure the content structure\n+   * @return the import\n+   * @see Import\n+   */\n+  public static Import importResources(\n+      ValueProvider<String> fhirStore,\n+      ValueProvider<String> tempDir,\n+      ValueProvider<String> deadLetterDir,\n+      @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+  }\n+\n+  /** The type Read. */\n+  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n+\n+    /** Instantiates a new Read. */\n+    public Read() {}\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedReads;\n+      /** The Pct. */\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+       *\n+       * @param pct the pct\n+       * @return the read result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+            .keySet()\n+            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Read.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedReads =\n+            pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed reads.\n+       *\n+       * @return the failed reads\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedReads() {\n+        return failedReads;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Read.Result expand(PCollection<String> input) {\n+      return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n+    }\n+\n+    /**\n+     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+     * store, and fetches the actual {@link String} object based on the id in the notification and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    static class FetchResourceJsonString\n+        extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+      /** Instantiates a new Fetch Fhir message DoFn. */\n+      public FetchResourceJsonString() {}\n+\n+      @Override\n+      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+        return new FhirIO.Read.Result(\n+            resourceIds.apply(\n+                ParDo.of(new ReadResourceFn())\n+                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for fetching messages from the Fhir store with error handling. */\n+      static class ReadResourceFn extends DoFn<String, String> {\n+\n+        private Counter failedMessageGets =\n+            Metrics.counter(ReadResourceFn.class, \"failed-message-reads\");\n+        private static final Logger LOG = LoggerFactory.getLogger(ReadResourceFn.class);\n+        private final Counter successfulStringGets =\n+            Metrics.counter(ReadResourceFn.class, \"successful-hl7v2-message-gets\");\n+        private HealthcareApiClient client;\n+        private ObjectMapper mapper;\n+\n+        /** Instantiates a new Hl 7 v 2 message get fn. */\n+        ReadResourceFn() {}\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+          this.mapper = new ObjectMapper();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          String resourceId = context.element();\n+          try {\n+            context.output(fetchResource(this.client, resourceId));\n+          } catch (Exception e) {\n+            failedMessageGets.inc();\n+            LOG.warn(\n+                String.format(\n+                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                        + \"Queue. Cause: %s Stack Trace: %s\",\n+                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+          }\n+        }\n+\n+        private String fetchResource(HealthcareApiClient client, String resourceId)\n+            throws IOException, IllegalArgumentException {\n+          long startTime = System.currentTimeMillis();\n+\n+          HttpBody resource = client.readFhirResource(resourceId);\n+\n+          if (resource == null) {\n+            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+          }\n+          this.successfulStringGets.inc();\n+          return mapper.writeValueAsString(resource);\n+        }\n+      }\n+    }\n+  }\n+\n+  /** The type Write. */\n+  @AutoValue\n+  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n+\n+    /** The tag for the failed writes to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for the files that failed to FHIR store`. */\n+    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+        new TupleTag<HealthcareIOError<String>>() {};\n+    /** The tag for temp files for import to FHIR store`. */\n+    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n+\n+    /** The enum Write method. */\n+    public enum WriteMethod {\n+      /**\n+       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+       */\n+      EXECUTE_BUNDLE,\n+      /**\n+       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+       * FHIR stores. <a\n+       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+       */\n+      IMPORT\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput {\n+      private final Pipeline pipeline;\n+      private final PCollection<HealthcareIOError<String>> failedBodies;\n+      private final PCollection<HealthcareIOError<String>> failedFiles;\n+\n+      /**\n+       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+       * pipeline\n+       *\n+       * @param failedBodies the failed inserts\n+       * @return the result\n+       */\n+      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedBodies) {\n+        return new Result(pipeline, failedBodies, null);\n+      }\n+\n+      static Result in(\n+          Pipeline pipeline,\n+          PCollection<HealthcareIOError<String>> failedBodies,\n+          PCollection<HealthcareIOError<String>> failedFiles) {\n+        return new Result(pipeline, failedBodies, failedFiles);\n+      }\n+\n+      /**\n+       * Gets failed bodies with err.\n+       *\n+       * @return the failed inserts with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedBodies() {\n+        return this.failedBodies;\n+      }\n+\n+      /**\n+       * Gets failed file imports with err.\n+       *\n+       * @return the failed GCS uri with err\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedFiles() {\n+        return this.failedFiles;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pipeline;\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(Write.FAILED_BODY, failedBodies, Write.FAILED_FILES, failedFiles);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+          String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+      private Result(\n+          Pipeline pipeline,\n+          PCollection<HealthcareIOError<String>> failedBodies,\n+          @Nullable PCollection<HealthcareIOError<String>> failedFiles) {\n+        this.pipeline = pipeline;\n+        this.failedBodies = failedBodies;\n+        if (failedFiles == null) {\n+          failedFiles =\n+              (PCollection<HealthcareIOError<String>>)\n+                  pipeline.apply(Create.empty(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+        }\n+        this.failedFiles = failedFiles;\n+      }\n+    }\n+\n+    /**\n+     * Gets Fhir store.\n+     *\n+     * @return the Fhir store\n+     */\n+    abstract String getFhirStore();\n+\n+    /**\n+     * Gets write method.\n+     *\n+     * @return the write method\n+     */\n+    abstract WriteMethod getWriteMethod();\n+\n+    /**\n+     * Gets content structure.\n+     *\n+     * @return the content structure\n+     */\n+    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+\n+    /**\n+     * Gets import gcs temp path.\n+     *\n+     * @return the import gcs temp path\n+     */\n+    abstract Optional<String> getImportGcsTempPath();\n+\n+    /**\n+     * Gets import gcs dead letter path.\n+     *\n+     * @return the import gcs dead letter path\n+     */\n+    abstract Optional<String> getImportGcsDeadLetterPath();\n+\n+    /** The type Builder. */\n+    @AutoValue.Builder\n+    abstract static class Builder {\n+\n+      /**\n+       * Sets Fhir store.\n+       *\n+       * @param fhirStore the Fhir store\n+       * @return the Fhir store\n+       */\n+      abstract Builder setFhirStore(String fhirStore);\n+\n+      /**\n+       * Sets write method.\n+       *\n+       * @param writeMethod the write method\n+       * @return the write method\n+       */\n+      abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+      /**\n+       * Sets content structure.\n+       *\n+       * @param contentStructure the content structure\n+       * @return the content structure\n+       */\n+      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+      /**\n+       * Sets import gcs temp path.\n+       *\n+       * @param gcsTempPath the gcs temp path\n+       * @return the import gcs temp path\n+       */\n+      abstract Builder setImportGcsTempPath(String gcsTempPath);\n+\n+      /**\n+       * Sets import gcs dead letter path.\n+       *\n+       * @param gcsDeadLetterPath the gcs dead letter path\n+       * @return the import gcs dead letter path\n+       */\n+      abstract Builder setImportGcsDeadLetterPath(String gcsDeadLetterPath);\n+\n+      /**\n+       * Build write.\n+       *\n+       * @return the write\n+       */\n+      abstract Write build();\n+    }\n+\n+    private static Write.Builder write(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder().setFhirStore(fhirStore);\n+    }\n+\n+    /**\n+     * Create Method creates a single FHIR resource. @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @param gcsTempPath the gcs temp path\n+     * @param gcsDeadLetterPath the gcs dead letter path\n+     * @param contentStructure the content structure\n+     * @return the write\n+     */\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsTempPath,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    public static Write fhirStoresImport(\n+        String fhirStore,\n+        String gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+          .build();\n+    }\n+\n+    public static Write fhirStoresImport(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> gcsTempPath,\n+        ValueProvider<String> gcsDeadLetterPath,\n+        @Nullable FhirIO.Import.ContentStructure contentStructure) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(Write.WriteMethod.IMPORT)\n+          .setContentStructure(contentStructure)\n+          .setImportGcsTempPath(gcsTempPath.get())\n+          .setImportGcsDeadLetterPath(gcsDeadLetterPath.get())\n+          .build();\n+    }\n+\n+    /**\n+     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     *\n+     * @param fhirStore the hl 7 v 2 store\n+     * @return the write\n+     */\n+    public static Write executeBundles(String fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore)\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    /**\n+     * Execute bundles write.\n+     *\n+     * @param fhirStore the fhir store\n+     * @return the write\n+     */\n+    public static Write executeBundles(ValueProvider<String> fhirStore) {\n+      return new AutoValue_FhirIO_Write.Builder()\n+          .setFhirStore(fhirStore.get())\n+          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+          .build();\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+    @Override\n+    public Result expand(PCollection<String> input) {\n+      PCollection<HealthcareIOError<String>> failedBundles;\n+      PCollection<HealthcareIOError<String>> failedImports;\n+      switch (this.getWriteMethod()) {\n+        case IMPORT:\n+          LOG.warn(\n+              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+          String deadPath = getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+          FhirIO.Import.ContentStructure contentStructure =\n+              getContentStructure().orElseThrow(IllegalArgumentException::new);\n+          String tempPath =\n+              getImportGcsTempPath().orElse(input.getPipeline().getOptions().getTempLocation());\n+\n+          return input.apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure));\n+        case EXECUTE_BUNDLE:\n+        default:\n+          failedBundles =\n+              input\n+                  .apply(\n+                      \"Execute FHIR Bundles\",\n+                      ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())))\n+                  .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+      return Result.in(input.getPipeline(), failedBundles);\n+    }\n+  }\n+\n+  /**\n+   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+   * fhirStores.import Request for that file. This is intended for batch use only to facilitate\n+   * large backfills to empty FHIR stores and should not be used with unbounded PCollections. If\n+   * your use case is streaming checkout using {@link ExecuteBundles} to more safely execute bundles\n+   * as transactions which is safer practice for a use on a \"live\" FHIR store.\n+   */\n+  public static class Import extends Write {\n+\n+    private final String fhirStore;\n+    private final String deadLetterGcsPath;\n+    private final ContentStructure contentStructure;\n+    private static final int DEFAULT_FILES_PER_BATCH = 10000;\n+    private static final Logger LOG = LoggerFactory.getLogger(Import.class);\n+    private String tempGcsPath;\n+\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> tempGcsPath,\n+        ValueProvider<String> deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore.get();\n+      this.tempGcsPath = tempGcsPath.get();\n+      this.deadLetterGcsPath = deadLetterGcsPath.get();\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    Import(\n+        ValueProvider<String> fhirStore,\n+        ValueProvider<String> deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore.get();\n+      this.deadLetterGcsPath = deadLetterGcsPath.get();\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+    /**\n+     * Instantiates a new Import.\n+     *\n+     * @param fhirStore the fhir store\n+     * @param tempGcsPath the temp gcs path\n+     * @param deadLetterGcsPath the dead letter gcs path\n+     * @param contentStructure the content structure\n+     */\n+    Import(\n+        String fhirStore,\n+        String tempGcsPath,\n+        String deadLetterGcsPath,\n+        @Nullable ContentStructure contentStructure) {\n+      this.fhirStore = fhirStore;\n+      this.tempGcsPath = tempGcsPath;\n+      this.deadLetterGcsPath = deadLetterGcsPath;\n+      if (contentStructure == null) {\n+        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+      } else {\n+        this.contentStructure = contentStructure;\n+      }\n+    }\n+\n+    @Override\n+    String getFhirStore() {\n+      return fhirStore;\n+    }\n+\n+    @Override\n+    WriteMethod getWriteMethod() {\n+      return WriteMethod.IMPORT;\n+    }\n+\n+    @Override\n+    Optional<ContentStructure> getContentStructure() {\n+      return Optional.of(contentStructure);\n+    }\n+\n+    @Override\n+    Optional<String> getImportGcsTempPath() {\n+      return Optional.of(tempGcsPath);\n+    }\n+\n+    @Override\n+    Optional<String> getImportGcsDeadLetterPath() {\n+      return Optional.of(deadLetterGcsPath);\n+    }\n+\n+    @Override\n+    public Write.Result expand(PCollection<String> input) {\n+      checkState(\n+          input.isBounded() == IsBounded.BOUNDED,\n+          \"FhirIO.Import should only be used on unbounded PCollections as it is\"\n+              + \"intended for batch use only.\");\n+\n+      // fall back on pipeline's temp location.\n+      String tempPath = tempGcsPath;\n+      if (tempPath == null) {\n+        tempPath = input.getPipeline().getOptions().getTempLocation();\n+      }\n+\n+      // Write bundles of String to GCS\n+      PCollectionTuple writeTmpFileResults =\n+          input.apply(\n+              \"Write nd json to GCS\",\n+              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempPath, deadLetterGcsPath))\n+                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+      PCollection<HealthcareIOError<String>> failedBodies =\n+          writeTmpFileResults\n+              .get(Write.FAILED_BODY)\n+              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      int numShards = 100;\n+      PCollection<HealthcareIOError<String>> failedFiles =\n+          writeTmpFileResults\n+              .get(Write.TEMP_FILES)\n+              .apply(\n+                  \"Shard files\", // to paralelize group into batches\n+                  WithKeys.of(ThreadLocalRandom.current().nextInt(0, numShards)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b19ae11ec1c4d4c5535303eb852bfd019bf68717"}, "originalPosition": 820}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1418, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}