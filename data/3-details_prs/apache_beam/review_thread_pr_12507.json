{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0OTM1NDA0", "number": 12507, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoxMDo0MVrOEW54Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODozMTowNFrOEXvz7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDUyNDE4OnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSqlCalciteTranslationUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoxMDo0MVrOG-Zycw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyNTozMFrOG-aRRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA4NzQxMQ==", "bodyText": "I believe a single column with an empty name is allowed. ZetaSQL allows multiple columns without names.", "url": "https://github.com/apache/beam/pull/12507#discussion_r468087411", "createdAt": "2020-08-10T18:10:41Z", "author": {"login": "apilloud"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSqlCalciteTranslationUtils.java", "diffHunk": "@@ -17,174 +17,333 @@\n  */\n package org.apache.beam.sdk.extensions.sql.zetasql;\n \n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_BOOL;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_BYTES;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_DATE;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_DATETIME;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_DOUBLE;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_INT64;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_NUMERIC;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_STRING;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_TIME;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_TIMESTAMP;\n-import static java.util.stream.Collectors.toList;\n-\n-import com.google.zetasql.ArrayType;\n+import com.google.zetasql.CivilTimeEncoder;\n import com.google.zetasql.StructType;\n import com.google.zetasql.StructType.StructField;\n import com.google.zetasql.Type;\n import com.google.zetasql.TypeFactory;\n+import com.google.zetasql.Value;\n import com.google.zetasql.ZetaSQLType.TypeKind;\n+import com.google.zetasql.functions.ZetaSQLDateTime.DateTimestampPart;\n+import java.math.BigDecimal;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n import java.util.List;\n-import java.util.function.Function;\n+import java.util.stream.Collectors;\n import org.apache.beam.sdk.annotations.Internal;\n+import org.apache.beam.sdk.extensions.sql.meta.provider.bigquery.BeamBigQuerySqlDialect;\n+import org.apache.beam.sdk.extensions.sql.zetasql.translation.SqlOperators;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.avatica.util.ByteString;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.avatica.util.TimeUnit;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.avatica.util.TimeUnitRange;\n import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataType;\n import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexBuilder;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexNode;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.fun.SqlStdOperatorTable;\n import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.util.DateString;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.util.TimeString;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.util.TimestampString;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n \n /**\n  * Utility methods for ZetaSQL <=> Calcite translation.\n  *\n- * <p>Unsupported ZetaSQL types: INT32, UINT32, UINT64, FLOAT, ENUM, PROTO, GEOGRAPHY\n+ * <p>Unsupported ZetaSQL types: INT32, UINT32, UINT64, FLOAT, ENUM (internal), PROTO, GEOGRAPHY\n  */\n @Internal\n public final class ZetaSqlCalciteTranslationUtils {\n \n   private ZetaSqlCalciteTranslationUtils() {}\n \n+  // TODO[BEAM-9178]: support DateTimestampPart.WEEK and \"WEEK with weekday\"s\n+  private static final ImmutableMap<Integer, TimeUnit> TIME_UNIT_CASTING_MAP =\n+      ImmutableMap.<Integer, TimeUnit>builder()\n+          .put(DateTimestampPart.YEAR.getNumber(), TimeUnit.YEAR)\n+          .put(DateTimestampPart.MONTH.getNumber(), TimeUnit.MONTH)\n+          .put(DateTimestampPart.DAY.getNumber(), TimeUnit.DAY)\n+          .put(DateTimestampPart.DAYOFWEEK.getNumber(), TimeUnit.DOW)\n+          .put(DateTimestampPart.DAYOFYEAR.getNumber(), TimeUnit.DOY)\n+          .put(DateTimestampPart.QUARTER.getNumber(), TimeUnit.QUARTER)\n+          .put(DateTimestampPart.HOUR.getNumber(), TimeUnit.HOUR)\n+          .put(DateTimestampPart.MINUTE.getNumber(), TimeUnit.MINUTE)\n+          .put(DateTimestampPart.SECOND.getNumber(), TimeUnit.SECOND)\n+          .put(DateTimestampPart.MILLISECOND.getNumber(), TimeUnit.MILLISECOND)\n+          .put(DateTimestampPart.MICROSECOND.getNumber(), TimeUnit.MICROSECOND)\n+          .put(DateTimestampPart.ISOYEAR.getNumber(), TimeUnit.ISOYEAR)\n+          .put(DateTimestampPart.ISOWEEK.getNumber(), TimeUnit.WEEK)\n+          .build();\n+\n   // Type conversion: Calcite => ZetaSQL\n-  public static Type toZetaType(RelDataType calciteType) {\n+  public static Type toZetaSqlType(RelDataType calciteType) {\n     switch (calciteType.getSqlTypeName()) {\n       case BIGINT:\n-        return TypeFactory.createSimpleType(TYPE_INT64);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_INT64);\n       case DOUBLE:\n-        return TypeFactory.createSimpleType(TYPE_DOUBLE);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_DOUBLE);\n       case BOOLEAN:\n-        return TypeFactory.createSimpleType(TYPE_BOOL);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_BOOL);\n       case VARCHAR:\n-        return TypeFactory.createSimpleType(TYPE_STRING);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_STRING);\n       case VARBINARY:\n-        return TypeFactory.createSimpleType(TYPE_BYTES);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_BYTES);\n       case DECIMAL:\n-        return TypeFactory.createSimpleType(TYPE_NUMERIC);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_NUMERIC);\n       case DATE:\n-        return TypeFactory.createSimpleType(TYPE_DATE);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_DATE);\n       case TIME:\n-        return TypeFactory.createSimpleType(TYPE_TIME);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_TIME);\n       case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n-        return TypeFactory.createSimpleType(TYPE_DATETIME);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_DATETIME);\n       case TIMESTAMP:\n-        return TypeFactory.createSimpleType(TYPE_TIMESTAMP);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_TIMESTAMP);\n       case ARRAY:\n-        return TypeFactory.createArrayType(toZetaType(calciteType.getComponentType()));\n+        return TypeFactory.createArrayType(toZetaSqlType(calciteType.getComponentType()));\n       case ROW:\n-        List<StructField> structFields =\n+        return TypeFactory.createStructType(\n             calciteType.getFieldList().stream()\n-                .map(f -> new StructField(f.getName(), toZetaType(f.getType())))\n-                .collect(toList());\n-\n-        return TypeFactory.createStructType(structFields);\n+                .map(f -> new StructField(f.getName(), toZetaSqlType(f.getType())))\n+                .collect(Collectors.toList()));\n       default:\n-        throw new UnsupportedOperationException(\"Unsupported RelDataType: \" + calciteType);\n+        throw new UnsupportedOperationException(\n+            \"Unknown Calcite type: \" + calciteType.getSqlTypeName().getName());\n     }\n   }\n \n   // Type conversion: ZetaSQL => Calcite\n-  public static SqlTypeName toCalciteTypeName(TypeKind type) {\n-    switch (type) {\n+  public static RelDataType toCalciteType(Type type, boolean nullable, RexBuilder rexBuilder) {\n+    RelDataType nonNullType;\n+    switch (type.getKind()) {\n       case TYPE_INT64:\n-        return SqlTypeName.BIGINT;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.BIGINT);\n+        break;\n       case TYPE_DOUBLE:\n-        return SqlTypeName.DOUBLE;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.DOUBLE);\n+        break;\n       case TYPE_BOOL:\n-        return SqlTypeName.BOOLEAN;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.BOOLEAN);\n+        break;\n       case TYPE_STRING:\n-        return SqlTypeName.VARCHAR;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.VARCHAR);\n+        break;\n       case TYPE_BYTES:\n-        return SqlTypeName.VARBINARY;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.VARBINARY);\n+        break;\n       case TYPE_NUMERIC:\n-        return SqlTypeName.DECIMAL;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.DECIMAL);\n+        break;\n       case TYPE_DATE:\n-        return SqlTypeName.DATE;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.DATE);\n+        break;\n       case TYPE_TIME:\n-        return SqlTypeName.TIME;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.TIME);\n+        break;\n       case TYPE_DATETIME:\n-        return SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE;\n+        nonNullType =\n+            rexBuilder.getTypeFactory().createSqlType(SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE);\n+        break;\n       case TYPE_TIMESTAMP:\n-        // TODO: handle timestamp with time zone.\n-        return SqlTypeName.TIMESTAMP;\n-        // TODO[BEAM-9179] Add conversion code for ARRAY and ROW types\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.TIMESTAMP);\n+        break;\n+      case TYPE_ARRAY:\n+        // TODO: Should element type has the same nullability as the array type?\n+        nonNullType = toCalciteArrayType(type.asArray().getElementType(), nullable, rexBuilder);\n+        break;\n+      case TYPE_STRUCT:\n+        // TODO: Should field type has the same nullability as the struct type?\n+        nonNullType = toCalciteStructType(type.asStruct(), nullable, rexBuilder);\n+        break;\n       default:\n-        throw new UnsupportedOperationException(\"Unknown ZetaSQL type: \" + type.name());\n+        throw new UnsupportedOperationException(\"Unknown ZetaSQL type: \" + type.getKind().name());\n     }\n+    return rexBuilder.getTypeFactory().createTypeWithNullability(nonNullType, nullable);\n   }\n \n-  public static RelDataType toRelDataType(RexBuilder rexBuilder, Type type, boolean isNullable) {\n-    if (type.getKind().equals(TypeKind.TYPE_ARRAY)) {\n-      return toArrayRelDataType(rexBuilder, type.asArray(), isNullable);\n-    } else if (type.getKind().equals(TypeKind.TYPE_STRUCT)) {\n-      return toStructRelDataType(rexBuilder, type.asStruct(), isNullable);\n-    } else {\n-      // TODO: Check type's nullability?\n-      return toSimpleRelDataType(type.getKind(), rexBuilder, isNullable);\n-    }\n+  private static RelDataType toCalciteArrayType(\n+      Type elementType, boolean nullable, RexBuilder rexBuilder) {\n+    return rexBuilder\n+        .getTypeFactory()\n+        // -1 cardinality means unlimited array size\n+        .createArrayType(toCalciteType(elementType, nullable, rexBuilder), -1);\n   }\n \n-  public static RelDataType toArrayRelDataType(\n-      RexBuilder rexBuilder, ArrayType arrayType, boolean isNullable) {\n-    // -1 cardinality means unlimited array size.\n-    // TODO: is unlimited array size right for general case?\n-    // TODO: whether isNullable should be ArrayType's nullablity (not its element type's?)\n-    return nullable(\n-        rexBuilder,\n-        rexBuilder\n-            .getTypeFactory()\n-            .createArrayType(toRelDataType(rexBuilder, arrayType.getElementType(), isNullable), -1),\n-        isNullable);\n+  private static RelDataType toCalciteStructType(\n+      StructType structType, boolean nullable, RexBuilder rexBuilder) {\n+    List<StructField> fields = structType.getFieldList();\n+    List<String> fieldNames = getFieldNameList(fields);\n+    List<RelDataType> fieldTypes =\n+        fields.stream()\n+            .map(f -> toCalciteType(f.getType(), nullable, rexBuilder))\n+            .collect(Collectors.toList());\n+    return rexBuilder.getTypeFactory().createStructType(fieldTypes, fieldNames);\n   }\n \n-  private static List<String> toNameList(List<StructField> fields) {\n+  private static List<String> getFieldNameList(List<StructField> fields) {\n     ImmutableList.Builder<String> b = ImmutableList.builder();\n     for (int i = 0; i < fields.size(); i++) {\n       String name = fields.get(i).getName();\n       if (\"\".equals(name)) {\n-        name = \"$col\" + i;\n+        name = \"$col\" + i; // empty field name is not allowed, generate an index-based name for it", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79d69f4f425b150cfa57a8688227463d569aec89"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NTMwMQ==", "bodyText": "Yeah this comment is not accurate. The real problem is Beam does not allow multiple columns with the same name (empty in this case). Thanks for spotting this.", "url": "https://github.com/apache/beam/pull/12507#discussion_r468095301", "createdAt": "2020-08-10T18:25:30Z", "author": {"login": "robinyqiu"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSqlCalciteTranslationUtils.java", "diffHunk": "@@ -17,174 +17,333 @@\n  */\n package org.apache.beam.sdk.extensions.sql.zetasql;\n \n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_BOOL;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_BYTES;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_DATE;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_DATETIME;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_DOUBLE;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_INT64;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_NUMERIC;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_STRING;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_TIME;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_TIMESTAMP;\n-import static java.util.stream.Collectors.toList;\n-\n-import com.google.zetasql.ArrayType;\n+import com.google.zetasql.CivilTimeEncoder;\n import com.google.zetasql.StructType;\n import com.google.zetasql.StructType.StructField;\n import com.google.zetasql.Type;\n import com.google.zetasql.TypeFactory;\n+import com.google.zetasql.Value;\n import com.google.zetasql.ZetaSQLType.TypeKind;\n+import com.google.zetasql.functions.ZetaSQLDateTime.DateTimestampPart;\n+import java.math.BigDecimal;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n import java.util.List;\n-import java.util.function.Function;\n+import java.util.stream.Collectors;\n import org.apache.beam.sdk.annotations.Internal;\n+import org.apache.beam.sdk.extensions.sql.meta.provider.bigquery.BeamBigQuerySqlDialect;\n+import org.apache.beam.sdk.extensions.sql.zetasql.translation.SqlOperators;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.avatica.util.ByteString;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.avatica.util.TimeUnit;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.avatica.util.TimeUnitRange;\n import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataType;\n import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexBuilder;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexNode;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.fun.SqlStdOperatorTable;\n import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.util.DateString;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.util.TimeString;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.util.TimestampString;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n \n /**\n  * Utility methods for ZetaSQL <=> Calcite translation.\n  *\n- * <p>Unsupported ZetaSQL types: INT32, UINT32, UINT64, FLOAT, ENUM, PROTO, GEOGRAPHY\n+ * <p>Unsupported ZetaSQL types: INT32, UINT32, UINT64, FLOAT, ENUM (internal), PROTO, GEOGRAPHY\n  */\n @Internal\n public final class ZetaSqlCalciteTranslationUtils {\n \n   private ZetaSqlCalciteTranslationUtils() {}\n \n+  // TODO[BEAM-9178]: support DateTimestampPart.WEEK and \"WEEK with weekday\"s\n+  private static final ImmutableMap<Integer, TimeUnit> TIME_UNIT_CASTING_MAP =\n+      ImmutableMap.<Integer, TimeUnit>builder()\n+          .put(DateTimestampPart.YEAR.getNumber(), TimeUnit.YEAR)\n+          .put(DateTimestampPart.MONTH.getNumber(), TimeUnit.MONTH)\n+          .put(DateTimestampPart.DAY.getNumber(), TimeUnit.DAY)\n+          .put(DateTimestampPart.DAYOFWEEK.getNumber(), TimeUnit.DOW)\n+          .put(DateTimestampPart.DAYOFYEAR.getNumber(), TimeUnit.DOY)\n+          .put(DateTimestampPart.QUARTER.getNumber(), TimeUnit.QUARTER)\n+          .put(DateTimestampPart.HOUR.getNumber(), TimeUnit.HOUR)\n+          .put(DateTimestampPart.MINUTE.getNumber(), TimeUnit.MINUTE)\n+          .put(DateTimestampPart.SECOND.getNumber(), TimeUnit.SECOND)\n+          .put(DateTimestampPart.MILLISECOND.getNumber(), TimeUnit.MILLISECOND)\n+          .put(DateTimestampPart.MICROSECOND.getNumber(), TimeUnit.MICROSECOND)\n+          .put(DateTimestampPart.ISOYEAR.getNumber(), TimeUnit.ISOYEAR)\n+          .put(DateTimestampPart.ISOWEEK.getNumber(), TimeUnit.WEEK)\n+          .build();\n+\n   // Type conversion: Calcite => ZetaSQL\n-  public static Type toZetaType(RelDataType calciteType) {\n+  public static Type toZetaSqlType(RelDataType calciteType) {\n     switch (calciteType.getSqlTypeName()) {\n       case BIGINT:\n-        return TypeFactory.createSimpleType(TYPE_INT64);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_INT64);\n       case DOUBLE:\n-        return TypeFactory.createSimpleType(TYPE_DOUBLE);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_DOUBLE);\n       case BOOLEAN:\n-        return TypeFactory.createSimpleType(TYPE_BOOL);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_BOOL);\n       case VARCHAR:\n-        return TypeFactory.createSimpleType(TYPE_STRING);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_STRING);\n       case VARBINARY:\n-        return TypeFactory.createSimpleType(TYPE_BYTES);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_BYTES);\n       case DECIMAL:\n-        return TypeFactory.createSimpleType(TYPE_NUMERIC);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_NUMERIC);\n       case DATE:\n-        return TypeFactory.createSimpleType(TYPE_DATE);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_DATE);\n       case TIME:\n-        return TypeFactory.createSimpleType(TYPE_TIME);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_TIME);\n       case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n-        return TypeFactory.createSimpleType(TYPE_DATETIME);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_DATETIME);\n       case TIMESTAMP:\n-        return TypeFactory.createSimpleType(TYPE_TIMESTAMP);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_TIMESTAMP);\n       case ARRAY:\n-        return TypeFactory.createArrayType(toZetaType(calciteType.getComponentType()));\n+        return TypeFactory.createArrayType(toZetaSqlType(calciteType.getComponentType()));\n       case ROW:\n-        List<StructField> structFields =\n+        return TypeFactory.createStructType(\n             calciteType.getFieldList().stream()\n-                .map(f -> new StructField(f.getName(), toZetaType(f.getType())))\n-                .collect(toList());\n-\n-        return TypeFactory.createStructType(structFields);\n+                .map(f -> new StructField(f.getName(), toZetaSqlType(f.getType())))\n+                .collect(Collectors.toList()));\n       default:\n-        throw new UnsupportedOperationException(\"Unsupported RelDataType: \" + calciteType);\n+        throw new UnsupportedOperationException(\n+            \"Unknown Calcite type: \" + calciteType.getSqlTypeName().getName());\n     }\n   }\n \n   // Type conversion: ZetaSQL => Calcite\n-  public static SqlTypeName toCalciteTypeName(TypeKind type) {\n-    switch (type) {\n+  public static RelDataType toCalciteType(Type type, boolean nullable, RexBuilder rexBuilder) {\n+    RelDataType nonNullType;\n+    switch (type.getKind()) {\n       case TYPE_INT64:\n-        return SqlTypeName.BIGINT;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.BIGINT);\n+        break;\n       case TYPE_DOUBLE:\n-        return SqlTypeName.DOUBLE;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.DOUBLE);\n+        break;\n       case TYPE_BOOL:\n-        return SqlTypeName.BOOLEAN;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.BOOLEAN);\n+        break;\n       case TYPE_STRING:\n-        return SqlTypeName.VARCHAR;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.VARCHAR);\n+        break;\n       case TYPE_BYTES:\n-        return SqlTypeName.VARBINARY;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.VARBINARY);\n+        break;\n       case TYPE_NUMERIC:\n-        return SqlTypeName.DECIMAL;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.DECIMAL);\n+        break;\n       case TYPE_DATE:\n-        return SqlTypeName.DATE;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.DATE);\n+        break;\n       case TYPE_TIME:\n-        return SqlTypeName.TIME;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.TIME);\n+        break;\n       case TYPE_DATETIME:\n-        return SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE;\n+        nonNullType =\n+            rexBuilder.getTypeFactory().createSqlType(SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE);\n+        break;\n       case TYPE_TIMESTAMP:\n-        // TODO: handle timestamp with time zone.\n-        return SqlTypeName.TIMESTAMP;\n-        // TODO[BEAM-9179] Add conversion code for ARRAY and ROW types\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.TIMESTAMP);\n+        break;\n+      case TYPE_ARRAY:\n+        // TODO: Should element type has the same nullability as the array type?\n+        nonNullType = toCalciteArrayType(type.asArray().getElementType(), nullable, rexBuilder);\n+        break;\n+      case TYPE_STRUCT:\n+        // TODO: Should field type has the same nullability as the struct type?\n+        nonNullType = toCalciteStructType(type.asStruct(), nullable, rexBuilder);\n+        break;\n       default:\n-        throw new UnsupportedOperationException(\"Unknown ZetaSQL type: \" + type.name());\n+        throw new UnsupportedOperationException(\"Unknown ZetaSQL type: \" + type.getKind().name());\n     }\n+    return rexBuilder.getTypeFactory().createTypeWithNullability(nonNullType, nullable);\n   }\n \n-  public static RelDataType toRelDataType(RexBuilder rexBuilder, Type type, boolean isNullable) {\n-    if (type.getKind().equals(TypeKind.TYPE_ARRAY)) {\n-      return toArrayRelDataType(rexBuilder, type.asArray(), isNullable);\n-    } else if (type.getKind().equals(TypeKind.TYPE_STRUCT)) {\n-      return toStructRelDataType(rexBuilder, type.asStruct(), isNullable);\n-    } else {\n-      // TODO: Check type's nullability?\n-      return toSimpleRelDataType(type.getKind(), rexBuilder, isNullable);\n-    }\n+  private static RelDataType toCalciteArrayType(\n+      Type elementType, boolean nullable, RexBuilder rexBuilder) {\n+    return rexBuilder\n+        .getTypeFactory()\n+        // -1 cardinality means unlimited array size\n+        .createArrayType(toCalciteType(elementType, nullable, rexBuilder), -1);\n   }\n \n-  public static RelDataType toArrayRelDataType(\n-      RexBuilder rexBuilder, ArrayType arrayType, boolean isNullable) {\n-    // -1 cardinality means unlimited array size.\n-    // TODO: is unlimited array size right for general case?\n-    // TODO: whether isNullable should be ArrayType's nullablity (not its element type's?)\n-    return nullable(\n-        rexBuilder,\n-        rexBuilder\n-            .getTypeFactory()\n-            .createArrayType(toRelDataType(rexBuilder, arrayType.getElementType(), isNullable), -1),\n-        isNullable);\n+  private static RelDataType toCalciteStructType(\n+      StructType structType, boolean nullable, RexBuilder rexBuilder) {\n+    List<StructField> fields = structType.getFieldList();\n+    List<String> fieldNames = getFieldNameList(fields);\n+    List<RelDataType> fieldTypes =\n+        fields.stream()\n+            .map(f -> toCalciteType(f.getType(), nullable, rexBuilder))\n+            .collect(Collectors.toList());\n+    return rexBuilder.getTypeFactory().createStructType(fieldTypes, fieldNames);\n   }\n \n-  private static List<String> toNameList(List<StructField> fields) {\n+  private static List<String> getFieldNameList(List<StructField> fields) {\n     ImmutableList.Builder<String> b = ImmutableList.builder();\n     for (int i = 0; i < fields.size(); i++) {\n       String name = fields.get(i).getName();\n       if (\"\".equals(name)) {\n-        name = \"$col\" + i;\n+        name = \"$col\" + i; // empty field name is not allowed, generate an index-based name for it", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA4NzQxMQ=="}, "originalCommit": {"oid": "79d69f4f425b150cfa57a8688227463d569aec89"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzM2MDQ0OnYy", "diffSide": "RIGHT", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSqlCalciteTranslationUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODozMTowNFrOG_thRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODozMTowNFrOG_thRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1OTI3MA==", "bodyText": "This LOC specified the return STRUCT type explicitly, so Calcite does not need to infer. Adding this line introduced a bug, because later when the schema is translated to Beam Schema, duplicate field names will be caught. #12550 fixes this bug.\n@apilloud", "url": "https://github.com/apache/beam/pull/12507#discussion_r469459270", "createdAt": "2020-08-12T18:31:04Z", "author": {"login": "robinyqiu"}, "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSqlCalciteTranslationUtils.java", "diffHunk": "@@ -17,174 +17,333 @@\n  */\n package org.apache.beam.sdk.extensions.sql.zetasql;\n \n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_BOOL;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_BYTES;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_DATE;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_DATETIME;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_DOUBLE;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_INT64;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_NUMERIC;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_STRING;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_TIME;\n-import static com.google.zetasql.ZetaSQLType.TypeKind.TYPE_TIMESTAMP;\n-import static java.util.stream.Collectors.toList;\n-\n-import com.google.zetasql.ArrayType;\n+import com.google.zetasql.CivilTimeEncoder;\n import com.google.zetasql.StructType;\n import com.google.zetasql.StructType.StructField;\n import com.google.zetasql.Type;\n import com.google.zetasql.TypeFactory;\n+import com.google.zetasql.Value;\n import com.google.zetasql.ZetaSQLType.TypeKind;\n+import com.google.zetasql.functions.ZetaSQLDateTime.DateTimestampPart;\n+import java.math.BigDecimal;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n import java.util.List;\n-import java.util.function.Function;\n+import java.util.stream.Collectors;\n import org.apache.beam.sdk.annotations.Internal;\n+import org.apache.beam.sdk.extensions.sql.meta.provider.bigquery.BeamBigQuerySqlDialect;\n+import org.apache.beam.sdk.extensions.sql.zetasql.translation.SqlOperators;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.avatica.util.ByteString;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.avatica.util.TimeUnit;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.avatica.util.TimeUnitRange;\n import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataType;\n import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexBuilder;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexNode;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.fun.SqlStdOperatorTable;\n import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.util.DateString;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.util.TimeString;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.util.TimestampString;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n \n /**\n  * Utility methods for ZetaSQL <=> Calcite translation.\n  *\n- * <p>Unsupported ZetaSQL types: INT32, UINT32, UINT64, FLOAT, ENUM, PROTO, GEOGRAPHY\n+ * <p>Unsupported ZetaSQL types: INT32, UINT32, UINT64, FLOAT, ENUM (internal), PROTO, GEOGRAPHY\n  */\n @Internal\n public final class ZetaSqlCalciteTranslationUtils {\n \n   private ZetaSqlCalciteTranslationUtils() {}\n \n+  // TODO[BEAM-9178]: support DateTimestampPart.WEEK and \"WEEK with weekday\"s\n+  private static final ImmutableMap<Integer, TimeUnit> TIME_UNIT_CASTING_MAP =\n+      ImmutableMap.<Integer, TimeUnit>builder()\n+          .put(DateTimestampPart.YEAR.getNumber(), TimeUnit.YEAR)\n+          .put(DateTimestampPart.MONTH.getNumber(), TimeUnit.MONTH)\n+          .put(DateTimestampPart.DAY.getNumber(), TimeUnit.DAY)\n+          .put(DateTimestampPart.DAYOFWEEK.getNumber(), TimeUnit.DOW)\n+          .put(DateTimestampPart.DAYOFYEAR.getNumber(), TimeUnit.DOY)\n+          .put(DateTimestampPart.QUARTER.getNumber(), TimeUnit.QUARTER)\n+          .put(DateTimestampPart.HOUR.getNumber(), TimeUnit.HOUR)\n+          .put(DateTimestampPart.MINUTE.getNumber(), TimeUnit.MINUTE)\n+          .put(DateTimestampPart.SECOND.getNumber(), TimeUnit.SECOND)\n+          .put(DateTimestampPart.MILLISECOND.getNumber(), TimeUnit.MILLISECOND)\n+          .put(DateTimestampPart.MICROSECOND.getNumber(), TimeUnit.MICROSECOND)\n+          .put(DateTimestampPart.ISOYEAR.getNumber(), TimeUnit.ISOYEAR)\n+          .put(DateTimestampPart.ISOWEEK.getNumber(), TimeUnit.WEEK)\n+          .build();\n+\n   // Type conversion: Calcite => ZetaSQL\n-  public static Type toZetaType(RelDataType calciteType) {\n+  public static Type toZetaSqlType(RelDataType calciteType) {\n     switch (calciteType.getSqlTypeName()) {\n       case BIGINT:\n-        return TypeFactory.createSimpleType(TYPE_INT64);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_INT64);\n       case DOUBLE:\n-        return TypeFactory.createSimpleType(TYPE_DOUBLE);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_DOUBLE);\n       case BOOLEAN:\n-        return TypeFactory.createSimpleType(TYPE_BOOL);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_BOOL);\n       case VARCHAR:\n-        return TypeFactory.createSimpleType(TYPE_STRING);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_STRING);\n       case VARBINARY:\n-        return TypeFactory.createSimpleType(TYPE_BYTES);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_BYTES);\n       case DECIMAL:\n-        return TypeFactory.createSimpleType(TYPE_NUMERIC);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_NUMERIC);\n       case DATE:\n-        return TypeFactory.createSimpleType(TYPE_DATE);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_DATE);\n       case TIME:\n-        return TypeFactory.createSimpleType(TYPE_TIME);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_TIME);\n       case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n-        return TypeFactory.createSimpleType(TYPE_DATETIME);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_DATETIME);\n       case TIMESTAMP:\n-        return TypeFactory.createSimpleType(TYPE_TIMESTAMP);\n+        return TypeFactory.createSimpleType(TypeKind.TYPE_TIMESTAMP);\n       case ARRAY:\n-        return TypeFactory.createArrayType(toZetaType(calciteType.getComponentType()));\n+        return TypeFactory.createArrayType(toZetaSqlType(calciteType.getComponentType()));\n       case ROW:\n-        List<StructField> structFields =\n+        return TypeFactory.createStructType(\n             calciteType.getFieldList().stream()\n-                .map(f -> new StructField(f.getName(), toZetaType(f.getType())))\n-                .collect(toList());\n-\n-        return TypeFactory.createStructType(structFields);\n+                .map(f -> new StructField(f.getName(), toZetaSqlType(f.getType())))\n+                .collect(Collectors.toList()));\n       default:\n-        throw new UnsupportedOperationException(\"Unsupported RelDataType: \" + calciteType);\n+        throw new UnsupportedOperationException(\n+            \"Unknown Calcite type: \" + calciteType.getSqlTypeName().getName());\n     }\n   }\n \n   // Type conversion: ZetaSQL => Calcite\n-  public static SqlTypeName toCalciteTypeName(TypeKind type) {\n-    switch (type) {\n+  public static RelDataType toCalciteType(Type type, boolean nullable, RexBuilder rexBuilder) {\n+    RelDataType nonNullType;\n+    switch (type.getKind()) {\n       case TYPE_INT64:\n-        return SqlTypeName.BIGINT;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.BIGINT);\n+        break;\n       case TYPE_DOUBLE:\n-        return SqlTypeName.DOUBLE;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.DOUBLE);\n+        break;\n       case TYPE_BOOL:\n-        return SqlTypeName.BOOLEAN;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.BOOLEAN);\n+        break;\n       case TYPE_STRING:\n-        return SqlTypeName.VARCHAR;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.VARCHAR);\n+        break;\n       case TYPE_BYTES:\n-        return SqlTypeName.VARBINARY;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.VARBINARY);\n+        break;\n       case TYPE_NUMERIC:\n-        return SqlTypeName.DECIMAL;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.DECIMAL);\n+        break;\n       case TYPE_DATE:\n-        return SqlTypeName.DATE;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.DATE);\n+        break;\n       case TYPE_TIME:\n-        return SqlTypeName.TIME;\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.TIME);\n+        break;\n       case TYPE_DATETIME:\n-        return SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE;\n+        nonNullType =\n+            rexBuilder.getTypeFactory().createSqlType(SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE);\n+        break;\n       case TYPE_TIMESTAMP:\n-        // TODO: handle timestamp with time zone.\n-        return SqlTypeName.TIMESTAMP;\n-        // TODO[BEAM-9179] Add conversion code for ARRAY and ROW types\n+        nonNullType = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.TIMESTAMP);\n+        break;\n+      case TYPE_ARRAY:\n+        // TODO: Should element type has the same nullability as the array type?\n+        nonNullType = toCalciteArrayType(type.asArray().getElementType(), nullable, rexBuilder);\n+        break;\n+      case TYPE_STRUCT:\n+        // TODO: Should field type has the same nullability as the struct type?\n+        nonNullType = toCalciteStructType(type.asStruct(), nullable, rexBuilder);\n+        break;\n       default:\n-        throw new UnsupportedOperationException(\"Unknown ZetaSQL type: \" + type.name());\n+        throw new UnsupportedOperationException(\"Unknown ZetaSQL type: \" + type.getKind().name());\n     }\n+    return rexBuilder.getTypeFactory().createTypeWithNullability(nonNullType, nullable);\n   }\n \n-  public static RelDataType toRelDataType(RexBuilder rexBuilder, Type type, boolean isNullable) {\n-    if (type.getKind().equals(TypeKind.TYPE_ARRAY)) {\n-      return toArrayRelDataType(rexBuilder, type.asArray(), isNullable);\n-    } else if (type.getKind().equals(TypeKind.TYPE_STRUCT)) {\n-      return toStructRelDataType(rexBuilder, type.asStruct(), isNullable);\n-    } else {\n-      // TODO: Check type's nullability?\n-      return toSimpleRelDataType(type.getKind(), rexBuilder, isNullable);\n-    }\n+  private static RelDataType toCalciteArrayType(\n+      Type elementType, boolean nullable, RexBuilder rexBuilder) {\n+    return rexBuilder\n+        .getTypeFactory()\n+        // -1 cardinality means unlimited array size\n+        .createArrayType(toCalciteType(elementType, nullable, rexBuilder), -1);\n   }\n \n-  public static RelDataType toArrayRelDataType(\n-      RexBuilder rexBuilder, ArrayType arrayType, boolean isNullable) {\n-    // -1 cardinality means unlimited array size.\n-    // TODO: is unlimited array size right for general case?\n-    // TODO: whether isNullable should be ArrayType's nullablity (not its element type's?)\n-    return nullable(\n-        rexBuilder,\n-        rexBuilder\n-            .getTypeFactory()\n-            .createArrayType(toRelDataType(rexBuilder, arrayType.getElementType(), isNullable), -1),\n-        isNullable);\n+  private static RelDataType toCalciteStructType(\n+      StructType structType, boolean nullable, RexBuilder rexBuilder) {\n+    List<StructField> fields = structType.getFieldList();\n+    List<String> fieldNames = getFieldNameList(fields);\n+    List<RelDataType> fieldTypes =\n+        fields.stream()\n+            .map(f -> toCalciteType(f.getType(), nullable, rexBuilder))\n+            .collect(Collectors.toList());\n+    return rexBuilder.getTypeFactory().createStructType(fieldTypes, fieldNames);\n   }\n \n-  private static List<String> toNameList(List<StructField> fields) {\n+  private static List<String> getFieldNameList(List<StructField> fields) {\n     ImmutableList.Builder<String> b = ImmutableList.builder();\n     for (int i = 0; i < fields.size(); i++) {\n       String name = fields.get(i).getName();\n       if (\"\".equals(name)) {\n-        name = \"$col\" + i;\n+        name = \"$col\" + i; // empty field name is not allowed, generate an index-based name for it\n       }\n       b.add(name);\n     }\n     return b.build();\n   }\n \n-  public static RelDataType toStructRelDataType(\n-      RexBuilder rexBuilder, StructType structType, boolean isNullable) {\n+  // Value conversion: ZetaSQL => Calcite\n+  public static RexNode toRexNode(Value value, RexBuilder rexBuilder) {\n+    Type type = value.getType();\n+    if (value.isNull()) {\n+      return rexBuilder.makeNullLiteral(toCalciteType(type, true, rexBuilder));\n+    }\n \n-    List<StructField> fields = structType.getFieldList();\n-    List<String> fieldNames = toNameList(fields);\n-    List<RelDataType> fieldTypes =\n-        fields.stream()\n-            .map(f -> toRelDataType(rexBuilder, f.getType(), isNullable))\n-            .collect(toList());\n+    switch (type.getKind()) {\n+      case TYPE_INT64:\n+        return rexBuilder.makeExactLiteral(\n+            new BigDecimal(value.getInt64Value()), toCalciteType(type, false, rexBuilder));\n+      case TYPE_DOUBLE:\n+        // Cannot simply call makeApproxLiteral() for ZetaSQL DOUBLE type because positive infinity,\n+        // negative infinity and NaN cannot be directly converted to BigDecimal. So we create three\n+        // wrapper functions here for these three cases such that we can later recognize it and\n+        // customize its unparsing in BeamBigQuerySqlDialect.\n+        double val = value.getDoubleValue();\n+        String wrapperFun = null;\n+        if (val == Double.POSITIVE_INFINITY) {\n+          wrapperFun = BeamBigQuerySqlDialect.DOUBLE_POSITIVE_INF_FUNCTION;\n+        } else if (val == Double.NEGATIVE_INFINITY) {\n+          wrapperFun = BeamBigQuerySqlDialect.DOUBLE_NEGATIVE_INF_FUNCTION;\n+        } else if (Double.isNaN(val)) {\n+          wrapperFun = BeamBigQuerySqlDialect.DOUBLE_NAN_FUNCTION;\n+        }\n \n-    return rexBuilder.getTypeFactory().createStructType(fieldTypes, fieldNames);\n+        RelDataType returnType = toCalciteType(type, false, rexBuilder);\n+        if (wrapperFun == null) {\n+          return rexBuilder.makeApproxLiteral(new BigDecimal(val), returnType);\n+        } else if (BeamBigQuerySqlDialect.DOUBLE_NAN_FUNCTION.equals(wrapperFun)) {\n+          // TODO[BEAM-10550]: Update the temporary workaround below after vendored Calcite version.\n+          // Adding an additional random parameter for the wrapper function of NaN, to avoid\n+          // triggering Calcite operation simplification. (e.g. 'NaN == NaN' would be simplify to\n+          // 'null or NaN is not null' in Calcite. This would miscalculate the expression to be\n+          // true, which should be false.)\n+          return rexBuilder.makeCall(\n+              SqlOperators.createZetaSqlFunction(wrapperFun, returnType.getSqlTypeName()),\n+              rexBuilder.makeApproxLiteral(BigDecimal.valueOf(Math.random()), returnType));\n+        } else {\n+          return rexBuilder.makeCall(\n+              SqlOperators.createZetaSqlFunction(wrapperFun, returnType.getSqlTypeName()));\n+        }\n+      case TYPE_BOOL:\n+        return rexBuilder.makeLiteral(value.getBoolValue());\n+      case TYPE_STRING:\n+        // Has to allow CAST because Calcite create CHAR type first and does a CAST to VARCHAR.\n+        // If not allow cast, rexBuilder() will only build a literal with CHAR type.\n+        return rexBuilder.makeLiteral(\n+            value.getStringValue(), toCalciteType(type, false, rexBuilder), true);\n+      case TYPE_BYTES:\n+        return rexBuilder.makeBinaryLiteral(new ByteString(value.getBytesValue().toByteArray()));\n+      case TYPE_NUMERIC:\n+        // Cannot simply call makeExactLiteral() for ZetaSQL NUMERIC type because later it will be\n+        // unparsed to the string representation of the BigDecimal itself (e.g. \"SELECT NUMERIC '0'\"\n+        // will be unparsed to \"SELECT 0E-9\"), and Calcite does not allow customize unparsing of\n+        // SqlNumericLiteral. So we create a wrapper function here such that we can later recognize\n+        // it and customize its unparsing in BeamBigQuerySqlDialect.\n+        return rexBuilder.makeCall(\n+            SqlOperators.createZetaSqlFunction(\n+                BeamBigQuerySqlDialect.NUMERIC_LITERAL_FUNCTION,\n+                toCalciteType(type, false, rexBuilder).getSqlTypeName()),\n+            rexBuilder.makeExactLiteral(\n+                value.getNumericValue(), toCalciteType(type, false, rexBuilder)));\n+      case TYPE_DATE:\n+        return rexBuilder.makeDateLiteral(dateValueToDateString(value));\n+      case TYPE_TIME:\n+        return rexBuilder.makeTimeLiteral(\n+            timeValueToTimeString(value),\n+            rexBuilder.getTypeFactory().getTypeSystem().getMaxPrecision(SqlTypeName.TIME));\n+      case TYPE_DATETIME:\n+        return rexBuilder.makeTimestampWithLocalTimeZoneLiteral(\n+            datetimeValueToTimestampString(value),\n+            rexBuilder\n+                .getTypeFactory()\n+                .getTypeSystem()\n+                .getMaxPrecision(SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE));\n+      case TYPE_TIMESTAMP:\n+        return rexBuilder.makeTimestampLiteral(\n+            timestampValueToTimestampString(value),\n+            rexBuilder.getTypeFactory().getTypeSystem().getMaxPrecision(SqlTypeName.TIMESTAMP));\n+      case TYPE_ARRAY:\n+        return arrayValueToRexNode(value, rexBuilder);\n+      case TYPE_STRUCT:\n+        return structValueToRexNode(value, rexBuilder);\n+      case TYPE_ENUM: // internal only, used for DateTimestampPart\n+        return enumValueToRexNode(value, rexBuilder);\n+      default:\n+        throw new UnsupportedOperationException(\"Unknown ZetaSQL type: \" + type.getKind().name());\n+    }\n+  }\n+\n+  private static RexNode arrayValueToRexNode(Value value, RexBuilder rexBuilder) {\n+    return rexBuilder.makeCall(\n+        toCalciteArrayType(value.getType().asArray().getElementType(), false, rexBuilder),\n+        SqlStdOperatorTable.ARRAY_VALUE_CONSTRUCTOR,\n+        value.getElementList().stream()\n+            .map(v -> toRexNode(v, rexBuilder))\n+            .collect(Collectors.toList()));\n+  }\n+\n+  private static RexNode structValueToRexNode(Value value, RexBuilder rexBuilder) {\n+    return rexBuilder.makeCall(\n+        toCalciteStructType(value.getType().asStruct(), false, rexBuilder),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79d69f4f425b150cfa57a8688227463d569aec89"}, "originalPosition": 359}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 608, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}