{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1Njg1Mzg4", "number": 12726, "title": "[BEAM-10475] Add max buffering duration to GroupIntoBatches (Java)", "bodyText": "Add an option in GroupIntoBatches interface to allow users to set a timeout for batching. This is useful when there can be incomplete batches, e.g., very few input elements or unbounded input in a global window that might arrive at arbitrary time intervals.\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nDataflow\nFlink\nSamza\nSpark\nTwister2\n\n\n\n\nGo\n\n---\n\n---\n\n---\n\n\nJava\n\n\n\n\n\n\n\n\nPython\n\n\n\n---\n\n---\n\n\nXLang\n\n---\n\n---\n\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\nWhitespace\n\n\n\n\nNon-portable\n\n \n\n\n\n\n\nPortable\n---\n\n---\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.\nGitHub Actions Tests Status (on master branch)\n\n\n\nSee CI.md for more information about GitHub Actions CI.", "createdAt": "2020-08-28T23:53:04Z", "url": "https://github.com/apache/beam/pull/12726", "merged": true, "mergeCommit": {"oid": "18e8da33b5a4aebd69481ce5e326735ec2a4337a"}, "closed": true, "closedAt": "2020-09-14T21:39:58Z", "author": {"login": "nehsyc"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdEWehfgFqTQ3ODgxNDU3Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdI5nnEgFqTQ4ODEzNDkzNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4ODE0NTc3", "url": "https://github.com/apache/beam/pull/12726#pullrequestreview-478814577", "createdAt": "2020-08-31T17:44:10Z", "commit": {"oid": "a0d977fa115a50df77c4e29300f15197321b9540"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo0NDoxMVrOHKCWhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo0NDoxMVrOHKCWhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4NjM0MQ==", "bodyText": "It seems like we want to clear the timer when the flush is triggered by batch size/end of window. I think we can just clear the timer when flushBatch is called by window timer expiration and num >= batchSize.", "url": "https://github.com/apache/beam/pull/12726#discussion_r480286341", "createdAt": "2020-08-31T17:44:11Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/GroupIntoBatches.java", "diffHunk": "@@ -150,70 +184,95 @@ public long apply(long left, long right) {\n               });\n \n       this.keySpec = StateSpecs.value(inputKeyCoder);\n-      // prefetch every 20% of batchSize elements. Do not prefetch if batchSize is too little\n+      // Prefetch every 20% of batchSize elements. Do not prefetch if batchSize is too little\n       this.prefetchFrequency = ((batchSize / 5) <= 1) ? Long.MAX_VALUE : (batchSize / 5);\n     }\n \n     @ProcessElement\n     public void processElement(\n-        @TimerId(END_OF_WINDOW_ID) Timer timer,\n+        @TimerId(END_OF_WINDOW_ID) Timer windowTimer,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer,\n         @StateId(BATCH_ID) BagState<InputT> batch,\n         @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n         @StateId(KEY_ID) ValueState<K> key,\n         @Element KV<K, InputT> element,\n         BoundedWindow window,\n         OutputReceiver<KV<K, Iterable<InputT>>> receiver) {\n-      Instant windowExpires = window.maxTimestamp().plus(allowedLateness);\n-\n-      LOG.debug(\n-          \"*** SET TIMER *** to point in time {} for window {}\",\n-          windowExpires.toString(),\n-          window.toString());\n-      timer.set(windowExpires);\n+      Instant windowEnds = window.maxTimestamp().plus(allowedLateness);\n+      LOG.debug(\"*** SET TIMER *** to point in time {} for window {}\", windowEnds, window);\n+      windowTimer.set(windowEnds);\n       key.write(element.getKey());\n+      LOG.debug(\"*** BATCH *** Add element for window {} \", window);\n       batch.add(element.getValue());\n-      LOG.debug(\"*** BATCH *** Add element for window {} \", window.toString());\n-      // blind add is supported with combiningState\n+      // Blind add is supported with combiningState\n       numElementsInBatch.add(1L);\n+\n       Long num = numElementsInBatch.read();\n+      if (num == 1 && maxBufferingDuration.isLongerThan(Duration.ZERO)) {\n+        // This is the first element in batch. Start counting buffering time if a limit was set.\n+        bufferingTimer.offset(maxBufferingDuration).setRelative();\n+      }\n       if (num % prefetchFrequency == 0) {\n-        // prefetch data and modify batch state (readLater() modifies this)\n+        // Prefetch data and modify batch state (readLater() modifies this)\n         batch.readLater();\n       }\n       if (num >= batchSize) {\n         LOG.debug(\"*** END OF BATCH *** for window {}\", window.toString());\n-        flushBatch(receiver, key, batch, numElementsInBatch);\n+        flushBatch(receiver, key, batch, numElementsInBatch, bufferingTimer);\n       }\n     }\n \n+    @OnTimer(END_OF_BUFFERING_ID)\n+    public void onBufferingTimer(\n+        OutputReceiver<KV<K, Iterable<InputT>>> receiver,\n+        @Timestamp Instant timestamp,\n+        @StateId(KEY_ID) ValueState<K> key,\n+        @StateId(BATCH_ID) BagState<InputT> batch,\n+        @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer) {\n+      LOG.debug(\n+          \"*** END OF BUFFERING *** for timer timestamp {} with buffering duration {}\",\n+          timestamp,\n+          maxBufferingDuration);\n+      flushBatch(receiver, key, batch, numElementsInBatch, bufferingTimer);\n+    }\n+\n     @OnTimer(END_OF_WINDOW_ID)\n-    public void onTimerCallback(\n+    public void onWindowTimer(\n         OutputReceiver<KV<K, Iterable<InputT>>> receiver,\n         @Timestamp Instant timestamp,\n         @StateId(KEY_ID) ValueState<K> key,\n         @StateId(BATCH_ID) BagState<InputT> batch,\n         @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer,\n         BoundedWindow window) {\n       LOG.debug(\n           \"*** END OF WINDOW *** for timer timestamp {} in windows {}\",\n           timestamp,\n           window.toString());\n-      flushBatch(receiver, key, batch, numElementsInBatch);\n+      flushBatch(receiver, key, batch, numElementsInBatch, bufferingTimer);\n     }\n \n     private void flushBatch(\n         OutputReceiver<KV<K, Iterable<InputT>>> receiver,\n         ValueState<K> key,\n         BagState<InputT> batch,\n-        CombiningState<Long, long[], Long> numElementsInBatch) {\n+        CombiningState<Long, long[], Long> numElementsInBatch,\n+        Timer bufferingTimer) {\n       Iterable<InputT> values = batch.read();\n-      // when the timer fires, batch state might be empty\n+      // When the timer fires, batch state might be empty\n       if (!Iterables.isEmpty(values)) {\n         receiver.output(KV.of(key.read(), values));\n       }\n       batch.clear();\n       LOG.debug(\"*** BATCH *** clear\");\n       numElementsInBatch.clear();\n+      // We might reach here due to batch size being reached, window expiration or buffering time\n+      // limit being reached. Reset the buffering timer anyway since the state is empty now. It'll\n+      // be reset again if a new element arrives before the expiration time set here.\n+      if (maxBufferingDuration.isLongerThan(Duration.ZERO)) {\n+        bufferingTimer.offset(maxBufferingDuration).setRelative();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0d977fa115a50df77c4e29300f15197321b9540"}, "originalPosition": 223}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MTUyNTc0", "url": "https://github.com/apache/beam/pull/12726#pullrequestreview-487152574", "createdAt": "2020-09-11T22:14:13Z", "commit": {"oid": "0c30decd9b9b375c0ce2b4d1efe46c770d811d49"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMjoxNDoxNFrOHQvRmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMjoyNjoyN1rOHQvevA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxMzgxOQ==", "bodyText": "Can we use null here?", "url": "https://github.com/apache/beam/pull/12726#discussion_r487313819", "createdAt": "2020-09-11T22:14:14Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/GroupIntoBatches.java", "diffHunk": "@@ -66,25 +68,49 @@\n  *         }\n  *     }}));\n  * </pre>\n+ *\n+ * <p>Example 2 (batch unbounded input in a global window):\n+ *\n+ * <pre>{@code\n+ * PCollection<KV<String, String>> unboundedInput = ...;\n+ * long batchSize = 100L;\n+ * Duration maxBufferingDuration = Duration.standardSeconds(10);\n+ * PCollection<KV<String, Iterable<String>>> batched = unboundedInput\n+ *     .apply(Window.<KV<String, String>>into(new GlobalWindows())\n+ *         .triggering(Repeatedly.forever(AfterPane.elementCountAtLeast(1)))\n+ *         .discardingFiredPanes())\n+ *     .apply(GroupIntoBatches.<String, String>ofSize(batchSize)\n+ *         .withMaxBufferingDuration(maxBufferingDuration));\n+ * }</pre>\n  */\n public class GroupIntoBatches<K, InputT>\n     extends PTransform<PCollection<KV<K, InputT>>, PCollection<KV<K, Iterable<InputT>>>> {\n \n   private final long batchSize;\n+  private final Duration maxBufferingDuration;\n \n-  private GroupIntoBatches(long batchSize) {\n+  private GroupIntoBatches(long batchSize, Duration maxBufferingDuration) {\n     this.batchSize = batchSize;\n+    this.maxBufferingDuration = maxBufferingDuration;\n   }\n \n   public static <K, InputT> GroupIntoBatches<K, InputT> ofSize(long batchSize) {\n-    return new GroupIntoBatches<>(batchSize);\n+    return new GroupIntoBatches<>(batchSize, Duration.ZERO);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c30decd9b9b375c0ce2b4d1efe46c770d811d49"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNDgyOQ==", "bodyText": "If Duration.ZERO is not preferred, we can have a check here.", "url": "https://github.com/apache/beam/pull/12726#discussion_r487314829", "createdAt": "2020-09-11T22:18:02Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/GroupIntoBatches.java", "diffHunk": "@@ -66,25 +68,49 @@\n  *         }\n  *     }}));\n  * </pre>\n+ *\n+ * <p>Example 2 (batch unbounded input in a global window):\n+ *\n+ * <pre>{@code\n+ * PCollection<KV<String, String>> unboundedInput = ...;\n+ * long batchSize = 100L;\n+ * Duration maxBufferingDuration = Duration.standardSeconds(10);\n+ * PCollection<KV<String, Iterable<String>>> batched = unboundedInput\n+ *     .apply(Window.<KV<String, String>>into(new GlobalWindows())\n+ *         .triggering(Repeatedly.forever(AfterPane.elementCountAtLeast(1)))\n+ *         .discardingFiredPanes())\n+ *     .apply(GroupIntoBatches.<String, String>ofSize(batchSize)\n+ *         .withMaxBufferingDuration(maxBufferingDuration));\n+ * }</pre>\n  */\n public class GroupIntoBatches<K, InputT>\n     extends PTransform<PCollection<KV<K, InputT>>, PCollection<KV<K, Iterable<InputT>>>> {\n \n   private final long batchSize;\n+  private final Duration maxBufferingDuration;\n \n-  private GroupIntoBatches(long batchSize) {\n+  private GroupIntoBatches(long batchSize, Duration maxBufferingDuration) {\n     this.batchSize = batchSize;\n+    this.maxBufferingDuration = maxBufferingDuration;\n   }\n \n   public static <K, InputT> GroupIntoBatches<K, InputT> ofSize(long batchSize) {\n-    return new GroupIntoBatches<>(batchSize);\n+    return new GroupIntoBatches<>(batchSize, Duration.ZERO);\n   }\n \n   /** Returns the size of the batch. */\n   public long getBatchSize() {\n     return batchSize;\n   }\n \n+  /**\n+   * Set a time limit (in processing time) on how long an incomplete batch of elements is allowed to\n+   * be buffered. Once a batch is flushed to output, the timer is reset.\n+   */\n+  public GroupIntoBatches<K, InputT> withMaxBufferingDuration(Duration duration) {\n+    return new GroupIntoBatches<>(batchSize, duration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c30decd9b9b375c0ce2b4d1efe46c770d811d49"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNTg1Mg==", "bodyText": "We want to pass bufferingTimer to null when flushBatchis called here since there is no need to clear the bufferTimer when it's fired.", "url": "https://github.com/apache/beam/pull/12726#discussion_r487315852", "createdAt": "2020-09-11T22:21:48Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/GroupIntoBatches.java", "diffHunk": "@@ -150,70 +185,96 @@ public long apply(long left, long right) {\n               });\n \n       this.keySpec = StateSpecs.value(inputKeyCoder);\n-      // prefetch every 20% of batchSize elements. Do not prefetch if batchSize is too little\n+      // Prefetch every 20% of batchSize elements. Do not prefetch if batchSize is too little\n       this.prefetchFrequency = ((batchSize / 5) <= 1) ? Long.MAX_VALUE : (batchSize / 5);\n     }\n \n     @ProcessElement\n     public void processElement(\n-        @TimerId(END_OF_WINDOW_ID) Timer timer,\n+        @TimerId(END_OF_WINDOW_ID) Timer windowTimer,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer,\n         @StateId(BATCH_ID) BagState<InputT> batch,\n         @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n         @StateId(KEY_ID) ValueState<K> key,\n         @Element KV<K, InputT> element,\n         BoundedWindow window,\n         OutputReceiver<KV<K, Iterable<InputT>>> receiver) {\n-      Instant windowExpires = window.maxTimestamp().plus(allowedLateness);\n-\n-      LOG.debug(\n-          \"*** SET TIMER *** to point in time {} for window {}\",\n-          windowExpires.toString(),\n-          window.toString());\n-      timer.set(windowExpires);\n+      Instant windowEnds = window.maxTimestamp().plus(allowedLateness);\n+      LOG.debug(\"*** SET TIMER *** to point in time {} for window {}\", windowEnds, window);\n+      windowTimer.set(windowEnds);\n       key.write(element.getKey());\n+      LOG.debug(\"*** BATCH *** Add element for window {} \", window);\n       batch.add(element.getValue());\n-      LOG.debug(\"*** BATCH *** Add element for window {} \", window.toString());\n-      // blind add is supported with combiningState\n+      // Blind add is supported with combiningState\n       numElementsInBatch.add(1L);\n+\n       Long num = numElementsInBatch.read();\n+      if (num == 1 && maxBufferingDuration.isLongerThan(Duration.ZERO)) {\n+        // This is the first element in batch. Start counting buffering time if a limit was set.\n+        bufferingTimer.offset(maxBufferingDuration).setRelative();\n+      }\n       if (num % prefetchFrequency == 0) {\n-        // prefetch data and modify batch state (readLater() modifies this)\n+        // Prefetch data and modify batch state (readLater() modifies this)\n         batch.readLater();\n       }\n       if (num >= batchSize) {\n         LOG.debug(\"*** END OF BATCH *** for window {}\", window.toString());\n-        flushBatch(receiver, key, batch, numElementsInBatch);\n+        flushBatch(receiver, key, batch, numElementsInBatch, bufferingTimer);\n       }\n     }\n \n+    @OnTimer(END_OF_BUFFERING_ID)\n+    public void onBufferingTimer(\n+        OutputReceiver<KV<K, Iterable<InputT>>> receiver,\n+        @Timestamp Instant timestamp,\n+        @StateId(KEY_ID) ValueState<K> key,\n+        @StateId(BATCH_ID) BagState<InputT> batch,\n+        @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer) {\n+      LOG.debug(\n+          \"*** END OF BUFFERING *** for timer timestamp {} with buffering duration {}\",\n+          timestamp,\n+          maxBufferingDuration);\n+      flushBatch(receiver, key, batch, numElementsInBatch, bufferingTimer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c30decd9b9b375c0ce2b4d1efe46c770d811d49"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNjM1Mw==", "bodyText": "Instead, we want to pass actual bufferingTimer here since we want to clear it.", "url": "https://github.com/apache/beam/pull/12726#discussion_r487316353", "createdAt": "2020-09-11T22:23:37Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/GroupIntoBatches.java", "diffHunk": "@@ -150,70 +185,96 @@ public long apply(long left, long right) {\n               });\n \n       this.keySpec = StateSpecs.value(inputKeyCoder);\n-      // prefetch every 20% of batchSize elements. Do not prefetch if batchSize is too little\n+      // Prefetch every 20% of batchSize elements. Do not prefetch if batchSize is too little\n       this.prefetchFrequency = ((batchSize / 5) <= 1) ? Long.MAX_VALUE : (batchSize / 5);\n     }\n \n     @ProcessElement\n     public void processElement(\n-        @TimerId(END_OF_WINDOW_ID) Timer timer,\n+        @TimerId(END_OF_WINDOW_ID) Timer windowTimer,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer,\n         @StateId(BATCH_ID) BagState<InputT> batch,\n         @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n         @StateId(KEY_ID) ValueState<K> key,\n         @Element KV<K, InputT> element,\n         BoundedWindow window,\n         OutputReceiver<KV<K, Iterable<InputT>>> receiver) {\n-      Instant windowExpires = window.maxTimestamp().plus(allowedLateness);\n-\n-      LOG.debug(\n-          \"*** SET TIMER *** to point in time {} for window {}\",\n-          windowExpires.toString(),\n-          window.toString());\n-      timer.set(windowExpires);\n+      Instant windowEnds = window.maxTimestamp().plus(allowedLateness);\n+      LOG.debug(\"*** SET TIMER *** to point in time {} for window {}\", windowEnds, window);\n+      windowTimer.set(windowEnds);\n       key.write(element.getKey());\n+      LOG.debug(\"*** BATCH *** Add element for window {} \", window);\n       batch.add(element.getValue());\n-      LOG.debug(\"*** BATCH *** Add element for window {} \", window.toString());\n-      // blind add is supported with combiningState\n+      // Blind add is supported with combiningState\n       numElementsInBatch.add(1L);\n+\n       Long num = numElementsInBatch.read();\n+      if (num == 1 && maxBufferingDuration.isLongerThan(Duration.ZERO)) {\n+        // This is the first element in batch. Start counting buffering time if a limit was set.\n+        bufferingTimer.offset(maxBufferingDuration).setRelative();\n+      }\n       if (num % prefetchFrequency == 0) {\n-        // prefetch data and modify batch state (readLater() modifies this)\n+        // Prefetch data and modify batch state (readLater() modifies this)\n         batch.readLater();\n       }\n       if (num >= batchSize) {\n         LOG.debug(\"*** END OF BATCH *** for window {}\", window.toString());\n-        flushBatch(receiver, key, batch, numElementsInBatch);\n+        flushBatch(receiver, key, batch, numElementsInBatch, bufferingTimer);\n       }\n     }\n \n+    @OnTimer(END_OF_BUFFERING_ID)\n+    public void onBufferingTimer(\n+        OutputReceiver<KV<K, Iterable<InputT>>> receiver,\n+        @Timestamp Instant timestamp,\n+        @StateId(KEY_ID) ValueState<K> key,\n+        @StateId(BATCH_ID) BagState<InputT> batch,\n+        @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer) {\n+      LOG.debug(\n+          \"*** END OF BUFFERING *** for timer timestamp {} with buffering duration {}\",\n+          timestamp,\n+          maxBufferingDuration);\n+      flushBatch(receiver, key, batch, numElementsInBatch, bufferingTimer);\n+    }\n+\n     @OnTimer(END_OF_WINDOW_ID)\n-    public void onTimerCallback(\n+    public void onWindowTimer(\n         OutputReceiver<KV<K, Iterable<InputT>>> receiver,\n         @Timestamp Instant timestamp,\n         @StateId(KEY_ID) ValueState<K> key,\n         @StateId(BATCH_ID) BagState<InputT> batch,\n         @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer,\n         BoundedWindow window) {\n       LOG.debug(\n           \"*** END OF WINDOW *** for timer timestamp {} in windows {}\",\n           timestamp,\n           window.toString());\n-      flushBatch(receiver, key, batch, numElementsInBatch);\n+      flushBatch(receiver, key, batch, numElementsInBatch, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c30decd9b9b375c0ce2b4d1efe46c770d811d49"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNzAwMw==", "bodyText": "If we checkArgument(duration != Duration.ZERO) when withMaxBufferingDuration (), then we can drop the check here.", "url": "https://github.com/apache/beam/pull/12726#discussion_r487317003", "createdAt": "2020-09-11T22:25:45Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/GroupIntoBatches.java", "diffHunk": "@@ -150,70 +185,96 @@ public long apply(long left, long right) {\n               });\n \n       this.keySpec = StateSpecs.value(inputKeyCoder);\n-      // prefetch every 20% of batchSize elements. Do not prefetch if batchSize is too little\n+      // Prefetch every 20% of batchSize elements. Do not prefetch if batchSize is too little\n       this.prefetchFrequency = ((batchSize / 5) <= 1) ? Long.MAX_VALUE : (batchSize / 5);\n     }\n \n     @ProcessElement\n     public void processElement(\n-        @TimerId(END_OF_WINDOW_ID) Timer timer,\n+        @TimerId(END_OF_WINDOW_ID) Timer windowTimer,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer,\n         @StateId(BATCH_ID) BagState<InputT> batch,\n         @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n         @StateId(KEY_ID) ValueState<K> key,\n         @Element KV<K, InputT> element,\n         BoundedWindow window,\n         OutputReceiver<KV<K, Iterable<InputT>>> receiver) {\n-      Instant windowExpires = window.maxTimestamp().plus(allowedLateness);\n-\n-      LOG.debug(\n-          \"*** SET TIMER *** to point in time {} for window {}\",\n-          windowExpires.toString(),\n-          window.toString());\n-      timer.set(windowExpires);\n+      Instant windowEnds = window.maxTimestamp().plus(allowedLateness);\n+      LOG.debug(\"*** SET TIMER *** to point in time {} for window {}\", windowEnds, window);\n+      windowTimer.set(windowEnds);\n       key.write(element.getKey());\n+      LOG.debug(\"*** BATCH *** Add element for window {} \", window);\n       batch.add(element.getValue());\n-      LOG.debug(\"*** BATCH *** Add element for window {} \", window.toString());\n-      // blind add is supported with combiningState\n+      // Blind add is supported with combiningState\n       numElementsInBatch.add(1L);\n+\n       Long num = numElementsInBatch.read();\n+      if (num == 1 && maxBufferingDuration.isLongerThan(Duration.ZERO)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c30decd9b9b375c0ce2b4d1efe46c770d811d49"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNzE4MA==", "bodyText": "Same above.", "url": "https://github.com/apache/beam/pull/12726#discussion_r487317180", "createdAt": "2020-09-11T22:26:27Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/GroupIntoBatches.java", "diffHunk": "@@ -150,70 +185,96 @@ public long apply(long left, long right) {\n               });\n \n       this.keySpec = StateSpecs.value(inputKeyCoder);\n-      // prefetch every 20% of batchSize elements. Do not prefetch if batchSize is too little\n+      // Prefetch every 20% of batchSize elements. Do not prefetch if batchSize is too little\n       this.prefetchFrequency = ((batchSize / 5) <= 1) ? Long.MAX_VALUE : (batchSize / 5);\n     }\n \n     @ProcessElement\n     public void processElement(\n-        @TimerId(END_OF_WINDOW_ID) Timer timer,\n+        @TimerId(END_OF_WINDOW_ID) Timer windowTimer,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer,\n         @StateId(BATCH_ID) BagState<InputT> batch,\n         @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n         @StateId(KEY_ID) ValueState<K> key,\n         @Element KV<K, InputT> element,\n         BoundedWindow window,\n         OutputReceiver<KV<K, Iterable<InputT>>> receiver) {\n-      Instant windowExpires = window.maxTimestamp().plus(allowedLateness);\n-\n-      LOG.debug(\n-          \"*** SET TIMER *** to point in time {} for window {}\",\n-          windowExpires.toString(),\n-          window.toString());\n-      timer.set(windowExpires);\n+      Instant windowEnds = window.maxTimestamp().plus(allowedLateness);\n+      LOG.debug(\"*** SET TIMER *** to point in time {} for window {}\", windowEnds, window);\n+      windowTimer.set(windowEnds);\n       key.write(element.getKey());\n+      LOG.debug(\"*** BATCH *** Add element for window {} \", window);\n       batch.add(element.getValue());\n-      LOG.debug(\"*** BATCH *** Add element for window {} \", window.toString());\n-      // blind add is supported with combiningState\n+      // Blind add is supported with combiningState\n       numElementsInBatch.add(1L);\n+\n       Long num = numElementsInBatch.read();\n+      if (num == 1 && maxBufferingDuration.isLongerThan(Duration.ZERO)) {\n+        // This is the first element in batch. Start counting buffering time if a limit was set.\n+        bufferingTimer.offset(maxBufferingDuration).setRelative();\n+      }\n       if (num % prefetchFrequency == 0) {\n-        // prefetch data and modify batch state (readLater() modifies this)\n+        // Prefetch data and modify batch state (readLater() modifies this)\n         batch.readLater();\n       }\n       if (num >= batchSize) {\n         LOG.debug(\"*** END OF BATCH *** for window {}\", window.toString());\n-        flushBatch(receiver, key, batch, numElementsInBatch);\n+        flushBatch(receiver, key, batch, numElementsInBatch, bufferingTimer);\n       }\n     }\n \n+    @OnTimer(END_OF_BUFFERING_ID)\n+    public void onBufferingTimer(\n+        OutputReceiver<KV<K, Iterable<InputT>>> receiver,\n+        @Timestamp Instant timestamp,\n+        @StateId(KEY_ID) ValueState<K> key,\n+        @StateId(BATCH_ID) BagState<InputT> batch,\n+        @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer) {\n+      LOG.debug(\n+          \"*** END OF BUFFERING *** for timer timestamp {} with buffering duration {}\",\n+          timestamp,\n+          maxBufferingDuration);\n+      flushBatch(receiver, key, batch, numElementsInBatch, bufferingTimer);\n+    }\n+\n     @OnTimer(END_OF_WINDOW_ID)\n-    public void onTimerCallback(\n+    public void onWindowTimer(\n         OutputReceiver<KV<K, Iterable<InputT>>> receiver,\n         @Timestamp Instant timestamp,\n         @StateId(KEY_ID) ValueState<K> key,\n         @StateId(BATCH_ID) BagState<InputT> batch,\n         @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer,\n         BoundedWindow window) {\n       LOG.debug(\n           \"*** END OF WINDOW *** for timer timestamp {} in windows {}\",\n           timestamp,\n           window.toString());\n-      flushBatch(receiver, key, batch, numElementsInBatch);\n+      flushBatch(receiver, key, batch, numElementsInBatch, null);\n     }\n \n     private void flushBatch(\n         OutputReceiver<KV<K, Iterable<InputT>>> receiver,\n         ValueState<K> key,\n         BagState<InputT> batch,\n-        CombiningState<Long, long[], Long> numElementsInBatch) {\n+        CombiningState<Long, long[], Long> numElementsInBatch,\n+        @Nullable Timer bufferingTimer) {\n       Iterable<InputT> values = batch.read();\n-      // when the timer fires, batch state might be empty\n+      // When the timer fires, batch state might be empty\n       if (!Iterables.isEmpty(values)) {\n         receiver.output(KV.of(key.read(), values));\n       }\n       batch.clear();\n       LOG.debug(\"*** BATCH *** clear\");\n       numElementsInBatch.clear();\n+      // We might reach here due to batch size being reached or window expiration. Reset the\n+      // buffering timer (if not null) since the state is empty now. It'll be extended again if a\n+      // new element arrives prior to the expiration time set here.\n+      // TODO(BEAM-10887): Use clear() when it's available.\n+      if (bufferingTimer != null && maxBufferingDuration.isLongerThan(Duration.ZERO)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c30decd9b9b375c0ce2b4d1efe46c770d811d49"}, "originalPosition": 231}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad21380ce9969372697192c37d2e3dc62c74d6d9", "author": {"user": {"login": "nehsyc", "name": "Siyuan Chen"}}, "url": "https://github.com/apache/beam/commit/ad21380ce9969372697192c37d2e3dc62c74d6d9", "committedDate": "2020-09-14T17:24:15Z", "message": "Add max buffering duration to GroupIntoBatches"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "480204ea69a3a84c80641fdf18d7e4ddd774f756", "author": {"user": {"login": "nehsyc", "name": "Siyuan Chen"}}, "url": "https://github.com/apache/beam/commit/480204ea69a3a84c80641fdf18d7e4ddd774f756", "committedDate": "2020-09-12T19:53:41Z", "message": "Address comments"}, "afterCommit": {"oid": "ad21380ce9969372697192c37d2e3dc62c74d6d9", "author": {"user": {"login": "nehsyc", "name": "Siyuan Chen"}}, "url": "https://github.com/apache/beam/commit/ad21380ce9969372697192c37d2e3dc62c74d6d9", "committedDate": "2020-09-14T17:24:15Z", "message": "Add max buffering duration to GroupIntoBatches"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MTM0OTM3", "url": "https://github.com/apache/beam/pull/12726#pullrequestreview-488134937", "createdAt": "2020-09-14T20:56:29Z", "commit": {"oid": "ad21380ce9969372697192c37d2e3dc62c74d6d9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4560, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}