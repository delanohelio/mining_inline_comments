{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2ODk5NTk3", "number": 10897, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwMToyMzoyOVrODhSHow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjowMjoyNFrODz8VVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MjI2NDY3OnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwMToyMzoyOVrOFr9r0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwMjozMToxOVrOFsAArQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0MzcyOQ==", "bodyText": "Nice. So looks like we don't have to create new Java transforms to use existing sources ?", "url": "https://github.com/apache/beam/pull/10897#discussion_r381643729", "createdAt": "2020-02-20T01:23:29Z", "author": {"login": "chamikaramj"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -182,6 +198,37 @@ private Unbounded(@Nullable String name, UnboundedSource<T, ?> source) {\n     @Override\n     public final PCollection<T> expand(PBegin input) {\n       source.validate();\n+\n+      if (ExperimentalOptions.hasExperiment(input.getPipeline().getOptions(), \"beam_fn_api\")\n+          && !ExperimentalOptions.hasExperiment(\n+              input.getPipeline().getOptions(), \"beam_fn_api_use_deprecated_read\")) {\n+        // We don't use Create here since Create is defined as a BoundedSource and using it would\n+        // cause an infinite expansion loop. We can reconsider this if Create is implemented\n+        // directly as a SplittableDoFn.\n+        PCollection<ValueWithRecordId<T>> outputWithIds =\n+            input\n+                .getPipeline()\n+                .apply(Impulse.create())\n+                .apply(\n+                    MapElements.into(new TypeDescriptor<UnboundedSource<T, CheckpointMark>>() {})\n+                        .via(element -> (UnboundedSource<T, CheckpointMark>) source))\n+                .setCoder(\n+                    SerializableCoder.of(\n+                        new TypeDescriptor<UnboundedSource<T, CheckpointMark>>() {}))\n+                .apply(\n+                    ParDo.of(\n+                        new UnboundedSourceAsSDFWrapperFn<>(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be048806002c21d086cf729cfbf225d4a1699fd3"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY4MTgzNw==", "bodyText": "Yes, the wrapper is going to convert existing UnboundedSource into SDF.", "url": "https://github.com/apache/beam/pull/10897#discussion_r381681837", "createdAt": "2020-02-20T02:31:19Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -182,6 +198,37 @@ private Unbounded(@Nullable String name, UnboundedSource<T, ?> source) {\n     @Override\n     public final PCollection<T> expand(PBegin input) {\n       source.validate();\n+\n+      if (ExperimentalOptions.hasExperiment(input.getPipeline().getOptions(), \"beam_fn_api\")\n+          && !ExperimentalOptions.hasExperiment(\n+              input.getPipeline().getOptions(), \"beam_fn_api_use_deprecated_read\")) {\n+        // We don't use Create here since Create is defined as a BoundedSource and using it would\n+        // cause an infinite expansion loop. We can reconsider this if Create is implemented\n+        // directly as a SplittableDoFn.\n+        PCollection<ValueWithRecordId<T>> outputWithIds =\n+            input\n+                .getPipeline()\n+                .apply(Impulse.create())\n+                .apply(\n+                    MapElements.into(new TypeDescriptor<UnboundedSource<T, CheckpointMark>>() {})\n+                        .via(element -> (UnboundedSource<T, CheckpointMark>) source))\n+                .setCoder(\n+                    SerializableCoder.of(\n+                        new TypeDescriptor<UnboundedSource<T, CheckpointMark>>() {}))\n+                .apply(\n+                    ParDo.of(\n+                        new UnboundedSourceAsSDFWrapperFn<>(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0MzcyOQ=="}, "originalCommit": {"oid": "be048806002c21d086cf729cfbf225d4a1699fd3"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Mjk3NjMzOnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMjowMDo1M1rOFu97-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMTozOTozMlrOFvChHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc5MzU5Mw==", "bodyText": "It seems the risk is higher setting this too low than too high--maybe 100 or more? (Is there a JIRA for letting the runner pass this in?)", "url": "https://github.com/apache/beam/pull/10897#discussion_r384793593", "createdAt": "2020-02-26T22:00:53Z", "author": {"login": "robertwb"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -375,4 +422,361 @@ public void checkDone() throws IllegalStateException {\n       }\n     }\n   }\n+\n+  /**\n+   * A splittable {@link DoFn} which executes an {@link UnboundedSource}.\n+   *\n+   * <p>We model the element as the original source and the restriction as a pair of the sub-source\n+   * and its {@link CheckpointMark}. This allows us to split the sub-source over and over as long as\n+   * the checkpoint mark is {@code null} or the {@link NoopCheckpointMark} since it does not\n+   * maintain any state.\n+   */\n+  // TODO: Support reporting the watermark, currently the watermark never advances.\n+  @UnboundedPerElement\n+  static class UnboundedSourceAsSDFWrapperFn<OutputT, CheckpointT extends CheckpointMark>\n+      extends DoFn<UnboundedSource<OutputT, CheckpointT>, ValueWithRecordId<OutputT>> {\n+\n+    private static final int DEFAULT_DESIRED_NUM_SPLITS = 20;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "228e5844a5022439cc048b19f070e1561b8ec94f"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2ODYzOA==", "bodyText": "The default in Dataflow is 4 * first non-null of (maxNumWorkers, numWorkers, 5):\n\n  \n    \n      beam/runners/google-cloud-dataflow-java/src/main/java/org/apache/beam/runners/dataflow/internal/CustomSources.java\n    \n    \n         Line 51\n      in\n      860131b\n    \n    \n    \n    \n\n        \n          \n           private static int getDesiredNumUnboundedSourceSplits(DataflowPipelineOptions options) { \n        \n    \n  \n\n (I like the TODO in the method)\nWhich is why I went with 20 as the default.", "url": "https://github.com/apache/beam/pull/10897#discussion_r384868638", "createdAt": "2020-02-27T01:39:32Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -375,4 +422,361 @@ public void checkDone() throws IllegalStateException {\n       }\n     }\n   }\n+\n+  /**\n+   * A splittable {@link DoFn} which executes an {@link UnboundedSource}.\n+   *\n+   * <p>We model the element as the original source and the restriction as a pair of the sub-source\n+   * and its {@link CheckpointMark}. This allows us to split the sub-source over and over as long as\n+   * the checkpoint mark is {@code null} or the {@link NoopCheckpointMark} since it does not\n+   * maintain any state.\n+   */\n+  // TODO: Support reporting the watermark, currently the watermark never advances.\n+  @UnboundedPerElement\n+  static class UnboundedSourceAsSDFWrapperFn<OutputT, CheckpointT extends CheckpointMark>\n+      extends DoFn<UnboundedSource<OutputT, CheckpointT>, ValueWithRecordId<OutputT>> {\n+\n+    private static final int DEFAULT_DESIRED_NUM_SPLITS = 20;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc5MzU5Mw=="}, "originalCommit": {"oid": "228e5844a5022439cc048b19f070e1561b8ec94f"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MzE0NzU0OnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMzowMTo0NFrOFu_kgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMTozOTo1OVrOFvChgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyMDM1NA==", "bodyText": "Is \"named tuple\" also java terminology, or should this be a POJO?", "url": "https://github.com/apache/beam/pull/10897#discussion_r384820354", "createdAt": "2020-02-26T23:01:44Z", "author": {"login": "robertwb"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -375,4 +422,361 @@ public void checkDone() throws IllegalStateException {\n       }\n     }\n   }\n+\n+  /**\n+   * A splittable {@link DoFn} which executes an {@link UnboundedSource}.\n+   *\n+   * <p>We model the element as the original source and the restriction as a pair of the sub-source\n+   * and its {@link CheckpointMark}. This allows us to split the sub-source over and over as long as\n+   * the checkpoint mark is {@code null} or the {@link NoopCheckpointMark} since it does not\n+   * maintain any state.\n+   */\n+  // TODO: Support reporting the watermark, currently the watermark never advances.\n+  @UnboundedPerElement\n+  static class UnboundedSourceAsSDFWrapperFn<OutputT, CheckpointT extends CheckpointMark>\n+      extends DoFn<UnboundedSource<OutputT, CheckpointT>, ValueWithRecordId<OutputT>> {\n+\n+    private static final int DEFAULT_DESIRED_NUM_SPLITS = 20;\n+    private static final int DEFAULT_BUNDLE_FINALIZATION_LIMIT_MINS = 10;\n+    private final Coder<CheckpointT> restrictionCoder;\n+\n+    private UnboundedSourceAsSDFWrapperFn(Coder<CheckpointT> restrictionCoder) {\n+      this.restrictionCoder = restrictionCoder;\n+    }\n+\n+    @GetInitialRestriction\n+    public KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> initialRestriction(\n+        @Element UnboundedSource<OutputT, CheckpointT> element) {\n+      return KV.of(element, null);\n+    }\n+\n+    @GetSize\n+    public double getSize(\n+        @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+        PipelineOptions pipelineOptions)\n+        throws Exception {\n+      if (restriction.getKey() instanceof EmptyUnboundedSource) {\n+        return 1;\n+      }\n+\n+      UnboundedReader<OutputT> reader =\n+          restriction.getKey().createReader(pipelineOptions, restriction.getValue());\n+      long size = reader.getSplitBacklogBytes();\n+      if (size != UnboundedReader.BACKLOG_UNKNOWN) {\n+        return size;\n+      }\n+      // TODO: Support \"global\" backlog reporting\n+      // size = reader.getTotalBacklogBytes();\n+      // if (size != UnboundedReader.BACKLOG_UNKNOWN) {\n+      //   return size;\n+      // }\n+      return 1;\n+    }\n+\n+    @SplitRestriction\n+    public void splitRestriction(\n+        @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+        OutputReceiver<KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>> receiver,\n+        PipelineOptions pipelineOptions)\n+        throws Exception {\n+      // The empty unbounded source is trivially done and hence we don't need to output any splits\n+      // for it.\n+      if (restriction.getKey() instanceof EmptyUnboundedSource) {\n+        return;\n+      }\n+\n+      // The UnboundedSource API does not support splitting after a meaningful checkpoint mark has\n+      // been created.\n+      if (restriction.getValue() != null\n+          && !(restriction.getValue()\n+              instanceof UnboundedSource.CheckpointMark.NoopCheckpointMark)) {\n+        receiver.output(restriction);\n+      }\n+\n+      try {\n+        for (UnboundedSource<OutputT, CheckpointT> split :\n+            restriction.getKey().split(DEFAULT_DESIRED_NUM_SPLITS, pipelineOptions)) {\n+          receiver.output(KV.of(split, null));\n+        }\n+      } catch (Exception e) {\n+        receiver.output(restriction);\n+      }\n+    }\n+\n+    @NewTracker\n+    public RestrictionTracker<\n+            KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>, UnboundedSourceValue<OutputT>[]>\n+        restrictionTracker(\n+            @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+            PipelineOptions pipelineOptions) {\n+      return new UnboundedSourceAsSDFRestrictionTracker(restriction, pipelineOptions);\n+    }\n+\n+    @ProcessElement\n+    public ProcessContinuation processElement(\n+        RestrictionTracker<\n+                KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>, UnboundedSourceValue[]>\n+            tracker,\n+        OutputReceiver<ValueWithRecordId<OutputT>> receiver,\n+        BundleFinalizer bundleFinalizer)\n+        throws IOException {\n+      UnboundedSourceValue<OutputT>[] out = new UnboundedSourceValue[1];\n+      while (tracker.tryClaim(out)) {\n+        receiver.outputWithTimestamp(\n+            new ValueWithRecordId<>(out[0].getValue(), out[0].getId()), out[0].getTimestamp());\n+      }\n+\n+      // Add the checkpoint mark to be finalized if the checkpoint mark isn't trivial.\n+      KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> currentRestriction =\n+          tracker.currentRestriction();\n+      if (currentRestriction.getValue() != null\n+          && !(tracker.currentRestriction().getValue() instanceof NoopCheckpointMark)) {\n+        bundleFinalizer.afterBundleCommit(\n+            Instant.now().plus(Duration.standardMinutes(DEFAULT_BUNDLE_FINALIZATION_LIMIT_MINS)),\n+            currentRestriction.getValue()::finalizeCheckpoint);\n+      }\n+\n+      // If we have been split/checkpoint by a runner, the tracker will have been updated to the\n+      // empty source and we will return stop. Otherwise the unbounded source has only temporarily\n+      // run out of work.\n+      if (tracker.currentRestriction().getKey() instanceof EmptyUnboundedSource) {\n+        return ProcessContinuation.stop();\n+      }\n+      return ProcessContinuation.resume();\n+    }\n+\n+    @GetRestrictionCoder\n+    public Coder<KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>> restrictionCoder() {\n+      return KvCoder.of(\n+          SerializableCoder.of(new TypeDescriptor<UnboundedSource<OutputT, CheckpointT>>() {}),\n+          NullableCoder.of(restrictionCoder));\n+    }\n+\n+    /**\n+     * A named tuple representing all the values we need to pass between the {@link UnboundedReader}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "228e5844a5022439cc048b19f070e1561b8ec94f"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2ODczNg==", "bodyText": "not really, borrowed it from python, will fix.", "url": "https://github.com/apache/beam/pull/10897#discussion_r384868736", "createdAt": "2020-02-27T01:39:59Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -375,4 +422,361 @@ public void checkDone() throws IllegalStateException {\n       }\n     }\n   }\n+\n+  /**\n+   * A splittable {@link DoFn} which executes an {@link UnboundedSource}.\n+   *\n+   * <p>We model the element as the original source and the restriction as a pair of the sub-source\n+   * and its {@link CheckpointMark}. This allows us to split the sub-source over and over as long as\n+   * the checkpoint mark is {@code null} or the {@link NoopCheckpointMark} since it does not\n+   * maintain any state.\n+   */\n+  // TODO: Support reporting the watermark, currently the watermark never advances.\n+  @UnboundedPerElement\n+  static class UnboundedSourceAsSDFWrapperFn<OutputT, CheckpointT extends CheckpointMark>\n+      extends DoFn<UnboundedSource<OutputT, CheckpointT>, ValueWithRecordId<OutputT>> {\n+\n+    private static final int DEFAULT_DESIRED_NUM_SPLITS = 20;\n+    private static final int DEFAULT_BUNDLE_FINALIZATION_LIMIT_MINS = 10;\n+    private final Coder<CheckpointT> restrictionCoder;\n+\n+    private UnboundedSourceAsSDFWrapperFn(Coder<CheckpointT> restrictionCoder) {\n+      this.restrictionCoder = restrictionCoder;\n+    }\n+\n+    @GetInitialRestriction\n+    public KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> initialRestriction(\n+        @Element UnboundedSource<OutputT, CheckpointT> element) {\n+      return KV.of(element, null);\n+    }\n+\n+    @GetSize\n+    public double getSize(\n+        @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+        PipelineOptions pipelineOptions)\n+        throws Exception {\n+      if (restriction.getKey() instanceof EmptyUnboundedSource) {\n+        return 1;\n+      }\n+\n+      UnboundedReader<OutputT> reader =\n+          restriction.getKey().createReader(pipelineOptions, restriction.getValue());\n+      long size = reader.getSplitBacklogBytes();\n+      if (size != UnboundedReader.BACKLOG_UNKNOWN) {\n+        return size;\n+      }\n+      // TODO: Support \"global\" backlog reporting\n+      // size = reader.getTotalBacklogBytes();\n+      // if (size != UnboundedReader.BACKLOG_UNKNOWN) {\n+      //   return size;\n+      // }\n+      return 1;\n+    }\n+\n+    @SplitRestriction\n+    public void splitRestriction(\n+        @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+        OutputReceiver<KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>> receiver,\n+        PipelineOptions pipelineOptions)\n+        throws Exception {\n+      // The empty unbounded source is trivially done and hence we don't need to output any splits\n+      // for it.\n+      if (restriction.getKey() instanceof EmptyUnboundedSource) {\n+        return;\n+      }\n+\n+      // The UnboundedSource API does not support splitting after a meaningful checkpoint mark has\n+      // been created.\n+      if (restriction.getValue() != null\n+          && !(restriction.getValue()\n+              instanceof UnboundedSource.CheckpointMark.NoopCheckpointMark)) {\n+        receiver.output(restriction);\n+      }\n+\n+      try {\n+        for (UnboundedSource<OutputT, CheckpointT> split :\n+            restriction.getKey().split(DEFAULT_DESIRED_NUM_SPLITS, pipelineOptions)) {\n+          receiver.output(KV.of(split, null));\n+        }\n+      } catch (Exception e) {\n+        receiver.output(restriction);\n+      }\n+    }\n+\n+    @NewTracker\n+    public RestrictionTracker<\n+            KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>, UnboundedSourceValue<OutputT>[]>\n+        restrictionTracker(\n+            @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+            PipelineOptions pipelineOptions) {\n+      return new UnboundedSourceAsSDFRestrictionTracker(restriction, pipelineOptions);\n+    }\n+\n+    @ProcessElement\n+    public ProcessContinuation processElement(\n+        RestrictionTracker<\n+                KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>, UnboundedSourceValue[]>\n+            tracker,\n+        OutputReceiver<ValueWithRecordId<OutputT>> receiver,\n+        BundleFinalizer bundleFinalizer)\n+        throws IOException {\n+      UnboundedSourceValue<OutputT>[] out = new UnboundedSourceValue[1];\n+      while (tracker.tryClaim(out)) {\n+        receiver.outputWithTimestamp(\n+            new ValueWithRecordId<>(out[0].getValue(), out[0].getId()), out[0].getTimestamp());\n+      }\n+\n+      // Add the checkpoint mark to be finalized if the checkpoint mark isn't trivial.\n+      KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> currentRestriction =\n+          tracker.currentRestriction();\n+      if (currentRestriction.getValue() != null\n+          && !(tracker.currentRestriction().getValue() instanceof NoopCheckpointMark)) {\n+        bundleFinalizer.afterBundleCommit(\n+            Instant.now().plus(Duration.standardMinutes(DEFAULT_BUNDLE_FINALIZATION_LIMIT_MINS)),\n+            currentRestriction.getValue()::finalizeCheckpoint);\n+      }\n+\n+      // If we have been split/checkpoint by a runner, the tracker will have been updated to the\n+      // empty source and we will return stop. Otherwise the unbounded source has only temporarily\n+      // run out of work.\n+      if (tracker.currentRestriction().getKey() instanceof EmptyUnboundedSource) {\n+        return ProcessContinuation.stop();\n+      }\n+      return ProcessContinuation.resume();\n+    }\n+\n+    @GetRestrictionCoder\n+    public Coder<KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>> restrictionCoder() {\n+      return KvCoder.of(\n+          SerializableCoder.of(new TypeDescriptor<UnboundedSource<OutputT, CheckpointT>>() {}),\n+          NullableCoder.of(restrictionCoder));\n+    }\n+\n+    /**\n+     * A named tuple representing all the values we need to pass between the {@link UnboundedReader}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyMDM1NA=="}, "originalCommit": {"oid": "228e5844a5022439cc048b19f070e1561b8ec94f"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MzE4ODI1OnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMzoxOTo0NFrOFu_9eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMTozNjowM1rOFvCdsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyNjc0Ng==", "bodyText": "JIRA for tracking? (Or would this be 10897?) Maybe update the PR/commit description to describe the current capabilities and limitations.", "url": "https://github.com/apache/beam/pull/10897#discussion_r384826746", "createdAt": "2020-02-26T23:19:44Z", "author": {"login": "robertwb"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -375,4 +422,361 @@ public void checkDone() throws IllegalStateException {\n       }\n     }\n   }\n+\n+  /**\n+   * A splittable {@link DoFn} which executes an {@link UnboundedSource}.\n+   *\n+   * <p>We model the element as the original source and the restriction as a pair of the sub-source\n+   * and its {@link CheckpointMark}. This allows us to split the sub-source over and over as long as\n+   * the checkpoint mark is {@code null} or the {@link NoopCheckpointMark} since it does not\n+   * maintain any state.\n+   */\n+  // TODO: Support reporting the watermark, currently the watermark never advances.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "228e5844a5022439cc048b19f070e1561b8ec94f"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2Nzc2MA==", "bodyText": "Will file JIRA if I can't do all the watermark reporting passing and implementation in the SDK harness.", "url": "https://github.com/apache/beam/pull/10897#discussion_r384867760", "createdAt": "2020-02-27T01:36:03Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -375,4 +422,361 @@ public void checkDone() throws IllegalStateException {\n       }\n     }\n   }\n+\n+  /**\n+   * A splittable {@link DoFn} which executes an {@link UnboundedSource}.\n+   *\n+   * <p>We model the element as the original source and the restriction as a pair of the sub-source\n+   * and its {@link CheckpointMark}. This allows us to split the sub-source over and over as long as\n+   * the checkpoint mark is {@code null} or the {@link NoopCheckpointMark} since it does not\n+   * maintain any state.\n+   */\n+  // TODO: Support reporting the watermark, currently the watermark never advances.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyNjc0Ng=="}, "originalCommit": {"oid": "228e5844a5022439cc048b19f070e1561b8ec94f"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MzI4MDY2OnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDowMzowMFrOFvA0QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMTozMzowNVrOFvCa4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0MDc2OA==", "bodyText": "I'm curious what WindowingStrategy is going to apply here. If it's using GlobalWindow, will it work in streaming mode?", "url": "https://github.com/apache/beam/pull/10897#discussion_r384840768", "createdAt": "2020-02-27T00:03:00Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -185,6 +200,37 @@ private Unbounded(@Nullable String name, UnboundedSource<T, ?> source) {\n     @Override\n     public final PCollection<T> expand(PBegin input) {\n       source.validate();\n+\n+      if (ExperimentalOptions.hasExperiment(input.getPipeline().getOptions(), \"beam_fn_api\")\n+          && !ExperimentalOptions.hasExperiment(\n+              input.getPipeline().getOptions(), \"beam_fn_api_use_deprecated_read\")) {\n+        // We don't use Create here since Create is defined as a BoundedSource and using it would\n+        // cause an infinite expansion loop. We can reconsider this if Create is implemented\n+        // directly as a SplittableDoFn.\n+        PCollection<ValueWithRecordId<T>> outputWithIds =\n+            input\n+                .getPipeline()\n+                .apply(Impulse.create())\n+                .apply(\n+                    MapElements.into(new TypeDescriptor<UnboundedSource<T, CheckpointMark>>() {})\n+                        .via(element -> (UnboundedSource<T, CheckpointMark>) source))\n+                .setCoder(\n+                    SerializableCoder.of(\n+                        new TypeDescriptor<UnboundedSource<T, CheckpointMark>>() {}))\n+                .apply(\n+                    ParDo.of(\n+                        new UnboundedSourceAsSDFWrapperFn<>(\n+                            (Coder<CheckpointMark>) source.getCheckpointMarkCoder())))\n+                .setCoder(ValueWithRecordIdCoder.of(source.getOutputCoder()));\n+        if (source.requiresDeduping()) {\n+          outputWithIds.apply(\n+              Distinct.<ValueWithRecordId<T>, byte[]>withRepresentativeValueFn(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "228e5844a5022439cc048b19f070e1561b8ec94f"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2NzA0Mg==", "bodyText": "No it won't, this was for some testing of mine.", "url": "https://github.com/apache/beam/pull/10897#discussion_r384867042", "createdAt": "2020-02-27T01:33:05Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -185,6 +200,37 @@ private Unbounded(@Nullable String name, UnboundedSource<T, ?> source) {\n     @Override\n     public final PCollection<T> expand(PBegin input) {\n       source.validate();\n+\n+      if (ExperimentalOptions.hasExperiment(input.getPipeline().getOptions(), \"beam_fn_api\")\n+          && !ExperimentalOptions.hasExperiment(\n+              input.getPipeline().getOptions(), \"beam_fn_api_use_deprecated_read\")) {\n+        // We don't use Create here since Create is defined as a BoundedSource and using it would\n+        // cause an infinite expansion loop. We can reconsider this if Create is implemented\n+        // directly as a SplittableDoFn.\n+        PCollection<ValueWithRecordId<T>> outputWithIds =\n+            input\n+                .getPipeline()\n+                .apply(Impulse.create())\n+                .apply(\n+                    MapElements.into(new TypeDescriptor<UnboundedSource<T, CheckpointMark>>() {})\n+                        .via(element -> (UnboundedSource<T, CheckpointMark>) source))\n+                .setCoder(\n+                    SerializableCoder.of(\n+                        new TypeDescriptor<UnboundedSource<T, CheckpointMark>>() {}))\n+                .apply(\n+                    ParDo.of(\n+                        new UnboundedSourceAsSDFWrapperFn<>(\n+                            (Coder<CheckpointMark>) source.getCheckpointMarkCoder())))\n+                .setCoder(ValueWithRecordIdCoder.of(source.getOutputCoder()));\n+        if (source.requiresDeduping()) {\n+          outputWithIds.apply(\n+              Distinct.<ValueWithRecordId<T>, byte[]>withRepresentativeValueFn(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0MDc2OA=="}, "originalCommit": {"oid": "228e5844a5022439cc048b19f070e1561b8ec94f"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MzMxOTk0OnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDoyMjozNFrOFvBLaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMToyOTo1N1rOFvCXTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0NjY5OQ==", "bodyText": "Also curious why each output has its own watermark. Will the watermark be different from timestamp for one given record?", "url": "https://github.com/apache/beam/pull/10897#discussion_r384846699", "createdAt": "2020-02-27T00:22:34Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -375,4 +422,361 @@ public void checkDone() throws IllegalStateException {\n       }\n     }\n   }\n+\n+  /**\n+   * A splittable {@link DoFn} which executes an {@link UnboundedSource}.\n+   *\n+   * <p>We model the element as the original source and the restriction as a pair of the sub-source\n+   * and its {@link CheckpointMark}. This allows us to split the sub-source over and over as long as\n+   * the checkpoint mark is {@code null} or the {@link NoopCheckpointMark} since it does not\n+   * maintain any state.\n+   */\n+  // TODO: Support reporting the watermark, currently the watermark never advances.\n+  @UnboundedPerElement\n+  static class UnboundedSourceAsSDFWrapperFn<OutputT, CheckpointT extends CheckpointMark>\n+      extends DoFn<UnboundedSource<OutputT, CheckpointT>, ValueWithRecordId<OutputT>> {\n+\n+    private static final int DEFAULT_DESIRED_NUM_SPLITS = 20;\n+    private static final int DEFAULT_BUNDLE_FINALIZATION_LIMIT_MINS = 10;\n+    private final Coder<CheckpointT> restrictionCoder;\n+\n+    private UnboundedSourceAsSDFWrapperFn(Coder<CheckpointT> restrictionCoder) {\n+      this.restrictionCoder = restrictionCoder;\n+    }\n+\n+    @GetInitialRestriction\n+    public KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> initialRestriction(\n+        @Element UnboundedSource<OutputT, CheckpointT> element) {\n+      return KV.of(element, null);\n+    }\n+\n+    @GetSize\n+    public double getSize(\n+        @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+        PipelineOptions pipelineOptions)\n+        throws Exception {\n+      if (restriction.getKey() instanceof EmptyUnboundedSource) {\n+        return 1;\n+      }\n+\n+      UnboundedReader<OutputT> reader =\n+          restriction.getKey().createReader(pipelineOptions, restriction.getValue());\n+      long size = reader.getSplitBacklogBytes();\n+      if (size != UnboundedReader.BACKLOG_UNKNOWN) {\n+        return size;\n+      }\n+      // TODO: Support \"global\" backlog reporting\n+      // size = reader.getTotalBacklogBytes();\n+      // if (size != UnboundedReader.BACKLOG_UNKNOWN) {\n+      //   return size;\n+      // }\n+      return 1;\n+    }\n+\n+    @SplitRestriction\n+    public void splitRestriction(\n+        @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+        OutputReceiver<KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>> receiver,\n+        PipelineOptions pipelineOptions)\n+        throws Exception {\n+      // The empty unbounded source is trivially done and hence we don't need to output any splits\n+      // for it.\n+      if (restriction.getKey() instanceof EmptyUnboundedSource) {\n+        return;\n+      }\n+\n+      // The UnboundedSource API does not support splitting after a meaningful checkpoint mark has\n+      // been created.\n+      if (restriction.getValue() != null\n+          && !(restriction.getValue()\n+              instanceof UnboundedSource.CheckpointMark.NoopCheckpointMark)) {\n+        receiver.output(restriction);\n+      }\n+\n+      try {\n+        for (UnboundedSource<OutputT, CheckpointT> split :\n+            restriction.getKey().split(DEFAULT_DESIRED_NUM_SPLITS, pipelineOptions)) {\n+          receiver.output(KV.of(split, null));\n+        }\n+      } catch (Exception e) {\n+        receiver.output(restriction);\n+      }\n+    }\n+\n+    @NewTracker\n+    public RestrictionTracker<\n+            KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>, UnboundedSourceValue<OutputT>[]>\n+        restrictionTracker(\n+            @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+            PipelineOptions pipelineOptions) {\n+      return new UnboundedSourceAsSDFRestrictionTracker(restriction, pipelineOptions);\n+    }\n+\n+    @ProcessElement\n+    public ProcessContinuation processElement(\n+        RestrictionTracker<\n+                KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>, UnboundedSourceValue[]>\n+            tracker,\n+        OutputReceiver<ValueWithRecordId<OutputT>> receiver,\n+        BundleFinalizer bundleFinalizer)\n+        throws IOException {\n+      UnboundedSourceValue<OutputT>[] out = new UnboundedSourceValue[1];\n+      while (tracker.tryClaim(out)) {\n+        receiver.outputWithTimestamp(\n+            new ValueWithRecordId<>(out[0].getValue(), out[0].getId()), out[0].getTimestamp());\n+      }\n+\n+      // Add the checkpoint mark to be finalized if the checkpoint mark isn't trivial.\n+      KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> currentRestriction =\n+          tracker.currentRestriction();\n+      if (currentRestriction.getValue() != null\n+          && !(tracker.currentRestriction().getValue() instanceof NoopCheckpointMark)) {\n+        bundleFinalizer.afterBundleCommit(\n+            Instant.now().plus(Duration.standardMinutes(DEFAULT_BUNDLE_FINALIZATION_LIMIT_MINS)),\n+            currentRestriction.getValue()::finalizeCheckpoint);\n+      }\n+\n+      // If we have been split/checkpoint by a runner, the tracker will have been updated to the\n+      // empty source and we will return stop. Otherwise the unbounded source has only temporarily\n+      // run out of work.\n+      if (tracker.currentRestriction().getKey() instanceof EmptyUnboundedSource) {\n+        return ProcessContinuation.stop();\n+      }\n+      return ProcessContinuation.resume();\n+    }\n+\n+    @GetRestrictionCoder\n+    public Coder<KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>> restrictionCoder() {\n+      return KvCoder.of(\n+          SerializableCoder.of(new TypeDescriptor<UnboundedSource<OutputT, CheckpointT>>() {}),\n+          NullableCoder.of(restrictionCoder));\n+    }\n+\n+    /**\n+     * A named tuple representing all the values we need to pass between the {@link UnboundedReader}\n+     * and the {@link org.apache.beam.sdk.transforms.DoFn.ProcessElement @ProcessElement} method of\n+     * the splittable DoFn.\n+     */\n+    @AutoValue\n+    abstract static class UnboundedSourceValue<T> {\n+      public static <T> UnboundedSourceValue<T> create(\n+          byte[] id, T value, Instant timestamp, Instant watermark) {\n+        return new AutoValue_Read_UnboundedSourceAsSDFWrapperFn_UnboundedSourceValue<T>(\n+            id, value, timestamp, watermark);\n+      }\n+\n+      @SuppressWarnings(\"mutable\")\n+      public abstract byte[] getId();\n+\n+      public abstract T getValue();\n+\n+      public abstract Instant getTimestamp();\n+\n+      public abstract Instant getWatermark();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "228e5844a5022439cc048b19f070e1561b8ec94f"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2NjEyNQ==", "bodyText": "The UnboundedSource can report a watermark that is reported separately from the element timestamp.", "url": "https://github.com/apache/beam/pull/10897#discussion_r384866125", "createdAt": "2020-02-27T01:29:57Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -375,4 +422,361 @@ public void checkDone() throws IllegalStateException {\n       }\n     }\n   }\n+\n+  /**\n+   * A splittable {@link DoFn} which executes an {@link UnboundedSource}.\n+   *\n+   * <p>We model the element as the original source and the restriction as a pair of the sub-source\n+   * and its {@link CheckpointMark}. This allows us to split the sub-source over and over as long as\n+   * the checkpoint mark is {@code null} or the {@link NoopCheckpointMark} since it does not\n+   * maintain any state.\n+   */\n+  // TODO: Support reporting the watermark, currently the watermark never advances.\n+  @UnboundedPerElement\n+  static class UnboundedSourceAsSDFWrapperFn<OutputT, CheckpointT extends CheckpointMark>\n+      extends DoFn<UnboundedSource<OutputT, CheckpointT>, ValueWithRecordId<OutputT>> {\n+\n+    private static final int DEFAULT_DESIRED_NUM_SPLITS = 20;\n+    private static final int DEFAULT_BUNDLE_FINALIZATION_LIMIT_MINS = 10;\n+    private final Coder<CheckpointT> restrictionCoder;\n+\n+    private UnboundedSourceAsSDFWrapperFn(Coder<CheckpointT> restrictionCoder) {\n+      this.restrictionCoder = restrictionCoder;\n+    }\n+\n+    @GetInitialRestriction\n+    public KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> initialRestriction(\n+        @Element UnboundedSource<OutputT, CheckpointT> element) {\n+      return KV.of(element, null);\n+    }\n+\n+    @GetSize\n+    public double getSize(\n+        @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+        PipelineOptions pipelineOptions)\n+        throws Exception {\n+      if (restriction.getKey() instanceof EmptyUnboundedSource) {\n+        return 1;\n+      }\n+\n+      UnboundedReader<OutputT> reader =\n+          restriction.getKey().createReader(pipelineOptions, restriction.getValue());\n+      long size = reader.getSplitBacklogBytes();\n+      if (size != UnboundedReader.BACKLOG_UNKNOWN) {\n+        return size;\n+      }\n+      // TODO: Support \"global\" backlog reporting\n+      // size = reader.getTotalBacklogBytes();\n+      // if (size != UnboundedReader.BACKLOG_UNKNOWN) {\n+      //   return size;\n+      // }\n+      return 1;\n+    }\n+\n+    @SplitRestriction\n+    public void splitRestriction(\n+        @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+        OutputReceiver<KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>> receiver,\n+        PipelineOptions pipelineOptions)\n+        throws Exception {\n+      // The empty unbounded source is trivially done and hence we don't need to output any splits\n+      // for it.\n+      if (restriction.getKey() instanceof EmptyUnboundedSource) {\n+        return;\n+      }\n+\n+      // The UnboundedSource API does not support splitting after a meaningful checkpoint mark has\n+      // been created.\n+      if (restriction.getValue() != null\n+          && !(restriction.getValue()\n+              instanceof UnboundedSource.CheckpointMark.NoopCheckpointMark)) {\n+        receiver.output(restriction);\n+      }\n+\n+      try {\n+        for (UnboundedSource<OutputT, CheckpointT> split :\n+            restriction.getKey().split(DEFAULT_DESIRED_NUM_SPLITS, pipelineOptions)) {\n+          receiver.output(KV.of(split, null));\n+        }\n+      } catch (Exception e) {\n+        receiver.output(restriction);\n+      }\n+    }\n+\n+    @NewTracker\n+    public RestrictionTracker<\n+            KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>, UnboundedSourceValue<OutputT>[]>\n+        restrictionTracker(\n+            @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+            PipelineOptions pipelineOptions) {\n+      return new UnboundedSourceAsSDFRestrictionTracker(restriction, pipelineOptions);\n+    }\n+\n+    @ProcessElement\n+    public ProcessContinuation processElement(\n+        RestrictionTracker<\n+                KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>, UnboundedSourceValue[]>\n+            tracker,\n+        OutputReceiver<ValueWithRecordId<OutputT>> receiver,\n+        BundleFinalizer bundleFinalizer)\n+        throws IOException {\n+      UnboundedSourceValue<OutputT>[] out = new UnboundedSourceValue[1];\n+      while (tracker.tryClaim(out)) {\n+        receiver.outputWithTimestamp(\n+            new ValueWithRecordId<>(out[0].getValue(), out[0].getId()), out[0].getTimestamp());\n+      }\n+\n+      // Add the checkpoint mark to be finalized if the checkpoint mark isn't trivial.\n+      KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> currentRestriction =\n+          tracker.currentRestriction();\n+      if (currentRestriction.getValue() != null\n+          && !(tracker.currentRestriction().getValue() instanceof NoopCheckpointMark)) {\n+        bundleFinalizer.afterBundleCommit(\n+            Instant.now().plus(Duration.standardMinutes(DEFAULT_BUNDLE_FINALIZATION_LIMIT_MINS)),\n+            currentRestriction.getValue()::finalizeCheckpoint);\n+      }\n+\n+      // If we have been split/checkpoint by a runner, the tracker will have been updated to the\n+      // empty source and we will return stop. Otherwise the unbounded source has only temporarily\n+      // run out of work.\n+      if (tracker.currentRestriction().getKey() instanceof EmptyUnboundedSource) {\n+        return ProcessContinuation.stop();\n+      }\n+      return ProcessContinuation.resume();\n+    }\n+\n+    @GetRestrictionCoder\n+    public Coder<KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>> restrictionCoder() {\n+      return KvCoder.of(\n+          SerializableCoder.of(new TypeDescriptor<UnboundedSource<OutputT, CheckpointT>>() {}),\n+          NullableCoder.of(restrictionCoder));\n+    }\n+\n+    /**\n+     * A named tuple representing all the values we need to pass between the {@link UnboundedReader}\n+     * and the {@link org.apache.beam.sdk.transforms.DoFn.ProcessElement @ProcessElement} method of\n+     * the splittable DoFn.\n+     */\n+    @AutoValue\n+    abstract static class UnboundedSourceValue<T> {\n+      public static <T> UnboundedSourceValue<T> create(\n+          byte[] id, T value, Instant timestamp, Instant watermark) {\n+        return new AutoValue_Read_UnboundedSourceAsSDFWrapperFn_UnboundedSourceValue<T>(\n+            id, value, timestamp, watermark);\n+      }\n+\n+      @SuppressWarnings(\"mutable\")\n+      public abstract byte[] getId();\n+\n+      public abstract T getValue();\n+\n+      public abstract Instant getTimestamp();\n+\n+      public abstract Instant getWatermark();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0NjY5OQ=="}, "originalCommit": {"oid": "228e5844a5022439cc048b19f070e1561b8ec94f"}, "originalPosition": 243}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzkyNDY5OnYy", "diffSide": "RIGHT", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjowMjoyNFrOGIpheQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjo1Nzo1MlrOGIrB7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMjEwNQ==", "bodyText": "Do we assume that getSize here is always called for calculating backlog in streaming? It is not correct for calculating  primary size(though primary size doesn't matter for now).", "url": "https://github.com/apache/beam/pull/10897#discussion_r411722105", "createdAt": "2020-04-20T22:02:24Z", "author": {"login": "boyuanzz"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -375,4 +423,372 @@ public void checkDone() throws IllegalStateException {\n       }\n     }\n   }\n+\n+  /**\n+   * A splittable {@link DoFn} which executes an {@link UnboundedSource}.\n+   *\n+   * <p>We model the element as the original source and the restriction as a pair of the sub-source\n+   * and its {@link CheckpointMark}. This allows us to split the sub-source over and over as long as\n+   * the checkpoint mark is {@code null} or the {@link NoopCheckpointMark} since it does not\n+   * maintain any state.\n+   */\n+  @UnboundedPerElement\n+  static class UnboundedSourceAsSDFWrapperFn<OutputT, CheckpointT extends CheckpointMark>\n+      extends DoFn<UnboundedSource<OutputT, CheckpointT>, ValueWithRecordId<OutputT>> {\n+    private static final Logger LOG = LoggerFactory.getLogger(UnboundedSourceAsSDFWrapperFn.class);\n+    private static final int DEFAULT_DESIRED_NUM_SPLITS = 20;\n+    private static final int DEFAULT_BUNDLE_FINALIZATION_LIMIT_MINS = 10;\n+    private final Coder<CheckpointT> restrictionCoder;\n+\n+    private UnboundedSourceAsSDFWrapperFn(Coder<CheckpointT> restrictionCoder) {\n+      this.restrictionCoder = restrictionCoder;\n+    }\n+\n+    @GetInitialRestriction\n+    public KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> initialRestriction(\n+        @Element UnboundedSource<OutputT, CheckpointT> element) {\n+      return KV.of(element, null);\n+    }\n+\n+    @GetSize\n+    public double getSize(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01c12c08bc0c4a093533d93d20ecf8f8869e68c7"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0Njc5Nw==", "bodyText": "getSize is used for the initial size and isn't used anywhere for progress/backlog reporting yet.\nWith #11472, this can be migrated to HasProgress on the restriction tracker.", "url": "https://github.com/apache/beam/pull/10897#discussion_r411746797", "createdAt": "2020-04-20T22:57:52Z", "author": {"login": "lukecwik"}, "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -375,4 +423,372 @@ public void checkDone() throws IllegalStateException {\n       }\n     }\n   }\n+\n+  /**\n+   * A splittable {@link DoFn} which executes an {@link UnboundedSource}.\n+   *\n+   * <p>We model the element as the original source and the restriction as a pair of the sub-source\n+   * and its {@link CheckpointMark}. This allows us to split the sub-source over and over as long as\n+   * the checkpoint mark is {@code null} or the {@link NoopCheckpointMark} since it does not\n+   * maintain any state.\n+   */\n+  @UnboundedPerElement\n+  static class UnboundedSourceAsSDFWrapperFn<OutputT, CheckpointT extends CheckpointMark>\n+      extends DoFn<UnboundedSource<OutputT, CheckpointT>, ValueWithRecordId<OutputT>> {\n+    private static final Logger LOG = LoggerFactory.getLogger(UnboundedSourceAsSDFWrapperFn.class);\n+    private static final int DEFAULT_DESIRED_NUM_SPLITS = 20;\n+    private static final int DEFAULT_BUNDLE_FINALIZATION_LIMIT_MINS = 10;\n+    private final Coder<CheckpointT> restrictionCoder;\n+\n+    private UnboundedSourceAsSDFWrapperFn(Coder<CheckpointT> restrictionCoder) {\n+      this.restrictionCoder = restrictionCoder;\n+    }\n+\n+    @GetInitialRestriction\n+    public KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> initialRestriction(\n+        @Element UnboundedSource<OutputT, CheckpointT> element) {\n+      return KV.of(element, null);\n+    }\n+\n+    @GetSize\n+    public double getSize(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMjEwNQ=="}, "originalCommit": {"oid": "01c12c08bc0c4a093533d93d20ecf8f8869e68c7"}, "originalPosition": 122}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2064, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}