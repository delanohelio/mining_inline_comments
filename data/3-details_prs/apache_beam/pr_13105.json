{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzMDkxOTU2", "number": 13105, "title": "[BEAM-10940] Add sdf initiated checkpoint support to portable Flink.", "bodyText": "This PR added the sdf self-checkpoint support to portable Flink by using timer and state where\n\n\nIn batch, we use InMemoryTimerInternals and InMemoryStateInternals to set the timer and persist residual elements.\n\n\nIn streaming, we use SdfFlinkTimerInternals as the wrapper of FlinkTimerInternals and SdfFlinkStateInternals as the wrapper of FlinkStateInternals for one specific key.\n\n\nFor more design details, please refer to this doc\nr: @robertwb @mxm\ncc: @ibzib @lukecwik\n\nThank you for your contribution! Follow this checklist to help us incorporate your contribution quickly and easily:\n\n Choose reviewer(s) and mention them in a comment (R: @username).\n Format the pull request title like [BEAM-XXX] Fixes bug in ApproximateQuantiles, where you replace BEAM-XXX with the appropriate JIRA issue, if applicable. This will automatically link the pull request to the issue.\n Update CHANGES.md with noteworthy changes.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.\n\nSee the Contributor Guide for more tips on how to make review process smoother.\nPost-Commit Tests Status (on master branch)\n\n\n\nLang\nSDK\nDataflow\nFlink\nSamza\nSpark\nTwister2\n\n\n\n\nGo\n\n---\n\n---\n\n---\n\n\nJava\n\n\n\n\n\n\n\n\nPython\n\n\n\n---\n\n---\n\n\nXLang\n\n---\n\n---\n\n---\n\n\n\nPre-Commit Tests Status (on master branch)\n\n\n\n---\nJava\nPython\nGo\nWebsite\nWhitespace\nTypescript\n\n\n\n\nNon-portable\n\n \n\n\n\n\n\n\nPortable\n---\n\n---\n---\n---\n---\n\n\n\nSee .test-infra/jenkins/README for trigger phrase, status and link of all Jenkins jobs.\nGitHub Actions Tests Status (on master branch)\n\n\n\nSee CI.md for more information about GitHub Actions CI.", "createdAt": "2020-10-14T04:09:32Z", "url": "https://github.com/apache/beam/pull/13105", "merged": true, "mergeCommit": {"oid": "cf6fd1ced9d2170ae1bab483aeceba10cd57b016"}, "closed": true, "closedAt": "2020-11-11T22:43:17Z", "author": {"login": "boyuanzz"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdUyrV_gBqjM5MDU2NDU0NTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdbjKYAABqjM5ODUzMzQ1ODg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cdf8629dfe9dff02adcfcfc532f35e5852c1c770", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/cdf8629dfe9dff02adcfcfc532f35e5852c1c770", "committedDate": "2020-10-21T02:08:26Z", "message": "more update."}, "afterCommit": {"oid": "a1997cfbb6052014f4a5b8a7ec29f6038afddbd4", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/a1997cfbb6052014f4a5b8a7ec29f6038afddbd4", "committedDate": "2020-10-21T19:38:06Z", "message": "Add sdf initiated checkpoint support to portable Flink."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9c751ebf725ce93c93a9ef1ec9ce627925df6cb3", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/9c751ebf725ce93c93a9ef1ec9ce627925df6cb3", "committedDate": "2020-10-22T19:17:43Z", "message": "test only."}, "afterCommit": {"oid": "7eeb7f22ba0a01a20597be759f13ba5aa878aadf", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/7eeb7f22ba0a01a20597be759f13ba5aa878aadf", "committedDate": "2020-10-23T00:07:31Z", "message": "test only commit"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7eeb7f22ba0a01a20597be759f13ba5aa878aadf", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/7eeb7f22ba0a01a20597be759f13ba5aa878aadf", "committedDate": "2020-10-23T00:07:31Z", "message": "test only commit"}, "afterCommit": {"oid": "5214f7ffe95e260aef28a4fc2d59483ef49e043b", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/5214f7ffe95e260aef28a4fc2d59483ef49e043b", "committedDate": "2020-10-23T02:14:30Z", "message": "Populate sideinput for SDF."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7559089aca920bad697c9dafbfc26101fae41a94", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/7559089aca920bad697c9dafbfc26101fae41a94", "committedDate": "2020-10-23T17:56:50Z", "message": "Update test categories."}, "afterCommit": {"oid": "ce161e63ac85824e23d3414475a22a913612fb80", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/ce161e63ac85824e23d3414475a22a913612fb80", "committedDate": "2020-10-23T19:59:57Z", "message": "Update test categories."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ce161e63ac85824e23d3414475a22a913612fb80", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/ce161e63ac85824e23d3414475a22a913612fb80", "committedDate": "2020-10-23T19:59:57Z", "message": "Update test categories."}, "afterCommit": {"oid": "a293f014cb1b1fcfde42a9a68c4e24f53101d128", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/a293f014cb1b1fcfde42a9a68c4e24f53101d128", "committedDate": "2020-10-26T17:48:43Z", "message": "Add sdf initiated checkpoint support to portable Flink."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a293f014cb1b1fcfde42a9a68c4e24f53101d128", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/a293f014cb1b1fcfde42a9a68c4e24f53101d128", "committedDate": "2020-10-26T17:48:43Z", "message": "Add sdf initiated checkpoint support to portable Flink."}, "afterCommit": {"oid": "82c2fc2df459e578a833a5e2fb4d944229876c77", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/82c2fc2df459e578a833a5e2fb4d944229876c77", "committedDate": "2020-10-26T22:02:39Z", "message": "Add sdf initiated checkpoint support to portable Flink."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3NDg1MTY5", "url": "https://github.com/apache/beam/pull/13105#pullrequestreview-517485169", "createdAt": "2020-10-27T09:13:09Z", "commit": {"oid": "82c2fc2df459e578a833a5e2fb4d944229876c77"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwOToxMzowOVrOHoyBgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwOTo0Nzo0MFrOHozYvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUyNDY3NQ==", "bodyText": "Maybe add a comment why this one is excluded?", "url": "https://github.com/apache/beam/pull/13105#discussion_r512524675", "createdAt": "2020-10-27T09:13:09Z", "author": {"login": "mxm"}, "path": "runners/flink/job-server/flink_job_server.gradle", "diffHunk": "@@ -166,23 +166,22 @@ def portableValidatesRunnerTask(String name, Boolean streaming, Boolean checkpoi\n         excludeCategories 'org.apache.beam.sdk.testing.UsesBundleFinalizer'\n         excludeCategories 'org.apache.beam.sdk.testing.UsesOrderedListState'\n         if (streaming) {\n+          excludeCategories 'org.apache.beam.sdk.testing.UsesBoundedSplittableParDo'\n           excludeCategories 'org.apache.beam.sdk.testing.UsesTestStreamWithProcessingTime'\n           excludeCategories 'org.apache.beam.sdk.testing.UsesTestStreamWithMultipleStages'\n           excludeCategories 'org.apache.beam.sdk.testing.UsesTestStreamWithOutputTimestamp'\n         } else {\n+          excludeCategories 'org.apache.beam.sdk.testing.UsesUnboundedSplittableParDo'\n+          excludeCategories 'org.apache.beam.sdk.testing.UsesSplittableParDoWithWindowedSideInputs'\n           excludeCategories 'org.apache.beam.sdk.testing.UsesUnboundedPCollections'\n           excludeCategories 'org.apache.beam.sdk.testing.UsesTestStream'\n         }\n-        //SplitableDoFnTests\n-        excludeCategories 'org.apache.beam.sdk.testing.UsesBoundedSplittableParDo'\n-        excludeCategories 'org.apache.beam.sdk.testing.UsesSplittableParDoWithWindowedSideInputs'\n-        excludeCategories 'org.apache.beam.sdk.testing.UsesUnboundedSplittableParDo'\n-\n       }\n     },\n     testFilter: {\n       // TODO(BEAM-10016)\n       excludeTestsMatching 'org.apache.beam.sdk.transforms.FlattenTest.testFlattenWithDifferentInputAndOutputCoders2'\n+      excludeTestsMatching 'org.apache.beam.sdk.transforms.SplittableDoFnTest.testPairWithIndexWindowedTimestampedBounded'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82c2fc2df459e578a833a5e2fb4d944229876c77"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUyNzUzMg==", "bodyText": "I'm assuming this was a bug?", "url": "https://github.com/apache/beam/pull/13105#discussion_r512527532", "createdAt": "2020-10-27T09:17:34Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1315,7 +1316,7 @@ void processPendingProcessingTimeTimers() {\n         keyedStateBackend.setCurrentKey(internalTimer.getKey());\n         TimerData timer = internalTimer.getNamespace();\n         checkInvokeStartBundle();\n-        fireTimer(timer);\n+        fireTimerInternal((ByteBuffer) internalTimer.getKey(), timer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82c2fc2df459e578a833a5e2fb4d944229876c77"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUyODY5Ng==", "bodyText": "Wouldn't it make sense to integrate this check with the timerUsesOutputTimestamp method?", "url": "https://github.com/apache/beam/pull/13105#discussion_r512528696", "createdAt": "2020-10-27T09:19:20Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1330,6 +1331,14 @@ private void onNewEventTimer(TimerData newTimer) {\n       }\n     }\n \n+    /** Holds the watermark when there is an sdf timer. */\n+    private void onNewSdfTimer(TimerData newTimer) {\n+      Preconditions.checkState(\n+          StateAndTimerBundleCheckpointHandler.isSdfTimer(newTimer.getTimerId()));\n+      Preconditions.checkState(timerUsesOutputTimestamp(newTimer));\n+      keyedStateInternals.addWatermarkHoldUsage(newTimer.getOutputTimestamp());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82c2fc2df459e578a833a5e2fb4d944229876c77"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUyOTA1MA==", "bodyText": "Wouldn't it make sense to integrate this check with the timerUsesOutputTimestamp method?", "url": "https://github.com/apache/beam/pull/13105#discussion_r512529050", "createdAt": "2020-10-27T09:19:52Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1342,6 +1351,14 @@ private void onRemovedEventTimer(TimerData removedTimer) {\n       }\n     }\n \n+    private void onRemovedSdfTimer(TimerData removedTimer) {\n+      Preconditions.checkState(\n+          StateAndTimerBundleCheckpointHandler.isSdfTimer(removedTimer.getTimerId()));\n+      Preconditions.checkState(timerUsesOutputTimestamp(removedTimer));\n+      // Remove the watermark hold which is set for this sdf timer.\n+      keyedStateInternals.removeWatermarkHoldUsage(removedTimer.getOutputTimestamp());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82c2fc2df459e578a833a5e2fb4d944229876c77"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUyOTY3Mg==", "bodyText": "We could rename the mentioned method to onFiredTimer and include the checks for output watermark holds in there.", "url": "https://github.com/apache/beam/pull/13105#discussion_r512529672", "createdAt": "2020-10-27T09:20:48Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1330,6 +1331,14 @@ private void onNewEventTimer(TimerData newTimer) {\n       }\n     }\n \n+    /** Holds the watermark when there is an sdf timer. */\n+    private void onNewSdfTimer(TimerData newTimer) {\n+      Preconditions.checkState(\n+          StateAndTimerBundleCheckpointHandler.isSdfTimer(newTimer.getTimerId()));\n+      Preconditions.checkState(timerUsesOutputTimestamp(newTimer));\n+      keyedStateInternals.addWatermarkHoldUsage(newTimer.getOutputTimestamp());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUyODY5Ng=="}, "originalCommit": {"oid": "82c2fc2df459e578a833a5e2fb4d944229876c77"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUyOTkzNg==", "bodyText": "We could rename the mentioned method to onFiredTimer and include the checks for output watermark holds in there.", "url": "https://github.com/apache/beam/pull/13105#discussion_r512529936", "createdAt": "2020-10-27T09:21:08Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1342,6 +1351,14 @@ private void onRemovedEventTimer(TimerData removedTimer) {\n       }\n     }\n \n+    private void onRemovedSdfTimer(TimerData removedTimer) {\n+      Preconditions.checkState(\n+          StateAndTimerBundleCheckpointHandler.isSdfTimer(removedTimer.getTimerId()));\n+      Preconditions.checkState(timerUsesOutputTimestamp(removedTimer));\n+      // Remove the watermark hold which is set for this sdf timer.\n+      keyedStateInternals.removeWatermarkHoldUsage(removedTimer.getOutputTimestamp());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUyOTA1MA=="}, "originalCommit": {"oid": "82c2fc2df459e578a833a5e2fb4d944229876c77"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUzMDU4Mg==", "bodyText": "Could be simplified by having a generic call here to onFiredTimer. See above.", "url": "https://github.com/apache/beam/pull/13105#discussion_r512530582", "createdAt": "2020-10-27T09:22:07Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1424,6 +1442,9 @@ private void registerTimer(TimerData timer, String contextTimerId) throws Except\n         case PROCESSING_TIME:\n         case SYNCHRONIZED_PROCESSING_TIME:\n           timerService.registerProcessingTimeTimer(timer, adjustTimestampForFlink(time));\n+          if (StateAndTimerBundleCheckpointHandler.isSdfTimer(timer.getTimerId())) {\n+            onNewSdfTimer(timer);\n+          }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82c2fc2df459e578a833a5e2fb4d944229876c77"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUzMDY4MQ==", "bodyText": "Could be simplified by having a generic call here to onFiredTimer. See above.", "url": "https://github.com/apache/beam/pull/13105#discussion_r512530681", "createdAt": "2020-10-27T09:22:14Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1451,6 +1472,8 @@ void onFiredOrDeletedTimer(TimerData timer) {\n         pendingTimersById.remove(getContextTimerId(timer.getTimerId(), timer.getNamespace()));\n         if (timer.getDomain() == TimeDomain.EVENT_TIME) {\n           onRemovedEventTimer(timer);\n+        } else if (StateAndTimerBundleCheckpointHandler.isSdfTimer(timer.getTimerId())) {\n+          onRemovedSdfTimer(timer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82c2fc2df459e578a833a5e2fb4d944229876c77"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUzMjUyMA==", "bodyText": "Maybe we should move these out of this class.", "url": "https://github.com/apache/beam/pull/13105#discussion_r512532520", "createdAt": "2020-10-27T09:25:02Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java", "diffHunk": "@@ -484,6 +530,148 @@ void setTimer(Timer<?> timerElement, TimerInternals.TimerData timerData) {\n     }\n   }\n \n+  /**\n+   * A {@link TimerInternalsFactory} for Flink operator to create a {@link\n+   * StateAndTimerBundleCheckpointHandler} to handle {@link\n+   * org.apache.beam.model.fnexecution.v1.BeamFnApi.DelayedBundleApplication}.\n+   */\n+  class SdfFlinkTimerInternalsFactory implements TimerInternalsFactory<InputT> {\n+    @Override\n+    public TimerInternals timerInternalsForKey(InputT key) {\n+      try {\n+        ByteBuffer encodedKey =\n+            (ByteBuffer) keySelector.getKey(WindowedValue.valueInGlobalWindow(key));\n+        return new SdfFlinkTimerInternals(encodedKey);\n+      } catch (Exception e) {\n+        throw new RuntimeException(\"Couldn't get a timer internals\", e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * A {@link TimerInternals} for rescheduling {@link\n+   * org.apache.beam.model.fnexecution.v1.BeamFnApi.DelayedBundleApplication}.\n+   */\n+  class SdfFlinkTimerInternals implements TimerInternals {\n+    private final ByteBuffer key;\n+\n+    SdfFlinkTimerInternals(ByteBuffer key) {\n+      this.key = key;\n+    }\n+\n+    @Override\n+    public void setTimer(\n+        StateNamespace namespace,\n+        String timerId,\n+        String timerFamilyId,\n+        Instant target,\n+        Instant outputTimestamp,\n+        TimeDomain timeDomain) {\n+      setTimer(\n+          TimerData.of(timerId, timerFamilyId, namespace, target, outputTimestamp, timeDomain));\n+    }\n+\n+    @Override\n+    public void setTimer(TimerData timerData) {\n+      try {\n+        try (Locker locker = Locker.locked(stateBackendLock)) {\n+          getKeyedStateBackend().setCurrentKey(key);\n+          timerInternals.setTimer(timerData);\n+          minEventTimeTimerTimestampInCurrentBundle =\n+              Math.min(\n+                  minEventTimeTimerTimestampInCurrentBundle,\n+                  adjustTimestampForFlink(timerData.getOutputTimestamp().getMillis()));\n+        }\n+      } catch (Exception e) {\n+        throw new RuntimeException(\"Couldn't set timer\", e);\n+      }\n+    }\n+\n+    @Override\n+    public void deleteTimer(StateNamespace namespace, String timerId, TimeDomain timeDomain) {\n+      throw new UnsupportedOperationException(\n+          \"It is not expected to use SdfFlinkTimerInternals to delete a timer\");\n+    }\n+\n+    @Override\n+    public void deleteTimer(StateNamespace namespace, String timerId, String timerFamilyId) {\n+      throw new UnsupportedOperationException(\n+          \"It is not expected to use SdfFlinkTimerInternals to delete a timer\");\n+    }\n+\n+    @Override\n+    public void deleteTimer(TimerData timerKey) {\n+      throw new UnsupportedOperationException(\n+          \"It is not expected to use SdfFlinkTimerInternals to delete a timer\");\n+    }\n+\n+    @Override\n+    public Instant currentProcessingTime() {\n+      return timerInternals.currentProcessingTime();\n+    }\n+\n+    @Override\n+    public @Nullable Instant currentSynchronizedProcessingTime() {\n+      return timerInternals.currentSynchronizedProcessingTime();\n+    }\n+\n+    @Override\n+    public Instant currentInputWatermarkTime() {\n+      return timerInternals.currentInputWatermarkTime();\n+    }\n+\n+    @Override\n+    public @Nullable Instant currentOutputWatermarkTime() {\n+      return timerInternals.currentOutputWatermarkTime();\n+    }\n+  }\n+\n+  /**\n+   * A {@link StateInternalsFactory} for Flink operator to create a {@link\n+   * StateAndTimerBundleCheckpointHandler} to handle {@link\n+   * org.apache.beam.model.fnexecution.v1.BeamFnApi.DelayedBundleApplication}.\n+   */\n+  class SdfFlinkStateInternalsFactory implements StateInternalsFactory<InputT> {\n+    @Override\n+    public StateInternals stateInternalsForKey(InputT key) {\n+      try {\n+        ByteBuffer encodedKey =\n+            (ByteBuffer) keySelector.getKey(WindowedValue.valueInGlobalWindow(key));\n+        return new SdfFlinkStateInternals(encodedKey);\n+      } catch (Exception e) {\n+        throw new RuntimeException(\"Couldn't get a state internals\", e);\n+      }\n+    }\n+  }\n+\n+  /** A {@link StateInternals} for keeping {@link DelayedBundleApplication}s as states. */\n+  class SdfFlinkStateInternals implements StateInternals {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82c2fc2df459e578a833a5e2fb4d944229876c77"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUzMjY1MQ==", "bodyText": "Maybe we should move these out of this class.", "url": "https://github.com/apache/beam/pull/13105#discussion_r512532651", "createdAt": "2020-10-27T09:25:11Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java", "diffHunk": "@@ -484,6 +530,148 @@ void setTimer(Timer<?> timerElement, TimerInternals.TimerData timerData) {\n     }\n   }\n \n+  /**\n+   * A {@link TimerInternalsFactory} for Flink operator to create a {@link\n+   * StateAndTimerBundleCheckpointHandler} to handle {@link\n+   * org.apache.beam.model.fnexecution.v1.BeamFnApi.DelayedBundleApplication}.\n+   */\n+  class SdfFlinkTimerInternalsFactory implements TimerInternalsFactory<InputT> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82c2fc2df459e578a833a5e2fb4d944229876c77"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU0NzAwNA==", "bodyText": "Will SDFs ever support stateful operations? If so, this wouldn't work anymore because keys are not guaranteed to be processed on the same operator instance.", "url": "https://github.com/apache/beam/pull/13105#discussion_r512547004", "createdAt": "2020-10-27T09:47:40Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/FlinkStreamingPortablePipelineTranslator.java", "diffHunk": "@@ -683,8 +694,24 @@ private void translateStreamingImpulse(\n                 inputPCollectionId,\n                 valueCoder.getClass().getSimpleName()));\n       }\n-      keyCoder = ((KvCoder) valueCoder).getKeyCoder();\n-      keySelector = new KvToByteBufferKeySelector(keyCoder);\n+      if (stateful) {\n+        keyCoder = ((KvCoder) valueCoder).getKeyCoder();\n+        keySelector = new KvToByteBufferKeySelector(keyCoder);\n+      } else {\n+        // For an SDF, we know that the input element should be\n+        // KV<KV<element, KV<restriction, watermarkState>>, size>. We are going to use the element\n+        // as the key.\n+        if (!(((KvCoder) valueCoder).getKeyCoder() instanceof KvCoder)) {\n+          throw new IllegalStateException(\n+              String.format(\n+                  Locale.ENGLISH,\n+                  \"The element coder for splittable DoFn '%s' must be KVCoder(KvCoder, DoubleCoder) but is: %s\",\n+                  inputPCollectionId,\n+                  valueCoder.getClass().getSimpleName()));\n+        }\n+        keyCoder = ((KvCoder) ((KvCoder) valueCoder).getKeyCoder()).getKeyCoder();\n+        keySelector = new SdfByteBufferKeySelector(keyCoder);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82c2fc2df459e578a833a5e2fb4d944229876c77"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MzAzMTM2", "url": "https://github.com/apache/beam/pull/13105#pullrequestreview-519303136", "createdAt": "2020-10-29T03:19:51Z", "commit": {"oid": "607b444d20e0cd66a25e48a19ac8260d1e7b3ecd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwMzoxOTo1MVrOHqGuSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwMzoxOTo1MVrOHqGuSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkxMjM5NQ==", "bodyText": "Is it a good idea to rely on TimerInternals.getCurrentInputWatermark() to not hold back the watermark so much?\n@mxm", "url": "https://github.com/apache/beam/pull/13105#discussion_r513912395", "createdAt": "2020-10-29T03:19:51Z", "author": {"login": "boyuanzz"}, "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/control/BundleCheckpointHandlers.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.fnexecution.control;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.beam.model.fnexecution.v1.BeamFnApi.DelayedBundleApplication;\n+import org.apache.beam.model.fnexecution.v1.BeamFnApi.ProcessBundleResponse;\n+import org.apache.beam.runners.core.StateInternals;\n+import org.apache.beam.runners.core.StateInternalsFactory;\n+import org.apache.beam.runners.core.StateNamespace;\n+import org.apache.beam.runners.core.StateNamespaces;\n+import org.apache.beam.runners.core.StateTags;\n+import org.apache.beam.runners.core.TimerInternals;\n+import org.apache.beam.runners.core.TimerInternalsFactory;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.fn.IdGenerator;\n+import org.apache.beam.sdk.fn.IdGenerators;\n+import org.apache.beam.sdk.state.TimeDomain;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.util.CoderUtils;\n+import org.apache.beam.sdk.util.WindowedValue;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** Utility methods for creating {@link BundleCheckpointHandler}s. */\n+public class BundleCheckpointHandlers {\n+\n+  /**\n+   * A {@link BundleCheckpointHandler} which uses {@link\n+   * org.apache.beam.runners.core.TimerInternals.TimerData} ans {@link\n+   * org.apache.beam.sdk.state.ValueState} to reschedule {@link DelayedBundleApplication}.\n+   */\n+  public static class StateAndTimerBundleCheckpointHandler<T> implements BundleCheckpointHandler {\n+    private static final Logger LOG =\n+        LoggerFactory.getLogger(StateAndTimerBundleCheckpointHandler.class);\n+    private final TimerInternalsFactory<T> timerInternalsFactory;\n+    private final StateInternalsFactory<T> stateInternalsFactory;\n+    private final Coder<WindowedValue<T>> residualCoder;\n+    private final Coder windowCoder;\n+    private final IdGenerator idGenerator = IdGenerators.incrementingLongs();\n+    public static final String SDF_PREFIX = \"sdf_checkpoint\";\n+\n+    public StateAndTimerBundleCheckpointHandler(\n+        TimerInternalsFactory<T> timerInternalsFactory,\n+        StateInternalsFactory<T> stateInternalsFactory,\n+        Coder<WindowedValue<T>> residualCoder,\n+        Coder windowCoder) {\n+      this.residualCoder = residualCoder;\n+      this.windowCoder = windowCoder;\n+      this.timerInternalsFactory = timerInternalsFactory;\n+      this.stateInternalsFactory = stateInternalsFactory;\n+    }\n+\n+    /**\n+     * A helper function to help check whether the given timer is the timer which is set for\n+     * rescheduling {@link DelayedBundleApplication}.\n+     */\n+    public static boolean isSdfTimer(String timerId) {\n+      return timerId.startsWith(SDF_PREFIX);\n+    }\n+\n+    private static String constructSdfCheckpointId(String id, int index) {\n+      return SDF_PREFIX + \":\" + id + \":\" + index;\n+    }\n+\n+    @Override\n+    public void onCheckpoint(ProcessBundleResponse response) {\n+      String id = idGenerator.getId();\n+      for (int index = 0; index < response.getResidualRootsCount(); index++) {\n+        DelayedBundleApplication residual = response.getResidualRoots(index);\n+        if (!residual.hasApplication()) {\n+          continue;\n+        }\n+        String tag = constructSdfCheckpointId(id, index);\n+        try {\n+          WindowedValue<T> stateValue =\n+              CoderUtils.decodeFromByteArray(\n+                  residualCoder, residual.getApplication().getElement().toByteArray());\n+          TimerInternals timerInternals =\n+              timerInternalsFactory.timerInternalsForKey((stateValue.getValue()));\n+          StateInternals stateInternals =\n+              stateInternalsFactory.stateInternalsForKey(stateValue.getValue());\n+          // Calculate the timestamp for the timer.\n+          Instant timestamp = Instant.now();\n+          if (residual.hasRequestedTimeDelay()) {\n+            timestamp = timestamp.plus(residual.getRequestedTimeDelay().getSeconds() * 1000);\n+          }\n+          // Calculate the watermark hold for the timer.\n+          long outputTimestamp = BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis();\n+          if (!residual.getApplication().getOutputWatermarksMap().isEmpty()) {\n+            for (org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp outputWatermark :\n+                residual.getApplication().getOutputWatermarksMap().values()) {\n+              outputTimestamp = Math.min(outputTimestamp, outputWatermark.getSeconds() * 1000);\n+            }\n+          } else {\n+            outputTimestamp = BoundedWindow.TIMESTAMP_MIN_VALUE.getMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "607b444d20e0cd66a25e48a19ac8260d1e7b3ecd"}, "originalPosition": 112}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwOTQ2MDQz", "url": "https://github.com/apache/beam/pull/13105#pullrequestreview-520946043", "createdAt": "2020-10-30T18:48:20Z", "commit": {"oid": "96d57c29b6bf1d36f41a146521710b4ec59164d8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODo0ODoyMFrOHrcA8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODo0ODoyMFrOHrcA8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwOTgwOA==", "bodyText": "This shouldn't be necessary. All timers will be drained on close(), at least in super.close().", "url": "https://github.com/apache/beam/pull/13105#discussion_r515309808", "createdAt": "2020-10-30T18:48:20Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java", "diffHunk": "@@ -502,6 +690,8 @@ public void close() throws Exception {\n     processWatermark1(Watermark.MAX_WATERMARK);\n     while (getCurrentOutputWatermark() < Watermark.MAX_WATERMARK.getTimestamp()) {\n       invokeFinishBundle();\n+      // Sleep for 5s to wait for any timer to be fired.\n+      Thread.sleep(5000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96d57c29b6bf1d36f41a146521710b4ec59164d8"}, "originalPosition": 266}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2MTQwNDMy", "url": "https://github.com/apache/beam/pull/13105#pullrequestreview-526140432", "createdAt": "2020-11-09T11:00:31Z", "commit": {"oid": "d8bb778e64fc591819a90677a9f2e119e706b52f"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMTowMDozMVrOHvpWnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMTowMDozMVrOHvpWnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTcyMjY1Mg==", "bodyText": "Perhaps add a TODO here, since we may want to eventually get rid of the sleep?", "url": "https://github.com/apache/beam/pull/13105#discussion_r519722652", "createdAt": "2020-11-09T11:00:31Z", "author": {"login": "mxm"}, "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java", "diffHunk": "@@ -502,6 +692,10 @@ public void close() throws Exception {\n     processWatermark1(Watermark.MAX_WATERMARK);\n     while (getCurrentOutputWatermark() < Watermark.MAX_WATERMARK.getTimestamp()) {\n       invokeFinishBundle();\n+      if (hasSdfProcessFn) {\n+        // Sleep for 5s to wait for any SDF timer to be fired.\n+        Thread.sleep(5000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8bb778e64fc591819a90677a9f2e119e706b52f"}, "originalPosition": 276}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d8bb778e64fc591819a90677a9f2e119e706b52f", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/d8bb778e64fc591819a90677a9f2e119e706b52f", "committedDate": "2020-11-04T20:51:06Z", "message": "Only free occupation in close() when we know we are processing SDF."}, "afterCommit": {"oid": "0ba5b74dc2d0f76bc12c9d575ee43380f87d821e", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/0ba5b74dc2d0f76bc12c9d575ee43380f87d821e", "committedDate": "2020-11-09T20:26:03Z", "message": "Add sdf initiated checkpoint support to portable Flink."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0ba5b74dc2d0f76bc12c9d575ee43380f87d821e", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/0ba5b74dc2d0f76bc12c9d575ee43380f87d821e", "committedDate": "2020-11-09T20:26:03Z", "message": "Add sdf initiated checkpoint support to portable Flink."}, "afterCommit": {"oid": "1096d391c368d0692545cf66e22c286d24af40fc", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/1096d391c368d0692545cf66e22c286d24af40fc", "committedDate": "2020-11-09T21:59:50Z", "message": "Add sdf initiated checkpoint support to portable Flink."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28914c2679feaae8bf00955229f64bb46d3970cd", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/28914c2679feaae8bf00955229f64bb46d3970cd", "committedDate": "2020-11-11T19:31:01Z", "message": "Add sdf initiated checkpoint support to portable Flink."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "56a004dd8fd9bb7c52fb56e0f53cd0dc7f8b1dfa", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/56a004dd8fd9bb7c52fb56e0f53cd0dc7f8b1dfa", "committedDate": "2020-11-11T00:52:04Z", "message": "Drain sdf processing timers during Operator.close()"}, "afterCommit": {"oid": "28914c2679feaae8bf00955229f64bb46d3970cd", "author": {"user": null}, "url": "https://github.com/apache/beam/commit/28914c2679feaae8bf00955229f64bb46d3970cd", "committedDate": "2020-11-11T19:31:01Z", "message": "Add sdf initiated checkpoint support to portable Flink."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2020, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}