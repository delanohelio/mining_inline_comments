{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4ODQ2NDc4", "number": 11728, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMjoyMzoxM1rOD9B_Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMjo0ODozMVrOD9CPCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzIyMjUxOnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/io/synthetic/step.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMjoyMzoxM1rOGWVX2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwMToyODoxN1rOGWXUbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3MjAyNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tsplits = append(splits, rest)\n          \n          \n            \n            \t\treturn splits\n          \n          \n            \n            \t\treturn append(splits, rest)", "url": "https://github.com/apache/beam/pull/11728#discussion_r426072025", "createdAt": "2020-05-15T22:23:13Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/step.go", "diffHunk": "@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Step creates a synthetic step transform that receives KV<[]byte, []byte>\n+// elements from other synthetic transforms, and outputs KV<[]byte, []byte>\n+// elements based on its inputs.\n+//\n+// This function accepts a StepConfig to configure the behavior of the synthetic\n+// step, including whether that step is implemented as a splittable or\n+// non-splittable DoFn.\n+//\n+// StepConfigs are recommended to be created via the DefaultStepConfig and\n+// modified before being passed to this method. Example:\n+//\n+//    cfg := synthetic.DefaultStepConfig()\n+//    cfg.OutputPerInput = 1000\n+//    cfg.Splittable = true\n+//    cfg.InitialSplits = 2\n+//    step := synthetic.Step(s, cfg, input)\n+func Step(s beam.Scope, cfg StepConfig, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Step\")\n+\tif cfg.Splittable {\n+\t\treturn beam.ParDo(s, &sdfStepFn{cfg: cfg}, col)\n+\t} else {\n+\t\treturn beam.ParDo(s, &stepFn{cfg: cfg}, col)\n+\t}\n+}\n+\n+// stepFn is a DoFn implementing behavior for synthetic steps. For usage\n+// information, see synthetic.Step.\n+//\n+// The stepFn is expected to be initialized with a cfg and will follow that\n+// config to determine its behavior when emitting elements.\n+type stepFn struct {\n+\tcfg StepConfig\n+\trng randWrapper\n+}\n+\n+// Setup sets up the random number generator.\n+func (fn *stepFn) Setup() {\n+\tfn.rng = rand.New(rand.NewSource(time.Now().UnixNano()))\n+}\n+\n+// ProcessElement takes an input and either filters it or produces a number of\n+// outputs identical to that input based on the outputs per input configuration\n+// in StepConfig.\n+func (fn *stepFn) ProcessElement(key, val []byte, emit func([]byte, []byte)) {\n+\tif fn.cfg.FilterRatio > 0 && fn.rng.Float64() < fn.cfg.FilterRatio {\n+\t\treturn\n+\t}\n+\tfor i := 0; i < fn.cfg.OutputPerInput; i++ {\n+\t\temit(key, val)\n+\t}\n+}\n+\n+// sdfStepFn is a splittable DoFn implementing behavior for synthetic steps.\n+// For usage information, see synthetic.Step.\n+//\n+// The sdfStepFn is expected to be initialized with a cfg and will follow\n+// that config to determine its behavior when splitting and emitting elements.\n+type sdfStepFn struct {\n+\tcfg StepConfig\n+\trng randWrapper\n+}\n+\n+// CreateInitialRestriction creates an offset range restriction representing\n+// the number of elements to emit for this received element, as specified by\n+// the output per input configuration in StepConfig.\n+func (fn *sdfStepFn) CreateInitialRestriction(key, val []byte) offsetrange.Restriction {\n+\treturn offsetrange.Restriction{\n+\t\tStart: 0,\n+\t\tEnd:   int64(fn.cfg.OutputPerInput),\n+\t}\n+}\n+\n+// SplitRestriction splits restrictions equally according to the number of\n+// initial splits specified in StepConfig. Each restriction output by this\n+// method will contain at least one element, so the number of splits will not\n+// exceed the number of elements.\n+func (fn *sdfStepFn) SplitRestriction(key, val []byte, rest offsetrange.Restriction) (splits []offsetrange.Restriction) {\n+\tif fn.cfg.InitialSplits <= 1 {\n+\t\t// Don't split, just return original restriction.\n+\t\tsplits = append(splits, rest)\n+\t\treturn splits", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af7039c4fd76a0e6a1dd7dc78fa0965ee1ccd57b"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEwMzkxNg==", "bodyText": "Done.", "url": "https://github.com/apache/beam/pull/11728#discussion_r426103916", "createdAt": "2020-05-16T01:28:17Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/io/synthetic/step.go", "diffHunk": "@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Step creates a synthetic step transform that receives KV<[]byte, []byte>\n+// elements from other synthetic transforms, and outputs KV<[]byte, []byte>\n+// elements based on its inputs.\n+//\n+// This function accepts a StepConfig to configure the behavior of the synthetic\n+// step, including whether that step is implemented as a splittable or\n+// non-splittable DoFn.\n+//\n+// StepConfigs are recommended to be created via the DefaultStepConfig and\n+// modified before being passed to this method. Example:\n+//\n+//    cfg := synthetic.DefaultStepConfig()\n+//    cfg.OutputPerInput = 1000\n+//    cfg.Splittable = true\n+//    cfg.InitialSplits = 2\n+//    step := synthetic.Step(s, cfg, input)\n+func Step(s beam.Scope, cfg StepConfig, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Step\")\n+\tif cfg.Splittable {\n+\t\treturn beam.ParDo(s, &sdfStepFn{cfg: cfg}, col)\n+\t} else {\n+\t\treturn beam.ParDo(s, &stepFn{cfg: cfg}, col)\n+\t}\n+}\n+\n+// stepFn is a DoFn implementing behavior for synthetic steps. For usage\n+// information, see synthetic.Step.\n+//\n+// The stepFn is expected to be initialized with a cfg and will follow that\n+// config to determine its behavior when emitting elements.\n+type stepFn struct {\n+\tcfg StepConfig\n+\trng randWrapper\n+}\n+\n+// Setup sets up the random number generator.\n+func (fn *stepFn) Setup() {\n+\tfn.rng = rand.New(rand.NewSource(time.Now().UnixNano()))\n+}\n+\n+// ProcessElement takes an input and either filters it or produces a number of\n+// outputs identical to that input based on the outputs per input configuration\n+// in StepConfig.\n+func (fn *stepFn) ProcessElement(key, val []byte, emit func([]byte, []byte)) {\n+\tif fn.cfg.FilterRatio > 0 && fn.rng.Float64() < fn.cfg.FilterRatio {\n+\t\treturn\n+\t}\n+\tfor i := 0; i < fn.cfg.OutputPerInput; i++ {\n+\t\temit(key, val)\n+\t}\n+}\n+\n+// sdfStepFn is a splittable DoFn implementing behavior for synthetic steps.\n+// For usage information, see synthetic.Step.\n+//\n+// The sdfStepFn is expected to be initialized with a cfg and will follow\n+// that config to determine its behavior when splitting and emitting elements.\n+type sdfStepFn struct {\n+\tcfg StepConfig\n+\trng randWrapper\n+}\n+\n+// CreateInitialRestriction creates an offset range restriction representing\n+// the number of elements to emit for this received element, as specified by\n+// the output per input configuration in StepConfig.\n+func (fn *sdfStepFn) CreateInitialRestriction(key, val []byte) offsetrange.Restriction {\n+\treturn offsetrange.Restriction{\n+\t\tStart: 0,\n+\t\tEnd:   int64(fn.cfg.OutputPerInput),\n+\t}\n+}\n+\n+// SplitRestriction splits restrictions equally according to the number of\n+// initial splits specified in StepConfig. Each restriction output by this\n+// method will contain at least one element, so the number of splits will not\n+// exceed the number of elements.\n+func (fn *sdfStepFn) SplitRestriction(key, val []byte, rest offsetrange.Restriction) (splits []offsetrange.Restriction) {\n+\tif fn.cfg.InitialSplits <= 1 {\n+\t\t// Don't split, just return original restriction.\n+\t\tsplits = append(splits, rest)\n+\t\treturn splits", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3MjAyNQ=="}, "originalCommit": {"oid": "af7039c4fd76a0e6a1dd7dc78fa0965ee1ccd57b"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzI2MzQ2OnYy", "diffSide": "RIGHT", "path": "sdks/go/pkg/beam/io/synthetic/step.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMjo0ODozMVrOGWVw2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwMTozNzowM1rOGWXXdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3ODQyNQ==", "bodyText": "Comment cuts out.", "url": "https://github.com/apache/beam/pull/11728#discussion_r426078425", "createdAt": "2020-05-15T22:48:31Z", "author": {"login": "lostluck"}, "path": "sdks/go/pkg/beam/io/synthetic/step.go", "diffHunk": "@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Step creates a synthetic step transform that receives KV<[]byte, []byte>\n+// elements from other synthetic transforms, and outputs KV<[]byte, []byte>\n+// elements based on its inputs.\n+//\n+// This function accepts a StepConfig to configure the behavior of the synthetic\n+// step, including whether that step is implemented as a splittable or\n+// non-splittable DoFn.\n+//\n+// StepConfigs are recommended to be created via the DefaultStepConfig and\n+// modified before being passed to this method. Example:\n+//\n+//    cfg := synthetic.DefaultStepConfig()\n+//    cfg.OutputPerInput = 1000\n+//    cfg.Splittable = true\n+//    cfg.InitialSplits = 2\n+//    step := synthetic.Step(s, cfg, input)\n+func Step(s beam.Scope, cfg StepConfig, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Step\")\n+\tif cfg.Splittable {\n+\t\treturn beam.ParDo(s, &sdfStepFn{cfg: cfg}, col)\n+\t} else {\n+\t\treturn beam.ParDo(s, &stepFn{cfg: cfg}, col)\n+\t}\n+}\n+\n+// stepFn is a DoFn implementing behavior for synthetic steps. For usage\n+// information, see synthetic.Step.\n+//\n+// The stepFn is expected to be initialized with a cfg and will follow that\n+// config to determine its behavior when emitting elements.\n+type stepFn struct {\n+\tcfg StepConfig\n+\trng randWrapper\n+}\n+\n+// Setup sets up the random number generator.\n+func (fn *stepFn) Setup() {\n+\tfn.rng = rand.New(rand.NewSource(time.Now().UnixNano()))\n+}\n+\n+// ProcessElement takes an input and either filters it or produces a number of\n+// outputs identical to that input based on the outputs per input configuration\n+// in StepConfig.\n+func (fn *stepFn) ProcessElement(key, val []byte, emit func([]byte, []byte)) {\n+\tif fn.cfg.FilterRatio > 0 && fn.rng.Float64() < fn.cfg.FilterRatio {\n+\t\treturn\n+\t}\n+\tfor i := 0; i < fn.cfg.OutputPerInput; i++ {\n+\t\temit(key, val)\n+\t}\n+}\n+\n+// sdfStepFn is a splittable DoFn implementing behavior for synthetic steps.\n+// For usage information, see synthetic.Step.\n+//\n+// The sdfStepFn is expected to be initialized with a cfg and will follow\n+// that config to determine its behavior when splitting and emitting elements.\n+type sdfStepFn struct {\n+\tcfg StepConfig\n+\trng randWrapper\n+}\n+\n+// CreateInitialRestriction creates an offset range restriction representing\n+// the number of elements to emit for this received element, as specified by\n+// the output per input configuration in StepConfig.\n+func (fn *sdfStepFn) CreateInitialRestriction(key, val []byte) offsetrange.Restriction {\n+\treturn offsetrange.Restriction{\n+\t\tStart: 0,\n+\t\tEnd:   int64(fn.cfg.OutputPerInput),\n+\t}\n+}\n+\n+// SplitRestriction splits restrictions equally according to the number of\n+// initial splits specified in StepConfig. Each restriction output by this\n+// method will contain at least one element, so the number of splits will not\n+// exceed the number of elements.\n+func (fn *sdfStepFn) SplitRestriction(key, val []byte, rest offsetrange.Restriction) (splits []offsetrange.Restriction) {\n+\tif fn.cfg.InitialSplits <= 1 {\n+\t\t// Don't split, just return original restriction.\n+\t\tsplits = append(splits, rest)\n+\t\treturn splits\n+\t}\n+\n+\t// TODO(BEAM-9978) Move this implementation of the offset range restriction\n+\t// splitting to the restriction itself, and add testing.\n+\tnum := int64(fn.cfg.InitialSplits)\n+\toffset := rest.Start\n+\tsize := rest.End - rest.Start\n+\tfor i := int64(0); i < num; i++ {\n+\t\tsplit := offsetrange.Restriction{\n+\t\t\tStart: offset + (i * size / num),\n+\t\t\tEnd:   offset + ((i + 1) * size / num),\n+\t\t}\n+\t\t// Skip restrictions that end up empty.\n+\t\tif split.End-split.Start <= 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tsplits = append(splits, split)\n+\t}\n+\treturn splits\n+}\n+\n+// RestrictionSize outputs the size of the restriction as the number of elements\n+// that restriction will output.\n+func (fn *sdfStepFn) RestrictionSize(key, val []byte, rest offsetrange.Restriction) float64 {\n+\t// TODO(BEAM-9978) Move this size implementation to the offset range restriction itself.\n+\treturn float64(rest.End - rest.Start)\n+}\n+\n+// CreateTracker creates an offset range restriction tracker for the\n+// restriction.\n+func (fn *sdfStepFn) CreateTracker(rest offsetrange.Restriction) *offsetrange.Tracker {\n+\treturn offsetrange.NewTracker(rest)\n+}\n+\n+// Setup sets up the random number generator.\n+func (fn *sdfStepFn) Setup() {\n+\tfn.rng = rand.New(rand.NewSource(time.Now().UnixNano()))\n+}\n+\n+// ProcessElement takes an input and either filters it or produces a number of\n+// outputs identical to that input based on the restriction size.\n+func (fn *sdfStepFn) ProcessElement(rt *offsetrange.Tracker, key, val []byte, emit func([]byte, []byte)) {\n+\tif fn.cfg.FilterRatio > 0 && fn.rng.Float64() < fn.cfg.FilterRatio {\n+\t\treturn\n+\t}\n+\tfor i := rt.Rest.Start; rt.TryClaim(i) == true; i++ {\n+\t\temit(key, val)\n+\t}\n+}\n+\n+// DefaultSourceConfig creates a SourceConfig with intended defaults for its\n+// fields. SourceConfigs should be initialized with this method.\n+func DefaultStepConfig() StepConfig {\n+\treturn StepConfig{\n+\t\tOutputPerInput: 1,     // Defaults shouldn't drop elements, so at least 1.\n+\t\tFilterRatio:    0.0,   // Defaults shouldn't drop elements, so don't filter.\n+\t\tSplittable:     false, // Default to non-splittable, SDFs are situational.\n+\t\tInitialSplits:  1,     // Defaults to 1, i.e. no initial splitting.\n+\t}\n+}\n+\n+// StepConfig is a struct containing all the configuration options for a\n+// synthetic step.\n+type StepConfig struct {\n+\t// OutputPerInput is the number of outputs to emit per input received. Each\n+\t// output is identical to the original input. A value of 0 drops each input.\n+\tOutputPerInput int\n+\n+\t// FilterRatio indicates the random chance that an input will be filtered\n+\t// out, meaning that no outputs will get emitted for it. For example, a\n+\t// FilterRatio of 0.25 means that 25% of inputs will get filtered out.\n+\tFilterRatio float64\n+\n+\t// Splittable indicates whether the step should use the splittable DoFn or\n+\t// non-splittable DoFn implementation. When a splittable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af7039c4fd76a0e6a1dd7dc78fa0965ee1ccd57b"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEwNDY5NA==", "bodyText": "Whoops, fixed.", "url": "https://github.com/apache/beam/pull/11728#discussion_r426104694", "createdAt": "2020-05-16T01:37:03Z", "author": {"login": "youngoli"}, "path": "sdks/go/pkg/beam/io/synthetic/step.go", "diffHunk": "@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Step creates a synthetic step transform that receives KV<[]byte, []byte>\n+// elements from other synthetic transforms, and outputs KV<[]byte, []byte>\n+// elements based on its inputs.\n+//\n+// This function accepts a StepConfig to configure the behavior of the synthetic\n+// step, including whether that step is implemented as a splittable or\n+// non-splittable DoFn.\n+//\n+// StepConfigs are recommended to be created via the DefaultStepConfig and\n+// modified before being passed to this method. Example:\n+//\n+//    cfg := synthetic.DefaultStepConfig()\n+//    cfg.OutputPerInput = 1000\n+//    cfg.Splittable = true\n+//    cfg.InitialSplits = 2\n+//    step := synthetic.Step(s, cfg, input)\n+func Step(s beam.Scope, cfg StepConfig, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Step\")\n+\tif cfg.Splittable {\n+\t\treturn beam.ParDo(s, &sdfStepFn{cfg: cfg}, col)\n+\t} else {\n+\t\treturn beam.ParDo(s, &stepFn{cfg: cfg}, col)\n+\t}\n+}\n+\n+// stepFn is a DoFn implementing behavior for synthetic steps. For usage\n+// information, see synthetic.Step.\n+//\n+// The stepFn is expected to be initialized with a cfg and will follow that\n+// config to determine its behavior when emitting elements.\n+type stepFn struct {\n+\tcfg StepConfig\n+\trng randWrapper\n+}\n+\n+// Setup sets up the random number generator.\n+func (fn *stepFn) Setup() {\n+\tfn.rng = rand.New(rand.NewSource(time.Now().UnixNano()))\n+}\n+\n+// ProcessElement takes an input and either filters it or produces a number of\n+// outputs identical to that input based on the outputs per input configuration\n+// in StepConfig.\n+func (fn *stepFn) ProcessElement(key, val []byte, emit func([]byte, []byte)) {\n+\tif fn.cfg.FilterRatio > 0 && fn.rng.Float64() < fn.cfg.FilterRatio {\n+\t\treturn\n+\t}\n+\tfor i := 0; i < fn.cfg.OutputPerInput; i++ {\n+\t\temit(key, val)\n+\t}\n+}\n+\n+// sdfStepFn is a splittable DoFn implementing behavior for synthetic steps.\n+// For usage information, see synthetic.Step.\n+//\n+// The sdfStepFn is expected to be initialized with a cfg and will follow\n+// that config to determine its behavior when splitting and emitting elements.\n+type sdfStepFn struct {\n+\tcfg StepConfig\n+\trng randWrapper\n+}\n+\n+// CreateInitialRestriction creates an offset range restriction representing\n+// the number of elements to emit for this received element, as specified by\n+// the output per input configuration in StepConfig.\n+func (fn *sdfStepFn) CreateInitialRestriction(key, val []byte) offsetrange.Restriction {\n+\treturn offsetrange.Restriction{\n+\t\tStart: 0,\n+\t\tEnd:   int64(fn.cfg.OutputPerInput),\n+\t}\n+}\n+\n+// SplitRestriction splits restrictions equally according to the number of\n+// initial splits specified in StepConfig. Each restriction output by this\n+// method will contain at least one element, so the number of splits will not\n+// exceed the number of elements.\n+func (fn *sdfStepFn) SplitRestriction(key, val []byte, rest offsetrange.Restriction) (splits []offsetrange.Restriction) {\n+\tif fn.cfg.InitialSplits <= 1 {\n+\t\t// Don't split, just return original restriction.\n+\t\tsplits = append(splits, rest)\n+\t\treturn splits\n+\t}\n+\n+\t// TODO(BEAM-9978) Move this implementation of the offset range restriction\n+\t// splitting to the restriction itself, and add testing.\n+\tnum := int64(fn.cfg.InitialSplits)\n+\toffset := rest.Start\n+\tsize := rest.End - rest.Start\n+\tfor i := int64(0); i < num; i++ {\n+\t\tsplit := offsetrange.Restriction{\n+\t\t\tStart: offset + (i * size / num),\n+\t\t\tEnd:   offset + ((i + 1) * size / num),\n+\t\t}\n+\t\t// Skip restrictions that end up empty.\n+\t\tif split.End-split.Start <= 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tsplits = append(splits, split)\n+\t}\n+\treturn splits\n+}\n+\n+// RestrictionSize outputs the size of the restriction as the number of elements\n+// that restriction will output.\n+func (fn *sdfStepFn) RestrictionSize(key, val []byte, rest offsetrange.Restriction) float64 {\n+\t// TODO(BEAM-9978) Move this size implementation to the offset range restriction itself.\n+\treturn float64(rest.End - rest.Start)\n+}\n+\n+// CreateTracker creates an offset range restriction tracker for the\n+// restriction.\n+func (fn *sdfStepFn) CreateTracker(rest offsetrange.Restriction) *offsetrange.Tracker {\n+\treturn offsetrange.NewTracker(rest)\n+}\n+\n+// Setup sets up the random number generator.\n+func (fn *sdfStepFn) Setup() {\n+\tfn.rng = rand.New(rand.NewSource(time.Now().UnixNano()))\n+}\n+\n+// ProcessElement takes an input and either filters it or produces a number of\n+// outputs identical to that input based on the restriction size.\n+func (fn *sdfStepFn) ProcessElement(rt *offsetrange.Tracker, key, val []byte, emit func([]byte, []byte)) {\n+\tif fn.cfg.FilterRatio > 0 && fn.rng.Float64() < fn.cfg.FilterRatio {\n+\t\treturn\n+\t}\n+\tfor i := rt.Rest.Start; rt.TryClaim(i) == true; i++ {\n+\t\temit(key, val)\n+\t}\n+}\n+\n+// DefaultSourceConfig creates a SourceConfig with intended defaults for its\n+// fields. SourceConfigs should be initialized with this method.\n+func DefaultStepConfig() StepConfig {\n+\treturn StepConfig{\n+\t\tOutputPerInput: 1,     // Defaults shouldn't drop elements, so at least 1.\n+\t\tFilterRatio:    0.0,   // Defaults shouldn't drop elements, so don't filter.\n+\t\tSplittable:     false, // Default to non-splittable, SDFs are situational.\n+\t\tInitialSplits:  1,     // Defaults to 1, i.e. no initial splitting.\n+\t}\n+}\n+\n+// StepConfig is a struct containing all the configuration options for a\n+// synthetic step.\n+type StepConfig struct {\n+\t// OutputPerInput is the number of outputs to emit per input received. Each\n+\t// output is identical to the original input. A value of 0 drops each input.\n+\tOutputPerInput int\n+\n+\t// FilterRatio indicates the random chance that an input will be filtered\n+\t// out, meaning that no outputs will get emitted for it. For example, a\n+\t// FilterRatio of 0.25 means that 25% of inputs will get filtered out.\n+\tFilterRatio float64\n+\n+\t// Splittable indicates whether the step should use the splittable DoFn or\n+\t// non-splittable DoFn implementation. When a splittable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3ODQyNQ=="}, "originalCommit": {"oid": "af7039c4fd76a0e6a1dd7dc78fa0965ee1ccd57b"}, "originalPosition": 180}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3778, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}